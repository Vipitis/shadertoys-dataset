{"id": "4dSXzR", "name": "[NV15]space voyage", "author": "antonOTI", "description": "I let us go to the stars\n[Edit] After quite some time I've discovered that it was inspired by the game out there (I'm not as creative as I'd like to think)", "tags": ["2d", "parallax", "noob", "nv15"], "likes": 6, "viewed": 1441, "published": "Public API", "date": "1426758026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n* - todo:\n* - Better paralax\n* - Better ship\n*/\n\nvec4 stars(in vec2 p)\n{\n    vec4 col = vec4(0.,0.,.1,1.);\n    col += mix(vec4(0.),vec4(1.),step(texture(iChannel0,(p*1.2) + vec2(iTime*.4,.0)*.005).r,.026));\n    col += mix(vec4(0.),vec4(1.),step(texture(iChannel0,(p*1.56)* vec2(.5,1.) + vec2(iTime*.1,.0)).r,.025));\n    float f = .2;\n    vec4 shifted = vec4(1.- f*p.x,0.99,1. - f*(1. -p.x),1.);\n    col += mix(vec4(0.),shifted,step(texture(iChannel0,(p*1.36) * vec2(.025,1.) + vec2(iTime*.3,.0)).r,.075));\n\treturn col;\n}\n\nfloat rectangle(vec2 p,vec2 dim,vec2 center,float a)\n{\n\tp.x -= center.x;\n\tp.y -= center.y;\n\tfloat x =  p.x *cos(a) - p.y* sin( a) ;\n\tfloat y = p.y *cos(a) + p.x *sin(a) ;\n\treturn step(-dim.x/2.,x)*step(x,dim.x/2.)*step(-dim.y/2.,y)*step(y,dim.y/2.);\n}\n\nfloat logo(in vec2 uv)\n{\n    uv = uv * iResolution.xy / iResolution.x;\n \tfloat f = step(distance(uv ,vec2(.5,.5)),.1); \n    f -= step(distance(uv ,vec2(.55,.47)),.05);\n    f -= step(distance(uv ,vec2(.5,.5)),.09)*.05;\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec4 col = stars(uv) ;\n    \n    \n    \n    \n    //oscillation\n    uv = (uv-vec2(.25)) * ((cos(iTime * .5)*.5+.5)*.25 +.95) + vec2(.25);\n    uv.y += sin(iTime)*.05;\n    \n    //shake\n    uv += (texture(iChannel0,vec2(0.,iTime)).xy - vec2(.5)) *.02 * (sin(iTime)*.5+1.);\n    \n    \n    float t = iTime * 2.09439333;\n    vec2 bp  = uv - vec2(.5,.26);\n    bp *= vec2(.2 ,(7.5 + uv.x*10.5) *1.6);\n    float r = (1.-distance(bp,vec2(cos(t*-9.),sin(t*.3))*.05))*1.25;\n    t += 2.0943;\n    float g = (1.-distance(bp,vec2(cos(t*-3. ),sin(t + bp.x*4.))*0.05))*1.25;\n    t += 2.0943;\n    float b = (1.-distance(bp,vec2(cos(t),-sin(t*4.8))*.05 ))*1.25;\n    vec4 beam = vec4(r,g,b,1.);\n    beam *= step(.18,uv.y)*step(uv.y,.34) * step(uv.x,.3);\n    \n    col += beam;\n    \n    //engin\n    col = mix(col,vec4(1.-length(uv.y *8. - 2.4)),rectangle(uv + vec2(uv.y * .4,0.),vec2(.1),vec2(.235,.29),0.));\n    col = mix(col,vec4(1.-length(uv.y *8. - 1.0)),rectangle(uv + vec2(uv.y * .4,0.),vec2(.1),vec2(.23,.24),0.));\n    col = mix(col,vec4(1.-length(uv.y *8. - 1.9)),rectangle(uv + vec2(uv.y * .4,0.),vec2(.1),vec2(.22,.27),0.));\n    //back wings\n    col = mix(col,vec4(.25),rectangle(uv + vec2(uv.y * -.3,0.),vec2(.12),vec2(.18,.14),0.));\n    col = mix(col,vec4(.25),rectangle(uv + vec2(uv.y * -.3,0.),vec2(.05,.04),vec2(.53,.21),0.));\n    col = mix(col,vec4(.37),rectangle(uv + vec2(uv.y * .5,0.),vec2(.19,.20),vec2(.40,.41),0.));\n    col = mix(col,vec4(.15),rectangle(uv + vec2(uv.y * .5,0.),vec2(.16,.17),vec2(.40,.41),0.));\n    //main body\n    col = mix(col,vec4(.5),rectangle(uv + vec2(uv.y * .4,0.),vec2(.4,.1),vec2(.5,.3),0.));\n    col = mix(col,vec4(.7),rectangle(uv + vec2(uv.y * .4,0.),vec2(.4,.08),vec2(.5,.3),0.));\n    col = mix(col,vec4(.5),rectangle(uv + vec2(uv.y * .4,0.),vec2(.3),vec2(.35,.3),0.));\n    col = mix(col,vec4(.8),rectangle(uv + vec2(uv.y * .4,0.),vec2(.28),vec2(.35,.3),0.));\n    \n    col = mix(col,vec4(.9,.9,.9,1.),rectangle(uv + vec2(uv.y * .4), vec2(.28,.04),vec2(.35,.47),0.));\n    col = mix(col,vec4(.9,.1,.1,1.),rectangle(uv + vec2(uv.y * .4), vec2(.28,.05),vec2(.35,.5),0.));\n    col = mix(col,vec4(.9,.1,.1,1.),rectangle(uv + vec2(uv.y * .4), vec2(.28,.025),vec2(.35,.45),0.));\n    \n    //head\n    col = mix(col,vec4(.5),rectangle(uv + vec2(uv.y * .4,0.),vec2(.18),vec2(.7,.3),0.));\n    col = mix(col,vec4(.9),rectangle(uv + vec2(uv.y * .4,0.),vec2(.16),vec2(.7,.3),0.));\n    float f = sin((uv.x +.4 * uv.y ) * 10. + iTime *10.);\n    f = smoothstep(f,f+.01,.985);\n    col = mix(col,mix(vec4(1.),vec4(.1,.1,.7,0.),f),rectangle(uv + vec2(uv.y * .4,0.),vec2(.07,.06),vec2(.755,.325),0.));\n    //front wing\n    col = mix(col,vec4(.4),rectangle(uv + vec2(uv.y * -.3,0.),vec2(.14),vec2(.20,.14),0.));\n    col = mix(col,vec4(.49),rectangle(uv + vec2(uv.y * -.31,0.),vec2(.115),vec2(.20,.1525),0.));\n    col = mix(col,vec4(.4),rectangle(uv + vec2(uv.y * -.3,0.),vec2(.05,.04),vec2(.54,.20),0.));\n    col = mix(col,vec4(.58),rectangle(uv + vec2(uv.y * -.3,0.),vec2(.04,.03),vec2(.54,.205),0.));\n    \n    col = mix(col,vec4(.1,.4,.1,1.),logo(uv*2.- vec2(uv.y * -.3,0.) + vec2(.08,.25)));\n    col = mix(col,vec4(.4,.4,.1,1.),logo(uv*4.- vec2(uv.y * -.3,0.) - vec2(1.81,.31)));\n    \n\tfragColor = col;\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSXzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 53, 76, 76, 524], [526, 526, 580, 580, 777], [779, 779, 803, 803, 1012], [1014, 1014, 1071, 1071, 4331]], "test": "untested"}
{"id": "4l23RD", "name": "findoff's-sincos", "author": "findoff", "description": "sin cos play", "tags": ["sin"], "likes": 4, "viewed": 121, "published": "Public", "date": "1427317853", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define DO_DISCARD\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float x = (uv.x-0.5);\n    float y = (uv.y-0.5);\n    vec4 tex = texture(iChannel0, uv, 0.);\n    bool do_disort = mod(iTime,10.)<5.;\n    \n    if(do_disort) {\n    \ty *= sin(tex.r+x*60.);\n        x *= 1.+sin(tex.g+y*(40.+sin(iTime*0.25)*20.));\n    } else {\n    \ty *= sin(x*60.);\n        //x *= 1.+sin(y*60.);\n        x *= 1.+sin(y*(40.+sin(iTime*0.25)*20.));\n    }\n    \n    y *= (iResolution.y/iResolution.x);\n    float r;\n    r = (sin(iTime*1.)+1.)/2.;\n    r = sqrt(x*x+y*y)*2./r;\n    float br = r*1.;\n    float e = 0.5;\n    float f = 5.;\n    br = 1./( e+ ((br<e)?(e-br):(br-e)) *f);\n    fragColor = vec4(0.4, 1.0*((sin(iTime*2.)+1.)/2.), 0.9, 1.)*br;\n#if defined(DO_DISCARD)\n    if(br<0.7)\n        fragColor = vec4(0.,0.5,0.,1.);// discard;\n#endif\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l23RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 79, 79, 873]], "test": "untested"}
{"id": "4l23Rh", "name": "Elevated coast", "author": "guil", "description": "Cheap sine noise with derivatives tested with the terrain from IQ's Elevated", "tags": ["3d", "noise", "terrain"], "likes": 129, "viewed": 15997, "published": "Public", "date": "1426934744", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n#define time -iTime\n\n\nfloat dh = 0.;\n\n                                 \nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\nmat2 im2 = mat2(0.8,  -0.6, 0.6,  0.8);\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/3.;\n}\n\nvec3 noised(in vec2 p){//noise with derivatives\n\tfloat res=0.;\n    vec2 dres=vec2(0.);\n    float f=1.;\n    mat2 j=m2;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        float a=p.x+sin(2.*p.y);\n        res+=sin(a);\n        dres+=cos(a)*vec2(1.,2.*cos(2.*p.y))*j;\n        j*=m2*f;\n        \n\t}        \t\n\treturn vec3(res,dres)/3.;\n}\n\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(noise( p*f )+.5)/f;       \n\t    f *=2.;\n        p=im2*p;\n       \n\t}\n\treturn 1.-r*.5;\n}\n\nfloat sea( vec2 p ) \n{\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += (1.-abs(noise( p*f +.9*time)))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.04)*(r-.2*iTime/(.1-f));\n\t}\n\treturn r/4.+.5;\n}\n\n\n\nfloat terrainIq( in vec2 x )//from IQ's Elevated : https://www.shadertoy.com/view/MdX3Rr\n{\n\tvec2  p = x;\n    float a = 0.0;\n    float b = 1.0;\n\tvec2  d = vec2(0.0);\n    for( int i=0; i<6; i++ )\n    {\n        vec3 n = noised(p);\n        d += n.yz;\n        a += b*n.x/(1.0+dot(d,d));\n\t\tb *= 0.5;\n        p = m2*p*2.0;\n    }\n\n\treturn .3*a+.5;\n}\n\nfloat swissTurbulence(vec2 p )//from http://www.decarpentier.nl/scape-procedural-extensions\n{\n     \n    float lacunarity = 2.0;\n    float gain = 0.5;\n    float warp = 0.15;\n    float sum = 0.;\n     float freq = 1.0, amp = 1.0;\n     vec2 dsum = vec2(0.);\n     for(int i=0; i < 7; i++)\n     {\n         vec3 n = noised((p + warp * dsum)*freq);\n         sum += amp * (1. - abs(n.x));\n         dsum += amp * n.yz * -n.x;\n         freq *= lacunarity;\n         amp *= gain * clamp(sum,0.,1.);\n    }\n    return sum/3.;\n}\n\nfloat jordanTurbulence(vec2 p)//from http://www.decarpentier.nl/scape-procedural-extensions\n{\n    \n    \n    float lacunarity = 2.0;\n    float gain1 = 0.8;\n    float gain = 0.5;\n    float warp0 = 0.4;\n    float warp = 0.35;\n    float damp0 = 1.0;\n    float damp = 0.8;\n    float damp_scale = 1.0;\n    vec3 n = noised(p);\n    vec3 n2 = n * n.x;\n    float sum = n2.x;\n    vec2 dsum_warp = warp0*n2.yz;\n    vec2 dsum_damp = damp0*n2.yz;\n\n    float amp = gain1;\n    float freq = lacunarity;\n    float damped_amp = amp * gain;\n\n    for(int i=1; i < 8; i++)\n    {\n        n = noised(p * freq + dsum_warp.xy);\n        n2 = n * n.x;\n        sum += damped_amp * n2.x;\n        dsum_warp += warp * n2.yz;\n        dsum_damp += damp * n2.yz;\n        freq *= lacunarity;\n        amp *= gain;\n        damped_amp = amp * (1.-damp_scale/(1.+dot(dsum_damp,dsum_damp)));\n    }\n    return sum/2.+.5;\n}\n\nfloat rocks(vec2 p){\n   //return jordanTurbulence(p );\n   // return swissTurbulence(p );\n   return terrainIq(p);\n   //return fbmabs(p)*.5+.5;   \n}\n\nfloat map( vec3 p)\n{\n\tfloat d1 =p.y-.1*p.z+.2-rocks(p.xz);\n    float d2 =p.y-.4*sea(p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\t\n       \t\n}\n\nvec3 normalRocks(in vec2 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        .008,\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        .004,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nvec3 sky(in vec2 p)\n{\t\n\t//return sin(vec3(1.7,1.5,1.)+1.8- .9*fbmabs(p*4.-.02*time))+.2;\n    return sin(vec3(1.7,1.5,1)+ .7+ .9*fbmabs(p*4.-.02*time))+.25;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 35.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    \n    p.zx = p.xz;\n    p.z=-p.z;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n   \tvec3 rd = normalize(vec3(p, -2.));\n\tvec3 ro = vec3(0.0, 2.0, -2.+.2*time);\n    vec3 li = normalize(vec3(-2., 2., -4.));\n    ro = transform(ro);\n\trd = transform(rd);\n    \n    \n    \n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        //if(dh<0.)t-=dh;\n        vec3 pos = ro + t * rd;\n        \n        float k=rocks(pos.xz)*2.;\n        \n        vec3 nor = normalRocks(pos.xz);\n        float r = max(dot(nor, li),0.05)/2.;\n        if(dh<0.&&dh>-.02)r+=.5*exp(20.*dh);\n        \n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh<0.02){\n        \tvec3 nor = normalSea(pos.xz);\n        \tnor = reflect(rd, nor);\n            col1+=vec3(0.9,.2,.05)*dh*.4;\n        \tcol1 += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.8);\n        \tcol1 +=.2* sky(nor.xz/(.5+nor.y));\n            \n        }\n\t    col = .1+col1;\n        \n\t}\n    else //sky\n        col = sky(rd.xz*(.1+rd.y));\n    \n   \tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l23Rh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 267, 290, 290, 465], [467, 467, 490, 514, 828], [831, 831, 855, 855, 1017], [1019, 1019, 1041, 1041, 1233], [1237, 1237, 1327, 1327, 1578], [1580, 1580, 1673, 1673, 2092], [2094, 2094, 2187, 2187, 2974], [2976, 2976, 2996, 3064, 3122], [3124, 3124, 3144, 3144, 3279], [3281, 3281, 3310, 3310, 3463], [3465, 3465, 3492, 3492, 3637], [3639, 3639, 3660, 3727, 3796], [3798, 3798, 3835, 3835, 4132], [4134, 4134, 4161, 4161, 4213], [4215, 4215, 4272, 4272, 5278]], "test": "untested"}
{"id": "4l23Rw", "name": "ngWaves0F", "author": "netgrind", "description": "subsystem rainbow", "tags": ["waves", "plasma", "netgrind", "arch"], "likes": 23, "viewed": 1773, "published": "Public API", "date": "1427666879", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float compute(vec2 p, float i){\n    float a = atan(p.y,p.x);\n    float l = length(p);\n    float d = mod(l-i*.5,1.);\n    d-=.5;\n    d = abs(d);\n    d-=sin(d)*.05+.1;\n    d = abs(d);    \n    d/=sin(a*12.+sin(l*l+i*.3)*10.)+2.;    \n    return 1.0-smoothstep(0.,.05, d/max(.15,p.y));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i=  iTime*.75;\n    vec4 c = vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xx*2.-1.;\n    uv.y += 1.;\n    \n    float l = length(uv);\n    float a = atan(uv.y,uv.x);\n    float deg = sin(i)*2.+8.;\n    float j = sin(i)*.3;\n    float d = sin(i*3.1415)*.03;\n    uv*=mat2(sin(a*deg+j-deg)*l,cos(a*deg-deg)*l,-cos(a*deg+j-deg)*l,sin(a*deg-deg)*l);\n    \n    c.r = compute(uv,i);\n    uv.y-=d;\n    c.g = compute(uv,i);\n\tuv.y+=d*2.;\n    c.b = compute(uv,i);\n    \n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l23Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 285], [287, 287, 344, 344, 824]], "test": "untested"}
{"id": "4l23zm", "name": "Moons", "author": "shezard", "description": "test", "tags": ["test"], "likes": 1, "viewed": 173, "published": "Public", "date": "1427739997", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int MAT0 = 0;\nconst int MAT1 = 1;\nconst int MAT2 = 2;\nconst int MAT3 = 3;\n\nfloat noise(in vec2 uv) {\n\treturn sin(1.5*uv.x)*sin(1.5*uv.y);\n}\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\nfloat fbm( vec2 uv ) {\n    float f = 0.0;\n    f += 0.5000*noise(uv); uv = m*uv*2.02;\n    f += 0.2500*noise(uv); uv = m*uv*2.03;\n    f += 0.1250*noise(uv); uv = m*uv*2.01;\n    f += 0.0625*noise(uv);\n    return f/0.9375;\n}\n\nfloat fbm2( in vec2 uv ){\n   vec2 p = vec2( fbm( uv + vec2(0.0,0.0) ),\n                  fbm( uv + vec2(5.2,1.3) ) );\n\n   return fbm( uv + 4.0*p );\n}\n\nfloat rand(in vec2 uv){\n    return fract(sin(dot(uv.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 rep(vec3 p, vec3 c) {\n    vec3 q = mod(p,c)-0.5*c;\n    return q;\n}\n\nvec2 rotate(vec2 p, float ang) {\n    float c = cos(ang), s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\nvec2 torus(vec3 p, vec2 t, int mat) {\n    \n  t = vec2(1.5,0.3);\n    \n  vec2 q = vec2(length(p.xz)-t.x,p.y*8.0)-vec2(0.1);\n  return vec2(length(q)-t.y, mat);\n}\n\nvec2 sphere(in vec3 p, float r, int mat) {\n    return vec2(length(p) - r, mat);\n}\n\nvec2 add(in vec2 a, in vec2 b) {\n \n    int mat = 0;\n    if(a.x < b.x) {\n      mat = int(a.y);\n    } else {\n      mat = int(b.y);\n    }\n    \n    return vec2(min(a.x,b.x), mat);\n}\n\nfloat map(in vec3 p, inout int mat) {\n   \n   vec2 scene = vec2(999.0, MAT0);\n    \n   vec3 meteorP = vec3(p.x - mod(iTime,12.0)+6.0,\n                       p.y + 2.0,\n                       p.z);\n    \n   float distorsion = .1 + 0.05*fbm(p.yz*24.0);\n   vec2 meteor = sphere(meteorP, distorsion, MAT3);\n    \n   scene = add(scene, meteor);\n    \n   p.xy = rotate(p.xy,.075);\n   p.yz = rotate(p.yz,-.05);\n    \n   p.xz = rotate(p.xz,iTime*.35);\n\n   vec2 planet = sphere(p, 1.0, MAT0);\n  \n   vec2 ring = torus(p,vec2(1.5,0.1), MAT3);\n    \n   vec2 moon = sphere(p-vec3(1.7,1.0,0.0),0.2, MAT2);\n \n    \n   scene = add(scene, planet);\n   scene = add(scene, ring);\n   scene = add(scene, moon);\n    \n   mat = int(scene.y);\n    \n   return scene.x;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // Approximation de la correction de fov\n    //p.x /= cos(p.y*1.1);\n    //p.y /= cos(p.y*1.1);\n    \n    vec3 ro = vec3(0.0,0.0,3);\n    vec3 rd = normalize(vec3(p,-1.0));\n    \n    float h = 0.001;\n    float tmax = 20.0;\n    float t = 1.0;\n    \n    int mat = MAT0;\n    \n    vec3 c = vec3(.3,.1,.1);\n    vec3 ao = vec3(0.0);\n    \n    for(int i = 0 ; i < 100 ; i++) {\n        \n        if(h < 0.001 || t > tmax ) {\n        \tao = vec3(1.0) - float(i)/100.0;\n            break;\n        }\n        \n        h = map(ro + t *rd, mat);\n        t += h;\n    }\n    \n    if(t<tmax) {\n      \t\n        vec3 pos = ro+rd*t;\n        \n        vec2 r = vec2(0.00001,0.0);\n        vec3 nor = normalize(vec3(map(pos+r.xyy, mat)-map(pos-r.xyy, mat),\n                                  map(pos+r.yxy, mat)-map(pos-r.yxy, mat),\n                                  map(pos+r.yyx, mat)-map(pos-r.yyx, mat)));\n      \t\n        if(mat == MAT0) {\n          c = vec3(.85, .15, .15) + fbm2(vec2(pos.x-iTime*.125,pos.y));\n        } else if(mat == MAT1) {\n          c = vec3(.85, .15, .15) + fbm2(vec2(sin(pos.x-iTime*.125),cos(pos.x-iTime*.125)));\n        } else if(mat == MAT2) {\n          c = vec3(.40,.60,.20) + fbm2(vec2(pos.x+iTime*0.125,pos.y));\n        } else if(mat == MAT3) {\n          c = vec3(.80,.40,.20) * pos.y + fbm2(vec2(pos))*0.1;\n        }\n        \n        vec3 lat = vec3(0.5773);\n        \n        c *= clamp(dot(nor,lat), 0.0, 1.0);\n        c += vec3(.2,.3,.2) * clamp(dot(-nor.zyx,lat), 0.0, .4);;\n\n        c += ao * .05;\n        \n    } else {\n        c = vec3(.2,.3,.5)*fbm2(vec2(p.x+iTime*.125,p.y))*pow(rand(p.xy),10.0);\n    }\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l23zm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 106, 106, 145], [198, 198, 220, 220, 418], [420, 420, 445, 445, 569], [571, 571, 594, 594, 666], [668, 668, 694, 694, 739], [741, 741, 773, 773, 860], [862, 862, 899, 899, 1020], [1022, 1022, 1064, 1064, 1103], [1105, 1105, 1137, 1137, 1282], [1284, 1284, 1321, 1321, 2018], [2020, 2020, 2077, 2077, 3842]], "test": "untested"}
{"id": "4l2Gzh", "name": "I Cannot Self Terminate", "author": "jameswilddev", "description": "AKA False Volumetrics IV.  Experimenting with infinite decay falloff rather than radiuses + occluders.  Currently has some issues with light clipping when near the camera.  Needs some cleanup as there's the remnants of a lot of experimentation in there.", "tags": ["fake", "lava", "false", "volumetrics"], "likes": 9, "viewed": 441, "published": "Public", "date": "1426879956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 sphericalNormal(float yaw, float pitch) {\n\treturn vec3(cos(pitch) * cos(yaw), sin(pitch), sin(pitch) * cos(yaw));\n}\n\nmat3 sphericalMatrix(float yaw, float pitch) {\n\treturn mat3(\n\t\t1.0, 0.0, 0.0,\n\t\t0.0, cos(pitch), -sin(pitch),\n\t\t0.0, sin(pitch), cos(pitch)\n\t)\n\t* mat3(\n\t\tcos(yaw), 0.0, -sin(yaw),\n\t\t0.0, 1.0, 0.0,\n\t\tsin(yaw), 0.0, cos(yaw)\n\t);\n}\n\n// Returns the location of the current fragment relative to the center of the screen, where 0.5 is the distance to the nearest screen border.\n// This will return values > +-0.5 on the X axis in widescreen, and the Y axis in portrait.\nvec2 pixelCoord(vec2 fragCoord) { \n\treturn ((fragCoord - (iResolution.xy / 2.0)) / min(iResolution.x, iResolution.y)); \n}\n\nstruct ray {\n\tvec3 start;\n\tvec3 normal;\n};\n\t\nray lens(vec2 fragCoord) {\n\treturn ray(vec3(0.0, 0.0, -3.0), normalize(vec3(pixelCoord(fragCoord), 0.5)) * sphericalMatrix(sin(iTime * 0.8) * 0.1, sin(iTime * 1.6) * 0.025));\n}\n\n// Returns how long along a ray in world units the nearest point to a given point is.\n// May return negative values.\nfloat along(ray from, vec3 point) {\n\treturn dot(point - from.start, from.normal);\n}\n\t\t\nvec3 nearest(ray from, vec3 point) {\n\treturn from.start + from.normal * along(from, point);\n}\n\nfloat radial(vec3 origin, float rate) {\n\treturn 1.0 / (1.0 + length(origin) * rate);\n}\n\nfloat directional(vec3 origin, vec3 normal, float focus) {\n\treturn pow(max(0.0, dot(normalize(origin), normal)), focus);\n}\n\nfloat hideWhenBehind(float distance) {\n\treturn distance > 0.0 ? distance : 1.0 / 0.0;\n}\n\nstruct plane {\n\tvec3 normal;\n\tfloat distance;\n};\n\nfloat occlusionPlane(ray line, plane surface) {\n    return dot(surface.normal, surface.normal * surface.distance - line.start) / dot(surface.normal, line.normal);\t\n}\n\nstruct sphere {\n\tvec3 origin;\n\tfloat radius;\n};\n\nfloat occlusion(ray from, sphere sphere) {\n\tfloat _along = along(from, sphere.origin);\n\tfloat distance = distance(from.start + from.normal * _along, sphere.origin) / sphere.radius;\n\tif(distance > 1.0) return 1.0 / 0.0;\n\treturn _along - cos(asin(distance));\n}\n\nfloat occlusion(ray from) {\n\treturn \n\t\tmin(\n\t\t\thideWhenBehind(occlusion(from, sphere(vec3(1.0, sin(iTime * 1.5) * 0.1 - 0.125, 1.0), 0.5))),\n\t\t\tmin(\n\t\t\t\thideWhenBehind(occlusionPlane(from, plane(vec3(0.0, -1.0, 0.0), -2.2))),\n\t\t\t\tmin(\n\t\t\t\t\thideWhenBehind(occlusionPlane(from, plane(vec3(0.0, 1.0, 0.0), -0.3))),\n\t\t\t\t\tmin(\n\t\t\t\t\t\thideWhenBehind(occlusionPlane(from, plane(vec3(1.0, 0.0, 0.0), -4.0))),\n\t\t\t\t\t\tmin(\n\t\t\t\t\t\t\thideWhenBehind(occlusionPlane(from, plane(vec3(-1.0, 0.0, 0.0), -4.0))),\n\t\t\t\t\t\t\thideWhenBehind(occlusionPlane(from, plane(vec3(0.0, 0.0, -1.0), -4.0)))\n\t\t\t\t\t\t)\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t);\n}\n\nvec3 closest(ray from, vec3 origin, float occlusionAlong, out float closeFade) {\n\tfloat dist = min(occlusionAlong, hideWhenBehind(along(from, origin)));\n\tcloseFade = 1.0 - (1.0 / pow(1.0 + dist, 0.3));\n\treturn from.start + from.normal * dist - origin;\n}\n\nfloat closestPlane(ray from, plane plane, float occlusionAlong) {\n\treturn\n\t\tdot(\n\t\t\tplane.normal,\n\t\t\tfrom.start + from.normal * min(\n\t\t\t\tocclusionAlong,\n\t\t\t\t// If the ray is pointing away from the plane...\n\t\t\t\tdot(from.normal, plane.normal) > 0.0 \n\t\t\t\t\t// The closest point must be the start.\n\t\t\t\t\t? 0.0\n\t\t\t\t\t// Else, it's where the ray intersects the surface.\n\t\t\t\t\t: occlusionPlane(from, plane)\n\t\t\t)\n\t\t) + plane.distance;\t\t\t\n}\n\nfloat falloffFromPlane(vec3 at, plane surface, float rate) {\n\tfloat loc = dot(at, surface.normal) - surface.distance;\n\treturn loc < 0.0 ? 0.0 : 1.0 / (1.0 + loc * rate);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tray from = lens(fragCoord);\n\tfloat occlusionAlong = occlusion(from);\n\tvec3 color = vec3(0.0);\n\tfloat dist;\n\tvec3 difference;\n\tfloat intensity = 0.0;\n\t\n\t#define overheadLamp(x, z) difference = closest(from, vec3(x, 2.0, z), occlusionAlong, dist); intensity += dist * radial(difference, 16.0) * 5.0 * directional(difference, vec3(0.0, -1.0, 0.0), 4.0) + radial(difference, 512.0) * 20.0;\t\n\t\n\toverheadLamp(2.5, 2.5)\n\toverheadLamp(-2.5, 2.5)\n\toverheadLamp(2.5, -2.5)\n\toverheadLamp(-2.5, -2.5)\t\n\tcolor += vec3(0.7, 0.6, 0.0) * intensity;\n\t\t\n\tintensity = 0.0;\n\tvec3 spin = vec3(0.0, cos(iTime * 5.0), sin(iTime * 5.0));\n\tdifference = closest(from, vec3(4.0, 1.0, 0.0), occlusionAlong, dist);\n\tintensity += dist * radial(difference, 32.0) + radial(difference, 8.0) * directional(difference, spin, 8.0);\t\t\n\tdifference = closest(from, vec3(-4.0, 1.0, 0.0), occlusionAlong, dist);\n\tintensity += dist * radial(difference, 32.0) + radial(difference, 8.0) * directional(difference, -spin, 8.0);\t\t\t\n\tcolor += vec3(1.0, 0.0, 0.0) * intensity;\n\t\n\t// Lava plane.\n\tcolor += vec3(0.7, 0.0, 0.0) * falloffFromPlane(from.start + from.normal * occlusionAlong, plane(vec3(0.0, 1.0, 0.0), -0.31), 8.0);\n\t\n\tintensity = 0.0;\n\t#define lavaFlare(x, z) difference = closest(from, vec3(x, sin(iTime * 1.2 + x + z) * 0.1 - 0.15, z), occlusionAlong, dist); intensity += dist * radial(difference, 32.0 + sin(iTime * 3.0 + x + z) * 16.0);\n\t\n\tlavaFlare(-0.7, -2.5)\n\tlavaFlare(0.5, -2.0)\n\tlavaFlare(-0.5, 0.0)\n\tlavaFlare(-1.3, 2.0)\n\tlavaFlare(-1.9, -0.3)\n\t\n\tcolor += vec3(1.0, 1.0, 0.0) * intensity;\n\t//color -= 0.1;\n    color *= pow(from.normal.z, 3.0);\n    color *= 2.0;\n\tcolor = clamp(color, 0.0, 1.0);\n\t\n\tfragColor = vec4( pow(color, vec3(1.0 / 2.2)), 0.0 );\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2Gzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 120], [122, 122, 168, 168, 350], [352, 586, 619, 619, 707], [754, 754, 780, 780, 930], [932, 1049, 1084, 1084, 1132], [1136, 1136, 1172, 1172, 1229], [1231, 1231, 1270, 1270, 1317], [1319, 1319, 1377, 1377, 1441], [1443, 1443, 1481, 1481, 1530], [1582, 1582, 1629, 1629, 1747], [1798, 1798, 1840, 1840, 2056], [2058, 2058, 2085, 2085, 2660], [2662, 2662, 2742, 2742, 2915], [2917, 2917, 2982, 2982, 3344], [3346, 3346, 3406, 3406, 3517], [3519, 3519, 3576, 3576, 5307]], "test": "untested"}
{"id": "4l2Gzz", "name": "Hypercube2", "author": "aki", "description": "Forked from elias 4slSzs", "tags": ["tesseract", "hypercube"], "likes": 4, "viewed": 269, "published": "Public", "date": "1426663508", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEPS 32\n#define PRECISION 0.01\n#define DEPTH 10.0\n//#define CROSSEYE\n\nvec3 eye = vec3(0,0,-2.5);\nvec2 uv; bool hit = false;\n\nfloat lines, dots, lineWidth = 0.001;\nfloat t = mod(iTime,1.0);\nfloat s = (sin(iTime*0.5)+1.0)/2.0*0.15+0.15;\n\t\t\n// iq's magic distance function\nfloat line(vec3 p,vec3 a,vec3 b){vec3 pa=p-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-ba*h)-lineWidth;}\n\n// Rotation\nmat3 rotZ(float a){float s=sin(a);float c=cos(a);return mat3(c,-s,0,s,c,0,0,0,1);}\nmat3 rotX(float a){float s=sin(a);float c=cos(a);return mat3(1,0,0,0,c,s,0,-s,c);}\nmat3 rotY(float a){float s=sin(a);float c=cos(a);return mat3(c,0,-s,0,1,0,s,0,c);}\n\n// Marching\nfloat scene(vec3);\nvec3 march(vec3 ro,vec3 rd){float t=0.0,d;hit=false;for(int i=0;i<STEPS;i++){d=scene(ro+rd*t);if(d<PRECISION){hit=true;break;}if(t>DEPTH){break;}t+=d;}return(ro+rd*t);}\nvec3 lookAt(vec3 o,vec3 t,vec2 p){vec2 uv=(2.0*p-iResolution.xy)/iResolution.xx;vec3 d=normalize(t-o),u=vec3(0,1,0),r=cross(u,d);return(normalize(r*uv.x+cross(d,r)*uv.y+d));}\n\n// Vertices\nconst vec3 lbf = vec3(-0.5,-0.5,-0.5);\nconst vec3 rbf = vec3( 0.5,-0.5,-0.5);\nconst vec3 lbb = vec3(-0.5,-0.5, 0.5);\nconst vec3 rbb = vec3( 0.5,-0.5, 0.5);\n\nconst vec3 ltf = vec3(-0.5, 0.5,-0.5);\nconst vec3 rtf = vec3( 0.5, 0.5,-0.5);\nconst vec3 ltb = vec3(-0.5, 0.5, 0.5);\nconst vec3 rtb = vec3( 0.5, 0.5, 0.5);\n\nvec3 lbfi = vec3(-0.5+s,-0.5+s,-0.5+s);\nvec3 rbfi = vec3( 0.5-s,-0.5+s,-0.5+s);\nvec3 lbbi = vec3(-0.5+s,-0.5+s, 0.5-s);\nvec3 rbbi = vec3( 0.5-s,-0.5+s, 0.5-s);\n\nvec3 ltfi = vec3(-0.5+s, 0.5-s,-0.5+s);\nvec3 rtfi = vec3( 0.5-s, 0.5-s,-0.5+s);\nvec3 ltbi = vec3(-0.5+s, 0.5-s, 0.5-s);\nvec3 rtbi = vec3( 0.5-s, 0.5-s, 0.5-s);\n\nvec3 lbf_lbfi = mix(lbf,lbfi,t);\nvec3 ltf_ltfi = mix(ltf,ltfi,t);\nvec3 lbb_lbbi = mix(lbb,lbbi,t);\nvec3 ltb_ltbi = mix(ltb,ltbi,t);\n\nvec3 rbb_lbb = mix(rbb,lbb,t);\nvec3 rbf_lbf = mix(rbf,lbf,t);\nvec3 rtf_ltf = mix(rtf,ltf,t);\nvec3 rtb_ltb = mix(rtb,ltb,t);\n\nvec3 lbfi_rbfi = mix(lbfi,rbfi,t);\nvec3 lbbi_rbbi = mix(lbbi,rbbi,t);\nvec3 ltfi_rtfi = mix(ltfi,rtfi,t);\nvec3 ltbi_rtbi = mix(ltbi,rtbi,t);\n\nvec3 rbbi_rbb = mix(rbbi,rbb,t);\nvec3 rbfi_rbf = mix(rbfi,rbf,t);\nvec3 rtfi_rtf = mix(rtfi,rtf,t);\nvec3 rtbi_rtb = mix(rtbi,rtb,t);\n\nfloat scene(vec3 p)\n{\n    #ifdef CROSSEYE\n    dots = length(p-vec3(0,1.1,0))-0.05;\n\tp *= rotX(iTime)*rotZ(0.785*iTime);\n    #else\n    p *= rotX(0.785);\n    dots = 1e10;\n    #endif\n    \n    lines = 1e10;\n\n\t// outside\n\tlines = min(lines,line(p,lbf_lbfi,rbf_lbf));\n\tlines = min(lines,line(p,lbb_lbbi,rbb_lbb));\n\tlines = min(lines,line(p,ltf_ltfi,rtf_ltf));\n\tlines = min(lines,line(p,ltb_ltbi,rtb_ltb));\n\n\tlines = min(lines,line(p,lbf_lbfi,lbb_lbbi));\n\tlines = min(lines,line(p,ltf_ltfi,ltb_ltbi));\n\tlines = min(lines,line(p,lbf_lbfi,ltf_ltfi));\n\tlines = min(lines,line(p,lbb_lbbi,ltb_ltbi));\n\n\tlines = min(lines,line(p,rbf_lbf,rbb_lbb));\n\tlines = min(lines,line(p,rtf_ltf,rtb_ltb));\n\tlines = min(lines,line(p,rbf_lbf,rtf_ltf));\n\tlines = min(lines,line(p,rbb_lbb,rtb_ltb));\n\n    // inside\n\tlines = min(lines,line(p,lbfi_rbfi,lbbi_rbbi));\n\tlines = min(lines,line(p,ltfi_rtfi,ltbi_rtbi));\n\tlines = min(lines,line(p,lbfi_rbfi,ltfi_rtfi));\n\tlines = min(lines,line(p,lbbi_rbbi,ltbi_rtbi));\n\n\tlines = min(lines,line(p,lbbi_rbbi,rbbi_rbb));\n\tlines = min(lines,line(p,lbfi_rbfi,rbfi_rbf));\n\tlines = min(lines,line(p,ltfi_rtfi,rtfi_rtf));\n\tlines = min(lines,line(p,ltbi_rtbi,rtbi_rtb));\n\n\tlines = min(lines,line(p,rbfi_rbf,rtfi_rtf));\n\tlines = min(lines,line(p,rbbi_rbb,rtbi_rtb));\n\tlines = min(lines,line(p,rbfi_rbf,rbbi_rbb));\n\tlines = min(lines,line(p,rtfi_rtf,rtbi_rtb));\n\n    // connections\n\tlines = min(lines,line(p,rtbi_rtb,rtb_ltb));\n\tlines = min(lines,line(p,rbfi_rbf,rbf_lbf));\n\tlines = min(lines,line(p,rbbi_rbb,rbb_lbb));\n\tlines = min(lines,line(p,rtfi_rtf,rtf_ltf));\n\t\n\tlines = min(lines,line(p,ltfi_rtfi,ltf_ltfi));\n\tlines = min(lines,line(p,ltbi_rtbi,ltb_ltbi));\n\tlines = min(lines,line(p,lbfi_rbfi,lbf_lbfi));\n\tlines = min(lines,line(p,lbbi_rbbi,lbb_lbbi));\n\t\n\treturn min(lines, dots);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tuv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.xx;\n    \n    eye *= rotX(iMouse[0]/100.0)*rotZ(iMouse[1]/100.);\n    vec3 p = march(eye,lookAt(eye,vec3(0),fragCoord));\n    \n\tvec3 col = vec3(1,1,1);\n\t\n\tif (hit == false) { col = vec3(0.0, 0.0, 0.0); }\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4l2Gzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[247, 279, 312, 312, 410], [412, 424, 443, 443, 506], [507, 507, 526, 526, 589], [590, 590, 609, 609, 672], [674, 705, 733, 733, 873], [874, 874, 908, 908, 1048], [1050, 2230, 2251, 2251, 4020], [4022, 4022, 4079, 4079, 4370]], "test": "untested"}
{"id": "4lB3Rw", "name": "2015-03-26-10-03", "author": "yastero", "description": "woozle", "tags": ["woozle"], "likes": 0, "viewed": 92, "published": "Public", "date": "1427435432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n  float t = iTime;\n\n  float vol = texture(iChannel0, vec2(abs(sin(t) * 100.0), 1.0)).x;\n    \n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  float u, v, w, i = 0.0;\n\n  vec4 z;\n    \n  i = pow(pow(0.5 - uv.x, 2.0) + pow(0.5 - uv.y, 11.0), 0.5) * 13.0;\n\n  v = pow(0.5 - uv.x, 3.0 * (vol * 0.3)) + (i * sin(t * 0.3));\n\n  w = pow(0.5 - uv.y, 3.0 * (vol * 0.3)) + (i * sin(t * 0.5));\n\n  u = pow(0.5 - uv.x, 2.0) + pow(0.5 - uv.y, 2.0) + (i * sin(t * 0.7));\n\n  z = vec4(v * sin(t), w * sin(t * 0.3), u * sin(t * 0.7), 1.0);\n\n  fragColor = z;\n}\n", "image_inputs": [{"id": "4dfGzn", "previewfilepath": "/media/ap/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/ec8a6ea755d34600547a5353f21f0a453f9f55ff95514383b2d80b8d71283eda.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lB3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 591]], "test": "untested"}
{"id": "4lB3zw", "name": "testshader!", "author": "rroohhh", "description": "testshader --> for testing", "tags": ["test"], "likes": 0, "viewed": 1013, "published": "Public API", "date": "1427469532", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lB3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 147]], "test": "untested"}
{"id": "4lBGRh", "name": "[NV15] 2001 Space Station", "author": "otaviogood", "description": "My best attempt at making the space station from the movie 2001 a space odyssey.", "tags": ["space"], "likes": 68, "viewed": 8837, "published": "Public API", "date": "1426837649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^This means do anything you want with this code. Because we are programmers, not lawyers.\n\nSorry this code is pretty messy. I had to finish in time for the competition. :)\n\n-Otavio Good\n*/\n\nconst int MAX_MARCH_REPS = 100;\nconst float MARCH_DISTANCE_MULTIPLIER = 0.9;\nconst int MAX_SHADOW_MARCHES = 30;\n\nfloat localTime = 0.0;\nconst float earthRad = 6371.0;\nconst vec3 earthPos = normalize(vec3(-6500,-6400,2400)) * (earthRad + 300.0);\n\n// some noise functions\nfloat Hash(float f)\n{\n    return fract(cos(f)*7561.0);\n}\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 521.0;\t// repeats after this value\n    float rand = fract(cos(f)*104729.0);\n    return rand;\n}\nvec2 Hash2(vec2 v)\n{\n    return fract(cos(v*3.333)*vec2(100003.9, 37049.7));\n}\nfloat Hash3d(vec3 uv)\n{\n    float f = uv.x + uv.y * 37.0 + uv.z * 521.0;\n    return fract(sin(f)*110003.9);\n}\n\nfloat mixS(float f0, float f1, float a)\n{\n    if (a < 0.5) return f0;\n    return f1;\n}\n\nfloat mixC(float f0, float f1, float a)\n{\n    return mix(f1, f0, cos(a*3.1415926) *0.5+0.5);\n}\n\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nvec2 mixP2(vec2 v0, vec2 v1, float a)\n{\n    return mix(v0, v1, a*a*(3.0-2.0*a));\n}\n\nfloat mixSS(float f0, float f1, float a)\n{\n    return mix(f0, f1, smoothstep(0.0, 1.0, a));\n}\n\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2dVec(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    vec2 h0 = vec2(Hash2d(fl), Hash2d(fl + zeroOne));\n    vec2 h1 = vec2(Hash2d(fl + zeroOne.yx), Hash2d(fl + zeroOne.yy));\n    vec2 xMix = mixP2(h0, h1, fr.x);\n    return mixC(xMix.x, xMix.y, fr.y);\n}\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 fl = floor(uv);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\nfloat noise(vec3 uv)\n{\n    vec3 fr = fract(uv.xyz);\n    vec3 fl = floor(uv.xyz);\n    float h000 = Hash3d(fl);\n    float h100 = Hash3d(fl + zeroOne.yxx);\n    float h010 = Hash3d(fl + zeroOne.xyx);\n    float h110 = Hash3d(fl + zeroOne.yyx);\n    float h001 = Hash3d(fl + zeroOne.xxy);\n    float h101 = Hash3d(fl + zeroOne.yxy);\n    float h011 = Hash3d(fl + zeroOne.xyy);\n    float h111 = Hash3d(fl + zeroOne.yyy);\n    return mixP(\n        mixP(mixP(h000, h100, fr.x),\n             mixP(h010, h110, fr.x), fr.y),\n        mixP(mixP(h001, h101, fr.x),\n             mixP(h011, h111, fr.x), fr.y)\n        , fr.z);\n}\n\nfloat PI=3.14159265;\n\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\nvec3 RotateX(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(v.x, cos * v.y + sin * v.z, -sin * v.y + cos * v.z);\n  //else return new float3(x, cos * y - sin * z, sin * y + cos * z);\n}\nvec3 RotateY(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x - sin * v.z, v.y, sin * v.x + cos * v.z);\n  //else return new float3(cos * x + sin * z, y, -sin * x + cos * z);\n}\nvec3 RotateZ(vec3 v, float rad)\n{\n  float cos = cos(rad);\n  float sin = sin(rad);\n  //if (RIGHT_HANDED_COORD)\n  return vec3(cos * v.x + sin * v.y, -sin * v.x + cos * v.y, v.z);\n}\n\nvec3 GetStarColor(vec3 rayDir, vec3 sunDir)\n{\n    rayDir.xyz = rayDir.yzx;\n\tfloat dense = 16.0;\n\tvec3 localRay = normalize(rayDir);\n\tfloat sunIntensity = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\t//sunIntensity = (float)Math.Pow(sunIntensity, 14.0);\n\tsunIntensity = 0.2 / sunIntensity;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\tsunIntensity = max(0.0, sunIntensity - 3.0);\n\n\tlocalRay.x = localRay.x + 1.0 - iTime * 0.1;\n\t//vec3 right = normalize(cross(sunDir, vec3(0.0,1.0,0.0)));\n\t//vec3 up = normalize(cross(sunDir, right));\n\tvec2 wrap = fract((localRay.xy)*dense);\n\tvec4 rand = texture(iChannel2, floor(localRay.xy*dense)/dense).xyzw;\n\tvec3 starColor = rand.xyz;\n\tstarColor = starColor * 0.75 + 0.25;\n\trand.xy = rand.xy * 2.0 - 1.0;\n\tvec2 center = vec2(0.5, 0.5) + rand.xy * 0.9;// floor(fract((localRay.xy)*8.0)) + 0.5;\n\tfloat star = length(wrap - center);\n\tfloat test = star;\n\tstar = saturate((1.0 - star));\n\tfloat blink = texture(iChannel2, localRay.xy + iTime * 0.03).x;\n\tfloat cluster = 0.3;// /*(localRay.x+0.5) */ (localRay.y+0.5) * 2.8 + 0.8;\n\tstar = pow(star, 60.0 + saturate(rand.z - 0.0) * 250.0 * cluster);\n\tstar *= blink;\n\t\n\tfloat milkyMask = saturate(0.25 - abs(localRay.x - 0.65));\n\tvec3 milkyway = texture(iChannel3, (localRay.yx*1.5 )+vec2(0.65, 0.3)).yxz;\n\tvec3 milkyLOD = texture(iChannel3, (localRay.yx*1.5 )+vec2(0.65, 0.3), 3.0).yxz;\n\tvec3 milkyDetail = texture(iChannel3, (-localRay.yx*8.0 )+vec2(0.65, 0.3)).yxz;\n\tmilkyway *= milkyDetail.xxx;\n\tmilkyway *= vec3(1.0, 0.8, 0.91)*1.5;\n\tmilkyway = pow(milkyway, vec3(2.0, 2.0, 2.0)*3.0);\n\tmilkyway += vec3(0.2, 0.0015, 1.001) * milkyLOD * 0.006;\n\t\n\tvec3 finalColor = milkyway /* milkyMask*/ * 10.0;\n\tfinalColor += /*environmentSphereColor + sunCol * sunIntensity +*/ starColor * star * 12.0 * cluster;\n\treturn finalColor;\n\t//return environmentSphereColor + sunCol * sunIntensity + starColor * star * 12000.0 * cluster;\n\t//return vec3(1.0,1.0,1.0)*cluster*1000.0;\n}\n\n// This function basically is a procedural environment map that makes the sun\nvec3 sunCol = vec3(258.0, 238.0, 210.0) / 3555.0;//unfortunately, i seem to have 2 different sun colors. :(\nvec3 GetSunColorReflection(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.015 / dist;\n\tsunIntensity = pow(sunIntensity, 0.93)*100.0;\n\n    //sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n    //vec3 skyColor = mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.3,0.95), pow(saturate(rayDir.y), 0.7))*skyMultiplier*0.95;\n\treturn sunCol * sunIntensity*0.00125;\n}\nvec3 GetSunColorSmall(vec3 rayDir, vec3 sunDir)\n{\n\tvec3 localRay = normalize(rayDir);\n\tfloat dist = 1.0 - (dot(localRay, sunDir) * 0.5 + 0.5);\n\tfloat sunIntensity = 0.05 / dist;\n    sunIntensity += exp(-dist*12.0)*300.0;\n\tsunIntensity = min(sunIntensity, 40000.0);\n\treturn sunCol * sunIntensity*0.025;\n}\n\nvec4 cXX = vec4(0.0, 3.0, 0.0, 0.0);\n\nvec3 camPos = vec3(0.0), camFacing;\nvec3 camLookat=vec3(0,0.0,0);\n\nfloat cylCone(vec3 p)\n{\n    float d = length(p.xy) - 1.0;\n    d = min(d, length(p.xy - 1.0) - 0.1);\n    d = max(0.0, d + max(0.0, abs(p.z) - 1.9)*1.0);\n    return d;\n}\n\nfloat sbox(vec3 p, vec3 size)\n{\n    vec3 a = abs(p) - size;\n    float c = max(a.x, a.y);\n    c = max(c, a.z);\n    return (c);\n}\n\nfloat diamond(vec3 p, vec3 size)\n{\n    vec3 a = abs(p) - size;\n    float c = (a.x*0.5 + a.y*5.0);\n    c = (c + a.z*2.0);\n    return (c*0.25);\n}\n\nfloat cylinderInner(vec3 p, float len)\n{\n    float d = length(p.xy) - clamp(abs(p.z), 0.5, 0.8);\n    //d = min(d, sbox(abs(p) - vec3(1.0/1.414, 1.0/1.414, 0.0), vec3(0.1, 0.1, len)));\n    d = max(d, abs(p.z) - len);\n    // bars above and below hangar\n    vec3 p2 = vec3(p.x, abs(p.y), abs(p.z));\n    d = min(d, sbox(p2 - vec3(0.0, 0.3, 2.0), vec3(0.6, 0.05, 0.025)));\n    // little rings around hangar area\n    float d3 = length(p.xy) - 0.82;\n    float d2 = max(d3, abs(-p.z + 1.9) - 0.03);\n    d3 = max(d3, abs(p.z + 1.9) - 0.03);\n    return min(d3, min(d, d2));\n}\n\nfloat cylinderV(vec3 p)\n{\n    float rad = 0.15;\n    float len = 4.0;\n    float d = length(p.xz) - rad;\n    float sp = sin(p.y * 10.0);\n    sp = pow(max(0.0, sp - 0.7), 0.4);\n    float ridges = length(p.xz) - rad * abs(sp + 0.5);\n    d = min(d, ridges);\n    //d = min(d, length(p.xy - 1.0) - 0.1);\n    //d = min(d, sbox(abs(p) - vec3(0.25, 0.0, 0.25), vec3(0.03, len, 0.01)));\n    vec2 p2 = vec2(abs(p.x), p.z);\n    d = min(d, length(p2 - vec2(0.25, 0.0)) - 0.02 );\n    d = min(d, length(p2 - vec2(0.35, 0.0)) - 0.02 );\n    float rep = 0.7;\n    vec3 p3 = vec3(abs(p.x), mod(p.y, rep) - rep*0.5, p.z);\n    d = min(d, sbox(p3, vec3(0.35, 0.01, 0.02)));\n    d = max(d, abs(p.y) - len);\n    return d;\n}\n\nfloat outerRadius = 4.0;\nfloat cylinderOuter(vec3 p, float len)\n{\n    float radial = length(p.xy);\n    //float dents = sin(radial * 32.0) * 0.05;\n    //dents = pow(abs(dents), 3.0);\n    float d = -(radial - outerRadius);\n    d = max(d, (radial - (outerRadius + 0.6)));\n    float bevel = abs(radial - (outerRadius + 0.2)) * 0.2;\n    d = max(d, abs(p.z) - len + bevel);\n    return d;\n}\n\nfloat wheel(vec3 p)\n{\n    vec3 p2 = p;\n    if (abs(p2.x) > abs(p2.y)) p2.xy = p2.yx;\n    float d = cylinderV(p2);\n    d = min(d, cylinderOuter(p, 0.25));\n    d = min(d, sbox(vec3(p2.x, abs(p2.y), p2.z) - vec3(0.0, outerRadius, 0.0), vec3(0.4, 0.2, 0.275)));\n    return d;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat shipPosition;\nfloat SpaceShip(vec3 p)\n{\n    float d = length(p) - 1.5 + cos(p.z*1.02) * 1.0;\n    d *= 1.1;\n    d = max(d, -sbox(p + vec3(0.0, -0.6, 0.0), vec3(1.0,0.7,1.5)) );\n    d = smin(d, 0.7*diamond(p + vec3(0.0, 0.2, -0.5), vec3(0.1)),0.1);\n    d = max(d, sbox(p, vec3(0.9,4.2,2.5)) );\n    return d;\n}\n\nfloat ScaleShip(vec3 p, float s)\n{\n    return SpaceShip(p/s)*s;\n}\n\nfloat rotationSpeed = 0.2;\nvec2 DistanceToObject(vec3 p0)\n{\n    float material = 0.0;\n    float h = 0.0;\n    vec3 pr = RotateZ(p0, iTime * rotationSpeed);\n    float d = cylinderInner(pr, 2.0);\n    //p2.x = max(abs(p.x), abs(p.y));\n    //d = sbox(p, vec3(1.0, 1.0, 1.0));\n    vec3 p2 = vec3(pr.x, pr.y, abs(pr.z)) - vec3(0.0, 0.0, 1.5);\n    //p2.z = abs(p2.z);\n    d = min(d, wheel(p2));\n    d = max(d, -sbox(p2, vec3(0.6, 0.2, 0.7)));\t// ship docking bay - mirrored\n    d = min(d, ScaleShip(pr - vec3(0.0, 0.1, shipPosition), 0.4));\n    material = h;\n    float final = d;\n    return vec2(final, material);\n}\n\nfloat distFromSphere;\nfloat IntersectSphereAndRay(vec3 pos, float radius, vec3 posA, vec3 posB, out vec3 intersectA2, out vec3 intersectB2)\n{\n\t// Use dot product along line to find closest point on line\n\tvec3 eyeVec2 = normalize(posB-posA);\n\tfloat dp = dot(eyeVec2, pos - posA);\n\tvec3 pointOnLine = eyeVec2 * dp + posA;\n\t// Clamp that point to line end points if outside\n\t//if ((dp - radius) < 0) pointOnLine = posA;\n\t//if ((dp + radius) > (posB-posA).Length()) pointOnLine = posB;\n\t// Distance formula from that point to sphere center, compare with radius.\n\tfloat distance = length(pointOnLine - pos);\n\tfloat ac = radius*radius - distance*distance;\n\tfloat rightLen = 0.0;\n\tif (ac >= 0.0) rightLen = sqrt(ac);\n\tintersectA2 = pointOnLine - eyeVec2 * rightLen;\n\tintersectB2 = pointOnLine + eyeVec2 * rightLen;\n\tdistFromSphere = distance - radius;\n\tif (distance <= radius) return 1.0;\n\treturn 0.0;\n}\n\n// dirVec MUST BE NORMALIZED FIRST!!!!\nfloat SphereIntersect(vec3 pos, vec3 dirVecPLZNormalizeMeFirst, vec3 spherePos, float rad)\n{\n    vec3 radialVec = pos - spherePos;\n    float b = dot(radialVec, dirVecPLZNormalizeMeFirst);\n    float c = dot(radialVec, radialVec) - rad * rad;\n    float h = b * b - c;\n    if (h < 0.0) return -1.0;\n    return -b - sqrt(h);\n}\n\nvec4 cubicTex(vec2 uv)\n{\n    uv *= iChannelResolution[2].xy;\n    vec2 fr = fract(uv);\n    vec2 smoothv = fr*fr*(3.0-2.0*fr);\n    vec2 fl = floor(uv);\n    uv = smoothv + fl;\n    return textureLod(iChannel2, (uv + 0.5)/iChannelResolution[2].xy, 0.0);\t// use constant here instead?\n}\n\nvec4 tex3d(vec3 pos, vec3 normal)\n{\n\t// loook up texture, blended across xyz axis based on normal.\n\tvec4 texX = texture(iChannel2, pos.yz);\n\tvec4 texY = texture(iChannel2, pos.xz);\n\tvec4 texZ = texture(iChannel2, pos.xy);\n\t//vec4 texX = cubicTex(pos.yz);\n\t//vec4 texY = cubicTex(pos.xz);\n\t//vec4 texZ = cubicTex(pos.xy);\n\tvec4 tex = mix(texX, texZ, abs(normal.z));\n\ttex = mix(tex, texY, abs(normal.y));//.zxyw;\n\treturn tex;\n}\n\nvec4 tex3d3(vec3 pos, vec3 normal)\n{\n\t// loook up texture, blended across xyz axis based on normal.\n\tvec4 texX = texture(iChannel3, pos.yz);\n\tvec4 texY = texture(iChannel3, pos.xz);\n\tvec4 texZ = texture(iChannel3, pos.xy);\n\tvec4 tex = mix(texX, texZ, abs(normal.z));\n\ttex = mix(tex, texY, abs(normal.y));//.zxyw;\n\treturn tex;\n}\n\nfloat GrayPanel(vec2 uv)\n{\n    float grayPanels = texture(iChannel1, uv.xy * 0.25).z;\n    float grayPanels2 = texture(iChannel1, uv.xy * 0.333 + vec2(0.1, 0.3)).z;\n    grayPanels += grayPanels2;\n    float grayPanels3 = texture(iChannel1, uv.xy * 0.1777*vec2(1.0,5.0) + vec2(0.432, 0.765)).z;\n    grayPanels += grayPanels3;\n    return grayPanels;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    localTime = iTime - 0.0;\n\t// ---------------- First, set up the camera rays for ray marching ----------------\n\tvec2 uv = fragCoord.xy/iResolution.xy * 2.0 - 1.0;\n    float zoom = 2.0;\n    uv /= zoom;\n\n\t// Camera up vector.\n\tvec3 camUp=vec3(0,1,0); // vuv\n\n\t// Camera lookat.\n\tcamLookat=vec3(0,0.0,0);\t// vrp\n\n    // debugging camera\n    float mx=iMouse.x/iResolution.x*PI*2.0-0.7 + localTime*3.1415 * 0.0625;\n\tfloat my=0.0;//-iMouse.y/iResolution.y*10.0 - sin(localTime * 0.31)*0.5;//*PI/2.01;\n\tcamPos += vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*(12.2); \t// prp\n\n\n    // add randomness to camera for depth-of-field look close up.\n    //camPos += vec3(Hash2d(uv)*0.91, Hash2d(uv+37.0), Hash2d(uv+47.0))*0.01;\n\n\t// Camera setup.\n\tvec3 camVec=normalize(camLookat - camPos);//vpn\n\tvec3 sideNorm=normalize(cross(camUp, camVec));\t// u\n\tvec3 upNorm=cross(camVec, sideNorm);//v\n\tvec3 worldFacing=(camPos + camVec);//vcv\n\tvec3 worldPix = worldFacing + uv.x * sideNorm * (iResolution.x/iResolution.y) + uv.y * upNorm;//scrCoord\n\tvec3 relVec = normalize(worldPix - camPos);//scp\n\n\t// ----------------------------------- Animate ------------------------------------\n    float repTime = 32.0;\t// repeat every x seconds\n    float t1 = mod(localTime-5.0, repTime) / repTime;\n    shipPosition = 9.5 - min(pow(t1, 0.7), 0.5) * 16.0;\n\t// --------------------------------------------------------------------------------\n\t// I put a bounding sphere around the whole object. If the ray is outside\n\t// of the bounding sphere, I don't bother ray marching. It's just an optimization.\n\t//vec3 iA, iB;\n\t//float hit = IntersectSphereAndRay(vec3(0,0,0), 7.6, camPos, camPos+relVec, iA, iB);\n\n\t// --------------------------------------------------------------------------------\n\tvec2 distAndMat = vec2(0.05, 0.0);\n\tfloat t = 7.0;\n\t//float inc = 0.02;\n\tfloat maxDepth = 22.0;\n\tvec3 pos = vec3(0,0,0);\n    // start and end the camera ray at the sphere intersections.\n    //camPos = 0.5;//iA;\n    //maxDepth = distance(iA, iB);\n\t// ray marching time\n\t//if (hit > 0.5)\t// check if inside bounding sphere before wasting time ray marching.\n\t{\n        for (int i = 0; i < MAX_MARCH_REPS; i++)\t// This is the count of the max times the ray actually marches.\n        {\n            if ((t > maxDepth) || (abs(distAndMat.x) < 0.0075)) break;\n            pos = camPos + relVec * t;\n            // *******************************************************\n            // This is _the_ function that defines the \"distance field\".\n            // It's really what makes the scene geometry.\n            // *******************************************************\n            distAndMat = DistanceToObject(pos);\n            // adjust by constant because deformations mess up distance function.\n            t += distAndMat.x * MARCH_DISTANCE_MULTIPLIER;\n        }\n    }\n    /*else\n    {\n\t\tt = maxDepth + 1.0;\n        distAndMat.x = 1.0;\n    }*/\n\t// --------------------------------------------------------------------------------\n\t// Now that we have done our ray marching, let's put some color on this geometry.\n\n\tvec3 sunDir = normalize(vec3(0.93, 0.82, -1.5));\n\tvec3 finalColor = vec3(0.0);\n    float radial = length(pos.xy);\n\n\t// If a ray actually hit the object, let's light it.\n\tif (abs(distAndMat.x) < 0.75)\n    //if (t <= maxDepth)\n\t{\n        vec3 posRot = RotateZ(pos, iTime * rotationSpeed);\n\n\t\tfloat grayPanels = GrayPanel(posRot.xy);\n\n        // calculate the normal from the distance field. The distance field is a volume, so if you\n        // sample the current point and neighboring points, you can use the difference to get\n        // the normal.\n        vec3 smallVec = vec3(0.005, 0, 0);\n        vec3 normalU = vec3(distAndMat.x - DistanceToObject(pos - smallVec.xyy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yxy).x,\n                           distAndMat.x - DistanceToObject(pos - smallVec.yyx).x);\n\n        vec3 normal = normalize(normalU);\n        \n        // bump map inner stuff\n        if (radial < outerRadius - 0.01)\n        {\n            normal += (texture(iChannel1, posRot.xy * 0.27).x - 0.4) * 0.0625;\n            normal.y += (grayPanels - 1.5) * 0.1;\n            normal = normalize(normal);\n        }\n        else\n        {\n            float ridge = sin(radial*16.0+0.3);\n            ridge = pow(abs(ridge), 16.0);\n            normal += ridge*normal.z;\n            normal = normalize(normal);\n        }\n\n\n        // calculate 2 ambient occlusion values. One for global stuff and one\n        // for local stuff - so the green sphere light source can also have ambient.\n        float ambientS = 1.0;\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.1).x*10.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.2).x*5.0);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.4).x*2.5);\n        ambientS *= saturate(DistanceToObject(pos + normal * 0.8).x*1.25);\n        float ambient = ambientS * saturate(DistanceToObject(pos + normal * 1.6).x*1.25*0.5);\n        ambient *= saturate(DistanceToObject(pos + normal * 3.2).x*1.25*0.25);\n        //ambient *= saturate(DistanceToObject(pos + normal * 6.4).x*1.25*0.125);\n        ambient = max(0.15, pow(ambient, 0.3));\t// tone down ambient with a pow and min clamp it.\n        ambient = saturate(ambient);\n\n        // Trace a ray toward the sun for sun shadows\n        float sunShadow = 1.0;\n        float iter = 0.1;\n\t\tfor (int i = 0; i < MAX_SHADOW_MARCHES; i++)\n        {\n            float tempDist = DistanceToObject(pos + sunDir * iter).x;\n\t        sunShadow *= saturate(tempDist*50.0);\n            if (tempDist <= 0.0) break;\n            //iter *= 1.5;\t// constant is more reliable than distance-based\n            iter += max(0.00, tempDist)*1.0;\n            if (iter > 8.0) break;\n        }\n        sunShadow = saturate(sunShadow);\n\n        // calculate the reflection vector for highlights\n        vec3 ref = reflect(relVec, normal);\n\n        // ------ Calculate texture color ------\n        vec3 texColor;\n        texColor = vec3(0.35);// * grayPanels;\n\n        // texture outer ring\n        if (radial >= outerRadius - 0.01)\n        {\n            vec2 uvr = vec2(atan(posRot.x, posRot.y) * 8.0, length(posRot.xy) * 2.0);\n\t        if ((radial >= outerRadius  + 0.3) && (radial < outerRadius + 0.5))\n            {\n                float checker = texture(iChannel1, uvr).x;\n                float checkerL = texture(iChannel0, uvr*0.0625).x;\n                checker = pow(checker, 19.0);\n                checker *= saturate((checkerL - 0.7) * 94.0);\n                //texColor += vec3(15.0, 4.0, 2.0) * 5.0 * saturate(checker);\n                //texColor *= vec3(1.0) * saturate(checker);\n            }\n            float stripes = texture(iChannel1, uvr * vec2(0.0625, 1.0)).x;\n            texColor -= stripes * 0.03;\n        }\n        else\n        {\n            texColor = vec3(0.3) + grayPanels * 0.03;\n        }\n        if (length(normal.xy) > 0.95)\n        {\n            vec2 uvr = vec2(atan(posRot.x, posRot.y) * 1.0, posRot.z * 0.25);\n            //float checker = texture(iChannel1, uvr).x;\n            float checker = GrayPanel(uvr * vec2(1.0, 4.0));\n            texColor += vec3(0.05) * checker - vec3(0.025);\n        }\n\n        // ------ Calculate lighting color ------\n        // Start with sun color, standard lighting equation, and shadow\n        vec3 lightColor = sunCol * saturate(dot(sunDir, normal)) * sunShadow*24.0;\n        // sky color, hemisphere light equation approximation, anbient occlusion\n        lightColor += vec3(0.1,0.35,0.95) * (dot(normal, normalize(earthPos)) * 0.5 + 0.5) * ambient * 0.4;\n        // ground color - another hemisphere light\n        lightColor += vec3(1.0) * ((-normal.y) * 0.5 + 0.5) * ambient * 0.01;\n        // Apply red glow to hangar\n        vec3 lightPos = vec3(0.0, 0.0, 1.75);\n        vec3 redGlow = vec3(1.0, 0.1, 0.2) * saturate(0.8 - length(pos - lightPos));\n        redGlow *= max(0.0, dot(normalize(-lightPos-pos), normal));\n        lightColor += redGlow * 43.0;\n        // Apply red glow to hangar (again. too tired to do mirror math.)\n        lightPos = vec3(0.0, 0.0, -1.75);\n        redGlow = vec3(1.0, 0.1, 0.2) * saturate(0.8 - length(pos - lightPos));\n        redGlow *= max(0.0, dot(normalize(-lightPos-pos), normal));\n        lightColor += redGlow * 43.0;\n\n\n        // finally, apply the light to the texture.\n        finalColor = texColor * lightColor;\n\n        // glowing windows\n        if (radial >= outerRadius - 0.01)\n        {\n            vec2 uvr = vec2(atan(posRot.x, posRot.y) * 8.0, length(posRot.xy) * 2.0);\n\t        if ((radial >= outerRadius  + 0.3) && (radial < outerRadius + 0.5))\n            {\n                float checker = texture(iChannel1, uvr).x;\n                float checkerL = texture(iChannel0, uvr*0.0625).x;\n                checker = pow(checker, 19.0);\n                checker *= saturate((checkerL - 0.7) * 94.0);\n                finalColor += vec3(10.0, 6.0, 2.0) * 1.0 * saturate(checker);\n                //texColor *= vec3(1.0) * saturate(checker);\n            }\n        }\n\n        // specular highlights - just a little\n        vec3 refColor = GetSunColorReflection(ref, sunDir)*0.68;\n        finalColor += refColor * sunCol * sunShadow * 9.0 * texColor.g;\n\n        // fog that fades to sun color so that fog is brightest towards sun\n    //    finalColor = mix(vec3(0.98, 0.981, 0.981) + min(vec3(0.25),GetSunColorSmall(relVec, sunDir))*2.0, finalColor, exp(-t*0.007));\n        //finalColor = vec3(1.0, 21.0, 26.0) * saturate(length(normalU)-0.01);\n        //finalColor = vec3(40.0) * length(normalU);\n           // finalColor = normal * 0.5 + 0.5;\n\t}\n    else\n    {\n        //vec3 iA, iB;\n        //float hit = IntersectSphereAndRay(earthPos, earthRad, camPos, camPos+relVec, iA, iB);\n        float hit = SphereIntersect(camPos, normalize(relVec), earthPos, earthRad);\n        if (hit >= 0.0)\n        {\n\t\t\tvec3 intersection = camPos + relVec * hit;\n            vec3 normal = normalize(intersection - earthPos);\n            finalColor = texture(iChannel2, vec2(normal.z, normal.y)).xyz;\n            vec3 surface = vec3(0.01, 0.01, 0.1);\n            surface += tex3d(normal * 0.75, normal).yyy;\n            float d = dot(normal, normalize(camPos - intersection));\n\n            float atmosphere = 1.0 - d;\n            atmosphere = pow(atmosphere, 3.5);\n            atmosphere = atmosphere * 0.9 + 0.1;\n            surface = mix(surface, vec3(70.0, 130.0, 240.0)/355.0, atmosphere);\n\t\t\tfinalColor = surface;\n            //finalColor = vec3(1.0) * d;\n            //finalColor = normal * 0.5 + 0.5;\n        }\n        else\n        {\n\t\t\t//finalColor += GetStarColor(relVec, sunDir);\n            float stars = tex3d3(relVec*1.0, relVec).z;\n            stars = pow(stars,63.0);//63\n            finalColor += vec3(2.0) * stars;\n        }\n        // Our ray trace hit nothing, so draw sky.\n        // fade the sky color, multiply sunset dimming\n        //finalColor *=0.0;// mix(vec3(1.0, 0.95, 0.85), vec3(0.2,0.5,0.95), pow(saturate(relVec.y), 0.7))*0.95;\n        // add the sun\n    }\n    finalColor += GetSunColorReflection(relVec, sunDir);// + vec3(0.1, 0.1, 0.1);\n\n    // vignette?\n    finalColor *= vec3(1.0) * saturate(1.0 - length(uv/2.5));\n    finalColor *= 1.95;\n\n\t// output the final color with sqrt for \"gamma correction\"\n\tfragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}\n\n\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 1, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBGRh.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[890, 914, 935, 935, 970], [971, 971, 994, 994, 1117], [1118, 1118, 1138, 1138, 1196], [1197, 1197, 1220, 1220, 1306], [1308, 1308, 1349, 1349, 1394], [1396, 1396, 1437, 1437, 1490], [1492, 1492, 1533, 1533, 1576], [1577, 1577, 1616, 1616, 1659], [1661, 1661, 1703, 1703, 1754], [1793, 1793, 1820, 1820, 2072], [2073, 2073, 2097, 2097, 2364], [2365, 2365, 2387, 2387, 2972], [2996, 2996, 3019, 3019, 3048], [3049, 3049, 3072, 3072, 3101], [3102, 3102, 3127, 3127, 3156], [3158, 3158, 3191, 3191, 3405], [3406, 3406, 3439, 3439, 3653], [3654, 3654, 3687, 3687, 3832], [3834, 3834, 3879, 3879, 5776], [5778, 5964, 6018, 6018, 6444], [6445, 6445, 6494, 6494, 6748], [6855, 6855, 6878, 6878, 7022], [7024, 7024, 7055, 7055, 7151], [7153, 7153, 7187, 7187, 7296], [7298, 7298, 7338, 7338, 7863], [7865, 7865, 7890, 7890, 8562], [8589, 8589, 8629, 8629, 8947], [8949, 8949, 8970, 8970, 9222], [9224, 9260, 9301, 9301, 9394], [9416, 9416, 9441, 9441, 9709], [9711, 9711, 9745, 9745, 9776], [9805, 9805, 9837, 9837, 10385], [10409, 10409, 10528, 10589, 11283], [11285, 11324, 11416, 11416, 11646], [11648, 11648, 11672, 11672, 11928], [11930, 11930, 11965, 12028, 12355], [12357, 12357, 12393, 12456, 12684], [12686, 12686, 12712, 12712, 13033], [13035, 13035, 13092, 13092, 24494]], "test": "untested"}
{"id": "4lBGRm", "name": "Gen-Newton", "author": "paf31", "description": "Generalized Newton Raphson", "tags": ["fractal"], "likes": 2, "viewed": 99, "published": "Public", "date": "1427488947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cmult(vec2 c1, vec2 c2) {\n    return vec2\n        ( c1.x * c2.x - c1.y * c2.y \n        , c1.x * c2.y + c2.x * c1.y\n        );\n}\n\nvec2 cdiv(vec2 c1, vec2 c2) {\n    float d = c2.x * c2.x + c2.y * c2.y;\n    \n    return vec2\n        ( c1.x * c2.x + c1.y * c2.y \n        , c2.x * c1.y - c1.x * c2.y\n        ) / d;\n}\n\nvec2 step(vec2 x) {\n    float t = iTime * 3.0;\n    vec2 p = vec2(cos(t), sin(t));\n    vec2 q = vec2(cos(t * 0.9), sin(t * 0.9));\n    vec2 r = vec2(cos(t * 1.1), sin(t * 1.1));\n    vec2 s = vec2(cos(t * 1.2), sin(t * 1.2));\n    \n    return x - cdiv(\n        cmult(p, cmult(cmult(x, x), x)) +\n        cmult(q, cmult(x, x)) +\n        s,\n        3.0 * cmult(p, cmult(x, x)) +\n        2.0 * cmult(q, x));\n}\n\nvec2 iter(vec2 x) \n{\n    for (int i = 0; i < 50; i++) {\n        x = step(x);\n    }\n  \n    return x;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 x = fragCoord.xy / iResolution.xy * 3.0 - vec2(1.5, 1.5);\n    \n    float d = cos(atan(iter(x).y, iter(x).x)) * 0.3 + 0.5;\n    \n    fragColor = vec4(d, d, d * 2.0, 1.0);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 132], [134, 134, 163, 163, 315], [317, 317, 336, 336, 718], [720, 720, 740, 740, 824], [826, 826, 883, 883, 1069]], "test": "untested"}
{"id": "4lBGRW", "name": "WIP: Readable Raytracer", "author": "Hewpiedawg", "description": "Added a triangle. And triangle intersections. Next: shadows.", "tags": ["ray", "tracer"], "likes": 2, "viewed": 294, "published": "Public", "date": "1427081014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define NUM_SPHERES 5\n#define NUM_PARALLELS 1\n#define SMALL_NUM 0.0001\n#define PI 3.14159265359\n#define maximumBounces 3\n\nvec4 ambientLight = vec4(0.1, 0.1, 0.1, 0.2);\n\nstruct Material {\n    float ambient;\n    float diffuse;\n    float specular;\n    float shininess;\n    float reflectiveness;\n};\n    \nMaterial mirror;\n\n\n    \n\n   \n\nstruct ParallelLight {\n    vec3 direction;\n    vec4 color;\n};\n    \nParallelLight parallels[NUM_PARALLELS];\n\nParallelLight parallelLight(vec3 direction, vec4 color) {\n    ParallelLight light;\n    light.direction = normalize(direction);\n    light.color = color;\n    return light;\n}\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    int numberOfHits;\n    vec4 reflectance;\n    vec4 color;\n    float distance;\n};\n    \nRay ray(vec3 origin, vec3 direction, int numberOfHits, vec4 color, float distance) {\n\tRay r;\n    r.origin = origin;\n    r.direction = direction;\n    r.numberOfHits = numberOfHits;\n    r.color = color;\n    r.reflectance = vec4(1.0);\n    r.distance = distance;\n    return r;\n}\n\n//By default return eye location;\nRay ray() {\n    \n    return ray(vec3(0.0, 0.0, 0.0), \n               vec3(0.0, 0.0, 1.0), \n               0, \n               vec4(0.0, 0.0, 0.0, 1.0), \n               0.0);\n}\n    \nstruct Sphere {\n    vec3 center;\n    float radius;\n    vec4 color;\n};\n    \n\nSphere spheres[NUM_SPHERES];\n\nSphere sphere(vec3 location, float radius, vec4 color) { \n    Sphere s;\n    s.center = location;\n    s.radius = radius;\n    s.color = color;\n    return s;\n}\n\nvec3 triangle[3];\nvec4 triangleColor;\n\nvoid setupScene() { \n    \n    mirror.ambient = 0.0; \n\tmirror.diffuse = 0.0;\n\tmirror.specular = 0.1;\n\tmirror.shininess = 32.0;\n\tmirror.reflectiveness = 0.9;\n    \n    mat3 rotation = mat3(cos(iTime/4.0) , sin(iTime/4.0), 0.0, \n                         sin(iTime/4.0), - cos(iTime/4.0), 0.0, \n                          0.0, 0.0, 1.0);\n    spheres[0] = sphere(vec3(0.0, 0.0, 14) \n                        + rotation * vec3(1.0, -0.5, 0.33)\n                        ,\n                        0.75, \n                        vec4(0.9, 0.2, 0.3, 1.0));\n    spheres[1] = sphere(vec3( 1.0, 0.0, 11.0)+ vec3(1.0, 2.0, 4.0) * rotation, \n                        1.5, \n                        vec4(0.67));\n    spheres[2] = sphere(vec3(3.0, -2.0, 22.0) + vec3(1.0) * rotation, \n                        1.0,  \n                        vec4(0.125, 0.25, 0.55, 1.0));\n    spheres[3] = sphere(vec3(-1.0, 0.0, 25.0) + vec3(0.5, 2.0, 0.2) * rotation, \n                        1.5, \n                        vec4(0.125, 0.33, 0.7, 1.0));\n    spheres[4] = sphere(vec3(1.0, 0.0, 19.0) \n                        + rotation * vec3(1.0, -1.0, 0.50), \n                        1.0, \n                        vec4(0.55, 0.25, 0.76, 1.0));\n   \n    triangle[0] = rotation * vec3(0.0, 0.0, 25.0 );\n    triangle[1] = rotation * vec3(2.0, 1.0, 29.0 );\n    triangle[2] = rotation * vec3(2.0, 0.0, 20.0 );\n    triangleColor = vec4(0.4, 0.3, 0.7, 1.0);\n \n    parallels[0] = parallelLight(normalize(vec3(11.0, -1.0, 0.0)  * cos(iTime/100.0) \n                                 + vec3(1.0, 1.0, 0.0) * sin(iTime / 100.0) + vec3(1.0))\n        \t\t\t  , vec4(2.0, 1.5, 1.0, 1.0)); \n                         \n}\n\nvec4 calculateLambertianTerm(vec4 current, vec3 normal, vec3 direction, vec4 materialColor) { \n    vec4 color = vec4(0.0); //dot(-1.0 * normal, direction) * materialColor;  \n    for (int i = 0; i < NUM_PARALLELS; i++) {\n        float lambertian =  dot(-1.0 * normal,parallels[i].direction);\n        if (lambertian > 0.0){\n        \tcolor += lambertian\n            \t* materialColor \n                * parallels[i].color \n                / float(NUM_PARALLELS);\n        }\n    }\n   \n    color =  color;\n    return color;  \n}\n\nvec4 calculateSpecularTerm(vec4 current, vec3 normal, vec3 direction, vec4 materialColor) {   \n    vec4 color = vec4(0.0); //dot(-1.0 * normal, direction) * materialColor;  \n    for (int i = 0; i < NUM_PARALLELS; i++) {\n        float specular =  dot(- normal,parallels[i].direction);\n        if (specular > 0.0){\n            specular = pow(specular, 16.0);\n        \tcolor += specular\n            \t* materialColor * parallels[i].color / float(NUM_PARALLELS);\n        }\n    }\n    return color; \n    \n}\n\nvoid reflectRay(out Ray r, Ray inRay, vec4 materialColor, vec3 normal, float t, vec3 intersection) {\n    r = inRay;\n    vec3 reflection = normalize(reflect(inRay.direction, normal));\n\tvec4 specular = calculateSpecularTerm(inRay.color, reflection, inRay.direction, materialColor);\n    vec4 lambert = calculateLambertianTerm(inRay.color, normal, inRay.direction, materialColor);\n    r.color = inRay.color +  inRay.reflectance  * (lambert/1.5  + specular/2.0);\n        \n    r.origin = intersection;\n    r.direction = reflection;\n    r.reflectance = inRay.reflectance * materialColor / 3.0 * (float(inRay.numberOfHits) + 1.0);\n    r.numberOfHits++;\n    r.distance = t;  \n    \n}\n\nfloat intersect(out Ray result, Ray r, Sphere s) { \n    float a = dot(r.direction, r.direction);\n    float c = dot(r.origin, r.origin)\n        \t  + dot(s.center, s.center) \n        \t  - 2.0 * dot(r.origin, s.center) \n        \t  - s.radius * s.radius;\n    float b = 2.0 * (dot(r.direction, r.origin) \n              - dot(s.center, r.direction)); \n    float det = b * b - 4.0 * a * c;\n    float t = 0.0;\n    if (det >= 0.0) { \n        float t2 = -b - sqrt(det);\n    \tfloat t1 = -b + sqrt(det);\n        \n    \tif (t2 > 0.0) { \n        \tt = t2 / (2.0 * a);\n    \t} else if (t1 > 0.0) {      \n        \tt = t1 / (2.0 * a);\n        \n    \t}  \n        vec3 intersection = t * r.direction + r.origin;\n        vec3 normal = normalize(intersection - s.center);\n        reflectRay(result, r, s.color, normal , t, intersection); \n    }; \n     \n    return t;\n}\n\nfloat intersect(out Ray result, Ray r, vec3 triangle[3]) {\n    \n    float distance = 0.0;\n    vec3 u = triangle[1] - triangle[0];\n    vec3 v = triangle[2] - triangle[0];\n    vec3 normal = cross(u, v);\n   \n    if (length(normal) < 0.01) return 0.0; // Degenerate triangles \n    normal = normalize(normal);\n    vec3 w0 = r.origin - triangle[0] ;\n    float a = -dot(normal, w0);\n    float b = dot(normal, r.direction);\n    \n    if (abs(b) < SMALL_NUM) return 0.0;\n    distance = a / b;\n    if (distance < 0.0) return 0.0;\n        \n    vec3 planeIntersection = distance * r.direction + r.origin;\n    vec3 w = planeIntersection - triangle[0];\n    float udotu = dot(u, u);\n    float vdotv = dot(v, v);\n    float udotv = dot(u, v);\n    float wdotu = dot(w, u);\n    float wdotv = dot(w, v);\n    float denominator = udotv * udotv - udotu * vdotv;\n    float s = (udotv * wdotv - vdotv * wdotu) / denominator;\n    if (s < 0.0) return 0.0;\n    \n    float t = (udotv * wdotu - udotu * wdotv) / denominator;\n    if (t < 0.0 || s + t > 1.0) return 0.0;\n                    \n \n    if (dot(normal, r.direction) > 0.0) \n        normal = -normal;\n\n   \n    reflectRay(result, r, triangleColor, normal, distance, planeIntersection);\n    \n    return distance;\n\n}\n\nRay castRay(Ray defaultRay) {\n    \n    Ray visible = defaultRay;\n    int lastSphereBounced = -1;\n    bool triangleBounced = false;\n    for (int j=0; j < maximumBounces; j++) {\n  \t\tRay temp = visible;\n\t\tfloat closest = 1000.0;\n        for (int i = 0; i < NUM_SPHERES; i++) {\n            if (i == lastSphereBounced) continue;\n            Ray sphereRay = visible;\n            float t = intersect(sphereRay, visible, spheres[i]);\n            if (t > 0.0) {  \n               if (t < closest) {\n                   closest = t; \n                   triangleBounced = false;\n                   temp = sphereRay;\n                   lastSphereBounced = i;\n                } \n            }\n        }\n        if (!triangleBounced) {\n            Ray triangleRay = visible;\n            float t = intersect(triangleRay, visible, triangle);\n            if ( t < closest && t > 0.0) {\n            \ttriangleBounced = true;\n            \tlastSphereBounced = -1;\n                temp = triangleRay;\n                \n            } else {\n             \ttriangleBounced = false;   \n            }\n            \n        }\n        if (visible.numberOfHits < temp.numberOfHits) {\n            visible = temp;\n        }\n    }\n    return visible;\n}\n\nvec4 castAntiAliasingRay(vec2 uv) { \n    vec4 color = vec4(0.0);\n    for (int x = 0; x < 3; x ++) {\n        for (int y = 0; y < 3; y++) { \n      \t\tfloat xFloat = float(x) / 2.0 - 0.5 ;\n            float yFloat = float(y) / 2.0 - 0.5;\n        \tRay defaultRay = ray(vec3(0.0, 0.0, 0.0), \n                                 normalize(vec3(uv.x + xFloat / iResolution.x,                                    \n                                           uv.y + yFloat / iResolution.y, \n                                           1.0)), \n                                0, \n                                vec4(0.0, 0.0, 0.0, 1.0), \n                                0.0);\n            Ray result = castRay(defaultRay);\n            color += result.color / 9.0;\n        } \n    }  \n    return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setupScene();\n\tvec2 uv = fragCoord.xy / iResolution.xy / 2.0 ;\n    uv.y = (uv.y - 0.25) * iResolution.y/iResolution.x  ;\n    uv.x = uv.x - 0.25 ;\n    fragColor =castAntiAliasingRay(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lBGRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 438, 495, 495, 609], [749, 749, 833, 833, 1023], [1025, 1059, 1070, 1070, 1233], [1345, 1345, 1401, 1401, 1501], [1542, 1542, 1561, 1561, 3198], [3200, 3200, 3293, 3293, 3720], [3722, 3722, 3813, 3813, 4221], [4223, 4223, 4323, 4323, 4896], [4898, 4898, 4948, 4948, 5741], [5743, 5743, 5801, 5801, 6983], [6985, 6985, 7014, 7014, 8200], [8202, 8202, 8237, 8237, 8987], [8988, 8988, 9045, 9045, 9237]], "test": "untested"}
{"id": "4lj3RW", "name": "vish shader", "author": "vsingh", "description": "learning", "tags": ["2d"], "likes": 0, "viewed": 100, "published": "Public", "date": "1427350267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*by musk License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\tDerivative based edge detection. \n\tdFdx() and dFdy() are applied to the surface normal. \n\tIt will detect discontinuities in the normal.\n\n  modified by vish\n\n*/\n\n//functions that build rotation matrixes\nmat2 rotate_2D(float a){float sa = sin(a); float ca = cos(a); return mat2(ca,sa,-sa,ca);}\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nfloat t = iTime - 4.0;\n\nfloat df_back(vec3 p)\n{\n\treturn (16.0-length(p));\n}\n\nmat3 rot = rotate_x(t*.5)*rotate_y(t*.5)*rotate_z(t*.5);\n//mat3 rot = rotate_z(t);// * rotate_x(0.50);\n//vec3 trans = vec3(sin(t),cos(t),sin(t))*.1;\nvec3 trans = vec3(0.0, 0.0, 0.0);\n\n//2D texture based 3 component 1D, 2D, 3D noise\nvec3 noise(float p){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0)).xyz;}\nvec3 noise(vec2 p){return texture(iChannel0,p/iChannelResolution[0].xy).xyz;}\nvec3 noise(vec3 p){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev).yz).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s).yz).xyz,m);}\n\nvec3 noise(float p, float lod){return texture(iChannel0,vec2(p/iChannelResolution[0].x,.0),lod).xyz;}\nvec3 noise(vec2 p, float lod){return texture(iChannel0,p/iChannelResolution[0].xy,lod).xyz;}\nvec3 noise(vec3 p, float lod){float m = mod(p.z,1.0);float s = p.z-m; float sprev = s-1.0;if (mod(s,2.0)==1.0) { s--; sprev++; m = 1.0-m; };return mix(texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(sprev,lod).yz,lod).xyz,texture(iChannel0,p.xy/iChannelResolution[0].xy+noise(s,lod).yz,lod).xyz,m);}\n\n#define sphere(center) s0 = min(s0, length(p+center) - 0.2);\n\nfloat line(float s0, vec3 p, vec3 a, vec3 b)\n{\n    for (float t = 0.0; t <= 1.0; t += 0.1)\n    {\n    \tsphere(a*t + b * (1.0 - t));\n    }\n        \n    return s0;\n}\n\nfloat df_obj(vec3 p)\n{\n\tp += trans;\n\tp *= rot;\n\t\n\tfloat s0 = 1.0; //dot(abs(p),vec3(1.0))-1.5;\n\ts0*=.5;\n\t\n    //sphere(vec3(1.2, 0.0, 0.0));\n    \n    s0 = line(s0, p, vec3(2.0, 0.5, 0.0), vec3(2.5, -0.5, 0.0));\n    s0 = line(s0, p, vec3(2.0, 0.5, 0.0), vec3(1.5, -0.5, 0.0));\n\n    s0 = line(s0, p, vec3(1.0, 0.5, 0.0), vec3(1.0, 0.0, 0.0));\n    \n    sphere(vec3(1.0, -0.5, 0.0));\n    \n    s0 = line(s0, p, vec3(0.0, 0.0, 0.0), vec3(0.5, 0.0, 0.0));\n    s0 = line(s0, p, vec3(0.5, 0.0, 0.0), vec3(0.0, 0.5, 0.0));\n    s0 = line(s0, p, vec3(0.0, 0.5, 0.0), vec3(0.5, 0.5, 0.0));\n    \n    s0 = line(s0, p, vec3(-0.5, 0.5, 0.0), vec3(-0.5, -0.5, 0.0));\n    s0 = line(s0, p, vec3(-0.5, 0.0, 0.0), vec3(-1.0, 0.0, 0.0));\n    s0 = line(s0, p, vec3(-1.0, 0.0, 0.0), vec3(-1.0, 0.5, 0.0));\n\n    s0 = line(s0, p, vec3(-1.5, 0.0, 0.0), vec3(-1.5, -0.5, 0.0));\n    sphere(vec3(-1.5, 0.5, 0.0));\n    \n    //s0 = line(s0, p, vec3(1.0, 0.0, 0.0), vec3(1.0, 1.0, 0.0));\n    //s0 = line(s0, p, vec3(1.0, 0.0, 0.0), vec3(1.0, 0.0, 1.0));\n    \n    /*\n\tp*=rot;\n\t\n\ts0 = min(s0,max(max(abs(p.x+2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-2.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-2.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+2.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-2.0),abs(p.x)),abs(p.y))-.25);\n\t\n\tp*=rot;\n\t\n\ts0 = min(s0,max(max(abs(p.x+4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.x-4.0),abs(p.y)),abs(p.z))-.25);\n\ts0 = min(s0,max(max(abs(p.y+4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.y-4.0),abs(p.z)),abs(p.x))-.25);\n\ts0 = min(s0,max(max(abs(p.z+4.0),abs(p.x)),abs(p.y))-.25);\n\ts0 = min(s0,max(max(abs(p.z-4.0),abs(p.x)),abs(p.y))-.25);\n\t*/\n\n\treturn s0;\n}\n\n\nfloat df(vec3 p)\n{\n\treturn min(df_obj(p),df_back(p));\n}\n\n\nvec3 nf(vec3 p)\n{\n\tfloat e = .01;\n\tfloat dfp = df(p);\n\treturn vec3(\n\t\t(dfp+df(p+vec3(e,.0,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,e,.0)))/e,\n\t\t(dfp+df(p+vec3(.0,.0,e)))/e);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n\t\n\tvec2 mouse = iMouse.xy/ iResolution.xy*2.0-1.0;\n\tmouse.x *= iResolution.x/iResolution.y*4.0;\n\t\n\tmat3 rotmat = rotate_y(mouse.x) * rotate_x(mouse.y);\n\t\n\tvec3 pos = vec3(.0,.0,-3.0) ;\n\tvec3 dir = normalize(vec3(uv*.5,1.0-length(uv)*.25));\n\t\n\tvec3 light_dir = normalize(vec3(.4,.5,.6));\n\tvec3 light_color = vec3(.6,.5,.4);\n\t\n\tfloat dist;\n\t\n\tfor (int i=0; i<80; i++)\n\t{\n\t\tdist = df(pos);\n\t\tpos+=dir*dist;\n\t\tif (dist<.00001) break;\n\t}\n\n\tvec3 n = nf(pos);\n\t\n\tvec3 color1 = n*.4+.4;\n\t\n    //color1 = vec3(pos.z, 0.0, 0.0);\n    \n\tfragColor = vec4(pow(color1,vec3(.5)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lj3RW.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[257, 298, 322, 322, 387], [388, 388, 411, 411, 498], [499, 499, 522, 522, 609], [610, 610, 633, 633, 719], [745, 745, 768, 768, 796], [982, 1030, 1050, 1050, 1116], [1117, 1117, 1136, 1136, 1194], [1195, 1195, 1214, 1214, 1473], [1475, 1475, 1506, 1506, 1576], [1577, 1577, 1607, 1607, 1669], [1670, 1670, 1700, 1700, 1975], [2039, 2039, 2085, 2085, 2201], [2203, 2203, 2225, 2225, 3997], [4000, 4000, 4018, 4018, 4055], [4058, 4058, 4075, 4075, 4221], [4224, 4224, 4281, 4281, 4944]], "test": "untested"}
{"id": "4lj3z1", "name": "Fractal atom", "author": "tomkh", "description": "Based on Mlj3zz", "tags": ["voronoi", "distancefield", "dla"], "likes": 15, "viewed": 455, "published": "Public", "date": "1426938891", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// An attempt to create DLA-like particles flying in space (sort of),\n// unfortunately it runs a little bit slow... maybe can be optimized, maybe not?\n\n// Comment this out to disable scaling animation\n//#define SCALE_ANIMATION\n\n#define M_PI 3.1415926535897932384626433832795\n\nfloat hash(in float n){ return fract(n*43758.5453); }\n\nvec4 df(vec3 p, float anim, float scale)\n{\n    vec4 src[9];\n    vec4 dst[9];\n    \n    //float anim = iTime*.125; //(sin(iDate.w)+1.0)*.4999;\n    float anim_scale = .5;\n    \n    for(int i=0; i<3; ++i) {\n    \tfloat f = float(i)*(1.0/3.0);\n        float a = f*(M_PI*2.0);\n        float ds = .4*scale;\n        vec4 s = vec4(cos(a)*ds,sin(a)*ds,0,f+float(i*21));\n        dst[i] = s;\n    }\n\n    for(int lev=0; lev<6; ++lev) {\n        // Replicate:\n        for(int k=0; k<3; ++k) {\n          vec4 s = dst[k];\n          float ds = .2*scale;\n          float sw = floor(s.w);\n          float h = hash(sw) - .5;\n          float f = fract(s.w) + anim*h*anim_scale;\n          float a = h + f*(2.0*M_PI) + sw*.31;\n          src[k] = s + vec4(cos(a)*ds,sin(a)*ds,h*ds,1);\n          a += M_PI*2.0/3.0;\n          src[k+3] = s + vec4(cos(a)*ds,sin(a)*ds,ds,3);\n          a += M_PI*2.0/3.0;\n          src[k+6] = s + vec4(cos(a)*ds,sin(a)*ds,-ds,7);\n        }\n        if (lev==5) break;\n        // Copy only 3 closest to dst (idea how to optimize this, anyone?):\n        float dmax = 0.0;\n        vec4 o = src[0];\n        for(int k=0; k<3; ++k) {\n            float dmin = 1e32;\n            for(int i=0; i<9; ++i) {\n               vec4 s = src[i];\n               vec3 dp = p.xyz - s.xyz;\n               float d = dot(dp,dp);\n               if (d > dmax && d < dmin) { o = s; dmin = d; }\n            }\n            dst[k] = o;\n            dmax = dmin;\n        }\n        scale *= .5;\n        anim_scale *= 1.5;\n    }\n    \n    float dist = 6.0;\n    vec4 minp;\n    for(int i=0; i<9; ++i) {\n        vec4 s = src[i];\n        vec3 dp = p.xyz - s.xyz;\n    \tfloat d = length(dp)-.02;\n        if (d < dist) {\n\t\t\tdist = d;\n            minp = s;\n        }\n    }\n    float d = length(p.xyz)-.2;\n    if (d < dist) {\n        dist = d;\n        minp = vec4(0);\n    }\n    minp.w = max(0.0,dist);\n    //dist = min(dist, );\n    return minp;\n}\n\nfloat voro3(vec3 p)\n{\n\tvec3 sp = p - vec3(.5,.5,.5);\n    vec3 fp = fract(sp);\n    vec3 gp = sp - fp;\n\tfloat dmin = 1e32;\n    for(int i=0; i<2; i++)\n    for(int j=0; j<2; j++)\n    for(int k=0; k<2; k++)\n    {\n       vec3 hp = gp + vec3(float(i),float(j),float(k));\n       for(int seed=1; seed<8; ++seed) {\n          float seed1 = float(seed);\n          seed1 += fract(hp.x*234.12467 + hp.y*5472.1346 + hp.z*5725.1364);\n          vec3 dp = vec3(\n              hp.x + fract(seed1*2345.127+.317),\n              hp.y + fract(seed1*6234.171+.217),\n              hp.z + fract(seed1*7133.271+.171))\n              - p;\n          dmin = min(dmin,dot(dp,dp));\n       }\n    }\n\treturn dmin;\n}\n\nvec4 trace(vec3 p, vec3 n)\n{\n    float time = iTime;\n    float anim = time*.125;\n    float scale = 4.0;\n#ifdef SCALE_ANIMATION\n    scale += exp(-time*.5)*4.0;\n    if (time>24.0) {\n        scale += log(time+1.0-24.0)*2.0;\n    }\n#endif\n\tfloat d;\n    float lit = 0.0;\n    float cen = 0.0;\n    float halo = 0.0;\n    // It's quite slow... 13 steps is already too much for my GTX 460\n    const int steps = 13;\n    vec4 minp;\n    for(int k=0; k<steps; ++k) {\n    \tminp = df(p,anim,scale);\n        d = minp.w;\n        p += d*.95*n;\n        lit += 1.0/(d + 0.15);\n        float dcen = dot(p.xyz,p.xyz);\n        cen += 1.0/dcen;\n        halo += 1.0/(max(0.0,dcen-.2) + 0.15);\n    }\n    lit *= .2/float(steps);\n    lit = pow(lit,1.5);\n    \n    halo = halo*.007;\n\n    //lit += cen*texture(iChannel0,p.xy*.2).r*.1;\n    \n    //vec4 tex = texture(iChannel0,normalize(p-minp.xyz));\n    vec4 col = vec4(lit-d*.1+halo,lit*.95+halo,.3+lit*.08+halo,1);\n    //float bkg = df(vec3(n.xy*3.0,0), 4.0);\n    float bkg = voro3(n*4.0+vec3(0,0,anim*2.0))*2.0;\n                      //vec3(sin(n.z*4.0+anim)*3.0,sin(n.x*4.0-anim)*3.0,sin(n.y*4.0+anim)*3.0));\n    float star = max(0.0,1.0-voro3(n*32.0+vec3(0,0,anim*.1))*iResolution.x);\n    bkg += star*2.0*(bkg*.5+.8);\n    vec4 bkg_col = vec4(bkg,bkg,bkg,1);\n    return mix(col,bkg_col,d*.08);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*0.5) / iResolution.x;\n    \n    float anim = iTime*.25;\n    \n    float a = iMouse.x / iResolution.x * 2.0 + cos(anim)*.2; // - 1.0;\n    float co = cos(a);\n    float si = sin(a);\n    const float ds = 10.0;\n    vec3 p1 = vec3(-ds*si, 0, -ds*co);\n    vec3 n1 = normalize(vec3(uv,1));\n    vec3 n2 = vec3(n1.x*co + n1.z*si, n1.y, -n1.x*si + n1.z*co);\n    \n    //fragColor = trace(p1, n2);\n    \n    \n    a = -iMouse.y / iResolution.y * 2.0 + sin(anim*(2.0/3.0))*.2;\n    co = cos(a);\n    si = sin(a);\n    vec3 p2 = vec3(p1.x, p1.y*co + p1.z*si, -p1.y*si + p1.z*co);\n    vec3 n3 = vec3(n2.x, n2.y*co + n2.z*si, -n2.y*si + n2.z*co);\n    \n    fragColor = trace(p2, n3);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lj3z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[152, 276, 299, 299, 329], [331, 331, 373, 373, 2231], [2233, 2233, 2254, 2254, 2912], [2914, 2914, 2942, 2942, 4229], [4231, 4231, 4288, 4288, 4999]], "test": "untested"}
{"id": "4ljGRR", "name": "[NV15] Space Box", "author": "cabbibo", "description": "Space: The final frontier\n\nThis one didn't make it all the way, but I do like the corona effect!", "tags": ["nvscene"], "likes": 3, "viewed": 195, "published": "Public", "date": "1427047589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mostly taken from \n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 60;\n\n\nconst vec3 LIGHT_POS = vec3( 1. , 1. , 1. );\n\n\nconst int NUM_PLANETS = 6;\nvec3 planets[ NUM_PLANETS ];\n\nconst vec3 sun = vec3( 0. );\n\n\n\n\n//-------\n// Extra Util Functions\n//-------\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k ){\n    \n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n    \n}\n\n\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),2.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n//----\n// Distance Functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//----\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 fullRotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat rotatedBox( vec3 p , vec3 rot , vec3 size , float rad ){\n    \n    vec3 q = fullRotate( rot ) * p;\n    return udRoundBox( q , size , rad );\n    \n    \n}\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    vec3 rot = vec3( 0. );//vec3( iTime * .05 + 1., iTime * .02 + 2. , iTime * .03  );\n    // Rotating box\n   \t//vec2 res = vec2( rotatedBox( pos , rot , vec3( 0.7 ) , .1 ) , 1.0 );\n   \t\n    vec2 res = vec2( sdSphere( pos , .8 ) , 1. );\n    \n    for( int i = 0; i < NUM_PLANETS; i++){\n    \tvec2 res2 = vec2( sdSphere( pos - planets[i] , .2 ), 2. );\n   \t\tres = opU( res , res2 );\n    }\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\n//------\n// Volumetric funness\n//------\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2 + vec3( iTime * .01 , 0. , 0.), .1 );\n    return f;\n    \n}\n\n#define STEPS 10\nfloat fogCube( vec3 ro , vec3 rd , vec3 n ){\n \n    float lum = 1.;\n    for( int i = 0; i < STEPS; i++ ){\n        vec3 p = ro + rd * .05  * float( i );\n        \n        lum += posToFloat( p );// + sin( p.y * 3. ) + sin( p.z * 5.);\n    }\n    \n    return lum / float(STEPS);\n}\n\n\n\n#define FOG_STEPS 70\nvec4 overlayFog( vec3 ro , vec3 rd , vec2 screenPos){\n \n    float lum = 0.;\n    vec3 col = vec3( 0. );\n    \n    float nSize = .01;\n   \tfloat n = (noise(vec3(2.0*screenPos, abs(sin(iTime * 10. ))*.1))*nSize) -.5* nSize;\n    for( int i = 0; i < FOG_STEPS; i++ ){\n        vec3 p = ro * ( 1. + n )  + rd  * ( MAX_TRACE_DISTANCE / float( FOG_STEPS))  * float( i );\n        \n        vec2 m  = map( p );\n\n        if( m.x < 0. ){ return vec4( col , lum ) / float( FOG_STEPS ); }\n        \n        \n        float planetFog = 0.;\n        //planetFog += (1. / length( p-sun ));\n        \n        for( int i  = 0; i < NUM_PLANETS; i++ ){\n            \n          planetFog += (1. / length( p-planets[i] ));\n            \n        }\n        \n        //Check to see if we\n        \n        if( length( p ) < 1.4 && length( p ) > .8 ){\n           \n         \n            float d = (1.4 - length( p )) / .6;\n            lum += 10. * posToFloat( p * (3. / length( p )) ) * d;//30. / length( p );\n            col += vec3( 1. , 0. , 0. ) * 30. *  d* posToFloat( p* (3. / length( p )) );//* lum;\n        \n        }\n        \n        // TODO: MAKE THIS BETTER!!!!\n        //float fleck = noise( p * 10.);\n        //if( fleck > .99 ){ lum += 10.; col = vec3( 100000. ); }\n        \n        \n        lum += pow( planetFog , 2. ) * .3 * posToFloat( p * .3 * planetFog  + vec3( 100. ));//// + sin( p.y * 3. ) + sin( p.z * 5.);\n        col += planetFog * hsv( lum * .7 * (1. / float( FOG_STEPS))+ .5 , 1. , 1. );\n    }\n    \n    return vec4( col , lum ) / float(FOG_STEPS);\n}\n\n\n\n\n\n/*vec3 doLighting( vec3 ro , vec3 rd ){\n    \n    \n    \n}*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    \n    float tInput = 36.1; // iTime\n    \n    for( int i = 0; i < NUM_PLANETS; i++ ){\n     \n        \n        float f = float( i );\n        planets[i].x = (.5 + (f+2.)/3.)*(cos(f + (.1 + ( .04 * f )) * tInput ));\n        planets[i].z = (.5 + (f+2.)/3.)*(sin(f + (.1 + ( .04 * f )) * tInput ));\n        \n        \n    }\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    vec3 col = vec3( 0. );\n    \n    // Center object\n    if( res.y ==  1. || res.y == 2.){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos );\n        \n       \tvec3 lightPos = vec3( 5. , 5. , 5. );\n        \n        lightPos -= pos;\n        lightPos = normalize( lightPos );\n        \n        vec3 refl = reflect( lightPos , norm );\n        \n        float eyeMatch = max( 0. , dot( refl , rd ) );\n        float lamb =pow(max( 0.0 , dot( lightPos , norm )),.3);\n        \n        \n        float lum = fogCube( pos , rd , norm );\n       // col = norm * .5 + .5;\n      \n        float lu = max( 0.0 , -dot( lightPos , norm ));\n        \n        vec3 nCol = hsv( posToFloat( pos) + .3 , .4 , 1.);\n        nCol *=pow( lum * 2. , min( 5. , 1./eyeMatch) ) * eyeMatch;\n        \n        vec3 col2 = hsv( posToFloat( pos) + .6, .6, .4);\n        nCol += lamb * col2 * pow( lum * 2. , min( 5. , 1./eyeMatch) ) * ( 1. - eyeMatch );\n        \n        vec3 col3 = hsv( posToFloat( pos) + .6, .9, .2);\n        nCol += col3 * pow( lum * 2., min( 5. , 1./eyeMatch) ) * ( 1. - lamb );\n        \n       // nCol +=  vec3( .2 ) * ( 1. - eyeMatch );\n       // nCol *= hsv( abs(sin(lum * .1)) , .5 , 1. );\n        \n        //nCol += pow( eyeMatch , 10. ) * vec3( 1. );//hsv( eyeMatch * 1. , .5 , 1. );\n        col += nCol;\n           \n        \n    //}else if( res.y == 2. ){\n        \n       // col = vec3( .1 );\n    }\n\n    \n    // OVER LAY FOG\n    \n    vec4 fog = overlayFog( ro , rd , fragCoord.xy );\n    col += .6 * fog.xyz * fog.w;\n   \n    \n\tfragColor = vec4(col,1.0);\n    \n}\n\n\n\n\n\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4sfGzn", "previewfilepath": "/media/ap/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljGRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[433, 479, 516, 516, 648], [650, 650, 714, 714, 908], [911, 911, 933, 933, 969], [971, 971, 996, 996, 1332], [1336, 1388, 1410, 1410, 1435], [1436, 1436, 1457, 1457, 1537], [1573, 1625, 1668, 1668, 1971], [1975, 2006, 2070, 2070, 2248], [2250, 2250, 2333, 2333, 2446], [2450, 2557, 2588, 2588, 2626], [2629, 2629, 2674, 2674, 2714], [2717, 2717, 2752, 2752, 2776], [2778, 2872, 2901, 2901, 2944], [2947, 3020, 3043, 3043, 3149], [3151, 3151, 3174, 3174, 3280], [3282, 3282, 3305, 3305, 3414], [3417, 3417, 3443, 3443, 3512], [3514, 3514, 3576, 3576, 3670], [3673, 3757, 3778, 3778, 4198], [4202, 4202, 4250, 4250, 4717], [4719, 4832, 4863, 4863, 5089], [5093, 5134, 5161, 5161, 5255], [5274, 5274, 5318, 5318, 5547], [5572, 5572, 5625, 5625, 7110], [7116, 7177, 7233, 7233, 9717]], "test": "untested"}
{"id": "4ljGzW", "name": "3d Voronoi noise", "author": "jimmikaelkael", "description": "This is an attempt to make some 3d voronoi noise based on IQ's voronoise article: http://www.iquilezles.org/www/articles/voronoise/voronoise.htm", "tags": ["voronoi", "noise", "voronoise"], "likes": 14, "viewed": 747, "published": "Public", "date": "1427282740", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hash3(in vec3 p) {\n    vec3 q = vec3(dot(p, vec3(127.1, 311.7, 189.2)),\n                  dot(p, vec3(269.5, 183.3, 324.7)),\n                  dot(p, vec3(419.2, 371.9, 128.5)));\n    return fract(sin(q) * 43758.5453);\n}\n\nfloat noise(in vec3 x, float v) {\n    // adapted from IQ's 2d voronoise:\n    // http://www.iquilezles.org/www/articles/voronoise/voronoise.htm\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    float s = 1.0 + 31.0 * v;\n    float va = 0.0;\n    float wt = 0.0;\n    for (int k=-2; k<=1; k++)\n    for (int j=-2; j<=1; j++)\n    for (int i=-2; i<=1; i++) {\n        vec3 g = vec3(float(i), float(j), float(k));\n        vec3 o = hash3(p + g);\n        vec3 r = g - f + o + 0.5;\n        float d = dot(r, r);\n        float w = pow(1.0 - smoothstep(0.0, 1.414, sqrt(d)), s);\n        va += o.z * w;\n        wt += w;\n     }\n     return va / wt;\n}\n\n\nfloat fBm(in vec3 p, float v) {\n    float sum = 0.0;\n    float amp = 1.0;\n    for(int i = 0; i < 4; i++) {\n        sum += amp * noise(p, v);\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    vec3 rd = normalize(vec3(p.xy, 1.0));\n    vec3 pos = vec3(0.0, 0.0, 1.0) * iTime + rd * 10.0;\n\n    vec3 col = vec3(0.0);\n    if (p.x < -0.005) {\n        col = vec3(0.5 * fBm(pos, 1.0));\n    } else {\n        col = vec3(0.5 * fBm(pos, 0.2));\n    }\n\n    // the black line\n    if (p.x > -0.005 && p.x < 0.005 ) {\n        col = vec3(0.0);\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljGzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 224], [226, 226, 259, 368, 859], [862, 862, 893, 893, 1064], [1066, 1066, 1123, 1123, 1558]], "test": "untested"}
{"id": "4ljGzz", "name": "ngTweet1", "author": "netgrind", "description": "tweet sized shader", "tags": ["tweet", "shadeaday", "netgrind"], "likes": 4, "viewed": 1119, "published": "Public API", "date": "1426662461", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat i=iTime;vec2 uv=fragCoord.xy*.01;uv.x-=2.5+sin(i);float f=sin(i+uv.x/sin(uv.y*sin(length(uv))+i));fragColor = vec4(f*f,f,f,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ljGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 194]], "test": "untested"}
{"id": "4ll3Dj", "name": "Vaihtoehtopolitiikkaa Torstaina", "author": "Branch", "description": "Vaihtoehtopolitiikkaa Torstaina", "tags": ["vaihtoehtopolitiikkaatorstaina"], "likes": 1, "viewed": 113, "published": "Public", "date": "1425249829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct polygon{\n\tvec2 A, B, C;\n};\nfloat sign(vec2 p1, vec2 p2, vec2 p3){\n  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\nint PointInTriangle(vec2 pt, vec2 v1, vec2 v2, vec2 v3){\n\tint b1, b2, b3;\n\n\tif(sign(pt, v1, v2) < 0.0) b1=1;\n\tif(sign(pt, v2, v3) < 0.0) b2=1;\n\tif(sign(pt, v3, v1) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\nint PointInTriangle(vec2 pt, polygon X){\n\tint b1, b2, b3;\n\n\tif(sign(pt, X.A, X.B) < 0.0) b1=1;\n\tif(sign(pt, X.B, X.C) < 0.0) b2=1;\n\tif(sign(pt, X.C, X.A) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\nfloat box(vec2 coord, vec2 pos, vec2 size){\n\tif((coord.x<(pos.x+size.x)) &&\n\t   (coord.x>(pos.x-size.x)) &&\n\t   (coord.y<(pos.y+size.y)) && \n\t   (coord.y>(pos.y-size.y)) ) \n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat sun(vec2 coord, vec2 pos, float size){\n\tif(length(coord-pos)<size)\n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rotate(float Angle)\n{\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(floor(length( pa - ba*h ) - r),0.);\n}\nfloat triangle( vec2 coord, vec2 pos, float angle, float thick, float size){\n    vec2 original_coord = coord;\n    coord += pos;\n    coord *= rotate(angle);\n    float collision = 0.0;\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2( 0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.3,-0.2)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += 3.0*texture( iChannel0, original_coord * 0.6 + vec2(iTime*0.02) ).b * 0.6;\n    collision += 2.5*texture( iChannel0, original_coord * 0.1 + vec2(iTime*0.001) ).b * 0.4;\n    return -min(max(-collision,0.0),1.0);\n}\nfloat circle(vec2 coord, float size, float start, float end){\n    float angle = atan(coord.x, coord.y);\n    if(angle>start && angle<end) return 0.0;\n    return min(floor(distance(coord,vec2(0.))-size),0.);\n}\nvec3 piip(){\n    vec2 res=iResolution.xy;\n    vec2 coord = 1.8 * vec2((res.x/res.y),1.0) *(gl_FragCoord.xy / res.xy - 0.5);\n    vec2 p=coord;\n    coord*=0.7;\n    vec3 COLOR =vec3(0.7,0.77,0.9);\n    for(float ttt=0.; ttt<0.4; ttt+=0.1){\n    float time=ttt+iTime*(0.6)+floor(coord.y*4.+iTime*0.2+coord.x*0.2)*0.1;\n    coord*=sin(time*0.001)*0.4+0.7-time*0.001;\n   \tcoord*=rotate(time*0.1);\n    coord*=1.0+0.4*sin(iTime*0.2+length(coord)*2.1);\n    coord *= sin(cos(length(coord)*1.4-time*0.42)*4.+time*.1)*1.6;\n        \n    coord += 0.01*(rand(vec2(floor(coord.x*10.),floor(coord.y*44.)+ttt))-0.5);\n        \n        \n        \n    coord.x +=0.06*(rand(vec2(floor(coord.y*12.+time)))-0.5);\n    coord.y +=0.01*(rand(vec2(floor(coord.x*777.+time)))-0.5);\n    for(float i=0.; i<44.; i+=1.3)\n        COLOR -= (vec3(sin(i+time*.78),cos(i+time*.64+length(coord)*4.),sin(time))*0.05+0.3)*circle(coord,0.01*i+0.4*sin(time+i),sin(i*4.3+time*0.1)*3.141,sin(i*0.3+time*0.1)*3.141) - 0.3*circle(coord,-0.02+0.01*i+0.4*sin(time+i),sin(i*4.3+time*0.1)*3.141,sin(i*0.3+time*0.1)*3.141);\n    if(mod(p.y*2e2+p.x*2e2,3.)<1.1)\n        COLOR -= vec3(0.05);\n    COLOR += 0.2*(cos(time)*0.16 + 1.1 - min(time, 1.0));\n    COLOR+=0.1*(1.0+mod(time*5.0,1.0)*0.1)-\n        vec3(\n        rand(p+.21*vec2(time))*rand(vec2(p.x,time*.3)),\n        rand(vec2(coord.y,0.)+p+.31*vec2(time))*rand(vec2(p.x*0.01,time*2.1)),\n        rand(p+.41*vec2(time))*rand(vec2(p.x*0.1,time))\n        )*.4;\n    }\n    COLOR/=2.8;\n    return COLOR;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec4 tulos;\n\tvec4 lopullinentulos=vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    vec2 ori_coord=coord;\n\tfor(float rgbare=0.0; rgbare<2.0; rgbare++){\n        coord = vec2(aspectCorrection,1.0) *coordinate_entered * (1.+0.2*cos(iTime*0.05));\n        coord.x*=1.0+rgbare*0.007;\n        coord*=1.5+0.1*sin(1.01*0.1);\n        tulos=vec4(vec3(16.0/255.0, 8.0/255.0, 0.0/255.0),1.0);\n        coord*=sin(iTime*3.)*.2+2.;\n\t\tcoord+=5.*(vec2(rand(vec2(floor(iTime))),rand(vec2(floor(iTime+66.))))-vec2(0.5));\n        coord*=rand(vec2(floor(iTime+444.)));\n    \tcoord+=max(2.0-(mod(iTime*8.,16.))/2.,0.)*vec2(rand(floor(coord*2.+iTime))-0.5,rand(floor(coord*2.+44.+iTime))-0.5);\n        \n        vec3 taikurivitunluttinen=vec3(0.);\n        if(mod(iTime,6.)>1.){\n            taikurivitunluttinen.rb+=0.7*max(1.0-(iTime,4.)/2.,0.)*vec2(rand(floor(coord*2.))-0.5,rand(floor(coord*2.+44.))-0.5);\n            taikurivitunluttinen.rg-=0.7*max(1.0-(iTime,4.)/2.,0.)*vec2(rand(floor(coord*.9))-0.5,rand(floor(coord*.9+44.))-0.5);\n        }\n        coord.x+=( 0.05*sin((iTime)*12.+coord.y) ) / (1.0+33.*(mod(iTime,2.)));\n    \tcoord.y+=( 0.05*sin((iTime)*12.+coord.x) ) / (1.0+33.*(mod(iTime,2.)));\n\n        float headTime=max(iTime-2.,0.);\n        vec2 head_coord=coord*(sin(headTime*40.)*0.1/(headTime*22.)+1.);\n        tulos.rgb+=sun(head_coord,vec2(0.),.9);\n        tulos.rgb+=sun(head_coord,vec2(0.),1.2);\n        tulos.rgb-=sun(head_coord,vec2(0.),1.1);\n        tulos.rgb-=sun(head_coord,vec2(0.35,0.12),.18);\n        tulos.rgb+=sun(head_coord,vec2(0.35,0.12),.12);\n        tulos.rgb-=sun(head_coord,vec2(-0.35,0.12),.12);\n        tulos.rgb+=sdCapsule( head_coord+vec2(0.,0.1*cos(head_coord.x*3.14159/1.4-3.14159/16.)), vec2(-.666,-0.4), vec2(.666,-0.4), 0.1);\n\n        if(head_coord.y>0.4){\n            tulos.rgb-=sun(head_coord,vec2(0.333,0.3),.33);\n            tulos.rgb+=sun(head_coord,vec2(0.333,0.3),.28);\n            tulos.rgb-=sun(head_coord,vec2(-0.333,0.3),.33);\n            tulos.rgb+=sun(head_coord,vec2(-0.333,0.3),.28);\n        }\n        tulos.rgb-=triangle( coord*rotate(iTime+1.), vec2(0.,-.2), 0.0, 0.1, 5.*sin(iTime+1.)+mod(iTime,2.)+10.+sin(iTime)*2.);\n        tulos.rgb-=triangle( coord*rotate(iTime*.42+1.), vec2(0.,-.2), 0.0, 0.2, 5.*sin(iTime+2.)+mod(iTime,2.)+12.+sin(iTime)*2.)/2.;\n        tulos.rgb-=triangle( coord*rotate(iTime*1.3+1.), vec2(0.,-.2), \t0.0, 0.133, 5.*sin(iTime+3.)+mod(iTime,2.)+14.+sin(iTime)*2.)/4.;\n        tulos.rgb-=triangle( coord*rotate(iTime*1.6+1.), vec2(0.,-.2), \t0.0, 0.4, 5.*sin(iTime+4.)+mod(iTime,2.)+14.+sin(iTime)*2.)/4.;\n        tulos.rgb-=triangle( coord*rotate(iTime*0.6+1.), vec2(0.,-.2), \t0.0, 0.1, 5.*sin(iTime+5.)+mod(iTime,2.)+14.+sin(iTime)*4.)/4.;\n\n        float collision = 0.0;\n        if(collision<0.0)\n            tulos.xyz += vec3(0.1);\n\n        tulos.xyz=tulos.xyz-vec3(min(max(-0.57+length(ori_coord)*0.32,0.0),1.0))-vec3(0.015+0.03*rand(vec2(ori_coord.x+ori_coord.y,1.01*ori_coord.y*ori_coord.x)));\n\n        if(rgbare==0.0)\n            lopullinentulos.r=tulos.r;\n        if(rgbare==1.0)\n            lopullinentulos.gb=tulos.gb;\n\t}\n\tlopullinentulos.xyz=lopullinentulos.xyz*(1.05-0.1*mod(fragCoord.y,2.0));\n    float vignette = 1.0 / max(0.3 + 1.7*dot(coord,coord),1.);\n\tfragColor = lopullinentulos*vec4(piip()+vec3(.6)+vignette,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ll3Dj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 72, 72, 146], [147, 147, 203, 203, 378], [380, 380, 420, 420, 601], [603, 603, 646, 646, 804], [805, 805, 849, 849, 906], [907, 907, 927, 927, 999], [1001, 1001, 1027, 1027, 1159], [1160, 1160, 1211, 1211, 1353], [1354, 1354, 1430, 1430, 2033], [2034, 2034, 2095, 2095, 2241], [2242, 2242, 2254, 2254, 3736], [3740, 3740, 3796, 3796, 7263]], "test": "untested"}
{"id": "4lS3zD", "name": "pixellated parallax noise", "author": "tom", "description": "landscape wip", "tags": ["2d", "parallax", "snoise", "pixellated"], "likes": 12, "viewed": 353, "published": "Public", "date": "1427285175", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The first part of this shader is lifted off the internet and has license\n//\n// Description : Array and textureless GLSL 2D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec2 mod289(vec2 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec3 permute(vec3 x) {\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat snoise(vec2 v)\n  {\n  const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                      0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                     -0.577350269189626,  // -1.0 + 2.0 * C.x\n                      0.024390243902439); // 1.0 / 41.0\n// First corner\n  vec2 i  = floor(v + dot(v, C.yy) );\n  vec2 x0 = v -   i + dot(i, C.xx);\n\n// Other corners\n  vec2 i1;\n  //i1.x = step( x0.y, x0.x ); // x0.x > x0.y ? 1.0 : 0.0\n  //i1.y = 1.0 - i1.x;\n  i1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n  // x0 = x0 - 0.0 + 0.0 * C.xx ;\n  // x1 = x0 - i1 + 1.0 * C.xx ;\n  // x2 = x0 - 1.0 + 2.0 * C.xx ;\n  vec4 x12 = x0.xyxy + C.xxzz;\n  x12.xy -= i1;\n\n// Permutations\n  i = mod289(i); // Avoid truncation effects in permutation\n  vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n                + i.x + vec3(0.0, i1.x, 1.0 ));\n\n  vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n  m = m*m ;\n  m = m*m ;\n\n// Gradients: 41 points uniformly over a line, mapped onto a diamond.\n// The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n\n  vec3 x = 2.0 * fract(p * C.www) - 1.0;\n  vec3 h = abs(x) - 0.5;\n  vec3 ox = floor(x + 0.5);\n  vec3 a0 = x - ox;\n\n// Normalise gradients implicitly by scaling m\n// Approximation of: m *= inversesqrt( a0*a0 + h*h );\n  m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\n// Compute final noise value at P\n  vec3 g;\n  g.x  = a0.x  * x0.x  + h.x  * x0.y;\n  g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n  return 130.0 * dot(m, g);\n}\n\n// The rest of this shader is licensed (for what it's worth..):\n// Copyright Tom 2015\n// This work is licensed under a Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec2 getUV(vec2 fragCoord, float xtiles)\n{\n    float tileSize = iResolution.x / xtiles;\n    float ytiles = floor(iResolution.y / tileSize);\n    // step the uvs to get a pixellated effect. later render to a small fbo and resize\n    vec2 steps = vec2(xtiles,ytiles);\n    vec2 uv = (fragCoord.xy / iResolution.xy)*steps;\n    return floor(uv)/steps;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int depth =6;\n    //vec4 fg = vec4(0.06,0.59,0.28,1);\n    vec4 fg = vec4(0.23,0.36,0.48,1);\n    vec4 fg1 = vec4(0.85,0.95,1.,1);\n    for (int i=0;i<depth;++i){\n        float pc = pow(float(i)/float(depth),1.5);\n        float tls = mix(80., iResolution.x/2., pc);\n        float speed = mix(150.,10., pc);\n        float freq = mix(.8, 3.,pc);\n        vec2 uv = getUV(fragCoord.xy+vec2(iTime*speed,mix(-30.,-90.,pc)), tls);\n        float f = snoise(vec2(2.,4.)*uv*freq)+2.*uv.y;\n        if (f<0.5) {\n\t\t\tfg1 = mix(fg,fg1,pc);\n            break;\n    \t}\n    }\n    fragColor = fg1;\n\n        \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lS3zD.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 445, 466, 466, 515], [517, 517, 538, 538, 587], [589, 589, 611, 611, 648], [650, 650, 674, 674, 2194], [2196, 2392, 2434, 2434, 2739], [2741, 2741, 2798, 2798, 3395]], "test": "untested"}
{"id": "4lsGDl", "name": "Very first plasma", "author": "tesla", "description": "My first shadertoy thing.", "tags": ["oldschool", "plasma"], "likes": 12, "viewed": 3439, "published": "Public API", "date": "1426175047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// My first Shadertoy experiment\n// Algorithm copied from here: http://www.bidouille.org/prog/plasma\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float pi = 3.141592;\n    \n    // v1\n    float v1 = sin(uv.x*5.0 + iTime);\n       \n    // v2\n    float v2 = sin(5.0*(uv.x*sin(iTime / 2.0) + uv.y*cos(iTime/3.0)) + iTime);\n    \n    // v3\n    float cx = uv.x + sin(iTime / 5.0)*5.0;\n    float cy = uv.y + sin(iTime / 3.0)*5.0;\n    float v3 = sin(sqrt(100.0*(cx*cx + cy*cy)) + iTime);\n    \n    float vf = v1 + v2 + v3;\n    float r  = cos(vf*pi);\n    float g  = sin(vf*pi + 6.0*pi/3.0);\n    float b  = cos(vf*pi + 4.0*pi/3.0);\n\n    fragColor = vec4(r, g, b, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 102, 159, 159, 716]], "test": "untested"}
{"id": "4lsGDX", "name": "ngWaves08", "author": "netgrind", "description": "mouse x is\nr a d", "tags": ["waves", "netgrind", "neat"], "likes": 2, "viewed": 1264, "published": "Public API", "date": "1425710024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 hue(vec4 color, float shift) {\n\n    const vec4  kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n    const vec4  kRGBToI     = vec4 (0.596, -0.275, -0.321, 0.0);\n    const vec4  kRGBToQ     = vec4 (0.212, -0.523, 0.311, 0.0);\n\n    const vec4  kYIQToR   = vec4 (1.0, 0.956, 0.621, 0.0);\n    const vec4  kYIQToG   = vec4 (1.0, -0.272, -0.647, 0.0);\n    const vec4  kYIQToB   = vec4 (1.0, -1.107, 1.704, 0.0);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec4    yIQ   = vec4 (YPrime, I, Q, 0.0);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nvec2 rotate(vec2 v, float a){\n\tfloat t = atan(v.y,v.x)+a;\n    float d = length(v);\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 4.0;\n    float i= iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy*scale - scale*.5;\n    vec4 c = vec4(1.0,0.0,1.0,1.0);\n    uv = rotate(uv,sin(length(uv.yx)+iMouse.x*.02+i));\n    mat2 m = mat2(\n    \tuv.x*uv.y,\n        uv.y,\n        dot(uv.y,uv.x+iMouse.y*.02),\n        sin(uv.y*6.0+cos(uv.x)*5.0)\n    );\n    m[0] = rotate(m[0],length(uv));\n    c.rb= mod(uv*m+i,1.0)*.5+.5;\n    c.rb = pow(c.rb,vec2(9.0));\n    c.rgb = hue(c,i).rgb;\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsGDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 1019], [1021, 1021, 1050, 1050, 1159], [1161, 1161, 1218, 1218, 1685]], "test": "untested"}
{"id": "4lSGRh", "name": "Parallax mapping", "author": "nimitz", "description": "Parallax mapping, a way of augmenting depth perception without intersecting in 3d space or iterating.  Mouse enabled.\n\nAslo using the opportunity to show off TekF's great cell texture: https://www.shadertoy.com/view/ltXGWS", "tags": ["3d", "raymarching", "bumpmapping", "technique", "parallaxmapping"], "likes": 39, "viewed": 1615, "published": "Public", "date": "1426736831", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Parallax mapping by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4lSGRh\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tI was reading on parallax mapping and thought this would be\n\tof good use for cheap detailing. Yet as of this writing, \n\tthere isn't a single implementation of it on shadertoy.\n\n\tThis implementation was written from scratch, \n\tlet me know if you see errors/optimizations.\n\n\tI tried getting the exact height for every bump mapping tap, but it\n\tis more expensive to compute and the results weren't better.\n\n\tRelevant code is at line 106\n*/\n\n//Show only the raymarched geometry (for comparison)\n//#define RAYMARCHED_ONLY\n\n//The amount of parallax\n#define PARALLAX_SCALE .2\n\n//Scale the texture offset as a function of incidence (much better results)\n#define USE_OFFSET_SCALING\n#define OFFSET_SCALE 2.\n\n//Bump mapping intensity\n#define BUMP_STRENGTH .1\n#define BUMP_WIDTH 0.004\n\n//Main texture scale\nconst float texscl = 2.5;\n\n#define ITR 70\n#define FAR 15.\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nfloat hash(vec2 x){\treturn fract(cos(dot(x.xy,vec2(2.31,53.21))*124.123)*412.0); }\n\nfloat sdfsw = 0.; //Global mouse control\n\nfloat length4(in vec3 p ){\n\tp = p*p; p = p*p;\n\treturn pow( p.x + p.y + p.z, 1.0/4.0 );\n}\n\nfloat map(vec3 p)\n{\n    float d = mix(length(p)-1.1,length4(p)-1.,sdfsw-0.3);\n    d = min(d, -(length4(p)-4.));\n    return d*.95;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.001;\n    float h=precis*2.0;\n    float d = 0.;\n    for( int i=0; i<ITR; i++ )\n    {\n        if( abs(h)<precis || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d);\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(in vec3 p)\n{  \n    vec2 e = vec2(-1., 1.)*0.005;   \n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\n//From TekF (https://www.shadertoy.com/view/ltXGWS)\nfloat cells(in vec3 p)\n{\n    p = fract(p/2.0)*2.0;\n    p = min(p, 2.0-p);\n    return 1.-min(length(p),length(p-1.0));\n}\n\nfloat tex( vec3 p )\n{\n    p *= texscl;\n    float rz= 0.;\n    float z= 1.;\n    for ( int i=0; i<2; i++ )\n    { \n        #ifndef RAYMARCHED_ONLY\n        rz += cells(p)/z;\n        #endif\n        p *= 1.5;\n        z *= -1.1;\n    }\n    return clamp(rz*rz*2.5,0.,1.)*2.-1.;\n}\n\n/*\n\tThe idea is to displace the shaded position along the surface normal towards\n\tthe viewer,\tthe tgt vector is the displacement vector, then\tI apply a scaling\n\tfactor to the displacement and also have an incidence based\toffset scaling set up.\n*/\nvec3 prlpos(in vec3 p, in vec3 n, in vec3 rd)\n{\n    //vec3 tgt = cross(cross(rd,n), n); //Naive method (easier to grasp?)\n    vec3 tgt = n*dot(rd, n) - rd; //Optimized\n\n#ifdef USE_OFFSET_SCALING\n    tgt /= (abs(dot(tgt,rd)))+OFFSET_SCALE;\n    \n#endif\n    \n    p += tgt*tex(p)*PARALLAX_SCALE;\n    return p;\n}\n\nfloat btex(in vec3 p)\n{\n    float rz=  tex(p);\n    rz += tex(p*10.)*0.01; //Extra (non-parallaxed) bump mapping can be added\n    return rz;\n}\n\nvec3 bump(in vec3 p, in vec3 n, in float ds)\n{\n    vec2 e = vec2(BUMP_WIDTH*sqrt(ds)*0.5, 0);\n    float n0 = btex(p);\n    vec3 d = vec3(btex(p+e.xyy)-n0, btex(p+e.yxy)-n0, btex(p+e.yyx)-n0)/e.x;\n    vec3 tgd = d - n*dot(n ,d);\n    n = normalize(n-tgd*BUMP_STRENGTH*8./(ds));\n    return n;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 bp = fragCoord.xy/iResolution.xy*2.-1.; \n    vec2 p = bp;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 mo = iMouse.xy / iResolution.xy-.5;\n    mo = (mo==vec2(-.5))?mo=vec2(0.4,-0.25):mo;\n\tmo.x *= iResolution.x/iResolution.y;\n\tp.x += mo.x*1.;\n    sdfsw = mo.y*4.;\n    \n\tvec3 ro = vec3(0.,0.,4.);\n    vec3 rd = normalize(vec3(p,-3.+sin(time*0.9+sin(time))));\n    mat2 mx = mm2(time*.1+sin(time*0.4)-0.2);\n    mat2 my = mm2(time*0.07+cos(time*0.33)-0.1);\n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n\t\n\tfloat rz = march(ro,rd);\n\t\n    vec3 col = vec3(0);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal( pos );\n        pos = prlpos(pos,nor,rd);\n        float d = distance(ro,pos);\n        nor = bump(pos, nor, d);\n\n        vec3 ligt = normalize( vec3(-.5, 0.5, -0.3) );\n        float dif = clamp( dot( nor, ligt ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(vec3(-ligt))), 0.0, 1.0 );\n        float spe = pow(clamp( dot( reflect(rd,nor), ligt ), 0.0, 1.0 ),70.);\n        float fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n        vec3 brdf = vec3(0.3);\n        brdf += bac*vec3(0.3);\n        brdf += dif*0.5;\n        \n        float tx=  tex(pos);\n        col = sin(vec3(1.5+mo.x*0.4,2.2+mo.x*0.25,2.7)+tx*1.2+4.2)*0.6+0.55;\n        col = col*brdf + spe*.5/sqrt(rz) +.25*fre;\n        \n        col = mix(col,vec3(.0),clamp(exp(rz*0.43-4.),0.,1.));\n    }\n    \n    col = clamp(col*1.05,0.,1.);\n    col *= pow(smoothstep(0.,.2,(bp.x + 1.)*(bp.y + 1.)*(bp.x - 1.)*(bp.y - 1.)),.3);\n    col *= smoothstep(3.9,.5,sin(p.y*.5*iResolution.y+time*10.))+0.1;\n    col -= hash(col.xy+p.xy)*.025;\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSGRh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1007, 1106, 1127, 1127, 1179], [1180, 1180, 1199, 1199, 1262], [1282, 1306, 1332, 1332, 1394], [1396, 1396, 1415, 1415, 1527], [1529, 1529, 1566, 1566, 1795], [1797, 1797, 1821, 1821, 1983], [1985, 2037, 2061, 2061, 2156], [2158, 2158, 2179, 2179, 2427], [2429, 2676, 2723, 2797, 2983], [2985, 2985, 3008, 3008, 3126], [3128, 3128, 3174, 3174, 3418], [3420, 3420, 3477, 3477, 5163]], "test": "untested"}
{"id": "4lSGRm", "name": "Swirling rings", "author": "jimmikaelkael", "description": "Just my fun of the day.", "tags": ["swirl", "rings", "swirling"], "likes": 3, "viewed": 156, "published": "Public", "date": "1427483803", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ID_NONE         -1.0\n#define ID_RING_0        0.10\n#define ID_RING_1        0.11\n#define ID_RING_2        0.12\n#define ID_RING_3        0.13\n\nconst vec4 RING_0     = vec4(5.0, 0.0, 0.0, ID_RING_0);\nconst vec4 RING_1     = vec4(5.1, 0.0, 0.0, ID_RING_1);\nconst vec4 RING_2     = vec4(5.2, 0.0, 0.0, ID_RING_2);\nconst vec4 RING_3     = vec4(5.3, 0.0, 0.0, ID_RING_3);\n\nconst vec3 lightPos = vec3(-15.0, 0.0, -15.0);\nconst vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\nfloat sdBox(in vec3 p, in vec3 box) {\n    vec3 d = abs(p) - box;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(vec3 p, float s) {\n    return length(p) - s;\n}\n\nvec3 rotateY(in vec3 p, float an) {\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(in vec3 p, float an) {\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nvec2 map(in vec3 p) {\n    // hit object ID is stored in res.x, distance to object is in res.y\n\n    float sz = 0.2;\n    float time = iTime;\n    float time2 = sin(iTime * 0.25) * 8.0;\n\n    float d1 = sdBox(rotateZ(rotateY(p, 0.75 + time), 0.0 - time2), vec3(sz, RING_0.x, RING_0.x));\n    float d2 = sdSphere(p, RING_0.x);\n    vec2 res = vec2(ID_RING_0, max(-d2, max(d1, sdSphere(p, RING_0.x))));\n\n    d1 = sdBox(rotateZ(rotateY(p, -0.75 + time), -0.75 - time2), vec3(sz, RING_1.x, RING_1.x));\n    d2 = sdSphere(p, RING_1.x);\n    vec2 obj = vec2(ID_RING_1, max(-d2, max(d1, sdSphere(p, RING_1.x))));\n    if (obj.y < res.y) res = obj;\n\n    d1 = sdBox(rotateZ(rotateY(p, 0.0 + time), -1.5 - time2), vec3(sz, RING_2.x, RING_2.x));\n    d2 = sdSphere(p, RING_2.x);\n    obj = vec2(ID_RING_2, max(-d2, max(d1, sdSphere(p, RING_2.x))));\n    if (obj.y < res.y) res = obj;\n\n    d1 = sdBox(rotateZ(rotateY(p, -0.75 + time), 0.75 - time2), vec3(sz, RING_3.x, RING_3.x));\n    d2 = sdSphere(p, RING_3.x);\n    obj = vec2(ID_RING_3, max(-d2, max(d1, sdSphere(p, RING_3.x))));\n    if (obj.y < res.y) res = obj;\n           \n    return res;\n}\n\nvec2 raymarchScene(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    vec3 res = vec3(ID_NONE);\n    float t = tmin;\n    for (int i = 0; i < 280; i++) {\n        vec3 p = ro + rd * t;\n        res = vec3(map(p), t);\n        float d = res.y;\n        if (d < (0.001 * t) || t > tmax)\n            break;\n        t += 0.75 * d;\n     }\n     return res.xz;\n}\n\nvec3 getNormal(in vec3 p) {\n    vec2 eps = vec2(0.00015, 0.0);\n    return normalize(vec3(map(p + eps.xyy).y - map(p - eps.xyy).y,\n                          map(p + eps.yxy).y - map(p - eps.yxy).y,\n                          map(p + eps.yyx).y - map(p - eps.yyx).y));\n}\n\nfloat raymarchAO(in vec3 ro, in vec3 rd, float tmin) {\n    float ao = 0.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        float t = tmin + pow(i / 5.0, 2.0);\n        vec3 p = ro + rd * t;\n        float d = map(p).y;\n        ao += max(0.0, t - 0.5 * d - 0.05);\n    }\n    return 1.0 - 0.5 * ao;\n}\n\nfloat raymarchShadows(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    float sh = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 40; i++) {\n        vec3 p = ro + rd * t;\n        float d = map(p).y;\n        sh = min(sh, 4.0 * d / t);\n        t += 0.75 * d;\n        if (d < (0.001 * t) || t > tmax)\n            break;\n    }\n    return sh;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.05, -20.0);\n    vec3 rd = normalize(vec3(p.xy, 2.5));\n\n    // background\n    vec3 col = vec3(0.0);\n\n    float tmin = 0.1;\n    float tmax = 50.0;\n    vec2 obj = raymarchScene(ro, rd, tmin, tmax);\n    float id = obj.x;\n    float t = obj.y;\n    if (t < tmax) {\n        vec3 pos = ro + rd * t;\n        if (id == ID_RING_0) col = vec3(0.2);\n        if (id == ID_RING_1) col = vec3(0.0, 0.15, 0.5);\n        if (id == ID_RING_2) col = vec3(0.0, 0.5, 0.15);\n        if (id == ID_RING_3) col = vec3(0.5, 0.075, 0.075);\n\n        vec3 nor = getNormal(pos);\n        float occ = clamp(raymarchAO(pos, nor, tmin), 0.0, 1.0);\n\n        // point light\n        vec3 lDir = normalize(lightPos - pos);\n        float lDist = length(lightPos - pos);\n        float dif = 0.1 + max(0.0, dot(nor, lDir));\n        vec3 h = normalize(-rd + lDir);\n        float spe = pow(clamp(dot(h, nor), 0.0, 1.0), 16.0);\n        vec3 lightColor = dif * lightColor * (10.0 / lDist);\n        lightColor += 5.0 * dif * spe * vec3(1.0, 1.0, 1.0);\n\n        float sha = clamp(raymarchShadows(pos, lDir, tmin, tmax), 0.15, 1.0);\n        col *= lightColor * sha * occ;\n    }\n\n    // gamma correction\n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor = vec4(pow(col, gamma), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[468, 468, 505, 505, 602], [604, 604, 637, 637, 665], [667, 667, 702, 702, 811], [813, 813, 848, 848, 956], [958, 958, 979, 1051, 2078], [2080, 2080, 2154, 2154, 2438], [2440, 2440, 2467, 2467, 2707], [2709, 2709, 2763, 2763, 3004], [3006, 3006, 3077, 3077, 3350], [3352, 3352, 3409, 3409, 4736]], "test": "untested"}
{"id": "4lSGRW", "name": "Flowy Flame", "author": "zeroevilz", "description": "Based on the code from https://www.shadertoy.com/view/ldXGRl\n\nShader practice", "tags": ["noise", "flame"], "likes": 5, "viewed": 321, "published": "Public", "date": "1427072590", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Based on the code from https://www.shadertoy.com/view/ldXGRl\n//Trying to learn shader mode :)\n\n// speed of perturbations\nconst float PSPEED1 = 2.0;\nconst float PSPEED2 = 2.5;\nconst float PSPEED3 = 1.2;\n// speed of flame cores\nvec2 CORESPEED = vec2(-2.0, 2.0);\nconst vec3 color1 = vec3(0.4, 0.4, 0.8);\nconst vec3 color2 = vec3(0.8, 0.4, 0.4);\nconst vec3 color3 = vec3(-0.5, -0.5, -0.5);\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n);\n\tvec2 f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    vec2 pos = fragCoord.xy;\n    float scale = (iResolution.y*2.0-fragCoord.y)*0.02;\n    pos.y *= scale;\n    pos.x *= -scale;\n\tvec2 p = pos.xy / iResolution.xy;\n\tvec2 r = vec2(noise(p - iTime*PSPEED1), \n                  noise(-p - iTime*PSPEED2));\n\tvec3 c = mix(color1, color2, noise(p + r + CORESPEED*iTime));\n    vec2 r2 = vec2(0.0, \n                  noise(p - iTime*2.5));\n    float yRatio = (fragCoord.y/iResolution.y); \n    float yRatioBtm = -1.5, \n          yRatioTop = 1.3 + sin(fragCoord.x*0.05-iTime*2.9)*0.2;\n    yRatio = mix(yRatioBtm,yRatioTop,yRatio);\n    float v = noise(p + r2 - vec2(3.0,5.3)*iTime*PSPEED3);\n    c = mix(c, color3, v+yRatio);\n    \n    fragColor = vec4(c, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lSGRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[204, 389, 409, 409, 476], [478, 478, 499, 499, 702], [704, 704, 761, 761, 1462]], "test": "untested"}
{"id": "4lsGW2", "name": "pastel_waves", "author": "echophon", "description": "daily", "tags": ["shadeaday"], "likes": 0, "viewed": 101, "published": "Public", "date": "1425265850", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float j = 0.10, k = 0.3;\n    float time = iTime * sin(iTime*0.01);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = 1.0-uv;\n    time -= distance(2.0+p, uv*2.0);\n    j += 1.0-sin(uv.y*k);\n    k *= cos(uv.y*k)* time;\n    k *= mod(uv.x*j, j*k*sin(time));\n    uv += dot(uv.x * j, uv.y * k);\n    uv += mod(1.0-p, 1.0-sin(uv));\n    uv += reflect(uv.xy, p.yx);\n    uv /= mix(uv, uv/p, p*uv);\n    \n    \n    fragColor = vec4(uv-0.5, uv.x*uv.y, j*k*uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 513]], "test": "untested"}
{"id": "4lsGWf", "name": "lowres metaballs", "author": "germangb", "description": "A few metaballs", "tags": ["raymarching", "metaballs"], "likes": 9, "viewed": 413, "published": "Public", "date": "1425760373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define BIG_PIXELS\n\nmat2 rotate (float angle) {\n \treturn mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));   \n}\n\n#define METABALL(i) meta-=0.75*0.65/pow(length(vec3(sin(iTime*0.1 + float(i)*128.0),sin(iTime*0.1 - float(i)*64.0),cos(iTime*0.1 - float(i)*16.0))*2.25-p), g);\n\nfloat volume (vec3 p) {\n    float meta = 0.0;\n    float g = 2.125;\n    METABALL(0);  METABALL(2);  METABALL(3);  METABALL(4);\n    METABALL(5);  METABALL(6);  METABALL(7);  METABALL(8);\n    METABALL(9);  METABALL(10); METABALL(11); METABALL(12);\n    METABALL(13); METABALL(14);\n    return min(p.y + 3.25, meta + 1.0);\n}\n\nvec3 normal (vec3 p) {\n \tvec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\n    \tvolume(p + eps.xyy) - volume(p - eps.xyy),\n        volume(p + eps.yxy) - volume(p - eps.yxy),\n        volume(p + eps.yyx) - volume(p - eps.yyx)\n    ));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    #ifdef BIG_PIXELS\n    uv.xy = floor(uv.xy*26.0)/26.0;\n\t#endif\n    \n    vec3 sun = normalize(vec3(0.0, -1.0, 0.0));\n    vec3 fog = vec3(1.0);\n    vec3 color = vec3(1.0);\n   \tvec3 ro = vec3(uv, -5.0);\n    vec3 rd = normalize(vec3(uv * .75, 1.0));\n  \n    float h = 0.0;\n    for (int i = 0; i < 150; ++i) {\n     \tvec3 p = ro+h*rd;\n        float tr = volume(p);\n        h += max(0.01, tr);\n       \n        if (h > 14.0) break;\n        if (tr < 0.0) {\n            vec3 n = normal(p);\n            float shade = clamp(dot(n, -sun), 0.0, 1.0);\n            float shade2 = clamp(dot(n, normalize(vec3(-1.0, -1.0, 0.0))), 0.0, 1.0);\n        \tcolor = vec3(1.0, 0.9, 0.7)*1.5*mix(0.2, 1.0, shade);\n            color += vec3(0.2, 0.2, 0.5)*0.25 * shade2;\n            \n            if (p.y < -3.0 + 1e-6) {\n                \n                color -= mix(0.0, 0.25, rand(floor(p.xz*0.5)));\n                \n             \tfloat sh = 0.1;\n                for (int i = 0; i < 16; ++i) {\n                 \tvec3 pp = p + sh * vec3(0.0, 1.0, 0.0);\n                    float si = volume(pp);\n                    sh += max(0.01, si);\n                    if (sh > 4.0) break;\n                    if (si < 0.0) {\n                     \tcolor *= 1.0 - exp(-max(0.0, length(pp-p)-0.125) * 3.5);\n                        break;   \n                    }\n                }\n            }\n            \n            float asd = clamp(dot(n, normalize(ro-p)), 0.0, 1.0);\n            color = mix(color*2.0, color, smoothstep(0.1, 0.50, asd));\n            color = mix(vec3(0.5), color, smoothstep(0.0, 0.5, asd));\n           \tcolor = mix(color, fog, 1.0-exp(-length(p)*0.25));\n            break;\n        }\n    }\n    \n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    uv2 = uv2 * 2.0 - 1.0;\n    #ifdef BIG_PIXELS\n    uv2.xy = floor(uv2.xy*26.0)/26.0;\n    #endif\n    color *= smoothstep(2.25, 1.65 - 0.75, length(uv2));\n    \n    fragColor = vec4(pow(color, vec3(0.7)), 1.0);\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 49, 49, 134], [297, 297, 320, 320, 615], [617, 617, 639, 639, 856], [858, 858, 878, 878, 950], [952, 952, 1009, 1009, 3052]], "test": "untested"}
{"id": "4lsGWs", "name": "shadeaday ( 3 / 11 / 2015 )", "author": "cabbibo", "description": "Trying to get a bit of glitter for the metaballs. Cool effect, but definitely doesn't look sparkly enough...", "tags": ["shadeaday"], "likes": 2, "viewed": 1221, "published": "Public", "date": "1426204274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .00001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 80;\n\t\nvec4 spherePos[10];\n    \nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 noiseVec( vec3 p ){\n    \n    float x = rand( p.xy * 3015010.);\n    float y = rand( p.yz * 526.);\n    float z = rand( p.zx * 1000.541 );\n \n    return normalize(normalize(vec3( x , y , z )) - vec3( .5 ));\n    \n}\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p )\n{\n    \n    float f = sin( p.z * 5. ) * sin( p.x * 5. );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y - (abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\n\nfloat sdSphere( vec3 p, float s , float offset)\n{\n\n\n    float d1 = length(p) - .1*smoothstep(0.0,1.0,iTime);;\n    d1 *= .8;\t\n    \n   // vec3 nP = vec3( x , y , z );\n    return d1 -s;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \tvec2 res = vec2( 10000. , 0.);// vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    for( int i = 0; i < 20; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , spherePos[i].w  , float( i )) , float(i) + 1.);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    for( int i =0; i < 20; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n    \tspherePos[i] = vec4( x ,  y ,  z , r  );\n        \n        \n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n    vec3 lightPos = vec3( 2. , 1. , 0. );\n    \n    vec3 col = vec3( 0. );//vec3( .8 , .8 , .8 ); \n   \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 nor = calcNormal( pos );\n        \n        vec3 lightDir = lightPos - pos;\n        lightDir = normalize( lightDir );\n        \n        vec3 shinyNorm = normalize( noiseVec( pos ) * .2 + nor);\n        \n        vec3 shinyRefl = reflect( lightDir , shinyNorm );\n        float shinyMatch = max( 0. , dot( shinyRefl , rd ) );\n        \n        float AO = calcAO( pos , nor );\n        \n        float match = -dot( nor , rd );\n        \n\n       // float c = pow(( 1.-AO) , 5.)*  10.;\n        float c = 0.;\n        //c += pow((1.- match),4.) * 1.;\n        c += pow(( 1.-AO) , 5.)*  2.;\n       // col = vec3( c );// * .4 * ( nor * .5 + .5 );\n       \n        col = hsv( c ,1.,1.) * c;\n        col += pow( shinyMatch , 1. ) * hsv(abs(sin(shinyMatch*2.)) , 1. , 1. );\n        //col = vec3( shinyMatch );\n       /* if( res.y < .5 ){\n            \n            float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n            col *= abs( f );\n            col /= pow( length( pos ), 4.);\n        }*/\n    }\n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lsGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 357, 394, 394, 526], [528, 528, 548, 548, 620], [622, 622, 646, 646, 836], [838, 838, 903, 903, 1087], [1090, 1090, 1135, 1135, 1175], [1177, 1177, 1202, 1202, 1372], [1376, 1376, 1425, 1425, 1560], [1562, 1562, 1600, 1600, 1771], [1773, 1804, 1868, 1868, 2046], [2048, 2048, 2131, 2131, 2244], [2249, 2343, 2372, 2372, 2415], [2417, 2453, 2494, 2494, 2565], [2567, 2567, 2602, 2602, 2641], [2642, 2726, 2747, 2747, 3211], [3215, 3215, 3263, 3263, 3730], [3732, 3845, 3876, 3876, 4102], [4105, 4105, 4179, 4179, 4440], [4443, 4443, 4485, 4485, 4784], [4787, 4787, 4843, 4843, 7166]], "test": "untested"}
{"id": "4lX3Df", "name": "Band Stretch", "author": "echophon", "description": "editing / remixing code & slowly learning", "tags": ["shadeaday"], "likes": 2, "viewed": 165, "published": "Public", "date": "1425534728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//an edit of shader found at http://glslsandbox.com/e#20524.3\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec2 resolution;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\tvec2 a; \n\ta.xy = iResolution.yx * 0.0245; \t\n    vec2 p = ( fragCoord.xy / a.xy ) * 0.169125;\n\tvec2 q = vec2( 1.0-cos(p.x), 1.0-sin(p.y) );\n\ttime = time*2.0 + q.x / q.y / length( q );\n\t\n\tvec3 c = 1.0-vec3( 1.05 );\n\t\n\tc += vec3(0.10, 0.5, 0.05) * fract( (              p.x + p.y + sin(time*0.5) ) * 0.54 ) ;\n\tc *= vec3(0.5, 2.0, 0.5) * fract( (sin(time*0.0005)*p.x - cos(time*0.015)*p.y + fract(time*0.005) ) * 15.0 ) ;\n\tc *= dot(p.x/p.y,( p.x * p.y ));\n    c -= 1.0-vec3(0.10,0.25,0.175)*vec3(p, 0.95);\n    \n    float fd = 1.0-(p.y+p.x);\n\tfragColor = vec4( c+fd, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lX3Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 127, 184, 184, 780]], "test": "untested"}
{"id": "4lXGWl", "name": "Sin Rotate Pattern", "author": "gaz", "description": "2d", "tags": ["2d"], "likes": 3, "viewed": 137, "published": "Public", "date": "1425951317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    float t = iTime;\n    vec2 q = p;\n    //q = pow(q, vec2(3.0));\n    if (mod(t, 10.0) - 5.0 > 0.0)\n    {\n    \tp.x += 1.5 * sin(q.y *  5.0+ t) + 0.6 * cos(q.y *  2.0+ t * 3.0);\n    \tp.y += 2.0 * sin(q.x * 30.0+ t) + 0.8 * cos(p.x * 15.0+ t * 2.0);    \n    } else {\n    \tp.x += 1.5 * cos(q.y * 20.0 + t)+ 0.5 * cos(q.y * 4.0 + t * 3.0);\n    \tp.y += 1.5 * sin(q.x * 15.0 + t)+ 0.5 * sin(q.x * 5.0 + t * 2.0);\n    }    \n    p *= rotate(atan(-p.x, p.y));\n    fragColor = vec4(clamp(p.y * 0.2, 0.0, 1.0));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4lXGWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 72], [74, 74, 131, 131, 699]], "test": "untested"}
{"id": "4t23RR", "name": "Toon Cloud", "author": "AntoineC", "description": "Simple 2D layered animation. Better in full screen (could become a screen saver?) ", "tags": ["2d", "minimalist"], "likes": 134, "viewed": 4283, "published": "Public", "date": "1426631078", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ----------------------------------------------------------------------------------------\n//\t\"Toon Cloud\" by Antoine Clappier - March 2015\n//\n//\tLicensed under:\n//  A Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International License.\n//\thttp://creativecommons.org/licenses/by-nc-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n#define TAU 6.28318530718\n\n\nconst vec3 BackColor\t= vec3(0.0, 0.4, 0.58);\nconst vec3 CloudColor\t= vec3(0.18,0.70,0.87);\n\n\nfloat Func(float pX)\n{\n\treturn 0.6*(0.5*sin(0.1*pX) + 0.5*sin(0.553*pX) + 0.7*sin(1.2*pX));\n}\n\n\nfloat FuncR(float pX)\n{\n\treturn 0.5 + 0.25*(1.0 + sin(mod(40.0*pX, TAU)));\n}\n\n\nfloat Layer(vec2 pQ, float pT)\n{\n\tvec2 Qt = 3.5*pQ;\n\tpT *= 0.5;\n\tQt.x += pT;\n\n\tfloat Xi = floor(Qt.x);\n\tfloat Xf = Qt.x - Xi -0.5;\n\n\tvec2 C;\n\tfloat Yi;\n\tfloat D = 1.0 - step(Qt.y,  Func(Qt.x));\n\n\t// Disk:\n\tYi = Func(Xi + 0.5);\n\tC = vec2(Xf, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi+ pT/80.0));\n\n\t// Previous disk:\n\tYi = Func(Xi+1.0 + 0.5);\n\tC = vec2(Xf-1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi+1.0+ pT/80.0));\n\n\t// Next Disk:\n\tYi = Func(Xi-1.0 + 0.5);\n\tC = vec2(Xf+1.0, Qt.y - Yi ); \n\tD =  min(D, length(C) - FuncR(Xi-1.0+ pT/80.0));\n\n\treturn min(1.0, D);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Setup:\n\tvec2 UV = 2.0*(fragCoord.xy - iResolution.xy/2.0) / min(iResolution.x, iResolution.y);\t\n\t\n\t// Render:\n\tvec3 Color= BackColor;\n\n\tfor(float J=0.0; J<=1.0; J+=0.2)\n\t{\n\t\t// Cloud Layer: \n\t\tfloat Lt =  iTime*(0.5  + 2.0*J)*(1.0 + 0.1*sin(226.0*J)) + 17.0*J;\n\t\tvec2 Lp = vec2(0.0, 0.3+1.5*( J - 0.5));\n\t\tfloat L = Layer(UV + Lp, Lt);\n\n\t\t// Blur and color:\n\t\tfloat Blur = 4.0*(0.5*abs(2.0 - 5.0*J))/(11.0 - 5.0*J);\n\n\t\tfloat V = mix( 0.0, 1.0, 1.0 - smoothstep( 0.0, 0.01 +0.2*Blur, L ) );\n\t\tvec3 Lc=  mix( CloudColor, vec3(1.0), J);\n\n\t\tColor =mix(Color, Lc,  V);\n\t}\n\n\tfragColor = vec4(Color, 1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t23RR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-4.0", "functions": [[0, 517, 539, 539, 610], [613, 613, 636, 636, 689], [692, 692, 724, 724, 1268], [1272, 1272, 1329, 1340, 1934]], "test": "untested"}
{"id": "4t23Rw", "name": "Shiny Galaxy", "author": "guil", "description": "A shinier version of my previous shader", "tags": ["3d", "galaxy"], "likes": 36, "viewed": 1334, "published": "Public", "date": "1427664066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n// Galaxy morphology based on http://iopscience.iop.org/0004-637X/783/2/138/pdf/0004-637X_783_2_138.pdf\n\nfloat zoom=1.;\nconst float arms = 2.;\nconst float winding = 12.;\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\nconst mat2 m2 = mat2(.8,.6,-.6,.8);\n\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=2.;\n\tfor( int i=0; i< 4; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.0;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/4.;\n}\n\nfloat noise(in vec3 p)\n{\n   \n\tp*=2.;\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p.xy=m2*p.xy;\n        p=p.zxy*f+.6;     \n        f*=1.15;\n        res+=sin(p.y+1.3*sin(1.2*p.x)+1.7*sin(1.7*p.z));\n\t}        \t\n\treturn res/3.;\n\n}\n\n\nfloat fbmdisk( vec3 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<5;i++){\t\n\t\tr += abs(noise( p*(f) ))/f;       \n\t    f +=f;\n        \n\t}\n\treturn 1.2/(.07+r);\n}\n\n\nfloat fbmgal( vec3 p ) {\n    \n    p=p*4.;\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<5;i++){\t\n\t\tr += noise( p*(20.+3.*f) )/f; \n        p.xz*=m2;\n\t    f +=1.;\n        \n\t}\n\treturn pow(abs(r),4.);\n}\n\n\n\nfloat fbmdust( vec3 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<5;i++){\t\n\t\tr += 1./abs(noise( p*(f) ))/f;       \n\t    f +=f;\n        \n\t}\n\treturn pow(abs(1.-1./(.01+r)),4.);\n}\n\n\nfloat theta(float r, float wb, float wn){\n\treturn atan(exp(1./r)/wb)*2.*wn;\n}\n\nfloat arm(float n, float aw, float wb, float wn,vec2 p){\n    float t = atan(p.y,p.x);\n    float r = length(p);    \n\treturn pow(1.-.15*sin((theta(r,wb,wn)-t)*n),aw)*exp(-r*r)*exp(-.07/r);\n}\n\n\nfloat bulb(vec2 p){\n    float r = exp(-dot(p,p)*1.2);\n    //p.y-=.2;\n\treturn (.8*r+2.*exp(-dot(p,p)*16.));\n}\n\n\nfloat map(in vec3 p) {\n\tvec2 q=p.xz;\n    vec3 res= vec3(0.);\n\tfloat a= arm(arms,6.,.7,winding,q);\n    float r = max(a+.5,bulb(q));\n    return 4.*exp(-28.*(abs(p.y)-r/16.));\n}\n\n\n\nvec3 raymarch( in vec3 ro, vec3 rd)\n{\n    float t = 1.5;\n    float dt = .065;\n    vec3 col= vec3(0.);\n    float c = 0.,s=0.,d=0.;\n    for( int i=0; i<50; i++ )\n\t{\n        t+=dt*exp(-.2*c*s);\n        if(t>6.)break;\n        vec3 pos = ro+t*rd;\n        \n        c = map(pos);\n        if(c>.2){\n        \ts = fbmdisk(pos*32.)/1.5;\n        \td = fbmdust(pos*4.)/4.;\n            c*=d;\n        }\n        //col = .98*col+ .05*vec3(c*c*c, c*c, c);\t\n        col = .98*col+ .02*vec3(c*c, 1.3*c*s,1.8* s)*c;\n        \n    }    \n    return .8*col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(2.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.05*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n      \n\n\t// raymarch\n    vec3 col = raymarch(ro,rd);\n    float g = .4*fbmgal(rd);\n    col +=.3*vec3(g*g*g, g*g*1.3, 1.5*g);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t23Rw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 291, 310, 310, 357], [398, 398, 421, 421, 596], [598, 598, 622, 622, 855], [858, 858, 883, 883, 1031], [1034, 1034, 1058, 1058, 1241], [1245, 1245, 1270, 1270, 1436], [1439, 1439, 1480, 1480, 1516], [1518, 1518, 1574, 1574, 1706], [1709, 1709, 1728, 1728, 1817], [1820, 1820, 1842, 1842, 1994], [1998, 1998, 2035, 2035, 2531], [2534, 2534, 2591, 2591, 3377]], "test": "untested"}
{"id": "4t2GRm", "name": "Tetrahedron with depth", "author": "candycat", "description": "A rotating tetrahedron. Dased lines and color to offer depth infomation.", "tags": ["tetrahedron"], "likes": 45, "viewed": 7425, "published": "Public", "date": "1427708288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265358979\n#define sqrt3_divide_6 0.289\n#define sqrt6_divide_12 0.204\n\nconst float seg = 4.0;\nconst float segwidth = 1./(2.*seg-1.);\n\nfloat _CircleRadius = 0.10;\nfloat _OutlineWidth = 0.02;\nfloat _LineWidth = 0.08;\nvec4 _OutlineColor = vec4(0.,0.,0.,0.);\nvec4 _FrontColor = vec4(186.0/256.0,42.0/256.0,42.0/256.0,1.);\nvec4 _BackColor = vec4(120.0/256.0,30.0/256.0,30.0/256.0,1.);\nvec4 _BackgroundColor = vec4(227./256.,206./256.,178./256.,1.);\n\n//======================\n// Line functions\n//======================\nfloat line(vec2 pos, vec2 point1, vec2 point2, float width) {\n    vec2 dir0 = point2 - point1;\n    vec2 dir1 = pos - point1;\n    float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n    float d = (length(dir1 - dir0 * h) - width * 0.5);\n    return d;\n}\n\nvec4 line_with_color(vec2 pos, vec2 point1, vec2 point2, float width) {   \t\t\n    float d = line(pos, point1, point2, width);\n    float w = fwidth(0.5*d) * 2.0;\n    vec4 layer0 = vec4(_OutlineColor.rgb, 1.-smoothstep(-w, w, d - _OutlineWidth));\n    vec4 layer1 = vec4(_FrontColor.rgb, 1.-smoothstep(-w, w, d));\n    \n    return mix(layer0, layer1, layer1.a);\n}\n\n//======================\n// Dashed line functions\n//======================\nfloat dashedline(vec2 pos, vec2 point1, vec2 point2, float width) {\n    vec2 prePoint = point1;\n    vec2 curPoint = point1*(1.-segwidth)+segwidth*point2;\n    float d = 1.;\n    for (float t=segwidth; t<1.01; t+=2.*segwidth) {\n        curPoint = point1*(1.-t)+t*point2;\n        d = min(d, line(pos, prePoint, curPoint, width));\n        prePoint = point1*(1.-(t+segwidth))+(t+segwidth)*point2;\n    }\n    return d;\n}\n\nvec4 dashedline_with_color(vec2 pos, vec2 point1, vec2 point2, float width) {   \t\n    float d = dashedline(pos, point1, point2, width);\n    float w = fwidth(0.5*d) * 2.0;\n    vec4 layer0 = vec4(_OutlineColor.rgb, 1.-smoothstep(-w, w, d - _OutlineWidth));\n    vec4 layer1 = vec4(_BackColor.rgb, 1.-smoothstep(0., w, d));\n    \n    return mix(layer0, layer1, layer1.a);\n}\n\n//======================\n// Circle functions\n//======================\nfloat circle(vec2 pos, vec2 center, float radius) {\n    float d = length(pos - center) - radius;\n    return d;\n}\n\nvec4 circle_with_color(vec2 pos, vec2 center, float radius, vec4 color) {\n    float d = circle(pos, center, radius);\n    float w = fwidth(0.5*d) * 2.0;\n    vec4 layer0 = vec4(_OutlineColor.rgb, 1.-smoothstep(-w, w, d - _OutlineWidth));\n    vec4 layer1 = vec4(color.rgb, 1.-smoothstep(0., w, d));\n    \n    return mix(layer0, layer1, layer1.a);\n}\n\n//======================\n// Helper functions\n//======================\nvoid setlayer(inout vec4 layers[6], int index, vec4 val) {\n    if (index == 0) {\n        layers[0] = val;\n    } else if (index == 1) {\n        layers[1] = val;\n    } else if (index == 2) {\n        layers[2] = val;\n    } else if (index == 3) {\n        layers[3] = val;\n    } else if (index == 4) {\n        layers[4] = val;\n    } else if (index == 5) {\n        layers[5] = val;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 originalPos = (2.0 * fragCoord - iResolution.xy)/iResolution.yy;\n    vec2 pos = originalPos;\n\n    // Apply X Y Z rotations\n    // Find more info from http://en.wikipedia.org/wiki/Rotation_matrix\n    float xSpeed = 0.3*iTime+iMouse.x*0.01;\n    float ySpeed = 0.5*iTime+iMouse.y*0.01;\n    float zSpeed = 0.7*iTime;\n    mat3 matrix = mat3(1., 0., 0.,\n                      0., cos(xSpeed), sin(xSpeed),\n                      0., -sin(xSpeed), cos(xSpeed));\n    matrix = mat3(cos(ySpeed), 0., -sin(ySpeed),\n                      0., 1., 0.,\n                      sin(ySpeed), 0., cos(ySpeed))*matrix;\n    matrix = mat3(cos(zSpeed), sin(zSpeed), 0.,\n                 \t  -sin(zSpeed), cos(zSpeed), 0.,\n                 \t  0., 0., 0.)*matrix;\n    \n    float l = 1.5;\n    vec3 p[4];\n    p[0] = vec3(0., 0., sqrt6_divide_12 * 3.) * l;\n    p[1] = vec3(-0.5, -sqrt3_divide_6, -sqrt6_divide_12) * l;\n    p[2] = vec3(0.5, -sqrt3_divide_6, -sqrt6_divide_12) * l;\n    p[3] = vec3(0, sqrt3_divide_6 * 2., -sqrt6_divide_12) * l;\n\n    for (int i = 0; i < 4; i++) {\n        p[i] = matrix * p[i];\n    }\n    \n    // Compure normals\n    vec3 normalOf012 = cross(p[1]-p[0], p[2]-p[0]);\n    vec3 normalOf013 = cross(p[3]-p[0], p[1]-p[0]);\n    vec3 normalOf023 = cross(p[2]-p[0], p[3]-p[0]);\n    vec3 normalOf123 = cross(p[3]-p[1], p[2]-p[1]);\n\n    vec4 layers[6];\n    int upperLayer = 0;\n    int underlayer = 5;\n    float circleColors[4];\n    for (int i = 0; i < 4; i++) {\n        circleColors[i] = -1.;\n    }\n    \n    if (normalOf012.z < 0. && normalOf013.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[0].xy, p[1].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[0].xy, p[1].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[0] = 1.;\n        circleColors[1] = 1.;\n    }\n    if (normalOf012.z < 0. && normalOf123.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[1].xy, p[2].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[1].xy, p[2].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[1] = 1.;\n        circleColors[2] = 1.;\n    }\n    if (normalOf023.z < 0. && normalOf123.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[2].xy, p[3].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[2].xy, p[3].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[2] = 1.;\n        circleColors[3] = 1.;\n    }\n    if (normalOf023.z < 0. && normalOf012.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[0].xy, p[2].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[0].xy, p[2].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[0] = 1.;\n        circleColors[2] = 1.;\n    }\n    if (normalOf023.z < 0. && normalOf013.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[0].xy, p[3].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[0].xy, p[3].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[0] = 1.;\n        circleColors[3] = 1.;\n    }\n    if (normalOf123.z < 0. && normalOf013.z < 0.) {\n        setlayer(layers, underlayer, dashedline_with_color(pos, p[1].xy, p[3].xy, _LineWidth));\n        underlayer -= 1;\n    } else {\n        setlayer(layers, upperLayer, line_with_color(pos, p[1].xy, p[3].xy, _LineWidth));\n        upperLayer += 1;\n        circleColors[1] = 1.;\n        circleColors[3] = 1.;\n    }\n    \n    // Background\n\tfragColor = vec4(_BackgroundColor.rgb * (1.0-0.2*length(originalPos)), 1.);\n    for (int i = 5; i >= 0; i--) {\n        fragColor = mix(fragColor, layers[i], layers[i].a);\n    }\n    \n    for (int i = 0; i < 4; i++) {\n        if (circleColors[i] > 0.) {\n            vec4 c = circle_with_color(pos, p[i].xy, _CircleRadius, _FrontColor);\n            fragColor = mix(fragColor, c, c.a);\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4t2GRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[462, 530, 591, 591, 789], [791, 791, 862, 862, 1149], [1151, 1226, 1293, 1293, 1638], [1640, 1640, 1717, 1717, 2008], [2010, 2080, 2131, 2131, 2192], [2194, 2194, 2267, 2267, 2538], [2540, 2610, 2668, 2668, 2993], [2995, 2995, 3052, 3052, 7178]], "test": "untested"}
{"id": "4tB3RR", "name": "Gavoronoise 3d", "author": "guil", "description": "A 3d version of my previous shader : https://www.shadertoy.com/view/llsGWl", "tags": ["3d", "voronoi", "noise", "gabor"], "likes": 7, "viewed": 338, "published": "Public", "date": "1426434691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\n\n#define PI 3.14159265358979\n\nint windows = 0;//0=noise,1=abs(noise),2=fbm,3=fbmabs\n\n\nfloat hash( in vec3 p ) \n{\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\n}\n\nvec3 hash3( in vec3 p )\n{\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\n}\n\n//mat2 m2= mat2(.8,.6,-.6,.8);\n\n// Gabor/Voronoi mix 3x3 kernel (some artifacts for v=1.)\nfloat gavoronoi3(in vec3 p)\n{    \n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float f = 4.*PI;//frequency\n    float v = .8;//cell variability <1.\n    float dv = .9;//direction variability <1.\n    vec3 dir = vec3(.1);\n    float va = 0.0;\n   \tfloat wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n    for (int k=-1; k<=1; k++)    \n\t{\t\t\n        vec3 o = vec3(i, j, k)-.5;\n        vec3 h = hash3((ip - o));\n        vec3 pp = fp +o  -h;\n        float d = dot(pp, pp);\n        float w = exp(-d*4.);\n        wt +=w;\n        h = dv*h+dir;//h=normalize(h+dir);\n        va += cos(dot(pp,h)*f/v)*w;\n\t}    \n    return va/wt;\n}\n\n\n// Gabor/Voronoi mix 4x4 kernel (clean but slower)\nfloat gavoronoi4(in vec3 p)\n{    \n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    vec3 dir = vec3(1.);\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\n    float v = .8;//cell variability <1.\n    float dv = .7;//direction variability <1.\n    float va = 0.0;\n   \tfloat wt = 0.0;\n    for (int i=-2; i<=1; i++) \n\tfor (int j=-2; j<=1; j++)\n    for (int k=-2; k<=1; k++)     \n\t{\t\t\n        vec3 o = vec3(i, j, k);\n        vec3 h = hash3(ip - o);\n        vec3 pp = fp +o  -v*h;\n        float d = dot(pp, pp);\n        float w = exp(-d*4.);\n        wt +=w;\n      \th= dv*h+dir;//h=normalize(h+dir);\n        va +=cos(dot(pp,h)*f)*w;\n\t}    \n    return va/wt;\n}\n\n// Gabor/Voronoi mix 5x5 kernel (even slower but suitable for large wavelets)\nfloat gavoronoi5(in vec3 p) \n{    \n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float f = 2.*PI;//frequency\n    float v = 1.;//cell variability <1.\n    float dv = .8;//direction variability <1.\n    vec3 dir = vec3(.7);\n    float va = 0.0;\n   \tfloat wt = 0.0;\n    for (int i=-2; i<=2; i++) \n\tfor (int j=-2; j<=2; j++)\n    for (int k=-2; k<=2; k++)     \n\t{\t\t\n        vec3 o = vec3(i, j, k)-.5;\n        vec3 h = hash3(ip - o);\n        vec3 pp = fp +o  -h;\n        float d = dot(pp, pp);\n        float w = exp(-d*1.);\n        wt +=w;\n        h = dv*h+dir;//h=normalize(h+dir);\n        va += cos(dot(pp,h)*f/v)*w;\n\t}    \n    return va/wt;\n}\n\n  \n\n//concentric waves variant\nfloat gavoronoi3b(in vec3 p)\n{    \n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float f = 4.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\n    float v = .8;//cell variability <1.\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++)\n    for (int k=-1; k<=1; k++)     \n\t{\t\t\n        vec3 o = vec3(i, j, k)-.5;       \t\t\n        vec3 pp = fp +o  - v*hash3(ip - o);\n        float d = dot(pp, pp);\n        float w = exp(-d*4.);\n        wt +=w;\n        va +=sin(sqrt(d)*f)*w;\n\t}    \n    return va/wt;\n}\n\n\nfloat noise( vec3 p)\n{   \n    if(fract(iTime*.1)<.33)return gavoronoi3(p);\n    if(fract(iTime*.1)<.66)return gavoronoi4(p);\n    return gavoronoi3b(p);\n}\n\nfloat fbmabs( vec3 p ) {\n\t\n\tfloat f=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<4;i++){\t\n\t\tr += abs(noise( p*f ))/f;       \n\t    f *=2.2;\n\t}\n\treturn r;\n}\n\nfloat fbm( vec3 p ) {\n\t\n\tfloat f=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<4;i++){\t\n\t\tr += noise( p*f )/f;       \n\t    f *=2.;\n\t}\n\treturn r;\n}\n\nfloat map(vec3 p){\n\n    if(windows==0)return noise(p*4.);\n    if(windows==1)return 2.*abs( noise(p*10.));\n\tif(windows==2)return fbm(p);\n    return 1.2*fbmabs(p);\n}\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = vec3(4.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n    \n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\n\n\tfloat c;\n    \n   \tif (tmm.x<0.)c =  map(rd)/2.;\n    else c= map(ro+rd*tmm.x)/2.;\n    vec3 col = vec3( c,c*c,c*c*c);\n   \n\t\n\t// shade\n    \n    col =  1.5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n}\n\t\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tB3RR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[310, 350, 376, 376, 478], [480, 480, 505, 505, 557], [591, 649, 678, 678, 1292], [1295, 1346, 1375, 1375, 2024], [2026, 2104, 2134, 2134, 2746], [2752, 2779, 2809, 2809, 3337], [3340, 3340, 3362, 3362, 3492], [3494, 3494, 3518, 3518, 3648], [3650, 3650, 3671, 3671, 3795], [3797, 3797, 3815, 3815, 3960], [3963, 3963, 3982, 3982, 4029], [4031, 4031, 4093, 4093, 4279], [4281, 4281, 4338, 4338, 5169]], "test": "untested"}
{"id": "4tB3zD", "name": "Raymarching Attempt 2", "author": "Craxic", "description": "A much much faster version of my first ray marcher. I've noticed that using continuous functions rather than if statements yields much much better results (way more than I expected). Neat!", "tags": ["raymarching"], "likes": 58, "viewed": 2771, "published": "Public API", "date": "1427154367", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright (C) 2015 Matthew Ready\n// Licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Australia license.\n// http://creativecommons.org/licenses/by-nc-sa/3.0/au\n\n#define INNER_RADIUS 0.75\n#define OUTER_RADIUS 0.9\n#define SHEET_THICKNESS 0.012\n#define NOISINESS 10.0\n\n#define INNER_COLOR vec4(0.0, 30.0, 30.0, 1.0)\n#define OUTER_COLOR vec4(20.0, 20.0, 30.0, 1.0)\n\n#define NUM_STEPS 20\n#define TIME_SCALE 5.0\n\nfloat trapezium(float x)\n{\n    //            __________\n    // 1.0 -     /          \\\n    //          /            \\                .\n    // 0.5 -   /              \\              .  --> Repeating\n    //        /                \\            . \n    // 0.0 - /                  \\__________/\n    //\n    //       |    |    |    |    |    |    |\n    //      0.0  1/6  2/6  3/6  4/6  5/6  6/6\n    //\n\treturn min(1.0, max(0.0, 1.0 - abs(-mod(x, 1.0) * 3.0 + 1.0)) * 2.0);\n}\n\nvec3 colFromHue(float hue)\n{\n    // https://en.wikipedia.org/wiki/Hue#/media/File:HSV-RGB-comparison.svg\n\treturn vec3(trapezium(hue - 1.0/3.0), trapezium(hue), trapezium(hue + 1.0/3.0));\n}\n\n// Cheap noise functions. I just messed around with sin functions until\n// I got something I liked. The important thing was to make sure the periods\n// of the sin functions weren't constant and varied over space.\nfloat cnoise3(float pos)\n{\n\treturn (cos(pos / 2.0) * 0.2 + 1.0);\n}\n\nfloat cnoise2(float pos)\n{\n\treturn (sin(pos * cnoise3(pos) / 2.0) * 0.2 + 1.0);\n}\n\nfloat cnoise(vec4 pos)\n{\n    // These values are all very carefully chosen using \n    // lots of very complex mathematics. In other news, \n    // bashing my head on my keyboard is now complex \n    // mathematics\n    float x = pos.x * cnoise2(pos.y) + pos.w * 0.87123 + 82.52;\n    float y = pos.y * cnoise2(pos.z) + pos.w * 0.78725 + 12.76;\n    float z = pos.z * cnoise2(pos.x) + pos.w * 0.68201 + 42.03;\n    return (sin(x) + sin(y) + sin(z)) / 3.0;\n}\n\nvec4 merge_colours(vec4 apply_this, vec4 on_top_of_this)\n{\n    // Very basic colour merging\n    return on_top_of_this * (1.0 - apply_this.a) + apply_this * apply_this.a;\n}\n\nvec4 getdensity(vec3 pos)\n{\n    // This function get's the \"density\" of fog at a position in space (pos)\n    \n    // First, let's make a variable we can reuse for scaled time.\n    float time = iTime * TIME_SCALE;\n    \n    // The next thing to do is decide where to sample the noise functions.\n    // We want the radius of the bubble to be constant along any ray from \n    // the center of the bubble. So, to ensure that we always sample the same\n    // position in the noise function for any ray, we normalize the position\n    // vector (since the origin of the bubble is at 0)\n    vec3 samplePos = normalize(pos);\n    \n    // The inner colour of the buble is just a random colour sampled from the cheap noise function.\n    vec4 inner_color = vec4(colFromHue(cnoise(vec4(samplePos / 5.0, time / 15.0))) * 25.0, 1.0);\n    // The outer colour of the buble is a big whiter than the inside. This helps make the bubble\n    // look more natural.\n    vec4 outer_color = merge_colours(vec4(25.0,25.0,25.0,0.5), inner_color);\n    \n    // Now we're going to sample the noise function to get the radius of the bubble along this ray\n    float sample_ = (cnoise(vec4(samplePos * NOISINESS, time)) + 1.0) / 2.0;\n    // Clamp the noise in case using a different noise function (perlin for example)\n    sample_ = clamp(sample_, 0.0, 1.0);\n    // Calculate the inner and outer most radius boundaries\n    float innerIncBorder = INNER_RADIUS + SHEET_THICKNESS;\n    float outerIncBorder = OUTER_RADIUS - SHEET_THICKNESS;\n    // Calculate the radius of the bubble by linearly interpolating \n    // the noise sample between inner and outer boundaries.\n    float radius = innerIncBorder + (outerIncBorder - innerIncBorder) * sample_;\n    \n    // Calculate the distance between the volume sample position and the center of the bubble\n    float dist = distance(pos, vec3(0.0, 0.0, 0.0));\n    // Calculate the density of the fog. We use a very \"strongly peaking\" function here. \n    // It's almost 0 everywhere except at radius, where it peaks to 1 and then falls to 0 very quickly.\n    // Take a look at it in wolframalpha. \n    float density = exp(-pow(dist - radius, 2.0) * 05000.0);\n    \n    // Calculate final color here. Lerp the inner and outer colours depending on the radius and scale by density\n    return (inner_color + (outer_color - inner_color) * (radius - innerIncBorder) / (outerIncBorder - innerIncBorder)) * density;\n}\n\nvec4 raymarch(vec3 start, vec3 end)\n{\n    // This is the ray marching function. Here, we sample NUM_STEPS points along the vector\n    // between start and end. Then, we integrate the resultant densities linearly.\n    vec4 retn = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec3 delta = end - start;\n    float stepDistance = length(delta) / float(NUM_STEPS);\n    \n    vec4 densityPrevious = getdensity(start);\n    for (int i = 1; i < NUM_STEPS; i++) \n    {\n        vec3 samplePos = start + delta * float(i) / float(NUM_STEPS);\n        vec4 density = getdensity(samplePos);\n        // Integrate the density using linear interpolation\n        // The colours will be the average of the two weighted by their alpha\n        vec4 densityIntegrated = (density + densityPrevious) / 2.0;\n        // Optimised out to return. densityIntegrated *= stepDistance\n        retn += densityIntegrated;\n        \n        densityPrevious = density;\n    }\n    \n    return retn * stepDistance;\n}\n\nvec4 raymarch_ball(vec2 coord)\n{\n\t// Now we're going to intersect a ray from the \n    // coord along the Z axis onto two spheres, one \n    // inside the other (same origin). getdensity \n    // is only > 0 between these volumes.\n    float d = distance(coord, vec2(0.0, 0.0));\n    if (d > OUTER_RADIUS) {\n        // No intersection on the spheres.\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    float dOuterNormalized = d / OUTER_RADIUS;\n    float outerStartZ = -sqrt(1.0 - dOuterNormalized*dOuterNormalized) * OUTER_RADIUS; // sqrt(1-x*x) = function of a circle :)\n    float outerEndZ = -outerStartZ;\n    if (d > INNER_RADIUS) {\n        // The ray only intersects the larger sphere, \n        // so we need to cast from the front to the back\n        \n        // We do it twice so that the number of samples in this branch\n        // is identical to the number of samples \n        // inside the blob. Otherwise we see artifacts with \n        // a lower number of samples.\n        vec4 frontPart = raymarch(vec3(coord, outerStartZ), vec3(coord, 0));\n        vec4 backPart = raymarch(vec3(coord, 0), vec3(coord, outerEndZ));\n        return frontPart + backPart;\n    }\n    \n    float dInnerNormalized = d / INNER_RADIUS;\n    float innerStartZ = -sqrt(1.0 - dInnerNormalized*dInnerNormalized) * INNER_RADIUS; // sqrt(1-x*x) = function of a circle :)\n    float innerEndZ = -innerStartZ;\n    // The ray intersects both spheres.\n    vec4 frontPart = raymarch(vec3(coord, outerStartZ), vec3(coord, innerStartZ));\n    vec4 backPart = raymarch(vec3(coord, innerEndZ), vec3(coord, outerEndZ));\n    vec4 final = frontPart + backPart;\n    return final;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / min(iResolution.x, iResolution.y)) * 2.0 - vec2(iResolution.x / iResolution.y, 1.0);\n    fragColor = merge_colours(raymarch_ball(uv), vec4(0.0, 0.0, 0.0, 1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tB3zD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 437, 463, 829, 902], [904, 904, 932, 1008, 1092], [1094, 1307, 1333, 1333, 1373], [1375, 1375, 1401, 1401, 1456], [1458, 1458, 1482, 1669, 1908], [1910, 1910, 1968, 2001, 2081], [2083, 2083, 2110, 2258, 4493], [4495, 4495, 4532, 4707, 5449], [5451, 5451, 5483, 5678, 7087], [7090, 7090, 7147, 7147, 7337]], "test": "untested"}
{"id": "4tB3zm", "name": "Tetrahedron", "author": "candycat", "description": "Draw a tetrahedron with/without AA. Uncomment line 28 to see the difference between _Antialias and fwidth.", "tags": ["tetrahedron", "aa"], "likes": 17, "viewed": 2093, "published": "Public", "date": "1427527303", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265358979\n#define sqrt3_divide_6 0.289\n#define sqrt6_divide_12 0.204\n\nconst float seg = 3.0;\nconst float segwidth = 1./(2.*seg-1.);\n\nfloat _CircleRadius = 0.1;\nfloat _OutlineWidth = 0.02;\nvec4 _OutlineColor = vec4(0.,0.,0.,0.);\nfloat _LineWidth = 0.08;\nvec4 _LineColor = vec4(186.0/256.0,42.0/256.0,42.0/256.0,0.);\nfloat _Antialias = 0.01;\nvec4 _BackgroundColor = vec4(227./256.,206./256.,178./256.,0.);\n\nfloat line(vec2 pos, vec2 point1, vec2 point2, float width) {   \t\t\n    vec2 dir0 = point2 - point1;\n    vec2 dir1 = pos - point1;\n    float h = clamp(dot(dir0, dir1)/dot(dir0, dir0), 0.0, 1.0);\n    return (length(dir1 - dir0 * h) - width * 0.5);\n}\n\nfloat dashedline(vec2 pos, vec2 point1, vec2 point2, float width) {   \t\t\n    vec2 prePoint = point1;\n    vec2 curPoint;\n    float d = 1.;\n    for (float t=segwidth; t<1.1; t+=2.*segwidth) {\n        curPoint = point1*(1.-t)+t*point2;\n        d = min(d, line(pos, prePoint, curPoint, width));\n        prePoint = point1*(1.-(t+segwidth))+(t+segwidth)*point2;\n    }\n    \n    return d;\n}\n\nfloat circle(vec2 pos, vec2 center, float radius) {\n    float d = length(pos - center) - radius;\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 originalPos = (2.0 * fragCoord - iResolution.xy)/iResolution.yy;\n    vec2 pos = originalPos;\n    \n    // Twist\n    //pos.x += 0.5 * sin(5.0 * pos.y);\n\n    vec2 split = vec2(0, 0); \n    if (iMouse.z > 0.0) {       \n        split = (-iResolution.xy + 2.0 * iMouse.xy) / iResolution.yy;\n    }\n    \n    // Background\n    vec3 col = _BackgroundColor.rgb * (1.0-0.2*length(originalPos));\n    \n    // Apply X Y Z rotations\n    // Find more info from http://en.wikipedia.org/wiki/Rotation_matrix\n    float xSpeed = 0.3;\n    float ySpeed = 0.5;\n    float zSpeed = 0.7;\n    mat3 matrix = mat3(1., 0., 0.,\n                      0., cos(xSpeed*iTime), sin(xSpeed*iTime),\n                      0., -sin(xSpeed*iTime), cos(xSpeed*iTime));\n    matrix = mat3(cos(ySpeed*iTime), 0., -sin(ySpeed*iTime),\n                      0., 1., 0.,\n                      sin(ySpeed*iTime), 0., cos(ySpeed*iTime))*matrix;\n    matrix = mat3(cos(zSpeed*iTime), sin(zSpeed*iTime), 0.,\n                 \t  -sin(zSpeed*iTime), cos(zSpeed*iTime), 0.,\n                 \t  0., 0., 0.)*matrix;\n    \n    float l = 1.5;\n    vec3 p0 = vec3(0., 0., sqrt6_divide_12 * 3.) * l;\n    vec3 p1 = vec3(-0.5, -sqrt3_divide_6, -sqrt6_divide_12) * l;\n    vec3 p2 = vec3(0.5, -sqrt3_divide_6, -sqrt6_divide_12) * l;\n    vec3 p3 = vec3(0, sqrt3_divide_6 * 2., -sqrt6_divide_12) * l;\n    \n    p0 = matrix * p0;\n    p1 = matrix * p1;\n    p2 = matrix * p2;\n    p3 = matrix * p3;\n    \n    vec2 point0 = p0.xy;\n    vec2 point1 = p1.xy;\n    vec2 point2 = p2.xy;\n    vec2 point3 = p3.xy;\n\n    float d = line(pos, point0, point1, _LineWidth);\n    d = min(d, line(pos, point1, point2, _LineWidth));\n    d = min(d, line(pos, point2, point3, _LineWidth));\n    d = min(d, line(pos, point0, point2, _LineWidth));\n    d = min(d, line(pos, point0, point3, _LineWidth));\n    d = min(d, line(pos, point1, point3, _LineWidth));\n    d = min(d, circle(pos, point0, _CircleRadius));\n    d = min(d, circle(pos, point1, _CircleRadius));\n    d = min(d, circle(pos, point2, _CircleRadius));\n    d = min(d, circle(pos, point3, _CircleRadius));\t\n\n    if (originalPos.x < split.x) {\n        col = mix(_OutlineColor.rgb, col, step(0., d - _OutlineWidth));\n\t    col = mix(_LineColor.rgb, col, step(0., d));\n    } else if (originalPos.y > split.y) {\n        float w = _Antialias;\n        col = mix(_OutlineColor.rgb, col, smoothstep(-w, w, d - _OutlineWidth));\n        col = mix(_LineColor.rgb, col, smoothstep(-w, w, d));      \n    } else {\n        float w = fwidth(0.5*d) * 2.0;\n        col = mix(_OutlineColor.rgb, col, smoothstep(-w, w, d - _OutlineWidth));\n        col = mix(_LineColor.rgb, col, smoothstep(-w, w, d));\n    }\n    \n    // Draw split lines\n    col = mix(vec3(0), col, smoothstep(0.005, 0.007, abs(originalPos.x - split.x)));\n    col = mix(col, vec3(0), (1. - smoothstep(0.005, 0.007, abs(originalPos.y - split.y))) * step(split.x, originalPos.x));\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tB3zm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[423, 423, 484, 484, 670], [672, 672, 739, 739, 1054], [1056, 1056, 1107, 1107, 1168], [1170, 1170, 1227, 1227, 4152]], "test": "untested"}
{"id": "4tBGRm", "name": "true pinball physics", "author": "archee", "description": "Click on the shader-screen to define start location. \nI actually coded this in my head during the long flight home from NVScene, California, 2015\n", "tags": ["2d", "physics"], "likes": 44, "viewed": 2543, "published": "Public API", "date": "1427504885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int showSolution = 0; // set to one to show the final horizontal velocity of the ball et given starting locations\nfloat solution;\nint MotionBlur = 1; \nfloat bounceRatio = 0.5;\nfloat gravity = -0.5;\nfloat ti;\nvec2 sp;\nfloat aspect = 16.0/9.0;\nvec3 color = vec3(0.0);\nfloat timeleft;\nfloat ballsize= 0.007; //(the ball is actually a dot, has no radius to avoid having to check vertex collision)\nfloat newBallTiming = 10.0;\n\n#define pixelsize (1.0/iResolution.x)\n#define linethickness (pixelsize*2.0*aspect)\n\nvoid drawline(vec2 a,vec2 b,vec3 linecolor) // antialiased line\n{\n    vec2 s = sp;\n    if ( dot(b-a,s-a) < 0.0 || dot(b-a,s-a)>dot(b-a,b-a)  ) return;\n    float aaval = (1.0-(abs( (a.x-b.x)*(s.y-a.y)-(a.y-b.y)*(s.x-a.x)  )/linethickness/length(a-b)*2.0));\n    color = max(color, linecolor*aaval);\n}\n\n// draw a disk with motion blur\nvec3 diskWithMotionBlur( vec3 col, in vec2 uv, in vec3 sph, in vec2 cd, in vec3 sphcol, in float alpha )\n{\n\tvec2 xc = uv - sph.xy;\n\tfloat a = dot(cd,cd);\n\tfloat b = dot(cd,xc);\n\tfloat c = dot(xc,xc) - sph.z*sph.z;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt( h );\n\t\t\n\t\tfloat ta = max( 0.0, (-b - h)/a );\n\t\tfloat tb = min( 1.0, (-b + h)/a );\n\t\t\n\t\tif( ta < tb ) // we can comment this conditional, in fact\n\t\t    col = mix( col, sphcol, alpha*clamp(2.0*(tb-ta),0.0,1.0) );\n\t}\n\n\treturn col;\n}\n\n\nvoid drawdisk(vec2 center,vec2 vel,float radius) \n{\n    if (showSolution!=0) return;\n\n    if (MotionBlur!=0)\n    {\n    \tcolor = diskWithMotionBlur(color,sp,vec3(center,radius),vel/24.0,vec3(1.0,1.0,1.0),1.0);\n    }\n    else\n    {   // antialiased disk\n\t    float val = clamp( -(length(center-sp)-radius)/pixelsize,-0.5,0.5 )+0.5;\n\t    color = max(color, vec3(1.0,1.0,1.0)*val);\n    }\n}\n\nvec2 ballpos,ballvel;\nconst int LineCount = 6;\nvec2 lines[LineCount*2];\n\nvec2 getBallPosFly(float t)\n{\n    vec2 np = ballpos + ballvel*t;\n    np.y += gravity*t*t*0.5;\n    return np;\n}\n\nfloat bounceTime;\nfloat time0;\nfloat bounceTan;\nfloat bounceLineAX,bounceLineBX;\n\nvoid lineFlyIntersection(vec2 la,vec2 lb)\n{\n    float k = (lb.y - la.y) / (lb.x - la.x); // line tangent\n    float topT = -ballvel.y/gravity;\n    float topX = ballpos.x + ballvel.x*topT;\n    float topY = ballpos.y - 0.5*gravity*topT*topT;\n    float topLineY = k*(topX-la.x)+la.y;\n    \n    float b = -(topY-topLineY);\n    float a = -k*ballvel.x;\n    float t0 = -a/gravity+topT;\n    if (2.0*b*gravity + a*a<=0.0) return;\n    float td = -sqrt(2.0*b*gravity + a*a)/gravity;\n    \n    \n    float t = t0-td;\n    if (t<0.001 || ballpos.x+ballvel.x*t<la.x || ballpos.x+ballvel.x*t>lb.x) t = t0+td;\n    \n    if (bounceTime>t && t>0.001 && ballpos.x+ballvel.x*t>=la.x && ballpos.x+ballvel.x*t<=lb.x) \n    {\n//\t    drawdisk(getBallPosFly(t),ballsize); // mark bounces\n        bounceTime = t;\n        bounceTan = k;\n        bounceLineAX = la.x;\n        bounceLineBX = lb.x;\n        if (lb.y<0.1) solution = 1.0;\n    }\n}\n\nvoid showPathFly(float t)\n{\n    if (showSolution!=0) return;\n    float xt = (sp.x-ballpos.x)/ballvel.x;\n    if (xt>0.0 && xt<t)\n    {\n        float py = ballpos.y + ballvel.y*xt + xt*xt*gravity*0.5;\n        vec2 vel = ballvel;\n        vel.y += xt*gravity;\n        float aa = 1.0-abs(sp.y-py)/pixelsize/1.5/length(vec2(1.0,vel.y/vel.x));\n        color = max(color,aa*vec3(0.1,0.4,0.9));\n    }\n}\n\nvec2 displayBallPos,displayBallVel;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lines[0] =vec2(0.1,0.4);\n    lines[1] =vec2(0.35,0.25);\n    lines[2] =vec2(0.35,0.22);\n    lines[3] = vec2(0.5,0.21);\n    lines[4] = vec2(0.5,0.16);\n    lines[5] = vec2(0.7,0.3);\n    lines[6] = vec2(0.84,0.19);\n    lines[7] = vec2(0.90,0.34);\n    lines[8] = vec2(0.4,0.06);\n    lines[9] = vec2(1.0,0.2);\n    lines[10] = vec2(0.2,0.08);\n    lines[11] = vec2(0.5,0.01);\n    \n    ti = mod( iTime,newBallTiming);\n\tsp = fragCoord.xy / iResolution.xy;\n    sp.y /= aspect;\n    \n    timeleft = ti;\n    time0 = 0.0;\n    \n    ballpos = iMouse.xy/iResolution.xy/vec2(1.0,aspect);\n    if (length(ballpos)==0.0)  \n        ballpos = vec2(0.19-mod(floor(iTime/newBallTiming)*0.02211,0.12),0.57);\n\tif (showSolution!=0) ballpos = sp;    \n    \n    ballvel = vec2(0.08,-0.08);// initial velocity x must not be 0\n    \n    for(int i=0;i<LineCount;i++)\n    {\n        vec2 fakeshift = normalize(lines[i*2+1].yx-lines[i*2].yx)*vec2(ballsize,-ballsize);\n    \tdrawline(lines[i*2]+fakeshift,lines[i*2+1]+fakeshift,vec3(1.0,0.8,0.1));\n    }\n    \n\n    for(int pass=0;pass<50;pass++) // max bounce count\n    {\n    \n        bounceTime = 1e35;\n        \n        for(int i=0;i<LineCount;i++)\n        {\n            lineFlyIntersection(lines[i*2],lines[i*2+1]);\n        }\n        float timeToGo = bounceTime;\n        showPathFly(timeToGo);\n        if (bounceTime>timeleft && timeleft>0.0) \n        {\n            displayBallPos = getBallPosFly(timeleft);\n            displayBallVel = ballvel;\n            displayBallVel.y += timeleft*gravity;\n        }\n        ballpos = getBallPosFly(timeToGo);\n        ballvel.y += timeToGo*gravity;\n        timeleft -= timeToGo;\n        time0 += timeToGo;\n        \n        \n        if (timeleft==0.0 || bounceTime==1e35) break;\n        \n        // bounce or roll\n        vec2 norm = normalize(vec2(-bounceTan,1.0));\n        if (abs(dot(norm,ballvel))<0.02) // roll \n        {\n            ballvel -= norm*dot(norm,ballvel);\n            \n            // find rolling end\n            vec2 slope = vec2(1.0,bounceTan);\n            vec2 gravslope = gravity * slope*bounceTan/dot(slope,slope);\n//            float x = ballpos.x + ballvel.x*t + gravslope.x*t*t*0.5;\n            float A = 0.5*gravslope.x;\n            float B = ballvel.x;\n            float C1 = ballpos.x - bounceLineAX; \n            float C2 = ballpos.x - bounceLineBX; \n            \n            float tm = B/-2.0/A; // lines can't be horizontal\n            float rollendt = 99.0;\n            if (B*B-4.0*A*C1>0.0)\n            {\n            \tfloat td = abs(sqrt(B*B-4.0*A*C1)/2.0/A);\n                float t=tm-td;\n                if (t<=0.0) t = tm+td;\n                if (t>0.0) rollendt = t;\n            }\n            if (B*B-4.0*A*C2>0.0)\n            {\n            \tfloat td = abs(sqrt(B*B-4.0*A*C2)/2.0/A);\n                float t=tm-td;\n                if (t<=0.0) t = tm+td;\n                if (t>0.0)  rollendt = min(rollendt,t);\n            }\n            \n            float turnT = max(tm,0.0);\n            if (turnT > rollendt) turnT=0.0;\n            vec2 turnBallPos = ballpos + ballvel*turnT + turnT*turnT*0.5*gravslope;\n            \n            if (rollendt>timeleft && timeleft>0.0) \n            {\n                displayBallPos = ballpos + ballvel*timeleft + timeleft*timeleft*0.5*gravslope;\n                displayBallVel = ballvel;\n            }\n            \n            timeToGo = rollendt;\n            ballpos += ballvel*timeToGo + timeToGo*timeToGo*0.5*gravslope;\n            ballvel += gravslope * timeToGo;\n            \n            if (showSolution==0) drawline(ballpos,turnBallPos,vec3(0.1,0.4,0.9));\n            \n            time0 += timeToGo;\n            timeleft -= timeToGo;\n            \n            \n        }\n        else\n        {\n\t        ballvel -= norm*dot(norm,ballvel)*(1.0+bounceRatio); // just bounce\n        }\n        \n        if (ballpos.y<0.0) break;\n       \n    }\n    \n    \n    \n    \n    drawdisk(displayBallPos,displayBallVel,ballsize);\n    \n   if (showSolution!=0) \n   {\n       color = max(color,vec3(-ballvel.x*3.0,ballvel.x*3.0,0.0));\n//       if (solution!=0.0) color = vec3(solution*0.5,0,solution);\n   }\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[305, 506, 571, 571, 804], [806, 838, 944, 944, 1331], [1334, 1334, 1385, 1385, 1719], [1794, 1794, 1823, 1823, 1904], [1988, 1988, 2031, 2031, 2894], [2896, 2896, 2923, 2923, 3289], [3328, 3328, 3385, 3385, 7531]], "test": "untested"}
{"id": "4tBGRz", "name": "smooth warp", "author": "mattz", "description": "playing around to get correct antialiasing using partial derivatives of a warp based on finite differencing", "tags": ["grid", "warp", "finitedifferences"], "likes": 32, "viewed": 745, "published": "Public", "date": "1426462510", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float scl;\n\nfloat det(mat2 A) {\n    return A[0][0]*A[1][1] - A[1][0]*A[0][1];\n}\n\nvec2 warp(vec2 p) {\n\t\n\tvec2 o = vec2(4.0*cos(iTime), 4.0*sin(2.0*iTime));\n\t\n\tvec2 po = p-o;\n\tfloat r2 = dot(po,po);\n\tfloat dr = -0.7*exp(-r2/16.0);\n\treturn p + dr*po;\n\n}\n\n// change #if 0 to #if 1 to use built-in differencing\nmat2 jacWarp(vec2 p) {\n#if 0\n    return mat2(dFdx(warp(p)), dFdy(warp(p)))/scl;\n#else    \n\tvec2 h = vec2(0.001, 0.0);\n\tvec2 jx = (warp(p+h.xy) - warp(p-h.xy))/(2.0*h.x);\n\tvec2 jy = (warp(p+h.yx) - warp(p-h.yx))/(2.0*h.x);\n\treturn mat2(jx, jy);\n#endif\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    scl = 30.0 / iResolution.x;\n\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) * scl;\n\t\n\tmat2 J = jacWarp(uv);\n\n    uv = warp(uv);\n\tfloat dJ = abs(det(J));\n\t\t\n\tuv = (fract(uv + 0.5) - 0.5);\n\t\n\tconst float rad = 2.0;\n\tfloat d = smoothstep((rad)*scl, (rad+1.0)*scl, length(uv)/sqrt(dJ));\n\tvec2 g = smoothstep(0.5*scl, 1.5*scl, abs(uv)/sqrt(dJ));\n\t\n\tfragColor.xyz = min(vec3(d), vec3(g.x, min(g.x, g.y), g.y));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tBGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[12, 12, 31, 31, 79], [81, 81, 100, 100, 250], [252, 306, 328, 328, 558], [560, 560, 617, 617, 1038]], "test": "untested"}
{"id": "4tfGWl", "name": "Valve Noise", "author": "Impossible", "description": "Quick implementation of noise from valve's vr talk. Subtle but it actually does reduce the banding if you look closely.\nhttp://media.steampowered.com/apps/valve/2015/Alex_Vlachos_Advanced_VR_Rendering_GDC2015.pdf", "tags": ["noise"], "likes": 17, "viewed": 1795, "published": "Public API", "date": "1426047041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec3 vDither = vec3(dot(vec2(171.0,231.0),fragCoord.xy + vec2(iTime)));\n    vDither.rgb = fract(vDither.rgb/vec3(103.0,71.0,97.0))-vec3(0.5,0.5,0.5);\n\tfragColor = (uv.x>0.5?vec4((vDither.rgb/255.0),1.0):vec4(0.0)) + pow(vec4(uv.y,uv.y,uv.y,0.0),vec4(1.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tfGWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 362]], "test": "untested"}
{"id": "4tj3Rz", "name": "Metaballs 2", "author": "notlion", "description": "blah", "tags": ["learning"], "likes": 2, "viewed": 155, "published": "Public", "date": "1426659056", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rotateX(float a) {\n    float sa = sin(a), ca = cos(a);\n    return mat3(1.0, 0.0, 0.0, 0.0, ca, sa, 0.0, -sa, ca);\n}\nmat3 rotateY(float a) {\n    float sa = sin(a), ca = cos(a);\n    return mat3(ca, 0.0, sa, 0.0, 1.0, 0.0, -sa, 0.0, ca);\n}\nmat3 lookAt(vec3 fw){\n\tfw = normalize(fw);\n    vec3 rt = normalize(cross(fw, vec3(0.0, 1.0, 0.0)));\n    return mat3(rt, cross(rt, fw), fw);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\nfloat sampleDistance(in vec3 p) {\n    float t = iTime * 2.0;\n    return smin(smin(smin(\n        sdSphere(p - vec3(sin(t*.813),cos(t*.758),0.) * 2., 1.2),\n        sdSphere(p - vec3(0.,sin(t*.454),cos(t*.676)) * 3., 1.), 0.5),\n        sdSphere(p - vec3(cos(t*.345),1.,sin(t*.253)) * 1.5, 1.5), 0.5),\n        sdSphere(p - vec3(cos(t*.929),sin(t*.987),0.) * 2.5, .8), 0.5);\n}\n\nvec3 sampleNormal(in vec3 pos) {\n    float e = .01;\n\tfloat d = sampleDistance(pos);\n\treturn normalize(vec3(\n        (d + sampleDistance(pos + vec3(e, 0.0, 0.0))) / e,\n\t\t(d + sampleDistance(pos + vec3(0.0, e, 0.0))) / e,\n\t\t(d + sampleDistance(pos + vec3(0.0, 0.0, e))) / e));\n}\n\n#define MIN_DIST 0.00001\n#define MAX_DIST 100.0\n\n// iq's soft shadows from http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softShadow(in vec3 ro, in vec3 rd, float k) {\n    float res = 1.0;\n    float d, t = 0.05;\n    for(int i = 0; i < 64; ++i) {\n        d = sampleDistance(ro + rd * t);\n        //if(t > MAX_DIST || d < MIN_DIST) return 0.0;\n        res = min(res, k * d / t);\n        t += d;\n    }\n    return res;\n}\n\nfloat light(in vec3 ro, in vec3 rd) {\n    float diffuse = max(0., dot(sampleNormal(ro), rd));\n    return diffuse * softShadow(ro, rd, 16.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tfloat aspect = iResolution.x / iResolution.y;\n    vec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n    uv.x *= aspect;\n    \n    float time = iTime;\n    \n    vec3 ro = vec3(cos(time*1.261), sin(time), sin(time*1.123)) * 5.0;\n   \tvec3 rd = lookAt(vec3(.1) - ro) * normalize(vec3(uv, 1.0));\n\tvec3 sp;\n\n    float d, t = 0.05;\n    for(int i = 0; i < 128; ++i) {\n        sp = ro + rd * t;\n        d = sampleDistance(sp);\n        if(t > MAX_DIST || d < MIN_DIST) break;\n        t += d;\n    }\n    \n    if (d < MIN_DIST) {\n        float lt = time * 1.0;\n        vec3 c = vec3(0.);\n        c += vec3(.7,.7,.6) * light(sp, normalize(vec3(.2,sin(lt*.1),-cos(lt*.1))));\n        c += vec3(.3,.3,.3) * light(sp, normalize(vec3(-.2,cos(lt),sin(lt))));\n        c += vec3(.3,.2,.2) * light(sp, normalize(vec3(sin(lt),cos(lt),0.)));\n        fragColor = vec4(c, 1.);\n    }\n    else {\n        float v = (rd.y + 1.) * .5;\n        fragColor = vec4(vec3(v), 1.0);\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tj3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 120], [121, 121, 144, 144, 241], [242, 242, 263, 263, 383], [385, 385, 424, 424, 527], [529, 529, 568, 568, 596], [598, 598, 631, 631, 969], [971, 971, 1003, 1003, 1247], [1298, 1387, 1438, 1438, 1687], [1689, 1689, 1726, 1726, 1831], [1833, 1833, 1888, 1888, 2843]], "test": "untested"}
{"id": "4tjGRm", "name": "Rainbow Draw - 180 chars", "author": "GregRostami", "description": "Use the mouse to draw on the screen.\nInspired by klk's brilliant use of the discard command in this shader:\n[url]https://www.shadertoy.com/view/Xt23Rw[/url]", "tags": ["2d", "rainbow", "paint", "draw", "2tc", "paintbrush"], "likes": 10, "viewed": 1349, "published": "Public API", "date": "1427695899", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 o, vec2 n) {\n    float t = iTime,s = 8.+5.*sin(t);\n    vec2 m = iMouse.xy;\n    if(length(n-(iResolution.xy-m))>s+s && length(n-m)>s)\n        discard;\n    o = clamp(abs(fract(t + vec4(1, .6, .3, 0)) * 6. - 3.) - 1., 0., 1.); }\n\n/*\n//Here's a super simple draw shader with only 75 chars!?\nvoid mainImage(vec4 o,vec2 n)\n{\n    if(length(n-iMouse.xy)>9.)\n        discard;\n\to=vec4(1);\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tjGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 249]], "test": "untested"}
{"id": "4tl3Wj", "name": "a canine and then you could be a", "author": "Branch", "description": "Oh so you could be a canine and then you could be a non canine?", "tags": ["ohsoyoucouldbeacanineandthenyoucouldbeanoncanine"], "likes": 0, "viewed": 131, "published": "Public", "date": "1425241624", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct polygon{\n\tvec2 A, B, C;\n};\n    \nfloat circle(vec2 coord, float size, float start, float end){\n    float angle = atan(coord.x, coord.y);\n    if(angle>start && angle<end) return 0.0;\n    return min(floor(distance(coord,vec2(0.))-size),0.);\n}\nfloat sgn(vec2 p1, vec2 p2, vec2 p3){\n  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\nint PointInTriangle(vec2 pt, vec2 v1, vec2 v2, vec2 v3){\n\tint b1, b2, b3;\n\n\tif(sgn(pt, v1, v2) < 0.0) b1=1;\n\tif(sgn(pt, v2, v3) < 0.0) b2=1;\n\tif(sgn(pt, v3, v1) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\nint PointInTriangle(vec2 pt, polygon X){\n\tint b1, b2, b3;\n\n\tif(sgn(pt, X.A, X.B) < 0.0) b1=1;\n\tif(sgn(pt, X.B, X.C) < 0.0) b2=1;\n\tif(sgn(pt, X.C, X.A) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1;\n\treturn 0;\n}\n\nfloat box(vec2 coord, vec2 pos, vec2 size){\n\tif((coord.x<(pos.x+size.x)) &&\n\t   (coord.x>(pos.x-size.x)) &&\n\t   (coord.y<(pos.y+size.y)) && \n\t   (coord.y>(pos.y-size.y)) ) \n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat sun(vec2 coord, vec2 pos, float size){\n\tif(length(coord-pos)<size)\n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nmat2 rotate(float Angle)\n{\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(floor(length( pa - ba*h ) - r),0.);\n}\nfloat triangle( vec2 coord, vec2 pos, float angle, float thick, float size){\n    vec2 original_coord = coord;\n    coord += pos;\n    coord *= rotate(angle);\n    float collision = 0.0;\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2( 0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.0, 0.333)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += sdCapsule( coord, vec2( 0.3,-0.2)*size, vec2(-0.3,-0.2)*size, thick );\n    collision += 3.0*texture( iChannel0, original_coord * 0.6 + vec2(iTime*0.02) ).b * 0.6;\n    collision += 2.5*texture( iChannel0, original_coord * 0.1 + vec2(iTime*0.001) ).b * 0.4;\n    return -min(max(-collision,0.0),1.0);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec4 tulos;\n\tvec4 lopullinentulos=vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    vec2 ori_coord=coord;\n\tfor(float rgbare=0.0; rgbare<2.0; rgbare++){\n        coord = vec2(aspectCorrection,1.0) *coordinate_entered * 2.5;\n        coord.x*=1.0+rgbare*0.005;\n\t\tcoord*=1.0+0.2*rand(coord+iTime)/(pow(iTime,12.0)*3.0)-length(coord)*4.0/(pow(iTime*61.1,24.0));\n        coord*=1.0+0.1*sin(1.01*0.1);\n        tulos=vec4(vec3(255.0/255.0, 255.0/255.0, 255.0/255.0),1.0);\n        float beat = ceil(iTime);\n\t\tvec2 base_coord = coord;\n\t\tcoord/=(1.+iTime/3.);\n            \n        coord*=rotate(iTime/4.);\n        coord.x+=iTime/3.;\n\t\n        float s1 = max(iTime-1.,0.);\n        float s2 = max(iTime-2.,0.);\n        float s3 = max(iTime-3.,0.);\n        float s4 = max(iTime-5.,0.);\n        float s5 = max(iTime-6.,0.);\n        vec3 taikurivitunluttinen=vec3(0.);\n        if(iTime>4.){\n            taikurivitunluttinen.rb+=0.7*max(1.0-(iTime-4.)/2.,0.)*vec2(rand(floor(coord*2.))-0.5,rand(floor(coord*2.+44.))-0.5);\n            taikurivitunluttinen.rg-=0.7*max(1.0-(iTime-4.)/2.,0.)*vec2(rand(floor(coord*.9))-0.5,rand(floor(coord*.9+44.))-0.5);\n        }\n        tulos.rgb+=taikurivitunluttinen;\n        if(s2<1.){\n            if(circle(coord-vec2(-.75+s2*s2,0.), 0.1*max(min(iTime*10.,1.)*(1.+sin(10.*iTime)/(1.+iTime*50.)),0.), 0., 0.)<0.)\n                tulos.rgb -= vec3(1.2);\n            if(circle(coord-vec2(-.75+s2*s2,0.), 0.08*max(min(iTime*10.,1.)*(1.+sin(10.*iTime)/(1.+iTime*50.)),0.), 0., 0.)<0.)\n                tulos.rgb += vec3(1.2);\n        }\n        for(float i=0.; i<12.; i++){\n            vec2 tripos = vec2(-i*.1-iTime*0.1*(1.+i*.1),rand(vec2(i+213.))-iTime*0.01*(1.+i*.1));\n        \ttulos.rgb += .8*vec3(rand(vec2(i+6.)),rand(vec2(i+88.)),rand(vec2(i+66.)))*\n                          triangle( coord, vec2(-3.,-.5)+tripos, mod(iTime+i*.74722,1.)+iTime+i, min(max(s5,0.),1.)*0.03, 0.5*min(max(s5,0.),1.)*(sin(s5*5.+i)*sin(i+iTime*.53)+1.1));\n        }\n        \n        if(circle(coord-vec2(.75,0.), 0.62*max(min(s1*10.,1.)*(1.+sin(10.*s1)/(1.+s1*50.)),0.), 0., 0.)<0.)\n            tulos.rgb -= vec3(1.2);\n        if(circle(coord-vec2(.75,0.), 0.58*max(min(s1*10.,1.)*(1.+sin(10.*s1)/(1.+s1*50.)),0.), 0., 0.)<0.)\n            tulos.rgb += vec3(1.2);\n        if(circle(coord-vec2(.75,0.), 0.575*max(min(s1*10.,1.)*(1.+sin(10.*s1)/(1.+s1*50.)),0.), 0., 0.)<0.)\n            tulos.rgb += vec3(1.2);\n        if(circle(coord-vec2(1.,0.), 0.2*max(min(s1*10.,1.)*(1.+sin(10.*s1)/(1.+s1*50.)),0.), -3.14159*0.75*min(s3*22.,1.), 3.14159*0.25*min(s3*22.,1.))<0.)\n            tulos.rgb -= vec3(2.2);\n        if(circle(coord-vec2(.5,0.), 0.2*max(min(s1*10.,1.)*(1.+sin(10.*s1)/(1.+s1*50.)),0.), -3.14159*0.25*min(s3*22.,1.), 3.14159*0.75*min(s3*22.,1.))<0.)\n            tulos.rgb -= vec3(2.2);\n\n        if(circle(coord-vec2(1.,0.), 0.2*max(min(s1*10.,1.)*(1.+sin(10.*s1)/(1.+s1*50.)),0.), 0., 0.)<0.)\n            tulos.rgb -= vec3(2.2);\n        if(circle(coord-vec2(1.,0.), 0.18*max(min(s1*10.,1.)*(1.+sin(10.*s1)/(1.+s1*50.)),0.), 0., 0.)<0.)\n            tulos.rgb += vec3(2.2);\n        if(circle(coord-vec2(.5,0.), 0.2*max(min(s1*10.,1.)*(1.+sin(10.*s1)/(1.+s1*50.)),0.), 0., 0.)<0.)\n            tulos.rgb -= vec3(2.2);\n        if(circle(coord-vec2(.5,0.), 0.18*max(min(s1*10.,1.)*(1.+sin(10.*s1)/(1.+s1*50.)),0.), 0., 0.)<0.)\n            tulos.rgb += vec3(2.2);\n\n        if(circle(coord-vec2(.75,-.4), 0.2*max(min(s3*10.,1.)*(1.+sin(10.*s3)/(1.+s3*50.)),0.), 0.,0.)<0.)\n            tulos.rgb -= vec3(2.2);\n        if(circle(coord-vec2(.75,-.4), 0.18*max(min(s3*4.,1.)*(1.+sin(4.*s3)/(1.+s3*50.)),0.), 0.,0.)<0.)\n            tulos.rgb += vec3(2.2);\n\n        if(circle(coord-vec2(.75,0.), 1.8, 0.,0.)<0.)\n            tulos.rgb -= vec3(2.2);\n        if(circle(coord-vec2(.75,0.), 1.77, 0.,0.)<0.)\n            tulos.rgb += vec3(2.2);\n        if(iTime>4.)\n        for(float i=0.; i<16.; i++){\n            vec2 posi=vec2(rand(vec2(i-43.))*.6-0.5,rand(vec2(i+44.))*.5-.25);\n            if(circle(coord+posi*(1.+s4*5.)+vec2(-.75,0.), 0.1*(s4+sin(i)), 0.,0.)<0.)\n                tulos.rgb -= vec3(0.02,0.1,0.01);\n        }\n        for(float i=0.; i<8.; i++){\n            vec2 posi=vec2(rand(vec2(i))-.5,rand(vec2(i+66.))-.5);\n            posi=normalize(posi)*.6;\n            if(circle(coord-vec2(.75,0.)+posi, 0.3+sin(i+iTime)*0.1, 0., 0.)<0.)\n                tulos.rgb -= vec3(0.2,0.3,0.4)*.5;\n        }\n        tulos.xyz=tulos.xyz-vec3(min(max(-0.57+length(ori_coord)*0.32,0.0),1.0))+vec3(0.015+0.03*rand(vec2(ori_coord.x+ori_coord.y,1.01*ori_coord.y*ori_coord.x)));\n\t\t\n    if(mod(coord.y*200.+coord.x*200.,8.)<1.1){\n        tulos.xyz -= vec3(0.05);\n    }else if(mod(coord.y*200.-coord.x*200.,8.)<1.1){\n        tulos.xyz -= vec3(0.05);\n    }\n        base_coord*=rotate(floor(iTime/3.)*3.14159);\n        if(abs(base_coord.y)<0.8 && iTime>8. && floor(mod((base_coord.y+base_coord.x+iTime)*3.,2.))==0.)\n            tulos.rgb=vec3(1.4,.7,.2)*(1.+.1*sin(iTime*3.14159));\n        if(abs(base_coord.y)<0.7 && iTime>8. && floor(mod((base_coord.y+base_coord.x+iTime*.4)*3.,2.))==0.)\n            tulos.rgb=vec3(0.);\n        if(rgbare==0.0)\n            lopullinentulos.r=tulos.r;\n        if(rgbare==1.0)\n            lopullinentulos.gb=tulos.gb;\n    }\n\tlopullinentulos.xyz=lopullinentulos.xyz*(1.0-0.05*mod(fragCoord.y,2.0));\n\tfragColor = lopullinentulos;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tl3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[39, 39, 100, 100, 246], [247, 247, 284, 284, 358], [359, 359, 415, 415, 587], [589, 589, 629, 629, 807], [809, 809, 852, 852, 1010], [1011, 1011, 1055, 1055, 1112], [1113, 1113, 1133, 1133, 1205], [1207, 1207, 1233, 1233, 1365], [1366, 1366, 1417, 1417, 1559], [1560, 1560, 1636, 1636, 2239], [2244, 2244, 2300, 2300, 7809]], "test": "untested"}
{"id": "4tlGDs", "name": "Raymarching Attempt 1", "author": "Craxic", "description": "My first attempt at a very basic ray marcher. I haven't even used a projection matrix :P \nNot sure where to start optimizing though, this shader is SLOW.", "tags": ["raymarching"], "likes": 39, "viewed": 2607, "published": "Public API", "date": "1426496916", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define INNER_RADIUS 0.75\n#define OUTER_RADIUS 0.9\n#define SHEET_THICKNESS 0.012\n#define NOISINESS 2.0\n\n#define INNER_COLOR vec4(0.0, 30.0, 30.0, 1.0)\n#define OUTER_COLOR vec4(20.0, 20.0, 30.0, 1.0)\n\n#define NUM_STEPS 128\n\n// THE FOLLOWING CODE (FROM HERE UNTIL THE END MARKER) WAS BLATANTLY LIFTED FROM \n// https://github.com/ashima/webgl-noise/blob/master/src/noise4D.glsl\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nfloat permute(float x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n  }\n\t\t\t\t\t\t\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289(i); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n/// THE END MARKER!\n/// All the next code was written by yours truly!\n\nvec4 merge_colours(vec4 apply_this, vec4 on_top_of_this)\n{\n    return on_top_of_this * (1.0 - apply_this.a) + apply_this * apply_this.a;\n}\n\nvec4 getdensity(vec3 pos)\n{\n    vec3 samplePos = normalize(pos);\n    float sample_ = (snoise(vec4(samplePos * NOISINESS, iTime)) + 1.0) / 2.0;\n    sample_ = clamp(sample_, 0.0, 1.0);\n    float innerIncBorder = INNER_RADIUS + SHEET_THICKNESS;\n    float outerIncBorder = OUTER_RADIUS - SHEET_THICKNESS;\n    \n    float radius = innerIncBorder + (outerIncBorder - innerIncBorder) * sample_;\n    float dist = distance(pos, vec3(0.0, 0.0, 0.0));\n    if (dist > radius && dist < radius + SHEET_THICKNESS) {\n        return INNER_COLOR + (OUTER_COLOR - INNER_COLOR) * (radius - innerIncBorder) / (outerIncBorder - innerIncBorder);\n    } else {\n        return vec4(0.0, 0.0, 0.0, 0.0);\n    }\n}\n\nvec4 raymarch(vec3 start, vec3 end)\n{\n    vec4 retn = vec4(0.0, 0.0, 0.0, 0.0);\n\tvec3 delta = end - start;\n    float stepDistance = length(delta) / float(NUM_STEPS);\n    \n    vec4 densityPrevious = getdensity(start);\n    for (int i = 1; i < NUM_STEPS; i++) \n    {\n        vec3 samplePos = start + delta * float(i) / float(NUM_STEPS);\n        vec4 density = getdensity(samplePos);\n        // Integrate the density using linear interpolation\n        // The colours will be the average of the two weighted by their alpha\n        vec4 densityIntegrated = (density + densityPrevious) / 2.0;\n        // Optimised out to return. densityIntegrated *= stepDistance\n        retn += densityIntegrated;\n        \n        densityPrevious = density;\n    }\n    \n    return retn * stepDistance;\n}\n\nvec4 raymarch_ball(vec2 coord)\n{\n\t// Now we're going to intersect a ray from the \n    // position onto two spheres, one inside the \n    // other (same origin). getdensity is only > 0 \n    // between these volumes.\n    float d = distance(coord, vec2(0.0, 0.0));\n    if (d > OUTER_RADIUS) {\n        // No intersection on the spheres.\n\t\treturn vec4(0.0, 0.0, 0.0, 0.0);\n    }\n    float dOuterNormalized = d / OUTER_RADIUS;\n    float outerStartZ = -sqrt(1.0 - dOuterNormalized*dOuterNormalized) * OUTER_RADIUS; // sqrt(1-x*x) = function of a circle :)\n    float outerEndZ = -outerStartZ;\n    if (d > INNER_RADIUS) {\n        // The ray only intersects the larger sphere, \n        // so we need to cast from the front to the back\n        return raymarch(vec3(coord, outerStartZ), vec3(coord, outerEndZ));\n    }\n    \n    float dInnerNormalized = d / INNER_RADIUS;\n    float innerStartZ = -sqrt(1.0 - dInnerNormalized*dInnerNormalized) * INNER_RADIUS; // sqrt(1-x*x) = function of a circle :)\n    float innerEndZ = -innerStartZ;\n    // The ray intersects both spheres.\n    vec4 frontPart = raymarch(vec3(coord, outerStartZ), vec3(coord, innerStartZ));\n    vec4 backPart = raymarch(vec3(coord, innerEndZ), vec3(coord, outerEndZ));\n    //vec4 mr = merge_colours(frontPart, backPart);\n    vec4 final = frontPart + backPart;\n    return final;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / min(iResolution.x, iResolution.y)) * 2.0 - vec2(iResolution.x / iResolution.y, 1.0);\n    fragColor = merge_colours(raymarch_ball(uv), vec4(0.0, 0.0, 0.0, 1.0));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tlGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 769, 790, 790, 839], [841, 841, 864, 864, 913], [915, 915, 937, 937, 977], [979, 979, 1003, 1003, 1043], [1045, 1045, 1073, 1073, 1125], [1127, 1127, 1157, 1157, 1209], [1211, 1211, 1243, 1243, 1506], [1514, 1588, 1612, 1612, 4090], [4092, 4163, 4221, 4221, 4301], [4303, 4303, 4330, 4330, 4986], [4988, 4988, 5025, 5025, 5767], [5769, 5769, 5801, 5982, 7101], [7104, 7104, 7161, 7161, 7351]], "test": "untested"}
{"id": "4ts3DS", "name": "Spinner Breakdown", "author": "Kyle273", "description": "An expanded version of 'spinner' for iBreakDownShaders.blogspot.com. The code here is expanded to demonstrate the techniques of creating the shader.", "tags": ["2d", "simple", "tutorial"], "likes": 3, "viewed": 966, "published": "Public", "date": "1425245192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    //Generate a uv offset describing a vector from\n    //the center of the screen\n    vec2 pos = ( fragCoord.xy/iResolution.xy ) - vec2(0.5, 0.5);\n\n    //Correct aspect ratio\n    pos.x *= iResolution.x/iResolution.y;\n\n    //Get the distance from the current pixel to the center\n    float radius = length(pos);\n\n    //Get the angle from the current pixel to the center\n    float angle = atan(pos.y, pos.x);\n\n    //Generate a sinusoidal intensity based off of the radius\n    //These look like rings.\n    float ringMask = pow(sin(radius * 32.0), 2.0);\n\n    //Scale the intensity by the radius, to produce a dimming effect\n    ringMask = ringMask*radius;\n\n    //Create a rotating 'sun burst' from the center.\n    float spinMask =  pow(sin(angle * 68.0 + 32.0*iTime) * 0.5 + 0.5, 2.0);\n\n    //Multiply the intensities together to create dots from the center.\n    float composition = spinMask * ringMask;\n\n    //Modulus based pattern switching to demonstrate layers\n    \n    spinMask *= mod(iTime,3.0) < 1.0 ? 1.0 : 0.0;\n    ringMask *= mod(iTime+1.0,3.0) < 1.0 ? 1.0 : 0.0;\n    composition *= mod(iTime+2.0,3.0) < 1.0 ? 1.0 : 0.0;\n    float c = spinMask + ringMask + composition;\n \n\n    vec4 color = vec4(0.0, 0.0, 0.15, 0.0);\n\n\n    color += vec4(2.0 * c, 2.0 * c, 2.0 * c, 1.0 * c);\n\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ts3DS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 59, 142, 1365]], "test": "untested"}
{"id": "4ts3DX", "name": "mandelbrot bulbe", "author": "Dermenslof", "description": "cool", "tags": ["raymandel"], "likes": 7, "viewed": 292, "published": "Public", "date": "1425719073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat stime, ctime;\nvec3 pos = vec3(0.0, 0.0, 0.0);\n//\nvec3 sundir = normalize(vec3(0.1, 0.8, 0.6));vec3 sun = vec3(1.64, 1.27, 0.99); \nvec3 skycolor = vec3(0.6, 1.5, 1.0);\nfloat pixel_size = 1.0;\n\nvoid ry(inout vec3 p, float a)\n{  \n \tfloat c,s;\n    vec3 q = p;  \n  \tc = cos(a);\n    s = sin(a);  \n  \tp.x = c * q.x + s * q.z;  \n  \tp.z = -s * q.x + c * q.z; \n}  \n\n\n/* \n** z = r*(sin(theta)cos(phi) + i cos(theta) + j sin(theta)sin(phi)\n** zn+1 = zn^8 +c\n** z^8 = r^8 * (sin(8*theta)*cos(8*phi) + i cos(8*theta) + j sin(8*theta)*sin(8*theta)\n** zn+1' = 8 * zn^7 * zn' + 1\n*/\n\nvec3 mb(vec3 p)\n{\n\tp.xyz = p.xzy;\n\tvec3 z = p;\n\tfloat power = 8.0;\n\tfloat r, theta, phi;\n\tfloat dr = 1.0;\n\tfloat t0 = 1.0;\n\t\n\tfor(int i = 0; i < 7; ++i)\n    {\n\t\tr = length(z);\n\t\tif(r > 2.0)\n            continue;\n\t\ttheta = atan(z.y / z.x);\n\t\tphi = asin(z.z / r);\t\t\n\t\tdr = pow(r, power - 1.0) * dr * power + 1.0;\n\t\tr = pow(r, power);\n\t\ttheta = theta * power;\n\t\tphi = phi * power;\n\t\tz = r * vec3(cos(theta) * cos(phi), sin(theta) * cos(phi), sin(phi)) + p;\n\t\tt0 = min(t0, r);\n\t}\n\treturn vec3(0.5 * log(r) * r / dr, t0, 0.0);\n}\n\nvec3 f(vec3 p)\n{ \n\t//ry(p, 1.15);\n    ry(p, stime);\n    return mb(p); \n} \n\n\nfloat softshadow(vec3 ro, vec3 rd, float k)\n{ \n\tfloat akuma = 1.0;\n    float h= 0.0; \n\tfloat t = 0.01;\n    for(int i = 0; i < 50; ++i)\n    { \n        h = f(ro + rd * t).x; \n        if(h < 0.001)\n            return 0.02; \n        akuma = min(akuma, k * h / t); \n \t\tt += clamp(h, 0.01, 2.0); \n    } \n    return akuma; \n} \n\nvec3 nor(in vec3 pos)\n{\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n\treturn normalize(vec3(\n           f(pos+eps.xyy).x - f(pos-eps.xyy).x,\n           f(pos+eps.yxy).x - f(pos-eps.yxy).x,\n           f(pos+eps.yyx).x - f(pos-eps.yyx).x ));\n}\n\nvec3 intersect(in vec3 ro, in vec3 rd)\n{\n    ro = ro - pos;\n    float t = 1.0;\n    float res_t = 0.0;\n    float res_d = 1000.0;\n    vec3 c, res_c;\n    float max_error = 1000.0;\n\tfloat d = 1.0;\n    float pd = 100.0;\n    float os = 0.0;\n    float step = 0.0;\n    float error = 1000.0;\n    \n    for(int i = 0; i < 54; i++)\n    {\n        if(error >= pixel_size * 0.5 && t <= 20.0 )\n        {\n            c = f(ro + rd * t);\n            d = c.x;\n            if(d > os)\n            {\n                os = 0.4 * d * d / pd;\n                step = d + os;\n                pd = d;\n            }\n            else\n            {\n                step = -os;\n                os = 0.0;\n                pd = 100.0;\n                d = 1.0;\n            }\n            error = d / t;\n            if(error < max_error) \n            {\n                max_error = error;\n                res_t = t;\n                res_c = c;\n            }\n            t += step;\n        }\n\n    }\n\tif(t > 20.0)\n        res_t = -1.0;\n    return vec3(res_t, res_c.y, res_c.z);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) \n{ \n    vec2 q = fragCoord.xy / iResolution.xy; \n \tvec2 uv = -1.0 + 2.0 * q; \n \tuv.x *= iResolution.x / iResolution.y; \n\n\t\n \tstime = sin(iTime * 0.1); \n \tctime = cos(iTime * 0.1); \n     \n    vec3 ro = vec3(0.0, -2.0, 3.0);\n \t//vec3 ro= vec3(3.0 * stime, stime * 2.0 + 1.0, 3.0 * ctime); \n\t//vec3 ro = vec3(0.0, 2.0*stime*ctime, 2.2);\n\t//vec3 ro = vec3(0.0, 0.0, 2.0);\n\n \tvec3 cf = normalize(-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0, 1.0, 0.0))); \n    vec3 cu = normalize(cross(cs, cf)); \n \tvec3 rd = normalize(uv.x * cs + uv.y * cu + 3.0 * cf);\n    \n    //vec3 rd = normalize(vec3(uv, -1.0));\n\tpixel_size = 1.0 / (iResolution.x * 2.0 * length(ro - pos));    \n\tvec3 bg = exp(uv.y - 2.0) * vec3(0.4, 1.6, 1.0);\n    float halo = clamp(dot(normalize(-ro), rd), 0.0, 1.0); \n    vec3 col = bg + vec3(0.6, 0.8, 0.4) * pow(halo * 0.1, 42.0); \n\n    vec3 p = ro; \n\tvec3 res = intersect(ro, rd);\n\tif(res.x > 0.001)\n    {\n\t\t  p = ro + res.x * rd;\n          vec3 n = nor(p); \n          float shadow = softshadow(p, sundir, 10.0 );\n          float dif = max(0.0, dot(n, sundir)); \n          float sky = 0.6 + 0.4 * max(0.0, dot(n, vec3(0.0, 1.0, 0.0))); \n \t\t  float bac = max(0.3 + 0.7 * dot(vec3(-sundir.x, -1.0, -sundir.z), n), 0.0); \n          float spe = max(0.0, pow(clamp(dot(sundir, reflect(rd, n)), 0.0, 1.0), 10.0)); \n\n          vec3 lin = 8.5 * sun * dif * shadow; \n          lin += 0.8 * bac * sun; \n          lin += 0.6 * sky * skycolor; \n          lin += 3.0 * spe; \n\n\t\t  res.y = pow(clamp(res.y, 0.0, 1.0), 0.55);\n\t\t  vec3 tc0 = 0.5 + 0.5 * sin(3.2 + 3.2 * res.y + vec3(0.5, 0.5, 0.0));\n          col = lin *vec3(0.9, 0.5, 0.6) *  0.6 * tc0;\n \t\t  col = mix(col,bg, 1.0 - exp(-0.001 * res.y * res.y));\n    }\n    col = pow(clamp(col, 0.0, 1.0),vec3(0.45));\n    col = col * 0.6 + 0.4 * col * col * (3.0 - 2.0 * col);\n    col = mix(col, vec3(dot(col, vec3(0.33))), -0.5);\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.7);\n \tfragColor = vec4(col.xyz, 1.0); \n }", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ts3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 200, 232, 232, 360], [365, 575, 592, 592, 1098], [1100, 1100, 1116, 1133, 1172], [1176, 1176, 1221, 1221, 1494], [1497, 1497, 1520, 1520, 1731], [1733, 1733, 1773, 1773, 2769], [2771, 2771, 2827, 2827, 4817]], "test": "untested"}
{"id": "4tS3R1", "name": "Circly", "author": "Zetape", "description": "Playing with circles", "tags": ["2d", "simple"], "likes": 1, "viewed": 135, "published": "Public", "date": "1426769527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 FragColor, in vec2 FragCoord ) \n{\n    vec2 mitt = vec2 (iResolution.x/2.+cos(iTime)*iResolution.y/3.,iResolution.y/3.-sin(iTime)*iResolution.y/3.);\n    vec2 mitt2 = vec2 (iResolution.x/3.+cos(iTime+2.1)*iResolution.y/3.,2.*iResolution.y/3.+sin(iTime+2.1)*iResolution.y/3.);\n    vec2 mitt3 = vec2 (2.*iResolution.x/3.+cos(iTime+4.2)*iResolution.y/3.,2.*iResolution.y/3.+sin(iTime+4.2)*iResolution.y/3.);\n\tvec2 punkt = gl_FragCoord.xy;\n    float radie=length(punkt-mitt)+iTime*60.;\n    float radie2=length(punkt-mitt2)-iTime*80.;\n    float radie3=length(punkt-mitt3)-iTime*70.\t;\n    float kontrast = 0.;\n    float kontrast2 = 0.;\n    float kontrast3 = 0.;\n    if  (mod((gl_FragCoord.y+iTime*4.5+sin(iTime*1.1)*3.)*0.0651,4.)>1.)\n        kontrast = 1.;\n    if  (mod((gl_FragCoord.x+iTime*5.5+sin(iTime*1.6)*3.)*0.052,4.)>1.)\n        kontrast = abs(-1.+kontrast);\n    if  (mod((gl_FragCoord.y-iTime*6.5+cos(iTime*1.3)*3.)*0.0453+0.33,4.)>1.)\n        kontrast2 = 1.;\n    if  (mod((gl_FragCoord.x-iTime*7.+sin(iTime*1.5)*3.)*0.0454+0.33,4.)>1.)\n        kontrast2 = abs(-1.+kontrast2);\n\tif  (mod((gl_FragCoord.y+iTime*6.+cos(iTime*1.4)*3.)*0.0655+0.67,4.)>1.)\n        kontrast3 = 1.;\n    if  (mod((gl_FragCoord.x-iTime*5.+cos(iTime*1.2)*3.)*0.0556+0.67,4.)>1.)\n        kontrast3 = abs(-1.+kontrast3);\n     \n    FragColor = vec4(\n        (abs(sin(radie*0.062)*0.3)+kontrast*0.2+abs(sin(radie3*0.06)*0.1))*0.601,\n        (abs(sin(radie2*0.058)*0.2)+kontrast2*0.25+abs(sin(radie3*0.06)*0.1))*0.501,\n        (abs(sin(radie3*0.06)*0.4)+kontrast3*0.4)*1.6001,\n        1);\n\t} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tS3R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 1586]], "test": "untested"}
{"id": "4ts3W2", "name": "Tapestry Z", "author": "echophon", "description": "z space remix", "tags": ["fractal", "shadeaday"], "likes": 5, "viewed": 257, "published": "Public", "date": "1425284209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// edit of http://glslsandbox.com/e#18752.0\nuniform vec2 mouse;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gTime = iTime*0.25;\n\tfloat f =20., g=0.005;\n\tvec2 res = iResolution.xy;\n\tvec2 mou = mouse.xy;\n\t\n\t//if (mouse.x < 0.5)\n\t//{\n\tmou.x = sin(gTime * .3)*sin(gTime * .17) * 1. + sin(gTime * .3);\n\tmou.y = (1.0-cos(gTime * .632))*sin(gTime * .131)*1.0+cos(gTime * .3);\n\tmou = (mou+1.0) * res;\n\t//}\n\tvec2 z = ((-res+2.0 * gl_FragCoord.xy) / res.y);\n\tvec2 p = ((-res+2.0+mou) / res.y);\n\tfor( int i = 0; i < 5; i++) \n\t{\n\t\tfloat d = dot(z,z);\n        z = (vec2( dot(-z.x,0.5), dot(z.y,1.5) ) / d) + p; \n        z.x =  1.0-abs(z.x);\n        z.y =  1.0-abs(z.y);\n\t\tf = max( f-d, (dot(z-p,z-p) ));\n\t\tg = min( g*d, sin(dot(z+p,z+p))+1.0);\n\t}\n\tf = abs(-log(f) / 3.5);\n\tg = abs(-log(g) / 8.0);\n\tfragColor = vec4(min(vec3(g, g*f, f), 1.0),1.0);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4ts3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 122, 122, 863]], "test": "untested"}
{"id": "4tSGRz", "name": "ngWaves0B", "author": "netgrind", "description": "noisey waves", "tags": ["noise", "waves", "netgrind"], "likes": 2, "viewed": 1229, "published": "Public API", "date": "1426452287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xx);\n    uv.x -=.5;\n    vec4 c = vec4(1.0);\n    vec3 a = vec3(atan(uv.y,uv.x));\n    vec3 d = vec3(length(uv));\n    a.g+=.025;\n    a.b+=.05;\n    vec3 coord = d*.5-sin(iTime*.4)*.5+.5+sin(a*50.0*sin(a*3.0+iTime)*50.0)*d;\n    c.rgb = abs(fract(coord-0.5)-0.5)/fwidth(coord*1.0);\n    c.rgb = 1.0-min(c.rgb,1.0);\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 422]], "test": "untested"}
{"id": "4tsGWs", "name": "sinMountains", "author": "Fred1024", "description": "Been playing with raymarch algorithms :)", "tags": ["3d", "raymarch"], "likes": 13, "viewed": 1220, "published": "Public API", "date": "1426202793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ~ sinMountains ~\n// Frederic Heintz\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define FOV_DEGRE 60.0\n#define E 0.15\n#define LIGHT_RANGE 3000.0\n\nvec3 camPos;\nint scapeType;\n\nfloat mapY( in vec3 pos )\n{\n    if(scapeType == 1)\n    {\n\t    pos.x = floor(pos.x / 10.0) * 10.0;\n    }\n    float y = sin( (pos.x + iTime * 5.0) * 0.1) * sin( (pos.z + iTime * 3.0) * 0.1) * 30.0;\n    y += (sin( (pos.x + iTime * 10.0) * 0.05) * sin( (pos.z - iTime * 7.0) * 0.05) * 30.0);\n    y += sin( (pos.x + iTime * 8.0) * 0.025) * sin( (pos.z + iTime * 12.0) * 0.025) * 30.0;\n\n    if(scapeType == 2)\n    {\n\t   \ty = floor(y / 10.0) * 10.0;\n    }\n    float q = length(pos.xz - camPos.xz) * 2.0;\n    return y * (0.2 + q * q * 0.0000015);\n}\n\nvec3 mapNormal( in vec3 pos )\n{\n\tfloat yl = mapY( pos + vec3(-E, 0.0, 0.0));\n\tfloat yr = mapY( pos + vec3(E, 0.0, 0.0));\n\tfloat yt = mapY( pos + vec3(0.0, 0.0, -E));\n\tfloat yb = mapY( pos + vec3(0.0, 0.0, E));\n    vec3 vx = normalize(vec3(E, yr - yl, 0.0));\n    vec3 vz = normalize(vec3(0.0, yt - yb, -E));\n    vec3 norm = normalize(cross( vx, vz ));\n\treturn norm;\n}\n\n// the higher we get in the map the further we go\nbool rayMarchFirstHit( in vec3 ray, inout float delta, inout vec3 ptr)\n{\n\tfor( int i = 0; i < 90; i++)\n\t{\n\t\tptr += (delta * ray);\n        float dy = ptr.y - mapY(ptr);\n\t\tif(dy <= 0.0)\n\t\t{\n\t\t\tptr -= (delta * ray);\n            return true;\n        }\n        delta = clamp(dy, 0.1, 9.0);\n    }\n    return false;\n}\n\n// refine with smaller and smaller steps\nvoid rayMarchRefine( in vec3 ray, in float delta, inout vec3 ptr)\n{\n\tfor( int i = 0; i < 20; i++)\n\t{\n\t\tptr += (delta * ray);\n\n\t\tif(ptr.y < mapY(ptr))\n\t\t{\n\t\t\tptr -= (delta * ray);\n            delta *= 0.5;\n        }\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float localTime = mod((iTime + (fragCoord.x / iResolution.x) * 8.0), 40.0);\n    \n    if(abs(mod(localTime, 20.0)) < 0.01)\tscapeType = 0;\n    else if(localTime <= 20.0)\t\t\t\tscapeType = 1;\n    else\t\t\t\t\t\t\t\t\tscapeType = 2;\n\n    vec3 lightPos = vec3(sin(iTime * 0.08) * 700.0, 150.0 - sin(iTime * 0.25) * 30.0, cos(iTime * 0.08) * 100.0);\n\n    // Camera setup\n    float height = 20.0 + (iMouse.y / iResolution.y) * 100.0;\n    camPos = mix(vec3(0.4, height, 0.3), lightPos, 0.3);\n    camPos.y = height;\n    \n    vec3 camTgt = vec3(lightPos.x, lightPos.y * 0.2, lightPos.z);\n\n    // A view matrix\n    vec3 dir = normalize(camTgt - camPos);\t\t\t\t\t// z dir\n    vec3 side = normalize(cross(dir, vec3(0.0, 1.0, 0.0)));\t// side\n    vec3 up = normalize(cross(side, dir));\t\t\t\t\t// up\n    mat3 viewMatrix = mat3(side.x, up.x, dir.x, side.y, up.y, dir.y, side.z, up.z, dir.z);\n    \n    // Ray setup\n    float tangF = tan(radians(FOV_DEGRE));\n    float ratio = iResolution.y / iResolution.x;\n    float rX = (((fragCoord.x / iResolution.x) * 2.0) - 1.0) * tangF;\n    float rY = (((fragCoord.y / iResolution.y) * 2.0) - 1.0) * tangF * ratio;\n    vec3 ray = normalize(vec3(rX, rY, 1.0));\n    \n    // apply camera trans to ray\n    ray = ray * viewMatrix;\n\n\t// sky\n    vec3 lightDir = (lightPos - camPos);\n    float lightDist = length(lightDir);\n   \tlightDir = normalize(lightDir);\n    float skyDot = clamp(dot(lightDir, ray), 0.0, 1.0);\n    vec3 colorSky = mix(vec3(0.5, 0.5, 1.0), vec3(0.0, 0.0, 1.0), clamp(ray.y, 0.0, 1.0));\n    colorSky += mix(vec3(0.0, 0.0, 0.0), vec3(0.5, 0.5, 1.0), vec3(pow(skyDot, 30.0) * 0.8, pow(skyDot, 15.0) * 0.6, pow(skyDot, 20.0) * 0.75));\n\n    vec3 color = colorSky;\n        \n\tvec3 ptr = camPos;\n    float delta = 2.0;\n\tif(scapeType == 0)\n    {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n    else if( rayMarchFirstHit( ray, delta, ptr ) == true)\n    {\n        rayMarchRefine( ray, delta * 0.5, ptr );\n\n        vec3 norm = mapNormal(ptr);\n        // surface color\n        if( abs(norm.z) > 0.8)          color = vec3(1.0, 0.04, 0.0);\n        else if( abs(norm.y) < 0.8)     color = mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), clamp((ptr.y + 25.0) * 0.05, 0.0, 1.0));\n        else if( abs(norm.y) < 0.82)    color = vec3(1.0, 1.0, 0.0);\n        else            \t\t\t\tcolor = mix(vec3(0.5, 0.5, 1.0), vec3(1.0, 0.5, 0.0), clamp((ptr.y + 16.0) * 0.025, 0.0, 1.0));\n\n        // shading\n\t    float lightDot = clamp(dot(lightDir, norm), 0.0, 1.0);\n\n\t    float spec = 0.0;\n\t\tfloat lightI = 0.0;\n        if(lightDot >= 0.0 && lightDist < LIGHT_RANGE)\n\t    {\n        \tlightI = lightDot * pow(1.0 - (lightDist / LIGHT_RANGE), 2.0) * 1.6;\n\t    \tspec = clamp(dot(ray, normalize(lightDir - norm)), 0.0, 1.0);\n\t    \tspec = pow(spec, 200.0) * 1.0;\n        }\n        color = ( (color * 0.15) + (color * lightI) + spec );\n        \n        // mix with sky in the distance\n        vec3 hitDir = (ptr - camPos);\n        float hitDist = length(hitDir);\n        float q = min(1.0, hitDist * hitDist * 0.0000017);\n        color = mix( color, colorSky, q );\n    }\n\n    // show light\n    lightDir = normalize(lightDir);\n    float lightQ = max( 0.0, dot(ray, lightDir));\n    color.xyz += vec3(pow(lightQ, 600.0 + sin(iTime * 50.0) * 20.0));\n\n    // Gamma\n    color = pow(color, vec3(0.4545));\n\n    color = clamp(color, 0.0, 1.0);\n    \n    fragColor = vec4(color, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tsGWs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 222, 249, 249, 762], [764, 764, 795, 795, 1130], [1132, 1182, 1254, 1254, 1492], [1494, 1535, 1602, 1602, 1757], [1759, 1759, 1816, 1816, 5173]], "test": "untested"}
{"id": "4tSGzz", "name": "oncontextlost", "author": "zproxy", "description": "\n\nhttps://www.shadertoy.com/view/ldsGR7", "tags": ["text", "bitmap"], "likes": 1, "viewed": 258, "published": "Public", "date": "1426501137", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float GetBinaryAt0(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000000;\ncol[3] = 0x00000000;\ncol[4] = 0x00000000;\ncol[5] = 0x00000000;\ncol[6] = 0x00000000;\ncol[7] = 0x00000000;\ncol[8] = 0x00000000;\ncol[9] = 0x00000000;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt1(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000000;\ncol[3] = 0x00000000;\ncol[4] = 0x00000000;\ncol[5] = 0x00000000;\ncol[6] = 0x00000000;\ncol[7] = 0x00000000;\ncol[8] = 0x00000000;\ncol[9] = 0x00000000;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt2(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x0000001f;\ncol[1] = 0x00008000;\ncol[2] = 0x0000dc00;\ncol[3] = 0x00000301;\ncol[4] = 0x000007de;\ncol[5] = 0x00004030;\ncol[6] = 0x00000000;\ncol[7] = 0x00000000;\ncol[8] = 0x00000000;\ncol[9] = 0x00000000;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt3(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000022;\ncol[1] = 0x00008001;\ncol[2] = 0x00000800;\ncol[3] = 0x00000201;\ncol[4] = 0x00000111;\ncol[5] = 0x00000020;\ncol[6] = 0x00000010;\ncol[7] = 0x00000000;\ncol[8] = 0x00000000;\ncol[9] = 0x00000000;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt4(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00008f22;\ncol[1] = 0x0000878f;\ncol[2] = 0x00002800;\ncol[3] = 0x00003e3d;\ncol[4] = 0x00000101;\ncol[5] = 0x000071e0;\ncol[6] = 0x000000f8;\ncol[7] = 0x0000001e;\ncol[8] = 0x0000e3ef;\ncol[9] = 0x000003e1;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt5(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00001832;\ncol[1] = 0x00008441;\ncol[2] = 0x0000e800;\ncol[3] = 0x0000a645;\ncol[4] = 0x00000101;\ncol[5] = 0x00004260;\ncol[6] = 0x00000010;\ncol[7] = 0x00008030;\ncol[8] = 0x000004c8;\ncol[9] = 0x00000193;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt6(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00001f1e;\ncol[1] = 0x00008781;\ncol[2] = 0x0000f800;\ncol[3] = 0x0000c27f;\ncol[4] = 0x0000013d;\ncol[5] = 0x00004220;\ncol[6] = 0x00000010;\ncol[7] = 0x0000003e;\ncol[8] = 0x0000e44f;\ncol[9] = 0x0000011b;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt7(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00001132;\ncol[1] = 0x00000401;\ncol[2] = 0x0000d800;\ncol[3] = 0x00004204;\ncol[4] = 0x00001111;\ncol[5] = 0x00004220;\ncol[6] = 0x00000010;\ncol[7] = 0x00000022;\ncol[8] = 0x00002448;\ncol[9] = 0x0000011a;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt8(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00001922;\ncol[1] = 0x00000459;\ncol[2] = 0x0000d800;\ncol[3] = 0x00002604;\ncol[4] = 0x00001111;\ncol[5] = 0x00004220;\ncol[6] = 0x00000190;\ncol[7] = 0x00008032;\ncol[8] = 0x00002448;\ncol[9] = 0x00007193;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt9(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00003f6f;\ncol[1] = 0x000087cf;\ncol[2] = 0x00009801;\ncol[3] = 0x00003f78;\ncol[4] = 0x00001fde;\ncol[5] = 0x0000f770;\ncol[6] = 0x000000f1;\ncol[7] = 0x0000807e;\ncol[8] = 0x0000eeef;\ncol[9] = 0x000071f7;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt10(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000000;\ncol[3] = 0x00000000;\ncol[4] = 0x00000000;\ncol[5] = 0x00000000;\ncol[6] = 0x00000000;\ncol[7] = 0x00000000;\ncol[8] = 0x00000000;\ncol[9] = 0x00000100;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt11(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000000;\ncol[3] = 0x00000000;\ncol[4] = 0x00000000;\ncol[5] = 0x00000000;\ncol[6] = 0x00000000;\ncol[7] = 0x00000000;\ncol[8] = 0x00000000;\ncol[9] = 0x000000e0;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt12(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000000;\ncol[3] = 0x00000000;\ncol[4] = 0x00000000;\ncol[5] = 0x00000000;\ncol[6] = 0x00000000;\ncol[7] = 0x00000000;\ncol[8] = 0x00000000;\ncol[9] = 0x00000000;\ncol[10] = 0x00000000;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt13(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x0000ffff;\ncol[1] = 0x0000ffff;\ncol[2] = 0x0000ffff;\ncol[3] = 0x0000ffff;\ncol[4] = 0x0000ffff;\ncol[5] = 0x0000ffff;\ncol[6] = 0x0000ffff;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt14(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x0000ffff;\ncol[1] = 0x0000ffff;\ncol[2] = 0x0000ffff;\ncol[3] = 0x0000ffff;\ncol[4] = 0x0000ffff;\ncol[5] = 0x0000ffff;\ncol[6] = 0x0000ffff;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt15(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x0000ffff;\ncol[1] = 0x0000ffff;\ncol[2] = 0x0000ffff;\ncol[3] = 0x0000ffff;\ncol[4] = 0x0000ffff;\ncol[5] = 0x0000ffff;\ncol[6] = 0x0000ffff;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt16(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000000;\ncol[3] = 0x00000000;\ncol[4] = 0x00000000;\ncol[5] = 0x00000000;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt17(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000000;\ncol[3] = 0x00000000;\ncol[4] = 0x00000000;\ncol[5] = 0x00000000;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt18(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000000;\ncol[3] = 0x00000000;\ncol[4] = 0x00000000;\ncol[5] = 0x00000000;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt19(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000000;\ncol[3] = 0x00000000;\ncol[4] = 0x00000000;\ncol[5] = 0x00000000;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt20(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000000;\ncol[3] = 0x00000000;\ncol[4] = 0x00000007;\ncol[5] = 0x00000000;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt21(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000020;\ncol[3] = 0x00000400;\ncol[4] = 0x00000004;\ncol[5] = 0x00000040;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt22(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000f9c;\ncol[1] = 0x0000f38f;\ncol[2] = 0x000079f1;\ncol[3] = 0x00003eec;\ncol[4] = 0x00008704;\ncol[5] = 0x000003e7;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt23(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00009322;\ncol[1] = 0x00006449;\ncol[2] = 0x00008822;\ncol[3] = 0x0000046c;\ncol[4] = 0x00004884;\ncol[5] = 0x00000044;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt24(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00009162;\ncol[1] = 0x00002c40;\ncol[2] = 0x0000fc22;\ncol[3] = 0x00000438;\ncol[4] = 0x00009884;\ncol[5] = 0x00000047;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt25(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00009162;\ncol[1] = 0x00002c40;\ncol[2] = 0x00000822;\ncol[3] = 0x00000438;\ncol[4] = 0x00001884;\ncol[5] = 0x00000044;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt26(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00009122;\ncol[1] = 0x00002458;\ncol[2] = 0x00000b22;\ncol[3] = 0x0000646c;\ncol[4] = 0x00004884;\ncol[5] = 0x0000e644;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt27(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00003bbe;\ncol[1] = 0x000077cf;\ncol[2] = 0x0000f1e7;\ncol[3] = 0x00003cee;\ncol[4] = 0x0000cf9f;\ncol[5] = 0x0000e3c7;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryAt28(float coord_x)\n{\nfloat refcol = 0.0;\nint col[11];\ncol[0] = 0x00000000;\ncol[1] = 0x00000000;\ncol[2] = 0x00000000;\ncol[3] = 0x00000000;\ncol[4] = 0x00000000;\ncol[5] = 0x00000000;\ncol[6] = 0x0000fffc;\ncol[7] = 0x0000ffff;\ncol[8] = 0x0000ffff;\ncol[9] = 0x0000ffff;\ncol[10] = 0x00000001;\nif (coord_x >= 0.0)\nif (coord_x < 16.0) refcol = float(col[0]);\nelse if (coord_x < 32.0) refcol = float(col[1]);\nelse if (coord_x < 48.0) refcol = float(col[2]);\nelse if (coord_x < 64.0) refcol = float(col[3]);\nelse if (coord_x < 80.0) refcol = float(col[4]);\nelse if (coord_x < 96.0) refcol = float(col[5]);\nelse if (coord_x < 112.0) refcol = float(col[6]);\nelse if (coord_x < 128.0) refcol = float(col[7]);\nelse if (coord_x < 144.0) refcol = float(col[8]);\nelse if (coord_x < 160.0) refcol = float(col[9]);\nelse if (coord_x < 176.0) refcol = float(col[10]);\n\n\treturn \n\t\tmod(\n\t\t\tfloor(\n\t\t\t\trefcol / pow(2.0, \n\t\t\t\tfloor(\n\t\t\t\t\tmod(\n\t\t\t\t\t\tcoord_x, \n\t\t\t\t\t\t16.0\n\t\t\t\t\t)\n\t\t\t\t)\n\t\t\t)\n\t\t),\n\t\t2.0\n\t);\n\t\t\t\t\t\t\n}\nfloat GetBinaryLessThan8(vec2 coord)\n{\nif ((29 - int(coord.y)) == 0) return GetBinaryAt0(coord.x); \nif ((29 - int(coord.y)) == 1) return GetBinaryAt1(coord.x); \nif ((29 - int(coord.y)) == 2) return GetBinaryAt2(coord.x); \nif ((29 - int(coord.y)) == 3) return GetBinaryAt3(coord.x); \nif ((29 - int(coord.y)) == 4) return GetBinaryAt4(coord.x); \nif ((29 - int(coord.y)) == 5) return GetBinaryAt5(coord.x); \nif ((29 - int(coord.y)) == 6) return GetBinaryAt6(coord.x); \nif ((29 - int(coord.y)) == 7) return GetBinaryAt7(coord.x); \nreturn 0.0;\n}\nfloat GetBinaryLessThan16(vec2 coord)\n{\nif ((29 - int(coord.y)) == 8) return GetBinaryAt8(coord.x); \nif ((29 - int(coord.y)) == 9) return GetBinaryAt9(coord.x); \nif ((29 - int(coord.y)) == 10) return GetBinaryAt10(coord.x); \nif ((29 - int(coord.y)) == 11) return GetBinaryAt11(coord.x); \nif ((29 - int(coord.y)) == 12) return GetBinaryAt12(coord.x); \nif ((29 - int(coord.y)) == 13) return GetBinaryAt13(coord.x); \nif ((29 - int(coord.y)) == 14) return GetBinaryAt14(coord.x); \nif ((29 - int(coord.y)) == 15) return GetBinaryAt15(coord.x); \nreturn 0.0;\n}\nfloat GetBinaryLessThan24(vec2 coord)\n{\nif ((29 - int(coord.y)) == 16) return GetBinaryAt16(coord.x); \nif ((29 - int(coord.y)) == 17) return GetBinaryAt17(coord.x); \nif ((29 - int(coord.y)) == 18) return GetBinaryAt18(coord.x); \nif ((29 - int(coord.y)) == 19) return GetBinaryAt19(coord.x); \nif ((29 - int(coord.y)) == 20) return GetBinaryAt20(coord.x); \nif ((29 - int(coord.y)) == 21) return GetBinaryAt21(coord.x); \nif ((29 - int(coord.y)) == 22) return GetBinaryAt22(coord.x); \nif ((29 - int(coord.y)) == 23) return GetBinaryAt23(coord.x); \nreturn 0.0;\n}\nfloat GetBinaryLessThan32(vec2 coord)\n{\nif ((29 - int(coord.y)) == 24) return GetBinaryAt24(coord.x); \nif ((29 - int(coord.y)) == 25) return GetBinaryAt25(coord.x); \nif ((29 - int(coord.y)) == 26) return GetBinaryAt26(coord.x); \nif ((29 - int(coord.y)) == 27) return GetBinaryAt27(coord.x); \nif ((29 - int(coord.y)) == 28) return GetBinaryAt28(coord.x); \nreturn 0.0;\n}\nfloat GetBinary(vec2 coord) {\nif ((29 - int(coord.y)) < 8) return GetBinaryLessThan8(coord);\nif ((29 - int(coord.y)) < 16) return GetBinaryLessThan16(coord);\nif ((29 - int(coord.y)) < 24) return GetBinaryLessThan24(coord);\nif ((29 - int(coord.y)) < 32) return GetBinaryLessThan32(coord);\nreturn 0.0; }\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // zoom?\n\tvec2 xy = uv * vec2(312.0, 180.0);\n\n\t\n    \n\n\txy.y += -37.0 + -50.0 * (iMouse.y - iResolution.y /2.0) / iResolution.y  ;\t\n\txy.x += -12.0 + 4.0 * sin(iTime);\n    \n\n\tfloat intensity = GetBinary(xy) ;\n\t\t\n\t//float intensity2 = GetBinary2(xy) ;\n \n    float si = (sin(iTime)  + 1.0) / 2.0;\n    \n    intensity = \n        intensity * si  //+\n        //intensity2 * (1.0 -si)\n        ;\n\n    \n    if (intensity < 0.1)\n        fragColor = vec4(0, 0, 0, 0.5);\n    else\t\n\t\tfragColor = vec4(intensity, 0.5*intensity*sin(iTime), 0, 0.3 + intensity);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tSGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 1000], [1001, 1001, 1036, 1036, 2001], [2002, 2002, 2037, 2037, 3002], [3003, 3003, 3038, 3038, 4003], [4004, 4004, 4039, 4039, 5004], [5005, 5005, 5040, 5040, 6005], [6006, 6006, 6041, 6041, 7006], [7007, 7007, 7042, 7042, 8007], [8008, 8008, 8043, 8043, 9008], [9009, 9009, 9044, 9044, 10009], [10010, 10010, 10046, 10046, 11011], [11012, 11012, 11048, 11048, 12013], [12014, 12014, 12050, 12050, 13015], [13016, 13016, 13052, 13052, 14017], [14018, 14018, 14054, 14054, 15019], [15020, 15020, 15056, 15056, 16021], [16022, 16022, 16058, 16058, 17023], [17024, 17024, 17060, 17060, 18025], [18026, 18026, 18062, 18062, 19027], [19028, 19028, 19064, 19064, 20029], [20030, 20030, 20066, 20066, 21031], [21032, 21032, 21068, 21068, 22033], [22034, 22034, 22070, 22070, 23035], [23036, 23036, 23072, 23072, 24037], [24038, 24038, 24074, 24074, 25039], [25040, 25040, 25076, 25076, 26041], [26042, 26042, 26078, 26078, 27043], [27044, 27044, 27080, 27080, 28045], [28046, 28046, 28082, 28082, 29047], [29048, 29048, 29086, 29086, 29588], [29589, 29589, 29628, 29628, 30142], [30143, 30143, 30182, 30182, 30700], [30701, 30701, 30740, 30740, 31069], [31070, 31070, 31099, 31099, 31371], [31375, 31375, 31432, 31432, 32029]], "test": "untested"}
{"id": "4tXGDf", "name": "Tetrahedral Interpolation", "author": "paniq", "description": "A method for linear interpolation of four tetrahedral corners that regresses to simple barycentric interpolation on the faces; drag the mouse for a cutaway; hit P to toggle the cutting plane. Hit N to toggle nearest neighbor interpolation.", "tags": ["mattdamon"], "likes": 6, "viewed": 1424, "published": "Public API", "date": "1425520527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// see doMaterial for the interpolation routine\n\nvec2 m;\n\n// keys are javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nbool ReadKey( int key )//, bool toggle )\n{\n\tbool toggle = true;\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime;\n    float d = 3.0;\n\tcamPos = vec3(d*sin(an),1.2,d*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nfloat tetrahedron(vec3 p, float r) {\n    vec3 o = p / sqrt(3.0);\n    float p1 = -o.x+o.y-o.z;\n    float p2 =  o.x-o.y-o.z;\n    float p3 = -o.x-o.y+o.z;\n    float p4 =  o.x+o.y+o.z;    \n\tfloat s = max(max(max(p1,p2),p3),p4);\n    \n\treturn s-r*1.0/sqrt(3.0);\n}\n\nfloat octahedron(vec3 p, float r) {\n    vec3 o = abs(p) / sqrt(3.0);\n\tfloat s = o.x+o.y+o.z;\n\treturn s-r*2.0/sqrt(3.0);\n}\n\nfloat doModel( vec3 p ) {\n    \n    float mouse_delta = clamp(m.x,0.0,1.0)*2.0-1.0;\n    float plane = p.y  + mouse_delta;\n    if (ReadKey(Key_P)) {\n\t\tplane = ((p.x+p.y+p.z) + mouse_delta)/sqrt(3.0);\n       \tplane = abs(plane)-0.01;\n    }\n    \n    return max(tetrahedron(p,0.5), plane);\n  \n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\n\nvec4 max4(vec4 a, vec4 b) {\n    return (a.w > b.w)?a:b;\n}\nvec2 max4(vec2 a, vec2 b) {\n    return (a.y > b.y)?a:b;\n}\n\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n#if 1\n    const vec3 c0 = vec3(1.0,0.0,0.0);\n    const vec3 c1 = vec3(0.0,1.0,0.0);\n    const vec3 c2 = vec3(0.0,0.0,1.0);\n    const vec3 c3 = vec3(1.0,1.0,0.0);\n#else\n    // edge case\n    const vec3 c0 = vec3(1.0,0.0,0.0);\n    const vec3 c1 = vec3(0.0,0.0,0.0);\n    const vec3 c2 = vec3(0.0,0.0,0.0);\n    const vec3 c3 = vec3(0.0,0.0,0.0);\n#endif\n    \n    pos = vec3(pos.x, -pos.z, pos.y);\n    if (max(pos.x,max(pos.y,pos.z)) > 1.01)\n        return vec3(0.0);\n\n    vec4 edge = vec4((pos.yxz - pos.zyx - pos.xzy)*0.5+0.25, 0.0);\n    edge.w = 1.0-edge.x-edge.y-edge.z;\n    \n    vec3 col = vec3(0.0);\n    \n    if (ReadKey(Key_N)) {\n        edge = floor(1.0+edge-max(max(edge.yzwx,edge.zwxy),edge.wxyz));\n    }\n    \n    col = c0*edge.x + c1*edge.y + c2*edge.z + c3*edge.w;\n\n#if 0\n    // check if total energy of colors is below 1\n    if ((abs(col.x)+abs(col.y)+abs(col.z)) < 1.0)\n        return vec3(1.0);\n    if (max(col.x,max(col.y,col.z)) > 1.01)\n        return vec3(0.0);\n#endif\n    \n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        col = doMaterial( pos, nor );\n\t}\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 940, 982, 982, 1124], [1126, 1458, 1541, 1541, 1661], [1664, 1895, 1922, 1922, 1957], [1959, 1959, 1995, 1995, 2216], [2218, 2218, 2253, 2253, 2339], [2341, 2341, 2366, 2366, 2630], [2632, 2986, 3013, 3013, 3043], [3044, 3044, 3071, 3071, 3101], [3103, 3103, 3148, 3148, 4151], [4153, 4153, 4203, 4203, 4620], [4622, 4622, 4654, 4654, 5066], [5068, 5068, 5132, 5132, 5310], [5312, 5312, 5369, 5369, 6293]], "test": "untested"}
{"id": "4tXGDl", "name": "Happy Stars Music Viz", "author": "kig", "description": "Stars bouncing to the beat, #shadeADay for March 10", "tags": ["2d", "shadeaday", "musicvis"], "likes": 5, "viewed": 185, "published": "Public", "date": "1425975822", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA_SIZE 2.0\n#define pi 3.141592653589793\n\nfloat star(vec2 uv) {\n\tfloat a = atan(uv.y,uv.x);\n    float r = length(uv);\n    float starR = 0.5+0.25*pow(sin(a*2.5+iTime), 2.0);\n    return r < starR ? 1.0 : 0.0;\n}\n\nfloat pointyStar(vec2 uv, float r, float rotation) {\n\tfloat a = atan(uv.y,uv.x);\n    float len = length(uv);\n    float starR = r/0.75 * (0.5+0.25*(abs(mod(a*2.5+rotation, pi)/(0.5*pi)-1.0)));\n    return len - starR;\n}\n\nfloat pointyStars(vec2 uv) {\n    uv *= vec2(18.0, 16.0);\n    float idx = mod(floor(0.5*uv.x)*0.5+8.2, 16.0);\n    float val = texture(iChannel0, vec2(idx/18.0, 0.0)).r;\n    float yFac = pow(max(0.0, val - floor((0.5*uv.y)+8.0)*0.5/8.0), 0.2);\n    float phase = floor(0.5*uv.x)-floor(0.5*uv.y)+iTime*3.14159;\n    return pointyStar(mod(uv, vec2(2.0))-1.0, yFac*1.2-0.2, 2.0*cos(1.0*phase));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat bass = texture(iChannel0, vec2(0.3, 0.0)).r;\n    fragColor = vec4(0.0);\n    for (float x=0.0; x < AA_SIZE; x++) {\n        for (float y=0.0; y < AA_SIZE; y++) {\n            vec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n            vec2 uv = (fragCoord.xy + vec2(x,y)/AA_SIZE) / iResolution.xy;\n            uv = (2.0 * uv - 1.0) * aspect;\n            float starD = pointyStars(uv);\n            float bigStarD = pointyStar(uv+vec2(sin(iTime*2.8)*0.3 + tan(iTime*0.6) + cos(iTime*0.7), sin(iTime*0.8) + tan(iTime*0.5) + cos(iTime*1.6)*0.1), 0.6+0.3*(0.5-0.5*cos(bass*pi)), pi*iTime);\n            vec4 stars = vec4(1.2-0.8*abs(sin(uv*3.0)),0.7+0.3*sin(iTime+3.0*uv.x*uv.y),1.0) * float(starD < 0.0);\n            vec4 glow = vec4(0.0);\n            if (starD > 0.07) {\n                glow = vec4(1.0, 1.0, 0.5, 1.0)*max(0.0, step(0.0, 0.1-starD));\n            }\n            float a = -0.3;\n            uv.y += cos(iTime+uv.x*8.0+uv.y)*0.025;\n            vec2 ruv = mat2(cos(a), sin(a), -sin(a), cos(a)) * uv * (1.0+0.25*(uv.y+1.7));\n            vec2 checkerBoard = 0.5+0.5*sign(pow(sin(ruv*8.0), vec2(20.0))-0.5);\n            vec2 checkerBoard2 = 0.5+0.5*sign(pow(sin((ruv)*8.0), vec2(8.0))-0.5);\n            float c0 = max(checkerBoard.x, checkerBoard.y);\n            float c1 = max(checkerBoard2.x, checkerBoard2.y);\n\t\t    float mval = texture(iChannel0, vec2((4.5*uv.x+8.2)/64.0, 0.0)).r;\n            vec4 ccol = mix(vec4(mval*1., 0.6, 1.3-mval, 1.0), vec4(2.9*mval, mval, 0.25, 1.0), 1.0-c0);\n            vec4 bg = mix(vec4(1.58*mval,0.95,(1.3-mval)*0.75,1.0), ccol, max(c0, c1))*float(starD > 0.07)*float(bigStarD > 0.02);\n            vec4 bigStar = vec4(0.4, 0.5, 0.8, 1.0)*float(starD > 0.07)*float(bigStarD < 0.0); \n            bg = mix(bg, vec4(0.2, 0.5, 0.9,1.0), max(0.0, min(0.5, abs(1.5-(ruv.y*0.3+1.7)))));\n            vec4 col = bg + bigStar + stars + glow;\n            fragColor += col;\n \t\t}\n    }\n    fragColor /= AA_SIZE * AA_SIZE;\n}", "image_inputs": [{"id": "4sXGzn", "previewfilepath": "/media/ap/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/a6a1cf7a09adfed8c362492c88c30d74fb3d2f4f7ba180ba34b98556660fada1.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4tXGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 71, 71, 216], [218, 218, 270, 270, 435], [437, 437, 465, 465, 826], [828, 828, 885, 885, 2846]], "test": "untested"}
{"id": "ldlSDH", "name": "DancingVirii", "author": "entropynine", "description": "Dancin virii", "tags": ["audio", "virii", "dance"], "likes": 8, "viewed": 281, "published": "Public", "date": "1425873766", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define DOF_EFFECT\n//uncomment to enable DOF (actually works faster!)\n\nmat3 rot(vec3 v, float angle)\n{\n\tfloat c = cos(angle);\n\tfloat s = sin(angle);\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\nvec2 f=vec2(0.5,2.);\n\nfloat surfkifs(vec3 p,float sca) {\n\tfloat time = iTime*1.2;\n\tvec2 c=vec2(1.,1.);\n\tconst int iter=24;\n\tfloat sc=1.16+sca*.025;\n\tvec3 j=vec3(-1,-1,-1.5);\n\t//vec3 rotv=normalize(vec3(0.2,-0.2,-1)+.2*vec3(sin(time),-sin(time),cos(time)));\n\tvec3 rotv=normalize(vec3(-0.08+sin(time)*.02,-0.2,-.5));\n\tfloat rota=radians(50.);\n\tmat3 rotm=rot(normalize(rotv),rota);\n\tp.z=abs(p.z)-4.;\n\tfor (int i=0; i<iter; i++) {\n\t\tp.xy=abs(p.xy+f.xy)-f.xy;\n\t\tp*=rotm;\n\t\tp*=sc;\n\t\tp+=j;\n\t\t\n\t}\n\treturn length(p)*pow(sc,float(-iter));\n}\n\nfloat nucleo(vec3 p, float s) {\n\tfloat d=1000.;\n\tfor (float n=0.; n<10.; n++) {\n\t\tfloat t=mod((iTime+n)*2.,4000.);\n\t\tvec4 r=texture(iChannel1,vec2(floor(t/64.),mod(t,64.))/64.);\n\t\td=min(d,length(p+(r.xyz-vec3(.5))*s*.7)-s*(.2+r.w*.3));\n\t}\n\treturn d;\n}\n\n\nfloat sampleMusic()\n{\n\treturn (\n\t\ttexture( iChannel0, vec2( 0.01, 0.15 ) ).x + \n\t\ttexture( iChannel0, vec2( 0.07, 0.15 ) ).x + \n\t\ttexture( iChannel0, vec2( 0.15, 0.15 ) ).x + \n\t\ttexture( iChannel0, vec2( 0.30, 0.15 ) ).x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat sca=.5+sampleMusic();\n\tfloat time = iTime*.9;\n\tvec2 coord = fragCoord.xy / iResolution.xy *2. - vec2(1.);\n\tcoord.y *= iResolution.y / iResolution.x;\n\tfloat dist=29.+sin(time*2.)*5.;\n\tvec3 target = vec3(-f,0);\n\tvec3 from = target+dist*normalize(vec3(sin(time),cos(time),.5+sin(time)));\n\tvec3 up=vec3(1,sin(time)*.5,1);\n    vec3 edir = normalize(target - from);\n    vec3 udir = normalize(up-dot(edir,up)*edir);\n    vec3 rdir = normalize(cross(edir,udir));\n\tfloat fov=1.1*sin(iTime * 0.1)+sca*.09;\n\tvec3 dir=normalize((coord.x*rdir+coord.y*udir)*fov+edir);\n\tvec3 p=from;\n\tfloat steps;\n\tfloat totdist;\n\tfloat intens=1.;\n\tfloat maxdist=dist+15.;\n\tvec3 col=vec3(0.);\n\tfor (int r=0; r<110; r++) {\n\t\tfloat d1=surfkifs(p,sca);\n\t\tfloat d2=nucleo(p+vec3(f,0),max(5.,sca*3.));\n\t\tfloat d=min(d1,d2);\n\t\t#ifdef DOF_EFFECT\n\t\t\ttotdist+=max(max(0.5-time*0.5,0.02*pow(totdist*.06,3.)),abs(d));\n\t\t#else\n\t\t\ttotdist+=max(max(0.5-time*0.5,0.03),abs(d));\n\t\t#endif\n\t\tif (totdist>maxdist) break;\n\t\tp=from+totdist*dir;\n\t\tsteps++;\n\t\tintens=max(0.,maxdist-totdist+3.)/maxdist;\n\t\tcol+=(d==d1?vec3(2.1*sin(iTime),.2*sin(iTime),1)*pow(intens,2.5):vec3(1.3*sin(iTime),0.2,.1*sin(iTime))*(.05+sca*.2)*intens);\n\t}\n\tcol=col*0.035+vec3(.5)*(max(0.,length(coord)-.6));\n\tfragColor = vec4(col,1.0);\t\n\t\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}, {"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldlSDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 73, 104, 104, 454], [478, 478, 512, 512, 986], [988, 988, 1019, 1019, 1239], [1242, 1242, 1263, 1263, 1466], [1468, 1468, 1525, 1525, 2796]], "test": "untested"}
{"id": "ll23R1", "name": "shadeaday ( 3 / 22 / 2015 )", "author": "cabbibo", "description": "Playing with some banding.", "tags": ["metaballs", "raytrace", "band"], "likes": 7, "viewed": 193, "published": "Public", "date": "1427050568", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 40;\n\t\nvec4 spherePos[100];\n    \n\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p )\n{\n    \n    float f = sin( p.z * 5. ) * sin( p.x * 5. );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y - (abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\n\nfloat sdSphere( vec3 p, float s , float offset)\n{\n\n\n    float d1 = length(p) - .1*smoothstep(0.0,1.0,iTime);;\n    d1 *= .8;\t\n    \n   // vec3 nP = vec3( x , y , z );\n    return d1 -s;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \tvec2 res = vec2( 10000. , 0.);// vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    for( int i = 0; i < 20; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , spherePos[i].w  , float( i )) , float(i) + 1.);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    for( int i =0; i < 20; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n    \tspherePos[i] = vec4( x ,  y ,  z , r  );\n        \n        \n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n    vec3 col = vec3( 0. );//vec3( .8 , .8 , .8 ); \n   \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 nor = calcNormal( pos );\n        \n        float AO = calcAO( pos , nor );\n        \n        float match = -dot( nor , rd );\n        \n\n       // float c = pow(( 1.-AO) , 5.)*  10.;\n        float c = 0.;\n        c += pow((1.- match),3.) * 1.;\n        c += pow(( 1.-AO) , 3.)*  2.;\n        col = vec3( c );// * .4 * ( nor * .5 + .5 );\n        \n       /* if( res.y < .5 ){\n            \n            float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n            col *= abs( f );\n            col /= pow( length( pos ), 4.);\n        }*/\n       \n\n\n        float band = pow( match, 2. );\n        \n       \tband *= 6.;\n        band = floor( band );\n        //band /= 20.;\n        \n        nor = nor * .5 + .5;\n        if( mod( band , 6. ) == 0. ){\n         col = nor * vec3( 1. , .3 , .3 );      \n        }else if( mod( band , 6. ) == 1. ){\n         col = nor * vec3( 1. , .6 , .3 );        \n        }else if( mod( band , 6. ) == 2. ){\n         col = nor * vec3( 1. , .8 , .3 );    \n        }else if( mod( band , 6. ) == 3. ){\n         col = nor * vec3( 1. , .8 , .6 );   \n        }else if( mod( band , 6. ) == 4. ){\n         col = nor * vec3( 1. , .6 , .8 );   \n        }else if( mod( band , 6. ) == 5. ){\n         col = nor * vec3( .8 , .4 , 1. );    \n        }\n\n        \n\n    }\n    // apply gamma correction\n   // col = pow( col, vec3(0.2545) );\n\t\n    \n    \n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll23R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 359, 424, 424, 608], [611, 611, 656, 656, 696], [698, 698, 723, 723, 893], [897, 897, 946, 946, 1081], [1083, 1083, 1121, 1121, 1292], [1294, 1325, 1389, 1389, 1567], [1569, 1569, 1652, 1652, 1765], [1770, 1864, 1893, 1893, 1936], [1938, 1974, 2015, 2015, 2086], [2088, 2088, 2123, 2123, 2162], [2163, 2247, 2268, 2268, 2732], [2736, 2736, 2784, 2784, 3251], [3253, 3366, 3397, 3397, 3623], [3626, 3626, 3700, 3700, 3961], [3964, 3964, 4006, 4006, 4305], [4308, 4308, 4364, 4364, 6939]], "test": "untested"}
{"id": "ll2GRR", "name": "[NV15]Sun Rebirth", "author": "EvilRyu", "description": "This is how we recharge the sun.", "tags": ["raymarching", "space", "nv15"], "likes": 13, "viewed": 1996, "published": "Public API", "date": "1426777462", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by EvilRyu 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// NVScene 2015 Shadertoy Hackathon\n\n\n\n#define SPACE_SHIP 0.0\n#define SUN 1.0\n\n\nfloat type;  // space ship or sun\nfloat mindist;\n\nfloat smin(float a, float b, float k)\n{\n    float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nvoid rotate_x(inout vec3 p, float a) \n{ \n    float c,s;vec3 q=p; \n    c = cos(a); s = sin(a);\n    p.y = c * q.y - s * q.z; \n     p.z = s * q.y + c * q.z; \n} \n\nvoid rotate_z(inout vec3 p, float a) \n{ \n    float c,s;vec3 q=p; \n    c = cos(a); s = sin(a); \n    p.x = c * q.x - s * q.y; \n    p.y = s * q.x + c * q.y;\n} \n void rotate_y(inout vec3 p, float a)\n{ \n    float c,s;vec3 q=p; \n    c = cos(a); s = sin(a); \n    p.x = c * q.x + s * q.z; \n    p.z = -s * q.x + c * q.z;\n} \n\nfloat cylinder(vec3 p, vec2 h)\n{\n    vec2 d = abs(vec2(length(p.xz) ,p.y)) - vec2(h.x, h.y);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sphere(vec3 p, float r) \n{\n    return length(p)-r;\n}\n\nfloat propeller(vec3 p)\n{\n    rotate_y(p,0.7853);\n    float d1=cylinder(vec3(p.x-0.15,p.y+0.15,p.z),vec2(0.03,0.08));\n    p.xy=p.yx;\n    float d2=cylinder(vec3(p.x+0.15,p.y+0.1,p.z),vec2(0.01,0.25));\n    float d3=cylinder(vec3(p.x+0.15,p.y+0.12,p.z),vec2(0.02,0.15));\n    return min(d1,min(d3,d2));\n}\n\nfloat propellers(vec3 p)\n{\n    vec3 z=p;\n    z.xz=abs(z.xz);\n    z.x-=0.25;\n    z.y+=0.08;\n    z.z-=0.25;\n    \n    float d=1e10;\n    d=propeller(z);\n    return d;\n}\n\nfloat gun(vec3 p)\n{\n    p.y-=0.12;\n    return cylinder(p, vec2(0.007,0.35));\n}\n\nfloat spaceship(vec3 p)\n{\n    rotate_z(p,1.5708);\n    rotate_y(p,iTime*0.2);\n    p.y+=1.0;\n    float d=1e10;\n    float d1=cylinder(vec3(p.x,p.y,p.z),vec2(0.04,0.29));\n    float d2=cylinder(vec3(p.x,p.y,p.z)+vec3(0.0,-0.1,0.0),vec2(0.07,0.09));\n   \n    \n    float d3=propellers(p);\n    float d4=gun(p);\n    if(d>d1){d=d1;}\n    if(d>d2){d=smin(d,d2,0.1);}\n    if(d>d3){d=min(d,d3);}\n    if(d>d4){d=smin(d,d4,0.1);}\n    return d;\n}\n\nfloat dist_to_beam=1e10;\nfloat beam(vec3 p)\n{\n    p.xy=p.yx;\n   \t\n    return cylinder(p, vec2(0.01, 0.45));\n}\n\nfloat f(vec3 p)\n{\n    type=SUN;\n    float d1=sphere(p-vec3(1.0,0.0,0.0), 0.8);\n    float d2=spaceship(p+vec3(0.5,0.0,0.0));\n    float d=1e10;\n    if(d>d1){d=d1;type=SUN;}\n    if(d>d2){d=d2;type=SPACE_SHIP;}\n    \n    float db=beam(p+vec3(0.24,0.0,0.0)); \n    if(dist_to_beam>db){dist_to_beam=db;}  \n    \n    return d;\n}\n\n\nvec3 calcnormal(vec3 p)\n{ \n    vec3 e=vec3(0.001,0.0,0.0); \n    return normalize(vec3(f(p+e.xyy)-f(p-e.xyy), \n                      f(p+e.yxy)-f(p-e.yxy), \n                      f(p+e.yyx)-f(p-e.yyx))); \n}\n\n\nfloat intersect( in vec3 ro, in vec3 rd)\n{\n    float t = 0.0;\n    float h = 1.0;\n    \n    mindist=1e10;\n   \n    for( int i=0; i<48; i++ )\n    {\n        if( h<0.001 || t>20.0 ) continue;\n        h = f(ro + rd*t);\n        mindist=min(h,mindist);\n        t += h;\n    }\n    \n    if(t>20.0) t=-1.0;\n    return t;\n}\n\nvec3 lighting(vec3 p,vec3 rd)\n{\n    vec3 n=calcnormal(p);\n    vec3 col=vec3(0.0);\n    vec3 l1_dir=normalize(vec3(1.0,0.0,0.0));\n    vec3 l2_dir=normalize(vec3(0.0,0.0,1.0));\n     \n    if(type<SUN)   // space ship\n    {\n        float diff=max(0.0,dot(n,l1_dir));\n        float diff2=max(0.0,dot(n,l2_dir));\n        float spec = max(0.0, pow(clamp(dot(l1_dir, reflect(rd, n)), 0.0, 1.0), 8.0));\n            \n        col=0.8*(0.2*(3.0*diff+diff2+5.0*spec)*vec3(0.3,0.5,0.9))+0.2*3.0*diff*\n             vec3(1.7, 0.62,0.0)*max(0.0,sin(iTime));\n    }\n    else    // sun\n    {\n        float diff=max(0.0,dot(n,l2_dir));\n        col=diff*texture(iChannel0, vec2(p.x,p.y)*0.9+iTime*0.05).xxx*vec3(1.3, 0.6,0.2);\n    }\n    return col;\n}\n\nvec3 getbackground(vec3 p)\n{\n    vec3 col=texture(iChannel0, p.xy*0.5).xxx;\n    col=pow(col,vec3(2.0));\n    return col;\n}\n\nvec3 scene(vec3 ro, vec3 rd)\n{\n    float hit=intersect(ro,rd);\n    vec3 pos;\n    vec3 col=vec3(0.0);\n    \n    pos=ro+hit*rd;\n    \n    \n    //col+=pow(max(1.0-dist_to_beam,0.0),100.0)*vec3(1.7,0.247, 0.0)*max(0.0,cos(iTime));\n   \n    // the fake beam\n    col = mix(col, vec3(1.7, 0.2, 0.0), \n              pow((smoothstep(0.0, 0.05, pos.y+0.05) - smoothstep(0.05, 0.1, pos.y+0.05)) *\n                  (smoothstep(-1.0,0.0,pos.x) - smoothstep(0.0, 1.0, pos.x)), 40.0)) *\n          max(0.0, sin(iTime+1.0));\n                                                                                          \n    \n    if(type>SPACE_SHIP)  // sun\n    {\n      col += pow(max(1.0 - mindist,0.0), 10.0)*\n             (vec3(1.7, 0.6470, 0.0))*sin(iTime-0.5); // nagative color to dim the sun\n      \n    }\n    \n    if(hit>0.0)\n    {\n        col+=lighting(pos,rd);\n        float t=mod(pos.x-iTime, 6.283185307); // match the cycle of sin\n \n      \tcol += vec3(1.7, 0.2, 0.0)*\n              pow(smoothstep(0.0, .3, t) * smoothstep(0.5, .3, t), 20.0)\n             ;\n    }\n    else\n    {\n        col+=(0.3+2.7*max(0.0,sin(iTime)))*vec3(0.01,0.025,0.05)*getbackground(pos);\n    }\n    \n    return max(col,vec3(0.0));\n}\n\n\nvec3 tracer(vec2 fragCoord) {\n    float fov=3.0;\n    vec3 col = vec3(0.0);\n    vec2 p = 2.0*(fragCoord.xy)/iResolution.xy-1.0;\n    p.x*=iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy;\n    if (iMouse.x == 0.0 && iMouse.y == 0.0) {\n        m = vec2(iTime * 0.06 + 0.14,0.5);    \n    }\n    m = -1.0 + 2.0 * m;\n    m *= vec2(4.0,-1.5);\n    \n    vec3 ta = vec3(0.0, 0.0, 0.0);\n    vec3 ro=vec3(0.0,0.0,4.5);\n\n    vec3 cf = normalize(ta-ro); \n    vec3 cs = normalize(cross(cf,vec3(0.0,1.0,0.0))); \n    vec3 cu = normalize(cross(cs,cf)); \n    vec3 rd = normalize(p.x*cs + p.y*cu + fov*cf);\n        \n    col=scene(ro,rd);\n    return  col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec3 col = tracer(fragCoord);\n    // post\n    col=pow(clamp(col,0.0,1.0),vec3(0.45)); \n    col=col*0.6+0.4*col*col*(3.0-2.0*col);\n    col=mix(col, vec3(dot(col, vec3(0.33))), -0.7); \n    col*=pow(20.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7); \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2GRR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[208, 245, 284, 284, 373], [375, 375, 414, 414, 531], [534, 534, 573, 573, 689], [692, 692, 730, 730, 847], [850, 850, 882, 882, 999], [1001, 1001, 1033, 1033, 1059], [1061, 1061, 1086, 1086, 1361], [1363, 1363, 1389, 1389, 1527], [1529, 1529, 1548, 1548, 1607], [1609, 1609, 1634, 1634, 2037], [2064, 2064, 2084, 2084, 2148], [2150, 2150, 2167, 2167, 2468], [2471, 2471, 2496, 2496, 2676], [2679, 2679, 2721, 2721, 2988], [2990, 2990, 3021, 3021, 3717], [3719, 3719, 3747, 3747, 3840], [3842, 3842, 3872, 3872, 5035], [5038, 5038, 5067, 5067, 5692], [5694, 5694, 5751, 5751, 6071]], "test": "untested"}
{"id": "ll2Gzh", "name": "Distorted rings", "author": "flypig", "description": "A very 2D pattern: a distorted grid of rings, twisted across the canvas, and with a light shadow effect for some semblance of depth.\n\nThis is an example shader developed for use with shaderback.js", "tags": ["2d", "flat", "rings", "distorted"], "likes": 0, "viewed": 1205, "published": "Public API", "date": "1426986396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nCopyright (c) 2015 David Llewellyn-Jones\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\nprecision highp float;\n\n#define M_PI 3.1415926535897932384626433832795\n\n// (((((x - xc1)**2) + ((y - yc1)**2) - (r1**2)) * (((x - xc2)**2) + ((y - yc2)**2) - (r2**2)))) < (s / 1000)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vTextureCoord = fragCoord / iResolution.xy;\n    float width = iResolution.x;\n    float height = iResolution.y;\n    float time = iTime * 1000.0;\n\n\tvec2 ratio = vec2(width, height) / width;\n\tvec2 pos = vTextureCoord * ratio;\n\tfloat scale = (3.0 + sin(time / 25000.0)) / 5.0;\n\tpos += vec2(sin(time / 3500.0), sin(time / 3650.0)) * 0.1;\n\tvec2 centre = vec2(0.1 * scale, 0.1 * scale);\n\n\tfloat radius1 = distance(vec2(mod(sin(sin((0.5 * M_PI * pos.y) + time / 3800.0) + pos.x * M_PI), 0.2 * scale),\n\t\tmod(sin(cos((0.5 * M_PI * pos.x) + time / 4100.0) + pos.y * M_PI), 0.2 * scale)), centre);\n\n\tfloat angle1 = atan (pos.x - 0.5, pos.y - 0.5);\n\n\tfloat angle2 = atan (mod(sin(sin((0.5 * M_PI * pos.y) + time / 3800.0) + pos.x * M_PI), 0.2 * scale) - centre.x, \n\t\tmod(sin(cos((0.5 * M_PI * pos.x) + time / 4100.0) + pos.y * M_PI), 0.2 * scale) - centre.y);\n\n\tfloat red = 0.0;\n\tfloat green = 0.0;\n\tfloat blue = 0.0;\n\tif ((radius1 < 0.09 * scale) && (radius1 > 0.06 * scale)) {\n\t\tred = 1.0 - (sin ((time / 3300.0) + angle2 * 3.0) + 1.0) / 3.0;\n\t\tgreen = (sin ((time / 3200.0) + angle2 * 3.0) + 1.0) / 2.0;\n\t\tblue = (sin ((time / 3200.0) + angle1 * 3.0) + 1.0) / 2.0;\n\t}\n\telse {\n\t\tred = 1.0;\n\t\tgreen = 1.0;\n\t\tblue = 0.5;\n\n\t\tvec2 shadow = vec2(+0.005, -0.005);\n\t\tfloat radius1 = distance(vec2(mod(sin(sin((0.5 * M_PI * (pos.y - shadow.y)) + time / 3800.0) + (pos.x - shadow.x) * M_PI), 0.2 * scale),\n\t\tmod(sin(cos((0.5 * M_PI * (pos.x - shadow.x)) + time / 4100.0) + (pos.y - shadow.y) * M_PI), 0.2 * scale)), centre);\n\n\t\tif ((radius1 < 0.09 * scale) && (radius1 > 0.06 * scale)) {\n\t\t\tfloat darkness = cos(M_PI * (((radius1 / scale) - 0.075) / 0.03));\n\t\t\tred = 1.0 - 0.5 * darkness;\n\t\t\tgreen = 1.0 - 0.5 * darkness;\n\t\t\tblue = 0.5 - 0.5 * darkness;\n\t\t}\n\n\t}\n\n\tvec4 colour = vec4(red, green, blue, 1.0);\n\n\tfragColor = colour;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2Gzh.jpg", "access": "shaders20k", "license": "mit", "functions": [[1146, 1257, 1314, 1314, 3134]], "test": "untested"}
{"id": "ll2GzR", "name": "wake up", "author": "Dermenslof", "description": "cool, i love perlin noise", "tags": ["sunsea"], "likes": 1, "viewed": 140, "published": "Public", "date": "1426692626", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct\t\tobj\n{\n    int id;\n\tvec4 pos;\n\tvec3 dir;\n    vec3 col;\n    float ka;\n    float kd;\n    float ks;\n    float kl;\n};\n\nvec3 cam = vec3(0.0, -0.8, 8.0);\n\nobj olum = obj(0, vec4(0.0, 2.0, 0.0, 0.0), vec3(0.0), vec3(0.01, 0.01, 0.01), 0.0, 0.0, 0.0, 0.0);\nobj olum2 = obj(-1, vec4(0.0, 2.0, -100.0, 0.0), vec3(0.0), vec3(1.0, 0.2, 0.0), 0.0, 0.0, 0.0, 0.0);\nobj osph = obj(1, vec4(200.0, 110.0, -500.0, 10.0), vec3(0.0), vec3(1.0, 1.0, 1.0), 0.0, 0.4, 0.2, 1.0);\nobj opln = obj(2, vec4(0.0, -1.0, 0.0, -1.0), vec3(0.0), vec3(1.0, 0.0, 0.0), 0.0, 0.2, 0.8, 1.0);\nobj opln2 = obj(3, vec4(0.0, -0.9, 0.1, 200.0), vec3(0.0), vec3(0.0, 0.0, 1.0), 0.4, 1.0, 1.0, 1.0);\nobj osph2 = obj(4, vec4(0.0, -12.0, -200.0, 10.0), vec3(0.0), vec3(1.0, 0.2, 0.0), 1.0, 0.0, 0.0, 142.0);\n\nfloat rand;\nvoid randomize(vec2 c)\n{\n    rand = fract(sin(dot(c, vec2(113.421,17.329))) * 3134.1234);\n}\n\nfloat tri(in float x)\n{\n    return abs(fract(x) - 0.5);\n}\nvec3 tri3(in vec3 p)\n{\n    return vec3(tri(p.z + tri(p.y)), tri(p.z + tri(p.x)), tri(p.y+tri(p.x)));\n}\n                                 \nfloat noise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.0;\n    vec3 bp = p;\n\tfor (float i = 0.0; i <= 3.0; i++ )\n\t{\n        vec3 dg = tri3(bp * 2.0);\n        p += (dg + iTime * 0.1 * spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        \n        rz+= (tri(p.z + tri(p.x + tri(p.y)))) / z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nobj\t\tgetObj(in int id)\n{\n\tif (id == 1)\n        return (osph);\n    if (id == 2)\n        return (opln);\n    if (id == 3)\n        return (opln2);\n    if (id == 4)\n        return (osph2);\n    return (olum);\n}\n\nfloat\tisphere(in vec3 ro, in vec3 rd, in int id)\n{\n\tobj o = getObj(id);\n    ro = ro - o.pos.xyz;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(ro, rd);\n    float c = dot(ro, ro) - o.pos.w * o.pos.w;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.001)\n        return (-1.0);\n    a *= 2.0;\n    return (min((-b - sqrt(d)) / a, (-b + sqrt(d)) / a));\n}\n\nvec3\tnsphere(in vec3 pos, in int id, in int type)\n{\n\tobj o = getObj(id);\n    vec3 n = (pos - o.pos.xyz) / o.pos.w;\n    if (type == 0 || id == 4)\n        return (n);\n    vec3 eps = vec3(0.9, 0.0, 0.0);\n    return (vec3(n.x + noise3D(n - eps, 0.0) - noise3D(n + eps, 0.0),\n                 n.y + noise3D(n - eps.yxz, 0.0) - noise3D(n + eps.yxz, 0.0),\n                 n.z + noise3D(n - eps.zyx, 0.0) - noise3D(n + eps.zyx, 0.0)));\n}\n\nfloat\tiplane(in vec3 ro, in vec3 rd, in int id)\n{\n    obj o = getObj(id);\n    if (id == 2)\n    \t//ro.y += noise3D(cos(vec3(rd.y, rd.x, rd.y + 2.0)) * 8.0, 0.2) / 1.5;\n    \tro.y += noise3D(rd, 0.6);\n        \n    float d = -(dot(ro, normalize(o.pos.xyz)) + o.pos.w) / dot(rd, normalize(o.pos.xyz));\n\n    return (d);\n}\n\nvec3\tnplane(in vec3 pos, in int id, in int type)\n{\n    vec3 n, eps;\n    obj o = getObj(id);\n\tn = o.pos.xyz * -1.0;\n    if (type == 0 || id == 3)\n        return (n);\n    vec3 nn = vec3(n.x + pos.x, 50.0 * n.y + 100.0 * pos.y, n.z + pos.z);\n    \n    eps = vec3(0.001, 0.0, 0.0);\n    return (vec3(n.x + noise3D(nn - eps, 0.6) - noise3D(nn + eps, 0.6),\n                 n.y + noise3D(nn - eps.yxz, 0.6) - noise3D(nn + eps.yxz, 0.6),\n                 n.z + noise3D(nn - eps.zyx, 0.6) - noise3D(nn + eps.zyx, 0.6)));\n}\n\nfloat\tgetIntersect(in vec3 ro, in vec3 rd, in int id)\n{\n\tif (id == 1 || id == 4)\n        return (isphere(ro, rd, id));\n    if (id > 1)\n        return (iplane(ro, rd, id));\n    return (-1.0);\n}\n\nvec3\tgetNormale(in vec3 pos, in int id, in int type)\n{\n\tif (id == 1 || id == 4)\n        return (nsphere(pos, id, type));\n    if (id > 1)\n        return (nplane(pos, id, type));\n    return (vec3(0.0));\n}\n\nvec3\tgetColor(in vec3 p, int id)\n{\n    if (id == 3)\n    {\n    \tp.z += iTime * 20.0;\n    }\n    vec3 c1, c2, c3;\n    float v1, v2, v3;\n    v1 = 0.0;\n    v2 = 0.3;\n    v3 = 10.0;\n    c1 = vec3(0.0, 0.0, 0.0);\n    c2 = vec3(0.5, 0.5, 0.5);\n    c3 = vec3(0.01, 0.01, 0.0);\n    \n    if (id == 2)\n    {\n    \tc1 = vec3(1.0, 1.0, 1.0);\n    \tc2 = vec3(0.0, 0.0, 0.5);\n    \tc3 = vec3(0.2, 0.5, 1.0);\n        v1 = 0.2;\n    \tv2 = 0.1;\n    \tv3 = 0.4;\n    }\n\t\n    float n = abs(noise3D(id == 2 ? p : p / 800.0, 0.02));\n    \n    if (n < v1)\n        return c1;\n    if (n < v2)\n    \treturn c1 * (n - v1) / (v2 - v1) + c2 * (v2 - n) / (v2 - v1);\n\tif (n < v3)\n        return c2 * (n - v2) / (v3 - v2) + c3 * (v3 - n) / (v3 - v2);\n    return c3;\n}\n\nint\t\tintersect(in vec3 ro, in vec3 rd, out float t)\n{\n    int id = -1;\n    \n    t = 1000000.0;\n    for (int i = 1; i < 5; i++)\n    {\n        float ti = getIntersect(ro, rd, i);\n        if (ti > 0.001 && ti < t)\n        {\n            id = i;\n            t = ti;\n        }\n    }\n    return (id);\n}\n\nvec3\tprocessColor(in vec2 uv, in vec3 ro, in vec3 rd, in float t, int id, int inside)\n{\n    obj o, l;\n\tvec3 amb, dif, spe, p, n, ln, lp, nlp, ocol;\n    float ps1, ps2, t1, coef;\n    int id2;\n\n    o = getObj(id);\n    p = ro + t * rd;\n    ocol = (id == 1 || id == 4) ? o.col : getColor(p, id);\n    if (id == 3 && osph2.pos.y > -12.5)\n    {\n    \tvec3 col2 = vec3(0.0, 0.6, 1.0);\n    \tocol -= mix(col2, vec3(0.0, 0.0, 0.0), (osph2.pos.y + 15.0) / 6.0);\n    }\n    n = getNormale(p, id, 1);\n    l = olum;\n    lp = normalize(l.pos.xyz - p);\n    nlp = normalize(p - l.pos.xyz);\n    ps1 = dot(n, lp);\n    ps2 = -dot(n, nlp);\n    amb = ocol * o.ka;\n    dif = spe = vec3(0.0);\n    if (ps1 > 0.0)\n    {\n        id2 = intersect(l.pos.xyz, nlp, t1);\n    \tif (id2 == id || id == 1)\n        {\n            dif = o.kd * ocol * ps1;\n    \t\tif (ps2 > 0.0)\n    \t\t    spe = l.col * o.ks * pow(ps2, o.kl);\n        }\n    }\n    l = olum2;\n    lp = normalize(l.pos.xyz - p);\n    nlp = normalize(p - l.pos.xyz);\n    ps1 = dot(n, lp);\n    ps2 = -dot(n, nlp);\n    if (ps1 > 0.0)\n    {\n        id2 = intersect(l.pos.xyz, nlp, t1);\n    \tif (id2 == id || id == 1)\n        {\n            dif += o.kd * ocol * ps1;\n    \t\tif (ps2 > 0.0)\n    \t\t    spe += l.col * o.ks * pow(ps2, o.kl);\n        }\n    }\n    return (amb + dif +spe);\n}\n\nvec3\tgetPixelColor(in vec2 uv, in vec3 ro, in vec3 rd)\n{\n    vec3 col = vec3(0.0);\n    float t = 1000.0;\n    int id = intersect(ro, rd, t);\n    \n    if (id > 0)\n    \treturn (processColor(uv, ro, rd, t, id, 0));\n    return (col);\n}\n\nmat3 mid = mat3(1.0, 0.0, 0.0,\n                0.0, 1.0, 0.0,\n                0.0, 0.0, 1.0);\n\nmat3\trotX(float a)\n{\n\tmat3 m;\n    \n    m = mid;\n    m[1][1] = cos(a);m[1][2] = -sin(a);\n    m[2][1] = sin(a);m[2][2] = cos(a);\n    return (m);\n}\n\nmat3\trotY(float a)\n{\n\tmat3 m;\n    \n    m = mid;\n    m[0][0] = cos(a);m[0][2] = -sin(a);\n    m[2][0] = -sin(a);m[2][2] = cos(a);\n    return (m);\n}\n\nmat3\trotZ(float a)\n{\n\tmat3 m;\n    \n    m = mid;\n    m[0][0] = cos(a);m[0][1] = -sin(a);\n    m[1][0] = sin(a);m[1][1] = cos(a);\n    return (m);\n}\n\nmat3\trot(float x,float y, float z)\n{\n\tmat3 m;\n    \n    x = x * 3.1415 / 180.0;\n    y = y * 3.1415 / 180.0;\n    z = z * 3.1415 / 180.0;\n    m = mid;\n    m *= rotX(x);\n    m *= rotY(y);\n    m *= rotZ(z);\n    return (m);\n}\n\nvoid\tmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = tan(30.0 * 3.14 / 180.0);\n    float ratio = iResolution.x / iResolution.y;\n\tvec2 uv = (-1.0 + 2.0 * fragCoord.xy / iResolution.xy);\n    uv *= vec2(e, e / ratio);\n    vec3 ro = cam;\n    vec3 rd = normalize(vec3(uv, -1.0));\n    float y = sin(iTime) * 5.0 + 5.0;\n    osph2.pos.y += y;\n    olum2.pos.y += y;\n    osph2.col.y += y / 10.0;\n    osph.pos.z += y * y * y;\n    osph.ka *= 1.0 / y;\n    olum2.col *= y /50.0;\n    opln.kd += y / 20.0;\n    opln.kl -= y / 20.0;\n\n\tfragColor = vec4(getPixelColor(uv, ro, rd),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2GzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[782, 782, 806, 806, 873], [875, 875, 898, 898, 932], [933, 933, 955, 955, 1035], [1070, 1070, 1110, 1110, 1415], [1417, 1417, 1441, 1441, 1621], [1623, 1623, 1673, 1673, 1977], [1979, 1979, 2030, 2030, 2409], [2411, 2411, 2460, 2460, 2726], [2728, 2728, 2778, 2778, 3240], [3242, 3242, 3297, 3297, 3434], [3436, 3436, 3490, 3490, 3638], [3640, 3640, 3674, 3674, 4366], [4368, 4368, 4421, 4421, 4663], [4665, 4665, 4752, 4752, 5959], [5961, 5961, 6017, 6017, 6191], [6288, 6288, 6308, 6308, 6432], [6434, 6434, 6454, 6454, 6579], [6581, 6581, 6601, 6601, 6725], [6727, 6727, 6763, 6763, 6946], [6948, 6948, 7005, 7005, 7534]], "test": "untested"}
{"id": "ll2GzW", "name": "test matrix transform", "author": "Dermenslof", "description": "i try to understand how matrix-tranformation works.", "tags": ["raytracermatrixtransform"], "likes": 1, "viewed": 156, "published": "Public", "date": "1427367523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct\t\tobj\n{\n    int id;     // id of object\n\tvec3 pos;   // position\n\tvec3 dir;   // direction\n    vec3 scale; // scale\n    vec3 col;   // color\n    float r;    // radius\n    float ka;   // ambiance coeff\n    float kd;   // diffuse coeff\n    float ks;   // spectral coeff\n    float kl;   // shishiness coeff\n};\n\nvec4 cam = vec4(0.0, 0.0, 8.0, 1.0); // camera pos\n\nobj olum = obj(0,\n               vec3(0.0, 4.0, 0.0),\n               vec3(0.0, 0.0, 0.0),\n               vec3(1.0,1.0, 1.0),\n               vec3(1.0, 1.0, 1.0),\n               0.0, 0.0, 0.0, 0.0, 0.0); // light\nobj osph = obj(1,\n               vec3(0.0, 0.0, 0.0),\n               vec3(0.0, 0.0, 0.0),\n               vec3(0.5, 1.0, 0.5),\n               vec3(1.0, 1.0, 1.0),\n               0.5, 0.15, 0.5, 0.5, 1042.0); // sphere\nobj opln = obj(2,\n               vec3(0.0, -1.0, 0.0),\n               vec3(0.0, 0.0, 0.0),\n               vec3(1.0, 1.0, 1.0),\n               vec3(1.0, 0.0, 0.0),\n               0.0, 0.15, 0.5, 0.5, 42.0); // plane\n\nmat4 mid = mat4(1.0, 0.0, 0.0, 0.0,\n                0.0, 1.0, 0.0, 0.0,\n                0.0, 0.0, 1.0, 0.0,\n                0.0, 0.0, 0.0, 1.0);\n\nmat4\ttranslate(in vec3 tr)\n{\n    mat4 m;\n    \n    m = mid;\n    m[0][3] = tr.x;\n    m[1][3] = tr.y;\n    m[2][3] = tr.z;\n    return m;\n}\n\nmat4\tinvTranslate(in vec3 tr)\n{\n    mat4 m;\n    \n    m = mid;\n    m[0][3] = -tr.x;\n    m[1][3] = -tr.y;\n    m[2][3] = -tr.z;\n    return m;\n}\n\nmat4\tscale(in vec3 sc)\n{\n    mat4 m;\n    \n    m = mid;\n    m[0][0] = sc.x;\n    m[1][1] = sc.y;\n    m[2][2] = sc.z;\n    return m;\n}\n\nmat4\tinvScale(in vec3 sc)\n{\n    mat4 m;\n    \n    m = mid;\n    m[0][0] = 1.0 / sc.x;\n    m[1][1] = 1.0 / sc.y;\n    m[2][2] = 1.0 / sc.z;\n    return m;\n}\nmat4\trotX(float a)\n{\n\tmat4 m;\n    \n    m = mid;\n    m[1][1] = cos(a);m[1][2] = -sin(a);\n    m[2][1] = sin(a);m[2][2] = cos(a);\n    return (m);\n}\n\nmat4\trotY(float a)\n{\n\tmat4 m;\n    \n    m = mid;\n    m[0][0] = cos(a);m[0][2] = -sin(a);\n    m[2][0] = -sin(a);m[2][2] = cos(a);\n    return (m);\n}\n\nmat4\trotZ(float a)\n{\n\tmat4 m;\n    \n    m = mid;\n    m[0][0] = cos(a);m[0][1] = -sin(a);\n    m[1][0] = sin(a);m[1][1] = cos(a);\n    return (m);\n}\n\nmat4\trot(float x,float y, float z)\n{\n\tmat4 m;\n    \n    x = x * 3.1416 / 180.0;\n    y = y * 3.1416 / 180.0;\n    z = z * 3.1416 / 180.0;\n    m = mid;\n\tm *= rotY(y);\n    m *= rotZ(z);\n    m *= rotX(x);\n    return (m);\n}\n\nmat4\tinvRot(float x,float y, float z)\n{\n\tmat4 m;\n    \n    x = -x * 3.1416 / 180.0;\n    y = -y * 3.1416 / 180.0;\n    z = -z * 3.1416 / 180.0;\n    m = mid;\n    m *= rotX(x);\n    m *= rotZ(z);\n\tm *= rotY(y);\n    return (m);\n}\n\nvec4\ttransform(in vec4 v, in obj o)\n{\n\tmat4 m;\n\n    m = scale(o.scale);\n    m *= rot(o.dir.x, o.dir.y, o.dir.z);\n    m *= translate(o.pos);\n    v *= m;\n    if (v.w != 0.0)\n        v /= v.w;\n    return v;\n}\n\nvec4\tinvTransform(in vec4 v, in obj o)\n{\n\tmat4 m;\n    \n    m = invTranslate(o.pos);\n\tm *= invRot(o.dir.x, o.dir.y, o.dir.z);\n    m *= invScale(o.scale);\n    v *= m;\n    if (v.w != 0.0)\n        v /= v.w;\n    return v;\n}\n\nobj\t\tgetObj(in int id)\n{\n\tif (id == 1)\n        return (osph);\n    return (opln);\n}\n\nvec4\tcorrect(in vec4 n, in vec4 rd, in obj o)\n{\n\trd = invTransform(rd, o);\n    if (dot(n.xyz, rd.xyz) > 0.0)\n        n.xyz = n.xyz * -1.0;\n    n = transform(n, o);\n    return (vec4(normalize(n.xyz), 0.0));\n}\n\nfloat\tisphere(in vec4 ro, in vec4 rd, in int id, out vec4 i)\n{\n\tobj o = getObj(id);\n    ro = invTransform(ro, o);\n    rd = invTransform(rd, o);\n    float a = dot(rd.xyz, rd.xyz);\n    float b = dot(ro.xyz, rd.xyz);\n    float c = dot(ro.xyz, ro.xyz) - o.r * o.r;\n    float delta = b * b - a * c;\n    if (delta < 0.0)\n        return (-1.0);\n    float t1 = (-b + sqrt(delta)) / a;\n    float t2 = (-b - sqrt(delta)) / a;\n\tif (t1 <= 0.001 && t2 <= 0.001)\n\t\treturn (-1.0);\n    float t;\n\tif ((t1 <= t2 && t1 > 0.001) || (t2 < t1 && t2 < 0.001))\n\t\tt = t1;\n    else if ((t2 <= t1 && t2 > 0.001) || (t1 < t2 && t1 < 0.001))\n\t\tt = t2;\n    i.xyz = ro.xyz + rd.xyz * t;\n    i.w = 1.0;\n    t = length(ro.xyz - i.xyz);\n    i = transform(i, o);\n    return (t);\n}\n\nvec4\tnsphere(in vec4 p, in obj o, in vec4 rd)\n{\n    vec4 n = invTransform(p, o);\n    n.xyz /= n.w;\n    n.w = 0.0;\n    return correct(n, rd, o);\n}\n\nfloat\tiplane(in vec4 ro, in vec4 rd, in int id, out vec4 i)\n{\n    obj o = getObj(id);\n    ro = invTransform(ro, o);\n    rd = invTransform(rd, o);\n    if (rd.y == 0.0)\n        return (-1.0);\n    float t = -ro.y / rd.y;\n    if (t <= 0.0)\n        return (-1.0);\n    i.xyz = ro.xyz + rd.xyz  * t;\n    i.w = 1.0;\n    i.y = 0.0;\n    t = length(ro.xyz - i.xyz);\n\ti = transform(i, o);\n    return (t);\n}\n\nvec4\tnplane(in vec4 pos, in obj o, in vec4 rd)\n{\n    vec4 n = vec4(0.0, 1.0, 0.0, 0.0);\n\treturn correct(n, rd, o);\n}\n\nfloat\tgetIntersect(in vec4 ro, in vec4 rd, in int id, out vec4 i)\n{\n\tif (id == 1)\n        return (isphere(ro, rd, id, i));\n    return (iplane(ro, rd, id, i));\n}\n\nvec4\tgetNormale(in vec4 pos, in obj o, in vec4 rd)\n{\n\tif (o.id == 1)\n        return (nsphere(pos, o, rd));\n    return (nplane(pos, o, rd));\n}\n\nint\t\tintersect(in vec4 ro, in vec4 rd, out float t, out vec4 it)\n{\n    int id = -1;\n    \n    t = -1.0;\n    for (int i = 1; i < 3; i++)\n    {\n        float ti = getIntersect(ro, rd, i, it);\n        if (ti > 0.001 && (t < 0.0 || ti < t))\n        {\n            id = i;\n            t = ti;\n        }\n    }\n    return (id);\n}\n\nbool\tisLightning(in vec4 p) // p is the point of the intersection\n{\n    float t; // length of ray\n    vec4 ipt; // useless\n    vec4 ild = vec4(normalize(olum.pos - p.xyz), 0.0); // invert light direction\n    vec3 d = p.xyz - olum.pos; // length between point and light\n    \n\tint id = intersect(p, ild, t, ipt);\n    if (id > 0 && t > 0.001 && t < length(d))\n        return false;\n    return true;\n}\n\nvec3\tprocessColor(in vec4 ro, in vec4 rd, in float t, int id, in vec4 p)\n{\n    obj o, l; // object and light\n\tvec3 amb, dif, spe; // ambiance, diffuse, spectral colors\n    vec4 n, ld, ild;\n    float ps1, ps2;\n\n    o = getObj(id);\n    l = olum;\n    n = getNormale(p, o, rd); // normal\n    ld = vec4(normalize(l.pos - p.xyz), 0.0); // light direction\n    ild = vec4(normalize(p.xyz - l.pos), 0.0); // inverse light direction\n    ps1 = dot(n, ld);\n    ps2 = -dot(n, ild);\n    amb = o.col * o.ka;\n    dif = spe = vec3(0.0);\n    if (isLightning(p) && ps1 > 0.0)\n    {\n        dif = o.kd * o.col * ps1;\n    \tif (ps2 > 0.0)\n    \t\tspe = l.col * o.ks * pow(ps2, o.kl);\n    }\n    return (clamp(amb + dif + spe, 0.0, 1.0));\n}\n\nvec3\tgetPixelColor(in vec4 ro, in vec4 rd)\n{\n    vec3 col = vec3(0.0);\n    float t;\n    vec4 i;\n    int id = intersect(ro, rd, t, i);\n    \n    if (id > 0)\n    \treturn (processColor(ro, rd, t, id, i));\n    return (col);\n}\n\nvoid\tmainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float e = tan(30.0 * 3.1416 / 180.0);\n    float ratio = iResolution.x / iResolution.y;\n\tvec2 uv = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n    uv *= vec2(e, e / ratio);\n    vec4 ro = cam; // ray origin\n    vec4 rd = vec4(normalize(vec3(uv, -1.0)), 0.0); // ray direction\n    float c = cos(iTime);\n    float s = sin(iTime);\n    osph.dir.x += c * 180.0 + 180.0; // rotation x of sphere\n    osph.dir.z += s * 180.0 + 180.0; // rotation y of sphere\n    olum.pos.x += c * 3.0; // position x of light\n    olum.pos.z += s * 3.0; // position y of light\n\tfragColor = vec4(getPixelColor(ro, rd),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ll2GzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1000, 1156, 1184, 1184, 1290], [1292, 1292, 1323, 1323, 1432], [1434, 1434, 1458, 1458, 1564], [1566, 1566, 1593, 1593, 1717], [1718, 1718, 1738, 1738, 1862], [1864, 1864, 1884, 1884, 2009], [2011, 2011, 2031, 2031, 2155], [2157, 2157, 2193, 2193, 2373], [2375, 2375, 2414, 2414, 2597], [2599, 2599, 2636, 2636, 2804], [2806, 2806, 2846, 2846, 3024], [3026, 3026, 3050, 3050, 3108], [3110, 3110, 3157, 3157, 3317], [3319, 3319, 3381, 3381, 4064], [4066, 4066, 4113, 4113, 4211], [4213, 4213, 4274, 4274, 4607], [4609, 4609, 4657, 4657, 4725], [4727, 4727, 4794, 4794, 4887], [4889, 4889, 4941, 4941, 5030], [5032, 5032, 5098, 5098, 5352], [5354, 5354, 5421, 5421, 5751], [5753, 5753, 5827, 5827, 6467], [6469, 6469, 6513, 6513, 6689], [6691, 6691, 6748, 6748, 7350]], "test": "untested"}
{"id": "llB3RW", "name": "echo_lemniscate", "author": "echophon", "description": "shadeaday - ideas borrowed from http://tokyodemofest.jp/2014/7lines/index.html ", "tags": ["shadeaday"], "likes": 11, "viewed": 302, "published": "Public", "date": "1427263878", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//init to middle of screen\n    vec2 p = fragCoord.xy / iResolution.xy;\n    //alias time\n    float time = iTime;\n    //init c\n\tvec3 c=vec3(0);\n    for(int i=0;i<160;i++){\n        //create a position for each point\n        float t = 2.*3.14*float(i)/160. * sin(time*0.5);\n        //sohcahtoa\n        float x = -cos(t)+2.;\n        //float x = 1./80. * float(i) + 1.; \n        float y = sin(t*2.)+2.;\n        //radius\n        vec2 o = .25*vec2(x,y);\n        //from middle to radius\n        c += 0.001/(length(p-o))*vec3(0.5);\n    }\n    fragColor = vec4(c,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llB3RW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 85, 615]], "test": "untested"}
{"id": "llB3zw", "name": "Galaxy 3d", "author": "guil", "description": "Use mouse to change view.", "tags": ["3d", "volumetric", "galaxy"], "likes": 18, "viewed": 735, "published": "Public", "date": "1427624964", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\n// Galaxy morphology based on http://iopscience.iop.org/0004-637X/783/2/138/pdf/0004-637X_783_2_138.pdf\n\nfloat zoom=1.;\nconst float arms = 2.;\nconst float winding = 9.;\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\nconst mat2 m2 = mat2(.8,.6,-.6,.8);\n\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=2.;\n\tfor( int i=0; i< 4; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.0;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/4.;\n}\n\nfloat noise(in vec3 p)\n{\n   \n\tp*=2.;\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p.xy=m2*p.xy;\n        p=p.zxy*f+.6;     \n        f*=1.15;\n        res+=sin(p.y+1.3*sin(1.2*p.x)+1.7*sin(1.7*p.z));\n\t}        \t\n\treturn res/3.;\n\n}\n\n\nfloat fbmdisk( vec3 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<5;i++){\t\n\t\tr += abs(noise( p*(f) ))/f;       \n\t    f +=f;\n        \n\t}\n\treturn 1.2/(.07+r);\n}\n\n\nfloat fbmgal( vec3 p ) {\n    \n    p=p*4.;\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<5;i++){\t\n\t\tr += noise( p*(20.+3.*f) )/f; \n        p.xz*=m2;\n\t    f +=1.;\n        \n\t}\n\treturn pow(abs(r),4.);\n}\n\n\n\nfloat fbmdust( vec3 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<5;i++){\t\n\t\tr += 1./abs(noise( p*(f) ))/f;       \n\t    f +=f;\n        \n\t}\n\treturn pow(abs(1.-1./(.01+r)),4.);\n}\n\n\nfloat theta(float r, float wb, float wn){\n\treturn atan(exp(1./r)/wb)*2.*wn;\n}\n\nfloat arm(float n, float aw, float wb, float wn,vec2 p){\n    float t = atan(p.y,p.x);\n    float r = length(p);    \n\treturn pow(1.-.15*sin((theta(r,wb,wn)-t)*n),aw)*exp(-r*r)*exp(-.07/r);\n}\n\n\nfloat bulb(vec2 p){\n    float r = exp(-dot(p,p)*1.2);\n    p.y-=.2;\n\treturn 1.*(r+2.*exp(-dot(p,p)*16.));\n}\n\n\nfloat map(in vec3 p) {\n\tvec2 q=p.xz;\n    vec3 res= vec3(0.);\n\tfloat a= arm(arms,6.,.7,winding,q);\n    float r = max(a,bulb(q));\n    return 4.*exp(-28.*(abs(p.y)-r/16.));\n}\n\n\n\nvec3 raymarch( in vec3 ro, vec3 rd)\n{\n    float t = 1.5;\n    float dt = .065;\n    vec3 col= vec3(0.);\n    float c = 0.,s=0.,d=0.;\n    for( int i=0; i<44; i++ )\n\t{\n        t+=dt*exp(-2.*c*s);\n        if(t>6.)break;\n        vec3 pos = ro+t*rd;\n        \n        c = map(pos);\n        if(c>.2){\n        s = fbmdisk(pos*32.)/3.;\n        d = fbmdust(pos*4.)/4.;\n            c*=d;}\n        //col = .98*col+ .05*vec3(c*c*c, c*c, c);\t\n        col = .98*col+ .02*vec3(c*c, 1.2*c*s,1.5* s)*c;\n        \n    }    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(2.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.05*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n      \n\n\t// raymarch\n    vec3 col = raymarch(ro,rd);\n    float g = .4*fbmgal(rd);\n    col +=.3*vec3(g*g*g, g*g*1.3, 1.5*g);\n    \n\t\n\t// shade\n    \n    col =  .5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llB3zw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 290, 309, 309, 356], [397, 397, 420, 420, 595], [597, 597, 621, 621, 854], [857, 857, 882, 882, 1030], [1033, 1033, 1057, 1057, 1240], [1244, 1244, 1269, 1269, 1435], [1438, 1438, 1479, 1479, 1515], [1517, 1517, 1573, 1573, 1705], [1708, 1708, 1727, 1727, 1814], [1817, 1817, 1839, 1839, 1988], [1992, 1992, 2029, 2029, 2510], [2513, 2513, 2570, 2570, 3356]], "test": "untested"}
{"id": "llB3zz", "name": "shadeaday ( 3 / 15 / 2015 )", "author": "cabbibo", "description": "trying to play with volume inside a plane", "tags": ["volumetric", "raytrace"], "likes": 1, "viewed": 123, "published": "Public", "date": "1426625557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 200;\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\n// q is point\n// n is normal\n// p is point on plane\nvec3 projOnPlane( vec3 q, vec3 p , vec3 n){\n    \n    vec3 v = q - dot(q - p, n) * n;\n    return v;\n}\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2, .1 );\n    return f;\n    \n}\n\n\n\n\nfloat udBox( vec3 p, vec3 b )\n{\n  return length(max(abs(p)-b,0.0));\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in vec2 mouse )\n{\n    float an = 0.3 + 10.0*mouse.x;\n\tcamPos = vec3(3.5*sin(an),1.2 *sin( time  * .4),3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n// ROTATION FUNCTIONS TAKEN FROM\n//https://www.shadertoy.com/view/XsSSzG\nmat3 xrotate(float t) {\n\treturn mat3(1.0, 0.0, 0.0,\n                0.0, cos(t), -sin(t),\n                0.0, sin(t), cos(t));\n}\n\nmat3 yrotate(float t) {\n\treturn mat3(cos(t), 0.0, -sin(t),\n                0.0, 1.0, 0.0,\n                sin(t), 0.0, cos(t));\n}\n\nmat3 zrotate(float t) {\n    return mat3(cos(t), -sin(t), 0.0,\n                sin(t), cos(t), 0.0,\n                0.0, 0.0, 1.0);\n}\n\n\nmat3 fullRotate( vec3 r ){\n \n   return xrotate( r.x ) * yrotate( r.y ) * zrotate( r.z );\n    \n}\n\nfloat rotatedBox( vec3 p , vec3 rot , vec3 size , float rad ){\n    \n    vec3 q = fullRotate( rot ) * p;\n    return udRoundBox( q , size , rad );\n    \n    \n}\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n   \n    // using super thin cube as plane\n    vec3 size = vec3( 1.  , 1. , .01 );\n   // vec3 rot = vec3( iTime * .1 , iTime * .4 , -iTime * .3 );\n    vec3 rot = vec3( 0.,0.,0. );\n   \tvec2 res = vec2( rotatedBox( pos , rot , size , .001 ) , 1.0 );\n\n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n\n#define STEPS 20\nvec3 fogCube( vec3 ro , vec3 rd , vec3 n ){\n \n    float lum = 1.;\n    \n    vec3 col = vec3( 0. );\n    for( int i = 0; i < STEPS; i++ ){\n        vec3 p = ro + rd * .04  * float( i );\n        lum +=  pow((abs(mod( p.x * 2. , .5 )-.25) + abs(mod( p.y * 2., .5 )-.25)),.3);// * ( noise * .5);\n       \tcol += 5. *  hsv( lum / 10. + sin( iTime * .1 ) , 1. , 1. ) / lum;\n    }\n    \n    return col/float(STEPS);\n    \n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n\n\n    vec3 col = vec3( 0. );\n    \n    mat3 basis = mat3(\n     \n        1. , 0. , 0. ,\n        0. , 1. , 0. ,\n        0. , 0. , 1.\n       \n    );\n        \n   \n    \n    if( res.y > -.5 ){\n        \n        vec3 pos = ro + rd * res.x;\n        vec3 norm = calcNormal( pos );\n        \n        vec3 depthColor = fogCube( pos , rd , norm  );\n \n        col += depthColor;//lum  * vec3( 1. , .6 , 0.2);\n        \n        \n    }\n\n    fragColor = vec4( col , 1. );\n\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llB3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[189, 333, 370, 370, 502], [505, 557, 600, 600, 657], [659, 711, 733, 733, 758], [759, 759, 780, 780, 860], [896, 948, 991, 991, 1294], [1296, 1296, 1323, 1323, 1386], [1391, 1391, 1422, 1422, 1460], [1463, 1463, 1508, 1508, 1548], [1551, 1582, 1646, 1646, 1824], [1826, 1826, 1907, 1907, 2039], [2041, 2114, 2137, 2137, 2243], [2245, 2245, 2268, 2268, 2374], [2376, 2376, 2399, 2399, 2508], [2511, 2511, 2537, 2537, 2606], [2608, 2608, 2670, 2670, 2764], [2768, 2862, 2891, 2891, 2934], [2936, 3020, 3041, 3085, 3314], [3318, 3318, 3366, 3366, 3833], [3853, 3853, 3896, 3896, 4268], [4270, 4383, 4414, 4414, 4640], [4644, 4644, 4701, 4701, 5723]], "test": "untested"}
{"id": "llBGRh", "name": "[NV15] Lost In the Field", "author": "RK", "description": "Some piecewise distance field testing.\nThe goal is to create a random field of asteroids without experiencing too many glitches due to the nature of the distance function (rays could leak past a surface under some conditions).", "tags": ["raymarcher", "randomfield", "piecewisedistancefield"], "likes": 27, "viewed": 5859, "published": "Public", "date": "1426796217", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*TEXTURE_FORMAT:OutputFormat(1280, 720, GL_RGB, GL_UNSIGNED_BYTE, GL_NEAREST, GL_NEAREST)\n\nCALL:FORMAT_TO_CONSTANT(OutputFormat, OutputFormatSize)\n\nSHADER_SOURCE:HackathonShader\n{*/\n\t//#version 130\n\t//#define SINGLE_UNIT\t// Single unit, for tests purpose.\n\t//#define MULTI_SIMPLE\t// Showing the repitition bug, comment to see the solved version.\n\t#define FAST_METHOD\t\t// If this is commented, the method used is exact. Uncomment for speed.\n\t//#define NO_EFFECTS\t// Remove the image effects.\n\t#define INFINITE\t\t// Infinite animation.\n\n\t//INSERT(OutputFormatSize)\n\n\t/*uniform vec3\teyePos\t\t= vec3(0, 0, 4),\n\t\t\t\t\teyeTarget\t= vec3(0, 0, 0),\n\t\t\t\t\tlightDir\t= vec3(1, 0, 0);\n\tuniform\tfloat\tfocalLength\t= 0.5,\n\t\t\t\t\tlightFlux\t= 1.0;*/\n\tvec3\t\teyePos\t\t= vec3(4.0, 3.0, 4.0),\n        \t\teyeTarget\t= vec3(0.0, 0.0, 0.0);\n\tconst vec3\tlightDir\t= vec3(1.0, 0.0, 0.2);\n\tconst float\tfocalLength\t= 0.5,\n\t\t\t\tlightFlux\t= 4.0,\n                volumeSide \t= 10.0,\n        \t\tduration\t= 30.0;\n\n\tfloat blockHash(vec3 p)\n\t{\n\t\t//return sin(123.0*p.x)*sin(456.0*p.y)*sin(789.0*p.z)*241432439.0;\n        return sin(123.0*p.x)*sin(456.0*p.y)*sin(789.0*p.z)*2769.32;\n\t}\n\n\tfloat smin(float a, float b)\n\t{\n\t\tconst float k = 0.1;\n\t\tfloat h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n\t\treturn mix(b, a, h) - k*h*(1.0-h);\n\t}\n\n\tfloat absSq(float x)\n    {\n        return x*x;\n    }\n\n\tfloat getUnitDistance(float idx, vec3 p)\n\t{\n\t\tvec3 \tbumps1 \t\t= sin(idx*vec3(2.542, 1.564, 3.342))+1.0,\n\t\t\t\tbumps2\t\t= sin(idx*vec3(-1.432, 8.788, 9.453))+1.0,\n\t\t\t\ttranslation\t= sin(idx*vec3(0.345, 8.342, 3.324))/1.5;\n        bumps1 = max(abs(bumps1), vec3(1.0))*sign(bumps1); // avoid 0.0, avoid the spheres...\n        bumps2 = max(abs(bumps2), vec3(1.0))*sign(bumps2);\n\t\t\n\t\tp += sin(idx*vec3(0.234, 0.736, 0.213))*3.0;\n        \n\t\tfloat\ts1 \t= length(p) + sin(bumps1.x*p.x)*sin(bumps1.y*p.y)*sin(bumps1.z*p.z)/1.5 + sin(bumps1.x*p.x*4.0)*sin(bumps1.y*p.y*4.0)*sin(bumps1.z*p.z*4.0)/16.0 - 1.0,\n\t\t\t\ts2\t= distance(p, translation) + sin(bumps2.x*p.x)*sin(bumps2.y*p.y)*sin(bumps2.z*p.z)/1.5  + sin(bumps2.x*p.x*4.0)*sin(bumps2.y*p.y*4.0)*sin(bumps2.z*p.z*4.0)/16.0 - 1.0;\n\t\treturn  smin(s1, s2);\n    }\n\n\t/*float getUnitDistance(vec3 block, vec3 p)\n\t{\n\t\tvec3 \tbumps1 \t\t= fract(block*vec3(0.2342, 0.4564, 0.3342))*2.0,\n\t\t\t\tbumps2\t\t= fract(block*vec3(-0.7432, 0.8788, 0.9453))*2.0,\n\t\t\t\ttranslation\t= (fract(block*vec3(0.3450, 0.8342, -0.8324))*2.0-1.0)/1.5;\n        bumps1 = max(abs(bumps1), vec3(1.0))*sign(bumps1);\n        bumps2 = max(abs(bumps2), vec3(1.0))*sign(bumps2);\n\t\n\t\tp = p + (fract(block*vec3(0.2334, 0.5365, 0.4353))*2.0-1.0)*4.0;\n\n\t\tfloat\ts1 \t= length(p) + sin(bumps1.x*p.x)*sin(bumps1.y*p.y)*sin(bumps1.z*p.z)/1.5 + sin(bumps1.x*p.x*4.0)*sin(bumps1.y*p.y*4.0)*sin(bumps1.z*p.z*4.0)/16.0 - 1.0,\n\t\t\t\ts2\t= distance(p, translation) + sin(bumps2.x*p.x)*sin(bumps2.y*p.y)*sin(bumps2.z*p.z)/1.5  + sin(bumps2.x*p.x*4.0)*sin(bumps2.y*p.y*4.0)*sin(bumps2.z*p.z*4.0)/16.0 - 1.0;\n        \n\t\treturn  smin(s1, s2);\n    }*/\n\n\tfloat getUnitDistanceSimple(vec3 p)\n    {\n        return length(p)-4.8; // The coefficient is a bit ad-hoc here. The goal is to quickly catch a \"leaking ray\".\n    }\n\n\tvec2 sceneMap(vec3 p, vec3 dir)\n\t{\n\t\t#ifdef SINGLE_UNIT\n        \tconst float bidx = 43578.4534;\n\t\t\treturn vec2(getUnitDistance(bidx, p), 1.0+abs(bidx));\n\t\t#else \n        #ifdef MULTI_SIMPLE\n        \tvec3\tm0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0;\n        \tvec3\tv = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0;\n\t\t\tfloat\tbidx0 = blockHash(v);\n       \t\t\n        \treturn vec2(getUnitDistance(bidx0, m0), 1.0+abs(bidx0));\n        \n        \t/*vec3\tm0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0;\n        \tvec3\tblock = floor(p/volumeSide) + vec3(24.32, 32.4324, 63.6548);\n        \treturn vec2(getUnitDistance(block, m0), 1.0);*/\n        #else\n        #ifdef FAST_METHOD\n        \tvec3\tm0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0,\n                \tm1 = m0 - sign(vec3(dir.x, 0.0, 0.0)) * volumeSide,\n\t\t\t\t\tm2 = m0 - sign(vec3(0.0, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm3 = m0 - sign(vec3(0.0, 0.0, dir.z)) * volumeSide,\n\t\t\t\t\tm4 = m0 - sign(vec3(dir.x, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm5 = m0 - sign(vec3(0.0, dir.y, dir.z)) * volumeSide,\n\t\t\t\t\tm6 = m0 - sign(vec3(dir.x, 0.0, dir.z)) * volumeSide,\t\t\t\n\t\t\t\t\tm7 = m0 - sign(vec3(dir.x, dir.y, dir.z)) * volumeSide;\t\n        \tvec3\tv = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0;\n            float\tbidx0 = blockHash(v);\n        \tfloat \td = min(getUnitDistance(bidx0, m0),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m1),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m2),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m3),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m4),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m5),\n\t\t\t\t\t\tmin(getUnitDistanceSimple(m6),\n\t\t\t\t\t\t\tgetUnitDistanceSimple(m7) )))))));\n        \treturn vec2(d, 1.0+abs(bidx0));\n        #else\n\t\t\tvec3\tm0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0,\n\t\t\t\t\tm1 = m0 - sign(vec3(dir.x, 0.0, 0.0)) * volumeSide,\n\t\t\t\t\tm2 = m0 - sign(vec3(0.0, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm3 = m0 - sign(vec3(0.0, 0.0, dir.z)) * volumeSide,\n\t\t\t\t\tm4 = m0 - sign(vec3(dir.x, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm5 = m0 - sign(vec3(0.0, dir.y, dir.z)) * volumeSide,\n\t\t\t\t\tm6 = m0 - sign(vec3(dir.x, 0.0, dir.z)) * volumeSide,\t\t\t\n\t\t\t\t\tm7 = m0 - sign(vec3(dir.x, dir.y, dir.z)) * volumeSide;\t\n\t\t\tvec3\tv = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0;\n\t\t\tfloat\tbidx0 = blockHash(v),\n\t\t\t\t\tbidx1 = blockHash(v + vec3(sign(dir.x), 0.0, 0.0)),\n\t\t\t\t\tbidx2 = blockHash(v + vec3(0.0, sign(dir.y), 0.0)),\n\t\t\t\t\tbidx3 = blockHash(v + vec3(0.0, 0.0, sign(dir.z))),\n\t\t\t\t\tbidx4 = blockHash(v + vec3(sign(dir.x), sign(dir.y), 0.0)),\n\t\t\t\t\tbidx5 = blockHash(v + vec3(0.0, sign(dir.y), sign(dir.z))),\n\t\t\t\t\tbidx6 = blockHash(v + vec3(sign(dir.x), 0.0, sign(dir.z))),\t\t\t\n\t\t\t\t\tbidx7 = blockHash(v + vec3(sign(dir.x), sign(dir.y), sign(dir.z)));\t\t\n\t\t\tfloat \td = min(getUnitDistance(bidx0, m0),\n\t\t\t\t\t\tmin(getUnitDistance(bidx1, m1),\n\t\t\t\t\t\tmin(getUnitDistance(bidx2, m2),\n\t\t\t\t\t\tmin(getUnitDistance(bidx3, m3),\n\t\t\t\t\t\tmin(getUnitDistance(bidx4, m4),\n\t\t\t\t\t\tmin(getUnitDistance(bidx5, m5),\n\t\t\t\t\t\tmin(getUnitDistance(bidx6, m6),\n\t\t\t\t\t\t\tgetUnitDistance(bidx7, m7) )))))));\n        \t/*vec3\tm0 = mod(p+volumeSide/2.0, volumeSide)-volumeSide/2.0,\n\t\t\t\t\tm1 = m0 - sign(vec3(dir.x, 0.0, 0.0)) * volumeSide,\n\t\t\t\t\tm2 = m0 - sign(vec3(0.0, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm3 = m0 - sign(vec3(0.0, 0.0, dir.z)) * volumeSide,\n\t\t\t\t\tm4 = m0 - sign(vec3(dir.x, dir.y, 0.0)) * volumeSide,\n\t\t\t\t\tm5 = m0 - sign(vec3(0.0, dir.y, dir.z)) * volumeSide,\n\t\t\t\t\tm6 = m0 - sign(vec3(dir.x, 0.0, dir.z)) * volumeSide,\t\t\t\n\t\t\t\t\tm7 = m0 - sign(vec3(dir.x, dir.y, dir.z)) * volumeSide;\t\n\t\t\tvec3\tv = floor((p+volumeSide/2.0)/volumeSide)-volumeSide/2.0,\n        \t\t\tblock1 = v + vec3(sign(dir.x), 0.0, 0.0),\n\t\t\t\t\tblock2 = v + vec3(0.0, sign(dir.y), 0.0),\n\t\t\t\t\tblock3 = v + vec3(0.0, 0.0, sign(dir.z)),\n\t\t\t\t\tblock4 = v + vec3(sign(dir.x), sign(dir.y), 0.0),\n\t\t\t\t\tblock5 = v + vec3(0.0, sign(dir.y), sign(dir.z)),\n\t\t\t\t\tblock6 = v + vec3(sign(dir.x), 0.0, sign(dir.z)),\t\t\t\n\t\t\t\t\tblock7 = v + vec3(sign(dir.x), sign(dir.y), sign(dir.z));\n        \tfloat \td = min(getUnitDistance(v, m0),\n\t\t\t\t\t\tmin(getUnitDistance(block1, m1),\n\t\t\t\t\t\tmin(getUnitDistance(block2, m2),\n\t\t\t\t\t\tmin(getUnitDistance(block3, m3),\n\t\t\t\t\t\tmin(getUnitDistance(block4, m4),\n\t\t\t\t\t\tmin(getUnitDistance(block5, m5),\n\t\t\t\t\t\tmin(getUnitDistance(block6, m6),\n\t\t\t\t\t\t\tgetUnitDistance(block7, m7) )))))));*/\n\t\t\treturn vec2(d, 1.0+abs(bidx0));\n        #endif\n\t\t#endif\n        #endif\n\t}\n\n\tvec4 renderMaterial(vec2 fragCoord, vec3 p, vec3 n, float m)\n\t{\n        float d = distance(eyePos, p);\n\t\tvec4 c = vec4(0.0, 0.0, 0.0, 1.0);\n\n\t\tif(m>=1.0)\n\t\t\tc.rgb = vec3(1.0, 1.0, 1.0) * (0.03 + max(dot(normalize(lightDir), n), 0.0) * max(dot(normalize(eyePos-p), n), 0.0) * lightFlux);\n        \n        #ifndef NO_EFFECTS\n        if(floor(mod(m,10.0))==0.0 && d<50.0)\n\t\t\tc.rg += vec2(1.0, 0.25)*max(0.9 + sin(fragCoord.y/iResolution.y*100.0-iTime*10.0)/2.0, 0.0);\n        #endif\n            \n        const float cFloor = 0.01,\n            \t\ttau = 20.0;\n        \n        c.rgb = c.rgb*exp(-d/tau)*(1.0-cFloor)+cFloor*(1.0-exp(-d/tau));\n        \n\t\treturn c;\n\t}\n\n\t// Core of the Ray-marcher :\n\tmat3 computeCameraMatrix(in vec3 p, in vec3 target, float roll)\n\t{\n\t\tvec3 \tvForward = normalize(target-p),\n\t\t\t\tvUpAlign = vec3(sin(roll), cos(roll), 0.0),\n\t\t\t\tvLeftReal = normalize(cross(vForward, vUpAlign)),\n\t\t\t\tvUpReal = normalize(cross(vLeftReal, vForward));\n\t   \treturn mat3(vLeftReal, vUpReal, vForward);\n\t}\n\n\tvec3 castRay(in vec3 rayOrigin, in vec3 rayDirection)\n\t{\n\t\tconst int \tnumSteps = 128;\n\t\tconst float\tdMin = 0.0,\n\t\t\t\t\tdNear = 0.000001,\n\t\t\t\t\tdMax = 100.0;\n\t\tfloat\t\td = dMin,\n\t\t\t\t\tdLast = dMin,\n\t\t\tm = -1.0;\n\t\tfor(int i=0; i<numSteps; i++)\n\t\t{\n\t\t\tvec3 p = rayOrigin+rayDirection*d;\n\t\t\tvec2 res = sceneMap(p, rayDirection);\n\n\t\t\tdLast = res.x;\n\t\t\td += res.x;\n\t\t\tm = res.y;\n\n\t\t\tif(res.x<dNear || d>dMax)\n\t\t\t\tbreak;\n\t\t}\n\t\tif(d>dMax)\n\t\t\tm = -1.0;\n\n\t\treturn vec3(d, m, dLast);\n\t}\n\n\tvec3 calcNormal(in vec3 pos, in vec3 dir)\n\t{\n\t\tconst vec3 eps = vec3(0.001, 0.0, 0.0);\n\t\tvec3 n = vec3(\tsceneMap(pos+eps.xyy, dir).x - sceneMap(pos-eps.xyy, dir).x,\n\t\t\t\t\t\tsceneMap(pos+eps.yxy, dir).x - sceneMap(pos-eps.yxy, dir).x,\n\t\t\t\t\t\tsceneMap(pos+eps.yyx, dir).x - sceneMap(pos-eps.yyx, dir).x );\n\t\treturn normalize(n);\n\t}\n\n\tvec4 renderScene(vec2 fragCoord, const ivec2 formatSize, const vec3 eyePos, const vec3 eyeTarget, const float focalLength)\n\t{\n\t\tmat3 camera = computeCameraMatrix(eyePos, eyeTarget, 0.0);\n\t\tvec2 o = (fragCoord - vec2(formatSize)/2.0)/max(float(formatSize.x),float(formatSize.y));\n\t\tvec3 rayOrigin = vec3(o, 0.0) + eyePos,\n\t\t     rayDirection = normalize(camera*vec3(o, focalLength));\n\t\tvec3 res = castRay(rayOrigin, rayDirection);\n\t\tvec3 p = rayOrigin + rayDirection * res.x;\n\t\tvec3 n = calcNormal(p, rayDirection);\n\t\treturn renderMaterial(fragCoord, p, n, res.y);\n\t}\n\n\tvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n\t{\n        eyePos = eyePos + vec3(sin(iTime/10.0)/2.0, sin(iTime/10.0)/2.0, iTime*1.4);\n        eyeTarget = eyePos + vec3(sin(iTime/2.0)/10.0, 0.0, 1);\n        \n        #ifndef NO_EFFECTS\n        \tvec2 fragCoordMod = fragCoord + sin(iTime/2.0+fragCoord.y/5.0)*100.0*exp(-absSq(fragCoord.y/iResolution.y-sin(iTime)-0.5)*800.0);\n        #else\n        \tvec2 fragCoordMod = fragCoord;\n        #endif\n        \n\t\t// Render the scene :\n        vec4 c = renderScene(fragCoordMod, ivec2(iResolution.xy), eyePos, eyeTarget, focalLength);\n        \n        // Effects :\n        #ifndef NO_EFFECTS\n        \tc.rgb *= max(cos(3.14*length(fragCoord.xy/iResolution.xy - vec2(0.5,0.5))*0.85), 0.0);\n    \t\tc.rgb *= (iTime<=0.0) ? 1.0 : (1.0-exp(-iTime/4.0));\n        \tc.rgb *= (floor(mod(fragCoord.y,4.0))<=1.0) ? 1.5 : 1.0;\n        \n        \t#ifndef INFINITE\n        \tif(iTime>duration)\n            {\n                float \ty = abs(fragCoord.y/iResolution.y - 0.5),\n               \t\t\tylim = exp(-(iTime-duration)*10.0);\n           \t\tc.rgb *= float(y<ylim) + 100.0*exp(-absSq(y-ylim)*(10000.0*iTime));\n                c.rgb *= float(iTime<duration + 0.5);\n            }\n        \t#endif\n    \t\n       \t \t// hud 1 :\n       \t\tvec2 v = fragCoord/max(iResolution.x,iResolution.y);\n        \tc.r += 0.4*smoothstep(0.012, 0.010, distance(v,vec2(0.95, 0.53)))*float(mod(iTime,2.0)<=1.0);\n        \n        \t// hud 2 :\n        \t/*float p1 = max(abs(v.x-0.5), abs(v.y-0.05)*3.0);\n        \tc.r += 0.4*float(p1<0.05 && p1>0.04)*float(mod(iTime,0.5)<=0.25);\n        \tfloat p2 = max(abs(v.x-0.555)*3.0, abs(v.y-0.05));\n        \tc.r += 0.4*float(p2<0.01)*float(mod(iTime,0.5)<=0.25);*/\n    \t#endif\n        \n        fragColor = vec4(pow(c.rgb, vec3(1.0, 1.0, 1.0)/2.2), 1.0);\n    }\n/*}\n\nFILTER_LAYOUT:HackathonFilter(OutputFormat, HackathonShader)\n\nPIPELINE_MAIN:HackathonPipeline\n{\n\tOUTPUT_PORTS(outputTexture)\n\n\tFILTER_INSTANCE:HackathonFilter\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[565, 969, 995, 1064, 1136], [1139, 1139, 1170, 1170, 1279], [1282, 1282, 1308, 1308, 1334], [1337, 1337, 1380, 1380, 2133], [2136, 2957, 2998, 2998, 3121], [3124, 3124, 3158, 3158, 7454], [7457, 7457, 7520, 7520, 8116], [8119, 8149, 8215, 8215, 8461], [8464, 8464, 8520, 8520, 8934], [8937, 8937, 8981, 8981, 9263], [9266, 9266, 9391, 9391, 9832], [9835, 9835, 9891, 9891, 11632]], "test": "untested"}
{"id": "llBGz1", "name": "Gamma correctness: shadow", "author": "Zavie", "description": "Illustrating the effect of gamma space in shading. Without gamma correction on the left ; with gamma correction on the right (hint: the right is the one you want). Notice the shadow falloff and the rim reflection.\n\nClick and drag to control.", "tags": ["raytracing", "shadow", "sphere", "gamma", "gammacorrection", "linear"], "likes": 51, "viewed": 2651, "published": "Public API", "date": "1426874588", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nThis shader demonstrates the effect of gamma\ncorrection in rendering.\n\nInspired by:\nhttp://beautifulpixels.blogspot.co.uk/2009/10/gamma-correct-lighting-on-moon.html\n\nMove the mouse to see the difference between\nshading with no gamma correction (on the left)\nand with gamma correction (on the right).\n\nSee also: https://www.shadertoy.com/view/lsVGzK\n\n--\nZavie\n\n*/\n\n#define MAX_BOUNCES 2\nfloat gamma = 2.2;\n\n// ---8<----------------------------------------------------------------------\n// Material\n\nstruct Material\n{\n    vec3 c;\t\t// diffuse color\n    float f0;\t// specular color (monochrome)\n};\n\n// ---8<----------------------------------------------------------------------\n// Geometry\n\nstruct Ray\n{\n    vec3 o;\t\t// origin\n    vec3 d;\t\t// direction\n};\n\nstruct Hit\n{\n    float t;\t// solution to p=o+t*d\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\nconst Hit noHit = Hit(1e10, vec3(0.), Material(vec3(-1.), -1.));\n\nstruct Plane\n{\n    float d;\t// solution to dot(n,p)+d=0\n    vec3 n;\t\t// normal\n    Material m;\t// material\n};\n\nstruct Sphere\n{\n\tfloat r;\t// radius\n    vec3 p;\t\t// center position\n    Material m;\t// material\n};\n\nHit intersectPlane(Plane p, Ray r)\n{\n    float dotnd = dot(p.n, r.d);\n    if (dotnd > 0.) return noHit;\n\n    float t = -(dot(r.o, p.n) + p.d) / dotnd;\n    return Hit(t, p.n, p.m);\n}\n\nHit intersectSphere(Sphere s, Ray r)\n{\n\tvec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n\n    return Hit(t, (r.o + t*r.d - s.p) / s.r, s.m);\n}\n\nbool compare(inout Hit a, Hit b)\n{\n    if (b.m.f0 >= 0. && b.t < a.t)\n    {\n        a = b;\n        return true;\n    }\n    return false;\n}\n\nHit intersectScene(Ray r)\n{\n    Sphere s = Sphere(1., vec3(0., 1., 0.), Material(vec3(1.0), 0.04));\n    Plane p  = Plane(0., vec3(0., 1., 0.), Material(vec3(1.0), 0.04));\n\n    Hit hit = noHit;\n    compare(hit, intersectPlane(p, r));\n    compare(hit, intersectSphere(s, r));\n    return hit;\n}\n\n// ---8<----------------------------------------------------------------------\n// Lights\n\nstruct DirectionalLight\n{\n    vec3 d;\t\t// Direction\n    vec3 c;\t\t// Color\n};\n\nDirectionalLight sunLight = DirectionalLight(normalize(vec3(-2., 1., 1.)), vec3(1.));\n\nvec3 skyColor(vec3 d)\n{\n    return vec3(0.01);\n}\n\nfloat pow5(float x) { return x * x * x * x * x; }\n\n// Schlick approximation\nfloat fresnel(vec3 h, vec3 v, float f0)\n{\n  return pow5(1. - clamp(dot(h, v), 0., 1.)) * (1. - f0) + f0;\n}\n\nfloat epsilon = 4e-4;\n\nvec3 accountForDirectionalLight(vec3 p, vec3 n, DirectionalLight l)\n{\n    if (intersectScene(Ray(p + epsilon * l.d, l.d)).m.f0 < 0.)\n    {\n        return clamp(dot(n, l.d), 0., 1.) * l.c;\n    }\n    return vec3(0.);\n}\n\nvec3 radiance(Ray r)\n{\n    vec3 accum = vec3(0.);\n    vec3 attenuation = vec3(1.);\n\n    for (int i = 0; i <= MAX_BOUNCES; ++i)\n    {\n        Hit hit = intersectScene(r);\n\n        if (hit.m.f0 >= 0.)\n        {\n            float f = fresnel(hit.n, -r.d, hit.m.f0);\n\n            vec3 hitPos = r.o + hit.t * r.d;\n\n            // Diffuse\n            vec3 incoming = vec3(0.);\n            incoming += accountForDirectionalLight(hitPos, hit.n, sunLight);\n\n            accum += (1. - f) * attenuation * hit.m.c * incoming;\n\n            // Specular: next bounce\n            attenuation *= f;\n            vec3 d = reflect(r.d, hit.n);\n            r = Ray(r.o + hit.t * r.d + epsilon * d, d);\n        }\n        else\n        {\n            accum += attenuation * skyColor(r.d);\n            break;\n        }\n    }\n    return accum;\n}\n\n// ---8<----------------------------------------------------------------------\n// Scene\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n\n    vec3 color = vec3(0.);\n    for (int i = 0; i < 4; ++i)\n    {\n        vec3 p0 = vec3(0., 1.1, 4.);\n        vec3 p = p0;\n        //vec3 p = vec3(0., (2. * (iMouse.y==0.?.5*iResolution.y:iMouse.y) / iResolution.y - 1.), 0.) + p0;\n        vec3 offset = vec3(msaa[i] / iResolution.y, 0.);\n        vec3 d = normalize(vec3(iResolution.x/iResolution.y * uv.x, uv.y, -1.5) + offset);\n        Ray r = Ray(p, d);\n        color += radiance(r) / 4.;\n    }\n\n    float compareLimit = (iMouse.z > 0. ? iMouse.x : abs(fract(0.1*iTime) * 2. - 1.) * iResolution.x);\n\tif (compareLimit < fragCoord.x)\n        fragColor = vec4(pow(color, vec3(1./gamma)),1.0);\n    else\n        fragColor = vec4(color*1.2,1.0); // Fudge x1.2 factor to compensate for darkened result.\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBGz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[600, 1138, 1174, 1174, 1319], [1321, 1321, 1359, 1359, 1648], [1650, 1650, 1684, 1684, 1787], [1789, 1789, 1816, 1816, 2080], [2082, 2337, 2360, 2360, 2385], [2387, 2387, 2408, 2408, 2436], [2438, 2463, 2504, 2504, 2569], [2594, 2594, 2663, 2663, 2810], [2812, 2812, 2834, 2834, 3631], [3633, 3722, 3779, 3779, 4763]], "test": "untested"}
{"id": "llBGzm", "name": "Under the Bridge", "author": "jameswilddev", "description": "In a lost dark city...", "tags": ["bridge", "falsevolumetrics"], "likes": 40, "viewed": 938, "published": "Public", "date": "1427657416", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cross-platform workarounds.\n// ------------------------------------------------------------------------------------\n\n#define SHADERTOY\n//#define GLSLSANDBOX\n\n// ShaderToy defines this itself, but not all sandboxes do.\n#ifndef SHADERTOY\n\t#ifdef GL_ES\n\tprecision mediump float;\n\t#endif\n#endif\n\n// Almost all GLSL sandboxes include a resolution uniform, but they're all named differently\n// and have different things in the axes.  This should always return the width/height of the\n// display in pixels as a vec2.\n#ifdef SHADERTOY \n\t#define RESOLUTION iResolution.xy \n#endif\n#ifdef GLSLSANDBOX\n\tuniform vec2 resolution;\n\t#define RESOLUTION resolution\n#endif\n\n// Almost all GLSL sandboxes include a time uniform, but they're all named differently.\n// This should always return the time since the start of the animation, in seconds.\n#ifdef SHADERTOY \n\t#define TIME iTime\n#endif\n#ifdef GLSLSANDBOX\n\tuniform float time;\n\t#define TIME time\n#endif\n\n// Some GLSL sandboxes don't allow direct access to gl_FragCoord, so it can be aliased here.\n#ifdef SHADERTOY\n\t#define FRAGCOORD fragCoord\n#else\n\t#define FRAGCOORD gl_FragCoord.xy\n#endif\n\n// Some GLSL sandboxes don't allow direct access to gl_FragColor, so it can be aliased here.\n#ifdef SHADERTOY\n\t#define FRAGCOLOR fragColor\n#else\n\t#define FRAGCOLOR gl_FragColor\n#endif\n\n// Misc. tools.\n// ------------------------------------------------------------------------------------\n\n// IE11 has problems with 1.0/0.0.\n#define INFINITY 10000.0\n\n// Returns the location of the current fragment relative to the center of the screen, where 0.5 is the distance to the nearest screen border.\n// This will return values > +-0.5 on the X axis in widescreen, and the Y axis in portrait.\n#define PixelCoord ((FRAGCOORD - (RESOLUTION / 2.0)) / min(RESOLUTION.x, RESOLUTION.y))\n\n// Lenses.\n// ------------------------------------------------------------------------------------\n// Lenses generate a ray for the current pixel, storing where it starts in \"rayStart\",\n// and a normal along which it points in \"rayNormal\".\n\n// A very simplistic, not in any way accurate or \"true\" lens.  FieldOfView can be any positive value.\n#define SimpleLens(fieldOfView) { rayStart = vec3(0.0); vec2 coord = PixelCoord; rayNormal = normalize(vec3(coord.x / fieldOfView, 1.0, coord.y / fieldOfView)); }\n\n// Surfaces.\n// ------------------------------------------------------------------------------------\n// These are raytraceable surfaces, reading from rayStart and rayNormal to find the\n// distance along that ray to the surface.  (calling ApplySurface to store it in \"nearest\") \n//\n// They are not themselves rendered.\n//\n// When rendering lights, this position is used instead of the closest point on the ray\n// to the light origin if it is closer to the start of the ray.\n// Write to \"nearest\" if you are closer than the value already there.\n\n// Given the distance to a surface, first checks it is not behind the camera, then that it is\n// closer than what is already stored in \"nearest\" and overwrites it if so.\n#define ApplySurface(dist, pattern) { float _dist = dist; vec3 intersection = rayStart + rayNormal * _dist; if(_dist > 0.0 && _dist < nearest && pattern) nearest = _dist; }\n\n// Given a lowercase axis (x/y/z) and a (float) location on that axis, draws an infinitely \n// large plane there.\n#define AxisSurface(axis, location, pattern) ApplySurface((location - rayStart.axis) / rayNormal.axis, pattern)\n\n// Given a (vec3) location and a (float) radius, draws a sphere at that location of that size.\n#define SphereSurface(location, radius, pattern) { vec3 _location = location; float along = dot(_location - rayStart, rayNormal); float dist = distance(_location, rayStart + rayNormal * along); float _radius = radius; if(dist < _radius) { ApplySurface(along - (_radius * sin(acos(dist / _radius))), pattern) } }\n\nvec3 ClosestTimeOfApproach(vec3 pos1, vec3 vel1, vec3 pos2, vec3 vel2)\n{\n    // There's probably much better ways to calculate this, but I'm not very good at maths, so here's my approach:\n    // A slice of the target line is a point, so if we project the start/end as though we're looking right down the ray,\n    // we can clearly see where the closest point is.2\n    vec3 projStart = pos2 - (vel1 * dot(pos2 - pos1, vel1));\n    vec3 projEnd = vel2 - (vel1 * dot(vel2 - pos1, vel1));\n    vec3 projNorm = normalize(projEnd - projStart);\n  \n    float along = dot(pos1 - projStart, projNorm);\n    vec3 closest = mix(pos2, vel2, clamp(along / distance(projStart, projEnd), 0.0, 1.0));\n    return closest;\n}\n\n// Given the (vec3) location of the start and end of a capsule and a (float) radius, draws a capsule\n// between those locations of that size.  Essentially a cylinder between those locations capped with\n// a sphere; protrudes beyond start/end by radius.\n#define CapsuleSurface(start, end, radius, pattern) { SphereSurface( ClosestTimeOfApproach(rayStart, rayNormal, start, end), radius, pattern ) }\n\n// Patterns.\n// ------------------------------------------------------------------------------------\n// These are functions which define where on a surface is solid, and where is not.\n// They typically take the intersected point (intersection) and return true to make the surface solid.\n\n// Always solid.\n#define SolidPattern true\n\n// Never solid.\n#define NonSolidPattern false\n\n// Given a lowercase axis (x/y/z), a (float) location on that axis and two patterns, one pattern is shown \n// on one side of a plane on that axis at that location, and on the other side, the other pattern.\n#define AxisPattern(axis, location, negativePattern, positivePattern) (intersection.axis > location ? positivePattern : negativePattern)\n\n// Given a spacing between each circle, a radius for each circle and two patterns, one pattern is shown\n// inside a repeating grid of circles while the other is shown outside the circles.\n#define CirclePattern(spacing, radius, insidePattern, outsidePattern)\n\n// Given a (float) spacing between each stripe, a (float) width for the stripes and two patterns, \n// diagonal stripes are drawn with one pattern used on the stripes and the other used off the stripes.\n#define StripePattern(spacing, width, onPattern, offPattern)\n\n// Lights.\n// ------------------------------------------------------------------------------------\n// False volumetric lights computed by taking the closest point to the origin along the ray\n// and then computing the distance/etc. to the origin.  This gives a nice misty looking light.\n// \n// Each light is built in the following steps:\n// - An Origin function.  This determines the distance along the ray to the nearest point to the \n//   light (stored in \"origin\"), storing it in \"originAlong\".  These call common code to reset \n//   \"intensity\" to 1.0 and compute \"originNearest\", the closest point on the ray to the light origin.\n// - One or more Falloff functions.  These use the origin data to determine a coefficient (rolloff\n//   over distance, etc.) and multiply \"intensity\" by it.\n// - A call to Shade to color the light and store it in an accumulator.\n\n// Applies the current light, multiplying it by a color and saving it to the display.\n#define Shade(color) { accumulator += intensity * color; }\n\n// Resets the intensity of the light so its origin can be reused.\n#define ResetFalloff { intensity = 1.0; }\n\n// Called by every origin to setup common data.\n#define SetupOrigin { intensity = 1.0; if(originAlong < 0.0 || originAlong > nearest) { originAlong = nearest; } originNearest = rayStart + rayNormal * originAlong; }\n\n// Origins.\n// ---------------------------------\n\n// Given a location, creates a radial light from that location.\n#define RadialOrigin(location) { origin = location; originAlong = dot(origin - rayStart, rayNormal); SetupOrigin }\n\n// Given a lowercase axis (x/y/z) and a (float) location on that axis, creates a light emitted from\n// an infinite plane there.\n#define AxisOrigin(axis, location)\n\n// Falloffs.\n// ---------------------------------\n\n// The light gets darker the further we are from the origin.  Larger rates fall off quicker.\n// Linearity is the power of the falloff; 1.0 is linear, 2.0 is inverse square, 3.0 is inverse cube, etc.\n#define DistanceFalloff(rate, linearity) { intensity /= pow(1.0 + distance(origin, originNearest) * rate, linearity); }\n\n// The light gets darker the further off a (vec3) normal we are from the origin.\n// Linearity is the power of the falloff; 1.0 is linear, 2.0 is inverse square, 3.0 is inverse cube, etc.\n// Note that because we sample the closest point to the origin of the light, on point lights\n// pointing at or away from the camera the spot is infinitely small so the light disappears.\n#define DirectionalFalloff(normal, linearity) { intensity *= pow(max(0.0, dot(normal, normalize(originNearest - origin))), linearity); }\n\nvec3 rotateX(vec3 transform, float angle) {\n    mat3 mat = mat3(1.0, 0.0, 0.0, 0.0, cos(angle), -sin(angle), 0.0, sin(angle), cos(angle));\n    return transform * mat;\n}\n\nvec3 rotateY(vec3 transform, float angle) {\n    mat3 mat = mat3(cos(angle), 0.0, -sin(angle), 0.0, 1.0, 0.0, sin(angle), 0.0, cos(angle));\n    return transform * mat;\n}\n\nvec3 rotateZ(vec3 transform, float angle) {\n    mat3 mat = mat3(cos(angle), -sin(angle), 0.0, sin(angle), cos(angle), 0.0, 0.0, 0.0, 1.0);\n    return transform * mat;\n}\n\n\n// Post-processes.\n// ------------------------------------------------------------------------------------\n// These modify the color stored in \"accumulator\".\n\n// This where main() should be.\n// However, some GLSL sandboxes don't allow you to define main() yourself.\n#ifdef SHADERTOY\n\tvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n#else\n    void main()\n#endif\n{\n    vec3 rayStart, rayNormal;\n    \n    float nearest = INFINITY;\n    \n    vec3 origin, originNearest;\n    float originAlong;\n    \n    vec3 accumulator = vec3(0.0);\n    float intensity;    \n    \n    // Start of generated code.\n    SimpleLens(1.0)\n        \n    \n     rayStart.x += 5.9;\n    rayStart.y -= 14.4;\n        rayStart.z += 1.6;\n    \n    rayNormal = rotateZ(rotateX(rayNormal, sin(TIME * 0.4) * 0.1), 0.5 + sin(TIME * 0.5) * 0.1);\n    \n    // Render surfaces.\n    \n    // Road\n    AxisSurface(z, 0.0, SolidPattern)\n        \n    // Sidewalk top.\n        AxisSurface(z, 0.1, \n                    // Left.\n                    AxisPattern(x, -3.0, SolidPattern, \n                                // Right\n                               AxisPattern(x, 3.0, NonSolidPattern, SolidPattern)\n                   ))\n        \n    // Sidewalk left curb.\n        AxisSurface(x, -3.0, AxisPattern(z, 0.1, SolidPattern, NonSolidPattern))\n        \n    // Sidewalk right curb.\n        AxisSurface(x, 3.0, AxisPattern(z, 0.1, SolidPattern, NonSolidPattern)) \n       \n        //Streelights.\n        \n        CapsuleSurface(vec3(-4.425, 8.0, 0.1), vec3(-4.425, 8.0, 1.0), 0.25, SolidPattern)\n        CapsuleSurface(vec3(-4.425, 8.0, 1.0), vec3(-4.425, 8.0, 5.255), 0.125, SolidPattern)\n        CapsuleSurface(vec3(-2.8, 8.0, 5.225), vec3(-4.425, 8.0, 5.225), 0.125, SolidPattern)\n        \n        CapsuleSurface(vec3(4.425, -2.0, 0.1), vec3(4.425, -2.0, 1.0), 0.25, SolidPattern)\n        CapsuleSurface(vec3(4.425, -2.0, 1.0), vec3(4.425, -2.0, 5.255), 0.125, SolidPattern)\n        CapsuleSurface(vec3(2.8, -2.0, 5.225), vec3(4.425, -2.0, 5.225), 0.125, SolidPattern) \n        \n               CapsuleSurface(vec3(4.425, 18.0, 0.1), vec3(4.425, 18.0, 1.0), 0.25, SolidPattern)\n        CapsuleSurface(vec3(4.425, 18.0, 1.0), vec3(4.425, 18.0, 5.255), 0.125, SolidPattern)\n        CapsuleSurface(vec3(2.8, 18.0, 5.225), vec3(4.425, 18.0, 5.225), 0.125, SolidPattern)  \n        \n        CapsuleSurface(vec3(-4.425, -12.0, 0.1), vec3(-4.425, -12.0, 1.0), 0.25, SolidPattern)\n        CapsuleSurface(vec3(-4.425, -12.0, 1.0), vec3(-4.425, -12.0, 5.255), 0.125, SolidPattern)\n        CapsuleSurface(vec3(-2.8, -12.0, 5.225), vec3(-4.425, -12.0, 5.225), 0.125, SolidPattern)        \n        \n        CapsuleSurface(vec3(-4.425, 28.0, 0.1), vec3(-4.425, 28.0, 1.0), 0.25, SolidPattern)\n        CapsuleSurface(vec3(-4.425, 28.0, 1.0), vec3(-4.425, 28.0, 5.255), 0.125, SolidPattern)\n        CapsuleSurface(vec3(-2.8, 28.0, 5.225), vec3(-4.425, 28.0, 5.225), 0.125, SolidPattern)         \n        \n    // Bridge underside.\n        AxisSurface(z, 5.5, AxisPattern(y, 3.4, NonSolidPattern, AxisPattern(y, 28.2, SolidPattern, NonSolidPattern)));\n        \n    // Bridge front.\n    \tAxisSurface(y, 3.4, AxisPattern(z, 5.5, NonSolidPattern, AxisPattern(z, 8.4, SolidPattern, NonSolidPattern)))\n    \n    // Bridge lights.\n            CapsuleSurface(vec3(22.5, 10.0, 13.175), vec3(22.5, 5.6, 12.175), 0.125, SolidPattern)\n            CapsuleSurface(vec3(22.5, 5.6, 7.3), vec3(22.5, 5.6, 12.0), 0.25, SolidPattern)\n            \n            CapsuleSurface(vec3(-7.5, 10.0, 13.175), vec3(-7.5, 5.6, 12.175), 0.125, SolidPattern)\n            CapsuleSurface(vec3(-7.5, 5.6, 7.3), vec3(-7.5, 5.6, 12.0), 0.25, SolidPattern)            \n            \n     // Bridge supports.\n            CapsuleSurface(vec3(12.5, 9.2, 4.8), vec3(12.5, 9.2, -1.75), 2.0, SolidPattern)\n            CapsuleSurface(vec3(12.5, 22.40618, 4.8), vec3(12.5, 22.40618, -1.75), 2.0, SolidPattern)\n            \n            CapsuleSurface(vec3(-17.5, 9.2, 4.8), vec3(-17.5, 9.2, -1.75), 2.0, SolidPattern)\n            CapsuleSurface(vec3(-17.5, 22.40618, 4.8), vec3(-17.5, 22.40618, -1.75), 2.0, SolidPattern)            \n            \n            CapsuleSurface(vec3(-47.5, 9.2, 4.8), vec3(-47.5, 9.2, -1.75), 2.0, SolidPattern)\n            CapsuleSurface(vec3(-47.5, 22.40618, 4.8), vec3(-47.5, 22.40618, -1.75), 2.0, SolidPattern)   \n            \n            CapsuleSurface(vec3(-77.5, 9.2, 4.8), vec3(-77.5, 9.2, -1.75), 2.0, SolidPattern)\n            CapsuleSurface(vec3(-77.5, 22.40618, 4.8), vec3(-77.5, 22.40618, -1.75), 2.0, SolidPattern)                        \n            \n            // Distant buildings.\n            /*\n            AxisSurface(y, 115.0, AxisPattern(x, -58.7668, NonSolidPattern, AxisPattern(x, -37.55514, SolidPattern, NonSolidPattern)))\n            AxisSurface(x, -37.55514, AxisPattern(y, 115.0, NonSolidPattern, SolidPattern))\n            \n            AxisSurface(y, 123.14195, AxisPattern(x, -30.41511, NonSolidPattern, AxisPattern(x, -9.20345, SolidPattern, NonSolidPattern)))\n            AxisSurface(x, -30.41511, AxisPattern(y, 123.14195, NonSolidPattern, SolidPattern))\n            */\n    // Render lights.\n        #define Rain(size, speed, strength) { intensity *= dot(mix(vec3(strength), vec3(1.0), sin(sin(size * originNearest + TIME * speed) + TIME)), vec3(1.0)); }\n    #define StreetLight DistanceFalloff(1.2, 2.0) DirectionalFalloff(vec3(0.0, 0.0, -1.0), 2.0) Rain(0.5, vec3(1.0, 5.0, 8.0), 0.7) Shade(vec3(1.0, 1.0, 0.6))   \n    RadialOrigin(vec3(-2.8, -12.0, 5.225)) StreetLight    \n    RadialOrigin(vec3(2.8, -2.0, 5.225)) StreetLight    \n    RadialOrigin(vec3(-2.8, 8.0, 5.225)) StreetLight    \n    RadialOrigin(vec3(2.8, 18.0, 5.225)) StreetLight    \n    RadialOrigin(vec3(-2.8, 28.0, 5.225)) StreetLight   \n            \n    #define OverpassLight DistanceFalloff(1.2, 2.0) Rain(0.5, vec3(1.0, 5.0, 8.0), 0.7) Shade(vec3(0.8, 0.4, 0.1))   \n            // Closest side of overpass.\n    RadialOrigin(vec3(22.5, 10.0, 13.05)) OverpassLight              \n            RadialOrigin(vec3(-7.5, 10.0, 13.05)) OverpassLight              \n            RadialOrigin(vec3(-47.5, 10.0, 13.05)) OverpassLight              \n        \n            // Furthest side of overpass.\n          RadialOrigin(vec3(37.5, 21.6, 13.05)) OverpassLight    \n            RadialOrigin(vec3(7.5, 21.6, 13.05)) OverpassLight    \n\t\t\tRadialOrigin(vec3(-22.5, 21.6, 13.05)) OverpassLight    \n            RadialOrigin(vec3(-52.5, 21.6, 13.05)) OverpassLight    \n            /*\n            // Lights between the distant buildings.\n            #define DistantLight(color) DistanceFalloff(1.0, 2.0) Shade(color)\n            \n            RadialOrigin(vec3(-64.3834, 115.0, 1.0)) DistantLight(vec3(0.4, 0.3, 0.0))\n            RadialOrigin(vec3(-35.0, 135.0, 4.0)) DistantLight(vec3(0.5, 0.3, 0.0))\n            RadialOrigin(vec3(-8.0, 150.0, 3.0)) DistantLight(vec3(0.2, 0.1, 0.05))\n            */\n            // A big dim light to help separate things a little.\n            RadialOrigin(vec3(-38.96571, 58.15232, 20.55807)) DistanceFalloff(2.0, 1.0) Shade(vec3(0.0, 0.0, 1.0))\n            \n    // Sky\n        if(nearest == INFINITY) {\n            //accumulator += vec3(0.02, 0.018, 0.005);\n        }\n        \n    // End of generated code.\n    \n    // Gamma correct and wrap for GLSL.\n\tFRAGCOLOR = vec4(pow(accumulator, vec3(1.0 / 2.2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[3426, 3834, 3906, 4197, 4536], [8283, 8794, 8837, 8837, 8962], [8964, 8964, 9007, 9007, 9132], [9134, 9134, 9177, 9177, 9302]], "test": "untested"}
{"id": "llfGD2", "name": "Fractal Wheel 2.0", "author": "gabgoh", "description": "Wheel Fractal", "tags": ["thisonelookslikeawheel"], "likes": 7, "viewed": 955, "published": "Public", "date": "1425175054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform struct points { vec2 p[8]; };\n    \nstruct ind_dist { vec2 v; float dist; };\n\nfloat thresh(float x) {\n    if (x > 1.0) { return 1.0; }\n    if (x < 0.0) { return 0.0; }\n\treturn x;\n}\n    \nind_dist get_nearest(points p, vec2 uv)\n{\n    \n    float minval = 1e10;\n    vec2  v;\n    for (int i = 0; i < 8; i ++) {\n        float d = distance(uv, p.p[i]);\n        minval = min(d,minval);\n        if (minval == d) {\n            v = p.p[i];\n        }\n    }\n    \n    ind_dist o;\n    o.v = v;\n    o.dist  = minval;\n\treturn o;\n}\n    \nfloat ani(float iTime){\n    return abs(sin(1.0*iTime));\n}\n\nvec2 getuv(float scale, vec2 uv) {\n    // Get Normalized UV Coordinates\n\tuv = (uv - 0.5);\n   \tuv[0] = 1.8*uv[0];\n    uv = scale*uv; \n    return uv;\n}\n\nvec2 sphereinv(vec2 x, float r){\n    return r*x/(x[0]*x[0] + x[1]*x[1]);\n}\n\nmat2 rotate_mat(float theta) {\n    // 2x2 Rotation Matrix\n    return mat2( cos( theta ), -sin( theta ),\n                 sin( theta ),  cos( theta ));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float t = iTime;\n    \n    points p;\n    p.p[0] = vec2(  0.0,  2.0 );\n    p.p[1] = vec2(  2.0,  0.0 );\n    p.p[2] = vec2( -2.0,  0.0 );\n    p.p[3] = vec2(  0.0, -2.0 );\n    \n    float c = sqrt(2.0);\n    p.p[4] = vec2( -c, -c  );\n    p.p[5] = vec2( -c,  c );\n    p.p[6] = vec2(  c,  c );\n    p.p[7] = vec2(  c, -c );\n    \n    vec2 uv = getuv(3.2,fragCoord.xy / iResolution.xy);\n    \n\tind_dist I;\n    const int iters = 10;\n    float depth = 0.0;\n    vec2 closest_pt;\n    for (int i = 0; i < iters; i++) {\n        I = get_nearest(p, uv);\n        closest_pt = I.v;        \n        uv = (2.0)*(uv - closest_pt) + closest_pt;\n        uv = rotate_mat(0.5*t)*uv;\n        if (length(uv) < 1.7 -3.5*cos(1.0*t) ){\n            uv = sphereinv(uv,1.0 );\n    \t}\n        depth = depth + I.dist;\n    }\n    \n    float minval = I.dist/pow(2.0,float(iters));\n    float r; float g; float b;\n    r = 1.0 - smoothstep(0.0,15.0,depth);\n    g = 1.0 - smoothstep(0.0,15.0,depth);\n    b = 1.0 - smoothstep(0.0,15.0,depth);\n\n    fragColor = vec4(r,g,b,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llfGD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 108, 108, 187], [193, 193, 234, 234, 520], [526, 526, 549, 549, 583], [585, 585, 619, 656, 734], [736, 736, 768, 768, 810], [812, 812, 842, 869, 968], [970, 970, 1027, 1027, 2069]], "test": "untested"}
{"id": "llj3RD", "name": "Sunset Cloud", "author": "kuvkar", "description": "Cloud shader with sun coloring, was trying to accomplish a sunset look. Mouse to rotate cloud.", "tags": ["raymarching", "cloud"], "likes": 38, "viewed": 876, "published": "Public", "date": "1427556715", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\n////////////////// distance field functions from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n/////////////////\n\n\n// Utility stuff\n#define PI 3.14159\n\nmat3 rotx(float a) { mat3 rot; rot[0] = vec3(1.0, 0.0, 0.0); rot[1] = vec3(0.0, cos(a), -sin(a)); rot[2] = vec3(0.0, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.0, sin(a)); rot[1] = vec3(0.0, 1.0, 0.0); rot[2] = vec3(-sin(a), 0.0, cos(a)); return rot; }\n\n    \n\nfloat toClipSpace(float f)\n{\n    return f * 2.0 - 1.0;\n}\n\n\nvec3 lookAt(vec3 from, vec3 to, vec3 dir)\n{\n    mat3 m;\n    \n    vec3 fwd = normalize(to - from);\n    vec3 _up = vec3(0.0, 1.0, 0.0);\n    vec3 r = cross(fwd, _up);\n    vec3 u = cross(r, fwd);\n    \n    m[0] = r;\n    m[1] = u;\n    m[2] = fwd;\n    vec3 d = m * dir;    \n    d.z *= -1.0;\n    return d;\n}\n\nmat3 rotation;\n\n\n// Density at any position in world\nfloat worldDensity(vec3 position)\n{\n    float m = 9999.0;\n    position = position * rotation;\n    float s = sdSphere(position, 0.1);\n    \n    vec3 offset = vec3(0.0, 0.0, iTime * 0.010);\n    \n    float n = (snoise(position , 8.0)) * 0.08;\n    n -= (snoise(position + offset, 20.0)) * 0.035;\n    n += (snoise(position, 100.0)) * 0.010;\n    \n    if (s + n < 0.0)\n    {\n        return n;\n    }\n    \n    return m;\n}\n\n\n// Ray marching parameters\nconst int STEPS = 50;\nconst float STEP = 0.005;    \nconst int STEPS_TO_SUN = 2;\n\n\n// These variables can be tweaked\nvec3 sun = vec3(0.0, 1.0, 0.0);\nconst float LIGHTNESS = 1.26;\nconst float ABSORPTION = 3.5;\nconst float INTENSITY = 1.75;\nconst float SUN_INTENSITY = 0.035;\nconst float SUN_SHARPNESS = 30.0;\n\n\nvec4 basecolor = vec4(1.5, 0.5, 0.0, 0.0);\nvec4 suncolor = vec4(1.0, 0.3, 0.0, 0.0);\nvec2 uv;\n\nbool trace(vec3 from, vec3 dir, inout vec4 color)\n{\n    \n    vec3 rp = from + dir * 0.85;\n    vec4 cloudcolor = vec4(0.0, 0.0, 0.0, 0.0);\n    bool hit = false;\n    for (int i = 0; i < STEPS; ++i)\n    {\n        rp += dir * STEP;\n        float densityAtPosition = worldDensity(rp);\n        \n        if (densityAtPosition <= 0.0 && cloudcolor.a <= 1.0)\n        {\n            // ambient color\n            float density = abs(densityAtPosition) * ABSORPTION;\n            cloudcolor.rgb += (1.0 - cloudcolor.a) * INTENSITY * pow(density, LIGHTNESS);\n            cloudcolor.a += density;\n            \n            // in scattering from sun\n            vec3 pos = rp;\n            float d = 0.0;\n            for (int j = 0; j < STEPS_TO_SUN; ++j)\n            {\n\n                pos += sun * STEP;\n                float densityAtPosition = worldDensity(pos);\n                d += abs(clamp(densityAtPosition, -1.0, 0.0)) * SUN_SHARPNESS;\n            }\n            d = 1.0 - clamp(d, 0.0, 1.0);\n            cloudcolor += suncolor * d * SUN_INTENSITY;\n            hit = true;\n        }\n        \n        if(cloudcolor.a >= 1.0)\n        {\n           break;\n        }\n    }\n    \n    cloudcolor *= cloudcolor;\n    float orange = smoothstep(0.7, 1.4, 1.3 - uv.y);\n\n    float blue = 1.0 - orange;\n    basecolor *= orange;\n    basecolor += blue * vec4(0.0, 0.0, 0.2, 0.0);\n    color = basecolor + cloudcolor;\n    return hit;\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.x);\n    uv.y += (iResolution.y / iResolution.x) * 0.4;\n    \n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse -= vec2(0.5);\n    rotation = mat3(1);\n    \n    rotation *= roty(mouse.x * 10.0);\n    rotation *= rotx(mouse.y * 10.0);\n    \n    vec3 camPos = vec3(0.0, 0.0, 1.0);    \n    vec3 lk = vec3(-toClipSpace(uv.x), -toClipSpace(uv.y), -4.0);\n    vec3 dir = lookAt(camPos, vec3(0.0), normalize(lk));\n    vec4 color = vec4(0.0);\n    \n    trace(camPos, dir,  color);\n    \n    fragColor = color;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llj3RD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 36, 36, 560], [562, 678, 713, 713, 737], [758, 795, 815, 815, 942], [943, 943, 963, 963, 1090], [1098, 1098, 1126, 1126, 1154], [1157, 1157, 1200, 1200, 1456], [1475, 1511, 1546, 1546, 1922], [2034, 2356, 2407, 2407, 3762], [3767, 3767, 3824, 3824, 4398]], "test": "untested"}
{"id": "lll3Ds", "name": "ngWaves0A", "author": "netgrind", "description": "wavey", "tags": ["waves", "netgrind"], "likes": 3, "viewed": 1144, "published": "Public API", "date": "1426367918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec4 c = vec4(1.0);\n    c.r = sin(uv.y*10.0*cos(uv.x*10.0+i+sin(uv.x+uv.y+i)*tan(uv.y*1.0+i))+i)*.5+.5;\n    c.g = sin(c.r*PI*2.0)*.5+.5;\n    c.b = sin(c.g*PI*2.0+i)*.5+.5;\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lll3Ds.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 75, 75, 332]], "test": "untested"}
{"id": "lll3DX", "name": "Basic Water", "author": "felixisdev", "description": "basic water", "tags": ["waves"], "likes": 6, "viewed": 324, "published": "Public", "date": "1425874334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 getPixel(vec2 pos)\n{\n    return vec3(texture(iChannel0, pos / 500.0).rgb);\n}\n\nvec4 mixVec4(vec4 vf, vec4 vt, float mix)\n{\n    if (mix < 0.0) mix = 0.0;\n   \tif (mix > 1.0) mix = 1.0;\n    \n    return vec4(vf.r + (vt.r - vf.r) * mix, \n                vf.g + (vt.g - vf.g) * mix, \n                vf.b + (vt.b - vf.b) * mix, \n                vf.a + (vt.a - vf.a) * mix);\n}\n\nfloat sine(float value)\n{\n    return (sin(value) + 1.0) / 2.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ps = vec2(fragCoord.x, iResolution.y - 1.0 - fragCoord.y);\n    \n    float height = 150.0;\n    \n    for (int i = 0; i < 8; i++)\n    {\n        height += sin(ps.x / (50.0 + sin(4.15 + float(i) * 7.13) * 15.0) + iTime) * (2.0 + sin(2.14 + float(i) * 6.52));\n    }\n    \n    vec2 dist = ps;\n    vec2 light = ps;\n    \n    if (ps.y >= height + 7.0)\n    {\n        dist.x += sin(dist.y / 20.0 + iTime) * 4.0;\n        dist.y += sin(dist.x / 20.0 + iTime) * 4.0;\n        light.x += sin(light.y / 17.0 + iTime) * 20.0;\n        light.y += sin(light.x / 17.0 + iTime) * 20.0;\n    }\n    \n\tfragColor = vec4(getPixel(dist), 1.0);\n    \n    if (ps.y >= height)\n    {\n        float sm = ((ps.y - height) / 1.5);\n        if (sm > 1.0) sm = 1.0;\n        \n        float f = 0.75 - ((ps.y - height - 7.0) / 600.0);\n        if (f < 0.25) f = 0.25;\n        \n        fragColor = mixVec4(fragColor, vec4(0.5, 0.9, 1.0, 1.0), f * sm);\n        \n        f = mod((ps.x - ps.y) / 100.0, 1.0);\n        \n        float inten = 0.5 + sin((ps.x - ps.y) / 40.0) * 0.25 + sin((ps.x - ps.y) / 74.0) * 0.125;\n        \n        fragColor = mixVec4(fragColor, vec4(1.0, 1.0, 1.0, 1.0), \n                                (1.0 - ((light.y - height - 600.0) / (213.0 + sin(light.x / 124.0) * 47.0))) * \n                                ((sin(light.x / 63.0) + 1.0) / 2.0) * ((sin(iTime + sin(light.x / 52.0)) + 1.0) / 2.0)\n                           * inten * 0.25 * sm);\n        \n        fragColor = mixVec4(fragColor, vec4(1.0, 0.95, 0.9, 1.0), \n                                (1.0 - ((light.y - height - 7.0) / (200.0 + sin(light.x / 100.0) * 50.0))) * \n                                ((sin(light.x / 76.0) + 1.0) / 2.0) * ((sin(iTime + sin(light.x / 46.0)) + 1.0) / 2.0)\n                           * (f > inten ? 1.0 : 0.0) * sm);\n        \n        if (ps.y >= height && ps.y < height + 8.0)\n        {\n            fragColor = mixVec4(fragColor, vec4(0.75, 0.9, 1.0, 1.0), (1.0 - (ps.y - height) / 10.0) * sm);\n            fragColor = mixVec4(fragColor, vec4(1.0, 1.0, 1.0, 1.0), (1.0 - (ps.y - height) / 10.0) * sm * sine(ps.x / 30.0 + ps.y / 4.0));\n        }\n    }\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lll3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 81], [83, 83, 126, 126, 373], [375, 375, 400, 400, 439], [441, 441, 498, 498, 2671]], "test": "untested"}
{"id": "lll3W2", "name": "Toon Spheres", "author": "DeathOfRats", "description": "First ray march attempt. Thanks to huwb for his help talking me through the abstract stuff behind ray marching in general. Also nicked a few things from iq's website. (quite a few things)", "tags": ["raymarch"], "likes": 7, "viewed": 268, "published": "Public", "date": "1425399712", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DIST_MAX 200.\n//#define SOFT\n\n\nvec3 diffuse = vec3(.9,.02,.01);\nvec3 specular = vec3(.3,.3,.3);\nvec3 intensity = vec3(.95, .95, .95);\nvec3 ambient = vec3(.05,.05,.05);\nvec3 bg = vec3(.9,.9,.9);\nfloat atten = 0.03;\nfloat shininess = .04;\n\nfloat sdSphere ( in vec3 centre, in vec3 pos, in float r ){\n\treturn length(pos - centre) - r;\n}\n\nfloat sdPlane( vec3 p, vec3 planeP, vec3 planeN )\n{\n  return dot(p - planeP, planeN);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nfloat sdfMap(in vec3 p)\n{\n    //return min(sdSphere(vec3(0.,0.,0.), p, .5), sdPlane(p, vec3(0.,-1.,0.), vec3(0.,1.,0.)));\n    \n    vec3 c = vec3(15,20,15);\n    vec3 q = mod(p,c)-0.5*c;\n    return sdSphere(vec3(0.,0.,0.), q, 3.);\n\n}\n\nvec3 getNorm(in vec3 p)\n{\n\tvec3 e = vec3(0.001, 0., 0.);\n    vec3 norm = vec3\n        (sdfMap(p+e.xyy) - sdfMap(p-e.xyy),\n         sdfMap(p+e.yxy) - sdfMap(p-e.yxy),\n         sdfMap(p+e.yyx) - sdfMap(p-e.yyx));\n   \treturn normalize(norm);\n}\n\nvec3 castRay(in vec3 rd, in vec3 p, in float tmax)\n{\n    float tmin = .1;\n    float precis = 0.0002;\n    float d = 0.;\n    float steps = 0.;\n    \n    float t = tmin;\n    for(int i = 0; i < 200; i++){\n        d = sdfMap(p + t*rd);\n        if( t > tmax || d < precis) break;\n        t += d;\n        steps++;\n    }\n    \n    if(t > tmax) d = -1.0;\n    return vec3(t, d, steps);\n}\n\nfloat shadow(in vec3 rd, in vec3 p, in float tmax)\n{\n    float tmin = .1;\n    float precis = 0.01;\n    \n    float d = 0.;\n    float dmin = 1.;\n    \n    float t = tmin;\n    for(int i = 0; i < 100; i ++){\n     \td = sdfMap(p + rd * t);\n        if(d < precis) return 0.;\n        if(t > tmax) break;\n        #ifdef SOFT\n        \tdmin = min(dmin, 50. * d/t);\n        #endif\n        t += d;\n    }\n    \n    #ifdef SOFT\n    \treturn dmin;\n    #else\n    \treturn 1.;\n    #endif\n}\n\n// Function takes normal and ray direction,\n// returns light shaded color\nvec3 shade(in vec3 camPos, in vec3 pos, in vec3 normal, in vec3 rd){\n    vec3 lightPos = vec3(0.,camPos.y, 20. + 20. * sin(iTime));\n    vec3 lightDiff = lightPos - pos;\n    vec3 lightDir = normalize(lightDiff);\n    \n    // Standard light\n    float angOfInc = dot(normal, lightDir);\n    angOfInc = step(angOfInc, 1.);\n    \n    // Specular component - was gaussian before I made this toony\n    // Probably simpler ways to do this\n    vec3 halfAngle = normalize(lightDir - rd);\n    float angleNormalHalf = acos(dot(halfAngle, normal));\n    float exponent = angleNormalHalf/shininess;\n    exponent = -pow(exponent, 2.);\n    float gaussian = exp(exponent);\n    gaussian = step(shininess, gaussian);\n    \n    //Attenuation\n    float distSquared = dot(lightDiff, lightDiff);\n    intensity *= (1.0 / (1.0 + atten * sqrt(distSquared)));\n    \n    //Edge Lines\n    vec3 camDir = normalize(camPos - pos);\n    float dist = length(camPos - pos);\n    float c = mix(.25, .5, dist / DIST_MAX);\n    if(dot(normal, camDir) < c ){\n       diffuse = vec3(0.,0.,0.);\n       specular = vec3(0.,0.,0.);\n    }\n    \n    //Shadows\n    float s = shadow(lightDir, pos, length(lightDiff));\n    intensity *= s;\n    \n    vec3 color =(intensity * diffuse * angOfInc)\n        \t+ (intensity * specular * gaussian)\n        \t+ (ambient * diffuse)\n            ;\n    \n    return color;\n}\n\nvec3 rayMarch(in vec3 rd, in vec3 p)\n{\n    vec3 col;\n\n\tvec3 res = castRay(rd, p, DIST_MAX);\n    float t = res.x;\n    float d = res.y;\n\n    if(d > -0.5){\n        vec3 pos = p + t*rd;\n        vec3 norm = getNorm(pos);\n        vec3 ref = normalize(reflect(rd, norm));\n        \n        col = shade(p, pos, norm, rd);\n        col = pow( col, vec3(1.0/2.2) );\n        col = mix( col, bg, smoothstep(100., 200., t));//clamp(t / 190.0,0.,1.) );\n        //col = mix( col, bg, 1.-exp(-.005*t) );\n        //col = mix( col, bg, clamp(res.z / 70.0,0.,1.) );\n        \n    \n    }else{\n        col = bg;\n    }\n    \n    return clamp(col, 0.0, 1.0);\n}\n\nvec3 rayDir(in vec2 uv, out vec3 camPos)\n{\n    float radius = 1.;\n    float theta = sin(iTime / 2.);\n    \n    float camZ = radius * cos(theta);\n    float camX = radius * sin(theta);\n    \n    //camera frame setup\n    vec3 target = vec3(0.,iTime * 3.,0.);\n    camPos = target + vec3(camX, 0., -camZ);\n    \n    vec3 up = vec3(0,1,0);\n    vec3 fo = normalize(target - camPos);\n    vec3 ri = normalize(cross(fo, up));\n    \n    float fov = .5;\n    \n    //Calcuate rayDir\n    vec3 rayDir = normalize(fo + fov*uv.x*ri + fov*uv.y*up);\n    \n    return rayDir;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 pp = (-1.0 + 2.0*uv);\n    pp.x *= iResolution.x / iResolution.y;\n    \n\tvec3 camPos;\n    vec3 rd = rayDir( pp, camPos );\n    fragColor.xyz = rayMarch(rd, camPos);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lll3W2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 246, 305, 305, 341], [343, 343, 394, 394, 430], [432, 432, 463, 463, 559], [561, 561, 586, 682, 792], [794, 794, 819, 819, 1034], [1036, 1036, 1088, 1088, 1411], [1413, 1413, 1465, 1465, 1880], [1882, 1956, 2024, 2024, 3303], [3305, 3305, 3343, 3343, 3938], [3940, 3940, 3982, 3982, 4496], [4498, 4498, 4555, 4555, 4773]], "test": "untested"}
{"id": "lll3Wf", "name": "Shifting Waves", "author": "jameswilddev", "description": "They see me rolling", "tags": ["wave"], "likes": 5, "viewed": 130, "published": "Public", "date": "1425906192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy / iResolution.xy);\n    uv.y += sin(uv.x * 10.0) * 0.1;\n    uv.x += sin(uv.y * 20.0) * 0.1;\n    float t = uv.y * sin(iTime * cos(0.001 * iTime)) * 4.0 + uv.x * cos(iTime * 0.3) * 10.0;\n    mat2 rotation = mat2(cos(t), -sin(t), sin(t), cos(t));\n    \n    mat3 col = mat3(\n        1.0, 0.0, 0.0, \n        0.6, 0.3, 0.4, \n        0.7, 0.6, 0.3);\n    \n\tfragColor = vec4(vec3(abs(uv * rotation),1.0) * col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lll3Wf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 492]], "test": "untested"}
{"id": "lllGDl", "name": "Fluid with Obstacles", "author": "eiffie", "description": "Thanks to andregc we have fluid! Use the mouse to position some \"movers\".\nThe original is found here: [url]https://www.shadertoy.com/view/4llGWl[/url]", "tags": ["fluid", "fluidsolver"], "likes": 56, "viewed": 3320, "published": "Public API", "date": "1426274066", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//fluid with obstacles by eiffie based on...\n//2d fluid by andregc https://www.shadertoy.com/view/4llGWl\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define TEXTURE iChannel0\n#define STEP_COUNT 10\n\n\nconst float PI = 3.14159265;\n\n//these are the field movers\nvec2 swirl(vec2 uv, vec2 center, float strength, float eyeWall) {\n\tvec2 d = uv - center;\n\treturn vec2(d.y, -d.x)/(dot(d,d)/strength+eyeWall);\n}\nvec2 spray(vec2 uv, vec2 center, vec2 dir, float strength, float eyeWall){\n\tvec2 d = uv - center;\n\treturn vec2(d.x, d.y)/(dot(d,d)/strength+eyeWall)*dot(d,dir);\n}\nvec2 drain(vec2 uv, vec2 center, float strength, float eyeWall){\n\tvec2 d = uv - center;\n\treturn -vec2(d.x, d.y)/(dot(d,d)/strength+eyeWall);\n}\n//DE is used to define barriors\nfloat Tube(vec2 pa, vec2 ba){return length(pa-ba*clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0));}\nfloat DE(vec2 p){\n\tp+=vec2(0.5);\n\treturn min(length(p),Tube(p-vec2(1.0),vec2(0.4,0.2)));\n}\nvec2 ReflectOffSurf(vec2 p, vec2 r){\n\tfloat d=max(DE(p),0.001);\n\tvec2 v=vec2(d,0.0);\n\tvec2 N=normalize(vec2(DE(p+v.xy)-DE(p-v.xy),DE(p+v.yx)-DE(p-v.yx)));\n\td=clamp(sqrt(d)*1.1,0.0,1.0);\n\tr=mix(reflect(r,N)*clamp(0.5-0.5*dot(r,N),0.0,1.0),r*d,d);\n\treturn r;\n}\nvec2 field(vec2 uv) {\n\tvec2 mouse = (iMouse.x == 0. && iMouse.y==0.) ? vec2(-0.15,-0.1) : iMouse.xy/iResolution.xy-vec2(0.5);\n\tmouse.x *= iResolution.x/ iResolution.y;\n\tmouse*=3.0;\n\tvec2 p= \n\t\tswirl(uv, mouse,1.5,0.25)\n\t\t+spray(uv,-mouse,vec2(-1.0,0.5),0.5,0.1)\n\t\t+drain(uv,mouse,0.5,0.75)\n\t;\n\tp=ReflectOffSurf(uv,p);\n\treturn p;\n}\n\n//just basic clouds from perlin noise \nfloat rand(vec2 co){return fract(sin(dot(co,vec2(12.9898,78.233)))*43758.5453);}\nfloat noyz(vec2 co){\n\tvec2 d=smoothstep(0.0,1.0,fract(co));\n\tco=floor(co);\n\tconst vec2 v=vec2(1.0,0.0);\n\treturn mix(mix(rand(co),rand(co+v.xy),d.x),\n\t\tmix(rand(co+v.yx),rand(co+v.xx),d.x),d.y);\n}\nfloat clouds( in vec2 q, in float tm )\n{\n\tfloat f=0.0,a=0.6;\n\tfor(int i=0;i<5;i++){\n    \t\tf+= a*noyz( q+tm ); \n\t\tq = q*2.03;\n\t\ta = a*0.5;\n\t}\n\treturn f;\n}\n\nfloat getPattern(vec2 uv) {  //this can be any pattern but moving patterns work best \n\t//float w=texture(TEXTURE, uv*0.3).r;   \n\tfloat w=clouds(uv*5.0, iTime*0.5);\n\treturn w;\n}\n\nvec2 calcNext(vec2 uv, float t) {\n\tt /= float(STEP_COUNT);\n\tfor(int i = 0; i < STEP_COUNT; ++i) {\n\t\tuv -= field(uv)*t;\n\t}\n\treturn uv;\n}\n\nvec3 heatmap(float h){\n\treturn mix(vec3(0.1,0.2,0.4),vec3(2.0,1.5-h,0.5)/(1.0+h),h);\n}\n\nvec3 Fluid(vec2 uv, float t) {\n\tfloat t1 = t*0.5;\n\tfloat t2 = t1 + 0.5;\n\tvec2 uv1 = calcNext(uv, t1);\n\tvec2 uv2 = calcNext(uv, t2);\n\tfloat c1 = getPattern(uv1);\n\tfloat c2 = getPattern(uv2);\n\tfloat c=mix(c2,c1,t);\n    float f=1.5-0.5*abs(t-0.5);\n\tc=pow(c,f)*f;//correcting the contrast/brightness when sliding\n\tfloat h=mix(length(uv-uv2),length(uv-uv1),t);\n\treturn 2.0*c*heatmap(clamp(h*0.5,0.0,1.0));//blue means slow, red = fast\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord/iResolution.xy - vec2(0.5);\n\tuv.x *= iResolution.x/iResolution.y;\n\tuv*=3.0;\n\tfloat t = fract(iTime);\n\tvec3 c = Fluid(uv,t);//draws fluid\n\tfloat d=DE(uv);//get distance to objects\n\tc=mix(vec3(1.0-10.0*d*d),c,smoothstep(0.2,0.25,d));//mix in objects\n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllGDl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[273, 302, 367, 367, 445], [446, 446, 520, 520, 608], [609, 609, 673, 673, 751], [752, 784, 813, 813, 872], [873, 873, 890, 890, 963], [964, 964, 1000, 1000, 1222], [1223, 1223, 1244, 1244, 1553], [1555, 1594, 1614, 1614, 1674], [1675, 1675, 1695, 1695, 1870], [1871, 1871, 1911, 1911, 2024], [2026, 2026, 2053, 2153, 2202], [2204, 2204, 2237, 2237, 2339], [2341, 2341, 2363, 2363, 2427], [2429, 2429, 2459, 2459, 2860], [2862, 2862, 2919, 2919, 3216]], "test": "untested"}
{"id": "lllGWj", "name": "Alien magma", "author": "mpcomplete", "description": "Testing noise, fbm,and color rotation.", "tags": ["noise", "fbm", "hsv"], "likes": 10, "viewed": 1577, "published": "Public API", "date": "1425412359", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time (iTime*.15)\n\n// http://www.jcgt.org/published/0009/03/02/\nuvec3 pcg3d(uvec3 v) {\n  v = v * 1664525u + 1013904223u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  v ^= v >> 16u;\n\n  v.x += v.y*v.z;\n  v.y += v.z*v.x;\n  v.z += v.x*v.y;\n\n  return v;\n}\n// https://www.shadertoy.com/view/XlGcRh#\nvec3 hash3(vec3 uvt) {\n  uvec3 hu = pcg3d(uvec3(uvt * 1717.));  // scale by approximate resolution\n  return vec3(hu) * (1.0/float(0xffffffffu));\n}\n\n// Basic 3D noise\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nvec3 noise3(vec3 x) {\n\tvec3 i = floor(x);\n\tvec3 f = fract(x);\n\tvec3 u = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(mix( hash3(i + vec3(0,0,0)), hash3(i + vec3(1,0,0)), u.x),\n                 mix( hash3(i + vec3(0,1,0)), hash3(i + vec3(1,1,0)), u.x), u.y),\n             mix(mix( hash3(i + vec3(0,0,1)), hash3(i + vec3(1,0,1)), u.x),\n                 mix( hash3(i + vec3(0,1,1)), hash3(i + vec3(1,1,1)), u.x), u.y), u.z);\n}\n\n// https://code.google.com/p/fractalt}erraingeneration/wiki/Fractional_Brownian_Motion\nvec3 fbm(in vec2 p)\n{\n    const float gain = 0.5;\n    const float lacunarity = 2.;\n\n    vec3 total = vec3(0);\n\tfloat amplitude = gain;\n\n\tfor (int i = 1; i < 7; i++) {\n\t\ttotal += noise3(vec3(p, time)) * amplitude;\n\t\tamplitude *= gain;\n\t\tp *= lacunarity;\n\t}\n\treturn total;\n}\n\n// Simplex Noise\n// https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nconst float F3 = 0.3333333;\nconst float G3 = 0.1666667;\nfloat snoise(vec3 p) {\n\tvec3 s = floor(p + dot(p, vec3(F3)));\n\tvec3 x = p - s + dot(s, vec3(G3));\n\n\tvec3 e = step(vec3(0.0), x - x.yzx);\n\tvec3 i1 = e*(1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n\tvec3 x1 = x - i1 + G3;\n\tvec3 x2 = x - i2 + 2.0*G3;\n\tvec3 x3 = x - 1.0 + 3.0*G3;\n\n\tvec4 w, d;\n\n\tw.x = dot(x, x);\n\tw.y = dot(x1, x1);\n\tw.z = dot(x2, x2);\n\tw.w = dot(x3, x3);\n\n\tw = max(0.6 - w, 0.0);\n\n\td.x = dot(hash3(s), x);\n\td.y = dot(hash3(s + i1), x1);\n\td.z = dot(hash3(s + i2), x2);\n\td.w = dot(hash3(s + 1.0), x3);\n\n\tw *= w;\n\tw *= w;\n\td *= w;\n\n\treturn .5 + .5*dot(d, vec4(52.0));\n}\nvec2 snoise2(vec3 p) {\n  return vec2(snoise(p+vec3(17.1)), snoise(p+vec3(3.7)));\n}\n\n\nmat3 rotation(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * a.x * a.x + c,        oc * a.x * a.y - a.z * s,  oc * a.z * a.x + a.y * s,\n                oc * a.x * a.y + a.z * s,  oc * a.y * a.y + c,        oc * a.y * a.z - a.x * s,\n                oc * a.z * a.x - a.y * s,  oc * a.y * a.z + a.x * s,  oc * a.z * a.z + c);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tp.x *= iResolution.x/iResolution.y;\n\n    p.x = p.x*(1. + .2*sin(time*2.));\n    p.y = p.y*(1. + .2*sin(time*2.));\n    p += vec2(6.5, 6.5);\n\n    vec3 color = fbm(3.5*p);\n\n#if 0\n    color = mod(time + color*1.5, 1.);\n    color = hsv2rgb(vec3(color.x, .8, .8));\n#else\n    color = time*vec3(0.9, 0.7, 0.25) + color;\n\n    float c1 = color.x*3.;\n    float c2 = color.y*9.;\n    vec3 col1 = 0.5 + 0.5*sin(c1 + vec3(0.0,0.5,1.0));\n\tvec3 col2 = 0.5 + 0.5*sin(c2 + vec3(0.5,1.0,0.0));\n\tcolor = 2.0*pow(col1*col2,vec3(0.8));\n\n    vec3 axis = fbm(p*2.75);\n    color = rotation(.9*length(axis)*sin(8.*time), axis)*color;\n#endif\n\n    fragColor.xyz = color;\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 71, 93, 93, 270], [271, 313, 335, 335, 459], [461, 548, 569, 569, 967], [969, 1056, 1077, 1077, 1328], [1330, 1472, 1494, 1494, 2056], [2057, 2057, 2079, 2079, 2139], [2142, 2142, 2181, 2181, 2573], [2575, 2575, 2630, 2630, 3331]], "test": "untested"}
{"id": "lllGWX", "name": "ngRay0", "author": "netgrind", "description": "baby's first raytrace", "tags": ["raytrace", "cool", "netgrind"], "likes": 1, "viewed": 1143, "published": "Public API", "date": "1425799906", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//first ray thing\n//\n\n\n#define pi 3.1415\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n vec3 rc = ray;\n float c = dot(rc, rc) - (radius*radius);\n float b = dot(dir, rc);\n float d = b*b - c;\n float t = -b - sqrt(abs(d));\n float st = step(0.0, min(t,d));\n return mix(-1.0, t, st);\n}\n\nvec3 background(float t, vec3 rd)\n{\n vec3 light = normalize(vec3(sin(t), sin(t), cos(t)));\n float sun = max(0.0, dot(rd, light));\n float sky = max(0.0, dot(rd, vec3(-sin(iTime), -cos(iTime), -1.0)));\n float ground = max(0.0, -dot(rd, vec3(-sin(iTime+pi*2.0), -cos(iTime+pi*2.0), 1.0)));\n float bg = max(0.0, dot(rd, vec3(0.0,0.0, sin(iTime)*.2+1.0)));\n return \n  (pow(sun, 256.0)+0.2*pow(sun, 4.0))*vec3(1.0, 1.6, 0.0) +\n  pow(ground, 1.5)*vec3(sin(iTime)*.1+.4, 0.0, .3) +\n  pow(sky, 1.5)*vec3(0.0, sin(iTime)*.1+.3, .4)+\n  pow(bg, 2.0)*vec3(.5,.5,.5) ;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * \n    vec2(iResolution.x/iResolution.y, 1.0);\n    vec3 ro = vec3(0.0, 0.0, -2.5);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    float t = sphere(ro, rd, p, sin(cos(uv.x*13.0)*2.0+iTime+sin(uv.y*10.0+iTime))*.1+1.0);\n    vec3 nml = normalize(p - (ro+rd*t));\n    vec3 bgCol = background(iTime, rd);\n    rd = reflect(rd, nml);\n    vec3 col = background(iTime, rd) * vec3(0.9, 0.8, 1.0);\n    fragColor = vec4( mix(bgCol, col, step(0.0, t)), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lllGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 102, 102, 296], [298, 298, 333, 333, 854], [856, 856, 913, 913, 1446]], "test": "untested"}
{"id": "llS3Rw", "name": "Voronoi Experiment 5", "author": "aiekick", "description": "Vorono Experiment 5", "tags": ["experiment", "5", "vorono"], "likes": 4, "viewed": 1092, "published": "Public API", "date": "1427550362", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = iResolution.xy;\n\tvec2 uv = (2.*fragCoord.xy-s)/s.y;\n    \n    float coef = 12.;\n    \n    if ( iMouse.z>0. ) coef = iMouse.y/iResolution.y * coef;\n    \n    // voronoi\n    vec2 c0 = vec2(30.,20.);\n    vec2 c1 = vec2(10.,40.);\n    vec2 x = uv*coef;\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 mr;\n    float md = 5.;\n    float d;\n    for( int j=-1; j<=1; j++ )\n    {\n        for( int i=-1; i<=1; i++ )\n        {\n            vec2 g=vec2(float(i),float(j));\n            \n            // hash\n            vec2 ng = n+g;\n            float ng0 = dot(ng,c0);\n            float ng1 = dot(ng,c1);\n            vec2 ng01 = vec2(ng0,ng1);\n            vec2 hash = fract(cos(ng01)*iTime*0.2);\n            \n            vec2 o = 0.5+0.5*sin(6.2831*hash);//animated\n            \n            vec2 r = g+o-f;\n            \n            d = dot(r,r);\n            \n            if( d<md ) \n            {\n                md=d*dot(n,n);\n                mr=r*f;\n            } \n        }\n    }\n    vec3 voro = /*normalize*/(vec3(md, mr));\n    \n    // col    \n    vec3 col = voro.xzz;\n    \n   \tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llS3Rw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1170]], "test": "untested"}
{"id": "lls3Wf", "name": "Pseudo Knightyan", "author": "eiffie", "description": "An homage to Knighty.", "tags": ["godrays", "knighty", "volumelight", "pseudokleinian"], "likes": 46, "viewed": 2261, "published": "Public API", "date": "1425908996", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//pseudo knightyan by eiffie\n//I have been watching knighty put together a fine render engine here:\n//http://www.fractalforums.com/fragmentarium/updating-of-de-raytracer/\n//but because I dropped a pc on my fast graphics card I was unable to make a video\n//of it :) so I went this route and made a fake.\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nvec3 mcol=vec3(-1.0);\nmat2 rmx;\nint rotater=-1;\nfloat DE(vec3 p){//knighty's pseudo kleinian\n\tconst vec3 CSize = vec3(0.63248,0.78632,0.875);\n\tfloat DEfactor=1.;\n\tfor(int i=0;i<5;i++){\n\t\tif(i==rotater)p.xy=p.xy*rmx;\n\t\tp=2.*clamp(p, -CSize, CSize)-p;\n\t\tfloat k=max(0.70968/dot(p,p),1.);\n\t\tp*=k;DEfactor*=k;\n\t}\n\tif(mcol.r>=0.0)mcol+=abs(p);\n\tfloat rxy=length(p.xy);\n\treturn max(rxy-0.92784, abs(rxy*p.z) / length(p))/DEfactor;\n}\nvec3 Normal(in vec3 p, in float px){\n\tvec2 v=vec2(px*0.1,0.0);\n\tvec3 n=normalize(vec3(DE(p+v.xyy)-DE(p-v.xyy),DE(p+v.yxy)-DE(p-v.yxy),DE(p+v.yyx)-DE(p-v.yyx)));\n\treturn (n==n)?n:vec3(0.0);\n}\nfloat randSeed;\nvoid randomize(vec2 c){randSeed=fract(sin(dot(c,vec2(113.421,17.329)))*3134.1234);}\nfloat rand(){return fract(sin(randSeed++)*3143.45345);}\nvec3 path(float tyme){return vec3(cos(tyme),sin(tyme),-0.65+abs(sin(tyme*0.7))*0.25)*(2.0+sin(tyme*1.7)*0.5)+vec3(0.0,0.0,1.0);}\nvec4 scene(vec3 ro, vec3 rd, float pathSlider, float tyme, float pxl) {\n\trandomize(gl_FragCoord.xy+tyme);\n\tvec3 LP=path(tyme+1.0),p;\n\tLP.z+=pathSlider;\n\tro.z-=pathSlider;\n\tfloat d=DE(ro)*0.8,t=d*rand(),nt=d,od=1.0,ft=0.0;//t=totalDist,nt=nextDistForRealDECheck,od=lastDist,ft=fogStepDist\n\tvec4 col=vec4(0.0,0.0,0.0,1.0);\n\tvec4 am,tm=vec4(-1.0);//stacks for hit alphas and dists\n\tfor(int i=0;i<99;i++){\n\t\t//t+=d=DE(ro+rd*t);if(t>20.0 || d<0.001)break;\n\t\tif(nt>t+ft){//prepare for fog step\n\t\t\tp=ro+rd*(t+ft);\n\t\t\tp+=(LP-p)*(-p.z)/(LP.z-p.z);//sample the point on the plane z=0\n\t\t}else{//regular march \n\t\t\tp=ro+rd*t;\n\t\t}\n\t\td=DE(p);\n\t\tif(nt>t+ft){//step thru the fog and light it up\n\t\t\tfloat dL=0.05*length(ro+rd*(t+ft)-LP);//how far we step is based on distance to light\n\t\t\tcol.rgb+=col.a*vec3(1.0,1.0,0.7)*exp(-dL*40.0)*smoothstep(0.0,0.01,d);\n\t\t\tif(t+ft+dL>nt){\n\t\t\t\tft=0.0;\n\t\t\t\tt=nt;\n\t\t\t\tif(t>20.0)break;\n\t\t\t}else ft+=dL;\n\t\t}else{//save edge samples and march\n\t\t\tif(d<od && tm.w<0.0){\n\t\t\t\tfloat alpha=clamp(d/(pxl*t),0.0,1.0); \n\t\t\t\tif(alpha<0.95){\n\t\t\t\t\tam=vec4(alpha,am.xyz);tm=vec4(t,tm.xyz);\n\t\t\t\t\tcol.a*=alpha;\n\t\t\t\t}\n\t\t\t}\n\t\t\tod=d;\n\t\t\tnt=t+d*(0.6+0.2*rand());\n\t\t}\n\t}\n\tvec3 tcol=vec3(0.0);\n\tfor(int i=0;i<4;i++){//now surface lighting from the saved stack of hits\n\t\tif(tm.x<0.0)continue;\n\t\tmcol=vec3(0.0);\n\t\tp=ro+rd*tm.x;\n\t\tvec3 N=Normal(p,pxl*tm.x),L=LP-p,scol;\n\t\tmcol=sin(mcol)*0.3+vec3(0.8,0.6,0.4);\n\t\tfloat ls=exp(-dot(L,L)*0.2);\n\t\tp+=L*(-p.z)/L.z;\n\t\tL=normalize(L);\n\t\tscol=ls*mcol*max(0.0,dot(N,L));\n\t\tfloat v=max(0.0,dot(N,-rd));\n\t\tscol+=exp(-t)*mcol*v;\n\t\td=smoothstep(0.0,0.005,DE(p));\n\t\tscol+=ls*vec3(2.0,2.0,1.7)*max(0.0,dot(N,L))*d;\n\t\tif(rd.z<0.0 && d>0.0)scol+=ls*vec3(4.0,3.0,1.4)*pow(max(0.0,dot(reflect(rd,N),L)),5.0)*(1.0-0.25*v)*d;\n\t\ttcol=mix(scol,tcol,am.x);\n\t\tam=am.yzwx;tm=tm.yzwx;\n\t}\n\tcol.rgb=clamp(col.rgb+tcol,0.0,1.0);\n\treturn vec4(col.rgb,t);\n}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(fw,vec3(0.0,0.0,1.0)));return mat3(rt,cross(rt,fw),fw);\n}\n\nvoid SetCamera(inout vec3 ro, inout vec3 rd, inout float pathSlider,float tyme, vec2 uv){\n\tro=path(tyme);\n\tvec3 ta=path(tyme+0.2);ta.z+=0.1;\n\trd=lookat(ta-ro)*normalize(vec3(uv,1.0));\n\ttyme=mod(tyme,18.85);\n\trmx=mat2(cos(tyme),sin(tyme),-sin(tyme),cos(tyme));\n\trotater=5-int(tyme/3.1416);\n\tpathSlider=1.0;\n\tif(rotater==0)pathSlider=cos((tyme-15.707)*2.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 ro,rd;\n\tfloat pathSlider;\n\tSetCamera(ro,rd,pathSlider,iTime*0.125,uv);\n\tvec4 scn=scene(ro,rd,pathSlider,iTime*0.125,3.0/iResolution.y);\n\tfragColor = vec4(scn.rgb,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lls3Wf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 398, 415, 442, 776], [777, 777, 813, 813, 967], [984, 984, 1007, 1007, 1067], [1068, 1068, 1081, 1081, 1123], [1124, 1124, 1146, 1146, 1252], [1253, 1253, 1324, 1324, 3119], [3120, 3120, 3141, 3141, 3241], [3243, 3243, 3332, 3332, 3600], [3603, 3603, 3660, 3660, 3894]], "test": "untested"}
{"id": "lls3Wl", "name": "[TDF15]Wireframe 3D Shooting", "author": "yasuo", "description": "TokyoDemoFest2015\nGLSL Graphics Compo\n3rd", "tags": ["wireframe"], "likes": 20, "viewed": 987, "published": "Public", "date": "1426265973", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid circle(vec2 p, vec2 offset, float size, vec3 color, inout vec3 i){\n    float l = length(p - offset);\n    if(l < size){\n        i = color;\n    }\n}\n\nvoid rect(vec2 p, vec2 offset, float size, vec3 color, inout vec3 i){\n    vec2 q = (p - offset) / size;\n    if(abs(q.x) < 1.0 && abs(q.y) < 1.0){\n        i = color;\n    }\n}\n\nfloat line(vec2 p, vec2 p0, vec2 p1, float w) {\n    float WEIGHT = 3.0 / iResolution.x;\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t/1.0+(sin(iTime*0.5)*0.002);\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT*(w+(sin(iTime*0.5)*0.1));\n    return min(dist*dist,1.0);\n}\n\nvoid hud(vec2 p, vec2 offset, float size, vec3 color, inout vec3 i, float sp){\n    vec2 q = (p - offset) / size;\n    if(abs(q.x) < 1.0+abs(sin(iTime*sp)*19.0) && abs(q.y) < 0.9){\n        i = color;\n    }\n}\n\nmat4 matRotateX(float rad)\n{\n\treturn mat4(1,       0,        0,0,\n\t\t\t\t0,cos(rad),-sin(rad),0,\n\t\t\t\t0,sin(rad), cos(rad),0,\n\t\t\t\t0,       0,        0,1);\n}\n\nmat4 matRotateY(float rad)\n{\n\treturn mat4( cos(rad),0,-sin(rad),0,\n\t\t\t\t 0,       1,        0,0,\n\t\t\t\t sin(rad),0, cos(rad),0,\n\t\t\t\t 0,       0,        0,1);\n}\n\nmat4 matRotateZ(float rad)\n{\n\treturn mat4(cos(rad),-sin(rad),0,0,\n\t\t\t\tsin(rad), cos(rad),0,0,\n\t\t\t\t       0,        0,1,0,\n\t\t\t\t\t   0,        0,0,1);\n}\n\nmat4 translate(vec3 t)\n{\n\treturn mat4(1,0,0,t.x,\n\t\t\t\t0,1,0,t.y,\n\t\t\t\t0,0,1,t.z,\n\t\t\t\t0,0,0,1);\n}\n\nmat4 scale(vec3 s)\n{\n\treturn mat4(s.x,  0,  0,0,\n\t\t\t\t  0,s.y,  0,0,\n\t\t\t\t  0,  0,s.z,0,\n\t\t\t\t  0,  0,  0,1);\n}\n\nmat4 perspectiveLH(float vw, float vh, float z_near, float z_far)\n{\n\treturn mat4(2.0*z_near/vw,         \t   0,                           0,0,\n\t\t\t\t            0, 2.0*z_near/vh,                           0,0,\n\t\t\t\t            0,             0, \t     z_far/(z_far-z_near),1,\n\t\t\t\t            0,             0, z_near*z_far/(z_near-z_far),0);\n}\n\nmat4 lookAtLH(vec3 aUp, vec3 aFrom, vec3 aAt)\n{\n\tvec3 aX = vec3(0.0);\n\tvec3 aY = vec3(0.0);\n\n\tvec3 aZ = vec3(aAt.x,aAt.y,aAt.z);\n\taZ = normalize(aZ-aFrom);\n\n\taX = normalize(cross(aUp,aZ));\n\taY = cross(aZ,aX);\n\n\treturn mat4(          aX.x,           aY.x,           aZ.x,0,\n\t\t\t\t          aX.y,           aY.y,           aZ.y,0,\n\t\t\t\t          aX.z,           aY.z,           aZ.z,0,\n\t\t\t\t-dot(aFrom,aX), -dot(aFrom,aY), -dot(aFrom,aZ),1);\n}\n\nvec3 cube(vec2 world, mat4 proj, mat4 view, float time, vec3 p, vec3 s, float rotX, float rotY, float rotZ, vec3 cl)\n{\n\tvec3 col = vec3(0.0);\n\tvec4 pos = vec4(p,1.0);\n\n\tvec4 v1 = proj*view*((vec4(-1.0,-1.0,1.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v2 = proj*view*((vec4(1.0,-1.0,1.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v3 = proj*view*((vec4(1.0,1.0,1.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v4 = proj*view*((vec4(-1.0,1.0,1.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v5 = proj*view*((vec4(-1.0,-1.0,-1.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v6 = proj*view*((vec4(1.0,-1.0,-1.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v7 = proj*view*((vec4(1.0,1.0,-1.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v8 = proj*view*((vec4(-1.0,1.0,-1.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\n\tcol += cl*line(world,vec2(v1.x,v1.y),vec2(v2.x,v2.y),0.5);\n\tcol += cl*line(world,vec2(v2.x,v2.y),vec2(v3.x,v3.y),0.5);\n\tcol += cl*line(world,vec2(v3.x,v3.y),vec2(v4.x,v4.y),0.5);\n\tcol += cl*line(world,vec2(v4.x,v4.y),vec2(v1.x,v1.y),0.5);\n\tcol += cl*line(world,vec2(v5.x,v5.y),vec2(v6.x,v6.y),0.5);\n\tcol += cl*line(world,vec2(v6.x,v6.y),vec2(v7.x,v7.y),0.5);\n\tcol += cl*line(world,vec2(v7.x,v7.y),vec2(v8.x,v8.y),0.5);\n\tcol += cl*line(world,vec2(v8.x,v8.y),vec2(v5.x,v5.y),0.5);\n\n\tcol += cl*line(world,vec2(v8.x,v8.y),vec2(v4.x,v4.y),0.5);\n\tcol += cl*line(world,vec2(v7.x,v7.y),vec2(v3.x,v3.y),0.5);\n\tcol += cl*line(world,vec2(v5.x,v5.y),vec2(v1.x,v1.y),0.5);\n\tcol += cl*line(world,vec2(v6.x,v6.y),vec2(v2.x,v2.y),0.5);\n\n\treturn col;\n}\n\nvec3 airplane(vec2 world, mat4 proj, mat4 view, float time, vec3 p, vec3 s, float rotX, float rotY, float rotZ, vec3 cl)\n{\n\tvec3 col = vec3(0.0);\n\tvec4 pos = vec4(p,1.0);\n\n\tvec4 v1 = proj*view*((vec4(-0.215379,-0.018131,0.254635,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v2 = proj*view*((vec4(-0.130827,-0.030620,-0.229209,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v3 = proj*view*((vec4(-0.605928,0.226597,0.656825,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v4 = proj*view*((vec4(-0.457512,-0.151435,0.173292,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v5 = proj*view*((vec4(-0.301224,-0.276743,0.205711,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v6 = proj*view*((vec4(-0.762492,-0.313925,0.985007,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v7 = proj*view*((vec4(0.219197,-0.018172,0.253044,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v8 = proj*view*((vec4(0.605928,0.226597,0.656825,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v9 = proj*view*((vec4(0.134193,-0.030673,-0.229209,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v10 = proj*view*((vec4(0.457512,-0.151435,0.173292,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v11 = proj*view*((vec4(0.001113,0.122996,0.372016,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v12 = proj*view*((vec4(0.012398,0.313925,0.213513,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v13 = proj*view*((vec4(0.001113,-0.050108,-0.985007,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v14 = proj*view*((vec4(0.301224,-0.276743,0.205711,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v15 = proj*view*((vec4(0.762492,-0.313925,0.985007,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\n\tcol += cl*line(world,vec2(v2.x,v2.y),vec2(v3.x,v3.y),0.5);\n\tcol += cl*line(world,vec2(v2.x,v2.y),vec2(v12.x,v12.y),0.5);\n\n\tcol += cl*line(world,vec2(v3.x,v3.y),vec2(v4.x,v4.y),0.5);\n\tcol += cl*line(world,vec2(v4.x,v4.y),vec2(v5.x,v5.y),0.5);\n\tcol += cl*line(world,vec2(v4.x,v4.y),vec2(v6.x,v6.y),0.5);\n\tcol += cl*line(world,vec2(v6.x,v6.y),vec2(v5.x,v5.y),0.5);\n\tcol += cl*line(world,vec2(v5.x,v5.y),vec2(v13.x,v13.y),0.5);\n\n\tcol += cl*line(world,vec2(v8.x,v8.y),vec2(v9.x,v9.y),0.5);\n\tcol += cl*line(world,vec2(v8.x,v8.y),vec2(v10.x,v10.y),0.5);\n\tcol += cl*line(world,vec2(v10.x,v10.y),vec2(v15.x,v15.y),0.5);\n\tcol += cl*line(world,vec2(v10.x,v10.y),vec2(v14.x,v14.y),0.5);\n\n\tcol += cl*line(world,vec2(v2.x,v2.y),vec2(v13.x,v13.y),0.5);\n\tcol += cl*line(world,vec2(v4.x,v4.y),vec2(v13.x,v13.y),0.5);\t\t\t\n\tcol += cl*line(world,vec2(v9.x,v9.y),vec2(v13.x,v13.y),0.5);\n\tcol += cl*line(world,vec2(v10.x,v10.y),vec2(v13.x,v13.y),0.5);\n\n\tcol += cl*line(world,vec2(v3.x,v3.y),vec2(v12.x,v12.y),0.5);\t\t\t\t\n\tcol += cl*line(world,vec2(v8.x,v8.y),vec2(v12.x,v12.y),0.5);\n\n\tcol += cl*line(world,vec2(v12.x,v12.y),vec2(v11.x,v11.y),0.5);\n\n\tcol += cl*line(world,vec2(v11.x,v11.y),vec2(v3.x,v3.y),0.5);\n\tcol += cl*line(world,vec2(v11.x,v11.y),vec2(v8.x,v8.y),0.5);\n\n\tcol += cl*line(world,vec2(v11.x,v11.y),vec2(v7.x,v7.y),0.5);\n\tcol += cl*line(world,vec2(v11.x,v11.y),vec2(v1.x,v1.y),0.5);\n\n\tcol += cl*line(world,vec2(v9.x,v9.y),vec2(v12.x,v12.y),0.5);\n\n\tcol += cl*line(world,vec2(v8.x,v8.y),vec2(v7.x,v7.y),0.5);\n\tcol += cl*line(world,vec2(v3.x,v3.y),vec2(v1.x,v1.y),0.5);\n\n\tcol += cl*line(world,vec2(v1.x,v1.y),vec2(v6.x,v6.y),0.5);\n\tcol += cl*line(world,vec2(v7.x,v7.y),vec2(v15.x,v15.y),0.5);\n\n\tcol += cl*line(world,vec2(v12.x,v12.y),vec2(v13.x,v13.y),0.5);\n\tcol += cl*line(world,vec2(v13.x,v13.y),vec2(v14.x,v14.y),0.5);\n\tcol += cl*line(world,vec2(v14.x,v14.y),vec2(v15.x,v15.y),0.5);\n\n\treturn col;\n}\n\nvec3 mountain(vec2 world, mat4 proj, mat4 view, float time, vec3 p, vec3 s, float rotX, float rotY, float rotZ, vec3 cl)\n{\n\tvec3 col = vec3(0.0);\n\tfloat pi = 3.14159265358979;\n\n\tvec4 pos = vec4(p,1.0);\n\tvec4 v1 = proj*view*((vec4(1.0,0.0,0.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v2 = proj*view*((vec4(-1.0,0.0,0.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v3 = proj*view*((vec4(0.0,0.0,-2.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\tvec4 v4 = proj*view*((vec4(0.0,2.0,-1.0,1.0)-pos)*matRotateX(rotX)*matRotateY(rotY)*matRotateZ(rotZ)*scale(s));\n\n\tcol += cl*line(world,vec2(v1.x,v1.y),vec2(v2.x,v2.y),0.5);\n\tcol += cl*line(world,vec2(v2.x,v2.y),vec2(v3.x,v3.y),0.5);\n\tcol += cl*line(world,vec2(v3.x,v3.y),vec2(v1.x,v1.y),0.5);\n\tcol += cl*line(world,vec2(v1.x,v1.y),vec2(v4.x,v4.y),0.5);\n\tcol += cl*line(world,vec2(v2.x,v2.y),vec2(v4.x,v4.y),0.5);\n\tcol += cl*line(world,vec2(v3.x,v3.y),vec2(v4.x,v4.y),0.5);\n\treturn col;\n}\n\nvec3 _vUP = vec3(0, 1, 0);\nvec3 _vAT = vec3(0, -2, 0);\nvec3 _mEye = vec3(1, 0, 15);\nvec3 _mEyeA = vec3(0, 0, 20);\n\nfloat pi = atan(1.)*4.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t// set up world position\n\tvec2 worldCenter = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\tfloat cLength = length(worldCenter);\n\n\t// add post effect\n\tworldCenter += (worldCenter/cLength)*cos(cLength*12.0-iTime*4.0)*0.03; // ripple\n\n\tvec3 col = vec3(0.0);\n\n\t_mEyeA.xz = vec2(-cos(iTime*0.5)*200.,-sin(iTime*0.5)*200.);\n\t_mEyeA.y = 45.0;\n\n\t_mEye = _mEye*0.7;\n\t_mEye.x += _mEyeA.x * 0.5;\n\t_mEye.y += _mEyeA.y * 0.5;\n\t_mEye.z += _mEyeA.z * 0.5;\n\n\t// pipeline\n\tmat4 proj = perspectiveLH(1.0, 1.0, 0.12-(_mEyeA.x*0.0003), 1000.0);\n\tmat4 view = lookAtLH(_vUP, _mEye, _vAT);\n\n\tfloat loopZ = mod(iTime*3.0, 30.0);\n\tcol += airplane(worldCenter,proj,view,iTime,vec3(0.0,0.0,loopZ-15.0),vec3(1.8,1.8,1.8),0.0,0.0,sin(iTime*0.5),vec3(1.0,1.0,1.0));\n\n\tcol += cube(worldCenter,proj,view,iTime,vec3(6.0,0.0,0.0),vec3(1.2,1.2,1.2),iTime*.5-(pi/2.),0.0,0.0,vec3(1.0,1.0,1.0));\n\tcol += cube(worldCenter,proj,view,iTime,vec3(-4.0,0.0,6.0),vec3(1.2,2.2,1.2),0.0,0.0,0.0,vec3(1.0,1.0,1.0));\n\n\tcol += mountain(worldCenter,proj,view,iTime,vec3(4.0,0.0,9.0),vec3(2.2,1.2,1.2),0.0,0.0,0.0,vec3(1.0,1.0,1.0));\n\tcol += mountain(worldCenter,proj,view,iTime,vec3(-4.0,0.0,-6.5),vec3(2.2,2.1,1.2),0.0,0.0,0.0,vec3(1.0,1.0,1.0));\n\n\t// floor\n\tvec3 gridScale = vec3(3.5,3.5,3.5);\n\tfor(float i = -2.; i <= 2.; i ++)\n\t{\n\t\tvec4 t1 = proj*view*(vec4(-256.0*0.02,-64.0*0.02,i*128.0*0.02,1.0)*scale(gridScale));\n\t\tvec4 t2 = proj*view*(vec4(256.0*0.02,-64.0*0.02,i*128.0*0.02,1.0)*scale(gridScale));\n\t\tvec4 t3 = proj*view*(vec4(i*128.0*0.02,-64.0*0.02,-256.0*0.02,1.0)*scale(gridScale));\n\t\tvec4 t4 = proj*view*(vec4(i*128.0*0.02,-64.0*0.02,256.0*0.02,1.0)*scale(gridScale));\n\n\t\tcol += vec3(1.0,1.0,1.0)*line(worldCenter,vec2(t1.x,t1.y),vec2(t2.x,t2.y),0.5);\n\t\tcol += vec3(1.0,1.0,1.0)*line(worldCenter,vec2(t3.x,t3.y),vec2(t4.x,t4.y),0.5);\n\t}\n\n\t// if you don't want posteffect.\n\t//worldCenter = (gl_FragCoord.xy * 2.0 - iResolution) / min(iResolution.x, iResolution.y);\n\n\thud(worldCenter,vec2(-1.9+abs(sin(iTime*1.0)*0.57),0.85),0.03,vec3(1.0,1.0,1.0),col,1.0);\n\thud(worldCenter,vec2(-1.9+abs(sin(iTime*1.1)*0.57),0.75),0.03,vec3(1.0,1.0,1.0),col,1.1);\n\thud(worldCenter,vec2(-1.9+abs(sin(iTime*1.2)*0.57),0.65),0.03,vec3(1.0,1.0,1.0),col,1.2);\n\n\n\tfragColor = vec4(vec3(col), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lls3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 72, 72, 151], [153, 153, 222, 222, 325], [327, 327, 374, 374, 666], [668, 668, 746, 746, 873], [875, 875, 903, 903, 1027], [1029, 1029, 1057, 1057, 1185], [1187, 1187, 1215, 1215, 1336], [1338, 1338, 1362, 1362, 1432], [1434, 1434, 1454, 1454, 1542], [1544, 1544, 1611, 1611, 1882], [1884, 1884, 1931, 1931, 2321], [2323, 2323, 2441, 2441, 4136], [4138, 4138, 4260, 4260, 8131], [8133, 8133, 8255, 8255, 9161], [9302, 9302, 9359, 9385, 11632]], "test": "untested"}
{"id": "llS3zz", "name": "STYLE?5", "author": "Branch", "description": "STYLE?5", "tags": ["style5"], "likes": 1, "viewed": 1915, "published": "Public API", "date": "1426624173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float roundBox(vec2 coord, vec2 pos, vec2 b ){\n  return 1.-floor(length(max(abs(coord-pos)-b,0.0)));\n}\nmat2 rotate(float Angle)\n{\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nfloat box(vec2 coord, vec2 pos, vec2 size){\n\tif((coord.x<(pos.x+size.x)) &&\n\t   (coord.x>(pos.x-size.x)) &&\n\t   (coord.y<(pos.y+size.y)) && \n\t   (coord.y>(pos.y-size.y)) ) \n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat sun(vec2 coord, vec2 pos, float size){\n\tif(length(coord-pos)<size)\n\t\treturn 1.0;\n\treturn 0.0;\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat sign(vec2 p1, vec2 p2, vec2 p3){\n  return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\nfloat PIT(vec2 pt, vec2 v1, vec2 v2, vec2 v3){\n\tint b1, b2, b3;\n\n\tif(sign(pt, v1, v2) < 0.0) b1=1;\n\tif(sign(pt, v2, v3) < 0.0) b2=1;\n\tif(sign(pt, v3, v1) < 0.0) b3=1;\n\tif((b1 == b2) && (b2 == b3))\n\t\treturn 1.;\n\treturn 0.;\n}\nfloat arrow(vec2 coord, vec2 pos){\n\treturn box(coord, pos, vec2(.4,.1))+box(coord, pos+vec2(.3,-.3), vec2(.1,.4));\n}\nfloat guy(vec2 coord, vec2 pos){\n\tvec2 leftrotate=coord*rotate(0.7+sin(iTime*20.)*0.05);\n\tvec2 rightrotate=coord*rotate(-0.7+cos(iTime*20.)*0.05);\n\tfloat upndown=max(cos(iTime*7.+3.14)*0.1,0.);\n\tfloat random=sin(iTime*9.0)*0.01; //not really\n\treturn \tbox(coord, vec2(.2,-.34+upndown)+pos, vec2(.1,.2))+\n\t\t\tbox(coord, vec2(-.2,-.34+upndown)+pos, vec2(.1,.2))+\n\t\t\tbox(coord, vec2(0.,.2+upndown)+pos, vec2(.4,.3))+\n\t\t\tbox(leftrotate*vec2(1.), vec2(.55,.3+upndown*.5)+pos, vec2(.1,.2))+\n\t\t\tbox(rightrotate*vec2(1.), vec2(-.55,.3+upndown*.5)+pos, vec2(.1,.2))+\n\t\t\tbox(coord, vec2(0.,.75+upndown)+pos, vec2(.3,.2))-\n\t\t\tbox(coord, vec2(0.,.75+upndown)+pos, vec2(.2+random,.1+random))+\n\t\t\tbox(coord, vec2(.1,.78+upndown)+pos, vec2(.05+random,.05+random))+\n\t\t\tbox(coord, vec2(-.1,.78+upndown)+pos, vec2(.05-random,.05-random))+\n\t\t\tbox(coord, vec2(0.,.79+upndown*2.), vec2(.1,.12))+\n\t\t\tbox(coord, vec2(0.,.56+upndown*2.), vec2(.1,.045));\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tfloat t=mod(iTime,5.5);\n\tvec4 tulos;\n\tvec4 lopullinentulos=vec4(1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * uv - 1.0;\n\tvec2 c = vec2(aspectCorrection,1.0) *coordinate_entered;\n\tvec2 coord = c;\n\tcoord*=sin(iTime*2.435)*.2+1.2;\n\ttulos=vec4(1.0);\n\ttulos-=guy(coord,vec2(0.,-.5))*4.;\n\tif(mod(fragCoord.y,2.0)<1.0)   /////////////////////////\n\ttulos=tulos/1.3;\n\tfloat vignette = min(max(1.4 / (1.25 + 0.28*dot(c, c)),0.),1.);\n\tfragColor =tulos*vignette-0.01+rand(c*t)*0.02;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llS3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 102], [103, 103, 129, 129, 261], [262, 262, 305, 305, 463], [464, 464, 508, 508, 565], [566, 566, 586, 586, 658], [659, 659, 697, 697, 771], [772, 772, 818, 818, 995], [996, 996, 1030, 1030, 1112], [1113, 1113, 1145, 1145, 2043], [2044, 2044, 2100, 2100, 2666]], "test": "untested"}
{"id": "llSGR1", "name": "Galaxy spirals", "author": "guil", "description": "Use mouse to modify the number of arms or the winding number \nGalaxy morphology based on http://iopscience.iop.org/0004-637X/783/2/138/pdf/0004-637X_783_2_138.pdf", "tags": ["noise", "galaxy"], "likes": 23, "viewed": 1660, "published": "Public", "date": "1426847713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte\n// Galaxy morphology based on http://iopscience.iop.org/0004-637X/783/2/138/pdf/0004-637X_783_2_138.pdf\n\n\nint windows = 0;\nvec2 m = vec2(2.,6.);\nconst float pi = 3.141592;\n\nconst mat2 m2 = mat2(.8,.6,-.6,.8);\n\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=2.;\n\tfor( int i=0; i< 4; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.0;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/4.;\n}\n\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(noise( p*f ))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.08)*r;\n\t}\n\treturn r;\n}\n\nfloat fbmstars( vec2 p ) {\n    \n    p=floor(p*50.)/50.;\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<5;i++){\t\n\t\tr += noise( p*(20.+3.*f) )/f; \n        p*=m2;\n\t    f +=1.;\n        \n\t}\n\treturn pow(r,8.);\n}\n\nfloat fbmdisk( vec2 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<7;i++){\t\n\t\tr += abs(noise( p*(f) ))/f;       \n\t    f +=1.;\n        \n\t}\n\treturn 1./r;\n}\n\n\nfloat fbmdust( vec2 p ) {\n\t\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 1;i<7;i++){\t\n\t\tr += 1./abs(noise( p*(f) ))/f;       \n\t    f +=1.;\n        \n\t}\n\treturn pow(1.-1./r,4.);\n}\n\n\nfloat theta(float r, float wb, float wn){\n\treturn atan(exp(1./r)/wb)*2.*wn;\n}\n\nfloat arm(float n, float aw, float wb, float wn,vec2 p){\n    float t = atan(p.y,p.x);\n    float r = length(p);    \n\treturn pow(1.-.15*sin((theta(r,wb,wn)-t)*n),aw)*exp(-r*r)*exp(-.07/r);\n}\n\nvec2 maparm(float n, float aw, float wb, float wn,vec2 p){\n    float t = atan(p.y,p.x);\n    float r = length(p);\n    \n\treturn vec2((theta(r,wb,wn)-t)*n,r);\n}\n\nfloat bulb(vec2 p){\n    float r = exp(-dot(p,p)*1.2);\n    p.y-=.2;\n\treturn r+.5*exp(-dot(p,p)*12.);\n}\n\nfloat map(vec2 p){\n\n    \n    float a= arm(m.x,6.,.7,m.y,p);\n    float d = fbmdust(p);\n    float r = max(a*(.4+.1*arm(m.x+1.,4.,.7,m.y,p*m2))*(.1+.6*d+.4*fbmdisk(p)),bulb(p)*(.7+.2*d+.2*fbmabs(p)));\n    return max(r, a*fbmstars(p*4.));\n}\n\n\nvec2 rotate(in vec2 p, in float t)\n{\n\treturn p * cos(-t) + vec2(p.y, -p.x) * sin(-t);\n}\n\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 p = 2.*fragCoord.xy /iResolution.xy-1.;\n    p*=2.;\n\tif(p.y>0.){\n    \tif(p.x>0.)windows =1;\n    \telse    windows =0;}\n    else{\n    \tif(p.x>0.)windows =3;\n        else windows =2;}\n    \n    \n    p = rotate(p,-.02*iTime);\n    \n    if(iMouse.z>0.)m = floor(iMouse.xy/iResolution.xy*10.);\n    m.y*=2.;\n    \n\tfloat r;\n    vec3 light = normalize(vec3(4., 2., -1.));\n\n    float k=1.5*map(p);\n    float b=.3*map(p*m2)+.4;\n    r=.2;\n   \n\tfragColor = clamp(vec4(r*k*k, r*k, k*.5+b*.4, 1.0),0.,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSGR1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 324, 347, 347, 522], [525, 525, 549, 549, 706], [708, 708, 734, 734, 921], [923, 923, 948, 948, 1090], [1093, 1093, 1118, 1118, 1274], [1277, 1277, 1318, 1318, 1354], [1356, 1356, 1412, 1412, 1544], [1546, 1546, 1604, 1604, 1703], [1705, 1705, 1724, 1724, 1806], [1808, 1808, 1826, 1826, 2044], [2047, 2047, 2083, 2083, 2134], [2138, 2138, 2195, 2195, 2693]], "test": "untested"}
{"id": "llSGRw", "name": "Mercury craters", "author": "guil", "description": "A variant of my previous shader optimized for performance", "tags": ["3d", "voronoi"], "likes": 17, "viewed": 287, "published": "Public", "date": "1427547334", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte\n\n#define PI 3.14159265358979\n\nint windows = 3;//0=noise,1=abs(noise),2=fbm,3=fbmabs\n\n\nfloat hash( in vec3 p ) \n{\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\n}\n\nvec3 hash3( in vec3 p )\n{\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\n}\n\n\n\nfloat voronoi(in vec3 p)\n{    \n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n\tfloat rid = -1.;\n    vec2 r = vec2(2.);\n    for (int i=-1; i<=0; i++) \n\tfor (int j=-1; j<=0; j++) \n\tfor (int k=-1; k<=0; k++) \n\t{\n\t\tvec3 g = vec3(i, j, k);\n        //float h = hash(ip - g);\n        vec3 pp = fp +g +hash3(ip - g)*.6;\n        float d = dot(pp, pp);\n\n        if (d < r.x)\n\t\t{\n            r.y = r.x;\n            r.x = d;\n           // rid = h +.5;\n\t\t}\n        else if(d < r.y)\n\t\t{\n    \t\tr.y = d;\n\t\t}\n\t}    \n    return r.x;\n}\n\nfloat craters(vec3 p){\n    float v = voronoi(p);\n    return sin(sqrt(v)*PI*2.)*exp(-4.*v);\n}\n\nfloat stars(vec3 p){\n    float v = voronoi(p);\n    return pow(exp(.1-5.*v),18.);\n}\n  \n\nfloat fbmabs( vec3 p ) {\n\t\n\tfloat f=1.2;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<5;i++){\t\n\t\tr += abs(craters( p*f ))/f;       \n\t    f *=2.7;\n\t}\n\treturn r/2.;\n}\n\nfloat fbm( vec3 p ) {\n\t\n\tfloat f=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<3;i++){\t\n\t\tr += stars( p*f )/f;       \n\t    f *=2.;\n\t}\n\treturn r/4.;\n}\n\nfloat map(vec3 p){\n\n    \n    return 1.2*fbmabs(p);\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.00001, 0.0);\n\treturn normalize(p*.00004+vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = vec3(4.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time+1.);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\tvec3 li = normalize(vec3(0.5, .8, 3.0));\n    \n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,1.5) );\n\n\tfloat c;\n    \n   \tif (tmm.x<0.)c =  fbm(30.*rd)+fbm(40.*rd)+.2*exp(-64.*(.9-dot(li,rd)));\n    else c= map(ro+rd*tmm.x)/2.;\n    vec3 col = vec3( c*c*1.3,c*c,c*.5);\n    if (tmm.x>0.){\n        \n        float k = dot(ro+rd*tmm.x, li);\n        col*=.4;\n        if(k>0.){\n            \n    \t\tvec3 nor = calcNormal(ro+rd*tmm.x);\n            col += pow(max(dot(li, nor)*1.2, 0.05), .75)*k*vec3(.95,.55,.4);\n        }\n    }\n\t\n\t// shade\n    \n    //col =  1.5 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n}\n\t\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSGRw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[159, 199, 225, 225, 327], [329, 329, 354, 354, 406], [410, 410, 436, 436, 927], [929, 929, 951, 951, 1021], [1023, 1023, 1043, 1043, 1105], [1110, 1110, 1134, 1134, 1270], [1272, 1272, 1293, 1293, 1420], [1422, 1422, 1440, 1440, 1474], [1476, 1476, 1504, 1504, 1682], [1685, 1685, 1704, 1704, 1751], [1753, 1753, 1815, 1815, 2001], [2003, 2003, 2060, 2060, 3232]], "test": "untested"}
{"id": "llsGWl", "name": "Gavoronoise", "author": "guil", "description": "Inspired by Gabor 4: normalized (https://www.shadertoy.com/view/XlsGDs) and\nVoronoise (https://www.shadertoy.com/view/Xd23Dh)\nAn attempt to mix them. Use mouse to change wave direction", "tags": ["voronoi", "noise", "gabor"], "likes": 67, "viewed": 1813, "published": "Public", "date": "1426253841", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte\n//Based on Voronoise by iq :https://www.shadertoy.com/view/Xd23Dh\n//and Gabor 4: normalized  by FabriceNeyret2 : https://www.shadertoy.com/view/XlsGDs\n\n#define PI 3.14159265358979\n\nint windows = 0;\nvec2 m = vec2(.7,.8);\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*5.78) * 43758.236237153);\n}\n\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\nvec2 hash2b( vec2 p )\n{\n    vec2 q = vec2( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(q)*43758.5453)-.5;\n}\n\n\nmat2 m2= mat2(.8,.6,-.6,.8);\n\n// Gabor/Voronoi mix 3x3 kernel (some artifacts for v=1.)\nfloat gavoronoi3(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float f = 2.*PI;//frequency\n    float v = .8;//cell variability <1.\n    float dv = .4;//direction variability <1.\n    vec2 dir = m;//vec2(.7,.7);\n    float va = 0.0;\n   \tfloat wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j)-.5;\n        vec2 h = hash2(ip - o);\n        vec2 pp = fp +o  -h;\n        float d = dot(pp, pp);\n        float w = exp(-d*4.);\n        wt +=w;\n        h = dv*h+dir;//h=normalize(h+dir);\n        va += cos(dot(pp,h)*f/v)*w;\n\t}    \n    return va/wt;\n}\n\n\n// Gabor/Voronoi mix 4x4 kernel (clean but slower)\nfloat gavoronoi4(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    vec2 dir = m;// vec2(.9,.7);\n    float f = 2.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\n    float v = 1.;//cell variability <1.\n    float dv = .7;//direction variability <1.\n    float va = 0.0;\n   \tfloat wt = 0.0;\n    for (int i=-2; i<=1; i++) \n\tfor (int j=-2; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j);\n        vec2 h = hash2(ip - o);\n        vec2 pp = fp +o  -v*h;\n        float d = dot(pp, pp);\n        float w = exp(-d*2.);\n        wt +=w;\n      \th= dv*h+dir;//h=normalize(h+dir);\n        va +=cos(dot(pp,h)*f)*w;\n\t}    \n    return va/wt;\n}\n\n// Gabor/Voronoi mix 5x5 kernel (even slower but suitable for large wavelets)\nfloat gavoronoi5(in vec2 p) \n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float f = 2.*PI;//frequency\n    float v = .8;//cell variability <1.\n    float dv = .8;//direction variability <1.\n    vec2 dir = m;//vec2(.7,.7);\n    float va = 0.0;\n   \tfloat wt = 0.0;\n    for (int i=-2; i<=2; i++) \n\tfor (int j=-2; j<=2; j++) \n\t{\t\t\n        vec2 o = vec2(i, j)-.5;\n        vec2 h = hash2(ip - o);\n        vec2 pp = fp +o  -h;\n        float d = dot(pp, pp);\n        float w = exp(-d*1.);\n        wt +=w;\n        h = dv*h+dir;//h=normalize(h+dir);\n        va += cos(dot(pp,h)*f/v)*w;\n\t}    \n    return va/wt;\n}\n\n  \n\n//concentric waves variant\nfloat gavoronoi3b(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float f = 5.*PI;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t;//frequency\n    float v = 1.;//cell variability <1.\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j)-.5;       \t\t\n        vec2 pp = fp +o  - v*hash2(ip - o);\n        float d = dot(pp, pp);\n        float w = exp(-d*4.);\n        wt +=w;\n        va +=cos(sqrt(d)*f)*w;\n\t}    \n    return va/wt;\n}\n\n\n\nfloat noise( vec2 p)\n{   \n    return gavoronoi4(p);\n}\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<6;i++){\t\n\t\tr += abs(noise( p*f ))/f;       \n\t    f *=2.2;\n        p+=vec2(-.01,.07)*r+.2*m*iTime/(.1-f);\n\t}\n\treturn r;\n}\n\nfloat fbm( vec2 p ) {\n\t\n\tfloat f=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += noise( p*f )/f;       \n\t    f *=2.;\n        p+=vec2(.01,-.05)*r+.2*m*iTime/(.1-f);\n\t}\n\treturn r;\n}\n\nfloat map(vec2 p){\n\n    if(windows==0)return noise(p*10.);\n    if(windows==1)return 2.*abs( noise(p*10.));\n\tif(windows==2)return fbm(p)+1.;\n    return 1.-fbmabs(p);\n}\n\nvec3 nor(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn -normalize(vec3(\n\t\tmap(p + e.xy) - map(p - e.xy),\n\t\tmap(p + e.yx) - map(p - e.yx),\n\t\t.15));\n}\n\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 p = 2.*fragCoord.xy /iResolution.xy-1.;\n    \n\tif(p.y>0.){\n    \tif(p.x>0.)windows =1;\n    \telse    windows =0;}\n    else{\n    \tif(p.x>0.)windows =3;\n        else windows =2;}\n    //comment the following line to see windows\n    windows =3;\n    \n      \n    if(iMouse.z>0.)m = 2.*iMouse.xy/iResolution.xy-1.;\n   \tp += .2*m*iTime;\n    vec3 light = normalize(vec3(3., 2., -1.));\n\tfloat r;\n    r = max(dot(nor(p), light),0.25);\n    float k=map(p)*.8+.15;\n    fragColor = clamp(vec4(r, r, r, 1.0),0.,1.);\n\tfragColor = clamp(vec4(r*k*k, r*k, r*sqrt(k), 1.0),0.,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llsGWl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 334, 360, 360, 423], [426, 426, 446, 446, 504], [506, 506, 529, 529, 649], [682, 740, 769, 769, 1351], [1354, 1405, 1434, 1434, 2054], [2056, 2134, 2164, 2164, 2746], [2752, 2779, 2809, 2809, 3300], [3304, 3304, 3326, 3326, 3357], [3359, 3359, 3383, 3383, 3560], [3562, 3562, 3583, 3583, 3754], [3756, 3756, 3774, 3774, 3922], [3924, 3924, 3945, 3945, 4081], [4085, 4085, 4142, 4142, 4709]], "test": "untested"}
{"id": "llSGzW", "name": "ngWaves0E", "author": "netgrind", "description": "mouse x for cybertek dither", "tags": ["waves", "plasma", "blackandwhite", "shadeaday", "netgrind"], "likes": 9, "viewed": 1398, "published": "Public API", "date": "1427186144", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.0-1.0; \n    vec4 c = vec4(1.0);\n    float d = length(uv);\n    float a = atan(uv.y,uv.x)+sin(i*.2)*.5;\n    uv.x = cos(a)*d;\n    uv.y = sin(a)*d;\n\n    d-=i;\n    uv.x+=sin(uv.y*2.+i)*.1;    \n    uv += sin(uv*1234.567+i)*iMouse.x*.0005;\n    c.r = abs(mod(uv.y+uv.x*2.*d,uv.x*1.1));\n    \n\tfragColor = c.rrra;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSGzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 427]], "test": "untested"}
{"id": "llSGzz", "name": "shadeaday ( 3 / 17 / 2015 )", "author": "cabbibo", "description": "Un modding  yesterdays.", "tags": ["glsl"], "likes": 1, "viewed": 148, "published": "Public", "date": "1426621364", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 40;\n\t\nvec4 spherePos[20];\n  \n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 noiseVec( vec3 p ){\n    \n    float x = rand( p.xy );\n    float y = rand( p.yz);\n    float z = rand( p.zx );\n \n    return normalize(normalize(vec3( x , y , z )) - vec3( .5 ));\n    \n}\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p )\n{\n    \n    float f = sin( p.z * 5. ) * sin( p.x * 5. );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y - (abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdNoiseSphere( vec3 p, float s )\n{\n  return length(p)-( s * (1.3 + .3 * triNoise3D( p * .2, 1. ) ));\n}\n\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    //pos = mod( pos + .5 , 1. ) - .5 ;\n   \tvec2 res = vec2( 10000. , 0.);// vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    \n    for( int i = 0; i < 20; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , .2 ) ,  .1);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n    vec2 res2 = vec2( sdNoiseSphere( (pos) , .6 ) , 3.);\n    \n    res = opU( res , res2 );\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    for( int i =0; i < 20; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n        \n        vec3  p = vec3( x , y , z );\n        p = normalize( p ) * 1.3;\n        \n    \tspherePos[i] = vec4( p.x ,  p.y ,  p.z , .2  );\n        \n        \n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n    vec3 lightPos = vec3( 2. , 1. , 0. );\n    \n    vec3 col = vec3( 0. );//vec3( .8 , .8 , .8 ); \n   \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n        vec3 pos = ro + rd * res.x;\n        vec3 nor = calcNormal( pos );\n\n        vec3 lightDir = lightPos - pos;\n        lightDir = normalize( lightDir );\n        \n        vec3 lightRefl = reflect( lightDir , nor );\n        float reflMatch = pow( max( 0. , dot( rd , lightRefl )) , 10. );\n        \n\n\n        float AO = calcAO( pos , nor );\n\n        float match = max( 0. , dot( nor , lightDir ));\n        \n        float rim = pow( 1. - max( 0. , dot( -nor , rd ) ) , 5.);\n\n        if( res.y < 2. ){\n    \n           // float c = pow(( 1.-AO) , 5.)*  10.;\n            float c = 0.;\n            //c += pow((1.- match),4.) * 1.;\n            c += pow(( 1.-AO) , 5.)*  2.;\n           // col = vec3( c );// * .4 * ( nor * .5 + .5 );\n\n           // col = hsv( c ,1.,1.) * c;\n            col += vec3( 1. , .2 , 0.6 ) * pow(( 1.-AO) , 2.); \n            col += vec3( 1. , .8, .2 ) * rim;\n            col += vec3( .3 , .5 , 1. ) * reflMatch;\n            \n            //* pow( match , 3.) * hsv(abs(sin(match*1.)) , 1. , 1. );\n            //col += pow( shinyMatch , 5. ) * hsv(abs(sin(shinyMatch*10.)) , 1. , 1. );\n        }else{\n          \n        \tvec3 refl = normalize( reflect( rd , nor ));\n            \n            vec3 ro2 = pos + refl * .01;\n            vec3 rd2 = refl;\n            \n            vec2 res2 = calcIntersection( ro2 , rd2  );\n            \n            col += vec3( 1. , .8 , .2 ) * rim;\n            \n            if( res2.y > -.5 ){\n                \n                \n                \n\n                vec3 pos2 = ro2 + rd2 * res2.x;\n        \t\tvec3 nor2 = calcNormal( pos2 );\n\n                vec3 lightDir = lightPos - pos2;\n                lightDir = normalize( lightDir );\n\n                vec3 lightRefl = reflect( lightDir , nor2 );\n                float reflMatch = pow( max( 0. , dot( rd2 , lightRefl )) , 10. );\n                \n                float AO = calcAO( pos2 , nor2 );\n                col += vec3( 1. , .2 , .6 ) * pow(( 1.-AO) , 2.); \n                \n                float r2 = pow( 1. - max( 0. , dot( -nor2 , rd2 ) ) , 5.);\n                col += vec3( 1. , .8 , .2 ) * r2;\n                \n                col += vec3( .3 , .5 , 1. ) * reflMatch;\n            \n            }\n            \n          \n            \n        }\n        //col = vec3( shinyMatch );\n       /* if( res.y < .5 ){\n            \n            float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n            col *= abs( f );\n            col /= pow( length( pos ), 4.);\n        }*/\n    }\n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llSGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 405, 427, 427, 452], [453, 453, 474, 474, 554], [590, 642, 685, 685, 988], [990, 990, 1027, 1027, 1159], [1161, 1161, 1181, 1181, 1253], [1255, 1255, 1279, 1279, 1441], [1443, 1443, 1508, 1508, 1692], [1695, 1695, 1740, 1740, 1780], [1782, 1782, 1807, 1807, 1977], [1981, 1981, 2016, 2016, 2040], [2043, 2043, 2083, 2083, 2151], [2154, 2154, 2192, 2192, 2363], [2365, 2396, 2460, 2460, 2638], [2640, 2640, 2723, 2723, 2836], [2841, 2935, 2964, 2964, 3007], [3009, 3045, 3086, 3086, 3157], [3159, 3159, 3194, 3194, 3233], [3234, 3318, 3339, 3386, 3909], [3913, 3913, 3961, 3961, 4428], [4430, 4543, 4574, 4574, 4800], [4803, 4803, 4877, 4877, 5138], [5141, 5141, 5183, 5183, 5482], [5485, 5485, 5541, 5541, 9416]], "test": "untested"}
{"id": "llX3D2", "name": "tapestry fract", "author": "echophon", "description": "learning shadeaday - experimenting with the dot command", "tags": ["2d", "fractal"], "likes": 13, "viewed": 297, "published": "Public", "date": "1425192723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// edit of http://glslsandbox.com/e#18752.0\nuniform vec2 mouse;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float gTime = iTime*0.5;\n\tfloat f = 3., g = 3.;\n\tvec2 res = iResolution.xy;\n\tvec2 mou = mouse.xy;\n\t\n\t//if (mouse.x < 0.5)\n\t//{\n\tmou.x = sin(gTime * .3)*sin(gTime * .17) * 1. + sin(gTime * .3);\n\tmou.y = (1.0-cos(gTime * .632))*sin(gTime * .131)*1.0+cos(gTime * .3);\n\tmou = (mou+1.0) * res;\n\t//}\n\tvec2 z = ((-res+2.0 * fragCoord.xy) / res.y);\n\tvec2 p = ((-res+2.0+mou) / res.y);\n\tfor( int i = 0; i < 15; i++) \n\t{\n\t\tfloat d = dot(z,z);\n\t\tz = (vec2( z.x, -z.y ) / d) + p; \n\t\tz.x =  1.0-abs(z.x);\n\t\tf = max( f-d, (dot(z-p,z-p) ));\n\t\tg = min( g*d, sin(dot(z+p,z+p))+1.0);\n\t}\n\tf = abs(-log(f) / 3.5);\n\tg = abs(-log(g) / 8.0);\n\tfragColor = vec4(min(vec3(g, g*f, f), 1.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llX3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 65, 122, 122, 797]], "test": "untested"}
{"id": "llX3Wj", "name": "Voronoi Experiment 4.", "author": "aiekick", "description": "Vorono Experiment 4", "tags": ["voronoi", "experiment4"], "likes": 4, "viewed": 1149, "published": "Public API", "date": "1427549912", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 s = iResolution.xy;\n\tvec2 uv = (2.*fragCoord.xy-s)/s.y;\n    \n    float coef = 12.;\n    \n    if ( iMouse.z>0. ) coef = iMouse.y/iResolution.y * coef;\n    \n    // voronoi\n    vec2 c0 = vec2(30.,20.);\n    vec2 c1 = vec2(10.,40.);\n    vec2 x = uv*coef;\n    vec2 n = floor(x);\n    vec2 f = fract(x);\n    vec2 mr;\n    float md = 5.;\n    float d;\n    for( int j=-1; j<=1; j++ )\n    {\n        for( int i=-1; i<=1; i++ )\n        {\n            vec2 g=vec2(float(i),float(j));\n            \n            // hash\n            vec2 ng = n+g;\n            float ng0 = dot(ng,c0);\n            float ng1 = dot(ng,c1);\n            vec2 ng01 = vec2(ng0,ng1);\n            vec2 hash = fract(cos(ng01)*iTime*0.2);\n            \n            vec2 o = 0.5+0.5*sin(6.2831*hash);//animated\n            \n            vec2 r = g+o-f;\n            \n            d = dot(r,r);\n            \n            if( d<md ) \n            {\n                md=d;\n                mr=r;;\n            } \n        }\n    }\n    vec3 voro = /*normalize*/(vec3(md, mr));\n    \n    // col    \n    vec3 col = voro.xzz;\n    \n   \tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llX3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1160]], "test": "untested"}
{"id": "llXGWj", "name": "Sierpinski ...", "author": "gabgoh", "description": "Sierpinski Triangle", "tags": ["fractal"], "likes": 2, "viewed": 225, "published": "Public", "date": "1425167249", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform struct points { vec2 p[4]; };\n    \nstruct ind_dist { vec2 v; float dist; };\n\nind_dist get_nearest(points p, vec2 uv)\n{\n    \n    float minval = 1e10;\n    vec2  v;\n    for (int i = 0; i < 4; i ++) {\n        float d = distance(uv, p.p[i]);\n        minval = min(d,minval);\n        if (minval == d) {\n            v = p.p[i];\n        }\n    }\n    \n    ind_dist o;\n    o.v = v;\n    o.dist  = minval;\n\treturn o;\n}\n    \nfloat ani(float iTime){\n    return abs(sin(1.0*iTime));\n}\n\nvec2 getuv(float scale, vec2 uv) {\n    // Get Normalized UV Coordinates\n\tuv = (uv - 0.5);\n   \tuv[0] = 1.8*uv[0];\n    uv = scale*uv; \n    return uv;\n}\n\nvec2 sphereinv(vec2 x, float r){\n    return r*x/(x[0]*x[0] + x[1]*x[1]);\n}\n\nmat2 rotate_mat(float theta) {\n    // 2x2 Rotation Matrix\n    return mat2( cos( theta ), -sin( theta ),\n                 sin( theta ),  cos( theta ));    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    float t = iTime;\n    \n    points p;\n    p.p[0] = vec2( 0.0,  2.0 );\n    p.p[1] = vec2( 2.0 , 0.0);\n    p.p[2] = vec2( -2.0, 0.0);\n    p.p[3] = vec2( 0.0, -2.0);\n    \n    vec2 uv = getuv(0.2 + mod(-0.2*t,0.2),fragCoord.xy / iResolution.xy);\n    \n\tind_dist I;\n    const int iters = 20;\n    \n    float depth = 0.0;\n    for (int i = 0; i < iters; i++) {\n        I = get_nearest(p, uv);\n        vec2 closest_pt = I.v;\n        uv = (2.0)*(uv - closest_pt) + closest_pt;\n        if (length(uv) < 1.2 + 0.5*ani(1.0*t)){\n            uv = sphereinv(uv,1.0);\n    \t}\n        depth = depth + I.dist;\n    }\n    \n    float minval = I.dist/pow(2.0,float(iters));\n    \n    depth = depth/pow(2.0,float(iters-10));\n    \n    float r; float g; float b;\n\t\n    r = smoothstep(0.0,5.0 - mod(t,2.0),depth);\n    g = smoothstep(0.0,5.0 - mod(t,2.0),depth);\n    b = smoothstep(0.0,5.0 - mod(t,2.0),depth);\n\n    \n    fragColor = vec4(r,g,b,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llXGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[85, 85, 126, 126, 412], [418, 418, 441, 441, 475], [477, 477, 511, 548, 626], [628, 628, 660, 660, 702], [704, 704, 734, 761, 860], [862, 862, 919, 919, 1849]], "test": "untested"}
{"id": "lt23z1", "name": "ngWaves0D", "author": "netgrind", "description": "plasm", "tags": ["waves", "plasma", "netgrind"], "likes": 5, "viewed": 1224, "published": "Public API", "date": "1427066479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\nvec4 hue(vec4 color, float shift) {\n\n    const vec4  kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n    const vec4  kRGBToI     = vec4 (0.596, -0.275, -0.321, 0.0);\n    const vec4  kRGBToQ     = vec4 (0.212, -0.523, 0.311, 0.0);\n\n    const vec4  kYIQToR   = vec4 (1.0, 0.956, 0.621, 0.0);\n    const vec4  kYIQToG   = vec4 (1.0, -0.272, -0.647, 0.0);\n    const vec4  kYIQToB   = vec4 (1.0, -1.107, 1.704, 0.0);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec4    yIQ   = vec4 (YPrime, I, Q, 0.0);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i = iTime;\n    float scale = 4.0;\n\tvec2 uv = fragCoord.xy / iResolution.yy*scale-scale*.5;\n    vec4 c = vec4(1.0);\n    float a = atan(uv.y,uv.x);\n    mat2 m = mat2(sin(a+PI*.75),cos(a+sin(i*.2)-1.),-sin(a+PI),cos(a));\n    uv*=m;   \n    \n    float d = length(uv);    \n    a+=+sin(d*4.-i*2.)*.4;\n    a+= (iMouse.y/iResolution.y)*5.;\n    d+= sin(a*6.0+i)*d;\n    \n    c.g = mod(d*.5-i,1.0);\n    c.g -= mod(c.g,.5);\n    c.r = mod(a/PI*6.0,1.0);\n    c.r -= mod(c.r,.5);\n    c.b = length(c.rg);\n    c.rgb +=.5;\n    c.rgb = mix(vec3(0.), c.rgb, clamp(d+sin(a*4.0+i)*.1-.3,0.0,1.0));\n\tfragColor = hue(c,2.0+iMouse.x*.01);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt23z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 54, 54, 1038], [1040, 1040, 1097, 1097, 1722]], "test": "untested"}
{"id": "lt23zh", "name": "ngWaves0C", "author": "netgrind", "description": "rad plasma\nmouse x for moire", "tags": ["waves", "plasma", "netgrind"], "likes": 9, "viewed": 1377, "published": "Public API", "date": "1427008157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i = iTime*.5;\n    float scale = 5.0;\n\tvec2 uv = fragCoord.xy / iResolution.xy*scale-scale*.5;\n    uv.y = abs(uv.y);\n    float d = length(uv+vec2(sin(i),cos(i)));\n    vec4 c = vec4(1.0);\n    float bloom = .1*d;\n    c.rgb -= vec3(bloom,bloom*2.0,bloom*3.0);\n    mat2 m = mat2(\n        sin(uv.x+i),\n        cos(i+uv.y+uv.x),\n        sin(cos(uv.y*d+i)*uv.x),\n        -cos(uv.y*sin(uv.x+i+d))\n        );\n        \n    for(float j = 0.0; j<5.0;j+=.5){\n        uv*=m;\n        uv = sin(uv+i);\n        m[0,0] =sin(m[0,0]+10.);\n        m[1,0] += (d*j*.2);\n    }\n    \n    c.rgb = sin(i+c.rgb*uv.x+sin(uv.y+i))*PI*(2.0+iMouse.x*.1);\n    c.r = sin(c.r)*.5+.5;\n    c.g = sin(c.g)*.5+.5;\n    c.b = sin(c.b)*.5+.5;\n    \n    c.rgb*=min(1.0,1.5-d/scale*2.0);\n    \n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt23zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 76, 76, 849]], "test": "untested"}
{"id": "lt23zW", "name": "maggots - shadeADay", "author": "kig", "description": "Doing some simple stuff again. #shadeADay for 2015-03-26", "tags": ["raytrace", "shadeaday"], "likes": 5, "viewed": 190, "published": "Public", "date": "1427375406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphereDet(vec3 ray, vec3 dir, vec3 center, float radius, inout float b)\n{\n\tvec3 rc = ray-center;  // 1\n\tfloat c = dot(rc, rc); // 1\n\tc -= radius*radius;    // 2?\n\tb = dot(dir, rc);      // 1\n\treturn b*b - c;        // 2?\n}\n\nfloat sphere(vec3 ray, vec3 dir, vec3 center, float radius, float closestHit, inout vec3 nml)\n{\n\tfloat b;\n\tfloat d = sphereDet(ray, dir, center, radius, b); // 7\n\tif (d < 0.0) { // 1\n\t\treturn closestHit;\n\t}\n\tfloat t = -b - sqrt(d); // 3\n\tif (t > 0.0 && t < closestHit) { // 2\n        nml = center - (ray+dir*t);\n\t} else {\n\t\tt = closestHit;\n\t}\n    return t;\n}\n\nfloat square(float x) { return x*x; }\n\nvoid bg( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(iResolution.x/iResolution.y,1.0) * (-1.0 + 2.0*fragCoord.xy / iResolution.xy);\n   \n    vec2 ouv = uv;\n    \n    float a = sin(iTime*0.5)*0.2;\n    float ca = cos(a);\n    float sa = sin(a);\n    \n    uv *= mat2(ca, sa, -sa, ca);\n\n    float df = abs(uv.y*uv.y-1.3)*uv.x*uv.x;\n    uv *= 3.0+1.9*df;\n    uv.x += iTime*2.0;\n    uv.y += iTime*2.0;\n    \n    uv *= 2.0;\n\n    uv.x = pow(sin(uv.y+iTime*2.0) * cos(uv.y*0.5) * cos(uv.x*0.5+2.0), 4.0);\n    uv.y = abs(cos(uv.x*12.0) * sin(uv.y*0.25+3.14159*0.5));\n\n    uv = pow(uv, vec2(1.0, 4.0));\n    \n\tfragColor = vec4(uv.x+uv.x+0.25, 0.05+uv.y+uv.x, 0.15+uv.y, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bg(fragColor, fragCoord);\n\tvec2 uv = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -3.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    float t0 = iTime*1.2;\n    float t1 = iTime*2.32;\n    float closest = 1e9;\n    for (int i=0; i<20; i++) {\n        vec3 p = vec3(sin(float(i)+t0), cos(float(i)+t1), sin(t0)+sin(t1+float(i)));\n\t\tvec3 rc = ro-p;\n        float c = dot(rc, rc);\n        c -= square(0.1+abs(sin(float(i)))*0.5);\n        float b = dot(rd, rc);\n        float d = b*b - c;\n        float t = -b - sqrt(d);\n        if (d >= 0.0 && t > 0.0 && t < closest) {\n            vec3 nml = normalize(p-(ro+rd*t));\n            vec3 nrd = reflect(rd, nml);\n            bg(fragColor, (nrd.xy/nrd.z)*10.0);\n            fragColor.rgb = fragColor.rgb*0.15 + nml;\n            closest = t;\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt23zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 79, 79, 228], [230, 230, 325, 325, 588], [590, 590, 613, 613, 627], [629, 629, 679, 679, 1303], [1305, 1305, 1362, 1362, 2227]], "test": "untested"}
{"id": "lt2GRD", "name": "Spherical Harmonics lighting", "author": "jimmikaelkael", "description": "Just testing cheap spherical harmonics lighting from Ravi Ramamoorthi and Pat Hanrahan. Their formula uses only 9 coefficients to compute irradiance.", "tags": ["lighting", "spherical", "harmonics"], "likes": 31, "viewed": 2377, "published": "Public", "date": "1427388542", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Lighting is done by Spherical Harmonics:\n// This one is a cheap variant presented in 2001 by Ravi Ramamoorthi\n// and Pat Hanrahan: http://graphics.stanford.edu/papers/envmap/\n// http://graphics.stanford.edu/papers/envmap/envmap.pdf\n// There's a C program (prefilter.c) provided to compute spherical harmonic\n// coefficients from light probe images (in the floating point format).\n// I used pvalue tool from Radiance package on my Ubuntu system to convert\n// angular light probe images in HDR format to floating point format with\n// the following command:\n// $ pvalue -df -H -h grace_probe.hdr > grace_probe.float\n// I then have slightly modified prefilter.c to output values with a factor\n// applied to have coefficients in a correct range (I used a factor of 0.315),\n// and ran the following command:\n// $ ./prefilter grace_probe.float 1000\n// You can read too the Orange Book, chapter 12.3 (OpenGL Shading Language\n// by Randi J. Rost), it has been very useful.\n\nstruct SHCoefficients {\n    vec3 l00, l1m1, l10, l11, l2m2, l2m1, l20, l21, l22;\n};\n\n// These constants have been calculated with a light probe from this website:\n// http://www.pauldebevec.com/Probes/\n// The light probe image used is Grace Cathedral.\nconst SHCoefficients grace = SHCoefficients(\n    vec3( 0.7953949,  0.4405923,  0.5459412 ),\n    vec3( 0.3981450,  0.3526911,  0.6097158 ),\n    vec3(-0.3424573, -0.1838151, -0.2715583 ),\n    vec3(-0.2944621, -0.0560606,  0.0095193 ),\n    vec3(-0.1123051, -0.0513088, -0.1232869 ),\n    vec3(-0.2645007, -0.2257996, -0.4785847 ),\n    vec3(-0.1569444, -0.0954703, -0.1485053 ),\n    vec3( 0.5646247,  0.2161586,  0.1402643 ),\n    vec3( 0.2137442, -0.0547578, -0.3061700 )\n);\n\nvec3 calcIrradiance(vec3 nor) {\n    const SHCoefficients c = grace;\n    const float c1 = 0.429043;\n    const float c2 = 0.511664;\n    const float c3 = 0.743125;\n    const float c4 = 0.886227;\n    const float c5 = 0.247708;\n    return (\n        c1 * c.l22 * (nor.x * nor.x - nor.y * nor.y) +\n        c3 * c.l20 * nor.z * nor.z +\n        c4 * c.l00 -\n        c5 * c.l20 +\n        2.0 * c1 * c.l2m2 * nor.x * nor.y +\n        2.0 * c1 * c.l21  * nor.x * nor.z +\n        2.0 * c1 * c.l2m1 * nor.y * nor.z +\n        2.0 * c2 * c.l11  * nor.x +\n        2.0 * c2 * c.l1m1 * nor.y +\n        2.0 * c2 * c.l10  * nor.z\n    );\n}\n\nvec3 spherePos = vec3(0.0, 1.0, 0.0);\nvec3 planePos = vec3(0.0, 0.05, 0.0);\nfloat sphereRadius = 1.0;\n\nfloat raytracePlane(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    vec3 p = ro - planePos;\n    float t = -p.y / rd.y;\n    if (t > tmin && t < tmax) {\n        return t;\n    }\n    return -1.0;\n}\n\nfloat raytraceSphere(in vec3 ro, in vec3 rd, float tmin, float tmax, float r) {\n    vec3 ce = ro - spherePos;\n    float b = dot(rd, ce);\n    float c = dot(ce, ce) - r * r;\n    float t = b * b - c;\n    if (t > tmin) {\n        t = -b - sqrt(t);\n        if (t < tmax)\n            return t;\n        }\n    return -1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\n    vec3 eye = vec3(0.0, 2.0, 3.0);\n    vec2 rot = 6.2831 * (vec2(0.6 + iTime * 0.25, sin(iTime * 0.5) * 0.06) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.0, 1.0, 0.0);\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));   \n\n    vec3 col = vec3(0.0);\n    vec3 nor;\n    float occ = 1.0;\n\n    float tmin = 0.1;\n    float tmax = 50.0;\n\n    // raytrace the plane\n    float tpla = raytracePlane(ro, rd, tmin, tmax);\n    if (tpla > tmin) {\n        vec3 ppos = ro + rd * tpla;\n        nor = normalize(vec3(0.0, 1.0, 0.0) + ppos);\n        vec3 d = spherePos - ppos;\n        float l = length(d);\n        occ = 1.0 - (dot(nor, d / l) * (sphereRadius * sphereRadius) / (l * l));\n    }\n\n    // raytrace the sphere\n    float tsph = raytraceSphere(ro, rd, tmin, tmax, sphereRadius);\n    if (tsph > tmin) {\n        vec3 spos = ro + rd * tsph;\n        nor = normalize(spos - spherePos);\n        occ = 0.5 + 0.5 * nor.y;\n    }\n\n    if (tpla > tmin || tsph > tmin) {\n        col = calcIrradiance(nor) * occ;\n\n        // distant fog if we don't hit the sphere\n        if (tsph < tmin) {\n            col = mix(col, vec3(0.0), 1.0 - exp(-0.001 * tpla * tpla));\n        }\n    }\n\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2GRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1053, 1690, 1721, 1721, 2306], [2411, 2411, 2480, 2480, 2610], [2612, 2612, 2691, 2691, 2927], [2929, 2929, 2986, 2986, 4623]], "test": "untested"}
{"id": "lt2Gzh", "name": "rutherford atom", "author": "mattz", "description": "Experiment in adding outlines to distance marched scenes. Looks better fullscreen.", "tags": ["outlines"], "likes": 7, "viewed": 509, "published": "Public", "date": "1427043718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float farval = 1e5;\nconst vec3 tgt = vec3(0);\nvec3 cpos;\nconst int rayiter = 60;\nconst float dmax = 20.0;\nvec3 L = normalize(vec3(-0.3, 1.0, -1.0));\nmat3 Rview;\n\nconst float outline = 0.0225;\n\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n\treturn mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\nmat3 rotZ(in float t) {\n    float cz = cos(t), sz = sin(t);\n\treturn mat3(cz, -sz, 0.,\n                sz, cz, 0.,\n                0., 0., 1.);\n\n}\n\nfloat sdRibbon( vec3 p, vec2 h ) {\n\n\tvec2 q = vec2(length(p.xy)-h.x, p.z);\n    vec2 d = abs(q) - vec2(0.001, h.y);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n    \n}\n\n\n\nvec2 opU(vec2 a, vec2 b) {\n\treturn a.x < b.x ? a : b;\n}\n\n\nvec2 map(in vec3 pos) {\t\n    \n    vec2 rval = vec2(farval, 0.0);\n        \n    const float k = 0.15;\n    const float r = 0.25;\n    const float m = 0.04;\n\t  \n#if 0\n   \n    // Lithium?\n    pos = pos.xzy;\n    pos = rotX(0.2)*pos;\n    vec3 p0 = rotY(-0.1*iTime)*rotZ(-0.2*iTime)*pos;\n    rval = opU(rval, vec2(length(p0-vec3(k))-r, 0.0));\n    rval = opU(rval, vec2(length(p0-vec3(k,-k,-k))-r, 0.01));\n    rval = opU(rval, vec2(length(p0-vec3(-k,k,-k))-r, 0.5));\n    rval = opU(rval, vec2(length(p0-vec3(-k,-k,k))-r, 0.51));\n            \n    vec3 p1 = rotX(0.1)*rotZ(-2.9*iTime)*pos;\n    rval = opU(rval, vec2(length(p1-vec3(1.8,0,0))-r, 0.14));\n    rval = opU(rval, vec2(sdRibbon(p1, vec2(1.8, m)), 0.7));\n\n    vec3 p2 = rotX(-0.07)*rotZ(1.7*iTime)*pos;\n    rval = opU(rval, vec2(length(p2-vec3(1.2,0,0))-r, 0.14));\n    rval = opU(rval, vec2(sdRibbon(p2, vec2(1.2, m)), 0.7));   \n\n#else\n        \n    // Beryllium?\n    pos = pos.xzy;\n    vec3 p0 = rotY(-0.3*iTime)*rotZ(-0.2*iTime)*pos;\n\n    float c = sign(p0.x)*sign(p0.y)*sign(p0.z)*0.25 + 0.25;\n    rval = opU(rval, vec2(length(abs(p0)-vec3(k))-r, c));\n    \n    float rx = 0.2;\n    float rz = 1.05;\n    float l = 1.0;\n    float s = 1.0;\n    \n    for (int i=0; i<4; ++i) {\n        vec3 pi = rotX(0.04)*rotZ(s*rz*iTime)*rotY(-s*rx)*rotX(s*rx*0.5+0.35)*pos;\n        rval = opU(rval, vec2(length(pi-vec3(l,0,0))-r, 0.14));\n        rval = opU(rval, vec2(sdRibbon(pi, vec2(l, m)), 0.7));\n        l += 0.4;\n        rx += 0.05;\n        rz += 0.2;\n        s *= -1.0;\n    }\n    \n#endif    \n   \n\treturn rval;\n    \n}\n\nvec3 hue(float h) {\n\t\n\tvec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n\treturn h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n\n\nvec3 calcNormal( in vec3 pos )\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nvec4 castRay( in vec3 ro, in vec3 rd, in float maxd )\n{\n\tfloat precis = 0.002;\n    \n    float h=outline;\n    \n    float t = 0.0;\n    float m = -1.0;\n\n    float tclose = farval;\n    float hclose = 2.0*outline;\n    \n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n\t    vec2 res = map( ro+rd*t );\n        \n        if (h < outline && res.x > h && t < tclose) {\n            hclose = h;\n            tclose = t;\n            //t = maxd+1.;\n        } \n        \n        h = res.x;\n\t    m = res.y;        \n    }    \n    \n    if (t > maxd) {\n        m = -1.0;\n    }\n\n    return vec4(t, m, tclose, hclose);\n    \n}\n\nvec3 shade( in vec3 ro, in vec3 rd ){\n    \n    vec4 tm = castRay(ro, rd, dmax);        \n    \n    vec3 c;\n    \n    if (tm.y == -1.0) {\n        \n        c = vec3(step(farval, tm.z));\n        //c = vec3(smoothstep(0.5*outline, outline, tm.w)); // Bad anti-aliasing?\n        \n    } else {        \n        \n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);        \n        vec2 res = map( pos + 0.5*outline*n );        \n        \n        if (res.y != tm.y) {\n            \n            c = vec3(0);\n            \n        } else {\n\n            vec3 color = hue(tm.y) * 0.4 + 0.6;\n            vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * color;\n            vec3 R = 2.0*n*dot(n,L)-L;\n            float spec = 0.5*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n            c = diffamb + spec;\n            float u = clamp((tm.x-tm.z)*2.0, 0.0, 1.0);\n            c *= step(outline*u, tm.w);\n\n        }\n\n    }\n\n    \n    return c;\n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    cpos = vec3(0,0,3.5);\n\tvec2 uv = (fragCoord.xy - .5*iResolution.xy) * 1.25 / (iResolution.y);\n\t\n\tvec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\t\n\tfloat thetax = 0.0, thetay = 0.0;\n\t\n\tif (max(iMouse.x, iMouse.y) > 20.0) { \n\t\tthetax = (iMouse.y - .5*iResolution.y) * 3.14/iResolution.y; \n\t\tthetay = (iMouse.x - .5*iResolution.x) * -6.28/iResolution.x; \n\t}\n\t\n    Rview = mat3(rx,ry,rz)*rotX(thetax)*rotY(thetay);\n    L = Rview*L;\n\n\tvec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\t\n\tfragColor.xyz = shade(ro, rd);\n\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lt2Gzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 222, 222, 343], [345, 345, 368, 368, 486], [488, 488, 511, 511, 633], [635, 635, 669, 669, 811], [815, 815, 841, 841, 870], [873, 873, 896, 896, 2424], [2426, 2426, 2445, 2445, 2558], [2562, 2562, 2594, 2594, 2815], [2818, 2818, 2873, 2873, 3481], [3483, 3483, 3520, 3520, 4423], [4426, 4426, 4483, 4483, 5113]], "test": "untested"}
{"id": "ltB3zw", "name": "Interweaving sine bands", "author": "the23", "description": "Three colored sine-bands interweaving", "tags": ["animated", "bands", "sine", "wallpaper", "colormix"], "likes": 9, "viewed": 230, "published": "Public", "date": "1427575671", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 calcSine(vec2 uv, \n              float frequency, float amplitude, float shift, float offset,\n              vec3 color, float width, float exponent)\n{\n    float y = sin(iTime * frequency + shift + uv.x) * amplitude + offset;\n    float scale = pow(smoothstep(width, 0.0, distance(y, uv.y)), exponent);\n    return color * scale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    color += calcSine(uv, 2.0, 0.25, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.3, 1.0);\n    color += calcSine(uv, 2.6, 0.25, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.3, 1.0);\n    color += calcSine(uv, 2.9, 0.25, 0.4, 0.5, vec3(1.0, 0.0, 0.0), 0.3, 1.0);\n    \n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltB3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 155, 155, 333], [335, 335, 392, 392, 741]], "test": "untested"}
{"id": "ltfGDf", "name": "Cubic function Curve", "author": "gaz", "description": "2d", "tags": ["2d"], "likes": 3, "viewed": 162, "published": "Public", "date": "1425657363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2\tPI*2.0\n\nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    p.y -= p.x * (p.x - 1.0) * (p.x + 1.0);\n    p.x -= 3.0 * sin(p.y + iTime * 0.3);\n    float n = PI2 / 120.0;\n    p *= rotate(floor(atan(-p.x, p.y) / n) * n);\n    p.x = abs(p.x);\n    p.y -= 0.3;\n    vec3 col = vec3(0.0);\n    col = mix(col, hsv(sin(iTime * 0.1)+ 0.3, 0.6, 0.5), smoothstep(0.1, 0.0, abs(p.x)));\n    col = mix(col, hsv(sin(iTime * 0.1)+ 0.0, 1.0, 1.0), smoothstep(0.5, 0.0, abs(p.y)));\n    col = mix(col, hsv(sin(iTime * 0.1)+ 0.6, 0.7, 0.3), smoothstep(0.0, 5.0, length(p)));\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltfGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 67, 67, 117], [119, 119, 156, 156, 288], [294, 294, 351, 351, 944]], "test": "untested"}
{"id": "ltj3zh", "name": "Gloopy", "author": "flypig", "description": "Three lumps of lava-lamp style gloop.", "tags": ["lava", "liquid", "gloop"], "likes": 2, "viewed": 1400, "published": "Public API", "date": "1426987025", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nCopyright (c) 2015 David Llewellyn-Jones\n\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n*/\n\nprecision mediump float;\n\n#define M_PI 3.1415926535897932384626433832795\n\n// (((((x - xc1)**2) + ((y - yc1)**2) - (r1**2)) * (((x - xc2)**2) + ((y - yc2)**2) - (r2**2)))) < (s / 1000)\n\nconst vec3 position = vec3(-0.2, 0.2, 1.3);\nconst vec3 diffuseColour = vec3(0.25, 0.25, 0.5);\nconst float diffusePower = 2.0;\nconst vec3 specularColour = vec3(0.5, 0.1, 0.1);\nconst float specularPower = 5.0;\nconst float specularHardness = 5.0;\nconst vec3 ambientColour = vec3(0.4, 0.5, 0.4);\n\nvec3 BlinnPhongLighting(vec3 pos, vec3 viewDir, vec3 normal) {\n\tvec3 lightDir = position - pos;\n\tfloat distance = length (lightDir);\n\tlightDir = lightDir / distance;\n\tdistance = distance * distance;\n\n\tfloat NdotL = dot (normal, lightDir);\n\tfloat intensity = clamp (NdotL, 0.0, 1.0);\n\tvec3 diffuse = intensity * diffuseColour * diffusePower / distance;\n\tvec3 H = normalize (lightDir + viewDir);\n\tfloat NdotH = dot (normal, H);\n\tintensity = pow (clamp (NdotH, 0.0, 1.0), specularHardness);\n\tvec3 specular = intensity * specularColour * specularPower; \n\n\treturn (diffuse + specular + ambientColour);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vTextureCoord = fragCoord / iResolution.xy;\n    float time = (310.0 + iTime) * 1000.0;\n    float width = iResolution.x;\n    float height = iResolution.y;\n    \n\tconst float stickiness = 0.0050;\n\tconst float r1 = 0.25;\n\tconst float r2 = 0.25;\n\tconst float r3 = 0.25;\n\tvec2 ratio = vec2(width, height) / min(width, height);\n\tvec2 pos1 = vec2((1.0 + sin(time / 9000.0)) / 2.0, (1.0 + sin(time / 7100.0)) / 2.0) * ratio;\n\tvec2 pos2 = vec2((1.0 + sin(time / 8900.0)) / 2.0, (1.0 + sin(time / 10400.0)) / 2.0) * ratio;\n\tvec2 pos3 = vec2((1.0 + sin(time / 9650.0)) / 2.0, (1.0 + sin(time / 91500.0)) / 2.0) * ratio;\n\tvec2 pos = vTextureCoord * ratio;\n\n\tfloat d1 = pow((pos.x - pos1.x), 2.0) + pow((pos.y - pos1.y), 2.0) - pow(r1, 2.0);\n\tfloat d2 = pow((pos.x - pos2.x), 2.0) + pow((pos.y - pos2.y), 2.0) - pow(r2, 2.0);\n\tfloat d3 = pow((pos.x - pos3.x), 2.0) + pow((pos.y - pos3.y), 2.0) - pow(r3, 2.0);\n\n\tfloat dist = (stickiness - d1 * d2 * d3);\n\tvec3 position = vec3(pos.x, pos.y, dist);\n\n\tfloat d12 = distance(pos1, pos2);\n\tfloat d13 = distance(pos1, pos3);\n\tfloat d23 = distance(pos2, pos3);\n\tfloat weght12 = 1.0 / (1.0 + exp(((distance(pos1, pos) / d12) - 0.5) * 8.0));\n\tfloat weght13 = 1.0 / (1.0 + exp(((distance(pos1, pos) / d13) - 0.5) * 8.0));\n\tfloat weght23 = 1.0 / (1.0 + exp(((distance(pos2, pos) / d23) - 0.5) * 8.0));\n\n\tvec2 centre12 = (weght12 * pos1) + ((1.0 - weght12) * pos2);\n\tvec2 centre13 = (weght13 * pos1) + ((1.0 - weght13) * pos3);\n\tvec2 centre = (weght23 * centre12) + ((1.0 - weght23) * centre13);\n\n\thighp float up = pow(dist, 0.45);\n\tvec3 normal = normalize(vec3(pos.x - centre.x, pos.y - centre.y, up));\n\n\tvec4 colour = vec4(0.8 * (1.0 - vTextureCoord.y), 0.8 * vTextureCoord.y, 0.8, 1.0);\n\tif (dist > 0.0) {\n\t\tcolour.xyz = BlinnPhongLighting (position, vec3(0.0, 0.0, 1.0), normal);\n\t}\n\n\tfragColor = colour;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltj3zh.jpg", "access": "shaders20k", "license": "mit", "functions": [[1148, 1552, 1614, 1614, 2150], [2152, 2152, 2209, 2209, 4049]], "test": "untested"}
{"id": "ltjGzh", "name": "fountain - shadeADay", "author": "kig", "description": "Hey! You! Yeah you! Calculus, right? Yeah, I remember you! Vaguely!", "tags": ["2d", "particles", "integration", "shadeaday"], "likes": 16, "viewed": 528, "published": "Public", "date": "1426980791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float y(float t, float yv) {\n    return -0.01 + yv*t + -1.0*t*t*0.5;\n}\n\nfloat x(float t, float xv) {\n    return 0.5 + xv*t;\n}\n\nvec2 particle(float t, float xv, float yv) {\n    t = mod(t, 1.94152);\n    vec2 p = vec2(x(t, xv)-0.2*xv, y(t, yv));\n    return p;\n}\n\nfloat hash(float v) {\n    return fract(sin(v*27179.18917));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(1.0, iResolution.y / iResolution.x) * fragCoord.xy / iResolution.xy;\n    float r = 0.003;\n    float pxSize = 1.0/iResolution.x;\n    fragColor = vec4(0.3*(1.0-abs((uv.x-0.5)))*pow(1.0-uv.y,8.0), 0.4*uv.y, 0.6*uv.y, 1.0) + hash(iTime+fragCoord.x/fragCoord.y)/255.0;\n    float v = 0.0;\n    for (float j=0.0; j<4.0; j++) {\n    \tfor (float i=0.0; i<100.0; i++) {\n\t\t\tv += mix(1.0, 0.0, smoothstep(r, r+pxSize, length(particle(iTime+i+(j+hash(i*j+iTime+fragCoord.x/fragCoord.y))*(1.0/(2.0*60.0)), sin(i)*0.2, 0.9+0.05*cos(i*5.1))-uv)) );\n    \t}\n    }\n    v /= 4.0;\n    fragColor.r += v;\n    fragColor.g += v * 2.5*uv.y*uv.y;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltjGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 70], [72, 72, 100, 100, 125], [127, 127, 171, 171, 258], [260, 260, 281, 281, 321], [323, 323, 380, 380, 1016]], "test": "untested"}
{"id": "ltl3Dj", "name": "ngKale0", "author": "netgrind", "description": "so many functions", "tags": ["waves", "psychedelic", "kaleidoscope", "netgrind"], "likes": 5, "viewed": 2198, "published": "Public API", "date": "1425377379", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 hue(vec4 color, float shift) {\n\n    const vec4  kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n    const vec4  kRGBToI     = vec4 (0.596, -0.275, -0.321, 0.0);\n    const vec4  kRGBToQ     = vec4 (0.212, -0.523, 0.311, 0.0);\n\n    const vec4  kYIQToR   = vec4 (1.0, 0.956, 0.621, 0.0);\n    const vec4  kYIQToG   = vec4 (1.0, -0.272, -0.647, 0.0);\n    const vec4  kYIQToB   = vec4 (1.0, -1.107, 1.704, 0.0);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec4    yIQ   = vec4 (YPrime, I, Q, 0.0);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nvec2 kale(vec2 uv, float angle, float base, float spin) {\n\tfloat a = atan(uv.y,uv.x)+spin;\n\tfloat d = length(uv);\n\ta = mod(a,angle*2.0);\n\ta = abs(a-angle);\n\tuv.x = sin(a+base)*d;\n\tuv.y = cos(a+base)*d;\n    return uv;\n}\n\nvec2 rotate(float px, float py, float angle){\n\tvec2 r = vec2(0);\n\tr.x = cos(angle)*px - sin(angle)*py;\n\tr.y = sin(angle)*px + cos(angle)*py;\n\treturn r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float p = 3.14159265359;\n    float i = iTime*.5;\n\tvec2 uv = fragCoord.xy / iResolution.xy*5.0-2.5;\n    uv = kale(uv, p/6.0,i,i*0.2);\n    vec4 c = vec4(1.0);\n    mat2 m = mat2(sin(uv.y*cos(uv.x+i)+i*0.1)*20.0,-6.0,sin(uv.x+i*1.5)*3.0,-cos(uv.y-i)*2.0);\n    uv = rotate(uv.x,uv.y,length(uv)+i*.4);\n    c.rg = cos(sin(uv.xx+uv.yy)*m-i);\n    c.b = sin(rotate(uv.x,uv.x,length(uv.xx)*3.0+i).x-uv.y+i);\n    fragColor = vec4(1.0-hue(c,i).rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltl3Dj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 1019], [1021, 1021, 1078, 1078, 1239], [1241, 1241, 1286, 1286, 1394], [1396, 1396, 1453, 1453, 1900]], "test": "untested"}
{"id": "ltl3DX", "name": "DotDotDot", "author": "AntoineC", "description": "An exercise in seamless loop and smooth animation. Proved to be more difficult than expected!\nThe right solution was to use an exponential scaling that provides a nice acceleration while maintaining the same tangents at the beginning and end of the loop.", "tags": ["2d", "loop", "minimalist"], "likes": 18, "viewed": 338, "published": "Public", "date": "1425865708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ----------------------------------------------------------------------------------------\n//\t\"DotDotDot\" by Antoine Clappier - March 2015\n//\n//\tLicensed under a Creative Commons Attribution-ShareAlike 4.0 International License\n//\thttp://creativecommons.org/licenses/by-sa/4.0/\n// ----------------------------------------------------------------------------------------\n\n// An exercise in seamless loop and smooth animation. Proved to be more difficult than expected!\n// The right solution was to use an exponential scaling that provides a nice acceleration \n// while maintaining the same tangents at the beginning and end of the loop.\n\nconst float OversamplingSqrt\t= 4.0;\nconst float ShutterSpeed \t\t= 1.0/60.0;\n\nconst float LoopS\t= 3.0;\nconst float Radius\t= 0.53;\nconst float Scale0\t= 0.6;\nconst float ExpF\t= 4.05;\nconst float Spower\t= 9.0;\n\n\nconst float AaCount = OversamplingSqrt*OversamplingSqrt;\n   \n    \nvec3 Render(vec2 pQ, float pT)\n{\n\tfloat T = fract(pT / LoopS);\n\n\t// Transform:\n\tfloat Scale = Scale0*exp(ExpF*T);\n\n\tfloat Sgn = sign(fract(0.5*pT/LoopS) - 0.5);\n\tfloat Cs = cos(Sgn*T);\n\tfloat Sn = sin(Sgn*T);\n\n\tvec2 Qt = (1.0 + Scale*pQ*mat2(Cs, -Sn, Sn, Cs)) / 2.0;\n\n\t// Dot grid:\n\tvec2 Gf = 2.0*fract(Qt) - 1.0;\n\tfloat D =  step(length(Gf), Radius + 0.6*pow(T, Spower));\n\n\t// Disk clip:\n\tD *= step(length(Qt-0.5), 0.5*Radius*exp(ExpF));\n\n\treturn vec3(D);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float Ratio = 0.5*min(iResolution.x, iResolution.y);\n\t\n\t// Render scene in linear space with motion blur and Antialising:\n\tvec3 ColorSum = vec3(0.0);\n\tfor(float F=0.0; F<AaCount; F++)\n\t{\n\t\t// Antialiasing:\n\t\tvec2 Off = vec2(1.0 + floor(F/OversamplingSqrt), mod(1.0+F, OversamplingSqrt)) / OversamplingSqrt;\n\t\tvec2 UV = (fragCoord.xy + Off - iResolution.xy/2.0) / Ratio;\t\n\t\t\n\t\t// Motion blur:\n\t\tfloat t = iTime + F*ShutterSpeed / AaCount;\n\t\t\n\t\t// Render:\n\t\tColorSum += Render(UV, t);\n\t}\n\t\n\tColorSum /= AaCount;\n\t\n\t// Apply gamma:\n\tColorSum = pow(ColorSum, vec3(1.0/2.2));\n\t\n\tfragColor = vec4(ColorSum, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltl3DX.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0", "functions": [[372, 911, 943, 943, 1369], [1374, 1374, 1431, 1431, 2044]], "test": "untested"}
{"id": "ltl3W2", "name": "Voronoise terrains", "author": "guil", "description": "Trying to fit iqnoise from voronoise in a 3x3 kernel using various tricks in order to get acceptable perfomances\nUse mouse to modify the parameters.\n", "tags": ["2d", "voronoi", "noise", "terrain"], "likes": 24, "viewed": 724, "published": "Public", "date": "1425400769", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte\n//Based on Voronoise from iq :https://www.shadertoy.com/view/Xd23Dh\n\nint windows = 0;\nvec2 m = vec2(.7,.8);\n\nfloat hash( in vec2 p ) \n{\n    return fract(sin(p.x*15.32+p.y*5.78) * 43758.236237153);\n}\n\n\nvec2 hash2(vec2 p)\n{\n\treturn vec2(hash(p*.754),hash(1.5743*p.yx+4.5891))-.5;\n}\n\nvec2 hash2b( vec2 p )\n{\n    vec2 q = vec2( dot(p,vec2(127.1,311.7)), \n\t\t\t\t   dot(p,vec2(269.5,183.3)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\n\nfloat vnoise(vec2 x)//Value noise\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    return  2.*mix(mix( hash(p),hash(p + vec2(1.,0.)),f.x),\n                  mix( hash(p+vec2(0.,1.)), hash(p+1.),f.x),f.y)-1.;\n            \n}\n\nfloat gnoise( in vec2 p )// gradient noise from iq\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( hash2( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash2( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash2( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash2( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y)*2.;\n}\n\n\nmat2 m2= mat2(.8,.6,-.6,.8);\n\n\nfloat dvnoise(vec2 p)//Value noise + value noise with rotation\n{\n    return .5*(vnoise(p)+vnoise(m2*p));    \n}\n\n\n//Perlin like version of iqnoise adapted from voronoise : 3x3 kernel\n\n\nfloat iqnoisep( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-1; j<=1; j++ )//kernel limitations to increase performances :\n    for( int i=-1; i<=1; i++ )//3x3 instead of 5x5\n    {\n        \n        vec2 g = vec2( float(i),float(j) )+.5;\n\t\tfloat o = hash( p + g );\n\t\tvec2 r = g - f ;\n\t\tfloat d = dot(r,r)*(.4+m.x*.4);\n        d=smoothstep(0.0,1.,d);//d=smoothstep(0.0,1.,sqrt(d));\n        //d = d*d*d*(d*(d*6. - 15.) + 10.);\n\t\tfloat ww = 1.0-d;\n\t\tva += o*ww;\n\t\twt += ww;\n    }\n\t\n    return 2.*va/wt-1.;\n}\n\nvec3 hash3( vec2 p )\n{\n    vec3 q = vec3( dot(p,vec2(127.1531,311.7273)), \n\t\t\t\t   dot(p,vec2(269.5437,183.3581)), \n\t\t\t\t   dot(p,vec2(419.2673,371.9741)) );\n\treturn fract(sin(q)*43758.5453);\n}\nvec3 hash3b( vec2 p )\n{\n    float q = hash(p);\n\treturn vec3(q,1.-q,q*(2.-q));\n}\n\n\n\n//iq noise adapted from voronoise 3x3 kernel : valid for u+v<1.5\n\nfloat iqnoise3( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    vec2 sp = floor(f*1.1666);//kernel shift if f is large\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) )+sp;\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = sqrt(dot(r,r)*.5);\n        d = d*d*d*(d*(d*6. - 15.) + 10.);//additional hermit 5 smoothing\n\t\tfloat ww = pow( 1.0-smoothstep(0.,1.,d), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return 2.*va/wt-1.;\n}\n\n//a variant of the previous noise using exp in weights\n\nfloat iqnoise3b( in vec2 x, float u, float v )//iq noise adapted from voronoise 3x3 kernel : valid for u + v <1.5\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\tvec2 sp = floor(f*1.1666);\t\t\n\tfloat k = 1.0+15.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) )+sp;\n\t\tvec3 o = hash3( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r);\n\t\tfloat ww = exp(-4.*k*d);//pow( 1.0-smoothstep(0.0,1.,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return 2.*va/wt-1.;\n}\n\n//iq noise from voronoise 4x4 kernel : valid for all u and v \nfloat iqnoise4( in vec2 x, float u, float v )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n\t\t\n\tfloat k = 1.0+63.0*pow(1.0-v,4.0);\n\t\n\tfloat va = 0.0;\n\tfloat wt = 0.0;\n    for( int j=-2; j<=1; j++ )\n    for( int i=-2; i<=1; i++ )\n    {\n        vec2 g = vec2( float(i),float(j) )+.5;\n\t\tvec3 o = hash( p + g )*vec3(u,u,1.0);\n\t\tvec2 r = g - f + o.xy;\n\t\tfloat d = dot(r,r)*.5;\n\t\tfloat ww = pow( 1.0-smoothstep(0.0,1.,sqrt(d)), k );\n\t\tva += o.z*ww;\n\t\twt += ww;\n    }\n\t\n    return 2.*va/wt-1.;\n}\n\nfloat hash( in vec3 p ) \n{\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\n}\n\n\nfloat voronoise(in vec3 p)\n{    \n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-1; i<=2; i++) \n\tfor (int j=-1; j<=2; j++) \n\tfor (int k=-1; k<=2; k++)\n\t{\n\t\tvec3 o = vec3(i, j, k)-.5;       \t\t\n        vec3 pp = fp +o -hash(ip - o);\n        float d = dot(pp, pp)*.7;\n        d=clamp(d,0.,1.);d=sqrt(d);\n        d = d*d*(3.0-2.0*d);       \n        d = d*d*d*(d*(d*6. - 15.) + 10.);\n        float w = 1.-d;\n        va += w*d;\n        wt += w;\n\t}    \n    return 2.*va/wt-1.;\n}\n\n// a kind of pure voronoi version of iqnoise\nfloat voronoise(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j);       \t\t\n        vec2 pp = fp +o -hash2b(ip - o)*m.y;\n        float d = dot(pp, pp)*.7;       \n        d = smoothstep(0.0,1.,sqrt(d));       \n        d = d*d*d*(d*(d*6. - 15.) + 10.);\n        float w =  1.0-d;\n        va += w*d;\n        wt += w;\n\t}    \n    return 2.*va/wt-1.;\n}\n\n//a variant of the previous noise using exp in weights\n\nfloat voronoise1(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j);       \t\t\n        vec2 pp = fp +o -hash2(ip - o)*m.y-0.5;\n        float d = sqrt(dot(pp, pp)*.6);\n        d=clamp(d,0.,1.);\n        d = d*d*(3.0-2.0*d);//d = d*d*d*(d*(d*6. - 15.) + 10.);               \n        float w =  exp(-d*4.);\n        va += w*d;\n        wt += w;\n\t}    \n    return va/wt*2.-1.;\n}\n\n//standard voronoi 3x3 kernel giving f1,f2 and f3 if f3<1\n\nfloat voronoi(in vec2 p)\n{    \n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n    vec3 f = vec3(5.);\n    float va = 0.0;\n    float wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n\t{\t\t\n        vec2 o = vec2(i, j);       \t\t\n        vec2 pp = fp +o  -hash2b(ip - o);\n        float d = dot(pp, pp);\n        if(d<f.x){f=f.zxy;f.x=d;}\n        else if(d<f.y){f=f.xzy;f.y=d;}\n        else if(d<f.z){f.z=d;}\n\t}    \n    return (f.x+m.x*f.y-.5*m.y*min(f.z,1.))/2.;\n}\n\nfloat noise( vec2 p){\n    \n    \n    if(windows ==0)return voronoi(p);\n    if(windows ==1)return iqnoise3(p,m.x,m.y);\n    if(windows ==2)return iqnoisep(p);//iqnoise4(p,m.x,m.y);\n    //return 2.*gnoise(p*.5);\n    return voronoise(p*.5)*.8;\n}\n\nfloat fbmabs( vec2 p ) {\n\t\n\tfloat f=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(noise( p*f ))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.07)*r;\n\t}\n\treturn r;\n}\n\nfloat fbm( vec2 p ) {\n\t\n\tfloat f=1.;\n   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += noise( p*f )/f;       \n\t    f *=2.;\n\t}\n\treturn r;\n}\n\nfloat map(vec2 p){\n\n    //return noise(p*10.);\n    //return 2.*abs( noise(p*10.));\n\t//return fbm(p)+1.;\n    return 2.*fbmabs(p);\n}\n\nvec3 nor(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xy) - map(p - e.xy),\n\t\tmap(p + e.yx) - map(p - e.yx),\n\t\t-.2));\n}\n\n\t\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 p = 2.*fragCoord.xy /iResolution.xy-1.;\n    \n\tif(p.y>0.){\n    \tif(p.x>0.)windows =1;\n    \telse    windows =0;}\n    else{\n    \tif(p.x>0.)windows =3;\n        else windows =2;}\n    //windows =2;\n    \n    p += .5*iTime;\n    \n    if(iMouse.z>0.)m = iMouse.xy/iResolution.xy;\n    \n    \n\tfloat r;\n\tr = (noise(p*10.));\n    vec3 light = normalize(vec3(4., 2., -1.));\n\n    r = max(dot(nor(p), light),0.1);\n    float k=map(p);\n    fragColor = clamp(vec4(r, r, r, 1.0),0.,1.);\n\tfragColor = clamp(vec4(r*k*k, r*k, r, 1.0),0.,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltl3W2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 222, 248, 248, 311], [314, 314, 334, 334, 392], [394, 394, 417, 417, 534], [537, 537, 572, 572, 792], [794, 794, 846, 846, 1251], [1285, 1285, 1349, 1349, 1395], [1398, 1469, 1498, 1498, 2038], [2040, 2040, 2062, 2062, 2231], [2232, 2232, 2255, 2255, 2311], [2315, 2381, 2428, 2428, 3001], [3003, 3059, 3174, 3174, 3657], [3659, 3721, 3768, 3768, 4211], [4213, 4213, 4239, 4239, 4341], [4344, 4344, 4372, 4372, 4871], [4873, 4918, 4946, 4946, 5410], [5412, 5468, 5497, 5497, 5984], [5986, 6045, 6071, 6071, 6522], [6524, 6524, 6545, 6545, 6764], [6766, 6766, 6790, 6790, 6948], [6950, 6950, 6971, 6971, 7095], [7097, 7097, 7115, 7200, 7227], [7229, 7229, 7250, 7250, 7385], [7389, 7389, 7446, 7446, 7973]], "test": "untested"}
{"id": "ltlGDj", "name": "Planet and moon", "author": "skurmedel", "description": "A bit of a work in progress.\n\nA moon and a planet rendered using raycasting and distance fields.\n\nI don't really like the looks of the clouds, and the moon is just a clone of the planet, which needs fixing.\n\nPerformance in FF seems pretty poor too.", "tags": ["raymarching", "space", "distance", "function"], "likes": 19, "viewed": 645, "published": "Public", "date": "1425505868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\nconst int ITERS = 80;\nconst float THRESHOLD = 0.0005;\nconst float MAX_T = 25.0;\n\nconst vec3 LIGHT_POS    = vec3(0.0, -4.0, 1.5);\nconst vec3 DIRECTIONAL_LIGHT = vec3(-0.683763, -2.73505, 1.02565);\n\nconst vec2 CIExy4874K = vec2(0.3840, 0.3516);\nconst vec2 D5000_ILLUMINANT = vec2(0.3457, 0.3586);\nconst vec2 D6500_ILLUMINANT = vec2(0.3127, 0.3297);\nconst vec2 LIGHT_CIExy = CIExy4874K;\n\n// BEGIN: https://raw.githubusercontent.com/ashima/webgl-noise/master/src/classicnoise2D.glsl\n//\n// GLSL textureless classic 2D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-08-22\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x)\n{\n  return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec2 fade(vec2 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise\nfloat cnoise(vec2 P)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod289(Pi); // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise(vec2 P, vec2 rep)\n{\n  vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);\n  vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);\n  Pi = mod(Pi, rep.xyxy); // To create noise with explicit period\n  Pi = mod289(Pi);        // To avoid truncation effects in permutation\n  vec4 ix = Pi.xzxz;\n  vec4 iy = Pi.yyww;\n  vec4 fx = Pf.xzxz;\n  vec4 fy = Pf.yyww;\n\n  vec4 i = permute(permute(ix) + iy);\n\n  vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;\n  vec4 gy = abs(gx) - 0.5 ;\n  vec4 tx = floor(gx + 0.5);\n  gx = gx - tx;\n\n  vec2 g00 = vec2(gx.x,gy.x);\n  vec2 g10 = vec2(gx.y,gy.y);\n  vec2 g01 = vec2(gx.z,gy.z);\n  vec2 g11 = vec2(gx.w,gy.w);\n\n  vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));\n  g00 *= norm.x;  \n  g01 *= norm.y;  \n  g10 *= norm.z;  \n  g11 *= norm.w;  \n\n  float n00 = dot(g00, vec2(fx.x, fy.x));\n  float n10 = dot(g10, vec2(fx.y, fy.y));\n  float n01 = dot(g01, vec2(fx.z, fy.z));\n  float n11 = dot(g11, vec2(fx.w, fy.w));\n\n  vec2 fade_xy = fade(Pf.xy);\n  vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);\n  float n_xy = mix(n_x.x, n_x.y, fade_xy.y);\n  return 2.3 * n_xy;\n}\n\n// END: https://raw.githubusercontent.com/ashima/webgl-noise/master/src/classicnoise2D.glsl\n\n// A prettier version of cnoise, that is made by layering calls to cnoise.\nfloat cnoise2(in vec2 uv)\n{\n    return (\n          cnoise(uv * 0.5  + vec2(0.5))  * 0.5\n        + cnoise(uv * 2.0  + vec2(2.1))  * 0.25\n        + cnoise(uv * 4.0  + vec2(4.1))  * 0.125\n        + cnoise(uv * 8.0  + vec2(0.8))  * 0.0625\n    + 1.0) * 0.5 ;\n}\n\nfloat cloudnoise(in vec2 uv)\n{\n    float n = cnoise2(uv);\n    if ((n > 0.2 && n < 0.35) || (n > 0.4 && n < 0.46) || (n > 0.6 && n < 0.95))\n    {\n        return n;\n    }\n    return 0.0;\n}\n\n// Converts a CIE xy chromacity to sRGB.\nvec3 CIExyY_RGB(in vec2 cr)\n{\n    float Y = 1.0;\n    vec3 CIE = vec3(\n        Y * (cr.x / cr.y),\n        Y,\n        Y * ((1.0 - cr.x - cr.y) / cr.y));\n    \n    mat3 CIE_rgb = mat3(\n         3.2406, -1.5372, -0.4986,\n        -0.9689,  1.8758,  0.0415,\n         0.0557, -0.2040,  1.0570);\n    return pow(CIE*CIE_rgb, vec3(0.454));\n}\n\nfloat streakynoise(float x)\n{\n    float r = 1.0 / abs(0.1 + cos(x) - sin(x));\n    \t  r+= 1.0 / abs(0.1 + cos(x / 8.0) - sin(8.0 * x));\n    \t  r+= 1.0 / abs(0.1 + cos(x / 27.0) - sin(27.0 * x));\n    \t  r+= 1.0 / abs(0.1 + cos(x / 64.0) - sin(64.0 * x));\n    return clamp(r, 0.0, 35.0) / 35.0;\n}\n\nfloat rand(float x)\n{    \n    return fract(1.0 / sin(x * x *  x * 17.2375e4));\n}\n\nfloat rand(vec2 uv)\n{\n    float v = texture(iChannel1, uv).r;\n    return rand(v);\n}\n\nfloat sphere(in vec3 p, in float r)\n{\n    return length(p) - r;\n}\n\nfloat scene_dist(in vec3 p)\n{\n    float d =  sphere(p - vec3(0.5, 0.3, 2.0), 0.1);\n    d = min(sphere(p - vec3(\n        0.17 * cos(0.5 * iTime) + 0.5, \n        0.30 + 0.03 * (cos(.5 * iTime) + sin(0.5 * iTime)), \n        0.17 * sin(0.5 * iTime) + 2.0), 0.04)\n      , d);\n    return d;\n}\n\nvec3 normal(in vec3 p)\n{\n    // Took this pretty much straight from Ignacio's code, it computes the differentials in\n    // three axes. That's our distance field gradient and our \"normal\".\n\tvec3 stepsize = vec3(0.01, 0.0, 0.0);\n    vec3 N = vec3(\n        scene_dist(p + stepsize.xyz) - scene_dist(p - stepsize.xyz),\n        scene_dist(p + stepsize.yxz) - scene_dist(p - stepsize.yxz),\n        scene_dist(p + stepsize.yzx) - scene_dist(p - stepsize.yzx));\n    return normalize(N);\n}\n\nfloat raycast(in vec3 ro, in vec3 rd)\n{\n\tfloat t = 1.0;\n    for (int i = 0; i < ITERS; ++i)\n    {\n        float d = scene_dist(ro + rd * t);\n        if (d < THRESHOLD || d > MAX_T)\n        {\n            break;\n        }\n        t += d;\n    }\n    \n    return t;    \n}\n\n// Also from Ignacio! My own one broke, so I couldn't bother.\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 32; i++)\n    {\n\t\tfloat h = scene_dist(ro + rd*t);\n        res = min(res, 2.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t>tmax ) \n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = fragCoord.xy / iResolution.xx;\n    \n    vec3 light_colour = CIExyY_RGB(LIGHT_CIExy) * 0.4;\n    vec3 color        = CIExyY_RGB(D5000_ILLUMINANT);\n    vec3 halo_colour  = vec3(0.25, 0.3, 0.6);\n    vec3 ambient      = color * 0.01;   \n    \n    vec3 ro = vec3(uv, 0.0);\n    vec3 rd = vec3(0.0, 0.0, 1.0);\n    \n    float d = raycast(ro, rd);\n    float atmo = pow(1.0 - softshadow(ro, rd, 0.1, 3.5), 6.0);\n    \n    vec3 finalColour = vec3(0.0);\n    if (d > MAX_T)\n    {\n        float stars = texture(iChannel0, uv, 5.8).r;\n        float stars2 = texture(iChannel1, uv + vec2(iTime * 0.03) , 5.5).r;\n        finalColour = \n              vec3(0.0, 0.2, 0.4) * stars \n            + vec3(0.2) * pow(stars2, 2.0);\n\n    }\n   \telse\n    {\n        vec3 surfpos = ro + rd * d;\n        vec3 L =  normalize(-DIRECTIONAL_LIGHT) * softshadow(ro, normalize(-DIRECTIONAL_LIGHT), 0.1, 10.0);\n        vec3 N = normal(surfpos);\n        float fresnel = pow(max(1.0 - dot(N, -rd), 0.0), 1.5);\n    \n        float shade = softshadow(surfpos, L, 0.08, 1.0);\n        \n        float streaks = (streakynoise(sin(N.y - 3.14) + cos(0.17 * N.x) * sin(0.17 * N.z)) + 0.7);\n        mat3 crotY = mat3(0.0, 0.0, 1.0, 0.0, 1.0, 0.0, -1.0, 0.0, 0.0);\n        vec3 cN = crotY * N;\n        float clouds = cloudnoise(vec2(atan(cN.y / cN.x), acos(cN.z)) * 4.0 + vec2(iTime * 0.4));\n              clouds += cloudnoise(vec2(atan(cN.y / cN.x), acos(cN.z)) * 2.0 - vec2(iTime * 0.1));\n                \n        float lambert = max(dot(N, L), 0.0) * shade *1.5;\n        atmo *= 0.4;\n        \n\t\tfinalColour += \n              ambient\n            + lambert * vec3(0.3) * (fresnel + 0.4) *  clouds * (0.5 - streaks)\n            + mix(\n               \tstreaks * color * lambert * light_colour * 0.8, \n                halo_colour * 2.0, \n                fresnel * clamp(lambert, 0.42, 1.0));\n    }\n    \n    finalColour += vec3(0.0, 0.25, 0.4) * atmo;\n    fragColor = vec4(finalColour + vec3(0.56, 0.4, 0.4) * uv.x * uv.y * 3.0, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[409, 948, 969, 969, 1018], [1020, 1020, 1042, 1042, 1079], [1081, 1081, 1109, 1109, 1161], [1163, 1163, 1182, 1182, 1222], [1224, 1248, 1270, 1270, 2312], [2314, 2356, 2388, 2388, 3503], [3598, 3673, 3700, 3700, 3928], [3930, 3930, 3960, 3960, 4116], [4118, 4159, 4188, 4188, 4489], [4491, 4491, 4520, 4520, 4784], [4786, 4786, 4807, 4807, 4866], [4868, 4868, 4889, 4889, 4951], [4953, 4953, 4990, 4990, 5018], [5020, 5020, 5049, 5049, 5306], [5308, 5308, 5332, 5496, 5789], [5791, 5791, 5830, 5830, 6057], [6059, 6121, 6195, 6195, 6472], [6475, 6475, 6532, 6532, 8524]], "test": "untested"}
{"id": "ltlGDX", "name": "Rocky coast", "author": "guil", "description": "A rocky coast, summertime.\nIn fact, a sum of sine wave.", "tags": ["3d", "sea", "rocks"], "likes": 17, "viewed": 470, "published": "Public", "date": "1425860036", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte \n\n\n\n#define time -iTime\nfloat dh = 0.;\n\n                                 \nmat2 m2 = mat2(0.8,  0.6, -0.6,  0.8);\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn res/3.;\n}\n\n\nfloat fbmabs( vec2 p ) {\n\tp *=.5;\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += abs(noise( p*f ))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.04)*r;\n\t}\n\treturn r;\n}\n\nfloat sea( vec2 p ) \n{\n\tfloat f=1.;   \n\tfloat r = 0.0;\t\n    for(int i = 0;i<8;i++){\t\n\t\tr += (1.-abs(noise( p*f +.9*time)))/f;       \n\t    f *=2.;\n        p-=vec2(-.01,.04)*r;\n\t}\n\treturn r/4.+.5;\n}\n\n\n\nfloat rocks(vec2 p){\n   \n    return 1.5*fbmabs(p);   \n}\n\nfloat map( vec3 p)\n{\n\tfloat d1 =p.y-.1*p.z+.2-.4*fbmabs(p.xz);\n    float d2 =p.y-.4*sea(p.xz);\n    dh = d2-d1;\n    float d = min(d1,d2);\n\treturn d;\t\n       \t\n}\n\nvec3 normalRocks(in vec2 p)\n{\n\tconst vec2 e = vec2(0.004, 0.0);\n\treturn normalize(vec3(\n\t\trocks(p + e.xy) - rocks(p - e.xy),\n        .05,//.008,\n\t\trocks(p + e.yx) - rocks(p - e.yx)\n\t\t));\n}\n\nvec3 normalSea(in vec2 p)\n{\n\tconst vec2 e = vec2(0.002, 0.0);\n\treturn normalize(vec3(\n\t\tsea(p + e.xy) - sea(p - e.xy),\n        .004,\n\t\tsea(p + e.yx) - sea(p - e.yx)\n\t\t));\n}\n\nvec3 sky(in vec2 p)\n{\t\n\treturn sin(vec3(1.7,1.5,1)+1. + .45*fbmabs(p*4.+.02*time));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 30.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 128; i++)\n    {\n        if(h < precis*t || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 transform(in vec3 p)\n{\n    \n    p.zx = p.xz;\n    p.z=-p.z;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.);\n   \tvec3 rd = normalize(vec3(p, -2.));\n\tvec3 ro = vec3(0.0, 2.0, -2.+.2*time);\n    vec3 li = normalize(vec3(-2., 2., -4.));\n    ro = transform(ro);\n\trd = transform(rd);\n    \n    \n    \n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        if(dh<0.)t-=dh;\n        vec3 pos = ro + t * rd;\n        \n        float k=rocks(pos.xz);\n        \n        vec3 nor = normalRocks(pos.xz);\n        float r = max(dot(nor, li),0.05)/2.;\n        if(dh<0.&&dh>-.1)r+=.5*exp(20.*dh);\n        \n        vec3 col1 =vec3(r*k*k, r*k, r*.8);\n        if(dh<0.05){\n        \tvec3 nor = normalSea(pos.xz);\n        \tnor = reflect(rd, nor);\n        \tcol1 += pow(max(dot(li, nor), 0.0), 5.0)*vec3(.8);\n        \tcol1 +=.2* sky(nor.yz);\n        }\n\t    col = .1+col1;\n        \n\t}\n    else //sky\n        col = sky(rd.xz*(rd.y+.2));\n    \n   \tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltlGDX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 227, 250, 250, 425], [428, 428, 452, 452, 616], [618, 618, 640, 640, 814], [818, 818, 838, 838, 873], [875, 875, 895, 895, 1034], [1036, 1036, 1065, 1065, 1224], [1226, 1226, 1253, 1253, 1398], [1400, 1400, 1421, 1421, 1485], [1487, 1487, 1524, 1524, 1821], [1823, 1823, 1850, 1850, 1902], [1904, 1904, 1961, 1961, 2890]], "test": "untested"}
{"id": "lts3DX", "name": "Lights + Water", "author": "felixisdev", "description": "my lights shader combined with my water shader with some extra waves", "tags": ["wavelightwater"], "likes": 3, "viewed": 196, "published": "Public", "date": "1425875404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sine(float value)\n{\n    return (sin(value) + 1.0) / 2.0;\n}\n\nconst int amount = 8;\n\nvec3 getPixel(vec2 pos)\n{\n    vec3 mix = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < amount; i++)\n    {\n        float lx = sin(iTime * 1.43 + float(i) * 5.43) * 665.0;\n        float ly = sin(iTime * 1.76 + float(i) * 7.34) * 454.0;\n        float lgx = iResolution.x / 2.0 - pos.x - lx;\n        float lgy = iResolution.y / 2.0 - pos.y - ly;\n        float mul = (1.0 - (lgx * lgx + lgy * lgy) / (200000.0 + sin(iTime * 0.35 + float(i) * 324.0) * 40000.0));\n        if (mul > 0.0) mix += vec3(sine(float(i) * 2.43 + 0.42), sine(float(i) * 4.24 + 1.54), sine(float(i) * 5.82 + 1.43)) * mul;\n    }\n    \n    return mix;\n}\n\nvec4 mixVec4(vec4 vf, vec4 vt, float mix)\n{\n    if (mix < 0.0) mix = 0.0;\n   \tif (mix > 1.0) mix = 1.0;\n    \n    return vec4(vf.r + (vt.r - vf.r) * mix, \n                vf.g + (vt.g - vf.g) * mix, \n                vf.b + (vt.b - vf.b) * mix, \n                vf.a + (vt.a - vf.a) * mix);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 ps = vec2(fragCoord.x, iResolution.y - 1.0 - fragCoord.y);\n    \n    float height = 240.0 + sin(iTime + ps.x / 200.0) * 200.0 + sin(iTime + ps.x / 100.0) * 100.0 + sin(iTime + ps.x / 20.0) * 4.0;\n    \n    vec2 dist = ps;\n    vec2 light = ps;\n    \n    if (ps.y >= height + 7.0)\n    {\n        dist.x += sin(dist.y / 80.0 + iTime) * 48.0;\n        dist.y += sin(dist.x / 80.0 + iTime) * 48.0;\n        light.x += sin(light.y / 40.0 + iTime) * 24.0;\n        light.y += sin(light.x / 40.0 + iTime) * 24.0;\n    }\n    \n\tfragColor = vec4(getPixel(dist), 1.0);\n    \n    if (ps.y >= height)\n    {\n        float sm = ((ps.y - height) / 1.5);\n        if (sm > 1.0) sm = 1.0;\n        \n        float f = 0.75 - ((ps.y - height - 7.0) / 600.0);\n        if (f < 0.25) f = 0.25;\n        \n        fragColor = mixVec4(fragColor, vec4(0.5, 0.9, 1.0, 1.0), f * sm);\n        \n        f = mod((ps.x - ps.y) / 100.0, 1.0);\n        \n        float inten = 0.5 + sin((ps.x - ps.y) / 40.0) * 0.25 + sin((ps.x - ps.y) / 74.0) * 0.125;\n        \n        fragColor = mixVec4(fragColor, vec4(1.0, 1.0, 1.0, 1.0), \n                                (1.0 - ((light.y - height - 600.0) / (213.0 + sin(light.x / 124.0) * 47.0))) * \n                                ((sin(light.x / 63.0) + 1.0) / 2.0) * ((sin(iTime + sin(light.x / 52.0)) + 1.0) / 2.0)\n                           * inten * 0.25 * sm);\n        \n        fragColor = mixVec4(fragColor, vec4(1.0, 0.95, 0.9, 1.0), \n                                (1.0 - ((light.y - height - 7.0) / (200.0 + sin(light.x / 100.0) * 50.0))) * \n                                ((sin(light.x / 76.0) + 1.0) / 2.0) * ((sin(iTime + sin(light.x / 46.0)) + 1.0) / 2.0)\n                           * (f > inten ? 1.0 : 0.0) * sm);\n        \n        if (ps.y >= height && ps.y < height + 8.0)\n        {\n            fragColor = mixVec4(fragColor, vec4(0.75, 0.9, 1.0, 1.0), (1.0 - (ps.y - height) / 10.0) * sm);\n            fragColor = mixVec4(fragColor, vec4(1.0, 1.0, 1.0, 1.0), (1.0 - (ps.y - height) / 10.0) * sm * sine(ps.x / 30.0 + ps.y / 4.0));\n        }\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lts3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 64], [89, 89, 114, 114, 710], [712, 712, 755, 755, 1002], [1004, 1004, 1061, 1061, 3171]], "test": "untested"}
{"id": "ltS3Rm", "name": "Vector Shapes with even-odd wind", "author": "klk", "description": "2D shapes with even-odd winding rule and antialiasing\nKeys 1 and 2 toggle outline and blur respectively\nLMB pressed -- draw red triangles and change some params\nEnjoy.", "tags": ["2d", "antialiasing", "vector", "windingrule"], "likes": 5, "viewed": 1552, "published": "Public API", "date": "1427803554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// I love HLSL for type consistency\n// float is one dimensional\n// float2 is two dimensional\n// float3 is three dimensional\n\n#define float3 vec3\n#define float2 vec2\n#define float4 vec4\n\n#define KEY_1 49\n#define KEY_2 50\n#define KEY_3 51\n\nbool keyToggled(int key)\n{\n\treturn texture(iChannel2,float2((float(key)+0.5)/256.0,0.75)).x>0.0;\n}\n\nconst float pi=3.14159265359;\n\nprecision highp float;\n\nfloat3 h2rgb(float h)\n{\n    return clamp(2.0-abs(mod(h*3.0+float3(0.0,0.0,2.0),3.0)-float3(2.0,1.0,2.0))*2.0,0.0,1.0);\n}\n\nfloat Draw(float2 p0, float2 p1, float2 uv)\n{\n    float2 dp=normalize(p1-p0);\n    float2 dpp=float2(dp.y, -dp.x);\n    float l=abs(dot(dpp,uv-p0));\n    if((dot(dp,uv-p0)<0.0))\n        l=length(uv-p0);\n    if((dot(-dp,uv-p1)<0.0))\n        l=length(uv-p1);\n    return l;\n}\n\n\nfloat Fill(float2 _p0, float2 _p1, float2 uv)\n{\n    float2 p0;\n    float2 p1;\n    if(_p0.y<_p1.y)\n    {\n        p0=_p0;\n        p1=_p1;\n    }\n    else\n    {\n        p0=_p1;\n        p1=_p0;\n    }\n    if(uv.y<p0.y)\n        return 0.0;\n    if(uv.y>=p1.y)\n        return 0.0;\n    float2 dp=p1-p0;\n    float2 du=uv-p0;\n    if(dot(float2(dp.y,-dp.x),du)>0.0) \n        return 0.0;\n    return 0.5;\n}\n\nfloat s=0.0; \nfloat l=1.0;\nfloat line;\nfloat shape;\nfloat2 CP0;\nfloat2 CP;\nfloat2 uv;\nfloat size;\n\nvoid BeginShape()\n{\n    s=0.0; \n    l=1.0;\n}\n\nvoid MoveTo(float2 p)\n{\n    CP0=CP=p;\n}\n\nvoid LineTo(float2 p)\n{\n    l=min(l,Draw(CP,p,uv));\n    s+=Fill(CP,p,uv);\n    CP=p;\n}\n\nvoid CloseShape()\n{\n    LineTo(CP0);\n}\n\nvoid FinishShape()\n{\n    s=fract(s)*2.0;\n    float l0=sqrt(l*l*size*size);\n    if(keyToggled(KEY_2))\n        l0*=0.2;\n    l=clamp(1.0-2.0*l0,0.0,1.0)*0.5;\n    shape=abs(s-l);\n    line=clamp(1.0-l0,0.0,1.0);\n}\n\nfloat sx;\nfloat sy;\n\nfloat2 F(float t)\n{\n    t*=0.06;\n\treturn float2(cos(t),sin(t))*sin(t*sy)*sin(t*sx)*0.45;\n}\n\nfloat3 gmix(float3 c1, float3 c2, float v)\n{\n    float3 gamma=float3(2.2);\n    if(keyToggled(KEY_3))\n    {\n    \treturn pow(mix(pow(c1,gamma),pow(c2,gamma),v),1.0/gamma);\n    }\n    else\n    \treturn mix(c1,c2,v);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    size=min(iResolution.x, iResolution.y);\n    float2 mp=iMouse.xy/iResolution.xy-0.5;\n    mp.x=mp.x*iResolution.x/iResolution.y;\n\n    float t=iTime*0.25;\n\tuv = fragCoord.xy/iResolution.xy-0.5;\n    uv.x=uv.x*iResolution.x/iResolution.y;\n    \n    \n\tsx=(mp.x)*5.0;\n\tsy=(mp.y)*5.0;\n    \n    sx+=sin(3.0-t*13.0/100.0)*5.0;\n    sy+=sin(5.0+t*14.0/100.0)*5.0;\n\n    BeginShape();\n    MoveTo(float2(0));\n    for(int i=1;i<450;i++)\n    {\n        LineTo(F(float(i)));\n    }\n    CloseShape();\n    FinishShape();\n\n    float3 col0=1.0-0.5*h2rgb(atan(uv.x,uv.y)/pi/2.0);\n    float3 col1=h2rgb(atan(uv.x,uv.y)/pi/2.0);\n    float3 col2=float3(0);\n\n    fragColor=float4(col0,1.0);\n    fragColor.rgb=gmix(fragColor.rgb,col1,shape);\n   \tif(keyToggled(KEY_1))\n    \tfragColor.rgb=gmix(fragColor.rgb,col2,line);\n\n    BeginShape();\n    if(iMouse.z>0.0)\n    {\n        MoveTo(float2(0));\n        LineTo(float2(0,0.5));\n        LineTo(float2(0.5,0));\n        CloseShape();\n\n        MoveTo(mp*float2(0.5,0.7));\n        LineTo(mp*float2(0.8,0.3));\n        LineTo(mp);\n        CloseShape();\n        FinishShape();\n\n        fragColor.rgb=gmix(fragColor.rgb,float3(1,0,0),shape*0.5);\n        if(keyToggled(KEY_1))\n            fragColor.rgb=gmix(fragColor.rgb,float3(0,0,0),line);\n    }\n       \n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 2, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltS3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 238, 264, 264, 336], [393, 393, 416, 416, 513], [515, 515, 560, 560, 784], [787, 787, 834, 834, 1178], [1279, 1279, 1298, 1298, 1323], [1325, 1325, 1348, 1348, 1364], [1366, 1366, 1389, 1389, 1451], [1453, 1453, 1472, 1472, 1491], [1493, 1493, 1513, 1513, 1701], [1724, 1724, 1743, 1743, 1814], [1816, 1816, 1860, 1860, 2028], [2030, 2030, 2087, 2087, 3353]], "test": "untested"}
{"id": "lts3zN", "name": "Flow Body", "author": "KazimirO", "description": "Potential flow around a Rankine body.  Undefine DOTS to see the checker grid.", "tags": ["flow", "dipole", "potential", "rankinebody"], "likes": 16, "viewed": 403, "published": "Public", "date": "1427521212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define DOTS\nconst float LN2 = 0.693147181;\t// natural log of 2 used to convert Log2 to LogE\nconst float SourceMag = 2.55;\nconst float SinkMag = -SourceMag;\nconst float divs = 50.0;\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 div = vec2( divs, divs*iResolution.y/iResolution.x );\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\t\t\t\t\t\t\t\t\t// center on screen\n    vec2 p = div*uv;\n   \tvec2 q; \n    vec2 d = vec2( 8.0, 0.0 );\n    \n\t// Velocity Potential in x, Stream fn in y, \n    vec2 S;\n    \n    // init with position to get horizontal flow\n    S = p;\t\n\tS.x -= iTime*5.0;\t\t\t\t\t\t// animate stream\n    \n    // Source\n    q = p + d;\n    S.x += SourceMag*log2(dot(q,q))*LN2*0.5;\n\tS.y += SourceMag*atan(q.y,q.x);\n\n    // Sink\n    q = p - d;\n    S.x += SinkMag*log2(dot(q,q))*LN2*0.5;\n\tS.y += SinkMag*atan(q.y,q.x);\n\n//\tCorner flow\n//\tS.x = (p.x + p.y)*(p.x - p.y)*0.5;\t\t\t// \"velocity potential\"\n//\tS.y = p.x*p.y;\t\t\t\t\t\t\t\t// stream function\n\n\tvec2 sxy;\n    float a;\n#ifdef DOTS\n    sxy = abs( sin(3.14159265*S) );\n    a = sxy.x * sxy.y;\t\t\t\t\t\t\t// combine sine waves using product\n    float b = length(fwidth(sxy))*0.7071;\t\t// jacobian magnitude\n    float t = 0.8;\t\t\t\t\t\t\t\t// threshold\n\ta = smoothstep( t-b, t+b, a );\t\t\t\t// blend across threshold\n//\ta = mix( t-b, t+b, a );\n#else\n\tsxy = sin(3.14159*S);\n    vec2 b = fwidth(sxy)*0.7071;\t\t\t\t// jacobian\n\tsxy = smoothstep( -b, b, sxy );\n    sxy = 2.0*sxy - 1.0;\t\t\t\t\t\t// remap to [-1..1]\n    a = 0.5*(sxy.x * sxy.y) + 0.5;\t\t\t\t// combine sine waves and remap to [0..1]\n#endif\n    \n    float c = sqrt( a );\t\t\t\t\t\t// correct for gamma\n\tfragColor = vec4(c, c, c, 1.0);\n//\tfragColor = vec4(c, sxy.x, sxy.y, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lts3zN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 187, 244, 244, 1674]], "test": "untested"}
{"id": "ltsGDj", "name": "Escaping Blob", "author": "echophon", "description": "shadeaday", "tags": ["shadeaday"], "likes": 4, "viewed": 149, "published": "Public", "date": "1425364234", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//edit of http://glslsandbox.com/e#22535.0\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 resolution = iResolution;\n    float time = iTime/2.0;\n    vec2 p=(2.*fragCoord.xy-resolution.xy) / resolution.y;\n\tfloat l = length(p)*4.;\n\tvec2 rm = vec2( acos( cos(time/1.-l) * l ), asin( sin(time/0.25-l) * .5 * l ) / dot(p,p*l));\n\tp = vec2( p.x*rm.x - p.y*rm.y, p.x*rm.y - p.y*rm.x / 1.-dot(p,p/l));\n\t\t\n    float b=abs(l-2.0)+(cos(15.*(atan(p.x,p.x*dot(rm,p)))))*.13;\n\n    fragColor = vec4(b,abs(.8-b),1.-b, 1.4 );\n\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltsGDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 92, 149, 149, 579]], "test": "untested"}
{"id": "ltSGRw", "name": "Permutations", "author": "baldand", "description": "All 40320 permutations of 8 items. Takes about 10 minutes.\n\nEach row has a different combination (permutation) of the same 8 items. ", "tags": ["2d", "permutations"], "likes": 2, "viewed": 1108, "published": "Public API", "date": "1427546751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Permutations \n// Copyright (c) Andrew Baldwin 2015\n// This work is licensed under a Creative Commons Attribution 4.0 International License.\n\n/*\nCalculation permuted value a from o items\nwith permutation number p\np has up to 16 values each mod(index+2)\nThis can calculate unique permutations for up to 17 items\n17! (355,687,428,096,000) combinations\nHere we only use 8 items\n*/\nfloat perm(mat4 p,float a,float o) {\n    float sa = floor(a)+1.;\n    float fi = 0.;\n    for (int y=0;y<4;y++) {\n        for (int x=0;x<4;x++) {\n            int i = y*4+x;\n            fi = float(i);\n            if (fi>(o-3.0)) {\n                sa = floor(mod(p[y][x]+sa,o));\n                break;\n            }\n        \tsa = (1.0+floor(mod(fi + p[y][x] + sa,fi+2.0)))\n                *step(o-2.0-fi,a);\n        }\n        if (fi>(o-3.0)) break;\n    }\n    return sa;\n}\n\nvec4 colour(float index) {\n    float blue = mod(index,2.0);\n    float green = mod(floor(index*0.5),2.0);\n    float red = mod(floor(index*0.25),2.0);\n    return vec4(red,green,blue,1.0);    \n}\n\nvec4 tilecolour(vec2 block) {\n    vec4 v = vec4(0,0,0,0);\n    mat4 p; p[0]=v;p[1]=v;p[2]=v;p[3]=v; \n    p[0][0]=mod(floor(block.y),2.);\n    p[0][1]=mod(floor(block.y/2.),3.);\n    p[0][2]=mod(floor(block.y/6.),4.);\n    p[0][3]=mod(floor(block.y/24.),5.);\n    p[1][0]=mod(floor(block.y/120.),6.);\n    p[1][1]=mod(floor(block.y/720.),7.);\n    p[1][2]=mod(floor(block.y/5040.),8.);\n    float index = block.x;\n    float permindex = perm(p,index,8.);\n    vec4 stone = (0.9+0.1*texture(iChannel1,block*.1));\n\treturn (0.2+0.8*colour(permindex))*stone;\n}\n\nvec4 tile(vec2 block) {\n    vec2 intile = fract(block);\n    float l = length(2.0*(intile-0.5));\n    float ls = 1.0-length(2.0*(intile-0.5)-.1);\n    float s = max(intile.x+intile.y,0.);\n    vec4 c = tilecolour(block)*(1.2-l*s);\n    c.a = smoothstep(0.85,0.9,l);\n    c = mix(c,vec4(0.,0.,0.,.5+.5*smoothstep(.3,.0,ls)),c.a);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.x;\n    vec2 block = (uv*8.0);\n    block.y = block.y;\n    block = (block + vec2(0.,iTime*100.-1000.0*sin(iTime*.1)));\n    float speed = 1.-cos(iTime*.1);\n    vec4 m = vec4(0.);\n    for (int i=0;i<10;i++) {\n        vec2 s = vec2(0.,float(i)*speed*.05);\n\t    vec4 t = tile(block+s);\n\t    vec4 b = texture(iChannel0,(block+s)*.2);\n        m += mix(t,b,t.a);\n    }\n    fragColor = m*.1;\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSGRw.jpg", "access": "shaders20k", "license": "cc-by-sa-4.0 WITH generic-exception", "functions": [[144, 380, 416, 416, 847], [849, 849, 875, 875, 1040], [1042, 1042, 1071, 1071, 1587], [1589, 1589, 1612, 1612, 1927], [1929, 1929, 1986, 1986, 2408]], "test": "untested"}
{"id": "ltSGzD", "name": "RiseAndShine!", "author": "kuvkar", "description": "A rising sun 2D effect. It's my take on http://blog.camposanto.com sun effect. I didn't get the textures perfectly, but it looks nice I think.", "tags": ["2d", "noise", "sun", "texturing"], "likes": 8, "viewed": 409, "published": "Public", "date": "1427237828", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 sun;\n#define GRADIENT_Y 0.1 \n\n// \n#define SUNCOLOR vec4(1.0, 0.6, 0.3, 0.0)\n\n// SET TO CONTROL WITH MOUSE\n// #define MOUSE_CONTROL\n\n// DISABLE / ENABLE COLOR CYCLING\n//#define COLOR_CYCLING\n\nvec4 suncolor = SUNCOLOR;\n\nfloat snoise(vec3 uv, float res)\n{\n\tconst vec3 s = vec3(1e0, 1e2, 1e3);\n\t\n\tuv *= res;\n\t\n\tvec3 uv0 = floor(mod(uv, res))*s;\n\tvec3 uv1 = floor(mod(uv+vec3(1.), res))*s;\n\t\n\tvec3 f = fract(uv); f = f*f*(3.0-2.0*f);\n\n\tvec4 v = vec4(uv0.x+uv0.y+uv0.z, uv1.x+uv0.y+uv0.z,\n\t\t      \t  uv0.x+uv1.y+uv0.z, uv1.x+uv1.y+uv0.z);\n\n\tvec4 r = fract(sin(v*1e-1)*1e3);\n\tfloat r0 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\tr = fract(sin((v + uv1.z - uv0.z)*1e-1)*1e3);\n\tfloat r1 = mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y);\n\t\n\treturn mix(r0, r1, f.z)*2.-1.;\n}\n\nvec4 sunhalo(vec2 uv)\n{\n    vec4 col = vec4(0.0);\n    if(uv.y < GRADIENT_Y)\n    {\n        return col;\n    }\n    float limit = (1.0 + sin((uv.x + sun.x) * 3.14159)) * 0.5;\n    float l = (limit - uv.y - sun.y);\n    float distToSun = length (uv - vec2(0.5, 0.5) + sun);\n    \n    float r = 1.0 - distToSun;\n    r = pow(r, 1.1);\n    r *= l;\n    r *= 1.5;\n    r = clamp(r, 0.0, 1.0);\n    \n    col = suncolor * r;\n    col = clamp(col, 0.0, 1.0);\n    return col;\n}\n\nvec4 sundisc (vec2 uv)\n{\n    vec4 col = vec4(0.0);\n\n    if(uv.y < GRADIENT_Y)\n    {\n        return col;\n    }\n    \n    float sunw = 0.11;\n    \n    // disk\n    vec2 p = uv - vec2(0.5);\n    float distToSun = length(sun + p);\n    float r = 1.0 - smoothstep(sunw - 0.05, sunw, distToSun);\n    r = clamp(r, 0.0, 1.0);\n    col = suncolor * r;\n    \n    // rays\n    float an = atan(sun.x + p.x, sun.y + p.y);\n    vec2 noiseuv = vec2(an, distToSun - iTime * 0.1);\n    float r2 = 1.0 - smoothstep(sunw - 0.05, sunw + 0.10, distToSun);\n    float rays = mix(snoise(vec3(noiseuv, 0.0), 13.0), 1.0, 0.84) * r2;\n    col += vec4(rays);\n    col = clamp(col, 0.0, 1.0);\n    \n    // texture\n    float tex = texture(iChannel0, (sun + uv + vec2(iTime * 0.02, 0.0)) * 8.0 ).r;\n    tex *= r * 0.8;\n    col -= tex;\n    return col;\n}\n\n\nvec4 horizon(vec2 uv)\n{\n    vec4 col = vec4(0.0);\n    \n    float d = distance(vec2(0.0, uv.y), vec2(0.0, GRADIENT_Y));\n    float r = smoothstep(0.05, 0.0, d);\n    float r2 = smoothstep(0.2, 0.0, d);\n    \n    col.g = r * 0.4;\n    col.r = r * 0.7;\n    //col *= 0.5;\n    \n    float amount = 0.4;\n    col += suncolor * r2 * amount;\n    \n    col = clamp(col, 0.0, 1.0);\n    return col;\n}\n\nvec4 ground(vec2 uv)\n{\n    vec4 col = vec4(0.0);\n    if(uv.y > GRADIENT_Y)\n    {\n        return col;\n    }\n    // ground color\n    float d = GRADIENT_Y - length(vec2(0.0, GRADIENT_Y) - vec2(0.0, uv.y));\n    d *= 15.0;\n    d = pow(d, 2.0);\n    \n    // falloff\n    vec2 p = uv - vec2(0.5);\n    d *= 1.0 - pow(length(sun + p), 0.75);\n    \n    col = suncolor * d;\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv.y /= 1.7;\n    float sunspeed = 0.3;\n#ifdef MOUSE_CONTROL\n\n    sun = vec2(iMouse.x / iResolution.x, iMouse.y / iResolution.y) - vec2(0.5);\n#else\n    sun = vec2(0.0, 0.0);\n    sun.y += 0.1 + sin (iTime * sunspeed + 2.0) * 0.1;\n#endif\n    \n    sun *= 4.0;\n#ifdef COLOR_CYCLING\n    suncolor.b += (sin(iTime * 0.05) + 0.5 ) * 0.5;\n    suncolor.r -= (sin(iTime * 0.05) + 0.5 ) * 0.5;\n#endif\n    \n    fragColor += sunhalo(uv);\n    fragColor += horizon(uv);\n    fragColor += ground(uv);\n    fragColor += sundisc(uv);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltSGzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 223, 257, 257, 781], [783, 783, 806, 806, 1239], [1241, 1241, 1265, 1265, 2049], [2052, 2052, 2075, 2075, 2434], [2436, 2436, 2458, 2458, 2818], [2820, 2820, 2877, 2877, 3464]], "test": "untested"}
{"id": "ltXGRN", "name": "Fractal Experiment 2", "author": "aiekick", "description": "Fractal Experiment 2", "tags": ["fractalexperiment2"], "likes": 2, "viewed": 1115, "published": "Public API", "date": "1427496164", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define Iterations 150\n\nprecision highp float;\n\nfloat metaline(vec2 p, vec2 o, float thick, vec2 l){\n    vec2 po = 2.*p+o;\n    return thick / dot(po,vec2(l.x,l.y));\n}\nfloat metaball(vec2 p, vec2 o, float radius){\n    vec2 po = p-o;\n\treturn radius / dot(po, po);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // vars / time\n    float speed = 0.5;\n    float t0 = iTime*speed;\n    float t1 = sin(t0);\n    float t2 = 0.5*t1+0.5;\n    float t3 = 0.5*sin(iTime*0.1)+0.5;\n    float zoom=1.;\n    \n    // uv\n    float ratio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;uv.x*=ratio;uv*=zoom;\n    vec2 mo = iMouse.xy / iResolution.xy*2.-1.;mo.x*=ratio;mo*=zoom;\n\n    // cadre\n    float thick=0.05;\n    float inv=1.;\n\tfloat bottom = metaline(uv,vec2(0.,2.)*zoom, thick, vec2(0.0,1.*inv));\n\tfloat top = metaline(uv,vec2(0.,-2.)*zoom, thick, vec2(0.0,-1.*inv));\n\tfloat left = metaline(uv,vec2(2.*ratio,0.)*zoom, thick, vec2(1.*inv,0.0));\n\tfloat right = metaline(uv,vec2(-2.*ratio,0.)*zoom, thick, vec2(-1.*inv,0.0));\n\tfloat rect=bottom+top+left+right;\n    \n    // map\n    vec2 uvt = uv;\n    \n    // julia\n    float ratioIter = 1.;\n    float ratioTime = t0;\n    if ( iMouse.z > 0. ) {\n        ratioIter = iMouse.y/iResolution.y;\n        ratioTime = iMouse.x/iResolution.x*2.-1.;\n    }\n    int nIter = int(floor(float(Iterations)*ratioIter));\n    float lX = -0.79;\n    float lY = sin(ratioTime)*0.114;\n    float julia0 = 0., julia1 = 0., x = 0., y = 0., j=0.;\n\tfor(int i=0; i<Iterations; i++) \n    {\n        if ( i == nIter ) break;\n        x = (uvt.x * uvt.x - uvt.y * uvt.y) + lX;\n        y = (uvt.y * uvt.x + uvt.x * uvt.y) + lY;\n        uvt.x = x;\n        uvt.y = y;\n       \tj = mix(j, length(uvt*0.2)/dot(x,y*x), y/x*0.2);\n        if ( j >= 0.2 && j <= 8.5) julia0 += metaball(uv,vec2(0.), j);\n        else julia1 += metaball(uv,vec2(0.), j);\n    }\n    \n    float julia = julia0-julia1*0.01;\n    \n   \tfloat rt = t1*0.5;\n    float gt = t1*0.5;\n    float bt = t1*0.5;\n    \n    // color\n   \tfloat d = julia+rect;\n    float r = mix(1./d, d, abs(rt));\n    float g = mix(r, d, abs(gt));\n    float b = mix(g, d, abs(bt));\n    vec3 c = vec3(r,g,b);\n\tfragColor.rgb = vec3(c*0.001);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXGRN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 186, 238, 238, 304], [305, 305, 350, 350, 401], [402, 402, 458, 477, 2350]], "test": "untested"}
{"id": "ltXGzN", "name": "Fractal Experiment 3", "author": "aiekick", "description": "Fractal Experiment 3", "tags": ["fractalexperiment3"], "likes": 1, "viewed": 1104, "published": "Public API", "date": "1427496178", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define Iterations 150\n\nfloat metaline(vec2 p, vec2 o, float thick, vec2 l){\n    vec2 po = 2.*p+o;\n    return thick / dot(po,vec2(l.x,l.y));\n}\nfloat getJulia(vec2 coord, int iter, float time, float seuilInf, float seuilSup){ \n    vec2 uvt = coord;\n    float lX = -0.78;//-0.74;\n    float lY = time*0.115;//0.11\n    float julia = 0., x = 0., y = 0., j=0.;\n\tfor(int i=0; i<Iterations; i++) \n    {\n        if ( i == iter ) break;\n        x = (uvt.x * uvt.x - uvt.y * uvt.y) + lX;\n        y = (uvt.y * uvt.x + uvt.x * uvt.y) + lY;\n        uvt.x = x;\n        uvt.y = y;\n       \tj = mix(julia, length(uvt)/dot(x,y), 1.);\n        //if ( j >= seuilInf && j <= seuilSup ) \n            julia = j;\n    }\n    return julia;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // vars / time\n    float speed = 0.5;\n    float t0 = iTime*speed;\n    float t1 = sin(t0);\n    float t2 = 0.5*t1+0.5;\n    float t3 = 0.5*sin(iTime*0.1)+0.5;\n    float zoom=1.;\n    \n    // uv\n    float ratio = iResolution.x/iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;uv.x*=ratio;uv*=zoom;\n    vec2 mo = iMouse.xy / iResolution.xy*2.-1.;mo.x*=ratio;mo*=zoom;\n\n    // cadre\n    float thick=0.3;\n    float inv=1.;\n\tfloat bottom = metaline(uv,vec2(0.,2.)*zoom, thick, vec2(0.0,1.*inv));\n\tfloat top = metaline(uv,vec2(0.,-2.)*zoom, thick, vec2(0.0,-1.*inv));\n\tfloat left = metaline(uv,vec2(2.*ratio,0.)*zoom, thick, vec2(1.*inv,0.0));\n\tfloat right = metaline(uv,vec2(-2.*ratio,0.)*zoom, thick, vec2(-1.*inv,0.0));\n\tfloat rect=bottom+top+left+right;\n    \n    // map\n    vec2 uvt = uv;\n    \n    // julia\n    float ratioIter = 1.;\n    float ratioTime = t1;\n    if ( iMouse.z > 0. ) {\n        ratioIter = iMouse.y/iResolution.y;\n        ratioTime = iMouse.x/iResolution.x*2.-1.;\n    }\n    int nIter = int(floor(float(Iterations)*ratioIter));\n    float julia = getJulia(uvt, nIter, ratioTime, 0.2, 8.5); // default => 0.2 / 6.5\n    \n    // color\n    float d0 = julia+rect;\n    float d = smoothstep(d0-45.,d0+4.,1.);\n    float r = mix(1./d, d, 1.);\n    float g = mix(1./d, d, 3.);\n    float b = mix(1./d, d, 5.);\n    vec3 c = vec3(r,g,b);\n    \n    fragColor.rgb = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ltXGzN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 162, 214, 214, 280], [281, 281, 362, 362, 850], [851, 851, 907, 926, 2286]], "test": "untested"}
{"id": "Ml23zh", "name": "20150322_orthoTest", "author": "FMS_Cat", "description": "ortho is likely to traffic accident\nmouse x : turn\nmouse y : perspective - ortho", "tags": ["2d", "raymarching", "ortho"], "likes": 6, "viewed": 243, "published": "Public", "date": "1427012693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\n#define t iTime\n#define r iResolution.xy\n#define c fragCoord\n#define v vec2(0.,1.)\n\nfloat box( in vec3 _p )\n{\n    vec3 d = abs( _p ) - v.yyy*.1;\n    return min( max( d.x, max( d.y, d.z ) ), 0. ) + length( max( d, 0. ) );\n}\n\nfloat scene( in vec3 _p )\n{\n    vec3 p = _p;\n    p.z -= t*.4;\n    vec3 rep = v.yyy*.7;\n    p += rep/2.;\n    p = mod( p+rep/2., rep )-rep/2.;\n    float theta = exp( -mod( t, 4. )*4. )*PI;\n    p.xy = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) ) * p.xy;\n    p.yz = mat2( cos(theta), -sin(theta), sin(theta), cos(theta) ) * p.yz;\n    return box( p );\n}\n\nvec3 sceneNormal( in vec3 _p, in float _d )\n{\n    vec2 d = v*_d;\n    return normalize( vec3(\n        scene( _p+d.yxx ) - scene( _p-d.yxx ),\n        scene( _p+d.xyx ) - scene( _p-d.xyx ),\n        scene( _p+d.xxy ) - scene( _p-d.xxy )\n    ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (c*2.-r)/r.x;\n    float amp = iMouse.y/r.y;\n    float angle = iMouse.x/r.x*PI/2.;\n    \n    vec3 camPos = vec3( 1.*sin(angle), 0., 1.*cos(angle) );\n    vec3 camCen = v.yxx*sin( t )*.1 + v.xyx*sin( t*.73 )*.1;\n    vec3 camDir = normalize( camCen - camPos );\n    vec3 camAir = v.xyx;\n    vec3 camSid = cross( camDir, camAir );\n    vec3 camTop = cross( camSid, camDir );\n    \n    // ortho is here\n    camPos = camPos + p.x*camSid*amp*length( camPos ) + p.y*camTop*amp*length( camPos );\n    vec3 rayDir = normalize( p.x*camSid*( 1.-amp ) + p.y*camTop*( 1.-amp ) + camDir );\n    \n    float dist = 1E3;\n    float rayLen = 0.;\n    vec3 rayPos = camPos;\n    for( int i=0; i<32; i++ )\n    {\n        dist = scene( rayPos );\n        rayLen += dist;\n        rayPos = camPos + rayDir*rayLen;\n        if( abs( dist ) < 1E-3 || 1E2 < rayLen ){ break; }\n    }\n    \n    vec3 col = v.xxx;\n    if( dist < 1E-2 )\n    {\n        col = vec3( dot( vec3( .2, .3, .7 ), sceneNormal( rayPos, 1E-3 ) ) );\n    }\n    \n\tfragColor = vec4( col, 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ml23zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 131, 131, 244], [246, 246, 273, 273, 605], [607, 607, 652, 652, 850], [852, 852, 909, 909, 1938]], "test": "untested"}
{"id": "MlB3Rm", "name": "Xor - Glowing Webs", "author": "Xor", "description": "Glowing web shader.", "tags": ["2d", "noise", "worley", "glow", "xor", "web"], "likes": 8, "viewed": 305, "published": "Public", "date": "1427603200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float r(float n)\n{\n \treturn fract(cos(n*89.42)*343.42);\n}\nvec2 r(vec2 n)\n{\n \treturn vec2(r(n.x*23.62-300.0+n.y*34.35),r(n.x*45.13+256.0+n.y*38.89)); \n}\nfloat worley(vec2 P,vec2 R,float s)\n{\n    vec2 n = P+iTime*s-0.5*R;\n    float dis = 64.0;\n    for(int x = -1;x<2;x++)\n    {\n        for(int y = -1;y<2;y++)\n        {\n            vec2 p = floor(n/s)+vec2(x,y);\n            float d = length(r(p)+vec2(x,y)-fract(n/s));\n            if (dis>d)\n            {\n             \tdis = d;   \n            }\n        }\n    }\n    return pow(dis,4.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 c = fragCoord;\n    vec2 r = iResolution.xy;\n\tvec3 col = vec3(worley(c,r,32.0)+worley(c,r,36.0)+worley(c,r,44.0));\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlB3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 57], [58, 58, 74, 74, 151], [152, 152, 189, 189, 537], [538, 538, 595, 595, 748]], "test": "untested"}
{"id": "MlB3RW", "name": "2015-03-23-11-25", "author": "yastero", "description": "random", "tags": ["random"], "likes": 2, "viewed": 105, "published": "Public", "date": "1427178558", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n  float t = iTime;\n\n  vec2 uv = fragCoord.xy / iResolution.xy;\n\n  float vol = texture(iChannel0, vec2(abs(sin(t) * 100.0), 1.0)).x;\n\n  float w = 0.0;\n\n  w = sin(\n    sin(iTime * 13.5 + (3.0 * vol)) *\n    10.0 *\n    pow(\n      pow(uv.x, 1.0 + (2.0 * sin(iTime * 0.3))) + sin(uv.y *  + (19.0 * vol)) / 10.0,\n      (4.7 * sin(iTime * 0.2)) + (1.5 * sin(iTime * 0.2))\n    )\n  );\n\n  fragColor = vec4(w, w, w, 1.0);\n\n}\n", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlB3RW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 468]], "test": "untested"}
{"id": "MlB3zh", "name": "[NV15] The Barsoom Gate", "author": "jimmikaelkael", "description": "Somewhere on the red planet an ancient interstellar gate has been found.", "tags": ["raymarching", "warping", "domain", "mars", "gate"], "likes": 15, "viewed": 3337, "published": "Public", "date": "1426800418", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nvec3 skyColor = vec3(0.65, 0.28, 0.1);\nvec3 sunColor = vec3(1.8, 1.0, 0.6);\nvec3 sunLightColor = vec3(1.7, 1.25, 0.9);\nvec3 skyLightColor = vec3(0.8, 0.35, 0.15);\nvec3 indLightColor = vec3(0.4, 0.3, 0.2);\nvec3 horizonColor = vec3(0.85, 0.35, 0.15);\nvec3 sunDirection = normalize(vec3(0.6, 0.4, 0.9));\n\nfloat noise(in vec2 p) {\n    p += vec2(16.6, 17.0);\n    return texture(iChannel0, p / 256.0, -100.0).x;\n}\n\nfloat noise3d(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    vec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+.5)/256., 0.).yx;\n    return mix(rg.x, rg.y, f.z);\n}\n\nfloat fBm(in vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    for(int i = 0; i < 4; i++) {\n        sum += amp * noise(p);\n        amp *= 0.5;\n        p *= 2.5;\n    }\n    return sum * 0.5 + 0.15;\n}\n\nfloat fBm3d(in vec3 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    for(int i = 0; i < 4; i++) {\n        sum += amp * noise3d(p);\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    return sum;\n}\n\nfloat warp(in vec3 p) {\n    vec3 q, r;\n    q.x = fBm3d(p);\n    q.y = fBm3d(p + vec3(5.2,1.3,8.4));\n    q.z = fBm3d(p + vec3(2.2,5.4,7.9));\n    r.x = fBm3d(p + 2.0 * q + vec3(1.7,9.2,5.2));\n    r.y = fBm3d(p + 2.0 * q + vec3(8.3,2.8,4.8));\n    r.z = fBm3d(p + 2.0 * q + vec3(5.7,4.3,2.4));\n    return fBm3d(p + 4.0 * r);\n}\n\nfloat length2(in vec2 p) {\n    return sqrt(p.x*p.x + p.y*p.y);\n}\n\nfloat length8(in vec2 p) {\n    p = p*p; p = p*p; p = p*p;\n    return pow(p.x + p.y, 1.0 / 8.0);\n}\n\nfloat sdTorus82(in vec3 p, in vec2 t) {\n    vec2 q = vec2(length2(p.xz) - t.x, p.y);\n    return length8(q) - t.y;\n}\n\nfloat sdBox(in vec3 p, in vec3 box) {\n    vec3 d = abs(p) - box;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdTriPrism(in vec3 p, vec2 h) {\n    vec3 q = abs(p);\n    return max(q.z - h.y, max(q.x * 0.866025 + p.y * 0.5, -p.y) - h.x * 0.5);\n}\n\nfloat smin(float a, float b, float k) {\n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) / k;\n}\n\nvec3 rotateX(in vec3 p, float an) {\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(p.x, c * p.y - s * p.z, s * p.y + c * p.z);\n}\n\nvec3 rotateY(in vec3 p, float an) {\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(c * p.x + s * p.z, p.y, -s * p.x + c * p.z);\n}\n\nvec3 rotateZ(in vec3 p, float an) {\n    float c = cos(an);\n    float s = sin(an);\n    return vec3(c * p.x - s * p.y, s * p.x + c * p.y, p.z);\n}\n\nvec2 map(in vec3 p, bool frame) {\n    vec2 res = vec2(0.0, p.y - fBm(p.xz));\n    if (frame) {\n        float d1 = sdBox(rotateX(rotateY(p - vec3(0.0, 1.0, 0.0), -1.25), 1.58), vec3(0.5, 0.0, 0.5));\n        vec2 obj = vec2(1.0, max(d1, sdSphere(p - vec3(0.0, 1.0, 0.0), 0.5)));\n        if (obj.y < res.y) res = obj;\n    }\n    float d2 = sdTriPrism(rotateX(rotateY(p - vec3(0.0, 1.51, 0.0), -1.25), 3.14159), vec2(0.025, 0.055));\n    float d3 = sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.112, 0.635, 0.35), -1.25), 3.14159), 2.35), vec2(0.025, 0.055));\n    float d4 = sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.112, 0.635, -0.35), -1.25), 3.14159), -2.35), vec2(0.025, 0.055));\n    vec2 obj = vec2(2.0, smin(smin(smin(sdTorus82(rotateX(rotateY(p - vec3(0.0, 1.0, 0.0), -1.25), 1.58), vec2(0.5, 0.05)), d2, 16.0), d3, 16.0), d4, 16.0));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.0, sdTriPrism(rotateX(rotateY(p - vec3(0.0, 1.51, 0.0), -1.25), 3.14159), vec2(0.025, 0.1)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.1, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.122, 1.36, 0.35), -1.25), 3.14159), 0.84), vec2(0.025, 0.055)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.2, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.117, 1.36, -0.35), -1.25), 3.14159), -0.84), vec2(0.025, 0.055)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.3, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.162, 1.0, 0.49), -1.25), 3.14159), 1.6), vec2(0.025, 0.055)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.4, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.162, 1.0, -0.49), -1.25), 3.14159), -1.6), vec2(0.025, 0.055)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.5, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(-0.112, 0.635, 0.35), -1.25), 3.14159), 2.35), vec2(0.025, 0.1)));\n    if (obj.y < res.y) res = obj;\n    obj = vec2(3.6, sdTriPrism(rotateZ(rotateX(rotateY(p - vec3(0.115, 0.635, -0.35), -1.25), 3.14159), -2.35), vec2(0.025, 0.1)));\n    if (obj.y < res.y) res = obj;\n\n    return res;\n}\n\nvec2 map(in vec3 p) {\n    return map(p, true);\n}\n\nvec3 raymarchTerrain(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    float t = tmin;\n    vec3 res = vec3(-1.0);\n    float breakOut = 0.0;\n    int i = 0;\n    while (i < 10 && breakOut != 1.0) {\n        vec3 p = ro + rd * t;\n        res = vec3(map(p), t);\n        float d = res.y;\n        if (d < (0.001 * t) || t > tmax)\n            breakOut = 1.0;\n        t += 0.5 * d;\n        i++;\n    }\n    return res;\n}\n\nvec3 getTerrainNormal(in vec3 p) {\n    float eps = 0.025;\n    return normalize(vec3(fBm(vec2(p.x - eps, p.z)) - fBm(vec2(p.x + eps, p.z)),\n                          2.0 * eps,\n                          fBm(vec2(p.x, p.z - eps)) - fBm(vec2(p.x, p.z + eps))));\n}\n\nvec3 getGateNormal(in vec3 p, float e) {\n    vec2 eps = vec2(e, 0.0);\n    return normalize(vec3(map(p + eps.xyy).y - map(p - eps.xyy).y,\n                          2.0 * eps.x,\n                          map(p + eps.yyx).y - map(p - eps.yyx).y));\n}\n\nvec3 getGateBump(in vec3 p, float e) {\n    vec2 eps = vec2(e, 0.0);\n    return normalize(vec3(fBm3d(p + eps.xyy) - fBm3d(p - eps.xyy),\n                          fBm3d(p + eps.yxy) - fBm3d(p - eps.yxy),\n                          fBm3d(p + eps.yyx) - fBm3d(p - eps.yyx)));\n}\n\n\nfloat raymarchAO(in vec3 ro, in vec3 rd, float tmin) {\n    float ao = 0.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        float t = tmin + pow(i / 5.0, 2.0);\n        vec3 p = ro + rd * t;\n        float d = p.y - fBm(p.xz);\n        ao += max(0.0, t - 0.5 * d - 0.05);\n    }\n    return 1.0 - 0.4 * ao;\n}\n\nfloat raymarchShadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    float sh = 1.0;\n    float t = tmin;\n    float breakOut = 0.0;\n    int i = 0;\n    while (i < 40 && breakOut != 1.0) {\n        vec3 p = ro + rd * t;\n        float d = p.y - fBm(p.xz);\n        sh = min(sh, 16.0 * d / t);\n        t += 0.5 * d;\n        if (d < (0.001 * t) || t > tmax)\n            breakOut = 1.0;\n        i++;\n    }\n    return sh;\n}\n\n\nfloat raymarchGateShadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    float sh = 1.0;\n    float t = tmin;\n    float breakOut = 0.0;\n    int i = 0;\n    while (i < 80 && breakOut != 1.0) {\n        vec3 p = ro + rd * t;\n        float d = map(p, false).y;\n        sh = min(sh, 16.0 * d / t);\n        t += 0.5 * d;\n        if (d < (0.001 * t) || t > tmax)\n            breakOut = 1.0;\n        i++;\n    }\n    return sh;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n\n    vec3 eye = vec3(0.0, 1.25, 1.5);\n    vec2 rot = 6.2831 * (vec2(-0.05 + iTime * 0.025, 0.0 - sin(iTime * 0.5) * 0.01) + vec2(1.0, 0.0) * (iMouse.xy - iResolution.xy * 0.25) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye;\n    vec3 ta = vec3(0.5, 1.0, 0.0);\n\n    vec3 cw = normalize(ta - ro);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));\n\n    // background\n    vec3 color = skyColor;\n\n    // terrain marching\n    float tmin = 0.1;\n    float tmax = 20.0;\n    vec3 res = raymarchTerrain(ro, rd, tmin, tmax);\n    float t = res.z;\n    if (t < tmax) {\n        vec3 pos = ro + rd * t;\n        vec3 nor;\n        // add bumps\n        if (res.x == 0.0) {\n            nor = getTerrainNormal(pos);\n            nor = normalize(nor + 0.5 * getTerrainNormal(pos * 8.0));\n        } else if (res.x == 1.0){\n            nor = getGateNormal(pos, 0.1);\n            nor = normalize(nor + 0.05 * getGateBump(pos * 4.0 + vec3(iTime * 0.25, 1.0, 1.0), 0.005));\n        } else if (res.x == 2.0){\n            nor = getGateNormal(pos, 0.005);\n            nor = normalize(nor + 0.25 * getGateBump(pos * 32.0, 0.005));\n        } else {\n            nor = getGateNormal(pos, 0.005);\n            nor = normalize(nor + 0.1 * getGateBump(pos * 16.0, 0.005));\n        }\n\n        // 3 lights rig\n        float sun = clamp(dot(sunDirection, nor), 0.0, 1.0);\n        float sky = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0);\n        float ind = clamp(dot(vec3(-sunDirection.x, 0.0, -sunDirection.z), nor), 0.0, 1.0);\n        float occ = clamp(raymarchAO(pos, nor, 0.1), 0.0, 1.0);\n        float sha1 = clamp(raymarchShadow(pos, sunDirection, 0.25, tmax), 0.0, 1.0);\n        float sha2 = clamp(raymarchGateShadow(pos, sunDirection, 0.05, tmax), 0.0, 1.0);\n\n        vec3 lightColor = 1.0 * sun * sunLightColor;\n        lightColor *= pow(vec3(sha1), vec3(1.0, 1.2, 1.5));\n        lightColor *= pow(vec3(sha2), vec3(1.0, 1.2, 1.5));\n        lightColor += 0.7 * sky * skyLightColor * occ;\n        lightColor += 0.3 * ind * indLightColor * occ;\n\n        if (res.x == 1.0) {\n            vec3 h = normalize(-rd + sunDirection);\n            float spe = pow(clamp(dot(h, nor), 0.0, 1.0), 2.0);\n            float fresnel = 1.0;\n            float fre = fresnel + (1.0 - fresnel) * pow(1.0 - dot(nor, -rd), 5.0);\n            lightColor += 32.0 * spe * sun * occ;\n            color = vec3(0.05, 0.2, 0.8) * 2.0 * warp(pos * 2.0 + vec3(iTime * 0.15, 1.0, 1.0));\n            lightColor *= pow(indLightColor, vec3(1.0)) * fre;\n        } else if (res.x == 2.0) {\n            vec3 ref = reflect(rd, -sunDirection);\n            float spe = pow(clamp(dot(ref, nor), 0.0, 1.0), 2.0);\n            float fresnel = 1.0;\n            float fre = fresnel + (1.0 - fresnel) * pow(1.0 - dot(nor, -rd), 5.0);\n            lightColor += 32.0 * spe * sun * occ;\n            color = vec3(0.1, 0.11, 0.15) * 0.05;\n            lightColor *= pow(indLightColor, vec3(1.0)) * fre;\n        } else if (res.x > 2.0) {\n            vec3 ref = reflect(rd, -sunDirection);\n            float spe = pow(clamp(dot(ref, nor), 0.0, 1.0), 2.0);\n            float fresnel = 1.0;\n            float fre = fresnel + (1.0 - fresnel) * pow(1.0 - dot(nor, -rd), 5.0);\n            lightColor += 16.0 * spe * sun * occ;\n            color = vec3(0.2, 0.1, 0.01);\n            lightColor *= pow(indLightColor, vec3(1.0)) * fre;\n        }\n\n        color *= 0.8 * lightColor;\n\n        // there no air on mars but a bit of fog is better\n        color = mix(color, horizonColor, 1.0 - exp(-0.01 * t * t));\n    } else {\n        float sunDot = clamp(dot(sunDirection, rd), 0.0, 1.0);\n        float sky = clamp(0.8 * (1.0 - 0.8 * rd.y), 0.0, 1.0);\n        float diffuse = clamp(0.4 * sunDot, 0.0, 1.0);\n        color = sky * skyColor + pow(sunDot, 2000.0) * sunColor;\n\n        // horizon\n        color = mix(color, horizonColor, pow(1.0 - rd.y, 4.0));\n    }\n\n    // gamma correction\n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor = vec4(pow(color, gamma), 1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlB3zh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 390, 414, 414, 495], [497, 497, 520, 520, 747], [749, 749, 771, 771, 952], [954, 954, 978, 978, 1148], [1150, 1150, 1173, 1173, 1471], [1473, 1473, 1499, 1499, 1537], [1539, 1539, 1565, 1565, 1636], [1638, 1638, 1677, 1677, 1753], [1755, 1755, 1792, 1792, 1889], [1891, 1891, 1927, 1927, 1955], [1957, 1957, 1994, 1994, 2095], [2097, 2097, 2136, 2136, 2207], [2209, 2209, 2244, 2244, 2352], [2354, 2354, 2389, 2389, 2498], [2500, 2500, 2535, 2535, 2643], [2645, 2645, 2678, 2678, 4675], [4677, 4677, 4698, 4698, 4725], [4727, 4727, 4803, 4803, 5145], [5147, 5147, 5181, 5181, 5407], [5409, 5409, 5449, 5449, 5655], [5657, 5657, 5695, 5695, 5929], [5932, 5932, 5986, 5986, 6234], [6236, 6236, 6306, 6306, 6655], [6658, 6658, 6732, 6732, 7081], [7083, 7083, 7140, 7140, 11429]], "test": "untested"}
{"id": "MlB3zz", "name": "the magic cube", "author": "Branch", "description": "the magic cube", "tags": ["themagiccube"], "likes": 4, "viewed": 257, "published": "Public", "date": "1426625419", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rotY(in float a) {\n\treturn mat3( cos(a), 0.0, sin(a),\n\t\t\t\t 0.0,    1.0, 0.0,\n\t\t\t\t-sin(a), 0.0, cos(a)\n\t\t\t    );\n}\nfloat smin( float a, float b, float k ) {\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\nfloat length2( vec2 p ) {\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p ) {\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p ) {\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\nfloat sdTorus82( vec3 p, vec2 t ){\n  vec2 q = vec2(length2(p.xz)-t.x,p.y);\n  return length8(q)-t.y;\n}\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat udBox( vec3 p, vec3 b ){\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\nfloat sdSphere( vec3 p, float s ){\n  return length(p)-s;\n}\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\n    vec3 pa = p - a , ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdHexPrism( vec3 p, vec2 h ) {\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x+q.y*0.57735,q.y*1.1547)-h.x);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat palkki(in vec3 p, out vec3 color){\n    \n    float finalDistance = 10000000.;\n    \n    finalDistance = min(finalDistance, udRoundBox( p-vec3(0.0), vec3(2.0,8.0+sin(p.x)*2.,2.0) , 0.1) );\n    vec3 p2 = p;\n    vec3 p3 = p;\n    vec3 p4 = p;\n    p2.yxz *= rotY(3.14145*0.25);\n    finalDistance = min(finalDistance, udRoundBox( (p2-vec3(2.0,0.0,0.0)), vec3(0.2,1.0,1.0) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p2-vec3(2.0,0.0,0.0)), vec3(0.4,0.8,0.8) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p-vec3(2.0,-0.8,0.0)), vec3(0.4,1.2,0.8) , 0.1 ) );\n    \n    \n    p3.zyx *= rotY(3.14145*0.5);\n    p3.yxz *= rotY(3.14145*0.25);\n    p.zyx *= rotY(3.14145*0.5);\n    finalDistance = min(finalDistance, udRoundBox( (p3-vec3(2.0,0.0,0.0)), vec3(0.2,1.0,1.0) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p3-vec3(2.0,0.0,0.0)), vec3(0.4,0.8,0.8) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p-vec3(2.0,-0.8,0.0)), vec3(0.4,1.2,0.8) , 0.1 ) );\n    \n    \n    p4.zyx *= rotY(-3.14145*0.5);\n    p4.yxz *= rotY(3.14145*0.25);\n    p.zyx *= rotY(3.14145);\n    finalDistance = min(finalDistance, udRoundBox( (p4-vec3(2.0,0.0,0.0)), vec3(0.2,1.0,1.0) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p4-vec3(2.0,0.0,0.0)), vec3(0.4,0.8,0.8) , 0.1 ) );\n    finalDistance = min(finalDistance, udRoundBox( (p-vec3(2.0,-0.8,0.0)), vec3(0.4,1.2,0.8) , 0.1 ) );\n    return finalDistance;\n}\nfloat calculateDistance(in vec3 p, out vec3 color) {\n    float height = texture(iChannel1, vec2(p.xz+iTime)*0.05 ).r;\n    color = height+vec3(1.0);  \n    float finalDistance = 10000000.;\n    finalDistance = min(finalDistance, udBox( p-vec3(0.0,-2.0+height*0.1+sin(p.x*0.6+iTime)*0.1,0.0), vec3(30.,0.7,30.0) ) );\n    float dist1 = palkki(p,color);\n    if(dist1 < finalDistance){\n        finalDistance = dist1;\n        color = vec3(5.0,0.0,0.0);\n    }\n    return finalDistance;\n}\n\nfloat THESHITYO( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<32; i++ )\n    {\n        vec3 C;\n        float h = calculateDistance(ro + rd*t, C);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.02, 0.8 );\n\t\tif( h<0.001 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 tracer(vec3 rayStartPosition, vec3 rayDirection) {\n    vec3 finalColor = vec3(0., 0., 0.);\n    vec3 rayPosition = rayStartPosition;\n    float stepable = 0.4;\n    float dist = 0.01;\n    vec3 normalVector = rayDirection;\n    float coff = 0.3;\n    float find;\n    vec3 lightSource = vec3(120.0,120.0,120.0);\n    \n    for(float k=0.; k<3.; k++) {\n        find = 0.0;\n        for(float i=0.; i<50.; i++) {\n            vec3 color;\n            stepable = calculateDistance(rayPosition, color);\n            dist += stepable;\n            rayPosition = rayStartPosition + dist * rayDirection;\n            \n            \n            vec3 lightDir = (lightSource-rayPosition);\n            lightDir = normalize(lightDir);\n            float directLight = dot(normalVector, lightDir);\n            finalColor+= texture(iChannel0, (rayPosition.xy + rayPosition.y) * 0.8 ).r * texture(iChannel1, (rayPosition.xz + rayPosition.z) * 0.8 ).r * \n                \t\t\t0.2 * max(pow(directLight,7.)*  vec3(1.7,1.1,.9) * 1.8,0.0001);\n            \n            if(length(rayPosition)>25.) { \n                vec3 lightDir = (lightSource-rayStartPosition);\n                lightDir = normalize(lightDir);\n                float directLight = dot(normalVector, lightDir);\n                finalColor+=max( pow(directLight,7.) * vec3(1.7,1.1,.9) * 1.8, 0.01) + 0.2 * texture(iChannel1, 2.0*vec2(abs(atan(rayDirection.x,rayDirection.z)/3.141),rayDirection.y)).rgb * 0.7 * min(max(length(rayDirection.xz) * 3.0,0.0),1.0);;\n                return finalColor;\n            }\n            \n            if( abs(stepable) <= 0.005){\n                const float epsilon = 0.005;\n                vec3 C;\n                normalVector = vec3(\tcalculateDistance(rayPosition+vec3(epsilon,0,0),C)-calculateDistance(rayPosition+vec3(-epsilon,0,0),C),\n                                        calculateDistance(rayPosition+vec3(0,epsilon,0),C)-calculateDistance(rayPosition+vec3(0,-epsilon,0),C),\n                                        calculateDistance(rayPosition+vec3(0,0,epsilon),C)-calculateDistance(rayPosition+vec3(0,0,-epsilon),C));\n                normalVector = normalize(normalVector);\n                \n                \n                float shadow = (THESHITYO(rayPosition + normalVector, normalize(lightSource), 0.01, 0.6) * 1.9);\n                finalColor = mix(finalColor, (color * vec3(dot(normalVector, -rayDirection)) / (k*9.0*(shadow+1.0) + 1.0)) * shadow, coff) ;\n                finalColor = mix(finalColor, vec3(0.0), dist/24.0);  /*fog*/\n                find = 1.0;\n                break;\n                \n            }\n        }\n        dist = 0.1;\n        rayStartPosition = rayPosition + normalVector;\n        rayPosition = rayStartPosition;\n        rayDirection = reflect(rayDirection, normalVector);\n        coff *= 0.3;\n    }\n    return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 cameraPosition = vec3( -0.7, 0.0, -17.0 );\n    cameraPosition.yxz *= rotY( -0.2 );\n    cameraPosition *= rotY( 0.1 * 2.0 * 3.1415 * iTime );\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    uv *= vec2(sin(iTime+uv.x)/10.+1.,1.0);\n    float aspect = iResolution.x / iResolution.y;\n    if(length(uv*vec2(0.,aspect))>0.9) discard;\n    vec3 direction = normalize(vec3(.5 * uv * vec2(aspect, 1.0), 1. )) ;\n    direction.yxz *= rotY( -0.2 );\n    direction *= rotY( 0.1 * 2.0 * 3.1415 * iTime );\n    fragColor = vec4(tracer(cameraPosition, direction),1.0);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlB3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 118], [119, 119, 160, 160, 238], [239, 239, 264, 264, 301], [303, 303, 328, 328, 386], [388, 388, 413, 413, 478], [479, 479, 513, 513, 580], [581, 581, 614, 614, 679], [680, 680, 710, 710, 806], [807, 807, 841, 841, 865], [866, 866, 911, 911, 951], [952, 952, 1004, 1004, 1133], [1134, 1134, 1170, 1170, 1254], [1255, 1255, 1275, 1275, 1347], [1348, 1348, 1388, 1388, 2803], [2804, 2804, 2856, 2856, 3282], [3284, 3284, 3348, 3348, 3644], [3646, 3646, 3701, 3701, 6478], [6480, 6480, 6537, 6537, 7110]], "test": "untested"}
{"id": "MlBGRm", "name": "Grid 2947", "author": "paf31", "description": "grid", "tags": ["grid"], "likes": 0, "viewed": 127, "published": "Public", "date": "1427588173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float dist (vec2 uv, vec2 p0) {\n    vec2 off = abs(uv - p0) * 3.0;\n    float p = sin(iTime) * 2.0 + 4.0;\n    float r = pow(pow(off.x, p) + pow(off.y, p), 1.0 / p);\n    vec2 ox = uv - p;\n    float t = atan(ox.y, ox.x);\n    return 1.0 - abs(1.0 - pow(mod(r * 8.0 / (3.5 + sin(t * 4.0 + iTime)), 1.0), 2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float d1 = dist(uv, vec2(0.3, 0.3));\n    float d2 = dist(uv, vec2(0.7, 0.3));\n    float d3 = dist(uv, vec2(0.3, 0.7));\n    float d4 = dist(uv, vec2(0.7, 0.7));\n    float d = d1 - d2 - d3 + d4;\n\tfragColor = vec4(d, d, d, 1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 307], [309, 309, 366, 366, 645]], "test": "untested"}
{"id": "MlBGzh", "name": "moiree", "author": "kof", "description": "kind of moire effect", "tags": ["2d", "moiree"], "likes": 3, "viewed": 132, "published": "Public", "date": "1426794398", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sm1,sm2,sm3;\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    \n    float speed = 1.0/2000.0;\n    \n    float x1 = uv.x+cos(iTime/11.613*speed)*2.0;\n    float y1 = uv.y+sin(iTime/12.5*speed)*2.0;\n    \n    float x2 = uv.x+cos(iTime/13.414*speed)*2.0;\n    float y2 = uv.y+sin(iTime/14.31*speed)*2.0;\n    \n    float x3 = uv.x+cos(iTime/15.215*speed)*2.0;\n    float y3 = uv.y+sin(iTime/16.13*speed)*2.0;\n    \n    \n    float sum1 = sqrt((x1*x1)+(y1*y1));\n    \n    sum1 *= sqrt((x1*x1)+(y1*y1));\n    sum1 *= sqrt((x1*x1)+(y1*y1));\n    sum1 =  sin(sum1 * (( sin(iTime/10.5)+1.1)*10.0)  );\n    \n    \n    \n    float sum2 = sqrt((x2*x2)+(y2*y2));\n    \n    sum2 *= sqrt((x2*x2)+(y2*y2));\n    sum2 *= sqrt((x2*x2)+(y2*y2));\n    sum2 =  sin(sum2 * (( sin(iTime/10.6)+1.1)*10.0)  );\n    \n    \n    \n    float sum3 = sqrt((x3*x3)+(y3*y3));\n    \n    sum3 *= sqrt((x3*x3)+(y3*y3));\n    sum3 *= sqrt((x3*x3)+(y3*y3));\n    sum3 =  sin(sum3 * (( sin(iTime/10.77)+1.1)*10.0)  );\n    \n    \n    float sum = sum1+sum2+sum3;\n    \n\tfragColor = vec4(sum,sum,sum,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 78, 78, 1107]], "test": "untested"}
{"id": "MlBGzz", "name": "STYLE?2", "author": "Branch", "description": "STYLE?2", "tags": ["style2"], "likes": 20, "viewed": 2831, "published": "Public API", "date": "1426624029", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * p - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n\tfloat vignette = 1.0 / max(0.25 + 0.34*dot(coord,coord),1.);\n    \n    vec2 unreal=coord;\n    unreal*=4.-0.1*iTime+sin(iTime)*.1;\n    float beat = mod(iTime,1.);\n    unreal *= vec2(sin(beat+unreal.y+iTime*.01)*0.05*beat+1.,cos(beat*.01*1.121+unreal.x)*0.05*beat+1.);\n    unreal.x = mod(unreal.x,.5)-0.35;\n    unreal.y = mod(unreal.y,.5)-0.35;\n    float sizer1 = 1.+abs(coord.y*1.2);\n    vec3 rgb = vec3(0.1)-.1*mod(fragCoord.x+fragCoord.y,4.);\n    rgb += vec3(max(min(floor(length(unreal)*10.*sizer1),1.),0.));\n    rgb *= vec3(max(min(floor(length(unreal+vec2(.25))*10.*sizer1),1.),0.));\n    rgb = vec3(min(max(rgb.r,0.),1.),min(max(rgb.g,0.),1.),min(max(rgb.b,0.),1.));\n    rgb -= vec3(0.9,0.5,-0.);\n    \n    \n    vec2 cyclicmovement = vec2(cos(iTime*1.121),sin(iTime*1.121));\n    vec2 magicCoord = cyclicmovement+coord*length(coord+cyclicmovement*mod(iTime*2.,4.));\n    float s=texture(iChannel0,magicCoord).r*.1;\n    if(length(coord+s)*(.7+.1*sin(iTime))<.3)\n        rgb = vec3(1.0,.75,.2);\n    else \n        rgb += vec3(.11);\n    rgb += vec3(1.1-min(mod(floor(length(coord)*(2.3+mod(floor(iTime)+length(coord)*2.121,4.)))+iTime,4.),1.));\n\tfragColor = vec4(rgb*vignette\n         \t\t\t\t,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlBGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 1454]], "test": "untested"}
{"id": "Mlf3WX", "name": "Sky at night", "author": "guil", "description": "Very cheap clouds and stars", "tags": ["2d", "cloud", "stars"], "likes": 10, "viewed": 881, "published": "Public", "date": "1425595382", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte\n\nconst mat2 m2 = mat2(.8,.6,-.6,.8);\n\nfloat stars(in vec2 p){\n    vec2 z = p;\n    p=floor(p*5.)/5.+0.1;\n\tfloat r = 80.*dot(z-p,z-p);\n    z=p;\n\tfor( int i=0; i< 3; i++ ) \n\t{\t\t\n        z=m2*z*1.1+1.3;\n        z+=15.*sin(z+3.*sin(p.yx));        \n\t}        \t\n\treturn clamp(2.5-length(z),0.,1.)*exp(-r);\n}\n\nfloat noise(in vec2 p){\n\t\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 2; i++ ) \n\t{\t\t\n        p=m2*p*f+4.3;     \n        f*=1.1;\n        res+=(sin(p+sin(p.yx))).x;\n\t}        \t\n\treturn (res/3.);\n}\n\nfloat fbm(in vec2 p){\n\t\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 5; i++ ) \n\t{\n        f*=2.;\n        res+=noise(f*p)/f;\n\t}        \t\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = 15.*(-iResolution.xy+2.0*fragCoord.xy)/iResolution.y;\n\tfloat f = stars(p);\n\tp+=.8*iTime;\t\n\tvec3 col = vec3(f*f*f,f*f*.8,f*.8);\n    f= clamp(fbm(p*.1),0.,1.);\n    if(f>.1)col =vec3(f*f*f,f*f,f);\n    else col = mix(col,vec3(f*f*f,f*f,f),10.*f);\n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlf3WX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 151, 174, 174, 413], [415, 415, 438, 438, 617], [619, 619, 640, 640, 776], [778, 778, 835, 835, 1119]], "test": "untested"}
{"id": "MlfGDX", "name": "FCC Linear Interpolation", "author": "paniq", "description": "Linear interpolation of values in a face-centered cubic (FCC) lattice - original left, interpolated right; T = visualization; W = grid; C = automatic / user-controlled cross section; when user-controlled: P = change cutting plane.", "tags": ["mattdamon"], "likes": 14, "viewed": 1937, "published": "Public API", "date": "1425608755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\nTo find the cell that a point is passing, we skew the coordinates so that\nan octahedron with two tetrahedra at opposing sides forms a perfect\ncube with two interior faces along the normal (1 1 1); \n\nWe can now split the coordinate into an integer and a fractional part. \nThe integer coordinate is unskewed to find the local basis; we take the\ndot product of the fractional part and the normal (x+y+z) to get the type\nof cell: \n\nx < 1 is the lower left front tetrahedron, \n1 <= x < 2 is the center octahedron,\n2 <= x is the upper right back tetrahedron.\n\nThe first three interpolants q,r,s of the tetrahedra are simply the \nxyz components of the fractional part. The fourth interpolant\nis 1-q-r-s.\n\nThe three axis aligned interpolants of the octahedron are the unskewed\nfractional part - 1.\n*/\n\nvec3 cart2fcc(vec3 p) {\n    return vec3(p.yzx + p.zxy - p.xyz)/2.0;\n}\n\nvec3 fcc2cart(vec3 p) {\n    return vec3(p.yzx + p.zxy);\n}\n\n//------------------------------------------------------------------------\n\n// keys are javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nbool ReadKey( int key )//, bool toggle )\n{\n\tbool toggle = true;\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nvec2 mouse;\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float ur = 6.5;\n    float an = 0.1*sin(iTime);// + 10.0*mouseX;\n\tcamPos = vec3(ur*sin(an),3.0+cos(iTime*0.7)*1.5,ur*cos(an));\n    //camPos = vec3(0.0,4.0,ur);\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\nvec3 doBackground( void )\n{\n    return vec3( 1.0);\n}\n\nfloat box(vec3 p, vec3 b)\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nconst float INVSQRT3 = 0.5773502691896258;\n\nfloat octa(vec3 p) {\n    vec3 o = abs(p);\n\tfloat s = o.x+o.y+o.z;\n\treturn (s-1.0)*INVSQRT3;\n}\n\nfloat tetra1(vec3 o) {\n    float p1 = -o.x+o.y-o.z;\n    float p2 =  o.x-o.y-o.z;\n    float p3 = -o.x-o.y+o.z;\n    float p4 =  o.x+o.y+o.z;    \n\tfloat s = max(max(max(p1,p2),p3),p4);\n\treturn (s-0.5)*INVSQRT3;\n}\n\nfloat tetra2(vec3 o) {\n    return tetra1(vec3(-o.x,o.yz));\n}\n\n// face-centered lattice (rhombic dodecahedral symmetry), 12 directions\nfloat fcc_axis(vec3 p) {\n    vec3 o = abs(p);\n    vec3 q = o / 2.0;\n    float s = length(vec3(o.xy - (q.x + q.y), o.z));\n    s = min(s, length(vec3(o.xz - (q.x + q.z), o.y)));\n    s = min(s, length(vec3(o.yz - (q.y + q.z), o.x)));\n    return s;\n}\n\nfloat lattice_fcc(vec3 p) {\n    p = mod(p-1.0,2.0)-1.0;\n    float a0 = fcc_axis(p);\n    float ax = min(min(\n        fcc_axis(p-vec3(0.0,1.0,1.0)),\n        fcc_axis(p-vec3(0.0,-1.0,-1.0))\n   \t), min(\n        fcc_axis(p-vec3(0.0,-1.0,1.0)),\n        fcc_axis(p-vec3(0.0,1.0,-1.0))\n    ));\n    float ay = min(min(\n        fcc_axis(p-vec3(1.0,0.0,1.0)),\n        fcc_axis(p-vec3(-1.0,0.0,-1.0))\n   \t), min(\n        fcc_axis(p-vec3(-1.0,0.0,1.0)),\n        fcc_axis(p-vec3(1.0,0.0,-1.0))\n    ));\n    \n    return min(a0, min(ax, ay));\n}\n\nvec4 min4(vec4 a, vec4 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec4 max4(vec4 a, vec4 b) {\n    return (a.x > b.x)?a:b;\n}\n\nconst vec3 plane_color = vec3(0.6, 0.5, 0.4);\nconst vec3 oct_color = vec3(0.0,0.9,0.5);\nconst vec3 tet_color = vec3(0.1,0.9,0.5);\nconst vec3 point_color = vec3(0.1,0.0,0.1);\nconst vec3 lut_color = vec3(0.0);\n\nvec3 random_point() {\n    float t = iTime*0.05;\n    vec3 p = vec3(2.0*cos(3.0*t+0.1),2.0*cos(4.0*t+0.7),2.0*cos(7.0*t));\n    return p;//vec3(-0.3,-1.5,p.z);\n}\n    \nvec4 scene(vec3 p) {\n    // fix coordinate system so Z is up\n    p = vec3(p.x,-p.z,p.y);\n    \n    vec4 plane = vec4(p.z+2.0, plane_color);\n    \n    vec4 d = plane;\n    \n    vec3 rp = random_point();\n    vec3 mrp = cart2fcc(rp);\n    vec3 f = floor(mrp);\n    vec3 o = mrp - f;\n    float q = dot(o, vec3(1.0));\n    f = fcc2cart(f);\n    \n    float zcap = box(p, vec3(4.0,2.0,2.0));\n    float lattice = lattice_fcc(p);\n    vec4 m;\n    if (!ReadKey(Key_W)) {\n\t    m = vec4(max(zcap, lattice-0.05), 0.0, 0.0, 1.0);\n    } else {\n        lattice = 1e+20;\n        m.x = 1e+20;\n    }\n    \n    if (!ReadKey(Key_T)) {\n\t    m = min4(m, vec4(max(zcap,-lattice+0.1), 0.0, 0.0, 0.0));\n    } else {\n    \n        if (q < 1.0) {\n            m = min4(m,vec4(tetra1(p-f-vec3(0.5,0.5,0.5))+0.01, lut_color));\n        } else if (q < 2.0) {\n            m = min4(m,vec4(octa(p-f-vec3(1.0,1.0,1.0))+0.01, lut_color));\n        } else {\n            m = min4(m,vec4(tetra2(p-f-vec3(1.5,1.5,1.5))+0.01, lut_color));\n        }    \n    }\n\n    if (!ReadKey(Key_C)) {\n        m.x = max(m.x, max(rp.y-p.y,p.z-rp.z));\n\t    d = min4(d, vec4(length(p-rp)-0.1, point_color));\n    } else if (ReadKey(Key_P)) {\n        float df = (p.x+p.y-p.z)*INVSQRT3;\n\t    m.x = max(m.x, (mouse.x*4.0)-2.0-df);\n    } else {\n\t    m.x = max(m.x, (mouse.x*4.0)-2.0-p.y);\n    }\n    d = min4(d, m);\n    \n    return d;\n}\n\nvec3 hue2rgb(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl2rgb(vec3 c) {\n    vec3 rgb = hue2rgb(c.x);\n    return c.z + c.y * (rgb - 0.5) * (1.0 - abs(2.0 * c.z - 1.0));\n}\n\n#if 0\n\nconst vec3 c0 = vec3(1.0,0.0,0.0);\nconst vec3 c1 = vec3(0.0,1.0,1.0);\nconst vec3 c2 = vec3(0.0,1.0,0.0);\nconst vec3 c3 = vec3(1.0,0.0,1.0);\nconst vec3 c4 = vec3(0.0,0.0,1.0);\nconst vec3 c5 = vec3(1.0,1.0,0.0);\n\nvec3 tet_demo1(vec3 b, vec4 q) {\n    return c3*q.x + c1*q.y + c5*q.z + c4*q.w;\n}\n\nvec3 tet_demo2(vec3 b, vec4 q) {\n    return c3*q.x + c4*q.y + c2*q.z + c1*q.w;\n}\n\nvec3 oct_demo(vec3 b, vec3 s, vec3 t) {\n    return c0*s.x + c1*t.x + c2*s.y + c3*t.y + c4*s.z + c5*t.z;\n}\n\n#else\n\nconst vec3 c0 = vec3(1.0,0.0,0.0);\nconst vec3 c1 = vec3(0.0,1.0,1.0);\nconst vec3 c2 = vec3(0.0,1.0,0.0);\nconst vec3 c3 = vec3(1.0,0.0,1.0);\nconst vec3 c4 = vec3(0.0,0.0,1.0);\nconst vec3 c5 = vec3(1.0,1.0,0.0);\n\nvec3 fake_lut(vec3 p) {\n    // this would access a texture in a real application\n    p = fcc2cart(p);\n    float w = length(p)*0.2;\n    return hsl2rgb(vec3(w-iTime*0.01,1.0,0.5));\n}\n\nvec3 tet_demo1(vec3 b, vec4 q) {\n    vec3 p0 = fake_lut(b + vec3( 1.0, 0.0, 0.0));\n    vec3 p1 = fake_lut(b + vec3( 0.0, 1.0, 0.0));\n    vec3 p2 = fake_lut(b + vec3( 0.0, 0.0, 1.0));\n    vec3 p3 = fake_lut(b);\n\t\n    return p0 * q.x + p1 * q.y + p2 * q.z + p3 * q.w;\n}\n\nvec3 tet_demo2(vec3 b, vec4 q) {\n    vec3 p0 = fake_lut(b + vec3( 0.0, 1.0, 1.0));\n    vec3 p1 = fake_lut(b + vec3( 1.0, 0.0, 1.0));\n    vec3 p2 = fake_lut(b + vec3( 1.0, 1.0, 0.0));\n    vec3 p3 = fake_lut(b + vec3( 1.0 ));\n\t\n    return p0 * q.x + p1 * q.y + p2 * q.z + p3 * q.w;\n}\n\nvec3 oct_demo(vec3 b, vec3 s, vec3 t) {\n    vec3 p0 = fake_lut(b + vec3( 1.0, 0.0, 0.0));\n    vec3 p1 = fake_lut(b + vec3( 0.0, 1.0, 0.0));\n    vec3 p2 = fake_lut(b + vec3( 0.0, 0.0, 1.0));\n    vec3 p3 = fake_lut(b + vec3( 0.0, 1.0, 1.0));\n    vec3 p4 = fake_lut(b + vec3( 1.0, 0.0, 1.0));\n    vec3 p5 = fake_lut(b + vec3( 1.0, 1.0, 0.0));\n    \n    return p0*s.x + p1*s.y + p2*s.z + p3*t.x + p4*t.y + p5*t.z;\n}\n\n#endif\n\nvec3 fcc_lookup(vec3 p) {\n    // fix coordinate system so Z is up\n    p = vec3(p.x,-p.z,p.y);\n    \n    vec3 fcc_p = cart2fcc(p);\n    if (p.x < 0.0) {\n        return fake_lut(fcc_p);\n    }        \n    \n    vec3 fcc_basis = floor(fcc_p);\n    \n    vec3 fcc_fract = fcc_p - fcc_basis;\n    float q = fcc_fract.x+fcc_fract.y+fcc_fract.z;\n    \n    if (q < 1.0) {\n        vec4 t = vec4(fcc_fract, 1.0-q);\n        return tet_demo1(fcc_basis, t);\n    } else if (q < 2.0) {\n        vec3 w = fcc2cart(fcc_fract)-1.0;\n        float d = (1.0 - (abs(w.x)+abs(w.y)+abs(w.z)))/6.0;\n        vec3 s = d+max(-w,0.0);\n        vec3 t = d+max(w,0.0);\n        return oct_demo(fcc_basis, s,t);\n    } else {\n        vec4 t = vec4(1.0 - fcc_fract, q-2.0);\n        return tet_demo2(fcc_basis, t);\n    }\n    \n    return vec3(0.0);\n}\n\nfloat doModel( vec3 p ) {\n    return scene(p).x;\n}\n\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    vec3 hsl = scene(pos).yzw;\n    return hsl.b==0.0?fcc_lookup(pos):hsl2rgb(hsl);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nfloat ao(vec3 ro, vec3 rd) {\n\tconst float st = 0.2;\n\tfloat total = 0.0;\n\tfloat weight = 0.5;\n\tfor (int i = 1; i <= 5; ++i) {\n\t\tfloat d1 = st * float(i);\n\t\tfloat d2 = doModel(ro + rd * d1);\n\t\ttotal += weight * (d1 - d2);\n\t\tweight *= 0.5;\n\t}\n\t\n\treturn clamp(1.0 - 2.0 * total, 0.0, 1.0);\n}\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 lin = vec3(0.0);\n\n    // ambient light\n    //-----------------------------\n    lin += vec3(1.0) * ao( pos, nor );\n\n    \n    // surface-light interacion\n    //-----------------------------\n    vec3 col = mal*lin;\n\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.0005;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    mouse = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, mouse.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t//-----------------------------------------------------\n\t// postprocessing\n    //-----------------------------------------------------\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlfGDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 798, 821, 821, 867], [869, 869, 892, 892, 926], [1004, 1885, 1927, 1927, 2069], [2084, 2416, 2499, 2499, 2696], [2699, 2699, 2726, 2726, 2751], [2753, 2753, 2780, 2780, 2876], [2922, 2922, 2942, 2942, 3015], [3017, 3017, 3039, 3039, 3226], [3228, 3228, 3250, 3250, 3288], [3290, 3362, 3386, 3386, 3608], [3610, 3610, 3637, 3637, 4137], [4139, 4139, 4166, 4166, 4197], [4199, 4199, 4226, 4226, 4256], [4467, 4467, 4488, 4488, 4625], [4631, 4631, 4651, 4691, 5989], [5991, 5991, 6016, 6016, 6125], [6127, 6127, 6149, 6149, 6247], [8110, 8110, 8135, 8175, 8913], [8915, 8915, 8940, 8940, 8965], [8967, 8967, 9012, 9012, 9097], [9099, 9310, 9338, 9338, 9597], [9599, 9599, 9683, 9683, 9924], [9926, 9926, 9976, 9976, 10393], [10395, 10395, 10427, 10427, 10839], [10841, 10841, 10889, 10889, 11315], [11317, 11317, 11381, 11381, 11559], [11561, 11561, 11618, 11618, 12825]], "test": "untested"}
{"id": "MlfGWl", "name": "Numerical Analysis ", "author": "Orihaus", "description": "By triclops200, trivially modfied by Orihaus\n\nhttp://butdoesitfloat.com/Numerical-analysis-is-very-much-an-experimental-science", "tags": ["2d"], "likes": 3, "viewed": 205, "published": "Public", "date": "1426077644", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// By triclops200 (https://www.shadertoy.com/view/XtlGDS), trivially modfied by Orihaus\n\nfloat hash( in vec2 p )\n{\n\tfloat h = dot( p, vec2( 127.1,311.7 ) );\t\n    return fract( sin( h ) * 43758.5453123 );\n}\n\nfloat snoise( vec2 p ) {\n\tvec2 f = fract(p);\n\tp = floor(p);\n\tfloat v = p.x+p.y*1000.0;\n\tvec4 r = vec4(v, v+1.0, v+1000.0, v+1001.0);\n\tr = fract(100000.0*sin(r*.001));\n\tf = f*f*(3.0-2.0*f);\n\treturn 2.0*(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y))-1.0;\n}\n\nconst mat2 m3 = mat2( 0.80,  0.60, -0.60,  0.80 );\nfloat fbm2( vec2 p )\n{\n    float f = 0.5 * snoise( p ); p = m3 * p * 1.2;\n    return f + 0.25 * snoise( p );\n}\n\nvec2 points[12];\nfloat abs_sum(vec2 xs){\n\treturn abs(xs[0]) + abs(xs[1]);\n}\n\nvec3 color_from_point(vec2 point){\n\treturn vec3( abs( snoise( point -  iTime * 0.1 ) ) );\n}\n\nvec3 minimumDistColor(vec2 point){\n\tvec2 del = points[0] - point;\n\tfloat min_dist_sq = abs_sum(del);\n\tvec3 min_color = color_from_point(points[0]);\n\tif(min_dist_sq<0.005) return color_from_point(vec2(0.5,0.2))-vec3(0.2,0.2,0.2);\n\tfor(int i=0;i<12;i++){\n\t\tdel = points[i]-point;\n\t\tfloat d = abs_sum(del);\n\t\tif(d < 0.005) return color_from_point(vec2(0.5,0.2))-vec3(0.2,0.2,0.2);\n\t\tif(d < min_dist_sq){\n\t\t\tmin_color = color_from_point(points[i]);\n\t\t\tmin_dist_sq = d;\n\t\t}\n\t}\n    \n    float f = fwidth( point.x ) * floor( fract( iTime - min_dist_sq * 120.0 ) * 2.0 ) * 2000.0;\n\treturn min_color * f;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tpoints[0] = vec2(0.045+sin(iTime)*0.064,0.3+cos(iTime*3.1)*0.05);\n\tpoints[1] = vec2(0.92+sin(iTime*1.1)*0.032,0.14+cos(iTime*3.3+.2)*0.05);\n\tpoints[2] = vec2(0.23+sin(iTime*0.2)*0.076,0.5+cos(iTime*2.1+.2)*0.05);\n\tpoints[3] = vec2(0.85+sin(iTime*0.4)*0.02,0.4+cos(iTime*2.7+.7)*0.05);\n\tpoints[4] = vec2(0.27+sin(iTime*2.4)*0.0613,0.145+cos(iTime*1.5+.7)*0.09);\n\tpoints[5] = vec2(0.058+sin(iTime*0.6)*0.013,0.15+cos(iTime*0.7+.7)*0.09);\n\tpoints[6] = vec2(0.46+sin(iTime)*0.1,0.13+cos(iTime*3.1)*0.05);\n\tpoints[7] = vec2(0.94+sin(iTime*1.1)*0.04,0.21+cos(iTime*3.3+.2)*0.05);\n\tpoints[8] = vec2(0.122+sin(iTime*0.2)*0.31,0.54+cos(iTime*2.1+.2)*0.05);\n\tpoints[9] = vec2(0.81+sin(iTime*0.4)*0.21,0.4+cos(iTime*2.7+.7)*0.05);\n\tpoints[10] = vec2(0.38+sin(iTime*2.4)*0.043,0.15+cos(iTime*1.5+.7)*0.09);\n\tpoints[11] = vec2(0.56+sin(iTime*0.6)*0.16,0.15+cos(iTime*0.7+.7)*0.09);\n\tfloat u = fragCoord.x / iResolution.x;\n\tfloat v = fragCoord.y / iResolution.x;\n\tvec2 uv = vec2(u,v);\n\n\tfragColor = vec4(minimumDistColor(uv),1.0);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlfGWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 89, 114, 114, 205], [207, 207, 231, 231, 465], [518, 518, 540, 540, 628], [647, 647, 670, 670, 705], [707, 707, 741, 741, 798], [800, 800, 834, 834, 1397], [1400, 1400, 1457, 1457, 2478]], "test": "untested"}
{"id": "Mlj3RR", "name": "[NV15] space core", "author": "germangb", "description": "\"SPACE SPACE SPACE SPACE SPACE SPACE SPACE\"\n- Space core from Portal 2", "tags": ["space", "portal", "core"], "likes": 20, "viewed": 1257, "published": "Public", "date": "1426693017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float planet (vec3 p) {\n \treturn length(p + vec3(16.0, 4.0, -33.0)) - 32.0;   \n}\n\nmat2 rotate (float angle) {\n \treturn mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));   \n}\n\nfloat field (vec3 p) {\n    float sph = length(p) - 1.0;\n    float cil = length(vec2(abs(p.y), p.z) - vec2(1.125, -0.45)) - 0.055;\n    float final = sph;\n    if (abs(p.x) < 0.85)\n    \tfinal = min(sph, cil);\n    return min(final, planet(p));\n}\n\nfloat move (float x) {\n    #define STEP(A, X, H) A/(1.0+exp((X-x)*H))\n    x = mod(x, 16.0);\n    float h = 0.0;\n    h += STEP(1.0, 1.0, 24.0);\n    h += STEP(-0.5, 3.0, 24.0);\n    h += STEP(-1.0, 5.0, 24.0);\n    h += STEP(0.5, 8.0, 24.0);\n    h += STEP(-0.75, 12.0, 24.0);\n    h += STEP(1.25, 14.0, 24.0);\n    h += STEP(-0.5, 15.0, 24.0);\n \treturn h;   \n}\n\nvec3 normal (vec3 p) {\n\tvec2 eps = vec2(0.0001, 0.0);\n    return normalize(vec3(\n    \tfield(p+eps.xyy) - field(p-eps.xyy),\n    \tfield(p+eps.yxy) - field(p-eps.yxy),\n    \tfield(p+eps.yyx) - field(p-eps.yyx)\n    ));\n}\n\nvec4 eye (vec2 uv) {\n    vec4 orange = vec4(252.0/255.0, 148.0/255.0, 28.0/255.0, 0.0);\n    vec4 color = vec4(0.0);\n\tuv.x += 0.5 * move(iTime);\n    uv.y += 0.5 * move(iTime*2.0 + 42.0);\n    float bottomLid = -0.5 - 0.5 * move(iTime * 1.0 + 128.0);\n    float topLid = 0.25 - 0.75 * move(iTime * 2.0 + 128.0);\n    if (uv.y < bottomLid || 1.0 - uv.y < topLid) {\n        if (uv.y < bottomLid - 0.1 || 1.0 - uv.y < topLid - 0.1)\n\t        color = vec4(vec3(0.7), 1.0);\n        //else color = vec4(1.0);\n    } else {\n        if (abs(length(uv) - 0.65) < 0.2 && mod(atan(uv.x, uv.y)/(2.0*3.141592) + iTime * 0.025, 0.05) < 0.02)\n            color = orange;\n        float glow = clamp(cos(3.141592*(length(uv)-0.65)/0.70*0.5), 0.0, 1.0);\n        color += orange * pow(glow, 2.0) * (0.1 + sin(iTime * 32.0) * 0.05);\n        color += orange * pow(glow, 8.0) * 0.5;\n    }\n    \n            color = mix(vec4(1.0), color, smoothstep(0.0, 0.05, abs(uv.y+topLid-1.05)-0.05));\n            color = mix(vec4(1.0), color, smoothstep(0.0, 0.05, abs(1.0 - uv.y+bottomLid-1.05)-0.05));\n\n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv * 2.0 - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    uv.x *= aspect;\n    vec3 ro = vec3(uv, -1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 color = vec3(1.0);vec3(mix(sqrt(uv.y * 0.5+0.5), 1.0, 0.25));\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n    float h = 0.0;\n    float last = 9999.0;\n    for (int i = 0; i < 200; ++i) {\n        vec3 p = ro + h * rd;\n        if (p.z < 2.0) {\n            p.xy *= rotate(sin(iTime) * 0.2);\n            p.xz *= rotate(cos(iTime) * 0.1);\n            p.yz *= rotate(sin(iTime) * 0.2);\n            p.x += sin(iTime * 0.5) * 0.5;\n        }\n        vec3 oldP = p;\n        float dist = field(p);\n        h += max(dist, 0.01);\n        if (h < 2.0) {\n            if (dist < 0.05)\n                last = dist;  \n            else {\n                if (last < 0.05) {\n                    color = vec3(0.0);\n                    break;\n                } else last = 9999.0;\n            }\n        }\n        if (h > 16.0) break;\n        if (dist < 0.0) {\n            vec3 n = normal(p);\n            float diffuse = clamp(dot(n, normalize(vec3(1.75, 1.5, -1.75))), 0.1, 1.0);\n            float smDiff = diffuse;\n           // diffuse = mix(0.5, 1.0, diffuse);\n            diffuse = mix(0.5, 1.0, smoothstep(0.3, 0.3125, diffuse));\n            if (p.z > 2.0) {\n                float look = clamp(dot(-normalize(p), n), 0.0, 1.0);\n                color = vec3(0.6, 0.4, 0.7) * pow(look, 1.5);\n                color += pow(1.0 - look, 2.0) * vec3(1.0, 0.6, 1.0) * 0.7;\n                color += pow(1.0 - look, 4.0) * vec3(1.0, 0.6, 1.0) * 0.7;\n                color += pow(1.0 - look, 6.0) * vec3(1.0, 0.6, 1.0) * 0.7;\n            } else if (abs(p.y) < 1.0) {\n                color = vec3(0.9) * diffuse;\n                vec2 off = vec2(0.0);\n                off.x += 0.25 * move(iTime);\n                off.y += 0.25 * move(iTime*2.0+42.0);\n                float topE = (abs(p.y) -0.5)*0.15/0.5+0.1;\n                float rad = length(p.xy + off);\n                if (abs(p.x) < 0.04) color = vec3(0.1) * diffuse;\n                if (abs(abs(p.x) - 0.5) < 0.04) color = vec3(0.5)*diffuse;\n                if (abs(p.y) > 0.5 && abs(p.x) < topE) color = vec3(0.1) * diffuse;\n                vec3 grunge = texture(iChannel0,vec2(0.5, 0.2)*(p.xy*0.5+0.5)).rgb;\n                color *= mix(0.75, 1.0, grunge.r);\n                if (rad < 0.6) color *= clamp((rad-0.5)/0.1, 0.0, 1.0);\n                if (rad < 0.5) color = vec3(1.0) * diffuse*smDiff;\n                //if (rad < 0.325) color = vec3(0.1)*diffuse;\n                //if (rad < 0.275) {\n                    vec4 eyeC = eye((p.xy+off)/0.275);\n                   // color = eyeC.rgb;\n                    if (eyeC.a > 0.5) eyeC.rgb *= diffuse;\n                    color = mix(eyeC.rgb, color, smoothstep(0.0, 0.05, length(p.xy+off)-0.275));\n                //}\n                color = mix(vec3(0.125*diffuse), color, smoothstep(0.0, 0.0075, abs(rad - 0.3) - 0.023));\n\n                \n                color = mix(vec3(0.0), color, smoothstep(0.0, 0.0075, abs(length(p.xy+off)-0.5) - 0.025));\n                \n                //if (diffuse < 0.125) diffuse = 0.5;\n                //else diffuse = 1.0;\n                \n                \n                float back = clamp(dot(n, vec3(-1.0, 0.0, 0.75)), 0.0, 1.0);\n                color += vec3(1.0, 0.5, 1.0) * pow(back, 1.0);\n                color += vec3(1.0, 0.5, 1.0) * pow(back, 3.0);\n               \n            } else color = vec3(0.1)*diffuse;   \n            break;\n        }\n    }\n    color += smoothstep(0.0, 1.0, pow(uv.x*0.5+0.5, 3.0));\n   \tcolor.r = clamp(color.r, 0.0, 1.0);\n    color.g = clamp(color.g, 0.0, 1.0);\n    color.b = clamp(color.b, 0.0, 1.0);\n    uv2 = uv2 * 2.0 - 1.0;\n    color *= smoothstep(1.65, 1.65 - 0.75, length(uv2));\n    fragColor = vec4(sqrt(color), 1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlj3RR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 80], [82, 82, 109, 109, 194], [196, 196, 218, 218, 437], [439, 439, 461, 461, 792], [794, 794, 816, 816, 1009], [1011, 1011, 1031, 1031, 2093], [2095, 2095, 2149, 2149, 6041]], "test": "untested"}
{"id": "Mlj3zR", "name": "[NV15] blankspace", "author": "NBickford", "description": "This shader prints its own code, including the code for printing its own code.", "tags": ["recursion", "nv15", "quine"], "likes": 29, "viewed": 2372, "published": "Public API", "date": "1426749523", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 a000=mat4( 9,14,20, 0, 7, 3,44, 9,14,20, 0, 9,45,48, 9,14);\nmat4 a001=mat4(20, 0,17,43, 9,40,31,41,44, 9,42,31,45,52, 9,14);\nmat4 a002=mat4(20, 0,18,43, 9,42,31,40,31,41,44, 9,42,28,33,45);\nmat4 a003=mat4(52, 9,14,20, 0,22,43, 9,42,28,33,52,13, 1,20,31);\nmat4 a004=mat4( 0, 2,43,13, 1,20,31,44,27,45,52,22, 5, 3,31, 0);\nmat4 a005=mat4(23,43,22, 5, 3,31,44,27,45,52, 9, 6,44,18,43,43);\nmat4 a006=mat4(27,45,23,43, 2,46,27,47,52, 9, 6,44,18,43,43,28);\nmat4 a007=mat4(45,23,43, 2,46,28,47,52, 9, 6,44,18,43,43,29,45);\nmat4 a008=mat4(23,43, 2,46,29,47,52, 9, 6,44,18,43,43,30,45,23);\nmat4 a009=mat4(43, 2,46,30,47,52, 6,12,15, 1,20, 0, 5,43,27,37);\nmat4 a010=mat4(27,52, 9, 6,44,17,43,43,27,45, 5,43,23,37,18,52);\nmat4 a011=mat4( 9, 6,44,17,43,43,28,45, 5,43,23,37, 7,52, 9, 6);\nmat4 a012=mat4(44,17,43,43,29,45, 5,43,23,37, 2,52, 9, 6,44,17);\nmat4 a013=mat4(43,43,30,45, 5,43,23,37, 1,52,18, 5,20,21,18,14);\nmat4 a014=mat4( 0, 9,14,20,44, 5,45,52,49, 9,14,20, 0,16,29,44);\nmat4 a015=mat4( 9,14,20, 0, 4,45,48, 9,14,20, 0,13,43,28,52, 9);\nmat4 a016=mat4(14,20, 0,12,43,27,52, 6,15,18,44, 9,14,20, 0,12);\nmat4 a017=mat4(43,27,52,12,50,28,33,52,12,39,39,45,48, 9, 6,44);\nmat4 a018=mat4(12,51,43, 4,45, 2,18, 5, 1,11,52,13,41,43,29,52);\nmat4 a019=mat4(49,18, 5,20,21,18,14, 0,13,52,49, 6,12,15, 1,20);\nmat4 a020=mat4( 0,12,20,18,44, 9,14,20, 0, 3,38, 9,14,20, 0, 4);\nmat4 a021=mat4(45,48, 9,14,20, 0,13,43,16,29,44, 4,45,52, 9,14);\nmat4 a022=mat4(20, 0,18,43,27,52, 9, 6,44, 3,43,43,27,45,18,43);\nmat4 a023=mat4(30,29,34,33,34,52, 9, 6,44, 3,43,43,28,45,18,43);\nmat4 a024=mat4(36,29,30,34,52, 9, 6,44, 3,43,43,29,45,18,43,28);\nmat4 a025=mat4(34,33,35,31,52, 9, 6,44, 3,43,43,30,45,18,43,34);\nmat4 a026=mat4(33,27,28,52, 9, 6,44, 3,43,43,31,45,18,43,28,34);\nmat4 a027=mat4(32,32,33,52, 9, 6,44, 3,43,43,32,45,18,43,30,30);\nmat4 a028=mat4(34,33,52, 9, 6,44, 3,43,43,33,45,18,43,29,34,36);\nmat4 a029=mat4(32,29,52, 9, 6,44, 3,43,43,34,45,18,43,29,28,33);\nmat4 a030=mat4(35,28,52, 9, 6,44, 3,43,43,35,45,18,43,36,29,30);\nmat4 a031=mat4(31,52, 9, 6,44, 3,43,43,36,45,18,43,29,36,29,27);\nmat4 a032=mat4(52, 9, 6,44, 3,43,43,28,27,45,18,43,29,34,31,36);\nmat4 a033=mat4(33,52, 9, 6,44, 3,43,43,28,28,45,18,43,36,31,36);\nmat4 a034=mat4(27,52, 9, 6,44, 3,43,43,28,29,45,18,43,30,32,28);\nmat4 a035=mat4(27,52, 9, 6,44, 3,43,43,28,30,45,18,43,36,29,28);\nmat4 a036=mat4(33,52, 9, 6,44, 3,43,43,28,31,45,18,43,35,28,36);\nmat4 a037=mat4(31,52, 9, 6,44, 3,43,43,28,32,45,18,43,29,28,33);\nmat4 a038=mat4(32,30,52, 9, 6,44, 3,43,43,28,33,45,18,43,29,34);\nmat4 a039=mat4(36,29,31,52, 9, 6,44, 3,43,43,28,34,45,18,43,31);\nmat4 a040=mat4(29,31,32,52, 9, 6,44, 3,43,43,28,35,45,18,43,36);\nmat4 a041=mat4(31,36,29,52, 9, 6,44, 3,43,43,28,36,45,18,43,28);\nmat4 a042=mat4(35,29,35,36,52, 9, 6,44, 3,43,43,29,27,45,18,43);\nmat4 a043=mat4(29,30,31,27,27,52, 9, 6,44, 3,43,43,29,28,45,18);\nmat4 a044=mat4(43,28,28,34,27,52, 9, 6,44, 3,43,43,29,29,45,18);\nmat4 a045=mat4(43,29,28,33,32,27,52, 9, 6,44, 3,43,43,29,30,45);\nmat4 a046=mat4(18,43,28,35,52, 9, 6,44, 3,43,43,29,31,45,18,43);\nmat4 a047=mat4(36,32,32,31,52, 9, 6,44, 3,43,43,29,32,45,18,43);\nmat4 a048=mat4(29,30,30,34,35,52, 9, 6,44, 3,43,43,29,33,45,18);\nmat4 a049=mat4(43,30,31,28,33,52, 9, 6,44, 3,43,43,29,34,45,18);\nmat4 a050=mat4(43,29,28,32,29,32,52, 9, 6,44, 3,43,43,29,35,45);\nmat4 a051=mat4(18,43,29,36,29,31,52, 9, 6,44, 3,43,43,29,36,45);\nmat4 a052=mat4(18,43,30,31,29,27,52, 9, 6,44, 3,43,43,30,27,45);\nmat4 a053=mat4(18,43,28,35,29,33,35,52, 9, 6,44, 3,43,43,30,28);\nmat4 a054=mat4(45,18,43,28,30,36,27,33,52, 9, 6,44, 3,43,43,30);\nmat4 a055=mat4(29,45,18,43,28,32,35,31,52, 9, 6,44, 3,43,43,30);\nmat4 a056=mat4(30,45,18,43,29,28,35,27,36,52, 9, 6,44, 3,43,43);\nmat4 a057=mat4(30,31,45,18,43,29,30,30,35,31,52, 9, 6,44, 3,43);\nmat4 a058=mat4(43,30,32,45,18,43,29,28,35,31,32,52, 9, 6,44, 3);\nmat4 a059=mat4(43,43,30,33,45,18,43,29,29,28,27,28,52, 9, 6,44);\nmat4 a060=mat4( 3,43,43,30,34,45,18,43,29,31,32,34,32,52, 9, 6);\nmat4 a061=mat4(44, 3,43,43,30,35,45,18,43,29,30,32,32,28,52, 9);\nmat4 a062=mat4( 6,44, 3,43,43,30,36,45,18,43,30,28,29,34,36,52);\nmat4 a063=mat4( 9, 6,44, 3,43,43,31,27,45,18,43,30,29,30,28,36);\nmat4 a064=mat4(52, 9, 6,44, 3,43,43,31,28,45,18,43,30,29,31,29);\nmat4 a065=mat4(33,52, 9, 6,44, 3,43,43,31,29,45,18,43,29,34,36);\nmat4 a066=mat4(36,32,52, 9, 6,44, 3,43,43,31,30,45,18,43,29,36);\nmat4 a067=mat4(28,29,34,52, 9, 6,44, 3,43,43,31,31,45,18,43,29);\nmat4 a068=mat4(30,36,35,36,52, 9, 6,44, 3,43,43,31,32,45,18,43);\nmat4 a069=mat4(29,29,29,30,34,52, 9, 6,44, 3,43,43,31,33,45,18);\nmat4 a070=mat4(43,28,36,35,36,29,52, 9, 6,44, 3,43,43,31,34,45);\nmat4 a071=mat4(18,43,32,35,31,36,52, 9, 6,44, 3,43,43,31,35,45);\nmat4 a072=mat4(18,43,34,27,35,28,52, 9, 6,44, 3,43,43,31,36,45);\nmat4 a073=mat4(18,43,28,36,28,35,27,52, 9, 6,44, 3,43,43,32,27);\nmat4 a074=mat4(45,18,43,28,32,29,34,32,52, 9, 6,44, 3,43,43,32);\nmat4 a075=mat4(28,45,18,43,29,34,30,34,31,52, 9, 6,44, 3,43,43);\nmat4 a076=mat4(32,29,45,18,43,29,29,31,36,32,52, 9, 6,44, 3,43);\nmat4 a077=mat4(43,32,30,45,18,43,28,28,33,28,27,52, 9, 6,44, 3);\nmat4 a078=mat4(43,43,32,31,45,18,43,29,30,31,27,32,52, 9,14,20);\nmat4 a079=mat4( 0, 4,13,43,18,42,13,52,18,43,18,40,29,41,13,41);\nmat4 a080=mat4(44,18,42,44,29,41,13,45,45,40,44,18,40,13,41,44);\nmat4 a081=mat4(18,42,13,45,45,52, 9, 6,44,18,51,27,45,18, 5,20);\nmat4 a082=mat4(21,18,14, 0,28,37,27,52,18, 5,20,21,18,14, 0,27);\nmat4 a083=mat4(37,27,52,49, 9,14,20, 0,13, 9,44,13, 1,20,31, 0);\nmat4 a084=mat4( 2,38, 9,14,20, 0, 9,45,48, 9, 6,44, 9,51,43,28);\nmat4 a085=mat4(33,45,18, 5,20,21,18,14, 0,27,52, 9,14,20, 0,18);\nmat4 a086=mat4(43, 9,42,31,40,31,41,44, 9,42,28,33,45,52, 9,14);\nmat4 a087=mat4(20, 0,17,43, 9,40,31,41,44, 9,42,31,45,52,22, 5);\nmat4 a088=mat4( 3,31, 0,23,43,22, 5, 3,31,44,27,45,52, 9, 6,44);\nmat4 a089=mat4(18,43,43,27,45,23,43, 2,46,27,47,52, 9, 6,44,18);\nmat4 a090=mat4(43,43,28,45,23,43, 2,46,28,47,52, 9, 6,44,18,43);\nmat4 a091=mat4(43,29,45,23,43, 2,46,29,47,52, 9, 6,44,18,43,43);\nmat4 a092=mat4(30,45,23,43, 2,46,30,47,52, 6,12,15, 1,20, 0, 5);\nmat4 a093=mat4(43,27,37,27,52, 9, 6,44,17,43,43,27,45, 5,43,23);\nmat4 a094=mat4(37,18,52, 9, 6,44,17,43,43,28,45, 5,43,23,37, 7);\nmat4 a095=mat4(52, 9, 6,44,17,43,43,29,45, 5,43,23,37, 2,52, 9);\nmat4 a096=mat4( 6,44,17,43,43,30,45, 5,43,23,37, 1,52,18, 5,20);\nmat4 a097=mat4(21,18,14, 0, 9,14,20,44, 5,45,52,49, 6,12,15, 1);\nmat4 a098=mat4(20, 0, 2,12, 1,14,11,19,16, 1, 3, 5,44,22, 5, 3);\nmat4 a099=mat4(29, 0,21,22,45,48, 9,14,20, 0,14, 3,23,43,33,31);\nmat4 a100=mat4(52, 9,14,20, 0,20,22,43,28,33,33,52, 9,14,20, 0);\nmat4 a101=mat4(24,16,43, 9,14,20,44,21,22,37,24,45,52, 9,14,20);\nmat4 a102=mat4( 0,25,16,43, 9,14,20,44,21,22,37,25,45,52, 9,14);\nmat4 a103=mat4(20, 0,24, 3,43,24,16,42,31,52, 9,14,20, 0,24,13);\nmat4 a104=mat4(43,24,16,40,31,41,24, 3,52, 9,14,20, 0,25, 3,43);\nmat4 a105=mat4(25,16,42,33,52, 9,14,20, 0,25,13,43,25,16,40,33);\nmat4 a106=mat4(41,25, 3,52, 9, 6,44,44,24,13,43,43,30,45,54,54);\nmat4 a107=mat4(44,25,13,43,43,32,45,54,54,44,24, 3,51,43,14, 3);\nmat4 a108=mat4(23,45,45,48,18, 5,20,21,18,14, 0,28,37,27,52,49);\nmat4 a109=mat4( 9,14,20, 0, 4,43,24,13,39,30,41,25,13,52, 9,14);\nmat4 a110=mat4(20, 0,20, 3,43,24, 3,39,14, 3,23,41,25, 3,52, 6);\nmat4 a111=mat4(12,15, 1,20, 0,22,43,27,37,27,52, 9, 6,44,20, 3);\nmat4 a112=mat4(36,36,45,22,43,12,20,18,44,29,34,39,22,14,42,28);\nmat4 a113=mat4(27,27,38, 4,45,52, 9, 6,44,19, 3,43,43,34,45, 9);\nmat4 a114=mat4( 6,44,22,14,51,36,45,22,43,12,20,18,44,29,34,39);\nmat4 a115=mat4( 4,29,38, 4,45,52, 9, 6,44,19, 3,43,43,35,45,22);\nmat4 a116=mat4(43,12,20,18,44,29,34,39, 4,30,38, 4,45,52,49, 5);\nmat4 a117=mat4(12,19, 5, 0, 9, 6,44,19, 3,50,43,28,29,45,48,22);\nmat4 a118=mat4(43,12,20,18,44,13, 9,44,20,24,20,38,19, 3,40,30);\nmat4 a119=mat4(45,38, 4,45,52,49, 5,12,19, 5, 0, 9, 6,44,19, 3);\nmat4 a120=mat4(50,43,28,32,45,48, 9, 6,44,19, 3,43,43,28,30,45);\nmat4 a121=mat4(22,43,12,20,18,44,29,34,39,22,14,42,28,27,27,38);\nmat4 a122=mat4( 4,45,52, 9, 6,44,19, 3,43,43,28,31,45,22,43,12);\nmat4 a123=mat4(20,18,44,29,34,39, 4,29,38, 4,45,52, 9, 6,44,19);\nmat4 a124=mat4( 3,43,43,28,32,45,22,43,12,20,18,44,29,34,39, 4);\nmat4 a125=mat4(30,38, 4,45,52,49, 5,12,19, 5,48,22,43,12,20,18);\nmat4 a126=mat4(44,13, 9,44,20,24,20,38,19, 3,40,33,45,38, 4,45);\nmat4 a127=mat4(52,49,49, 5,12,19, 5,48,22,43,12,20,18,44, 7, 3);\nmat4 a128=mat4(44,20, 3,40,14, 3,23,41,44,20,22,45,40,33,31,40);\nmat4 a129=mat4(28,34,41,20,22,39,33,31,45,38, 4,45,52,49,18, 5);\nmat4 a130=mat4(20,21,18,14, 0,22,52,49,22,15, 9, 4, 0,13, 1, 9);\nmat4 a131=mat4(14, 9,13, 1, 7, 5,44,15,21,20, 0,22, 5, 3,31, 0);\nmat4 a132=mat4( 6,18, 1, 7, 3,15,12,15,18,38, 9,14, 0,22, 5, 3);\nmat4 a133=mat4(29, 0, 6,18, 1, 7, 3,15,15,18, 4,45,48,22, 5, 3);\nmat4 a134=mat4(29, 0,21,22,43,29,37,27,41,44, 6,18, 1, 7, 3,15);\nmat4 a135=mat4(15,18, 4,40, 9,18, 5,19,15,12,21,20, 9,15,14,37);\nmat4 a136=mat4(24,25,41,27,37,32,45,42, 9,18, 5,19,15,12,21,20);\nmat4 a137=mat4( 9,15,14,37,24,52, 6,12,15, 1,20, 0, 6,15, 7,43);\nmat4 a138=mat4(28,37,27,40, 3,12, 1,13,16,44,16,15,23,44, 4,15);\nmat4 a139=mat4(20,44,21,22,38,21,22,45,38,28,37,27,45,41,27,37);\nmat4 a140=mat4(28,40,27,37,29,39,27,37,29,41,21,22,37,25,38,27);\nmat4 a141=mat4(37,27,38,28,37,27,45,52,22, 5, 3,30, 0, 9,15,43);\nmat4 a142=mat4(22, 5, 3,30,44,27,37,27,38,28,37,27,38,27,37,27);\nmat4 a143=mat4(45,52, 6,12,15, 1,20, 0, 1,14, 7,12, 5, 5,43, 3);\nmat4 a144=mat4(12, 1,13,16,44,28,37,28,40, 9, 7,12,15, 2, 1,12);\nmat4 a145=mat4(20, 9,13, 5,41,27,37,27,27,31,38,27,37,27,38,28);\nmat4 a146=mat4(37,28,45,52, 6,12,15, 1,20, 0, 3,43, 3,15,19,44);\nmat4 a147=mat4( 1,14, 7,12, 5, 5,45,52, 6,12,15, 1,20, 0,19,43);\nmat4 a148=mat4(19, 9,14,44, 1,14, 7,12, 5, 5,45,52,22, 5, 3,30);\nmat4 a149=mat4( 0, 9,18,43,22, 5, 3,30,44,21,22,37,24,38, 3,41);\nmat4 a150=mat4(21,22,37,25,40,19,38,40,19,41,21,22,37,25,40, 3);\nmat4 a151=mat4(45,52, 6,12,15, 1,20, 0,20,43,40, 9,15,37,25,42);\nmat4 a152=mat4( 9,18,37,25,52,22, 5, 3,30, 0,16,43, 9,15,39,20);\nmat4 a153=mat4(41, 9,18,52,21,22,43,27,37,32,41,16,37,24,26,40);\nmat4 a154=mat4(22, 5, 3,29,44,40,27,37,32,38,40, 9, 7,12,15, 2);\nmat4 a155=mat4( 1,12,20, 9,13, 5,41,27,37,27,34,45,52, 9, 6,44);\nmat4 a156=mat4(21,22,37,24,50,27,37,27, 0,54,54, 0,21,22,37,24);\nmat4 a157=mat4(51,28,37,27, 0,54,54, 0,21,22,37,25,50,27,37,27);\nmat4 a158=mat4(45,48, 6,18, 1, 7, 3,15,12,15,18,43,22, 5, 3,31);\nmat4 a159=mat4(44, 6,15, 7,38, 6,15, 7,38, 6,15, 7,38,28,37,27);\nmat4 a160=mat4(45,52,18, 5,20,21,18,14,52,49,21,22,41,43,29,32);\nmat4 a161=mat4(33,37,27,52,21,22,37,25,43,13,15, 4,44,21,22,37);\nmat4 a162=mat4(25,38,28,33,27,27,37,27,45,52, 6,12,15, 1,20, 0);\nmat4 a163=mat4(22,43, 2,12, 1,14,11,19,16, 1, 3, 5,44,21,22,45);\nmat4 a164=mat4(41, 6,15, 7,52, 6,18, 1, 7, 3,15,12,15,18,43,22);\nmat4 a165=mat4( 5, 3,31,44,22,38,22,38,22,38,28,37,27,45,52,49);\n\nint gc(int i){\n    int q=i-4*(i/4);\n    int r=i/4-4*(i/16);\n    int v=i/16;\n    mat4 b=mat4(0);\n    if(v==  0)b=a000;\n    if(v==  1)b=a001;\n    if(v==  2)b=a002;\n    if(v==  3)b=a003;\n    if(v==  4)b=a004;\n    if(v==  5)b=a005;\n    if(v==  6)b=a006;\n    if(v==  7)b=a007;\n    if(v==  8)b=a008;\n    if(v==  9)b=a009;\n    if(v== 10)b=a010;\n    if(v== 11)b=a011;\n    if(v== 12)b=a012;\n    if(v== 13)b=a013;\n    if(v== 14)b=a014;\n    if(v== 15)b=a015;\n    if(v== 16)b=a016;\n    if(v== 17)b=a017;\n    if(v== 18)b=a018;\n    if(v== 19)b=a019;\n    if(v== 20)b=a020;\n    if(v== 21)b=a021;\n    if(v== 22)b=a022;\n    if(v== 23)b=a023;\n    if(v== 24)b=a024;\n    if(v== 25)b=a025;\n    if(v== 26)b=a026;\n    if(v== 27)b=a027;\n    if(v== 28)b=a028;\n    if(v== 29)b=a029;\n    if(v== 30)b=a030;\n    if(v== 31)b=a031;\n    if(v== 32)b=a032;\n    if(v== 33)b=a033;\n    if(v== 34)b=a034;\n    if(v== 35)b=a035;\n    if(v== 36)b=a036;\n    if(v== 37)b=a037;\n    if(v== 38)b=a038;\n    if(v== 39)b=a039;\n    if(v== 40)b=a040;\n    if(v== 41)b=a041;\n    if(v== 42)b=a042;\n    if(v== 43)b=a043;\n    if(v== 44)b=a044;\n    if(v== 45)b=a045;\n    if(v== 46)b=a046;\n    if(v== 47)b=a047;\n    if(v== 48)b=a048;\n    if(v== 49)b=a049;\n    if(v== 50)b=a050;\n    if(v== 51)b=a051;\n    if(v== 52)b=a052;\n    if(v== 53)b=a053;\n    if(v== 54)b=a054;\n    if(v== 55)b=a055;\n    if(v== 56)b=a056;\n    if(v== 57)b=a057;\n    if(v== 58)b=a058;\n    if(v== 59)b=a059;\n    if(v== 60)b=a060;\n    if(v== 61)b=a061;\n    if(v== 62)b=a062;\n    if(v== 63)b=a063;\n    if(v== 64)b=a064;\n    if(v== 65)b=a065;\n    if(v== 66)b=a066;\n    if(v== 67)b=a067;\n    if(v== 68)b=a068;\n    if(v== 69)b=a069;\n    if(v== 70)b=a070;\n    if(v== 71)b=a071;\n    if(v== 72)b=a072;\n    if(v== 73)b=a073;\n    if(v== 74)b=a074;\n    if(v== 75)b=a075;\n    if(v== 76)b=a076;\n    if(v== 77)b=a077;\n    if(v== 78)b=a078;\n    if(v== 79)b=a079;\n    if(v== 80)b=a080;\n    if(v== 81)b=a081;\n    if(v== 82)b=a082;\n    if(v== 83)b=a083;\n    if(v== 84)b=a084;\n    if(v== 85)b=a085;\n    if(v== 86)b=a086;\n    if(v== 87)b=a087;\n    if(v== 88)b=a088;\n    if(v== 89)b=a089;\n    if(v== 90)b=a090;\n    if(v== 91)b=a091;\n    if(v== 92)b=a092;\n    if(v== 93)b=a093;\n    if(v== 94)b=a094;\n    if(v== 95)b=a095;\n    if(v== 96)b=a096;\n    if(v== 97)b=a097;\n    if(v== 98)b=a098;\n    if(v== 99)b=a099;\n    if(v==100)b=a100;\n    if(v==101)b=a101;\n    if(v==102)b=a102;\n    if(v==103)b=a103;\n    if(v==104)b=a104;\n    if(v==105)b=a105;\n    if(v==106)b=a106;\n    if(v==107)b=a107;\n    if(v==108)b=a108;\n    if(v==109)b=a109;\n    if(v==110)b=a110;\n    if(v==111)b=a111;\n    if(v==112)b=a112;\n    if(v==113)b=a113;\n    if(v==114)b=a114;\n    if(v==115)b=a115;\n    if(v==116)b=a116;\n    if(v==117)b=a117;\n    if(v==118)b=a118;\n    if(v==119)b=a119;\n    if(v==120)b=a120;\n    if(v==121)b=a121;\n    if(v==122)b=a122;\n    if(v==123)b=a123;\n    if(v==124)b=a124;\n    if(v==125)b=a125;\n    if(v==126)b=a126;\n    if(v==127)b=a127;\n    if(v==128)b=a128;\n    if(v==129)b=a129;\n    if(v==130)b=a130;\n    if(v==131)b=a131;\n    if(v==132)b=a132;\n    if(v==133)b=a133;\n    if(v==134)b=a134;\n    if(v==135)b=a135;\n    if(v==136)b=a136;\n    if(v==137)b=a137;\n    if(v==138)b=a138;\n    if(v==139)b=a139;\n    if(v==140)b=a140;\n    if(v==141)b=a141;\n    if(v==142)b=a142;\n    if(v==143)b=a143;\n    if(v==144)b=a144;\n    if(v==145)b=a145;\n    if(v==146)b=a146;\n    if(v==147)b=a147;\n    if(v==148)b=a148;\n    if(v==149)b=a149;\n    if(v==150)b=a150;\n    if(v==151)b=a151;\n    if(v==152)b=a152;\n    if(v==153)b=a153;\n    if(v==154)b=a154;\n    if(v==155)b=a155;\n    if(v==156)b=a156;\n    if(v==157)b=a157;\n    if(v==158)b=a158;\n    if(v==159)b=a159;\n    if(v==160)b=a160;\n    if(v==161)b=a161;\n    if(v==162)b=a162;\n    if(v==163)b=a163;\n    if(v==164)b=a164;\n    if(v==165)b=a165;\n    \n    vec4 w=vec4(0);\n    if(r==0) w=b[0];\n    if(r==1) w=b[1];\n    if(r==2) w=b[2];\n    if(r==3) w=b[3];\n    \n    float e=0.0;\n    if(q==0) e=w.r;\n    if(q==1) e=w.g;\n    if(q==2) e=w.b;\n    if(q==3) e=w.a;\n    return int(e);\n}\n\nint p2(int d){\n    int m=1;\n    int l=0;\n    for(int l=0;l<16;l++){\n        if(l>=d) break;\n        m*=2;\n    }\n    return m;\n}\n\nfloat ltr(int c, int d){\n    int m=p2(d);\n    int r=0;\n    if(c==0)r=32767; //space\n\tif(c==1)r=9237; //a through...\n\tif(c==2)r=17684;\n\tif(c==3)r=7601;\n\tif(c==4)r=17556;\n\tif(c==5)r=3376;\n\tif(c==6)r=27952;\n\tif(c==7)r=21681;\n\tif(c==8)r=9234;\n\tif(c==9)r=2920;\n\tif(c==10)r=27496;\n\tif(c==11)r=9490;\n\tif(c==12)r=3510;\n\tif(c==13)r=9216;\n\tif(c==14)r=8194;\n\tif(c==15)r=21653;\n\tif(c==16)r=27924;\n\tif(c==17)r=4245;\n\tif(c==18)r=9492;\n\tif(c==19)r=18289;\n\tif(c==20)r=23400;\n\tif(c==21)r=1170;\n\tif(c==22)r=21650;\n\tif(c==23)r=18;\n\tif(c==24)r=9554;\n\tif(c==25)r=23378;\n\tif(c==26)r=3416; //z\n\tif(c==27)r=21525; //0 through...\n\tif(c==28)r=2924;\n\tif(c==29)r=3420;\n\tif(c==30)r=18268;\n\tif(c==31)r=13906;\n\tif(c==32)r=1584;\n\tif(c==33)r=21809;\n\tif(c==34)r=23384;\n\tif(c==35)r=21845;\n\tif(c==36)r=22101;\n\tif(c==37)r=24575; //9\n\tif(c==38)r=23551;\n\tif(c==39)r=31279;\n\tif(c==40)r=32319;\n\tif(c==41)r=32426;\n\tif(c==42)r=27995;\n\tif(c==43)r=29127;\n\tif(c==44)r=23989;\n\tif(c==45)r=22237;\n\tif(c==46)r=19892;\n\tif(c==47)r=5849;\n\tif(c==48)r=7081;\n\tif(c==49)r=19180;\n\tif(c==50)r=15275;\n\tif(c==51)r=27374;\n\tif(c==52)r=22495;\n\tif(c==53)r=11610;\n\tif(c==54)r=23405;\n    \n    int dm=r/m;\n    r=r-2*m*(r/(2*m))-(r-m*(r/m));\n    if(r>0)return 1.0;\n    return 0.0;\n}\n\nint mi(mat4 b, int i){\n    if(i>=16) return 0;\n    \n    int r=i/4-4*(i/16);\n    int q=i-4*(i/4);\n    vec4 w=vec4(0);\n    if(r==0) w=b[0];\n    if(r==1) w=b[1];\n    if(r==2) w=b[2];\n    if(r==3) w=b[3];\n    \n    float e=0.0;\n    if(q==0) e=w.r;\n    if(q==1) e=w.g;\n    if(q==2) e=w.b;\n    if(q==3) e=w.a;\n    return int(e);\n}\n\nfloat blankspace(vec2 uv){\n    int ncw=64;\n    int tv=166;//166 constants!\n    int xp=int(uv.x);\n    int yp=int(uv.y);\n    int xc=xp/4; int xm=xp-4*xc;\n    int yc=yp/6; int ym=yp-6*yc;\n    if((xm==3)||\n       (ym==5)||\n       (xc>=ncw)){\n        return 1.0;\n    }\n    int d=xm+3*ym;\n    \n    int tc=xc+ncw*yc;\n    float v=0.0;\n    if(tc<ncw*tv){\n        int sc=xc; //variable string index\n        int vn=tc/64; //variable num\n        mat4 txt=mat4(13,1,20,31,0,1,43,13,1,20,31,44,45,52,0,0); \n        int d2=vn/10-10*(vn/100);\n        int d3=vn-10*(vn/10);\n        if(sc<=5){\n            v=ltr(mi(txt,sc),d);\n        }else if(sc<=8){ //three-character digitcode \n            if(sc==6) v=ltr(27+vn/100,d);\n            if(sc==7) v=ltr(27+d2,d);\n            if(sc==8) v=ltr(27+d3,d);\n        }else if(sc<=14){\n            v=ltr(mi(txt,sc-3),d);\n        }else if(sc<=61){\n            int m3=sc-3*(sc/3);\n            int midx=(sc-14)/3;\n            int num=gc(midx+16*vn);\n            if(m3==0){\n                if(num<10){\n                    v=ltr(0,d);\n                }else{\n                \tv=ltr(27+num/10,d);\n                }\n            }\n            if(m3==1) v=ltr(27+(num-10*(num/10)),d);\n            if(m3==2) v=ltr(38,d);\n        }else{\n            v=ltr(mi(txt,sc-50),d);\n        }\n    }else if(tc<ncw*(tv)+75){\n\t\tv=ltr(gc(tc-ncw*tv),d);\n    }else if(tc<ncw*(tv)+75+17*tv){\n        //01234567890123456 - 17 chars!!!\n        //if(v==149)b=a149;\n        int rp=(tc-ncw*(tv)-75);//rel-pos\n        int vn=rp/17;\n        int sc=rp-17*vn; //within-var index\n        //            i f  (  v  =  =  ) b  = a  ;\n        mat4 txt=mat4(9,6,44,22,43,43,45,2,43,1,52,0,0,0,0,0);\n        v=1.0;\n        int d2=vn/10-10*(vn/100);\n        int d3=vn-10*(vn/10);\n        if(sc<=5){\n            v=ltr(mi(txt,sc),d);\n        }else if(sc<=8){\n            if(sc==6) if(vn>99) v=ltr(27+vn/100,d);\n            if(sc==7) if(vn>9) v=ltr(27+d2,d);\n            if(sc==8) v=ltr(27+d3,d);\n        }else if(sc<=12){\n            v=ltr(mi(txt,sc-3),d);\n        }else if(sc<=15){\n            if(sc==13) v=ltr(27+vn/100,d);\n            if(sc==14) v=ltr(27+d2,d);\n            if(sc==15) v=ltr(27+d3,d);\n        }else{\n            v=ltr(mi(txt,sc-6),d);\n        }\n    }else{\n    \tv=ltr(gc(tc-ncw*(tv)-64-17*tv+64),d);\n    }\n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //perspective lines converge at (iResolution.x/2,h)\n    //\n    vec2 uv=2.0*(fragCoord-iResolution.xy*0.5)/iResolution.x;\n    //float fog=exp(0.45*0.2*p.z);\n    float fog=1.0-clamp(pow(dot(uv,uv),1.0)*0.1-0.2+0.2*uv.y,0.0,1.0);\n    //camera: io,vec3(uv.x,uv.y,-1) rotatied around x\n    //(io+ir*t).y=0->t=-io.y/it.y\n    vec3 io=vec3(0.0,1.0,0.0);\n    float anglee=clamp(1.1-iTime*0.004,0.0,1.1);\n    float c=cos(anglee); float s=sin(anglee);\n    vec3 ir=vec3(uv.x,c*uv.y-s,-s*uv.y-c);\n    float t=-io.y/ir.y;\n    vec3 p=io+t*ir;\n    \n    //fog*=exp(p.z*0.03*0.45);\n    \n    uv=0.5*p.xz-vec2(-0.5,-iTime*0.07);\n    \n    if(uv.x<0.0 || uv.x>1.0 || uv.y<0.0){\n        fragColor=vec4(fog,fog,fog,1.0);\n        return;\n    }\n    uv*=256.0;\n    \n    //uv*=0.5; //easy reader\n    //uv*=2.0; //hard reader\n    uv.y=mod(uv.y,1600.0);\n    \n    float v=blankspace(uv)*fog;\n    fragColor=vec4(v,v,v,1.0);\n}\n\n/*Okay, you've made it to the end! You probably would like an explanation\nof what the heck's going on here.\nIf you try to code a program like this the normal way, you might store\nthe code in a string, then print back the string.\nBut that doesn't work, because the string has to include both the string\nand the code for printing the string, which leads to horrible recursion.\n\nThe way you get around this is to have the string store the printing code,\nand have the printing code print the programmer version of the string, then\nsome stuff in between, then the string itself (which is actually the code).\nIn other words, the string knows how to print the code, and the code knows \nhow to print the string.\nEasy, except...\n\nShadertoy doesn't have strings.\nShadertoy doesn't have arrays. (well, not iterable arrays)*\nShadertoy doesn't have fonts.\nShadertoy doesn't even have switch statements.\n\nSo we're using a whole bunch of neat tricks.\n\n*As of February 15th, 2017, Shadertoy supports WebGL 2.0, which includes bit\n operators as well as arrays that may be able to be dynamically accessed.\n As a result, this code could likely be made significantly simpler using the\n new features.\n\nFirst, I made a pixel font based off of one I did a few years ago\nwhich only supports symbols found in the code - all 54 or so of them.\nSince each letter is 5x3, we can encode on/off values into a 15-bit integer.\nThen, we do lookups, not using bit operations (since Shadertoy doesn't\nhave those) but instead using modular arithmetic and a custom pow function.\n\nSince Shadertoy doesn't have switch statements, we have to use 54 IF\nstatements, lovingly handcoded using copy+paste.\n\nSo now we can print an arbitrary character.\n\nInstead of arrays, we use lots and lots of constant vectors (164 of them).\nEach number cooresponds to a two-digit character in the font's custom encoding.\niVec4s don't require float->integer conversions, but are so small that this\nprogram would need about 655 of them, which is just too much.\nInstead, we use 4x4 matrices, which require slightly more difficult lookup\nmethods, but allow us to use 1/4th the number of constant vectors.\n(We could compress things even further and use only half of that, but \nwe're good for the moment.)\n\nThe only problem? WebGL won't let us index into vectors, so we do a two-level\nheirarchical lookup instead: we find the row of the index, then do another\npseudo-switch statement to find the value itself.\n\nSo, we pack the 'string' (the code for printing) into 164 mat4s, then\nuse 166 statements of the form\n...\nif(i=113)b=a113;\n...\nto simulate a larger array.\n\nSince each mat4 is miraculously 64 characters long, it's really easy\nto write code which will print out the values of each mat4 in sequence,\nin the same way you might concatenate Console.Write() calls, except\nwe need to do binary->decimal conversion manually (since WebGL doesn't\nhave .ToString, of course)\n\nBy this point I had quickly realized manually typing about three thousand\ncharacter codes was out of the question, so I wrote a quick C# program to\ngenerate code for a Shadertoy program that would eventually generate itself.\nBy this point I had also realized that this was getting just a bit ridiculous.\n\nAnyways, if we keep on packing the code into one of these constant arrays and\nmodifying the code to handle the larger constant array, we should eventually\nreach a fixed point, at which point we'll be done.\n\nBUT WAIT! Each of those IF statements (which will be included in the code\nto be packed, remember) uses 17 characters - and a single mat4 can only\nhold 16. That means that the size of the code would rise exponentially and\nnever reach a fixed point, which is bad.\n\nThe solution?\nThe IF statements are predictable enough that we can print those in roughly\nthe same way as we print the mat4s.\n\nThe result converges in two iterations to exactly 166 constants.\n\nAnd then I made the text scroll down a slowly rotating plane with subtle\nvignetting, because Shadertoy can do that.\n\nCHANGELOG:\n2015-03-19: Thanks to poljere and CrossProduct, changed integer mods to use the md() function\nfor full compatibility with OpenGL ES 2.0. (Full quine-ness temporarily disabled for now)\n3:25 PM: Whoops. Now works on reasonably fast Windows boxes.\n\nThanks!\n-nbickford\n\n(Just FYI: This is a kinda-remote submission \nbecause I have to leave Friday morning. Sorry.)\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mlj3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[10791, 10791, 10805, 10805, 14770], [14772, 14772, 14786, 14786, 14899], [14901, 14901, 14925, 14925, 16114], [16116, 16116, 16138, 16138, 16439], [16441, 16441, 16467, 16467, 18753], [18755, 18755, 18812, 18875, 19710]], "test": "untested"}
{"id": "MljGR1", "name": "20150322_screw", "author": "FMS_Cat", "description": "", "tags": ["3d", "raymarching"], "likes": 4, "viewed": 230, "published": "Public", "date": "1427029155", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\n#define t iTime\n#define r iResolution.xy\n#define c fragCoord\n#define v vec2(0.,1.)\n\nfloat box( in vec3 _p, in vec3 _s )\n{\n    vec3 d = abs( _p ) - _s;\n    return min( max( d.x, max( d.y, d.z ) ), 0. ) + length( max( d, 0. ) );\n}\n\nfloat tube( in vec3 _p )\n{\n    vec3 p = _p+v.xyx*.05;\n    float th = p.y*( 150. );\n    p.xz = mat2( cos(th), -sin(th), sin(th), cos(th) )*p.xz;\n    float pole = length( p.xz+.01 )-.05;\n    float cut = box( p, v.yyy*.3 );\n    return max( pole, cut );\n}\n\nfloat cap( in vec3 _p )\n{\n    vec3 p = _p-v.xyx*.25;\n    float sphere = length( p*vec3( 1., 2., 1. ) )-.1;\n    float cut = box( p-v.xyx*.08, v.yyy*.1 );\n    float mountain = max( sphere, cut );\n    float cros = box( p-v.xyx*.05, vec3( .015, .015, .1 ) );\n    cros = min( cros, box( p-v.xyx*.05, vec3( .1, .015, .015 ) ) );\n    return max( mountain, -cros );\n}\n\nfloat scene( in vec3 _p )\n{\n    vec3 p = _p;\n    float th = t;\n    p.xy = mat2( cos(th), -sin(th), sin(th), cos(th) )*p.xy;\n    th = t*.73;\n    p.yz = mat2( cos(th), -sin(th), sin(th), cos(th) )*p.yz;\n    vec3 rep = vec3( .7, 1.4, .7 );\n    p += rep/2.+v.xyx*t*1.;\n    p = mod( p+rep/2., rep )-rep/2.;\n    th = -t*2.56;\n    p.zx = mat2( cos(th), -sin(th), sin(th), cos(th) )*p.zx;\n    return min( cap( p ), tube( p ) );\n}\n\nvec3 sceneNormal( in vec3 _p, in float _d )\n{\n    vec2 d = v*_d;\n    return normalize( vec3(\n        scene( _p+d.yxx ) - scene( _p-d.yxx ),\n        scene( _p+d.xyx ) - scene( _p-d.xyx ),\n        scene( _p+d.xxy ) - scene( _p-d.xxy )\n    ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (c*2.-r)/r.x;\n    \n    vec3 camPos = vec3( 0., 0., 1. );\n    vec3 camCen = v.xxx;\n    vec3 camDir = normalize( camCen - camPos );\n    vec3 camAir = v.xyx;\n    vec3 camSid = cross( camDir, camAir );\n    vec3 camTop = cross( camSid, camDir );\n    \n    vec3 rayDir = normalize( p.x*camSid + p.y*camTop + camDir );\n    \n    float dist = 1E3;\n    float rayLen = 0.;\n    vec3 rayPos = camPos;\n    for( int i=0; i<32; i++ )\n    {\n        dist = scene( rayPos )*.8;\n        rayLen += dist;\n        rayPos = camPos + rayDir*rayLen;\n        if( abs( dist ) < 1E-3 || 1E2 < rayLen ){ break; }\n    }\n    \n    vec3 col = v.xxx;\n    float dec = exp( -rayLen*.6 );\n    if( dist < 1E-1 )\n    {\n        vec3 matColor = v.yyy*6.6;\n        vec3 light = camPos;\n        vec3 normal = sceneNormal( rayPos, 1E-3 );\n        float dif = dot( normalize( rayPos-light ), -normal )*.5;\n        float amb = .2;\n        float spe = pow( dot( normalize( rayPos-light ), -normal )*1.02, 1E2 );\n        col = vec3( ( dif + amb )*matColor + spe )*dec;\n    }\n    col += vec3( 1.-dec*10. )*vec3( .4, .9, 2. );\n    \n\tfragColor = vec4( col, 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljGR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[106, 106, 143, 143, 250], [252, 252, 278, 278, 503], [505, 505, 530, 530, 864], [866, 866, 893, 893, 1287], [1289, 1289, 1334, 1334, 1532], [1534, 1534, 1591, 1591, 2713]], "test": "untested"}
{"id": "MljGRm", "name": "Blue Sphere Raytracer", "author": "SiENcE", "description": "Raytraced blue transparent sphere.\n\nIt just needs some fine softshadows like described here:\nhttp://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm", "tags": ["raytracer", "sun", "sphere", "blue"], "likes": 11, "viewed": 1699, "published": "Public API", "date": "1427809638", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphere(vec3 ray, vec3 dir, vec3 center, float radius)\n{\n\tvec3 rc = ray-center;\n\tfloat c = dot(rc, rc) - (radius*radius);\n\tfloat b = dot(dir, rc);\n\tfloat d = b*b - c;\n\tfloat t = -b - sqrt(abs(d));\n\tfloat st = step(0.0, min(t,d));\n\treturn mix(-1.0, t, st);\n}\n\nvec3 background(float t, vec3 rd)\n{\n\tvec3 light = normalize(vec3(sin(t), 0.6, cos(t)));\n\tfloat sun = max(0.0, dot(rd, light));\n\tfloat sky = max(0.0, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tfloat ground = max(0.0, -dot(rd, vec3(0.0, 1.0, 0.0)));\n\treturn \n\t\t(pow(sun, 256.0)+0.2*pow(sun, 2.0))*vec3(2.0, 1.6, 1.0) +\n\t\tpow(ground, 0.4)*vec3(0.7, 0.6, 0.4) +\n\t\tpow(sky, 0.0)*vec3(0.5, 0.6, 0.7);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (-1.0 + 2.0*fragCoord.xy / iResolution.xy) * vec2(iResolution.x/iResolution.y, 1.0);\n\n\tvec3 ro = vec3(0.0, 0.0, -3.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 p = vec3(0.0, 0.0, 0.0);\n\tfloat t = sphere(ro, rd, p, 1.0);\n\n\tvec3 nml = normalize(p - (ro+rd*t));\n\tvec3 bgCol = background(iTime, rd);\n\trd = reflect(rd, nml);\n\tvec3 col = background(iTime, rd);\n\n\t// make sandstorm background \n//\tbgCol = normalize(bgCol.rgb);\n    \n\t// change color of the sphere to blue\n    col.r = col.r-0.50;\n    col.b = col.b+0.50;\n\t\n\tfragColor = vec4( mix( bgCol, col, step(0.0, t)), 1.0 );\n}  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MljGRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 262], [264, 264, 299, 299, 649], [651, 651, 708, 708, 1295]], "test": "untested"}
{"id": "Mll3Dl", "name": "Color Channels", "author": "shaktool", "description": "Introduction to using color channels. ", "tags": ["simple"], "likes": 0, "viewed": 259, "published": "Public", "date": "1426293532", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float red   = fragCoord.x / iResolution.x;\n    float green = fragCoord.y / iResolution.y;\n    float blue  = sin(iTime) * 0.5 + 0.5;\n    \n\tfragColor.rgb = vec3(red, green, blue);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mll3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 241]], "test": "untested"}
{"id": "Mll3DX", "name": "Oculus Test", "author": "daeken", "description": "Testing a field of cubes for oculus, for distortion calibration.", "tags": ["shaderforth", "oculus"], "likes": 3, "viewed": 230, "published": "Public", "date": "1425875032", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ noise ]\n\n:globals\n\ttrue =>shadertoy\n\t\t{\n\t\t\t@vec3 uniform =iResolution @float uniform =iTime\n\t\t\tiResolution .xy =>resolution\n\t\t\tiTime =>time\n\t\t}\n\t\t{ @vec2 uniform =resolution @float uniform =time }\n\tshadertoy cif\n\t@float =scene-noise\n;\n\n:m noise-2d pnoise-2d ;\n:m terrain ( p )\n\t20 2 p .x 6 / abs 0 1 clamp mix =>factor\n\t\tp .xz 2 / noise-2d factor /\n\t\tp .y neg\n\t-\n;\n\n:m ring-terrain ( p )\n\t[\n\t\t[\n\t\t\tp [ 0 .6 0 ] - [ 1 p .y - .05 * 1 - 2.5 2 ] / [ 1 .1 ] torus\n\t\t\tp [ 0 4.8 0 ] + 5 sphere\n\t\t] 1.25 unionsmooth\n\t\tp terrain\n\t] .2 unionsmooth\n;\n\n:m walkway ( p )\n\t{ ( $rp )\n\t\t[ rp .xz p rp - .x.z + 13.7 * sin .5 * rotate-2d rp .y ] .xzy [ .4 .1 .4 ] box\n\t} p [ 0 1 0 ] + [ 0 0 1 ] repeat\n;\n\n:m portal ( p )\n\t[\n\t\tp [ 0 .3 0 ] + [ 1 2.5 1 ] / 1 sphere\n\t\tp [ 1 3 .04 ] box\n\t] intersect\n;\n\n:m columns ( p )\n\tp .x sign neg =>flip\n\t{ ( $rp )\n\t\t[\n\t\t\t[ rp .xz rp .y flip * pi 2 / * pi 8 / + rotate-2d rp .y ] .xzy [ 0 1 0 ] + [ .2 1.5 .2 ] box\n\t\t\trp [ 0 1.25 0 ] - .4 sphere\n\t\t] .75 unionsmooth\n\t} p [ 2.25 0 2.5 ] repeat\n;\n\n:m hell-terrain ( p )\n\tp [ 0 p .z 4 / 0 ] + [ 0 1 0 1 ] plane scene-noise p .x time 1 + 2 * + sin .1 * + -.3 .6 clamp .4 * +\n;\n\n: scene ( p:vec3 -> vec2 )\n\t{ ( rp )\n\t\t[ rp [ .25 .25 .25 ] box 2 ]\n\t} p [ 2 2 2 ] repeat\n\t( p .x 100 / round =room\n\tp [ room 100 * 0 0 ] - =p\n\troom 1 eq =heaven\n\troom 2 eq =>hell\n\t\tp .xz [ 1.5 1 ] *\n\t\t[ 0 time neg 1.5 / heaven mix 0 time heaven hell + mix 1 .3 heaven mix * ] - \n\t\tp .y +\n\t\t\t.75\n\t\t\t3 room -\n\t\troom 1 - sign abs mix\n\t* noise-2d =scene-noise\n\t[\n\t\troom 0 == {\n\t\t\t[\n\t\t\t\t[ p [ 0 1 0 ] + ring-terrain 1 ]\n\t\t\t\t[ p walkway 2 ]\n\t\t\t\t[ p portal 3 ]\n\t\t\t] hitunion\n\t\t}\n\t\troom 1 == {\n\t\t\tp [ 1 p .z -.04 * + 1 1 ] * [ 0 p .z .05 * 0 ] + =p\n\t\t\t[\n\t\t\t\t[\n\t\t\t\t\t[\n\t\t\t\t\t\tp [ 0 1 0 ] + [ 0 1 0 0 ] plane\n\t\t\t\t\t\tp columns\n\t\t\t\t\t] .75 unionsmooth\n\t\t\t\t\tp [ 0 0 far .2 + ] - [ 1.5 far far ] box\n\t\t\t\t] intersect\n\t\t\t\t4\n\t\t\t]\n\t\t}\n\t\t{\n\t\t\t[ p hell-terrain 5 ]\n\t\t}\n\t] cond =>temp\n\troom 1 - sign abs temp .y 3 - sign abs * =>is-portal\n\ttemp [ scene-noise .03 * is-portal * 0 ] + )\n;\n\n:m portal-texture ( p )\n\t\t[\n\t\t\t##000\n\t\t\t.5 .5 0\n\t\t\tp .z sign 1 + 2 / 1 +\n\t\t\t0\n\t\t] material\n;\n\n:m marble-texture ( p )\n\tscene-noise abs =>noise\n\t##DBDBDB ##4F5052 noise mix =>color\n\t[ p .y .2 - 0 1 clamp 2 ** color - abs .3 .7 noise 100 * eps + 0 0 ] material\n;\n\n:m hell-texture ( p )\n\t[ ##525252 .05 .5 10 0 0 ] material\n;\n\n: get-material ( pos:vec3 dist:float id:float -> material )\n\t[\n\t\tid 1 == {\n\t\t\tpos .y .6 + 0 1 clamp =fade\n\t\t\t[ ##7A3B14 ##878787 fade mix .4 .7 1000 10 fade mix 0 -.3 ] material\n\t\t}\n\t\tid 2 == { [ ##DBDBDB ##525252 pos .z sign 0 1 clamp mix .3 .7 1000 0 0 ] material }\n\t\tid 3 == { pos portal-texture }\n\t\tid 4 == { pos marble-texture }\n\t\t{ pos hell-texture }\n\t] cond\n;\n\n:m union \\min ;\n:m unionsmooth ( list k ) list \\{ ( a b ) a b k smin-poly } ;\n:m hitunion \\{ ( $a $b ) a b a .x b .x < select } ;\n:m hitunionsmooth ( list k )\n\tlist \\{ ( $a $b )\n\t\ta .x b .x k smin-poly =smin\n\t\t[\n\t\t\tsmin\n\t\t\ta .y b .y a .x smin - abs b .x smin - abs < select\n\t\t]\n\t}\n;\n:m subtract \\{ ( d1 d2 ) d1 neg d2 max } ;\n:m intersect \\max ;\n:m hitintersect \\{ ( $a $b ) a b a .x b .x > select } ;\n:m repeat ( block p c ) p p c mod c 1000 * 0 1 clamp mix 0.5 c * - *block ;\n\n:m sphere ( p s ) p length s - ;\n:m torus ( $p t ) [ p .xy length t .x - p .z ] length t .y - ;\n: box ( p:vec3 b:vec3 -> float )\n\tp abs b - =d\n\td \\max 0 min\n\td 0 max length +\n;\n:m plane ( p n )\n\tp n .xyz dot n .w +\n;\n\n:struct material\n\t@vec3 =color\n\t@float =ambient\n\t@float =diffuse\n\t@float =specular\n\t@float =room\n\t@float =normal-mod\n;\n\n:struct hit\n\t@vec3 =pos\n\t@vec3 =origin\n\t@vec3 =dir\n\t@float =dist\n\t@float =total-dist\n\t@material =mat\n;\n\n:m tx [ _ 0 0 ] + ;\n:m ty [ 0 _ 0 ] + ;\n:m tz [ 0 0 _ ] + ;\n:m get-normal ( p )\n\t[\n\t\tp eps     tx scene .x\n\t\tp eps neg tx scene .x -\n\t\tp eps     ty scene .x\n\t\tp eps neg ty scene .x -\n\t\tp eps     tz scene .x\n\t\tp eps neg tz scene .x -\n\t] normalize\n;\n\n:m lightpos [ 0 room 100 * + 5 5 -1 room 1 - abs mix ] ;\n\n:m shadow-dist 0.1 ;\n\n: get-shadow ( ray:vec3 lpos:vec3 -> float )\n\tlpos ray - normalize =dir\n\tshadow-dist 10 * =dist\n\tlpos ray - length =mdist\n\tfar =lowest\n\t{\n\t\tray dir 2 * dist * + scene =cur\n\t\tlowest cur .x min =lowest\n\t\tdist cur .x abs shadow-dist max + =dist\n\t\t&break cur .x abs shadow-dist < dist mdist >= or when\n\t} 3 times\n\tlowest 0 max 0 shadow-dist .8 ** smoothstep\n;\n\n: ambient-occlusion ( pos:vec3 dir:vec3 cdist:float -> float )\n\tpos dir cdist * + =>npos\n\tnpos scene .x far min =>lowest\n\t0 lowest cdist 1.75 / smoothstep\n;\n\n: apply-fog ( color:vec3 cur:hit dist:float miss:float -> vec3 )\n\t\tcolor\n\t\tcur .origin 1 miss - * cur .dir sky\n\t\tdist cur .total-dist miss mix far fog - - fog / fog-factor * 0 1 clamp\n\tmix\n;\n\n: shade ( cur:hit -> vec3 )\n\tcur .pos =>pos\n\tpos .x 100 / round =room\n\tpos get-normal =normal\n\n\tlightpos =lpos\n\tlpos pos - normalize =ivec\n\tivec normal dot 0 max =incidence\n\tincidence =>diffuse\n\tpos normal cur .dist ambient-occlusion =>ambient\n\n\tcur .mat =>mat\n\n\t0 =specular\n\t{\n\t\t\tivec cur .origin + normalize normal dot\n\t\t\t0\n\t\tmax mat .specular pow\n\t\tlpos pos - length / =specular\n\t} mat .specular 0 != incidence 0 > and when\n\n\tcur .pos lpos get-shadow =shadow\n\n\t\t\tmat .color rgb->hsv1\n\t\t\t\t[ 1 1\n\t\t\t\t\tdiffuse mat .diffuse * shadow *\n\t\t\t\t\tambient mat .ambient * +\n\t\t\t\t\tspecular shadow * +\n\t\t\t\t\tnormal .x abs mat .normal-mod * +\n\t\t\t\t]\n\t\t* hsv1->rgb\n\tcur cur .origin.pos - length 0 apply-fog\n;\n\n:m nullhit\n\t[ ray ray dir far tdist [ 0 vec3 0 0 0 0 0 ] material ] hit\n;\n\n: march ( ray:vec3 dir:vec3 -> hit )\n\tclose =t\n\t0 =tdist\n\t2 =>magic-factor\n\tclose magic-factor * =minstep\n\tfar =last\n\t0 =room\n\t{\n\t\tray dir t * + scene =cur\n\t\t{ nullhit return } cur .x far > when\n\t\t{\n\t\t\t\t{\n\t\t\t\t\tt tdist + =tdist\n\t\t\t\t\t0 =t\n\t\t\t\t\tray 0 3 get-material =mat\n\t\t\t\t\tmat .room =room\n\t\t\t\t\tray [ room 100 * 0 0 ] + =ray\n\t\t\t\t}\n\t\t\t\t&break\n\t\t\tcur .y 3 == if\n\t\t}\n\t\t{\n\t\t\tt cur .x abs minstep + + =t\n\t\t\t{ nullhit return } t far > when\n\t\t\t{\n\t\t\t\tminstep close magic-factor / 3 * + =minstep\n\t\t\t} cur .x last >= room 0 == and when\n\t\t\tcur .x =last\n\t\t} cur .x close close magic-factor / t * + <= if\n\t} 40 times\n\n\tray dir t cur .x + * + =fray\n\n\t[\n\t\tfray\n\t\tray\n\t\tdir\n\t\tcur .x\n\t\ttdist\n\t\tfray cur .x.y get-material\n\t] hit\n;\n\n:m cut-horizon\n\t##000 1 dir .y - 0 1 clamp 2 ** mix\n;\n\n:m clouds ( dir )\n\tdir .xy cart->polar [ 3 7 ] * [ 0 time ] + noise-2d .2 .8 clamp .2 - vec3 cut-horizon\n;\n\n: sky ( origin:vec3 dir:vec3 -> vec3 )\n\torigin .x 100 / round =>room\n\t[\n\t\t0\t##6010C9 ##111438 dir .y 2.5 * mix\n\t\t1\t##FCFFD9 ##9CC5FF dir .y 6 * mix\n\t\t\t##AB1529 ##360B11 dir .y 5 * mix\n\t] room choose\n;\n\n2 =>focus\n:m far 20 ;\n:m fog 14 ;\n:m fog-factor 1.5 ;\n:m close 0.005 ;\n\n: camera-turn ( p:vec3 -> vec3 )\n\ttime 8 - 0 max 3.5 / =v\n\t[ p .xz v 0 1 clamp 1.2 ** v 1 - 0 max + neg rotate-2d p .y ] .xzy\n;\n\n: Kt ( i:int -> float )\n\t[\n\t\t\t[ 1.003000 1.020000 1.042000 1.066000 1.094000\n\t\t\t  1.126000 1.162000 1.203000 1.250000 1.310000 ]\n\t\tenumerate /{ =>[ k v ] i k int == { v return } } flatten\n\t\t{ 1.380000 return }\n\t] cond\n;\n:m K[] int Kt ;\n\n: catmull-rom ( r:float -> float )\n\t11 =>num_segments\n\t[ 10 r 3.6 ] \\* =scaled_val\n\t0 10 scaled_val floor min max =scaled_val_floor\n\tscaled_val_floor int =k\n    1 =k0p0\n    1 K[] 0 K[] - =k0m0\n    1 K[] =k0p1\n    2 K[] 0 K[] - .5 * =k0m1\n\n    k K[] =p0\n    k #1 + K[] k #1 - K[] - .5 * =m0\n    k #1 + K[] =p1\n    k #2 + K[] k K[] - .5 * =m1\n\n    k #0 == float =k0\n\n    k0 k0p0 * 1 k0 - p0 * + =p0\n    k0 k0p1 * 1 k0 - p1 * + =p1\n    k0 k0m0 * 1 k0 - m0 * + =m0\n    k0 k0m1 * 1 k0 - m1 * + =m1\n\n    scaled_val scaled_val_floor - =t\n    1 t - =omt\n\t    p0 1 2 t * + * m0 t * + omt !* *\n\t    p1 1 2 omt * + * m1 omt * - t !* *\n    +\n;\n\nresolution frag->position =pos\npos .x sign neg .1 * =eyeoff\nresolution .x.y / =rs\ntrue =>occlude-lens\n[ pos .x rs + rs mod rs 2 / - pos .y ] =eyepos\neyepos [ 1 resolution .y.x 2 / / ] / 2 / =eyepos\neyepos !dot =radsq\neyepos radsq 1.5 * catmull-rom * =eyepos\neyepos 2 * [ 1 resolution .y.x 2 / / ] * =eyepos\n\n1 time 10 / - 0 1 clamp 3 ** 100 * =>running\n[ 0 .5 -4 running - time 10 - 0 max 4 / sin .1 * + ] [ eyeoff 0 0 ] + camera-turn =origin\n[ 0 .5 -1 ] camera-turn =>ct\n\nct origin - normalize =cd\n[ 0 1 0 ] =>cu\ncd cu cross =>cs\ncs eyepos .x * cu eyepos .y * + cd focus * + normalize =>dir\n\n:m fade-in ( color )\n\t##fff color time .5 - 2 / 0 1 clamp mix\n;\n\n\t{\n\t\torigin dir march =cur\n\t\t\t{ cur shade fade-in ->fragcolor }\n\t\t\t{\n\t\t\t\t\tcur .origin.dir sky =cursky\n\t\t\t\t\t\tcursky\n\t\t\t\t\t\tcursky cur far 1 apply-fog\n\t\t\t\t\tcur .total-dist far * 1 min mix\n\t\t\t\tfade-in ->fragcolor\n\t\t\t}\n\t\tcur .dist close 10 * < if\n\t} { 0 vec3 ->fragcolor }\nradsq .195 < occlude-lens not or if\n*/\n\nstruct material {\n\tvec3 color;\n\tfloat ambient;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat room;\n\tfloat normal_mod;\n};\nstruct hit {\n\tvec3 pos;\n\tvec3 origin;\n\tvec3 dir;\n\tfloat dist;\n\tfloat total_dist;\n\tmaterial mat;\n};\nfloat scene_noise;\nmaterial get_material(vec3 pos, float dist, float id) {\n\tmaterial temp_1;\n\tif(id == 1.) {\n\t\tfloat fade = clamp(pos.y + .6, 0., 1.);\n\t\ttemp_1 = material(mix(vec3(.47843, .23137, .078431), vec3(.52941, .52941, .52941), fade), .4, .7, mix(1000., 10., fade), 0., -.3);\n\t} else if(id == 2.) {\n\t\ttemp_1 = material(mix(vec3(.85882, .85882, .85882), vec3(.32157, .32157, .32157), clamp(sign(pos.z), 0., 1.)), .3, .7, 1000., 0., 0.);\n\t} else if(id == 3.) {\n\t\ttemp_1 = material(vec3(0., 0., 0.), .5, .5, 0., (sign(pos.z) + 1.) / 2. + 1., 0.);\n\t} else if(id == 4.) {\n\t\ttemp_1 = material(abs(pow(clamp(pos.y - .2, 0., 1.), 2.) - mix(vec3(.85882, .85882, .85882), vec3(.30980, .31373, .32157), abs(scene_noise))), .3, .7, abs(scene_noise) * 100. + .00001, 0., 0.);\n\t} else {\n\t\ttemp_1 = material(vec3(.32157, .32157, .32157), .05, .5, 10., 0., 0.);\n\t}\n\treturn temp_1;\n}\nfloat Kt(int i) {\n\tif(i == 0) {\n\t\treturn 1.003000;\n\t} else if(i == 1) {\n\t\treturn 1.020000;\n\t} else if(i == 2) {\n\t\treturn 1.042000;\n\t} else if(i == 3) {\n\t\treturn 1.066000;\n\t} else if(i == 4) {\n\t\treturn 1.094000;\n\t} else if(i == 5) {\n\t\treturn 1.126000;\n\t} else if(i == 6) {\n\t\treturn 1.162000;\n\t} else if(i == 7) {\n\t\treturn 1.203000;\n\t} else if(i == 8) {\n\t\treturn 1.250000;\n\t} else if(i == 9) {\n\t\treturn 1.310000;\n\t} else {\n\t\treturn 1.380000;\n\t}\n}\nvec3 sky(vec3 origin, vec3 dir) {\n\treturn (floor(origin.x / 100. + .5) == 0. ? mix(vec3(.37647, .062745, .78824), vec3(.066667, .078431, .21961), dir.y * 2.5) : (floor(origin.x / 100. + .5) == 1. ? mix(vec3(.98824, 1., .85098), vec3(.61176, .77255, 1.), dir.y * 6.) : mix(vec3(.67059, .082353, .16078), vec3(.21176, .043137, .066667), dir.y * 5.)));\n}\nvec3 apply_fog(vec3 color, hit cur, float dist, float miss) {\n\treturn mix(color, sky(cur.origin * (1. - miss), cur.dir), clamp((mix(dist, cur.total_dist, miss) - 6.) / 14. * 1.5, 0., 1.));\n}\nfloat pnoise_2d(vec2 v) {\n\tvec4 Pi = mod(floor(v.xyxy) + vec4(0., 0., 1., 1.), 289.);\n\tvec4 Pf = fract(v.xyxy) - vec4(0., 0., 1., 1.);\n\tvec4 gx = fract(mod(((mod((Pi.xzxz * 34. + 1.) * Pi.xzxz, 289.) + Pi.yyww) * 34. + 1.) * (mod((Pi.xzxz * 34. + 1.) * Pi.xzxz, 289.) + Pi.yyww), 289.) / 41.) * 2. - 1.;\n\tvec4 gy = abs(gx) - .5;\n\tgx -= floor(gx + .5);\n\tvec4 norm = inversesqrt(sqrt(gx * gx + gy * gy));\n\tvec2 fade_xy = ((Pf.xy * 6. - 15.) * Pf.xy + 10.) * pow(Pf.xy, vec2(2.));\n\tvec2 n_x = mix(vec2(dot(vec2(gx.x, gy.x) * norm.x, Pf.xy), dot(vec2(gx.z, gy.z) * norm.y, Pf.xw)), vec2(dot(vec2(gx.y, gy.y) * norm.z, Pf.zy), dot(vec2(gx.w, gy.w) * norm.w, Pf.zw)), fade_xy.x);\n\treturn mix(n_x.x, n_x.y, fade_xy.y) * 2.3;\n}\nfloat box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.));\n}\nvec2 rotate_2d(vec2 c, float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn vec2(c.x * ca - c.y * sa, c.y * ca + c.x * sa);\n}\nvec3 hsv1_rgb(vec3 hsv) {\n\treturn mix(vec3(1., 1., 1.), clamp(abs(mod(hsv.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.), hsv.y) * hsv.z;\n}\nfloat smin_poly(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\nvec2 scene(vec3 p) {\n\treturn vec2(box(mix(p, mod(p, vec3(2., 2., 2.)), vec3(1., 1., 1.)) - vec3(1.0, 1.0, 1.0), vec3(.25, .25, .25)), 2.);\n}\nfloat get_shadow(vec3 ray, vec3 lpos) {\n\tvec3 dir = normalize(lpos - ray);\n\tfloat dist = 1.0;\n\tfloat mdist = length(lpos - ray);\n\tfloat lowest = 20.;\n\tfor(int temp_5 = 0; temp_5 < 3; ++temp_5) {\n\t\tvec2 cur = scene(ray + dir * 2. * dist);\n\t\tlowest = min(lowest, cur.x);\n\t\tdist += max(abs(cur.x), .1);\n\t\tif(abs(cur.x) < .1 || dist >= mdist) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn smoothstep(max(lowest, 0.), 0., .15849);\n}\nhit march(vec3 ray, vec3 dir) {\n\tvec2 cur;\n\tfloat t = .005;\n\tfloat tdist = 0.;\n\tfloat minstep = .010;\n\tfloat last = 20.;\n\tfloat room = 0.;\n\tfor(int temp_6 = 0; temp_6 < 40; ++temp_6) {\n\t\tcur = scene(ray + dir * t);\n\t\tif(cur.x > 20.) {\n\t\t\treturn hit(ray, ray, dir, 20., tdist, material(vec3(0.), 0., 0., 0., 0., 0.));\n\t\t}\n\t\tif(cur.x <= (.005 + .0025 * t)) {\n\t\t\tif(cur.y == 3.) {\n\t\t\t\ttdist += t;\n\t\t\t\tt = 0.;\n\t\t\t\tmaterial mat = get_material(ray, 0., 3.);\n\t\t\t\troom = mat.room;\n\t\t\t\tray += vec3(room * 100., 0., 0.);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tt += abs(cur.x) + minstep;\n\t\t\tif(t > 20.) {\n\t\t\t\treturn hit(ray, ray, dir, 20., tdist, material(vec3(0.), 0., 0., 0., 0., 0.));\n\t\t\t}\n\t\t\tif(cur.x >= last && room == 0.) {\n\t\t\t\tminstep += .0075;\n\t\t\t}\n\t\t\tlast = cur.x;\n\t\t}\n\t}\n\tvec3 fray = ray + dir * (t + cur.x);\n\treturn hit(fray, ray, dir, cur.x, tdist, get_material(fray, cur.x, cur.y));\n}\nfloat ambient_occlusion(vec3 pos, vec3 dir, float cdist) {\n\treturn smoothstep(0., min(scene(pos + dir * cdist).x, 20.), cdist / 1.75);\n}\nvec3 camera_turn(vec3 p) {\n\tfloat v = max(iTime - 8., 0.) / 3.5;\n\treturn vec3(rotate_2d(p.xz, -(pow(clamp(v, 0., 1.), 1.2) + max(v - 1., 0.))), p.y).xzy;\n}\nvec3 rgb_hsv1(vec3 rgb) {\n\tvec4 K = vec4(0., -.33333, .66667, -1.);\n\tvec4 p = (rgb.g < rgb.b ? vec4(rgb.bg, K.wz) : vec4(rgb.gb, K.xy));\n\tvec4 q = (rgb.r < p.x ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx));\n\tfloat d = q.x - min(q.w, q.y);\n\treturn vec3(abs(q.z + (q.w - q.y) / (6. * d + .00001)), d / (q.x + .00001), q.x);\n}\nvec3 shade(hit cur) {\n\tfloat room = floor(cur.pos.x / 100. + .5);\n\tvec3 normal = normalize(vec3(scene(cur.pos + vec3(.00001, 0., 0.)).x - scene(cur.pos + vec3(-.00001, 0., 0.)).x, scene(cur.pos + vec3(0., .00001, 0.)).x - scene(cur.pos + vec3(0., -.00001, 0.)).x, scene(cur.pos + vec3(0., 0., .00001)).x - scene(cur.pos + vec3(0., 0., -.00001)).x));\n\tvec3 lpos = vec3(room * 100., 5., mix(5., -1., abs(room - 1.)));\n\tvec3 ivec = normalize(lpos - cur.pos);\n\tfloat incidence = max(dot(ivec, normal), 0.);\n\tfloat specular = 0.;\n\tif(cur.mat.specular != 0. && incidence > 0.) {\n\t\tspecular = pow(max(dot(normalize(ivec + cur.origin), normal), 0.), cur.mat.specular) / length(lpos - cur.pos);\n\t}\n\tfloat shadow = get_shadow(cur.pos, lpos);\n\treturn apply_fog(hsv1_rgb(rgb_hsv1(cur.mat.color) * vec3(1., 1., incidence * cur.mat.diffuse * shadow + ambient_occlusion(cur.pos, normal, cur.dist) * cur.mat.ambient + specular * shadow + abs(normal.x) * cur.mat.normal_mod)), cur, length(cur.origin - cur.pos), 0.);\n}\nfloat catmull_rom(float r) {\n\tfloat scaled_val = 10. * r * 3.6;\n\tfloat scaled_val_floor = max(0., min(10., floor(scaled_val)));\n\tint k = int(scaled_val_floor);\n\tfloat k0p0 = 1.;\n\tfloat k0m0 = Kt(1) - Kt(0);\n\tfloat k0p1 = Kt(1);\n\tfloat k0m1 = (Kt(2) - Kt(0)) * .5;\n\tfloat p0 = Kt(int(k));\n\tfloat m0 = (Kt(int(k + 1)) - Kt(int(k - 1))) * .5;\n\tfloat p1 = Kt(int(k + 1));\n\tfloat m1 = (Kt(int(k + 2)) - Kt(int(k))) * .5;\n\tfloat k0 = float(k == 0);\n\tp0 = k0 * k0p0 + (1. - k0) * p0;\n\tp1 = k0 * k0p1 + (1. - k0) * p1;\n\tm0 = k0 * k0m0 + (1. - k0) * m0;\n\tm1 = k0 * k0m1 + (1. - k0) * m1;\n\tfloat t = scaled_val - scaled_val_floor;\n\tfloat omt = 1. - t;\n\treturn (p0 * (1. + 2. * t) + m0 * t) * omt * omt + (p1 * (1. + 2. * omt) - m1 * omt) * t * t;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tfloat eyeoff = -sign(pos.x) * .1;\n\tfloat rs = iResolution.x / iResolution.y;\n\tvec2 eyepos = vec2(mod(pos.x + rs, rs) - rs / 2., pos.y);\n\teyepos = eyepos / vec2(1., iResolution.y / (iResolution.x / 2.)) / 2.;\n\tfloat radsq = dot(eyepos, eyepos);\n\teyepos *= catmull_rom(radsq * 1.5);\n\teyepos = eyepos * 2. * vec2(1., iResolution.y / (iResolution.x / 2.));\n\tvec3 origin = camera_turn(vec3(0., .5, -4. - pow(clamp(1. - iTime / 10., 0., 1.), 3.) * 100. + sin(max(iTime - 10., 0.) / 4.) * .1) + vec3(eyeoff, 0., 0.));\n\tvec3 cd = normalize(camera_turn(vec3(0., .5, -1.)) - origin);\n\tif(radsq < .195 || false) {\n\t\thit cur = march(origin, normalize(cross(cd, vec3(0., 1., 0.)) * eyepos.x + vec3(0., 1., 0.) * eyepos.y + cd * 2.));\n\t\tif(cur.dist < .050) {\n\t\t\tfragColor = vec4(mix(vec3(1., 1., 1.), shade(cur), clamp((iTime - .5) / 2., 0., 1.)), 1.);\n\t\t} else {\n\t\t\tvec3 cursky = sky(cur.origin, cur.dir);\n\t\t\tfragColor = vec4(mix(vec3(1., 1., 1.), mix(cursky, apply_fog(cursky, cur, 20., 1.), min(cur.total_dist * 20., 1.)), clamp((iTime - .5) / 2., 0., 1.)), 1.);\n\t\t}\n\t} else {\n\t\tfragColor = vec4(vec3(0.), 1.);\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mll3DX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 8846, 8901, 8901, 9701], [9702, 9702, 9719, 9719, 10146], [10147, 10147, 10180, 10180, 10498], [10499, 10499, 10560, 10560, 10689], [10690, 10690, 10715, 10715, 11409], [11410, 11410, 11437, 11437, 11524], [11525, 11525, 11558, 11558, 11656], [11657, 11657, 11682, 11682, 11800], [11801, 11801, 11845, 11845, 11937], [11938, 11938, 11958, 11958, 12078], [12079, 12079, 12118, 12118, 12487], [12488, 12488, 12519, 12519, 13377], [13378, 13378, 13436, 13436, 13514], [13515, 13515, 13541, 13541, 13670], [13671, 13671, 13696, 13696, 13991], [13992, 13992, 14013, 14013, 14993], [14994, 14994, 15022, 15022, 15732], [15733, 15733, 15788, 15788, 16991]], "test": "untested"}
{"id": "Mll3Wl", "name": "Raymarching displacement test", "author": "jcanabald", "description": "Testing some procedural displacements with raymarching techniques ", "tags": ["raymarching", "displacement", "worley"], "likes": 19, "viewed": 592, "published": "Public", "date": "1426259201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Raymarching - Jose Angel Canabal\n// based on inigo quilez work\n\n// --------- Worley Noise ------------\n\n#define SIZE 6.0\n\n\nvec2 hash2D( vec2 p )\n{\n    float r = 523.0 * sin( dot( p, vec2( 53.3158, 43.6143 ) ) );\n    return vec2( fract( 15.32354 * r ), fract( 17.25865 * r ) );\n}\n\nvec3 hash3D( vec3 p )\n{\n    float r = 523.0 * sin( dot( p, vec3( 53.3158, 43.6143, 12.1687 ) ) );\n    return vec3( fract( 15.32354 * r ), fract( 17.25865 * r ), fract( 11.1021 * r ) );\n}\n\nmat4 getTranslationMatrix( vec3 t )\n{\n    mat4 tm = mat4( 1.0 );\n    \n    tm[0].z = t.x;\n    tm[1].z = t.y;\n    tm[2].z = t.z;\n    \n    return tm;\n}\n    \nvec3 worley( vec3 p, inout vec3 cp )\n{\n    // copy p if necessary\n    vec3 q = p;\n    \n    p *= SIZE;\n    \n    // get the pixel's cell\n    vec3 c = floor( p );\n    \n    // the three closest distances\n    vec3 f = vec3( 1e06 );\n    \n    // look for the closest point\n    for( int i=-1; i<=1; i++ )\n    for( int j=-1; j<=1; j++ )\n    for( int k=-1; k<=1; k++ )\n    {\n        // get the point at this grid cell\n        vec3 g = c + vec3( float( i ), float( j ), float( k ) );\n        vec3 o = g + hash3D( g);\n        // compute the distance between the current pixel and the grid point\n        vec3 r = p - o;\n        \n        // euclidean^2 distance\n        float d = dot( r, r );\n        // euclidean\n        //d = sqrt( d );\n        \n        //float d = length(r);\n        \n        // manhatan distance\n        //float d = abs( r.x ) + abs( r.y ) + abs( r.z );\n        \n        // check if it's the closest point\n        if( d < f.x )\n        {\n            f.z = f.y;\n            f.y = f.x;\n            f.x = d;\n            cp.x = o.x + o.y + o.z;\n        }\n        else if( d < f.y )\n        {\n            f.z = f.y;\n            f.y = d;\n            cp.y = o.x + o.y + o.z;\n        }\n        else if( d < f.z )\n        {\n            f.z = d;\n            cp.z = o.x + o.y + o.z;\n        }\n    }\n    \n    return f;\n}\n\n\n// signed distance field of a plane\nfloat sdPlane( vec3 p )\n{\n    return p.y;\n}\n\n// signed distance field of a sphere\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p) - s;\n}\n\n// sphere with a worley noise displacement\nfloat sdDisplacementSphere( vec3 p, vec3 f, vec3 cp, int fn )\n{\n    \n    float w = sqrt(f.x);\n    \n    // different combinations with the distances\n    if( fn == 1 ) \t\tw = 1.0 - f.x;\n    else if( fn == 2 ) \tw = f.y - f.x;\n    else if( fn == 3 )\tw = 0.5*f.x + 0.25*f.y + 0.125*f.z;\n    else if( fn == 4 )\tw = sqrt( 1.0 - 2.0*( 0.5*f.x - 0.1*f.y ) );\n\n    w = clamp( w, 0.0, 1.0 );\n        \n    float d1 = sdSphere( p, 1.0 );\n    float d2 = 0.06*( 1.0 - w );\n    //float d2 = 0.06*( 1.3 + 0.3*sin( 10.0*iTime ) )*(1.0 - w );\n    return d1 + d2;\n}\n\n// return the closest point\nvec2 computeVisibility( vec2 dm1, vec2 dm2 )\n{\n    return ( dm1.x < dm2.x ) ? dm1 : dm2;\n}\n\n// this function represent the scene. Return a signed distance and\n// a float that represents the material\nvec2 scene( vec3 pos )\n{  \n    vec3 cp = vec3( 2.0 );\n    vec3 f = worley( pos - vec3(  0.0, 1.0,  0.0  ), cp );\n    \n    vec2 dm = computeVisibility( \n        vec2( sdPlane( pos ), 1.0 ),\n        vec2( sdDisplacementSphere( pos - vec3( -5.0, 1.0, -2.0 ), f, cp, 0 ), 2.0 ) );\n    \n    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3(  -2.5, 1.0, -1.0 ), f, cp, 1 ), 3.0 ) );\n    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3(  0.0, 1.0,  0.0 ), f, cp, 2 ), 4.0 ) );\n    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3( 2.5, 1.0, -1.0 ), f, cp, 3 ), 3.0 ) );\n    dm = computeVisibility( dm, vec2( sdDisplacementSphere( pos - vec3( 5.0, 1.0, -2.0 ), f, cp, 4 ), 2.0 ) );\n    //vec2 dm = vec2( sdSphere( pos, 1.0 ), 1.0 );\n    return dm;\n}\n\n// computes the normal using finite differences\nvec3 calcNormal( vec3 pos )\n{\n    float eps = 0.01; // precission\n    float gradX = scene( pos + vec3(eps, 0.0, 0.0) ).x - scene( pos - vec3(eps, 0.0, 0.0)).x;\n    float gradY = scene( pos + vec3(0.0, eps, 0.0) ).x - scene( pos - vec3(0.0, eps, 0.0)).x;\n    float gradZ = scene( pos + vec3(0.0, 0.0, eps) ).x - scene( pos - vec3(0.0, 0.0, eps)).x;\n    return normalize( vec3( gradX, gradY, gradZ ) );\n}\n\nvec3 calcBackground( vec2 p )\n{\n    return vec3( 1.0 ) * ( 1.0 - 0.13 * length( p - vec2( 0.0 ) ) );\n}\n\nvec2 intersect( vec3 ro, vec3 rd )\n{\n    float e = 0.001;\t// precission\n    float tmin = 0.0;\t// minimum distance\n    float tmax = 32.0;\t// maximum distance\n    float t = 0.0;\t\t// intersection distance\n    float m = -1.0;\t\t// material representation\n    \n    // raymarching loop\n    for( int i=0; i<100; i++ )\n    {\n        vec2 dm = scene( ro + t*rd );\n        t += dm.x;\n        m = dm.y;\n        if( dm.x < e || t > tmax ) break;\n    }\n    \n    if( t > tmax ) m = -1.0;\n    return vec2( t, m );\n}\n\n// function that computes a hard shadow based on the position and light direction\nfloat shadow( vec3 pos, vec3 l )\n{\n    float tmin = 0.2;\n    float tmax = 6.0;\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n        vec2 dm = scene( pos + t*l );\n        if( dm.x < 0.001 ) return 0.0;\n        t += dm.x;\n    }\n    \n    return 1.0;\n}\n\n// function that computes a soft shadow based on the position and light direction\nfloat softShadow( vec3 pos, vec3 l )\n{\n    float tmin = 0.2;\n    float tmax = 6.0;\n    float k = 8.0;\t\t// small value produces more penumbra\n    float sh = 1.0;\t\t// initially not shadow\n    \n    float t = tmin;\n    for( int i=0; i<64; i++ )\n    {\n        float d = max( scene( pos + t*l ).x, 0.0 );\n        sh = min( sh, k*d / t );\n        t += clamp( d, 0.02, 0.1 );\n        if( d < 0.001 ) break;\n    }\n    \n    return clamp( sh, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // the coordinate of the pixel between [-1, 1]\n\tvec2 p = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    \n    // The ray equation r = ro + t*rd\n    // TODO: compute a real camera with FOV\n    vec3 ro = vec3( 0.0, 2.5, 3.6 );\t\t\t\t\t\t\t// camera position\n    \n    vec3 ta = vec3( 0.0, 0.5, 0.0 ); \t\t\t\t\t\t\t// target position\n    vec3 ww = normalize( ta - ro );\t\t\t\t\t\t\t\t// forward vector\n    vec3 uu = normalize( cross( ww, vec3( 0.0, 1.0, 0.0 ) ) );\t// right vector\n    vec3 vv = normalize( cross( uu, ww ) );\t\t\t\t\t\t// up vector\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.5*ww );\n\n    \n    // intersection\n    vec2 t = intersect( ro, rd );\n\n    // background\n    vec3 col = calcBackground( p );\n    \n    // check the intersection in order to get the color of the pixel\n    if( t.y > -0.5 )\n    {\n        vec3 pos = ro + t.x*rd;\n        vec3 n = calcNormal( pos );\n        \n        vec3 l = normalize( vec3( 1.5*sin(iTime), 0.8, 1.6 +0.6*cos(iTime) ) );\n        vec3 ref = reflect( rd, n );\n        \n        \n        float sh = softShadow( pos + 0.001*n, l );\n        \n        float con = 1.0;\n        float amb = 0.5 + 0.5*n.y;\n        float dif = max( dot( n, l ), 0.0 ) * sh;\n        float spe = pow( clamp( dot( ref, l ), 0.0, 1.0 ), 16.0 );\n        \n        \n        col  = 0.10 * con * vec3(0.80,0.90,1.00);\n        col += 0.70 * dif * vec3(1.00,0.97,0.85);\n        col += 0.60 * spe * vec3(0.80,0.90,1.00) * dif;\n        col += 0.20 * amb * vec3( 0.5, 0.4, 0.4 );\n        \n        if ( t.y < 1.5 ) \t\tcol *= 1.8*vec3( 0.3, 0.35, 0.40 ); \n        else if( t.y < 2.5 )\tcol *= vec3( 1.5, 0.9, 1.0 );\n        else if( t.y < 3.5 )\tcol *= vec3( 1.5, 0.75, 1.0 );\n        else if( t.y < 4.5 )\tcol *= vec3( 1.5, 0.6, 1.0 );\n        \n        //col = n;\n    }\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mll3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 126, 149, 149, 281], [283, 283, 306, 306, 469], [471, 471, 508, 508, 619], [625, 625, 663, 690, 1940], [1943, 1979, 2004, 2004, 2022], [2024, 2061, 2096, 2096, 2124], [2126, 2169, 2232, 2232, 2713], [2715, 2743, 2789, 2789, 2833], [2835, 2942, 2966, 2966, 3738], [3740, 3788, 3817, 3817, 4190], [4192, 4192, 4223, 4223, 4294], [4296, 4296, 4332, 4332, 4795], [4797, 4879, 4913, 4913, 5143], [5145, 5227, 5265, 5265, 5672], [5674, 5674, 5731, 5787, 7561]], "test": "untested"}
{"id": "Mls3D2", "name": "PseudoArmillaryTest", "author": "RK", "description": "A simple test on the ray marching concepts.\nI am mainly using tools originally written by Inigo Quilez.\nEdits :\n- Radiometric correction (the usual cos(-rayDirection, surfaceNormal) was missing).", "tags": ["raymarching", "softshadows", "armillary"], "likes": 13, "viewed": 766, "published": "Public", "date": "1425435780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Simple Ray marcher over distance field. \n// To be improved on the BTEs and the approximations quality.\n// I am mainly using tools originally written by Inigo Quilez.\n// See his articles at : http://www.iquilezles.org/www/index.htm\n\n#define RM_USE_ABSORPTION\n#define RM_USE_SCATTERING\n\n// Will requires : \nvec2 sceneMap(vec3 p);\nvec4 renderMaterial(vec3 pos, vec3 dir, vec3 normal, float material, float d, float absorption, float scattering);\n\n// Can require : \n#ifdef RM_USE_ABSORPTION\nfloat absorption(vec3 p, vec3 dir, float d);\n#endif\n\n#ifdef RM_USE_SCATTERING\nfloat scattering(vec3 p, vec3 dir, float d);\n#endif\n\n// Primitives :\nfloat plane(vec3 p)\n{\n    return p.y;\n}\n\nfloat sphere(vec3 p, float radius)\n{\n    return length(p)-radius;\n}\n\nfloat torus(vec3 p, vec2 t)\n{\n    return max(length(vec2(length(p.xz)-t.x,p.y))-t.y, 0.0);\n}\n\nfloat length4(vec2 p)\n{\n    p = p*p; p = p*p;\n    return pow( p.x + p.y, 1.0/4.0 );\n}\n\nfloat torus42(vec3 p, vec2 t)\n{\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length4(q)-t.y;\n}\n\n// Operators :\nvec2 opUnion(vec2 d1, vec2 d2)\n{\n    return (d1.x<d2.x) ? d1 : d2;\n}\n\nfloat opSubstraction(float d1, float d2)\n{\n    return max(-d1,d2);\n}\n\nfloat opIntersection(float d1, float d2)\n{\n    return max(d1,d2);\n}\n\n// Core functions for the RayMarcher : \nfloat sceneMapSimple(vec3 p)\n{\n    vec2 tmp = sceneMap(p);\n    return tmp.x;\n}\n\nmat3 computeCameraMatrix(in vec3 p, in vec3 target, float roll)\n{\n    vec3 \tvForward = normalize(target-p),\n        \tvUpAlign = vec3(sin(roll), cos(roll), 0.0),\n        \tvLeftReal = normalize(cross(vForward, vUpAlign)),\n        \tvUpReal = normalize(cross(vLeftReal, vForward));\n    return mat3(vLeftReal, vUpReal, vForward);\n}\n\nvec4 castRay(in vec3 rayOrigin, in vec3 rayDirection, const float dMin, const float dNear, const float dMax)\n{\n    const int numSteps = 128;\n    float d = dMin;\n    float m = -1.0;\n    float a = 0.0, s = 0.0;\n    for(int i=0; i<numSteps; i++)\n    {\n        vec3 p = rayOrigin+rayDirection*d;\n        vec2 res = sceneMap(p);\n        if(res.x<dNear || d>dMax)\n            break;\n        d += res.x;\n        m = res.y;\n        #ifdef RM_USE_ABSORPTION\n        a += absorption(p, rayDirection, res.x);\n        #endif\n        #ifdef RM_USE_SCATTERING\n        s += scattering(p, rayDirection, res.x);\n        #endif\n    }\n    if(d>dMax)\n        m = -1.0;\n    return vec4(d, m, a, s);\n}\n\nvec3 calcNormal(in vec3 pos)\n{\n    const vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 n = vec3(\tsceneMap(pos+eps.xyy).x - sceneMap(pos-eps.xyy).x,\n                  \tsceneMap(pos+eps.yxy).x - sceneMap(pos-eps.yxy).x,\n                  \tsceneMap(pos+eps.yyx).x - sceneMap(pos-eps.yyx).x );\n    return normalize(n);\n}\n\nvec4 renderScene(const ivec2 formatSize, vec3 eyePos, vec3 eyeTarget, const float focalLength, const float dMin, const float dNear, const float dMax)\n{\n    mat3 camera = computeCameraMatrix(eyePos, eyeTarget, 0.0);\n    vec2 o = (gl_FragCoord.xy - vec2(formatSize)/2.0)/max(float(formatSize.x),float(formatSize.y));\n    vec3 rayOrigin = vec3(o, 0.0) + eyePos,\n        rayDirection = normalize(camera*vec3(o, focalLength));\n    vec4 res = castRay(rayOrigin, rayDirection, dMin, dNear, dMax);\n    vec3 p = rayOrigin + rayDirection * res.x;\n    vec3 n = calcNormal(p);\n    return renderMaterial(p, rayDirection, n, res.y, res.x, res.z, res.w);\n}\n\n// Other tools : \nfloat softShadow(vec3 rayOrigin, vec3 lightPos, float dNearLight, float kShadowSoftness)\n{\n    const int maxStep = 128;\n    const float dNearIntersect = 0.0000001;\n    vec3 rayDirection = lightPos - rayOrigin;\n    float dMax = length(rayDirection) - dNearLight;\n    rayDirection = normalize(rayDirection);\n    float res = 1.0;\n    float d=0.0;\n    for(int k=0; k<maxStep; k++)\n    {\n        float closest = sceneMapSimple(rayOrigin + rayDirection*d);\n        if(closest<dNearIntersect)\n            return 0.0;\n        res = min(res, kShadowSoftness*closest/d);\n        d += closest;\n        if(d>=dMax)\n            break;\n    }\n    return res;\n}\n\n// Scene settings :\nconst vec3 \teyeTarget = vec3(0, 1.4, 5),\n    \t\tobjectCenter = vec3(0,1.8,5.0);\nconst float focalLength = 0.5;\nconst vec3 \tlightPos = vec3(2.8, 3, 4.3),\n            lightDir = vec3(-2.0, -0.5, 0.7),\n        \tlightCol = vec3(1, 1, 1.5);\nconst float lightSpan = 0.7, // cosine\n    \t\tlightRadiance = 15.0,\n    \t\tthetaRing2 = 0.2,\n    \t\tthetaRing3 = 0.4;\nmat3 rotMat2, rotMat3;\n\nfloat test(vec3 p)\n{\n    return length(max(abs(p-vec3(0,0,5))-0.5,0.0));\n}\n\nvec2 sceneMap(in vec3 p)\n{\n    return\topUnion( vec2(plane(p), 1), \n            opUnion( vec2(sphere(p-lightPos, 0.01), 1024),\n            opUnion( vec2(sphere(p-objectCenter, 0.5), 2),\n            opUnion( vec2(torus42(p-objectCenter, vec2(1.0, 0.1)), 3),\n            opUnion( vec2(torus42(rotMat2*(p-objectCenter), vec2(1.3, 0.1)), 4),\n                     vec2(torus42(rotMat3*(p-objectCenter), vec2(1.6, 0.1)), 5)\n                     )))));\n}\n\n\nfloat absorption(vec3 p, vec3 dir, float d)\n{\n    return d*exp(-p.y*5.0)/2.0;\n}\n\nfloat scattering(vec3 p, vec3 dir, float d)\n{\n    vec3 u = normalize(p - lightPos);\n    float dLight = distance(p, lightPos);\n    return  d*0.2*exp(-p.y*0.1)/(dLight*dLight) * (max(dot(u, normalize(lightDir)), lightSpan)-lightSpan)/(1.0-lightSpan);\n}\n\nvec4 renderMaterial(vec3 p, vec3 dir, vec3 normal, float material, float dist, float absorption, float scattering)\n{\n    vec4 col = vec4(0, 0, 0, 1);\n\n    if(material>0.0) // Valid object intersection\n    {\n        if(material<=1.0) //floor\n            col = mod(floor(5.0*p.z) + floor(5.0*p.x), 2.0)*vec4(0.3,0.3,0.3,0)+vec4(0.3,0.3,0.3,1);\n        else // other\n            col = vec4(material/5.0,1.0-material/5.0, material*material/25.0-p.y/3.0, 1.0);\n\n        // Simple shading :\n        vec3 u = p - lightPos;\n        float l = length(u);\n        u = u/l;\n        float s = max(dot(-dir, normal), 0.0) * max(dot(-u, normal),0.0) * max((max(dot(u, normalize(lightDir)), lightSpan)-lightSpan)/(1.0-lightSpan), 0.0) / max(l*l, 1.0) * lightRadiance;\n        col = col * max(s,0.0001) * vec4(lightCol,1);\n\n        // Light source : \n        col = (material>=1024.0) ? vec4(1,1,1,1) : col;\n    }\n\n    col.rgb = col.rgb * softShadow(p, lightPos, 1.0, 32.0) * max(1.0 - absorption,0.0) + scattering * lightRadiance * lightCol/max(1.0,dist*dist);\n\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // Setup the animation of the scene :\n\trotMat2 = mat3( 1, 0, 0,\n                    0, cos(thetaRing2*iTime), sin(thetaRing2*iTime),\n                    0, -sin(thetaRing2*iTime), cos(thetaRing2*iTime));\n\n\trotMat3 = mat3(\tcos(thetaRing3*iTime), sin(thetaRing3*iTime), 0,\n                    -sin(thetaRing3*iTime), cos(thetaRing3*iTime), 0,\n                     0, 0, 1);\n    vec3 eyePos = eyeTarget + vec3(4.0*cos(0.1*iTime), 1.5, 4.0*sin(0.1*iTime));\n    \n    // Render :\n    vec4 c = renderScene(ivec2(iResolution.xy), eyePos, eyeTarget, focalLength, 0.5, 0.001, 100.0);\n    fragColor = vec4(pow(c.rgb, vec3(1, 1, 1)/2.2), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mls3D2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[621, 637, 658, 658, 676], [678, 678, 714, 714, 745], [747, 747, 776, 776, 839], [841, 841, 864, 864, 926], [928, 928, 959, 959, 1029], [1031, 1046, 1078, 1078, 1114], [1116, 1116, 1158, 1158, 1184], [1186, 1186, 1228, 1228, 1253], [1255, 1295, 1325, 1325, 1373], [1375, 1375, 1440, 1440, 1701], [1703, 1703, 1813, 1813, 2382], [2384, 2384, 2414, 2414, 2699], [2701, 2701, 2852, 2852, 3342], [3344, 3362, 3452, 3452, 4007], [4009, 4403, 4423, 4423, 4477], [4479, 4479, 4505, 4505, 4925], [4928, 4928, 4973, 4973, 5007], [5009, 5009, 5054, 5054, 5259], [5261, 5261, 5377, 5377, 6323], [6325, 6325, 6381, 6423, 7019]], "test": "untested"}
{"id": "Mls3Df", "name": "Fiery Feigenbaum", "author": "jcreed", "description": "First 50 iterations of logistic map.", "tags": ["fractal"], "likes": 7, "viewed": 259, "published": "Public", "date": "1425935233", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 50\n#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = vec2(fragCoord.x / iResolution.x,\n                fragCoord.y / iResolution.y);\n  float z = fract(0.02 * iTime);\n  int acc = 0;\n  float trig = (cos(2. * M_PI * z) + 1.) / 2.;\n  float a = mix(1., 3.75, trig) + p.x * mix(3., 0.25, trig);\n  \n  for (int i = 0; i < ITERS; i++) {\n    acc += (z > p.y && z <= p.y + 1. / iResolution.y) ? 1 : 0;\n    z = a * z * (1.-z);\n  }\n  float iters = float(ITERS);\n  float g = 25. * float(acc) / iters;\n\n  fragColor = vec4(g, g /3., g / 8.,1.);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mls3Df.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 122, 122, 612]], "test": "untested"}
{"id": "Mls3WH", "name": "Rotating stars", "author": "bobmachiel", "description": "more practice, improved it with 1.0 - f and glow", "tags": ["stars", "rotation"], "likes": 4, "viewed": 219, "published": "Public", "date": "1427465008", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat x = fragCoord.x;\n    vec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 c = p - vec2(0.25, 0.5);\n    \n    \n    vec3 col = vec3 (0.0, 0.3, 0.5);\n    vec3 starcol = vec3 (1.0, 1.0, 0.0);\n   \n    float rot = iTime * 1.2;\n        \n    //stars\n    for (int i = 0 ; i < 8 ; i++) {\n         \n    c = p - vec2 (0.5 + 0.25 * sin ( - rot - float(i) * 0.78 ), 0.5 + 0.25 * cos ( - rot - float(i) * 0.78 ));\n    float r = 0.05 + 0.009 * cos  ( atan (c.y, c.x) * 5.0 + rot );\n  \tfloat f = smoothstep(r, r + 0.01, length(c)); \n    float bg = smoothstep(r, r + 0.01, length(c));\n\t\n    col *= f; //leave void for each star   \n    col += starcol * (1.0 - f ); //fill stars with color \n    \n    f = smoothstep(r+.01, r+ 0.04, length(c));\n    col += vec3 (0.8, 0.3, 0.0) * (1.0 - f); //add orange glow\n\n    }\n    \n    fragColor = vec4 (col, 1.0);\n    //bars\n    \t\n    float pat = iTime*5.0;\n    float rep = 120.0;\n    vec3 col2 = vec3(0.5 + 0.5 * sin(x/rep + 3.14 + pat), 0.5 + 0.5 * cos (x/rep + pat), 0.5 + 0.5 * sin (x/rep + pat));\n    if ( p.y > 0.1 && p.y < 0.106 || p.y > 0.9 && p.y < 0.906 ) {\n    fragColor = vec4 ( col2, 1.0 );\n   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mls3WH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1189]], "test": "untested"}
{"id": "Mls3Wl", "name": "Fire and Ice", "author": "alma", "description": "Valentine's Day Shader made by Jessi and me as a class assignment.\n\nYou can click and move the mouse around the screen to modify the colour beyond ice and fire.\n\nhttps://www.youtube.com/watch?v=Wo3_Pw0B134", "tags": ["heart", "love"], "likes": 1, "viewed": 1870, "published": "Public API", "date": "1426268708", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 paintHeart(vec3 col, vec3 col1, float x, float y)\n{\n\tfloat r = x*x + pow((y - pow(x*x, 1.0/3.0)), 2.0);\n\tr -= pow(sin(iTime), 10.0);\n\t\n\tif (r < 1.5) {\n\t\tcol = col1 * r;\n\t}\n\treturn col;\n}\n\nvec3 paintSpecialHeart(vec3 col, vec3 col1, float x, float y)\n{\n\tfloat r = x*x + pow((y - pow(x*x, 1.0/3.0)), 2.0);\n    r -= sin(iTime) - 0.6;\n    if ((r < 2.0 && r > 1.5) || (r < 1.0 && r > 0.6) || (r < 0.3 && r > 0.0)) {\n\t\tcol = col1 * r * 1.5*(sin(iTime)+1.0);\n\t\t//col = col1 * r * 3.0;\n    }\n\treturn col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 p = 4.0 * (fragCoord.xy / iResolution.xy);\n\tvec2 p2 = 45.0 * (fragCoord.xy / iResolution.xy);\n\t\n    vec3 col = vec3(0.0, 0.0, 0.0);\n\tvec3 col1 = mix(vec3(1.0,0.0,0.6), vec3(1.0,0.0,0.4), sqrt(p.y));\n\tvec3 col2 = mix(vec3(1.0,0.0,0.1), vec3(1.0,0.1,0.0), pow(p.y, 1.3));\n\n\tfloat x = p.x - 2.0;\n    float y = p.y - 1.65;\n\t\n\tif (length(iMouse.x) > p.x*200.0) {\n\t\tcol1 = vec3(0.1,0.1,0.5);\n\t\tcol2 = vec3(0.1,0.9,0.3);\n\t}\n\t\n\tcol = paintSpecialHeart(col, col1, x, y);\n\t\n\tfor (float i = 0.0; i < 5.0; i++) {\n\t\tx = p2.x - 7.5 * (i+1.0);\n\t\tif (i == 2.0) {\n\t\t\ty = p2.y - 22.0 - sin(iTime) * 12.0;\n\t\t} else if (i == 0.0 || i == 4.0) {\n\t\t\ty = p2.y - 22.0 - sin(iTime) * 3.0;\n\t\t} else {\n\t\t\ty = p2.y - 22.0 - sin(iTime) * (-9.0);\n\t\t}\n\t\n\t\tcol = paintHeart(col, col2, x, y);\n\t}\n    \n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mls3Wl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 191], [193, 193, 256, 256, 503], [505, 505, 560, 560, 1363]], "test": "untested"}
{"id": "Mls3WX", "name": "OcuLimbo", "author": "daeken", "description": "Testing oculus rift support in raymarching.  Credit goes to Sergio Gonzalez (Acid-RT developer) for the Catmull-Rom code for distorting the rays, as this is more-or-less a straight port of that code.", "tags": ["test", "oculusrift", "shaderforth"], "likes": 6, "viewed": 1129, "published": "Public", "date": "1425847182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Compiled with Shaderforth: https://github.com/daeken/Shaderforth\nimport[ noise ]\n\n:globals\n\ttrue =>shadertoy\n\t\t{\n\t\t\t@vec3 uniform =iResolution @float uniform =iTime\n\t\t\tiResolution .xy =>resolution\n\t\t\tiTime 30 mod =>time\n\t\t}\n\t\t{ @vec2 uniform =resolution @float uniform =time }\n\tshadertoy cif\n\t@float =scene-noise\n;\n\n:m noise-2d pnoise-2d ;\n:m terrain ( p )\n\t20 2 p .x 6 / abs 0 1 clamp mix =>factor\n\t\tp .xz 2 / noise-2d factor /\n\t\tp .y neg\n\t-\n;\n\n:m ring-terrain ( p )\n\t[\n\t\t[\n\t\t\tp [ 0 .6 0 ] - [ 1 p .y - .05 * 1 - 2.5 2 ] / [ 1 .1 ] torus\n\t\t\tp [ 0 4.8 0 ] + 5 sphere\n\t\t] 1.25 unionsmooth\n\t\tp terrain\n\t] .2 unionsmooth\n;\n\n:m walkway ( p )\n\t{ ( $rp )\n\t\t[ rp .xz p rp - .x.z + 13.7 * sin .5 * rotate-2d rp .y ] .xzy [ .4 .1 .4 ] box\n\t} p [ 0 1 0 ] + [ 0 0 1 ] repeat\n;\n\n:m portal ( p )\n\t[\n\t\tp [ 0 .3 0 ] + [ 1 2.5 1 ] / 1 sphere\n\t\tp [ 1 3 .04 ] box\n\t] intersect\n;\n\n:m columns ( p )\n\tp .x sign neg =>flip\n\t{ ( $rp )\n\t\t[\n\t\t\t[ rp .xz rp .y flip * pi 2 / * pi 8 / + rotate-2d rp .y ] .xzy [ 0 1 0 ] + [ .2 1.5 .2 ] box\n\t\t\trp [ 0 1.25 0 ] - .4 sphere\n\t\t] .75 unionsmooth\n\t} p [ 2.25 0 2.5 ] repeat\n;\n\n:m hell-terrain ( p )\n\tp [ 0 p .z 4 / 0 ] + [ 0 1 0 1 ] plane scene-noise p .x time 1 + 2 * + sin .1 * + -.3 .6 clamp .4 * +\n;\n\n: scene ( p:vec3 -> vec2 )\n\tp .x 100 / round =room\n\tp [ room 100 * 0 0 ] - =p\n\troom 1 eq =heaven\n\troom 2 eq =>hell\n\t\tp .xz [ 1.5 1 ] *\n\t\t[ 0 time neg 1.5 / heaven mix 0 time heaven hell + mix 1 .3 heaven mix * ] - \n\t\tp .y +\n\t\t\t.75\n\t\t\t3 room -\n\t\troom 1 - sign abs mix\n\t* noise-2d =scene-noise\n\t[\n\t\troom 0 == {\n\t\t\t[\n\t\t\t\t[ p [ 0 1 0 ] + ring-terrain 1 ]\n\t\t\t\t[ p walkway 2 ]\n\t\t\t\t[ p portal 3 ]\n\t\t\t] hitunion\n\t\t}\n\t\troom 1 == {\n\t\t\tp [ 1 p .z -.04 * + 1 1 ] * [ 0 p .z .05 * 0 ] + =p\n\t\t\t[\n\t\t\t\t[\n\t\t\t\t\t[\n\t\t\t\t\t\tp [ 0 1 0 ] + [ 0 1 0 0 ] plane\n\t\t\t\t\t\tp columns\n\t\t\t\t\t] .75 unionsmooth\n\t\t\t\t\tp [ 0 0 far .2 + ] - [ 1.5 far far ] box\n\t\t\t\t] intersect\n\t\t\t\t4\n\t\t\t]\n\t\t}\n\t\t{\n\t\t\t[ p hell-terrain 5 ]\n\t\t}\n\t] cond =>temp\n\troom 1 - sign abs temp .y 3 - sign abs * =>is-portal\n\ttemp [ scene-noise .03 * is-portal * 0 ] +\n;\n\n:m portal-texture ( p )\n\t\t[\n\t\t\t##000\n\t\t\t.5 .5 0\n\t\t\tp .z sign 1 + 2 / 1 +\n\t\t\t0\n\t\t] material\n;\n\n:m marble-texture ( p )\n\tscene-noise abs =>noise\n\t##DBDBDB ##4F5052 noise mix =>color\n\t[ p .y .2 - 0 1 clamp 2 ** color - abs .3 .7 noise 100 * eps + 0 0 ] material\n;\n\n:m hell-texture ( p )\n\t[ ##525252 .05 .5 10 0 0 ] material\n;\n\n: get-material ( pos:vec3 dist:float id:float -> material )\n\t[\n\t\tid 1 == {\n\t\t\tpos .y .6 + 0 1 clamp =fade\n\t\t\t[ ##7A3B14 ##878787 fade mix .4 .7 1000 10 fade mix 0 -.3 ] material\n\t\t}\n\t\tid 2 == { [ ##DBDBDB ##525252 pos .z sign 0 1 clamp mix .3 .7 1000 0 0 ] material }\n\t\tid 3 == { pos portal-texture }\n\t\tid 4 == { pos marble-texture }\n\t\t{ pos hell-texture }\n\t] cond\n;\n\n:m union \\min ;\n:m unionsmooth ( list k ) list \\{ ( a b ) a b k smin-poly } ;\n:m hitunion \\{ ( $a $b ) a b a .x b .x < select } ;\n:m hitunionsmooth ( list k )\n\tlist \\{ ( $a $b )\n\t\ta .x b .x k smin-poly =smin\n\t\t[\n\t\t\tsmin\n\t\t\ta .y b .y a .x smin - abs b .x smin - abs < select\n\t\t]\n\t}\n;\n:m subtract \\{ ( d1 d2 ) d1 neg d2 max } ;\n:m intersect \\max ;\n:m hitintersect \\{ ( $a $b ) a b a .x b .x > select } ;\n:m repeat ( block p c ) p p c mod c 1000 * 0 1 clamp mix 0.5 c * - *block ;\n\n:m sphere ( p s ) p length s - ;\n:m torus ( $p t ) [ p .xy length t .x - p .z ] length t .y - ;\n: box ( p:vec3 b:vec3 -> float )\n\tp abs b - =d\n\td \\max 0 min\n\td 0 max length +\n;\n:m plane ( p n )\n\tp n .xyz dot n .w +\n;\n\n:struct material\n\t@vec3 =color\n\t@float =ambient\n\t@float =diffuse\n\t@float =specular\n\t@float =room\n\t@float =normal-mod\n;\n\n:struct hit\n\t@vec3 =pos\n\t@vec3 =origin\n\t@vec3 =dir\n\t@float =dist\n\t@float =total-dist\n\t@material =mat\n;\n\n:m tx [ _ 0 0 ] + ;\n:m ty [ 0 _ 0 ] + ;\n:m tz [ 0 0 _ ] + ;\n:m get-normal ( p )\n\t[\n\t\tp eps     tx scene .x\n\t\tp eps neg tx scene .x -\n\t\tp eps     ty scene .x\n\t\tp eps neg ty scene .x -\n\t\tp eps     tz scene .x\n\t\tp eps neg tz scene .x -\n\t] normalize\n;\n\n:m lightpos [ 0 room 100 * + 5 5 -1 room 1 - abs mix ] ;\n\n:m shadow-dist 0.1 ;\n\n: get-shadow ( ray:vec3 lpos:vec3 -> float )\n\tlpos ray - normalize =dir\n\tshadow-dist 10 * =dist\n\tlpos ray - length =mdist\n\tfar =lowest\n\t{\n\t\tray dir 2 * dist * + scene =cur\n\t\tlowest cur .x min =lowest\n\t\tdist cur .x abs shadow-dist max + =dist\n\t\t&break cur .x abs shadow-dist < dist mdist >= or when\n\t} 3 times\n\tlowest 0 max 0 shadow-dist .8 ** smoothstep\n;\n\n: ambient-occlusion ( pos:vec3 dir:vec3 cdist:float -> float )\n\tpos dir cdist * + =>npos\n\tnpos scene .x far min =>lowest\n\t0 lowest cdist 1.75 / smoothstep\n;\n\n: apply-fog ( color:vec3 cur:hit dist:float miss:float -> vec3 )\n\t\tcolor\n\t\tcur .origin 1 miss - * cur .dir sky\n\t\tdist cur .total-dist miss mix far fog - - fog / fog-factor * 0 1 clamp\n\tmix\n;\n\n: shade ( cur:hit -> vec3 )\n\tcur .pos =>pos\n\tpos .x 100 / round =room\n\tpos get-normal =normal\n\n\tlightpos =lpos\n\tlpos pos - normalize =ivec\n\tivec normal dot 0 max =incidence\n\tincidence =>diffuse\n\tpos normal cur .dist ambient-occlusion =>ambient\n\n\tcur .mat =>mat\n\n\t0 =specular\n\t{\n\t\t\tivec cur .origin + normalize normal dot\n\t\t\t0\n\t\tmax mat .specular pow\n\t\tlpos pos - length / =specular\n\t} mat .specular 0 != incidence 0 > and when\n\n\tcur .pos lpos get-shadow =shadow\n\n\t\t\tmat .color rgb->hsv1\n\t\t\t\t[ 1 1\n\t\t\t\t\tdiffuse mat .diffuse * shadow *\n\t\t\t\t\tambient mat .ambient * +\n\t\t\t\t\tspecular shadow * +\n\t\t\t\t\tnormal .x abs mat .normal-mod * +\n\t\t\t\t]\n\t\t* hsv1->rgb\n\tcur cur .origin.pos - length 0 apply-fog\n;\n\n:m nullhit\n\t[ ray ray dir far tdist [ 0 vec3 0 0 0 0 0 ] material ] hit\n;\n\n: march ( ray:vec3 dir:vec3 -> hit )\n\tclose =t\n\t0 =tdist\n\t2 =>magic-factor\n\tclose magic-factor * =minstep\n\tfar =last\n\t0 =room\n\t{\n\t\tray dir t * + scene =cur\n\t\t{ nullhit return } cur .x far > when\n\t\t{\n\t\t\t\t{\n\t\t\t\t\tt tdist + =tdist\n\t\t\t\t\t0 =t\n\t\t\t\t\tray 0 3 get-material =mat\n\t\t\t\t\tmat .room =room\n\t\t\t\t\tray [ room 100 * 0 0 ] + =ray\n\t\t\t\t}\n\t\t\t\t&break\n\t\t\tcur .y 3 == if\n\t\t}\n\t\t{\n\t\t\tt cur .x abs minstep + + =t\n\t\t\t{ nullhit return } t far > when\n\t\t\t{\n\t\t\t\tminstep close magic-factor / 3 * + =minstep\n\t\t\t} cur .x last >= room 0 == and when\n\t\t\tcur .x =last\n\t\t} cur .x close close magic-factor / t * + <= if\n\t} 40 times\n\n\tray dir t cur .x + * + =fray\n\n\t[\n\t\tfray\n\t\tray\n\t\tdir\n\t\tcur .x\n\t\ttdist\n\t\tfray cur .x.y get-material\n\t] hit\n;\n\n:m cut-horizon\n\t##000 1 dir .y - 0 1 clamp 2 ** mix\n;\n\n:m clouds ( dir )\n\tdir .xy cart->polar [ 3 7 ] * [ 0 time ] + noise-2d .2 .8 clamp .2 - vec3 cut-horizon\n;\n\n: sky ( origin:vec3 dir:vec3 -> vec3 )\n\torigin .x 100 / round =>room\n\t[\n\t\t0\t##6010C9 ##111438 dir .y 2.5 * mix\n\t\t1\t##FCFFD9 ##9CC5FF dir .y 6 * mix\n\t\t\t##AB1529 ##360B11 dir .y 5 * mix\n\t] room choose\n;\n\n2 =>focus\n:m far 20 ;\n:m fog 14 ;\n:m fog-factor 1.5 ;\n:m close 0.005 ;\n\n: camera-turn ( p:vec3 -> vec3 )\n\ttime 8 - 0 max 3.5 / =v\n\t[ p .xz v 0 1 clamp 1.2 ** v 1 - 0 max + neg rotate-2d p .y ] .xzy\n;\n\n: K[] ( i:float -> float )\n\t[\n\t\t\t[ 1.003000 1.020000 1.042000 1.066000 1.094000\n\t\t\t  1.126000 1.162000 1.203000 1.250000 1.310000 ]\n\t\tenumerate /{ =>[ k v ] i k == { v return } } flatten\n\t\t{ 1.380000 return }\n\t] cond\n;\n\n: catmull-rom ( r:float -> float )\n\t11 =>num_segments\n\t[ 10 r 3.6 ] \\* =scaled_val\n\t0 10 scaled_val floor min max =scaled_val_floor\n\tscaled_val_floor =k\n    1 =k0p0\n    1 K[] 0 K[] - =k0m0\n    1 K[] =k0p1\n    2 K[] 0 K[] - .5 * =k0m1\n\n    k K[] =p0\n    k 1 + K[] k 1 - K[] - .5 * =m0\n    k 1 + K[] =p1\n    k 2 + K[] k K[] - .5 * =m1\n\n    k 0 == float =k0\n\n    k0 k0p0 * 1 k0 - p0 * + =p0\n    k0 k0p1 * 1 k0 - p1 * + =p1\n    k0 k0m0 * 1 k0 - m0 * + =m0\n    k0 k0m1 * 1 k0 - m1 * + =m1\n\n    scaled_val scaled_val_floor - =t\n    1 t - =omt\n\t    p0 1 2 t * + * m0 t * + omt !* *\n\t    p1 1 2 omt * + * m1 omt * - t !* *\n    +\n;\n\nresolution frag->position =pos\npos .x sign neg .15 * =eyeoff\nresolution .x.y / =rs\n[ pos .x rs + rs mod rs 2 / - pos .y ] =eyepos\neyepos [ 1 resolution .y.x 2 / / ] / 2 / =eyepos\neyepos !dot =radsq\neyepos radsq 1.65 * catmull-rom * =eyepos\neyepos 2 * [ 1 resolution .y.x 2 / / ] * =eyepos\n\n1 time 10 / - 0 1 clamp 3 ** 100 * =>running\n[ 0 .5 -4 running - time 10 - 0 max 4 / sin .1 * + ] [ eyeoff 0 0 ] + camera-turn =origin\n[ 0 .5 -1 ] camera-turn =>ct\n\nct origin - normalize =cd\n[ 0 1 0 ] =>cu\ncd cu cross =>cs\ncs eyepos .x * cu eyepos .y * + cd focus * + normalize =>dir\n\n:m fade-in ( color )\n\t##fff color time .5 - 2 / 0 1 clamp mix\n;\n\n:m vignette\n\t0 vec3 0 1 radsq .1 - 5 * smoothstep mix\n;\n\norigin dir march =cur\n\t{ cur shade fade-in vignette ->fragcolor }\n\t{\n\t\t\tcur .origin.dir sky =cursky\n\t\t\t\tcursky\n\t\t\t\tcursky cur far 1 apply-fog\n\t\t\tcur .total-dist far * 1 min mix\n\t\tfade-in vignette ->fragcolor\n\t}\ncur .dist close 10 * < if\n*/\n\nstruct material {\n\tvec3 color;\n\tfloat ambient;\n\tfloat diffuse;\n\tfloat specular;\n\tfloat room;\n\tfloat normal_mod;\n};\nstruct hit {\n\tvec3 pos;\n\tvec3 origin;\n\tvec3 dir;\n\tfloat dist;\n\tfloat total_dist;\n\tmaterial mat;\n};\nfloat scene_noise;\nmaterial get_material(vec3 pos, float dist, float id) {\n\tmaterial temp_1;\n\tif(id == 1.) {\n\t\tfloat fade = clamp(pos.y + .6, 0., 1.);\n\t\ttemp_1 = material(mix(vec3(.47843, .23137, .078431), vec3(.52941, .52941, .52941), fade), .4, .7, mix(1000., 10., fade), 0., -.3);\n\t} else if(id == 2.) {\n\t\ttemp_1 = material(mix(vec3(.85882, .85882, .85882), vec3(.32157, .32157, .32157), clamp(sign(pos.z), 0., 1.)), .3, .7, 1000., 0., 0.);\n\t} else if(id == 3.) {\n\t\ttemp_1 = material(vec3(0., 0., 0.), .5, .5, 0., (sign(pos.z) + 1.) / 2. + 1., 0.);\n\t} else if(id == 4.) {\n\t\ttemp_1 = material(abs(pow(clamp(pos.y - .2, 0., 1.), 2.) - mix(vec3(.85882, .85882, .85882), vec3(.30980, .31373, .32157), abs(scene_noise))), .3, .7, abs(scene_noise) * 100. + .00001, 0., 0.);\n\t} else {\n\t\ttemp_1 = material(vec3(.32157, .32157, .32157), .05, .5, 10., 0., 0.);\n\t}\n\treturn temp_1;\n}\nvec3 sky(vec3 origin, vec3 dir) {\n\treturn (floor(origin.x / 100. + .5) == 0. ? mix(vec3(.37647, .062745, .78824), vec3(.066667, .078431, .21961), dir.y * 2.5) : (floor(origin.x / 100. + .5) == 1. ? mix(vec3(.98824, 1., .85098), vec3(.61176, .77255, 1.), dir.y * 6.) : mix(vec3(.67059, .082353, .16078), vec3(.21176, .043137, .066667), dir.y * 5.)));\n}\nvec3 apply_fog(vec3 color, hit cur, float dist, float miss) {\n\treturn mix(color, sky(cur.origin * (1. - miss), cur.dir), clamp((mix(dist, cur.total_dist, miss) - 6.) / 14. * 1.5, 0., 1.));\n}\nfloat pnoise_2d(vec2 v) {\n\tvec4 Pi = mod(floor(v.xyxy) + vec4(0., 0., 1., 1.), 289.);\n\tvec4 Pf = fract(v.xyxy) - vec4(0., 0., 1., 1.);\n\tvec4 gx = fract(mod(((mod((Pi.xzxz * 34. + 1.) * Pi.xzxz, 289.) + Pi.yyww) * 34. + 1.) * (mod((Pi.xzxz * 34. + 1.) * Pi.xzxz, 289.) + Pi.yyww), 289.) / 41.) * 2. - 1.;\n\tvec4 gy = abs(gx) - .5;\n\tgx -= floor(gx + .5);\n\tvec4 norm = inversesqrt(sqrt(gx * gx + gy * gy));\n\tvec2 fade_xy = ((Pf.xy * 6. - 15.) * Pf.xy + 10.) * pow(Pf.xy, vec2(2.));\n\tvec2 n_x = mix(vec2(dot(vec2(gx.x, gy.x) * norm.x, Pf.xy), dot(vec2(gx.z, gy.z) * norm.y, Pf.xw)), vec2(dot(vec2(gx.y, gy.y) * norm.z, Pf.zy), dot(vec2(gx.w, gy.w) * norm.w, Pf.zw)), fade_xy.x);\n\treturn mix(n_x.x, n_x.y, fade_xy.y) * 2.3;\n}\nfloat K_(float i) {\n\tif(i == 0.) {\n\t\treturn 1.003000;\n\t} else if(i == 1.) {\n\t\treturn 1.020000;\n\t} else if(i == 2.) {\n\t\treturn 1.042000;\n\t} else if(i == 3.) {\n\t\treturn 1.066000;\n\t} else if(i == 4.) {\n\t\treturn 1.094000;\n\t} else if(i == 5.) {\n\t\treturn 1.126000;\n\t} else if(i == 6.) {\n\t\treturn 1.162000;\n\t} else if(i == 7.) {\n\t\treturn 1.203000;\n\t} else if(i == 8.) {\n\t\treturn 1.250000;\n\t} else if(i == 9.) {\n\t\treturn 1.310000;\n\t} else {\n\t\treturn 1.380000;\n\t}\n}\nfloat box(vec3 p, vec3 b) {\n\tvec3 d = abs(p) - b;\n\treturn min(max(max(d.x, d.y), d.z), 0.) + length(max(d, 0.));\n}\nvec2 rotate_2d(vec2 c, float a) {\n\tfloat ca = cos(a);\n\tfloat sa = sin(a);\n\treturn vec2(c.x * ca - c.y * sa, c.y * ca + c.x * sa);\n}\nvec3 hsv1_rgb(vec3 hsv) {\n\treturn mix(vec3(1., 1., 1.), clamp(abs(mod(hsv.x * 6. + vec3(0., 4., 2.), 6.) - 3.) - 1., 0., 1.), hsv.y) * hsv.z;\n}\nfloat smin_poly(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\nvec2 scene(vec3 p) {\n\tvec2 temp_17;\n\tfloat room = floor(p.x / 100. + .5);\n\tp -= vec3(room * 100., 0., 0.);\n\tfloat heaven = 1. - abs(sign(room - 1.));\n\tscene_noise = pnoise_2d((p.xz * vec2(1.5, 1.) - vec2(mix(0., -mod(iTime, 30.) / 1.5, heaven), mix(0., mod(iTime, 30.), heaven + 1. - abs(sign(room - 2.))) * mix(1., .3, heaven)) + p.y) * mix(.75, 3. - room, abs(sign(room - 1.))));\n\tif(room == 0.) {\n\t\tvec3 macro_torus_p = (p + vec3(0., 1., 0.) - vec3(0., .6, 0.)) / vec3((1. - (p + vec3(0., 1., 0.)).y) * .05 - 1., 2.5, 2.);\n\t\tvec3 macro_temp_10_rp = mix(p + vec3(0., 1., 0.), mod(p + vec3(0., 1., 0.), vec3(0., 0., 1.)), vec3(0., 0., 1.)) - vec3(0., 0., .5);\n\t\tvec2 macro_temp_13_a = vec2(smin_poly(smin_poly(length(vec2(length(macro_torus_p.xy) - 1., macro_torus_p.z)) - .1, length(p + vec3(0., 1., 0.) + vec3(0., 4.8, 0.)) - 5., 1.25), pnoise_2d((p + vec3(0., 1., 0.)).xz / 2.) / mix(20., 2., clamp(abs((p + vec3(0., 1., 0.)).x / 6.), 0., 1.)) - -(p + vec3(0., 1., 0.)).y, .2), 1.);\n\t\tvec2 macro_temp_13_b = vec2(box(vec3(rotate_2d(macro_temp_10_rp.xz, sin(((p - macro_temp_10_rp).x + (p - macro_temp_10_rp).z) * 13.7) * .5), macro_temp_10_rp.y).xzy, vec3(.4, .1, .4)), 2.);\n\t\tmacro_temp_13_a = (macro_temp_13_a.x < macro_temp_13_b.x ? macro_temp_13_a : macro_temp_13_b);\n\t\tmacro_temp_13_b = vec2(max(length((p + vec3(0., .3, 0.)) / vec3(1., 2.5, 1.)) - 1., box(p, vec3(1., 3., .04))), 3.);\n\t\ttemp_17 = (macro_temp_13_a.x < macro_temp_13_b.x ? macro_temp_13_a : macro_temp_13_b);\n\t} else if(room == 1.) {\n\t\tp = p * vec3(1. + p.z * -.04, 1., 1.) + vec3(0., p.z * .05, 0.);\n\t\tvec3 macro_temp_18_rp = mix(p, mod(p, vec3(2.25, 0., 2.5)), vec3(1., 0., 1.)) - vec3(1.125, 0., 1.25);\n\t\ttemp_17 = vec2(max(smin_poly(dot(p + vec3(0., 1., 0.), vec3(0., 1., 0.)), smin_poly(box(vec3(rotate_2d(macro_temp_18_rp.xz, macro_temp_18_rp.y * -sign(p.x) * 1.5708 + .39270), macro_temp_18_rp.y).xzy + vec3(0., 1., 0.), vec3(.2, 1.5, .2)), length(macro_temp_18_rp - vec3(0., 1.25, 0.)) - .4, .75), .75), box(p - vec3(0., 0., 20.2), vec3(1.5, 20., 20.))), 4.);\n\t} else {\n\t\ttemp_17 = vec2(dot(p + vec3(0., p.z / 4., 0.), vec3(0., 1., 0.)) + 1. + clamp(scene_noise + sin(p.x + (mod(iTime, 30.) + 1.) * 2.) * .1, -.3, .6) * .4, 5.);\n\t}\n\treturn temp_17 + vec2(scene_noise * .03 * abs(sign(room - 1.)) * abs(sign(temp_17.y - 3.)), 0.);\n}\nfloat get_shadow(vec3 ray, vec3 lpos) {\n\tvec3 dir = normalize(lpos - ray);\n\tfloat dist = 1.0;\n\tfloat mdist = length(lpos - ray);\n\tfloat lowest = 20.;\n\tfor(int temp_27 = 0; temp_27 < 3; ++temp_27) {\n\t\tvec2 cur = scene(ray + dir * 2. * dist);\n\t\tlowest = min(lowest, cur.x);\n\t\tdist += max(abs(cur.x), .1);\n\t\tif(abs(cur.x) < .1 || dist >= mdist) {\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn smoothstep(max(lowest, 0.), 0., .15849);\n}\nhit march(vec3 ray, vec3 dir) {\n\tvec2 cur;\n\tfloat t = .005;\n\tfloat tdist = 0.;\n\tfloat minstep = .010;\n\tfloat last = 20.;\n\tfloat room = 0.;\n\tfor(int temp_38 = 0; temp_38 < 40; ++temp_38) {\n\t\tcur = scene(ray + dir * t);\n\t\tif(cur.x > 20.) {\n\t\t\treturn hit(ray, ray, dir, 20., tdist, material(vec3(0.), 0., 0., 0., 0., 0.));\n\t\t}\n\t\tif(cur.x <= (.005 + .0025 * t)) {\n\t\t\tif(cur.y == 3.) {\n\t\t\t\ttdist += t;\n\t\t\t\tt = 0.;\n\t\t\t\tmaterial mat = get_material(ray, 0., 3.);\n\t\t\t\troom = mat.room;\n\t\t\t\tray += vec3(room * 100., 0., 0.);\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tt += abs(cur.x) + minstep;\n\t\t\tif(t > 20.) {\n\t\t\t\treturn hit(ray, ray, dir, 20., tdist, material(vec3(0.), 0., 0., 0., 0., 0.));\n\t\t\t}\n\t\t\tif(cur.x >= last && room == 0.) {\n\t\t\t\tminstep += .0075;\n\t\t\t}\n\t\t\tlast = cur.x;\n\t\t}\n\t}\n\tvec3 fray = ray + dir * (t + cur.x);\n\treturn hit(fray, ray, dir, cur.x, tdist, get_material(fray, cur.x, cur.y));\n}\nfloat ambient_occlusion(vec3 pos, vec3 dir, float cdist) {\n\treturn smoothstep(0., min(scene(pos + dir * cdist).x, 20.), cdist / 1.75);\n}\nvec3 camera_turn(vec3 p) {\n\tfloat v = max(mod(iTime, 30.) - 8., 0.) / 3.5;\n\treturn vec3(rotate_2d(p.xz, -(pow(clamp(v, 0., 1.), 1.2) + max(v - 1., 0.))), p.y).xzy;\n}\nvec3 rgb_hsv1(vec3 rgb) {\n\tvec4 K = vec4(0., -.33333, .66667, -1.);\n\tvec4 p = (rgb.g < rgb.b ? vec4(rgb.bg, K.wz) : vec4(rgb.gb, K.xy));\n\tvec4 q = (rgb.r < p.x ? vec4(p.xyw, rgb.r) : vec4(rgb.r, p.yzx));\n\tfloat d = q.x - min(q.w, q.y);\n\treturn vec3(abs(q.z + (q.w - q.y) / (6. * d + .00001)), d / (q.x + .00001), q.x);\n}\nvec3 shade(hit cur) {\n\tfloat room = floor(cur.pos.x / 100. + .5);\n\tvec3 normal = normalize(vec3(scene(cur.pos + vec3(.00001, 0., 0.)).x - scene(cur.pos + vec3(-.00001, 0., 0.)).x, scene(cur.pos + vec3(0., .00001, 0.)).x - scene(cur.pos + vec3(0., -.00001, 0.)).x, scene(cur.pos + vec3(0., 0., .00001)).x - scene(cur.pos + vec3(0., 0., -.00001)).x));\n\tvec3 lpos = vec3(room * 100., 5., mix(5., -1., abs(room - 1.)));\n\tvec3 ivec = normalize(lpos - cur.pos);\n\tfloat incidence = max(dot(ivec, normal), 0.);\n\tfloat specular = 0.;\n\tif(cur.mat.specular != 0. && incidence > 0.) {\n\t\tspecular = pow(max(dot(normalize(ivec + cur.origin), normal), 0.), cur.mat.specular) / length(lpos - cur.pos);\n\t}\n\tfloat shadow = get_shadow(cur.pos, lpos);\n\treturn apply_fog(hsv1_rgb(rgb_hsv1(cur.mat.color) * vec3(1., 1., incidence * cur.mat.diffuse * shadow + ambient_occlusion(cur.pos, normal, cur.dist) * cur.mat.ambient + specular * shadow + abs(normal.x) * cur.mat.normal_mod)), cur, length(cur.origin - cur.pos), 0.);\n}\nfloat catmull_rom(float r) {\n\tfloat scaled_val = 10. * r * 3.6;\n\tfloat scaled_val_floor = max(0., min(10., floor(scaled_val)));\n\tfloat k = scaled_val_floor;\n\tfloat k0p0 = 1.;\n\tfloat k0m0 = K_(1.) - K_(0.);\n\tfloat k0p1 = K_(1.);\n\tfloat k0m1 = (K_(2.) - K_(0.)) * .5;\n\tfloat p0 = K_(k);\n\tfloat m0 = (K_(k + 1.) - K_(k - 1.)) * .5;\n\tfloat p1 = K_(k + 1.);\n\tfloat m1 = (K_(k + 2.) - K_(k)) * .5;\n\tfloat k0 = float(k == 0.);\n\tp0 = k0 * k0p0 + (1. - k0) * p0;\n\tp1 = k0 * k0p1 + (1. - k0) * p1;\n\tm0 = k0 * k0m0 + (1. - k0) * m0;\n\tm1 = k0 * k0m1 + (1. - k0) * m1;\n\tfloat t = scaled_val - scaled_val_floor;\n\tfloat omt = 1. - t;\n\treturn (p0 * (1. + 2. * t) + m0 * t) * omt * omt + (p1 * (1. + 2. * omt) - m1 * omt) * t * t;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec2 pos = (fragCoord.xy / iResolution.xy * 2. - 1.) * vec2(iResolution.x / iResolution.y, 1.);\n\tfloat eyeoff = -sign(pos.x) * .15;\n\tfloat rs = iResolution.x / iResolution.y;\n\tvec2 eyepos = vec2(mod(pos.x + rs, rs) - rs / 2., pos.y);\n\teyepos = eyepos / vec2(1., iResolution.y / (iResolution.x / 2.)) / 2.;\n\tfloat radsq = dot(eyepos, eyepos);\n\teyepos *= catmull_rom(radsq * 1.65);\n\teyepos = eyepos * 2. * vec2(1., iResolution.y / (iResolution.x / 2.));\n\tvec3 origin = camera_turn(vec3(0., .5, -4. - pow(clamp(1. - mod(iTime, 30.) / 10., 0., 1.), 3.) * 100. + sin(max(mod(iTime, 30.) - 10., 0.) / 4.) * .1) + vec3(eyeoff, 0., 0.));\n\tvec3 cd = normalize(camera_turn(vec3(0., .5, -1.)) - origin);\n\thit cur = march(origin, normalize(cross(cd, vec3(0., 1., 0.)) * eyepos.x + vec3(0., 1., 0.) * eyepos.y + cd * 2.));\n\tif(cur.dist < .050) {\n\t\tfragColor = vec4(mix(mix(vec3(1., 1., 1.), shade(cur), clamp((mod(iTime, 30.) - .5) / 2., 0., 1.)), vec3(0.), smoothstep(0., 1., (radsq - .1) * 5.)), 1.);\n\t} else {\n\t\tvec3 cursky = sky(cur.origin, cur.dir);\n\t\tfragColor = vec4(mix(mix(vec3(1., 1., 1.), mix(cursky, apply_fog(cursky, cur, 20., 1.), min(cur.total_dist * 20., 1.)), clamp((mod(iTime, 30.) - .5) / 2., 0., 1.)), vec3(0.), smoothstep(0., 1., (radsq - .1) * 5.)), 1.);\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mls3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 8732, 8787, 8787, 9587], [9588, 9588, 9621, 9621, 9939], [9940, 9940, 10001, 10001, 10130], [10131, 10131, 10156, 10156, 10850], [10851, 10851, 10870, 10870, 11307], [11308, 11308, 11335, 11335, 11422], [11423, 11423, 11456, 11456, 11554], [11555, 11555, 11580, 11580, 11698], [11699, 11699, 11743, 11743, 11835], [11836, 11836, 11856, 11856, 14150], [14151, 14151, 14190, 14190, 14562], [14563, 14563, 14594, 14594, 15455], [15456, 15456, 15514, 15514, 15592], [15593, 15593, 15619, 15619, 15758], [15759, 15759, 15784, 15784, 16079], [16080, 16080, 16101, 16101, 17081], [17082, 17082, 17110, 17110, 17797], [17798, 17798, 17853, 17853, 19123]], "test": "untested"}
{"id": "MlS3zD", "name": "Ugly Brick", "author": "psykotic", "description": "Just a test for now.", "tags": ["2d"], "likes": 6, "viewed": 216, "published": "Public", "date": "1427309507", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( vec3 p )\n{\n\tfloat h = dot(p,vec3(127.1,311.7,201.3));\n\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix(mix( mix( hash( i + vec3(0,0,0) ), \n                         hash( i + vec3(1,0,0) ), u.x),\n                    mix( hash( i + vec3(0,1,0) ), \n                         hash( i + vec3(1,1,0) ), u.x), u.y),\n               mix( mix( hash( i + vec3(0,0,1) ), \n                         hash( i + vec3(1,0,1) ), u.x),\n                    mix( hash( i + vec3(0,1,1) ), \n                         hash( i + vec3(1,1,1) ), u.x), u.y), u.z );\n}\n\nfloat noise(vec2 p)\n{\n    return noise(vec3(p.xy, 1));\n}\n\nfloat fbm(vec2 p)\n{\n    const mat2 m = mat2(0.8, 0.6, -0.6, 0.8);\n \n    float f = 0.0;\n    f += 0.5000 * noise(p); p = m * p * 2.02;\n    f += 0.2500 * noise(p); p = m * p * 2.03;\n    f += 0.1250 * noise(p); p = m * p * 2.01;\n    f += 0.0625 * noise(p);\n    return f / 0.9375;\n}\n\n// ...\n\nconst vec2 brick_size = vec2(0.2, 0.1);\n\nvoid masks(vec2 p, out float mortar, out float mortar_grain, out float brick_grain)\n{\n    vec2 b = p / brick_size;\n    ivec2 bi = ivec2(b);\n    \n    b.x += 0.5 * float(bi.y - (bi.y / 2) * 2);\n    bi = ivec2(b);\n\n    vec2 bf = fract(b);\n    \n    bf.x += 0.05 * fbm(50.0 * p);\n    bf.y += 0.1 * fbm(30.0 * p);\t\n\n    mortar = 1.0 - smoothstep(0.025, 0.0255, bf.x) * smoothstep(0.975, 0.965, bf.x) * smoothstep(0.05, 0.051, bf.y) * smoothstep(0.90, 0.89, bf.y);\n    mortar_grain = 0.5 * fbm(300.0*p);\n    brick_grain = smoothstep(0.7, 0.9, fbm(100.0*p*vec2(1.0, 1.3)));\n}\n\nfloat height(vec2 p)\n{\n    float mortar, mortar_grain, brick_grain;\n    masks(p, mortar, mortar_grain, brick_grain);\n    return 0.01 * mortar * mortar_grain  + (1.0 - mortar) * (1.0 - 0.3 * brick_grain + 0.003 * fbm(110.0*p));\n}\n\nvec3 normal(vec2 p)\n{\n    float d = 0.001;\n    vec2 dx = vec2(d, 0.0);\n    vec2 dy = vec2(0.0, d);\n    float dh_dx = (height(p + dx) - height(p)) / d;\n    float dh_dy = (height(p + dy) - height(p)) / d;\n    return normalize(vec3(-dh_dx, -dh_dy, 1.0));\n}\n\nvec3 diffuse(vec2 p)\n{\n    vec2 b = p / brick_size;\n    ivec2 bi = ivec2(b);\n    \n    b.x += 0.5 * float(bi.y - (bi.y / 2) * 2);\n    bi = ivec2(b);\n\n    vec2 bf = fract(b);\n  \n    float mortar_mask, mortar_grain_mask, brick_grain_mask;\n    masks(p, mortar_mask, mortar_grain_mask, brick_grain_mask);\n    \n    vec3 mortar_color = vec3(0.7, 0.7, 0.7) - 0.1 * vec3(fbm(20.0*p));\n\tvec3 mortar_grain_color = 0.1 * vec3(0.6, 0.5, 0.3);\n    \n    mortar_color = mortar_grain_mask * mortar_grain_color + (1.0 - mortar_grain_mask) * mortar_color;\n    \n    vec3 brick_color = vec3(0.5, 0.1, 0.1);\n    brick_color += vec3(0.1 * noise(vec2(bi)));\n    brick_color -= vec3(smoothstep(0.0, 1.0, 0.7*fbm(20.0*(p)) - 0.3));\n\n\tvec3 brick_grain_color = vec3(0.6, 0.3, 0.2);\n    brick_color = brick_grain_mask * brick_grain_color + (1.0 - brick_grain_mask) * brick_color;\n    \n  \treturn mortar_color * mortar_mask + (1.0 - mortar_mask) * brick_color;\n}\n\nvec3 light(vec3 p, vec3 n, vec3 c, vec3 l, float i)\n{\n    vec3 d = l - p;\n    float a = 1.0 / (1.0 + length(d));\n    float f = dot(normalize(d), n);\n    float w = 0.5; \n    return c * a * i * max(0.0, (f + w) / (1.0 + w));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 l = vec3(0.5 + 0.5 * sin(2.0 * iTime), 0.5 + 0.5 * sin(3.0 * iTime), 1.0 + sin(iTime));\n\n    vec3 color;\n    //color = diffuse(q.xy);\n    //color = normal(p);\n    color = light(vec3(p, 0.0), normal(p), diffuse(p), l, 1.1);\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlS3zD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 109], [111, 111, 137, 137, 666], [668, 668, 689, 689, 724], [726, 726, 745, 745, 1003], [1005, 1054, 1139, 1139, 1621], [1623, 1623, 1645, 1645, 1851], [1853, 1853, 1874, 1874, 2106], [2108, 2108, 2130, 2130, 3039], [3041, 3041, 3094, 3094, 3265], [3267, 3267, 3324, 3324, 3676]], "test": "untested"}
{"id": "MlsGDs", "name": "ascii terminal", "author": "ryk", "description": "webgl compatible variant of this shader: [url]https://vimeo.com/119702476[/url]", "tags": ["2d", "crt", "pixels"], "likes": 51, "viewed": 5299, "published": "Public API", "date": "1426366950", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float time;\n\nfloat noise(vec2 p)\n{\n  return sin(p.x*10.) * sin(p.y*(3. + sin(time/11.))) + .2; \n}\n\nmat2 rotate(float angle)\n{\n  return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\n\nfloat fbm(vec2 p)\n{\n  p *= 1.1;\n  float f = 0.;\n  float amp = .5;\n  for( int i = 0; i < 3; i++) {\n    mat2 modify = rotate(time/50. * float(i*i));\n    f += amp*noise(p);\n    p = modify * p;\n    p *= 2.;\n    amp /= 2.2;\n  }\n  return f;\n}\n\nfloat pattern(vec2 p, out vec2 q, out vec2 r) {\n  q = vec2( fbm(p + vec2(1.)), fbm(rotate(.1*time)*p + vec2(1.)));\n  r = vec2( fbm(rotate(.1)*q + vec2(0.)), fbm(q + vec2(0.)));\n  return fbm(p + 1.*r);\n\n}\n\nfloat digit(vec2 p){\n    vec2 grid = vec2(3.,1.) * 15.;\n    vec2 s = floor(p * grid) / grid;\n    p = p * grid;\n    vec2 q;\n    vec2 r;\n    float intensity = pattern(s/10., q, r)*1.3 - 0.03 ;\n    p = fract(p);\n    p *= vec2(1.2, 1.2);\n    float x = fract(p.x * 5.);\n    float y = fract((1. - p.y) * 5.);\n    int i = int(floor((1. - p.y) * 5.));\n    int j = int(floor(p.x * 5.));\n    int n = (i-2)*(i-2)+(j-2)*(j-2);\n    float f = float(n)/16.;\n    float isOn = intensity - f > 0.1 ? 1. : 0.;\n    return p.x <= 1. && p.y <= 1. ? isOn * (0.2 + y*4./5.) * (0.75 + x/4.) : 0.;\n}\n\nfloat hash(float x){\n    return fract(sin(x*234.1)* 324.19 + sin(sin(x*3214.09) * 34.132 * x) + x * 234.12);\n}\n\nfloat onOff(float a, float b, float c)\n{\n\treturn step(c, sin(iTime + a*cos(iTime*b)));\n}\n\nfloat displace(vec2 look)\n{\n    float y = (look.y-mod(iTime/4.,1.));\n    float window = 1./(1.+50.*y*y);\n\treturn sin(look.y*20. + iTime)/80.*onOff(4.,2.,.8)*(1.+cos(iTime*60.))*window;\n}\n\nvec3 getColor(vec2 p){\n    \n    float bar = mod(p.y + time*20., 1.) < 0.2 ?  1.4  : 1.;\n    p.x += displace(p);\n    float middle = digit(p);\n    float off = 0.002;\n    float sum = 0.;\n    for (float i = -1.; i < 2.; i+=1.){\n        for (float j = -1.; j < 2.; j+=1.){\n            sum += digit(p+vec2(off*i, off*j));\n        }\n    }\n    return vec3(0.9)*middle + sum/10.*vec3(0.,1.,0.) * bar;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    time = iTime / 3.;\n    vec2 p = fragCoord / iResolution.xy;\n    float off = 0.0001;\n    vec3 col = getColor(p);\n    fragColor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[13, 13, 34, 34, 97], [99, 99, 125, 125, 191], [194, 194, 213, 213, 430], [432, 432, 479, 479, 635], [637, 637, 657, 657, 1210], [1212, 1212, 1232, 1232, 1322], [1324, 1324, 1364, 1364, 1412], [1414, 1414, 1441, 1441, 1600], [1602, 1602, 1624, 1624, 1995], [1997, 1997, 2054, 2054, 2201]], "test": "untested"}
{"id": "MlsGWX", "name": "Flow of cells", "author": "sben", "description": "A simple work on the graphs of a function.", "tags": ["2d", "visualization", "animation", "curve", "graph", "cell", "art", "multiprocess"], "likes": 114, "viewed": 7467, "published": "Public", "date": "1425824753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by sofiane benchaa - sben/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n#define FIELD 20.0\n#define HEIGHT 0.7\n#define ITERATION 2\n#define TONE vec3(0.5,0.2,0.3)\n\nfloat eq(vec2 p,float t){\n\tfloat x = sin( p.y +cos(t+p.x*.2) ) * cos(p.x-t);\n\tx *= acos(x);\n\treturn - x * abs(x-.5) * p.x/p.y;\n}\n\nvoid mainImage( out vec4 O, vec2 U ) {\n\tO -= O; vec4 X=O;\n\tvec2  p = 20.*(U / iResolution.xy  +.5);\n\tfloat t = iTime,i,\n         hs = 20.*(.7+cos(t)*.1),\n\t      x = eq(p,t), y = p.y-x;\n    \n    for(float i=0.; i<2.; ++i)\n\t\tp.x *= 2.,\n        X = x + vec4(0, eq(p,t+i+1.), eq(p,t+i+2.) ,0),\n        x = X.z += X.y,\n        O += vec4(.5,.2,.3,0) / abs(y-X-hs);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlsGWX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 219, 244, 244, 347], [349, 349, 387, 387, 709]], "test": "untested"}
{"id": "MlSGz1", "name": "[NV15]Flossing Space", "author": "florian", "description": "A ton of code thrown into glsl sandbox and then into shadertoy last minute. Needs flossing and tuning.", "tags": ["space", "nv15"], "likes": 7, "viewed": 264, "published": "Public", "date": "1426824801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n// ------------------------------------------------------- SH, yes 'orangebook' -----------------------------------------------------------------------------\n\nstruct SHC\n{\n    vec3 L00, L1m1, L10, L11, L2m2, L2m1, L20, L21, L22;\n};\n\nSHC beach = SHC(\n                vec3( 0.6841148,  0.6929004,  0.7069543),\n                vec3( 0.3173355,  0.3694407,  0.4406839),\n                vec3(-0.1747193, -0.1737154, -0.1657420),\n                vec3(-0.4496467, -0.4155184, -0.3416573),\n                vec3(-0.1690202, -0.1703022, -0.1525870),\n                vec3(-0.0837808, -0.0940454, -0.1027518),\n                vec3(-0.0319670, -0.0214051, -0.0147691),\n                vec3( 0.1641816,  0.1377558,  0.1010403),\n                vec3( 0.3697189,  0.3097930,  0.2029923)\n                );\n\nvec3 sh_light(vec3 normal, SHC l)\n{\n    float x = normal.x;\n    float y = normal.y;\n    float z = normal.z;\n    \n    const float C1 = 0.429043;\n    const float C2 = 0.511664;\n    const float C3 = 0.743125;\n    const float C4 = 0.886227;\n    const float C5 = 0.247708;\n    \n    return (\n            C1 * l.L22 * (x * x - y * y) +\n            C3 * l.L20 * z * z +\n            C4 * l.L00 -\n            C5 * l.L20 +\n            2.0 * C1 * l.L2m2 * x * y +\n            2.0 * C1 * l.L21  * x * z +\n            2.0 * C1 * l.L2m1 * y * z +\n            2.0 * C2 * l.L11  * x +\n            2.0 * C2 * l.L1m1 * y +\n            2.0 * C2 * l.L10  * z\n            );\n}\n// noise (iq)\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nvec3 hash3( vec3 p )\n{\n    vec3 q = vec3( dot(p,vec3(127.1,311.7, 567.324)), \n\t\t\t\t   dot(p,vec3(269.5,183.3, 341.693)), \n\t\t\t\t   dot(p,vec3(419.2,371.9, 127.143)) );\n\treturn fract(sin(q)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\n// ------------------------------------------------------- atmosphere -----------------------------------------------------------------------------\n// Credit: Written by GLtracy\n// found on shadertoy\n\n// math const\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\nconst float MAX = 10000.0;\n\n// scatter const\nconst float K_R = 0.166;\nconst float K_M = 0.0025;\nconst float E = 14.3; \t\t\t\t\t\t// light intensity\nconst vec3  C_R = vec3( 0.3, 0.7, 1.0 ); \t// 1 / wavelength ^ 4\nconst float G_M = -0.85;\t\t\t\t\t// Mie g\n\nconst float R = 1.016 * 6300.0;\nconst float R_INNER = 2.0 * 0.49840050697085 * 6300.0;\n\nconst float SCALE_H = 4.0 / ( R - R_INNER );\nconst float SCALE_L = 1.0 / ( R - R_INNER );\n\nconst int NUM_OUT_SCATTER = 10;\nconst float FNUM_OUT_SCATTER = 10.0;\n\nconst int NUM_IN_SCATTER = 10;\nconst float FNUM_IN_SCATTER = 10.0;\n\n// angle : pitch, yaw\nmat3 rot3xy( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// ray intersects sphere\n// e = -b +/- sqrt( b^2 - c )\nvec2 ray_vs_sphere( vec3 p, vec3 dir, float r ) {\n\tfloat b = dot( p, dir );\n\tfloat c = dot( p, p ) - r * r;\n\t\n\tfloat d = b * b - c;\n\tif ( d < 0.0 ) {\n\t\treturn vec2( MAX, -MAX );\n\t}\n\td = sqrt( d );\n\t\n\treturn vec2( -b - d, -b + d );\n}\n\n// Mie\n// g : ( -0.75, -0.999 )\n//      3 * ( 1 - g^2 )               1 + c^2\n// F = ----------------- * -------------------------------\n//      2 * ( 2 + g^2 )     ( 1 + g^2 - 2 * g * c )^(3/2)\nfloat phase_mie( float g, float c, float cc ) {\n\tfloat gg = g * g;\n\t\n\tfloat a = ( 1.0 - gg ) * ( 1.0 + cc );\n\n\tfloat b = 1.0 + gg - 2.0 * g * c;\n\tb *= sqrt( b );\n\tb *= 2.0 + gg;\t\n\t\n\treturn 1.5 * a / b;\n}\n\n// Reyleigh\n// g : 0\n// F = 3/4 * ( 1 + c^2 )\nfloat phase_reyleigh( float cc ) {\n\treturn 0.75 * ( 1.0 + cc );\n}\n\nfloat density( vec3 p ){\n\treturn exp( -( length( p ) - R_INNER ) * SCALE_H );\n}\n\nfloat optic( vec3 p, vec3 q ) {\n\tvec3 step = ( q - p ) / FNUM_OUT_SCATTER;\n\tvec3 v = p + step * 0.5;\n\t\n\tfloat sum = 0.0;\n\tfor ( int i = 0; i < NUM_OUT_SCATTER; i++ ) {\n\t\tsum += density( v );\n\t\tv += step;\n\t}\n\tsum *= length( step ) * SCALE_L;\n\t\n\treturn sum;\n}\n\nvec3 in_scatter( vec3 o, vec3 dir, vec2 e, vec3 l ) {\n\tfloat len = ( e.y - e.x ) / FNUM_IN_SCATTER;\n\tvec3 step = dir * len;\n\tvec3 p = o + dir * e.x;\n\tvec3 v = p + dir * ( len * 0.5 );\n\n\tvec3 sum = vec3( 0.0 );\n\tfor ( int i = 0; i < NUM_IN_SCATTER; i++ ) {\n\t\tvec2 f = ray_vs_sphere( v, l, R );\n\t\tvec3 u = v + l * f.y;\n\t\t\n\t\tfloat n = ( optic( p, v ) + optic( v, u ) ) * ( PI * 4.0 );\n\t\t\n\t\tsum += density( v ) * exp( -n * ( K_R * C_R + K_M ) );\n\n\t\tv += step;\n\t}\n\tsum *= len * SCALE_L;\n\t\n\tfloat c  = dot( dir, -l );\n\tfloat cc = c * c;\n\t\n\treturn sum * ( K_R * C_R * phase_reyleigh( cc ) + K_M * phase_mie( G_M, c, cc ) ) * E;\n}\n\n// ---------------------------------------------------------Shading Functions----------------------------------------------------------------------\n\nfloat pow5(float v)\n{\n    float tmp = v*v;\n    return tmp*tmp*v;\n}\n\nfloat distribution(vec3 n, vec3 h, float roughness)\n{\n    float m_Sq= roughness * roughness;\n    float NdotH_Sq= max(dot(n, h), 0.0);\n    NdotH_Sq= NdotH_Sq * NdotH_Sq;\n    return exp( (NdotH_Sq - 1.0)/(m_Sq*NdotH_Sq) )/ (3.14159265 * m_Sq * NdotH_Sq * NdotH_Sq);\n}\n\nfloat geometry(vec3 n, vec3 h, vec3 v, vec3 l, float roughness)\n{\n    float NdotL_clamped= max(dot(n, l), 0.0);\n    float NdotV_clamped= max(dot(n, v), 0.0);\n    float k= roughness * sqrt(2.0/3.14159265);\n    float one_minus_k= 1.0 -k;\n    return ( NdotL_clamped / (NdotL_clamped * one_minus_k + k) ) * ( NdotV_clamped / (NdotV_clamped * one_minus_k + k) );\n}\n\nfloat fresnel(float f0, vec3 n, vec3 l)\n{\n    return f0 + (1.0-f0) * pow(1.0- dot(n, l), 5.0);\n}\n\nfloat diffuseEnergyRatio(float f0, vec3 n, vec3 l)\n{\n    return 1.0 - fresnel(f0, n, l);\n}\n\n// -----------------------------------------------------Distance Function / Tools ---------------------------------------------------------------------\n\nfloat rmf(vec3 p, float frequency, float lacunarity)\n{\n    p *= frequency;\n    float signal = 0.0;\n    float value  = 0.0;\n    float weight = 1.0;\n    float h = 1.0;\n    float f = 1.0;\n\n    for (int curOctave=0; curOctave < 6; curOctave++) \n    {\n        signal = noise(p);\n        signal = pow(1.0 - abs(signal), 2.0) * weight;\n        weight = clamp(0.0, 1.0, signal * 16.0);\n        value += (signal * pow(f, -1.0));\n        f *= lacunarity;\n        p *= lacunarity;\n    }\n    \n    return (value * 1.25) - 1.0;\n}\n\nfloat sdHexPrism(vec3 p, vec2 h, float k)\n{\n    vec3 q = abs(p);\n    return max(q.z-h.y,max((q.x*0.866025*k+q.y*0.5),q.y)-h.x);\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y);\n    vec2 v = vec2( c.z*c.y/c.x, -c.z );\n\n    vec2 w = v - q;\n\n    vec2 vv = vec2( dot(v,v), v.x*v.x );\n    vec2 qv = vec2( dot(v,w), v.x*w.x );\n\n    vec2 d = max(qv,0.0)*qv/vv;\n\n    return sqrt( dot(w,w) - max(d.x,d.y) )* sign(max(q.y*v.x-q.x*v.y,w.y));\n}\n\nfloat sdBox(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// Kali's code for this fractal (modified)\nfloat cc, ss;\n\nvec4 formula (vec4 p) \n{\n\t//p.y-=t*.25;\n    p.y=abs(3.-mod(p.y, 6.));\n    for (int i=0; i<6; i++) {\n\t\tp.xyz = abs(p.xyz)-vec3(.0,1.,.0);\n\t\tp=p*1.6/clamp(dot(p.xyz,p.xyz),.2,1.)-vec4(0.4,1.5,0.4,0.);\n\t\tp.xz*=mat2(cc,ss,-ss,cc);\n\t}\n\treturn p;\n}\n\nvec2 de(vec3 pos) \n{\n\tfloat aa=smoothstep(0.,1.,clamp(cos(-pos.y*.4)*1.5,0.,1.))*3.14159;\n    cc=cos(aa);\n    ss=sin(aa);\n\tvec3 tpos=pos;\n\tvec4 p=vec4(tpos,1.);\n\tfloat y=max(0.,.3-abs(pos.y-3.3))/.3;\n    p=formula(p);\n    float fr=max(abs(p.z/p.w)-.01,length(p.zx)/p.w-.002);\n    float d=fr;\n    \n    return vec2(d, pow(dot(p.xy, p.zw)*0.004, 2.666));\n}\n\nfloat sdf(vec3 p, out float m)\n{\n    const vec3 c = vec3(6.0);\n    vec3 w = mod(p, c)-0.5*c;\n    vec3 hashid=hash3(floor(p/12.0));\n    w = rotationMatrix(hashid, iTime*0.05)*w;\n    \n    p = rotationMatrix(vec3(0.0, 1.0, 0.0), 0.1*iTime) * p;\n\tfloat sd = sdCappedCylinder(p, vec2(2.0, 0.16));\n    sd = max(sd, -sdCappedCylinder(p, vec2(1.86, 0.2)));\n    sd = max(sd, -sdCappedCylinder(p-vec3(0.0, 0.0, 0.0), vec2(1.96, 0.12)));\n    sd = min(sd, sdBox(p, vec3(0.16, 0.16, 1.86)));\n    sd = min(sd, sdBox(p, vec3(1.86, 0.16, 0.16)));\n    vec2 fr = de(p*0.25-vec3(0.0, 7.97, 0.0));\n    float fractal = fr.x;\n    m = min(1.0, fr.y);\n    fractal = max(fractal, sdCappedCylinder(p, vec2(2.0, 2.0)));\n    fractal = min(fractal, length(p)-0.5);\n    sd = min(sd, fractal);\n    sd = min(sd, length(p-vec3(0.0, 2.3, 0.0))-0.55);\n    sd = min(sd, sdBox(p-vec3(0.0, -2.7, 0.0), vec3(0.65)));\n    \n    float astroids = (length(w)-0.5*hash(dot(hashid, hashid))); \n    if (astroids < sd)\n    {\n        sd = astroids-rmf(w, 32.0, 0.5)*0.01;\n        m = 2.0;\n    }\n    return sd;\n}\n\n\nvec3 grad(vec3 p, float eps)\n{\n    float m;\n    vec3 f = vec3(sdf(p, m));\n    vec3 g = vec3(sdf(p+vec3(eps, 0.0, 0.0), m),\n                  sdf(p+vec3(0.0, eps, 0.0), m),\n                  sdf(p+vec3(0.0, 0.0, eps), m));\n    return (g-f) / eps;\n}\n\n// ---------------------------------------------------------------------------------------------------------------------------------------\n\nfloat ambientOcclusion(const vec3 p, vec3 N)\n{\n    const float k = 4.0;\n    float amboDelta = 0.04;\n    float ambo = 0.0;\n    float t = 1.0;\n    float m;\n    for (int i=1; i<=4; i++)\n    {\n        ambo += t * (float(i)*amboDelta - sdf(p+N*amboDelta*float(i), m));\n        t *= 0.5;\n    }\n    return 1.0 - min(1.0, k*ambo);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float maxt, float k) \n{\n\tfloat sh = 1.0;\n\tfloat t = mint;\n\tfloat h = 0.0;\n    float m;\n\tfor (int i = 0; i < 32; i++) \n\t{\n\t\tif (t > maxt)\n\t\t\tbreak;\n\t\th = sdf(ro+rd*t, m);\n\t\tsh = min(sh, k*h/t);\n\t\tt += h;\n\t}\n\treturn max(0.1, sh);\n}\n\nvec3 setupRayDirection(vec2 v, float camFov)\n{\n    float fov_y_scale = tan(camFov/2.0);\n    vec3 raydir = vec3(v.x*fov_y_scale, v.y*fov_y_scale, -1.0);\n    return normalize(raydir);\n}\n\nconst float starLimit = 0.975;\nconst vec3 starColor = vec3(1.0, 0.9, 0.8);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    // coordinate system with origin in the center and y-axis goes up\n    // y-range is [-1.0, 1.0] and x-range is based on aspect ratio.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0 * gl_FragCoord.xy) / iResolution.y;\n    vec2 m = 2.0*(iMouse.xy * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    //p.x += sin(time*10.0)*0.01*sin(uv.y*resolution.y*2.0);\n    //p.y += sin(time*100.0)*0.01*sin(uv.x*resolution.y*2.0);\n    \n    //vec3 lightPos = vec3(sin(time), 0.0, 0.3);\n    vec3 lightDir = normalize(vec3(-0.4496467, 0.4155184, 0.3416573));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 rayOrigin = vec3(-1.95, 0.0, 0.0);\n    mat3 rm = rotationMatrix(vec3(0.0, 1.2, 1.0), 1.9);\n    rm *= rotationMatrix(vec3(1.0, 0.0, 0.0), -sin(iTime)*0.1);\n    if (iTime > 15.0)\n    {\n        rayOrigin = vec3(-3.0, 4.0-iTime*0.05, 1.0);\n    \trm = rotationMatrix(normalize(vec3(0.0, 1.0, 1.0)), 2.0);\n    }\n    vec3 rayDir = rm * setupRayDirection(p, radians(100.0));\n    \n    vec3 rayPos = rayOrigin;\n    float sd;\n    float travel = 0.0;\n    \n    vec3 sp = vec3(0.0);\n    bool hit = false;\n    float coneR;\n    float mat =0.0;\n    for (int i=0; i<256; i++)\n    {\n        coneR = travel * tan(0.25*radians(100.0)/iResolution.y);\n        sd = sdf(rayPos, mat);\n        \n        if (abs(sd) < coneR)\n        {\n            hit = true;\n            break;\n        }\n        \n        rayPos += rayDir * sd *0.8;\n        travel += sd *0.8;\n        if (travel > 16.0)\n        {\n            break;\n        }\n    }\n\n    if (hit == true)\n    {\n        //gl_FragColor = vec4(travel*0.1);return;\n        vec3 N = normalize(grad(rayPos, coneR));\n        vec3 P = rayPos;\n        \n        float ambo = ambientOcclusion(P, N);\n        // shadow is messed up\n        float shadow = softShadow(P, lightDir, 0.1, 16.0, 128.0);\n        \n        // constants for now \n\t    float refractiveIndex = clamp(15.0*abs(mat), 0.0, 15.0);\n\t    float u_roughness = clamp(mat*0.25, 0.0, 1.0);\n\t    vec3 u_diffuseColor = mix(vec3(0.25, 0.3, 0.3)*2.0, vec3(0.6, 0.6, 0.8), clamp(mat, 0.0, 1.0));\n        if (mat >= 2.0)\n        {\n            u_diffuseColor = vec3(1.0);\n            u_roughness = 0.1;\n            refractiveIndex = 3.0;\n        }\n        float u_fresnel0 = pow((1.0 - refractiveIndex)/(1.0 + refractiveIndex), 2.0);\n\t    \n        // surface params\n        vec3 halfVec=  normalize(lightDir - rayDir);\n            \n        float NdotL = dot(N, lightDir);\n        float NdotV = dot(N, -rayDir);\n        float NdotL_clamped= max(NdotL, 0.0);\n        float NdotV_clamped= max(NdotV, 0.0);\n        float brdf_spec= fresnel(u_fresnel0, halfVec, lightDir) \n            * geometry(N, halfVec, -rayDir, lightDir, u_roughness) \n            * distribution(N, halfVec, u_roughness) / (4.0 * NdotL_clamped * NdotV_clamped);\n        vec3 color_spec= NdotL_clamped * brdf_spec * lightColor;\n        vec3 color_diff= NdotL_clamped * diffuseEnergyRatio(u_fresnel0, N, lightDir) * u_diffuseColor * lightColor;\n        vec3 color = max(vec3(0.0), color_spec)+color_diff+clamp(-N.z+0.25, 0.0, 1.0)*vec3(0.8, 0.8, 1.0)*u_diffuseColor; // + sh_light(rotationMatrix(vec3(0.0, 1.0, 0.0), 1.9)*N, beach)*0.15;\n        fragColor = vec4(ambo*shadow*color, 1.0);\n        //gl_FragColor.r += mod((atan(rayPos.x, rayPos.z)+3.14) / 6.28, 0.0625) * 16.0;\n    }\n    else\n    {\n        vec3 ro = rayOrigin + vec3(0.0, 0.0, 6450.0);\n        vec2 e = ray_vs_sphere( ro, rayDir, R );\n\t    if ( e.x > e.y || e.x < 0.0 ) {\n\t\t    float n = noise(vec3(uv * 1000.0, 0.0));\n            if (n > starLimit) {\n        \t\tfragColor = vec4(starColor * smoothstep(starLimit, 1.0, n), 1.0);\n            }\n            else {\n            \tfragColor = vec4(vec3(0.0), 1.0);\n            }\n\t\n            return;\n\t    }\n\t\n\t    vec2 f = ray_vs_sphere( ro, rayDir, R_INNER );\n        //e.y = f.x;\n\t    e.y = min( e.y, f.x );\n        \n\t    vec3 I = in_scatter( ro, rayDir, e, lightDir );\n        \n        fragColor = vec4(I, 1.0);\n    }\n    \n    float distanceFromCenter = length( uv - vec2(0.5, 0.5) );\n    float vignetteAmount;\n    vignetteAmount = 1.0 - distanceFromCenter;\n    vignetteAmount = smoothstep(0.1, 1.0, vignetteAmount);    \n    vec3 color = fragColor.xyz;\n    color = pow(color, vec3(0.8));\n    color += 0.05*sin(uv.y*iResolution.y*2.0);\n    color += 0.009 * sin(iTime*16.0);\n    color *=  vignetteAmount*1.0;\n    \n\tfragColor.xyz = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlSGz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 793, 828, 828, 1447], [1448, 1462, 1485, 1485, 1524], [1526, 1526, 1548, 1548, 1726], [1728, 1728, 1754, 1754, 2121], [2971, 2993, 3020, 3020, 3176], [3178, 3195, 3243, 3243, 3419], [3421, 3476, 3525, 3525, 3708], [3710, 3905, 3952, 3952, 4108], [4110, 4156, 4190, 4190, 4221], [4223, 4223, 4247, 4247, 4302], [4304, 4304, 4335, 4335, 4561], [4563, 4563, 4616, 4616, 5185], [5187, 5336, 5357, 5357, 5402], [5404, 5404, 5457, 5457, 5669], [5671, 5671, 5736, 5736, 6030], [6032, 6032, 6073, 6073, 6128], [6130, 6130, 6182, 6182, 6220], [6222, 6375, 6429, 6429, 6890], [6892, 6892, 6935, 6935, 7021], [7023, 7023, 7061, 7061, 7356], [7358, 7358, 7387, 7387, 7478], [7482, 7482, 7527, 7527, 7999], [8001, 8001, 8043, 8043, 8142], [8144, 8144, 8185, 8185, 8278], [8281, 8339, 8363, 8378, 8581], [8583, 8583, 8603, 8603, 8936], [8938, 8938, 8970, 8970, 10000], [10003, 10003, 10033, 10033, 10250], [10252, 10392, 10438, 10438, 10716], [10718, 10718, 10788, 10788, 10994], [10996, 10996, 11042, 11042, 11179], [11258, 11258, 11316, 11454, 15734]], "test": "untested"}
{"id": "MlXGWf", "name": "Xor - Cool Lake", "author": "Xor", "description": "Look around with the mouse. I've seen some nice water scenes, so here's my attempt.\nLet me know what you think in the comments. Suggestions are appreciated.\nUpdate 3/6/15:\nSmoothed water and fixed the stretched rocks.", "tags": ["3d", "refraction", "reflections"], "likes": 85, "viewed": 3327, "published": "Public", "date": "1425603456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time iTime\nfloat sfract(float n)\n{\n    return smoothstep(0.0,1.0,fract(n));\n}\nfloat rand(vec2 n)\n{\n \treturn fract(abs(sin(dot(n,vec2(5.3357,-5.8464))))*256.75+0.325);   \n}\n\nfloat noise(vec2 n)\n{\n    float h1 = mix(rand(vec2(floor(n.x),floor(n.y))),rand(vec2(ceil(n.x),floor(n.y))),sfract(n.x));\n    float h2 = mix(rand(vec2(floor(n.x),ceil(n.y))),rand(vec2(ceil(n.x),ceil(n.y))),sfract(n.x));\n    float s1 = mix(h1,h2,sfract(n.y));\n    return s1;\n}\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    vec2 dir = ((iMouse.xy/iResolution.xy)*vec2(1.0,-0.5)+vec2(0.0,0.75))*6.28;\n    vec3 pos = vec3(0.0,0.5,0.0);//vec3(noise((time/32.0)*vec2(1.0,0.0)),0.05,noise((time/32.0)*vec2(0.0,1.0)))*20.0;\n\tcamPos =  pos;//vec3(cos(time/4.0)*8.0,1.0,sin(time/4.0)*8.0);\n    camTar = pos+vec3(cos(dir.x)*cos(dir.y),sin(dir.y),sin(dir.x)*cos(dir.y));\n}\nvec3 doBackground( in vec3 dir)\n{\n    float sky = dot(dir,vec3(0.0,-1.0,0.0))*0.5+0.5;\n    float sun = pow(dot(dir,normalize(vec3(1.0,0.7,0.9)))*0.5+0.5,32.0);\n    vec2 p = vec2(dir.x+dir.z,dir.y-dir.z);\n    float clouds = noise(p*8.0)*noise(p*9.0)*noise(p*10.0)*noise(p*11.0)*sky;\n    vec3 total = vec3(sky*0.6+0.05+sun+clouds,sky*0.8+0.075+pow(sun,1.5)+clouds,sky+0.2+pow(sun,4.0)+clouds);\n    vec3 ground = texture(iChannel0,(dir.xz)/dir.y).rrr*vec3(1.1,1.0,0.9);\n    return mix(total,ground,clamp((sky-0.6)*64.0,0.0,1.0));\n}\n    \nfloat doModel( vec3 pos )\n{\n    vec3 p = pos+vec3(time*0.2,0.0,0.0)+vec3(noise(pos.xz),0.0,noise(pos.xz+8.0))*0.2;//Distort coordinates\n    float height = 0.1*pow(noise(p.xz+vec2(time*0.7,time*0.6))*0.5+noise(p.xz*8.0+vec2(time))*0.35+noise(p.xz*16.0+vec2(0.0,time*0.5))*0.1+noise(p.xz*24.0)*0.05,0.25);\n    float model = p.y-height;\n    return model;\n}\nvec3 doMaterial(in vec3 rd, in vec3 nor )\n{\n    vec3 ref = doBackground(reflect(rd,nor));\n    return mix(doBackground(refract(rd,nor,0.8)),ref,clamp(dot(ref,vec3(1.0/3.0))*1.5,0.0,1.0));\n}\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doFog( in vec3 rd, in float dis, in vec3 mal )\n{\n    vec3 col = mal;\n\tcol = mix(doBackground(rd),col,1.0-clamp(dis*dis/90.0,0.0,1.0));\n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 10.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h*.8;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd )\n{\n    float res = 1.0;\n    float t = 0.5;                 // selfintersection avoidance distance\n\tfloat h = 1.0;\n    for( int i=0; i<40; i++ )         // 40 is the max numnber of raymarching steps\n    {\n        h = doModel(ro + rd*t);\n        res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n\t\tt += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n    }\n    return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n\tvec3 col = doBackground(rd);\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        // materials\n        vec3 mal = doMaterial(rd, nor );\n\n        col = doFog( rd, t, mal );\n\t}\n    // gamma\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MlXGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 42, 42, 85], [86, 86, 106, 106, 179], [181, 181, 202, 202, 456], [457, 457, 540, 540, 883], [884, 884, 917, 917, 1412], [1418, 1418, 1445, 1445, 1771], [1772, 1772, 1815, 1815, 1960], [2010, 2010, 2063, 2063, 2168], [2170, 2170, 2220, 2220, 2640], [2642, 2642, 2674, 2674, 3086], [3088, 3088, 3136, 3136, 3559], [3561, 3561, 3625, 3625, 3803], [3805, 3805, 3862, 3862, 4647]], "test": "untested"}
{"id": "Mt23R1", "name": "rykscape", "author": "ryk", "description": "An idea so stupid I had to implement it. My shader equivalent of a theme song.", "tags": ["space", "dither", "netscape"], "likes": 8, "viewed": 1330, "published": "Public API", "date": "1427050332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\nstruct VolData\n{\n    vec3 bgCol;\n    vec3 fgCol;\n};\n\t\nstruct Hit\n{\n\tfloat dist;\n\tfloat index;\n};\n\nfloat hash(vec2 p)\n{\n    return fract(sin((mod(p.x*p.y*87328.24,1.0)+mod(p.y*923.123,1.0)))*34345.965 );\n}\n\t\nfloat time;\n\nfloat sphere(vec3 pos)\n{\n    return length(pos) - 4.;\n}\n\t\nHit scene(vec3 pos)\n{\n\treturn Hit(sphere(pos), 0.);\n}\n\nHit raymarch(Ray ray)\n{\n\tvec3 pos;\n\tHit hit;\n\thit.dist = 0.;\n\tHit curHit;\n\tfor (int i = 0; i < 30; i++)\n\t{\n\t\tpos = ray.org + hit.dist * ray.dir;\n\t\tcurHit = scene(pos);\n\t\thit.dist += curHit.dist;\n\t}\n\thit.index = curHit.index;\n\thit.index = curHit.dist < 0.01 ? hit.index : -1.;\n\treturn hit;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    scene(pos+eps.xyy).dist - scene(pos-eps.xyy).dist,\n\t    scene(pos+eps.yxy).dist - scene(pos-eps.yxy).dist,\n\t    scene(pos+eps.yyx).dist - scene(pos-eps.yyx).dist );\n\treturn normalize(nor);\n}\n\nvec3 starStart = vec3(-3.,15.,-10.);\nvec3 starEnd = vec3(3.3,-3.,8.);\n\nvec3 foreStarPos()\n{\n    float t = fract(time/4.);\n    return mix(starStart,starEnd,t);\n}\n\nfloat foreStarDist()\n{\n    return max(0., length(foreStarPos()) - 4.);\n}\n\nvec4 render(Ray ray)\n{\n\tHit hit = raymarch(ray);\n\tvec3 pos = ray.org + hit.dist*ray.dir;\n\tvec3 surfaceCol = vec3(0.5,0.3,.3);\n\tvec3 specCol = vec3(0.5,0.4,.3);\n\tvec3 col = vec3(0.);\n\tif (hit.index != -1.)\n\t{\n\t\tvec3 nor = calcNormal(pos);\n\t\tvec3 l = normalize(foreStarPos() - pos);\n        float inten = max(0.,1.-length(foreStarPos() - pos)/10.);\n\t\tcol = surfaceCol;\n\t\t\n\t\tfloat diff = clamp(dot(nor,l),0.,1.);\n\t\tvec3 r = normalize(2.*dot(nor,l)*nor-l);\n\t\tvec3 v = normalize(ray.org-pos);\n\t\tfloat spec = clamp(dot(v,r),0.,1.);\n\t\tcol = (diff*col + pow(spec,10.)*specCol)*inten + inten;\n\t}\n\treturn vec4(col, hit.index);\n}\n\nvec3 glow(Ray ray)\n{\n    float minDist = length(ray.org - ray.dir * dot(ray.dir, ray.org)) - 3.9;\n    float inten = max(0.1, 1.-pow(foreStarDist()*.3, 0.8));\n    float noi = sin(time*2. + sin(time*2.2)*2.) + 1.;\n    return vec3(0.2, 0.7, 0.9)/pow(minDist, 2.) * (inten+noi/15.) * 0.8;\n}\n\nfloat foreIntensity(vec3 pos)\n{\n    vec3 dir = starEnd - starStart;\n    vec3 c = foreStarPos();\n    vec3 p = pos-c;\n    float a = 0.8;\n    p.yz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n    vec3 stretch = p.z > 0. ? vec3(1.) : vec3(1.,1.,0.1);\n    float dist = length(p*stretch);\n    return max(0., 2.-dist*4.);\n}\n\nfloat backIntensity(vec3 pos, vec3 center, float speed, float spacing)\n{\n    pos -= center;\n    pos.z -= speed*time;\n    pos.z += spacing/2.;\n    pos.z = mod(pos.z, spacing);\n    pos.z -= spacing/2.;\n    vec3 stretch = pos.z > 0. ? vec3(1.) : vec3(1.,1.,.05);\n    float dist = length(pos*stretch);\n    return max(0., 2.-dist*2.);\n}\n\nVolData shootingStars(Ray ray)\n{\n    float dist = 0.;\n    vec3 p;\n    float fIntensity = 0.;\n    float bIntensity = 0.;\n    float a = 0.8;\n    for (float i = 0.; i < 50.; i+=1.)\n    {\n        p = ray.org + ray.dir * dist * i;\n        dist += 0.01;\n        fIntensity += foreIntensity(p);\n        p.yz *= mat2(cos(a), sin(a), -sin(a), cos(a));\n        bIntensity += backIntensity(p, vec3(-8., -1., 0.), 20., 50.);\n        bIntensity += backIntensity(p, vec3(-4., 9., 0.), 20., 60.);\n        bIntensity += backIntensity(p, vec3(-13., 5., 0.), 40., 80.);\n    }\n    VolData v;\n    v.fgCol = vec3(.8,.5,.4) * fIntensity;\n    v.bgCol = vec3(.8,.5,.4) * bIntensity*0.6;\n    v.bgCol += vec3(.5,.7,.8) * pow(hash(ray.dir.yz), 50.);\n   \n    return v;\n}\n\nRay createRay(vec3 center, vec3 lookAt, vec3 up, vec2 uv, float fov, float aspect)\n{\n\tRay ray;\n\tray.org = center;\n\tvec3 dir = normalize(lookAt - center);\n\tup = normalize(up - dir*dot(dir,up));\n\tvec3 right = cross(dir, up);\n\tuv = 2.*uv - vec2(1.);\n\tfov = fov * 3.1415/180.;\n\tray.dir = dir + tan(fov/2.) * right * uv.x + tan(fov/2.) / aspect * up * uv.y;\n\tray.dir = normalize(ray.dir);\t\n\treturn ray;\n}\n\nvoid backBar(vec2 uv, inout vec4 col)\n{\n    float w = 0.1;\n    float h = 0.7;\n    float mar = 0.002;\n    float l =\n        step(0., uv.x)\n        * (1. - step(w, uv.x)) \n        * smoothstep(0., mar, uv.y)\n        * (1. - smoothstep(h-mar, h, uv.y));\n    col.rgb = mix(col.rgb, vec3(1.), l);\n}\n\nvoid lserif(vec2 uv, inout vec4 col)\n{\n    float c = 0.05;\n    float w = 0.2;\n    float h = 0.03;\n    float mar = 0.002;\n    float l =\n        step(-w/2.+c, uv.x)\n        * (1. - step(w/2.+c, uv.x)) \n        * step(0., uv.y)\n        * (1. - step(h, uv.y));\n    float rad = w/2.-c;\n    vec2 lp = uv + vec2( w/2. - c, -h-rad);\n    float lc = smoothstep(rad-mar, rad+mar, length(lp)) * step(0., lp.x) * step(0., -lp.y)\n        * (1.-step(rad, -lp.y)) * (1.-step(rad, lp.x));\n    vec2 rp = uv + vec2( -w/2. - c, -h-rad);\n    float rc = smoothstep(rad-mar, rad+mar, length(rp)) * step(0., -rp.x) * step(0., -rp.y)\n        * (1.-step(rad, -rp.y)) * (1.-step(rad, -rp.x));\n    col.rgb = mix(col.rgb, vec3(1.), l + lc + rc);\n}\n\nvoid userif(vec2 uv, inout vec4 col)\n{\n    float c = 0.05;\n    float w = 0.2;\n    float h = 0.03;\n    float mar = 0.002;\n    float l =\n        step(-w/2.+c, uv.x)\n        * (1. - step(0., uv.x)) \n        * smoothstep(0., mar, uv.y)\n        * (1. - step(h, uv.y));\n    float rad = w/2.-c;\n    vec2 lp = uv + vec2( w/2. - c, -h-rad);\n    float lc = smoothstep(rad-mar, rad+mar, length(lp)) * step(0., lp.x) * step(0., -lp.y)\n        * (1.-step(rad, -lp.y)) * (1.-step(rad, lp.x));\n    col.rgb = mix(col.rgb, vec3(1.),  l+lc);\n}\n\nvoid roundThing(vec2 uv, inout vec4 col)\n{\n    float mar = 0.003;\n    float outRad = 0.18;\n    float inRad = 0.15;\n    float rw = 0.08;\n    uv.x -= rw;\n    float outerCircle = smoothstep(outRad+mar, outRad, length(uv)) * step(0., uv.x);\n    float rect = step(-rw, uv.x) * (1. - step(0., uv.x))\n        * (1.-smoothstep(outRad, outRad+mar, uv.y)) * smoothstep(-outRad-mar,-outRad, uv.y);\n    float innerCircle = smoothstep(inRad-mar, inRad, length(uv+vec2(rw,0.))) ;\n    col.rgb = mix(col.rgb, vec3(1.), (outerCircle + rect) * innerCircle);\n}\n\nvoid diagBar(vec2 uv, inout vec4 col)\n{\n    float m = 8.;\n    float d = 0.11;\n    float h = 0.2;\n    float lowT = sin(uv.x*m)*h;\n    float upT = sin((uv.x-d)*m)*h;\n    float mar = 0.003;\n    float l =\n        smoothstep(lowT, lowT+mar, uv.y)\n        * (1. - smoothstep(upT, upT+mar, uv.y));\n    float doDraw = col.w != 0. ? 1. : 0.;\n    col.rgb = mix(col.rgb, vec3(1.), l*doDraw);\n}\n\nvoid drawR(vec2 uv, inout vec4 col)\n{\n    uv += vec2(.08,.05);\n    backBar(uv-vec2(.4,.2), col);\n    lserif(uv-vec2(.4,.2), col);\n    userif(uv*vec2(1.,-1) + vec2(-0.4, 0.9), col);\n    roundThing(uv-vec2(.5,.717), col);\n    diagBar(uv-vec2(0.22,.36), col);\n}\n\nvec2 quantize(vec2 uv, float steps)\n{\n    return uv - fract(uv*steps)/steps;\n}\n\nvec3 quantizeColor(vec3 col, vec2 uv)\n{\n    vec3 noi = vec3(hash(uv + vec2(0.3,0.)*sin(time)),\n                    hash(uv+ vec2(0.3)*sin(time)),\n                    hash(uv+ vec2(0.,.3)*sin(time))) - 0.5;\n    col += noi/5.;\n    return col - fract(col*5.)/5.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord / iResolution.xy;\n\ttime = iTime ;\n\tvec3 cameraPos = vec3(3.,5.,0.);\n\tvec3 lookAt = vec3(0.,5.,0.);\n\tvec3 up = vec3(0.,1.,0.);\n\tfloat aspect = iResolution.x/iResolution.y;\n    vec2 uvQuant = quantize(uv, 64.);\n\tRay rayQuant = createRay(cameraPos, lookAt, up, uvQuant, 90., aspect);\n\tRay ray = createRay(cameraPos, lookAt, up, uv, 90., aspect);\n\t//vec4 col = render(ray);\n\tvec4 col = render(rayQuant);\n    vec3 glowCol = glow(rayQuant);\n    VolData shots = shootingStars(rayQuant);\n    col.rgb += (glowCol + shots.bgCol) * col.w * -1. + shots.fgCol;\n    col.rgb = quantizeColor(col.rgb, uvQuant);\n    drawR(uv, col);\n\tfragColor = vec4(col.rgb,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt23R1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[137, 137, 157, 157, 243], [259, 259, 283, 283, 314], [317, 317, 338, 338, 370], [372, 372, 395, 395, 662], [664, 664, 691, 691, 942], [1015, 1015, 1035, 1035, 1104], [1106, 1106, 1128, 1128, 1178], [1180, 1180, 1202, 1202, 1798], [1800, 1800, 1820, 1820, 2086], [2088, 2088, 2119, 2119, 2401], [2403, 2403, 2475, 2475, 2734], [2736, 2736, 2768, 2768, 3478], [3480, 3480, 3564, 3564, 3879], [3881, 3881, 3920, 3920, 4174], [4176, 4176, 4214, 4214, 4894], [4896, 4896, 4934, 4934, 5421], [5423, 5423, 5465, 5465, 5964], [5966, 5966, 6005, 6005, 6348], [6350, 6350, 6387, 6387, 6608], [6610, 6610, 6647, 6647, 6688], [6690, 6690, 6729, 6729, 6951], [6953, 6953, 7010, 7010, 7680]], "test": "untested"}
{"id": "Mt23z1", "name": "Metallic Diffraction 2", "author": "rcread", "description": "another modified version of https://www.shadertoy.com/view/XsXXDn\n", "tags": ["2d"], "likes": 12, "viewed": 537, "published": "Public", "date": "1427067991", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by randy read - rcread/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n//\tmodified version of https://www.shadertoy.com/view/XsXXDn\n\n\n//#define VARIATION2 1\n\n//\thash23() based on hash functions from Dave_Hoskins -- https://www.shadertoy.com/view/ltfGDs\nvec3 hash23( vec2 p ) {\n\tp\t\t= fract( p * vec2( 5.3983, 5.4427 ) );\n    p\t\t+= dot( p.yx, p.xy + vec2( 21.5351, 14.3137 ) );\n\treturn fract( p.x * p.y * vec3( 95.4337, 97.597, 93.234 ) );\n}\n\nvec2 complex_multiply( vec2 a, vec2 b )\t\t{ return vec2( a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x ); }\t//\tac - bd, ad + bc\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat t = ( sin( iTime / 2e1 ) + 1. ) * 2e1;\n\tvec2 r = iResolution.xy;\n\tvec3 c;\n\tfloat l=0., z=t, k=5.;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 p\t\t= floor( fragCoord.xy )/r;\n\t\tp\t\t\t-= .5;\n\t\tp.x\t\t\t*= r.x/r.y;\n\t\tz\t\t\t+= .07;\n#ifdef VARIATION2\n        k\t\t\t= log(iTime);\n        z\t\t\t+= k/1e2;\n#endif\n\t\tl\t\t\t= length(p);\n        p\t\t\t= complex_multiply( p, normalize( vec2( max( 0.01, sin( t ) + 1. ), max( 0.01, cos( t * l ) + 1. ) ) ) );\n\t\tp\t\t\t+= p/l*(sin(z)+1.)*abs(sin(l*9.-z*2.));\n\t\tc[i]\t\t= .01/length(abs(mod(p,1.)-.5));\n\t}\n    c\t\t\t\t= clamp( c, 0., 1. );\n    c\t\t\t\t= mix( k * c, vec3( .5 ), ( c.x + c.y + c.z ) / 4. );\n    c \t\t\t\t+= hash23( fragCoord.xy ) / 2e2;\t// dithering to remove banding -- iq did this with a texture https://www.shadertoy.com/view/ll2GD3\n    \n\tfragColor=vec4( 1.2 * c, 1. );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt23z1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[215, 310, 333, 333, 496], [498, 498, 540, 540, 603], [604, 625, 682, 682, 1470]], "test": "untested"}
{"id": "Mt23zz", "name": "ngPsy1", "author": "netgrind", "description": "#woah", "tags": ["colorful", "psychedelic", "netgrind", "mic"], "likes": 29, "viewed": 3250, "published": "Public API", "date": "1426722269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Made into third eye tye-dye by Cale Bradbury - @netgrind 2015\n// Edited version of https://www.shadertoy.com/view/MsfGzM Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define MIC\n//comment out the line above to disable mic\n\n//#define GREY\n//uncomment out above to make grey\n\nfloat f(vec3 p) \n{ \n    p.z-=iTime*.5;\n    return length(cos(p)-.1*cos(9.*(p.z+.1*p.x-p.y)+iTime*2.0))-(0.9+sin(iTime)*.1); \n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float i = iTime;\n    vec3 d = .5-vec3(fragCoord,1.)/iResolution.x;\n    d.y-=0.2;\n    d.x = abs(d.x);\n    vec3 o=d;\n    float l = length(d.xyz)*10.0;\n    float a = atan(d.y,d.x);\n    o.xy*= mat2(cos(i+sin(a+i))+10.0, sin(i*.5+a*l)*2.0, -sin(i+a),cos(i*d.z+l)+10.0);\n    for(int i=0;i<40;i++){\n    \tfloat m = 0.0;\n        #ifdef MIC\n        m = texture(iChannel0,vec2(.5,float(i/40))).r;\n        #endif\n        o+=f(o+m)*(d);\n    }\n    o.z = length(o*d);\n    vec4 c = vec4(sin(i+abs((o-d)+length(o.xy*step(o.z,700.0))))*.3+.7,1.0);\n    #ifdef GREY\n    c.r = c.b+c.g+c.r;\n    c.r/=3.0;\n    c.r = pow(c.r,2.0);\n    c.rgb = c.rrr;\n    #endif\n    fragColor=c;\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt23zz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[303, 354, 372, 372, 480], [481, 481, 538, 538, 1198]], "test": "untested"}
{"id": "Mt2Gz1", "name": "Smooth Voronoi Test", "author": "Nihilus", "description": "Smooth Voronoi Test, need to learn a lot more for a good implementation.", "tags": ["voronoi"], "likes": 2, "viewed": 181, "published": "Public", "date": "1427058651", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//quantity of cells\n#define N 8.0\n\nvec2 rd(in vec2 p) {\n\treturn texture(iChannel0, (p + 0.5)/256.0, -100.0 ).xy;\n}\n\nfloat voronoi(in vec2 x) {\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    \n    float res = 8.0;\n    \n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n        \tvec2 b = vec2(i, j);\n            vec2 r = vec2(b) + (0.5 + 0.5 * cos(iTime + 8.0*rd(p + b))) - f;\n            float d = dot(r, r);\n            \n            res = min(d, res);\n        }\n    }\n    \n    return sqrt(res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat c = voronoi(N * uv);\n    fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2Gz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 35, 55, 55, 114], [116, 116, 142, 142, 522], [524, 524, 581, 581, 688]], "test": "untested"}
{"id": "Mt2Gzw", "name": "Cryptic Curves", "author": "marius", "description": "elliptic curves of form x2 = y3 + ay + b, for a2 + b2 = 9\n\nhttp://en.wikipedia.org/wiki/Elliptic_curve", "tags": ["crypto"], "likes": 3, "viewed": 137, "published": "Public", "date": "1427785748", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = vec2(1.) - 2. * uv;  // [-1..1]\n    uv *= vec2(3.0);  // [-3..3]\n    \n    float a = 3.*sin(iTime);\n    float b = 3.*cos(iTime);\n    \n    float delta = (uv.x * uv.x) + (uv.y * uv.y * uv.y + a * uv.y + b);\n\n    if (abs(delta) < .07) {\n\t  fragColor = vec4(vec3(1. - abs(delta) * 10.),1.0);\n    } else if (delta < .0) {\n      fragColor = vec4(vec3(0.5),1.0);\n    } else {\n      fragColor = vec4(vec3(0.0),1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2Gzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 523]], "test": "untested"}
{"id": "Mt2Gzz", "name": "Tall Walls", "author": "echophon", "description": "Editing & learning from this great demo by Silexars https://www.shadertoy.com/view/XsXXDn", "tags": ["editnlearnshadeaday"], "likes": 2, "viewed": 227, "published": "Public", "date": "1426743941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.pouet.net/prod.php?which=57245\n// https://www.shadertoy.com/view/XsXXDn\n\n#define t iTime\n#define r iResolution.xy\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec3 c;\n\tfloat l,w,z=t;\n\tfor(int i=0;i<3;i++) {\n\t\tvec2 uv,p=fragCoord.xy/r;\n\t\tuv=p;\n\t\tp-=.5;\n\t\tp.x*=r.x/r.y;\n        p.y*=0.05;\n\t\tz*=0.5;\n\t\tl=length(p);\n        w=sin(t*0.5)*0.5;\n\t\tuv-=p/l*(sin(z))*abs(sin(l*10.+sin(w)-z*2.));\n\t\tc[i]=.0005/length(abs(mod(uv,1.)-0.5));\n\t}\n\tfragColor=vec4(c/l,t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mt2Gzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 129, 185, 185, 484]], "test": "untested"}
{"id": "MtB3zw", "name": "Plasma sines", "author": "the23", "description": "multiple sine-threads overlaying creating a saturated sine field", "tags": ["plasma", "sine", "inyourface", "saturated"], "likes": 2, "viewed": 265, "published": "Public", "date": "1427577926", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float speed = 1.5;\nconst float widthFactor = 4.0;\n\nvec3 calcSine(vec2 uv, \n              float frequency, float amplitude, float shift, float offset,\n              vec3 color, float width, float exponent)\n{\n    float angle = iTime * speed * frequency + (shift + uv.x) * 6.2831852;\n    \n    float y = sin(angle) * amplitude + offset;\n    \n    float scale = pow(smoothstep(width * widthFactor, 0.0, distance(y, uv.y)), exponent);\n    \n    return color * scale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    color += calcSine(uv, 2.0, 0.45, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.1, 3.0);\n    color += calcSine(uv, 2.2, 0.45, 0.2, 0.5, vec3(0.0, 1.0, 0.0), 0.1, 3.0);\n    color += calcSine(uv, 2.4, 0.45, 0.4, 0.5, vec3(1.0, 0.0, 0.0), 0.1, 3.0);\n\n    color += calcSine(uv, 2.6, 0.4, 0.6, 0.5, vec3(0.5, 0.0, 1.0), 0.1, 4.0);\n    color += calcSine(uv, 2.8, 0.4, 0.8, 0.5, vec3(1.0, 0.5, 1.0), 0.1, 4.0);\n    color += calcSine(uv, 3.0, 0.4, 0.0, 0.5, vec3(1.0, 0.0, 0.5), 0.1, 4.0);\n    \n    color += calcSine(uv, 2.25, 0.45, 0.5, 0.5, vec3(0.0, 0.5, 1.0), 0.1, 4.0);\n    color += calcSine(uv, 2.50, 0.45, 0.5, 0.5, vec3(0.5, 1.0, 0.5), 0.1, 4.0);\n    color += calcSine(uv, 2.75, 0.45, 0.5, 0.5, vec3(1.0, 0.5, 0.0), 0.1, 4.0);\n    \n    //this \"takes the edge off\" the overlay\n    //color *= 0.5;\n    \n    //this creates a solarized effect\n    //color = smoothstep(0.2, 0.5, color);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtB3zw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 212, 212, 466], [468, 468, 525, 525, 1512]], "test": "untested"}
{"id": "MtB3zz", "name": "Fire and water", "author": "Branch", "description": "Fire and water", "tags": ["fireandwater"], "likes": 14, "viewed": 399, "published": "Public", "date": "1426624703", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rotY(in float a){\n\treturn mat3( cos(a), 0.0, sin(a),\n\t\t\t\t 0.0,    1.0, 0.0,\n\t\t\t\t-sin(a), 0.0, cos(a)\n\t\t\t    );\n}\nfloat smin( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    return pow( (a*b)/(a+b), 1.0/k );\n}\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCappedCylinder( vec3 p, vec2 h ){\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ){\n    //r-=p.y*1.12;\n    //p*=rotY(iTime*.087683+p.x*.061);\n    //p.yxz*=rotY(iTime*.1+p.x*.016);\n    if(p.y>-1.9)\n    r+=-p.y*-1.1*texture(iChannel0,vec2((32./1024.)*3.141*atan(p.x,p.z)+0.1,p.y*.00811-iTime*.0126)).r;\n\n    vec3 pa = p - a , ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - r;\n}\nfloat sdHexPrism( vec3 p, vec2 h ){\n    vec3 q = abs(p);\n    return max(q.z-h.y,max(q.x+q.y*0.57735,q.y*1.1547)-h.x);\n}\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\nfloat udRoundBox( vec3 p, vec3 b, float r ){\n  return length(max(abs(p)-b,0.0))-r;\n}\nfloat sdSphere( vec3 p, float s ){\n  s+=texture(iChannel2, vec2(2.+atan(p.x,p.z)*1.1,p.y)*0.21+iTime*.1).r*0.13;\n  return length(p)-s;\n}\nfloat pallo( vec3 p, float s ){\n  return length(p)-s;\n}\n\nfloat scene(vec3 pos){\n\tfloat tulos=2.;\n    tulos = min(tulos, distance(texture(iChannel0, pos.xz*0.02423).r*0.6-1.3,pos.y+.1*sin(pos.z+sin(pos.x+iTime)+iTime)));\n    return tulos*0.86;\n}\nfloat calculateDistance(in vec3 p, out vec3 color){\n    vec3 rayPosition = vec3(p.xz, p.y).xzy;\n    vec3 d = abs(rayPosition) - vec3(2.0, 0.0, -52.0);\n    color = vec3(3.8, 1.0, 0.6);  \n    float finalDistance = 10000000.;\n    //float dist1;\n    float dist1 = sdCapsule( p, vec3(0.,5.5,0.), vec3(0.,-.0,0.), 1.84);\n    //dist1 = min(dist1, distance(texture(iChannel0, p.xz*0.02423).r*0.6-1.3,p.y+.1*sin(p.z+sin(p.x+iTime)+iTime)));\n\tdist1=min(dist1,scene(p));\n    if(finalDistance > dist1){\t\n        finalDistance = dist1;\n        color = vec3(1.2, 1.0, 0.6)*19.15*min(iTime*.1,0.9)*texture(iChannel1,vec2(atan(p.x,p.z),p.y+0.4)).rgb;\n    }\n    \n    /*\n    dist1 = sdSphere( p-vec3(0.,0.,0.), 2.);\n    \n    if(finalDistance > dist1){\t\n        finalDistance = dist1;\n        color = vec3(1.,2.1,1.1)*1.5*min(iTime*.1,0.9)*texture(iChannel1,vec2(atan(p.x,p.z),p.y+0.4)).rgb;\n    }\n    \n    dist1 = pallo( p-vec3(0.,0.,0.), 2.02);\n    \n    if(finalDistance > dist1){\t\n        finalDistance = dist1;\n        color = vec3(1.,2.,6.1)*1.5*min(iTime*.1,0.9)*texture(iChannel1,vec2(atan(p.x,p.z),p.y+0.4)).rgb;\n    }\n    */\n    return finalDistance;\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k ){\n    float res = 1.0;\n    float t = mint;\n    for( float i=0.; i<11.; i++ ){\n        vec3 C;\n        float h = calculateDistance(ro + rd*t, C);\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec3 tracer(vec3 rayStartPosition, vec3 rayDirection){\n\n    vec3 finalColor = vec3(0., 0., 0.);\n    vec3 rayPosition = rayStartPosition;\n    float stepable = 1.;\n    float dist = 0.;\n    vec3 normalVector = rayDirection;\n    float coff = 1.;\n    float find;\n    vec3 lightSource = vec3(16.,12.*sin(3.141*iTime*.01+3.141*.5), -6.7);\n    \n    for(float k=0.; k<2.; k++) {\n        find = 0.0;\n        for(float i=0.; i<33.; i++) {\n            vec3 color;\n            stepable = calculateDistance(rayPosition, color);\n            dist += stepable;\n            rayPosition = rayStartPosition + dist * rayDirection;\n            if(length(rayPosition)>33.) {\n                vec3 lightDir = (lightSource-rayStartPosition);\n                lightDir = (lightDir/length(lightDir));\n                float directLight = dot(normalVector, lightDir);\n                finalColor+=max(pow(directLight,55.)*vec3(1.6,1.1,.9)*1.8,0.0001);\n                return finalColor;\n            }\n            float value = 0.7;\n            if( abs(stepable) <= value){\n                float epsilon = value;\n                vec3 C;\n                normalVector = vec3(\tcalculateDistance(rayPosition+vec3(epsilon,0,0),C)-calculateDistance(rayPosition+vec3(-epsilon,0,0),C),\n                                        calculateDistance(rayPosition+vec3(0,epsilon,0),C)-calculateDistance(rayPosition+vec3(0,-epsilon,0),C),\n                                        calculateDistance(rayPosition+vec3(0,0,epsilon),C)-calculateDistance(rayPosition+vec3(0,0,-epsilon),C));\n                normalVector = normalize(normalVector);\n                \n                \n                float shadow = (0.3+softshadow(rayPosition + normalVector, normalize(lightSource), 0.01, 22.0) * .6);\n                finalColor = mix(finalColor, color * vec3(dot(normalVector, -rayDirection)) * shadow, coff) ;\n                finalColor = mix(finalColor, vec3(0.0), dist/15.0);  /*fog*/\n                find = 1.0;\n                break;\n                \n            }\n        }\n        dist = 0.0;\n        rayStartPosition = rayPosition + normalVector;\n        rayPosition = rayStartPosition;\n        rayDirection = reflect(rayDirection, normalVector);\n        coff *= 0.26;\t\n    }\n                vec3 lightDir = (lightSource-rayStartPosition);\n                lightDir = (lightDir/length(lightDir));\n                float directLight = dot(normalVector, lightDir);\n                finalColor+=max(pow(directLight,1.+iTime*0.4)*vec3(1.6,1.1,.9)*1.8,0.0001);\n                return finalColor;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec3 cameraPosition = vec3( 0., 5.+sin(iTime/8.), -18.+sin(iTime/5.)*4.);\n    cameraPosition*=rotY(-3.141*2.*iTime*0.081);\n    cameraPosition*=rotY(3.141*2.*iTime*0.0001);\n\tcameraPosition*=rotY(iTime*.7);\n    vec2 uv = 2.0 * fragCoord.xy / iResolution.xy - 1.0;\n    float aspect = iResolution.x / iResolution.y;\n    vec3 direction = normalize(vec3(.5 * uv * vec2(aspect, 1.0), 1. )) ;\n    direction.yxz *= rotY(-0.24);\n    direction*=rotY(-3.141*2.*iTime*0.081);\n    direction *= rotY(iTime*.7);\n    vec4 C = vec4(tracer(cameraPosition, direction),1.0);\n\tfloat vignette = 1.165 / (1.25 + 1.4*dot(uv, uv));\n\t\n    fragColor=vec4(pow(C.r,2.2)*C.rgb-vec3(.27),1.);\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtB3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 117], [118, 118, 159, 159, 237], [238, 238, 270, 270, 335], [336, 336, 377, 377, 476], [478, 478, 529, 625, 875], [876, 876, 911, 911, 995], [996, 996, 1016, 1016, 1088], [1089, 1089, 1133, 1133, 1173], [1174, 1174, 1208, 1208, 1310], [1311, 1311, 1342, 1342, 1366], [1368, 1368, 1390, 1390, 1555], [1556, 1556, 1607, 1607, 2698], [2700, 2700, 2764, 2764, 2995], [2997, 2997, 3051, 3051, 5535], [5537, 5537, 5593, 5593, 6260]], "test": "untested"}
{"id": "MtBGRD", "name": "Spherical voronoi", "author": "mattz", "description": "Picking uniform points on cube faces and warping through tangent function before projecting to sphere gives a nice even distribution. Computing cell noise directly on the sphere looks nicer (to my eyes) than on a regular 3D lattice.", "tags": ["voronoi", "sphere", "picking", "point"], "likes": 136, "viewed": 5207, "published": "Public API", "date": "1427512550", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Spherical voronoi, by mattz. \n   License Creative Commons Attribution 3.0 (CC BY 3.0) Unported License.\n\n   Mouse rotates (or click in bottom left for auto-rotate).\n\n   Keys do things:\n\n     D - toggle demo mode (nothing else does anything until you leave demo mode)\n\n     S - toggle sphere\n     W - toggle warp through tangent function\n     R - toggle randomization\n     P - toggle points\n     G - toggle grid boundaries\n     V - toggle voronoi cell boundaries\n     C - toggle color scheme (random or by cube face)\n     T - toggle voronoi cell texture\n\n     N,M - change number of points \n\n   Much of the code below could be simplified/optimized. \n\n*/\n\n/* Number of points per edge of the cube face (we will have 6*N^2 points) */\nfloat N = 8.0;\n\n/* Bunch o' settings */\nfloat fade_in = 1.0;\nfloat warp_fraction = 1.0;\nfloat randomize_amount = 1.0;\nfloat sphere_fraction = 1.0;\nfloat enable_color = 1.0;\nfloat enable_voronoi_edges = 1.0;\nfloat enable_grid_lines = 1.0;\nfloat enable_points = 1.0;\nfloat color_scheme = 1.0;\nfloat enable_texture = 0.0;\n\n/* Bunch o' other globals. */\nconst float farval = 1e5;\nconst vec3 tgt = vec3(0);\nconst vec3 cpos = vec3(0,0,2.8);\nconst int rayiter = 60;\nconst float dmax = 20.0;\nvec3 L = normalize(vec3(-0.7, 1.0, -1.0));\nmat3 Rview;\n\nconst float dot_size = 0.02;\nconst float dot_step = 0.005;\n\n/* Magic angle that equalizes projected area of squares on sphere. */\n#define MAGIC_ANGLE 0.868734829276 // radians\n\nfloat warp_theta = MAGIC_ANGLE;\nfloat tan_warp_theta;\n\n\n/* Return a permutation matrix whose first two columns are u and v basis \n   vectors for a cube face, and whose third column indicates which axis \n   (x,y,z) is maximal. */\nmat3 getPT(in vec3 p) {\n\n    vec3 a = abs(p);\n    float c = max(max(a.x, a.y), a.z);    \n\n    vec3 s = c == a.x ? vec3(1.,0,0) : c == a.y ? vec3(0,1.,0) : vec3(0,0,1.);\n\n    s *= sign(dot(p, s));\n    vec3 q = s.yzx;\n    return mat3(cross(q,s), q, s);\n\n}\n\n/* Warp to go cube -> sphere */\nvec2 warp(vec2 x) {\n    return tan(warp_theta*x)/tan_warp_theta;\n}\n\n/* Unwarp to go sphere -> cube */\nvec2 unwarp(vec2 x) {\n    return atan(x*tan_warp_theta)/warp_theta; \n}\n\n/* Return squared great circle distance of two points projected onto sphere. */\nfloat sphereDist2(vec3 a, vec3 b) {\n\t// Fast-ish approximation for acos(dot(normalize(a), normalize(b)))^2\n    return 2.0-2.0*dot(normalize(a),normalize(b));\n}\n\n\n/* Just used for visualization to make sure dots are round regardless of \n   whether we are visualizing them on cube or sphere. */\nfloat sphereOrCubeDist(vec3 a, vec3 b) {\n    return mix(length(a-b), sqrt(sphereDist2(a,b)), sphere_fraction);    \n}\n\n\n/* Just used to visualize distance from spherical Voronoi cell edges. */\nfloat bisectorDistance(vec3 p, vec3 a, vec3 b) {\n    vec3 n1 = cross(a,b);\n    vec3 n2 = normalize(cross(n1, 0.5*(normalize(a)+normalize(b))));\n    return abs(dot(p, n2));             \n}\n\n\n/* RGB from hue. */\nvec3 hue(float h) {\n    vec3 c = mod(h*6.0 + vec3(2, 0, 4), 6.0);\n    return h >= 1.0 ? vec3(h-1.0) : clamp(min(c, -c+4.0), 0.0, 1.0);\n}\n\n\n/* Get index (0-5) for axis. */\nfloat axisToIdx(vec3 axis) {\n    \n    float idx = dot(abs(axis), vec3(0.0, 2.0, 4.0));\n    if (dot(axis, vec3(1.0)) < 0.0) { idx += 1.0; }\n    \n    return idx;\n    \n}\n\n/* From https://www.shadertoy.com/view/4djSRW */\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nbool wrapCube(in mat3 PT, \n              inout vec2 uvn,\n              out mat3 PTn) {\n    \n    // new uv location might have gone off edge of cube face\n    // ...see if it has by comparing to clamped version\n    vec2 uvn_clamp = clamp(uvn, -1.0, 1.0);\n    vec2 extra = abs(uvn_clamp - uvn);\n\n    // it doesn't make sense to go over both corners so only allow\n    // overflow/underflow in u or v but not both\n    if (min(extra.x, extra.y) > 0.0) {\n        \n        return false;\n        \n    } else {            \n\n        // check if we have gone off starting face\n        float esum = extra.x + extra.y;\n\n        if (esum > 0.0) {\n            // need to re-establish what face we are on\n            vec3 p = PT * vec3(uvn_clamp, 1.0 - esum);\n            PTn = getPT(p);\n            uvn = (p * PTn).xy;\n        } else {\n            // same as starting face\n            PTn = PT;\n        }\n\n        return true;\n        \n    }\n    \n}\n\n\n/* Color the sphere/cube points. */\nvec3 gcolor(vec3 pos) {\n\n    // get permutation matrix \n    mat3 PT = getPT(pos);\n    \n    // project to cube face\n    vec3 cf = pos * PT; \n    \n    // UV is in [-1, 1] range\n    vec2 uv = cf.xy / cf.z; \n    \n    // unwarp from sphere -> cube (approximtion of atan)\n    uv = unwarp(uv);      \n    \n    // for viz only\n    pos /= (dot(pos, PT[2]));\n    \n    // quantize uv of nearest cell\n    vec2 uv_ctr = (floor(0.5*N*uv + 0.5) + 0.5)*2.0/N;\n    \n    // for drawing grid lines below\n    vec2 l = abs(mod(uv + 1.0/N, 2.0/N) - 1.0/N)*0.5*N;\n\n    // store distance, material & point for 1st, 2nd closest\n    float d1 = 1e4, d2 = 1e4;\n    float m1 = -1.0, m2 = -1.0;\n    vec3 p1 = vec3(0), p2 = vec3(0);\n\n    // for neighbors in 4x4 neighborhood\n    for (int du=-2; du<=1; ++du) {\n        for (int dv=-2; dv<=1; ++dv) {\n            \n            mat3 PTn;\n            \n            // any time you see 2.0/N it maps from [-1, 1] to [0, N]\n            vec2 uvn = uv_ctr + vec2(float(du), float(dv))*2.0/N;\n            \n            if (wrapCube(PT, uvn, PTn)) {\n\n                // now generate a unique id for the cell\n                vec2 ssn = floor((uvn*0.5 + 0.5)*N);\n                float faceid = axisToIdx(PTn[2]);\n                vec3 id = vec3(ssn, faceid);\n                \n                // generate 3 random #'s from id\n                vec3 r = hash33(id);\n                \n                // randomize dot position within cell\n                uvn += (r.xy-0.5)*2.0*randomize_amount/N;\n\n                // random material\n                float mn = mix((faceid+0.5 + 0.5*r.z - 0.25)/6.0, r.z, color_scheme);\n                \n                // warp cube -> sphere\n                uvn = warp(uvn);\n\n                // can save 1 multiplication over general matrix mult.\n                // because we know last coord is 1\n                vec3 pn = PTn[0]*uvn.x + PTn[1]*uvn.y + PTn[2];\n\n                // update distances if closer\n                float dn = sphereDist2(pn, pos);\n \n                if (dn < d1) {\n                    d2 = d1; p2 = p1; m2 = m1;\n                    d1 = dn; p1 = pn; m1 = mn;\n                } else if (dn < d2) {\n                    d2 = dn; p2 = pn; m2 = mn;\n                }\n\n            }\n            \n        }\n            \n    }\n\n    // get distance to voronoi boundary\n    float b = bisectorDistance(pos, p2, p1);\n    \n    // rainbow stained glass texture business\n    m1 = fract(m1 + enable_texture*(0.5*sqrt(N))*(sqrt(d2)-sqrt(d1)));\n    \n    // cell background color\n    vec3 bg = mix(hue(m1), hue(m2), 0.5*smoothstep(0.003, 0.0, b));\n    \n    // gray vs rgb\n    vec3 c = mix(vec3(0.9), bg, enable_color);\n\n    // grid lines\n    float s = mix(0.02, 0.015, sphere_fraction);\n    c = mix(c, vec3(0.7), smoothstep(2.0*s, s, min(l.x, l.y))*enable_grid_lines);\n\n    // voronoi lines    \n    c = mix(c, vec3(0.0), smoothstep(0.01, 0.00, b)*enable_voronoi_edges);\n\n    // draw points\n    c = mix(c, vec3(0.0), smoothstep(dot_step, 0.0, sphereOrCubeDist(pos, p1)-dot_size)*enable_points);\n\n    return vec3(c);\n    \n    \n}\n\n\n/* Rotate about x-axis */\nmat3 rotX(in float t) {\n    float cx = cos(t), sx = sin(t);\n    return mat3(1., 0, 0, \n                0, cx, sx,\n                0, -sx, cx);\n}\n\n\n/* Rotate about y-axis */\nmat3 rotY(in float t) {\n    float cy = cos(t), sy = sin(t);\n    return mat3(cy, 0, -sy,\n                0, 1., 0,\n                sy, 0, cy);\n\n}\n\n\n/* Adapted from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm */\nfloat sdCube(vec3 p, float r) {    \n    vec3 d = abs(p) - r;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d,0.0));    \n}\n\n\n\n/* Distance function to scene is a single cube/sphere. */\nvec2 map(in vec3 pos) {\t\n\n    float d = mix(sdCube(pos,0.5773), length(pos)-1.0, sphere_fraction);    \n    vec2 rval = vec2(d, 3.0);\n\n    return rval;\n\n}\n\n\n/* IQ's normal calculation. */\nvec3 calcNormal( in vec3 pos ) {\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n        map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n        map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n    return normalize(nor);\n}\n\n\n/* IQ's distance marcher. */\nvec2 castRay( in vec3 ro, in vec3 rd, in float maxd ) {\n\n    const float precis = 0.002;   \n    float h=2.0*precis;\n\n    float t = 0.0;\n    float m = -1.0;\n\n    for( int i=0; i<rayiter; i++ )\n    {\n        if( abs(h)<precis||t>maxd ) continue;//break;\n        t += h;\n        vec2 res = map( ro+rd*t );\n        h = res.x;\n        m = res.y;        \n    }    \n\n    if (t > maxd) {\n        m = -1.0;\n    }\n\n    return vec2(t, m);\n\n}\n\n\n\n/* Pretty basic shading function. */\nvec3 shade( in vec3 ro, in vec3 rd ){\n\n    vec2 tm = castRay(ro, rd, dmax);        \n\n    vec3 c;\n\n\n    if (tm.y < 0.0) {\n\n        c = vec3(1.0);\n\n    } else {        \n\n        vec3 pos = ro + tm.x*rd;\n        vec3 n = calcNormal(pos);\n        \n        pos -= n * map(pos).x;\n\n        vec3 color = gcolor(pos);\n\n        vec3 diffamb = (0.5*clamp(dot(n,L), 0.0, 1.0)+0.5) * color;\n        vec3 R = 2.0*n*dot(n,L)-L;\n        float spec = 0.3*pow(clamp(-dot(R, rd), 0.0, 1.0), 20.0);\n        c = diffamb + spec;\n\n    }\n\n    return c;\n\n}\n\n\n/* Bunch of ASCII keycodes */\nconst float KEY_C = 67.5/256.0;\nconst float KEY_D = 68.5/256.0;\nconst float KEY_G = 71.5/256.0;\nconst float KEY_M = 77.5/256.0;\nconst float KEY_N = 78.5/256.0;\nconst float KEY_R = 82.5/256.0;\nconst float KEY_S = 83.5/256.0;\nconst float KEY_T = 84.5/256.0;\nconst float KEY_P = 80.5/256.0;\nconst float KEY_W = 87.5/256.0;\nconst float KEY_V = 86.5/256.0;\n\n/* Compare key state to default state. */\nfloat keyState(float key, float default_state) {\n    return abs( texture(iChannel0, vec2(key, 0.75)).x - default_state );\n}\n\n\n/* Adapted from https://github.com/danro/jquery-easing/blob/master/jquery.easing.js */\nfloat easeOutBounce(float t, float d) {\n    if ((t/=d) < (1./2.75)) {\n        return (7.5625*t*t);\n    } else if (t < (2./2.75)) {\n        return (7.5625*(t-=(1.5/2.75))*t + .75);\n    } else if (t < (2.5/2.75)) {\n        return (7.5625*(t-=(2.25/2.75))*t + .9375);\n    } else {\n        return (7.5625*(t-=(2.625/2.75))*t + .984375);\n    }\n}\n\n\n/* Easing function. */\nfloat bounce_in(float lo, float hi, float u) {\n    return u < lo ? 0.0 : u > hi ? 1.0 :  1.0 - easeOutBounce(hi-u, hi-lo);\n}\n\n\n/* Easing function. */\nfloat bounce_out(float lo, float hi, float u) {\n    return u < lo ? 0.0 : u > hi ? 1.0 : easeOutBounce(u-lo, hi-lo);\n}\n\n\n/* ...finally! */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    \n\n    vec2 uv = (fragCoord.xy - .5*iResolution.xy) * 0.8 / (iResolution.y);\n\n    vec3 rz = normalize(tgt - cpos),\n        rx = normalize(cross(rz,vec3(0,1.,0))),\n        ry = cross(rx,rz);\n\n    float t;\n    \n    /* Do settings depending on whether demo mode. */\n    if (keyState(KEY_D, 1.0) == 1.0) {\n\n        float k = iTime;\n        t = mod(k, 32.0);\n        N = pow(2.0, mod(floor(k/32.0), 2.0)+3.0);\n\n        fade_in = smoothstep(0.0, 4.0, t) * smoothstep(32.0, 30.0, t);\n        enable_grid_lines = smoothstep(4.0, 6.0, t) * smoothstep(18.0, 16.0, t);\n        enable_points = smoothstep(4.0, 6.0, t) * smoothstep(22.0, 20.0, t);    \n        warp_fraction = bounce_out(6.0, 8.0, t);\n        randomize_amount = bounce_in(8.0, 10.0, t);        \n        sphere_fraction = bounce_out(12.0, 14.0, t);\n        enable_color = smoothstep(16.0, 18.0, t);\n        enable_voronoi_edges = smoothstep(20.0, 22.0, t);\n        enable_texture = smoothstep(24.0, 26.0, t);\n\n    } else {\n\n        t = iTime;\n\n        N = pow(2.0, 2.0+keyState(KEY_N, 1.0)+2.0*keyState(KEY_M, 0.0));\n\n        enable_grid_lines = keyState(KEY_G, 0.0);\n        enable_points = keyState(KEY_P, 0.0);\n        warp_fraction = keyState(KEY_W, 1.0);        \n        randomize_amount = keyState(KEY_R, 1.0);\n        sphere_fraction = keyState(KEY_S, 1.0);\n        enable_color = 1.0;\n        color_scheme = keyState(KEY_C, 1.0);\n        enable_voronoi_edges = keyState(KEY_V, 1.0);\n        enable_texture = keyState(KEY_T, 0.0);\n\n    }\n     \n    // For demonstration, warp_theta varies, but it should just be MAGIC_ANGLE for \"production\" code.\n    warp_theta = max(warp_fraction*MAGIC_ANGLE, 0.001);\n    tan_warp_theta = tan(warp_theta);\n\n  \n    /* Handle mouse motion for rotation. */\n    float thetay = (t-7.0) * 0.1;\n    float thetax = (t-7.0) * 0.05;        \n\n    if (max(iMouse.x, iMouse.y) > 20.0) { \n        thetax = (iMouse.y - .5*iResolution.y) * 5.0/iResolution.y; \n        thetay = (iMouse.x - .5*iResolution.x) * -10.0/iResolution.x; \n    }\n\n    Rview = mat3(rx,ry,rz)*rotX(thetax)*rotY(thetay);        \n    L = Rview*L;\n\n   \t/* Render. */\n    vec3 rd = Rview*normalize(vec3(uv, 1.)),\n        ro = tgt + Rview*vec3(0,0,-length(cpos-tgt));\n\n    fragColor.xyz = mix(vec3(1.0), shade(ro, rd), fade_in);\n\n\n}\n", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBGRD.jpg", "access": "shaders20k", "license": "cc-by-3.0 AND mit", "functions": [[1507, 1680, 1703, 1703, 1933], [1935, 1967, 1986, 1986, 2033], [2035, 2069, 2090, 2090, 2139], [2141, 2221, 2256, 2327, 2380], [2383, 2514, 2554, 2554, 2630], [2633, 2706, 2754, 2754, 2892], [2895, 2915, 2934, 2934, 3051], [3054, 3086, 3114, 3114, 3252], [3254, 3350, 3372, 3372, 3482], [3484, 3484, 3570, 3692, 4416], [4419, 4455, 4478, 4510, 7517], [7520, 7546, 7569, 7569, 7690], [7693, 7719, 7742, 7742, 7863], [7866, 7952, 7983, 7983, 8085], [8089, 8147, 8170, 8170, 8300], [8303, 8334, 8366, 8366, 8605], [8608, 8637, 8692, 8692, 9067], [9071, 9108, 9145, 9145, 9640], [10026, 10068, 10116, 10116, 10191], [10194, 10281, 10320, 10320, 10621], [10624, 10647, 10693, 10693, 10771], [10774, 10797, 10844, 10844, 10915], [10918, 10936, 10993, 10993, 13278]], "test": "untested"}
{"id": "MtBGzz", "name": "Daily: 17/3/15", "author": "hughsk", "description": "Mucking around with shadertoy again", "tags": ["rays", "lighting", "fog", "specular", "oren", "nayar", "guassian"], "likes": 19, "viewed": 380, "published": "Public", "date": "1426623975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec4 mod289_1_0(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nfloat mod289_1_0(float x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0; }\n\nvec4 permute_1_1(vec4 x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nfloat permute_1_1(float x) {\n     return mod289_1_0(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_1_2(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat taylorInvSqrt_1_2(float r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec4 grad4_1_3(float j, vec4 ip)\n  {\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;\n\n  return p;\n  }\n\n// (sqrt(5) - 1)/4 = F4, used once below\n#define F4 0.309016994374947451\n\nfloat snoise_1_4(vec4 v)\n  {\n  const vec4  C = vec4( 0.138196601125011,  // (5 - sqrt(5))/20  G4\n                        0.276393202250021,  // 2 * G4\n                        0.414589803375032,  // 3 * G4\n                       -0.447213595499958); // -1 + 4 * G4\n\n// First corner\n  vec4 i  = floor(v + dot(v, vec4(F4)) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C.xxxx\n  //  x1 = x0 - i1  + 1.0 * C.xxxx\n  //  x2 = x0 - i2  + 2.0 * C.xxxx\n  //  x3 = x0 - i3  + 3.0 * C.xxxx\n  //  x4 = x0 - 1.0 + 4.0 * C.xxxx\n  vec4 x1 = x0 - i1 + C.xxxx;\n  vec4 x2 = x0 - i2 + C.yyyy;\n  vec4 x3 = x0 - i3 + C.zzzz;\n  vec4 x4 = x0 + C.wwww;\n\n// Permutations\n  i = mod289_1_0(i);\n  float j0 = permute_1_1( permute_1_1( permute_1_1( permute_1_1(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute_1_1( permute_1_1( permute_1_1( permute_1_1 (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n\n// Gradients: 7x7x6 points over a cube, mapped onto a 4-cross polytope\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0_1_5 = grad4_1_3(j0,   ip);\n  vec4 p1 = grad4_1_3(j1.x, ip);\n  vec4 p2 = grad4_1_3(j1.y, ip);\n  vec4 p3 = grad4_1_3(j1.z, ip);\n  vec4 p4 = grad4_1_3(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt_1_2(vec4(dot(p0_1_5,p0_1_5), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_1_5 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt_1_2(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  return 49.0 * ( dot(m0*m0, vec3( dot( p0_1_5, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n\n  }\n\n\n\nfloat smin_2_6(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n  return mix(b, a, h) - k * h * (1.0 - h);\n}\n\n\n\nfloat gaussianSpecular_5_7(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float shininess) {\n  vec3 H = normalize(lightDirection + viewDirection);\n  float theta = acos(dot(H, surfaceNormal));\n  float w = theta / shininess;\n  return exp(-w*w);\n}\n\n\nfloat orenNayarDiffuse_3_8(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / 3.14159265;\n}\n\n\nfloat fogFactorExp2_4_9(\n  const float dist,\n  const float density\n) {\n  const float LOG2 = -1.442695;\n  float d = density * dist;\n  return 1.0 - clamp(exp2(d * d * LOG2), 0.0, 1.0);\n}\n\n\n\n//\n// GLSL textureless classic 3D noise \"cnoise\",\n// with an RSL-style periodic variant \"pnoise\".\n// Author:  Stefan Gustavson (stefan.gustavson@liu.se)\n// Version: 2011-10-11\n//\n// Many thanks to Ian McEwan of Ashima Arts for the\n// ideas for permutation and gradient selection.\n//\n// Copyright (c) 2011 Stefan Gustavson. All rights reserved.\n// Distributed under the MIT license. See LICENSE file.\n// https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_7_10(vec3 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_7_10(vec4 x)\n{\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_7_11(vec4 x)\n{\n  return mod289_7_10(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_7_12(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nvec3 fade_7_13(vec3 t) {\n  return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\n// Classic Perlin noise, periodic variant\nfloat pnoise_7_14(vec3 P, vec3 rep)\n{\n  vec3 Pi0 = mod(floor(P), rep); // Integer part, modulo period\n  vec3 Pi1 = mod(Pi0 + vec3(1.0), rep); // Integer part + 1, mod period\n  Pi0 = mod289_7_10(Pi0);\n  Pi1 = mod289_7_10(Pi1);\n  vec3 Pf0 = fract(P); // Fractional part for interpolation\n  vec3 Pf1 = Pf0 - vec3(1.0); // Fractional part - 1.0\n  vec4 ix = vec4(Pi0.x, Pi1.x, Pi0.x, Pi1.x);\n  vec4 iy = vec4(Pi0.yy, Pi1.yy);\n  vec4 iz0 = Pi0.zzzz;\n  vec4 iz1 = Pi1.zzzz;\n\n  vec4 ixy = permute_7_11(permute_7_11(ix) + iy);\n  vec4 ixy0 = permute_7_11(ixy + iz0);\n  vec4 ixy1 = permute_7_11(ixy + iz1);\n\n  vec4 gx0 = ixy0 * (1.0 / 7.0);\n  vec4 gy0 = fract(floor(gx0) * (1.0 / 7.0)) - 0.5;\n  gx0 = fract(gx0);\n  vec4 gz0 = vec4(0.5) - abs(gx0) - abs(gy0);\n  vec4 sz0 = step(gz0, vec4(0.0));\n  gx0 -= sz0 * (step(0.0, gx0) - 0.5);\n  gy0 -= sz0 * (step(0.0, gy0) - 0.5);\n\n  vec4 gx1 = ixy1 * (1.0 / 7.0);\n  vec4 gy1 = fract(floor(gx1) * (1.0 / 7.0)) - 0.5;\n  gx1 = fract(gx1);\n  vec4 gz1 = vec4(0.5) - abs(gx1) - abs(gy1);\n  vec4 sz1 = step(gz1, vec4(0.0));\n  gx1 -= sz1 * (step(0.0, gx1) - 0.5);\n  gy1 -= sz1 * (step(0.0, gy1) - 0.5);\n\n  vec3 g000 = vec3(gx0.x,gy0.x,gz0.x);\n  vec3 g100 = vec3(gx0.y,gy0.y,gz0.y);\n  vec3 g010 = vec3(gx0.z,gy0.z,gz0.z);\n  vec3 g110 = vec3(gx0.w,gy0.w,gz0.w);\n  vec3 g001 = vec3(gx1.x,gy1.x,gz1.x);\n  vec3 g101 = vec3(gx1.y,gy1.y,gz1.y);\n  vec3 g011 = vec3(gx1.z,gy1.z,gz1.z);\n  vec3 g111 = vec3(gx1.w,gy1.w,gz1.w);\n\n  vec4 norm0 = taylorInvSqrt_7_12(vec4(dot(g000, g000), dot(g010, g010), dot(g100, g100), dot(g110, g110)));\n  g000 *= norm0.x;\n  g010 *= norm0.y;\n  g100 *= norm0.z;\n  g110 *= norm0.w;\n  vec4 norm1 = taylorInvSqrt_7_12(vec4(dot(g001, g001), dot(g011, g011), dot(g101, g101), dot(g111, g111)));\n  g001 *= norm1.x;\n  g011 *= norm1.y;\n  g101 *= norm1.z;\n  g111 *= norm1.w;\n\n  float n000 = dot(g000, Pf0);\n  float n100 = dot(g100, vec3(Pf1.x, Pf0.yz));\n  float n010 = dot(g010, vec3(Pf0.x, Pf1.y, Pf0.z));\n  float n110 = dot(g110, vec3(Pf1.xy, Pf0.z));\n  float n001 = dot(g001, vec3(Pf0.xy, Pf1.z));\n  float n101 = dot(g101, vec3(Pf1.x, Pf0.y, Pf1.z));\n  float n011 = dot(g011, vec3(Pf0.x, Pf1.yz));\n  float n111 = dot(g111, Pf1);\n\n  vec3 fade_xyz = fade_7_13(Pf0);\n  vec4 n_z = mix(vec4(n000, n100, n010, n110), vec4(n001, n101, n011, n111), fade_xyz.z);\n  vec2 n_yz = mix(n_z.xy, n_z.zw, fade_xyz.y);\n  float n_xyz = mix(n_yz.x, n_yz.y, fade_xyz.x);\n  return 2.2 * n_xyz;\n}\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex\n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n//\n\nvec3 mod289_8_15(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289_8_15(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute_8_16(vec4 x) {\n     return mod289_8_15(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt_8_17(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise_8_18(vec3 v)\n  {\n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D_8_19 = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g_8_20 = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g_8_20;\n  vec3 i1 = min( g_8_20.xyz, l.zxy );\n  vec3 i2 = max( g_8_20.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D_8_19.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289_8_15(i);\n  vec4 p = permute_8_16( permute_8_16( permute_8_16(\n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D_8_19.wyz - D_8_19.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1_8_21 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0_8_22 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1_8_21.xy,h.z);\n  vec3 p3 = vec3(a1_8_21.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt_8_17(vec4(dot(p0_8_22,p0_8_22), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0_8_22 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0_8_22,x0), dot(p1,x1),\n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n\n\n\n\nfloat grain_6_23(vec2 texCoord, vec2 resolution, float frame, float multiplier) {\n    vec2 mult = texCoord * resolution;\n    float offset = snoise_8_18(vec3(mult / multiplier, frame));\n    float n1 = pnoise_7_14(vec3(mult, offset), vec3(1.0/texCoord * resolution, 0.0));\n    return n1 / 2.0 + 0.5;\n}\n\nfloat grain_6_23(vec2 texCoord, vec2 resolution, float frame) {\n    return grain_6_23(texCoord, resolution, frame, 2.5);\n}\n\nfloat grain_6_23(vec2 texCoord, vec2 resolution) {\n    return grain_6_23(texCoord, resolution, 0.0);\n}\n\n\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX ) {\n  float an = 0.6*iTime + 10.0*mouseX;\n  camPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n  camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void ) {\n  return vec3(0.2, 0.1, 0.2);\n}\n    \n//------------------------------------------------------------------------\n// Modelling \n//\n// Defines the shapes (a sphere in this case) through a distance field, in\n// this case it's a sphere of radius 1.\n//------------------------------------------------------------------------\nfloat doModel( vec3 p ) {\n  p = mod(p + 4.5, 9.0) - 4.5;\n  \n  float r = 1.2;\n  \n  r += snoise_1_4(vec4(p * 5.5, iTime)) * 0.04;\n  \n  float d = length(p) - r;\n  \n  for (int i = 0; i < 15; i++) {\n    float I = float(i);\n    vec3 pp = vec3(sin(I + iTime), cos(I + iTime), sin(I - iTime * 3.0));\n    d = smin_2_6(d, length(p - pp * 0.9) - 0.1, 0.5);\n  }\n  \n  return d;\n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\nvec3 doMaterial( in vec3 pos, in vec3 nor ) {\n  return vec3(0.4, 0.35, 0.3);\n}\n\n//------------------------------------------------------------------------\n// Lighting\n//------------------------------------------------------------------------\nfloat calcSoftshadow( in vec3 ro, in vec3 rd );\n\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec3 mal ) {\n  vec3 lin = vec3(0.0);\n\n  // key light\n  //-----------------------------\n  vec3  lig1 = normalize(vec3(1.0,0.7,0.9));\n  float dif1 = max(0.0, orenNayarDiffuse_3_8(lig1, -rd, nor, 0.9, 0.8));\n  float spc1 = max(0.0, gaussianSpecular_5_7(lig1, -rd, nor, 0.1));\n  \n  vec3  lig2 = normalize(vec3(0.5,-0.9,-0.9));\n  float dif2 = max(0.0, orenNayarDiffuse_3_8(lig2, -rd, nor, 0.9, 0.8)); // max(dot(nor,lig2),0.0);\n  float spc2 = max(0.0, gaussianSpecular_5_7(lig2, -rd, nor, 0.1));\n  \n  vec3 col1 = vec3(4.0, 1.3, 3.5);\n  vec3 col2 = vec3(1.0, 2.0, 5.0);\n  \n  lin += spc1*col1;\n  lin += dif1*col1;\n  lin += spc2*col2;\n  lin += dif2*col2;\n\n  // ambient light\n  //-----------------------------\n  lin += vec3(0.015);\n\n  \n  // surface-light interacion\n  //-----------------------------\n  vec3 col = mal*lin;\n\n  \n  // fog    \n  //-----------------------------\n  //col *= exp(-0.01*dis*dis);\n\n  return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd ) {\n  const float maxd = 20.0;           // max trace distance\n  const float precis = 0.001;        // precission of the intersection\n  float h = precis*2.0;\n  float t = 0.0;\n  float res = -1.0;\n  for( int i=0; i<90; i++ ) {\n    if( h<precis||t>maxd ) break;\n    h = doModel( ro+rd*t );\n    t += h;\n  }\n\n  if( t<maxd ) res = t;\n  return res;\n}\n\nvec3 calcNormal( in vec3 pos ) {\n  const float eps = 0.002;             // precision of the normal computation\n\n  const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n  const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n  const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n  const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n  return normalize(\n    v1*doModel( pos + v1*eps ) + \n    v2*doModel( pos + v2*eps ) + \n    v3*doModel( pos + v3*eps ) + \n    v4*doModel( pos + v4*eps ) );\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd ) {\n  float res = 1.0;\n  float t = 0.0005;                 // selfintersection avoidance distance\n  float h = 1.0;\n  for( int i=0; i<40; i++ ) {\n    h = doModel(ro + rd*t);\n    res = min( res, 64.0*h/t );   // 64 is the hardness of the shadows\n    t += clamp( h, 0.02, 2.0 );   // limit the max and min stepping distances\n  }\n  return clamp(res,0.0,1.0);\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll ) {\n  vec3 ww = normalize( ta - ro );\n  vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n  vec3 vv = normalize( cross(uu,ww));\n  return mat3( uu, vv, ww );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 p = (-iResolution.xy + 2.0*gl_FragCoord.xy)/iResolution.y;\n  vec2 m = iMouse.xy/iResolution.xy;\n\n  //-----------------------------------------------------\n  // camera\n  //-----------------------------------------------------\n  \n  // camera movement\n  vec3 ro, ta;\n  doCamera( ro, ta, iTime, m.x );\n\n  // camera matrix\n  mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n  // create view ray\n  vec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n  //-----------------------------------------------------\n  // render\n  //-----------------------------------------------------\n\n  vec3 col = doBackground();\n\n  // raymarch\n  float t = calcIntersection( ro, rd );\n  if( t>-0.5 )\n  {\n    // geometry\n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal(pos);\n\n    // materials\n    vec3 mal = doMaterial( pos, nor );\n\n    col = mix(col, doLighting( pos, nor, rd, t, mal ), 1. - fogFactorExp2_4_9(t, 0.1));\n  }\n\n  //-----------------------------------------------------\n  // postprocessing\n  //-----------------------------------------------------\n  col = pow( clamp(col,0.0,1.0), vec3(0.785) );\n  col.r = smoothstep(-0.2, 0.9, col.r);\n  col.g = smoothstep(-0.1, 0.8, col.g);\n  col += dot(p, p * 0.04) * vec3(-1.);\n  //col *= mix(0.9, 1.2, grain(p / 2.5, vec2(250.), iTime*10.));\n     \n  fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtBGzz.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 392, 417, 417, 466], [468, 468, 495, 495, 544], [546, 546, 572, 572, 616], [618, 618, 646, 646, 690], [692, 692, 724, 724, 776], [778, 778, 812, 812, 864], [866, 866, 902, 902, 1164], [1166, 1240, 1268, 1268, 3829], [3833, 3833, 3876, 3876, 3975], [3979, 3979, 4094, 4094, 4246], [4249, 4249, 4380, 4380, 4863], [4866, 4866, 4936, 4936, 5050], [5054, 5499, 5525, 5525, 5574], [5576, 5576, 5602, 5602, 5651], [5653, 5653, 5680, 5680, 5722], [5724, 5724, 5757, 5757, 5809], [5811, 5811, 5835, 5835, 5875], [5877, 5919, 5956, 5956, 8330], [8334, 8726, 8752, 8752, 8801], [8803, 8803, 8829, 8829, 8878], [8880, 8880, 8907, 8907, 8952], [8954, 8954, 8987, 8987, 9039], [9041, 9041, 9070, 9070, 11316], [11321, 11321, 11402, 11402, 11620], [11622, 11622, 11685, 11685, 11744], [11746, 11746, 11796, 11796, 11848], [11852, 12184, 12267, 12267, 12383], [12386, 12617, 12644, 12644, 12676], [12682, 12964, 12989, 12989, 13330], [13332, 13685, 13730, 13730, 13763], [13765, 13976, 14060, 14060, 14959], [14961, 14961, 15011, 15011, 15351], [15353, 15353, 15385, 15385, 15783], [15785, 15785, 15833, 15833, 16186], [16188, 16188, 16252, 16252, 16422], [16424, 16424, 16479, 16479, 17848]], "test": "untested"}
{"id": "MtfGDf", "name": "raymarching german 2", "author": "germangb", "description": "experiment #2\n\nsoft shadows\nhttp://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm", "tags": ["raymarching"], "likes": 5, "viewed": 226, "published": "Public", "date": "1425733911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI2 6.28318530718\n\nfloat smin( float a, float b, float k ) {\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nmat2 rotate (float angle) {\n \treturn mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));   \n}\n\n\nfloat cilinder (vec3 p) {\n    p.y -= 1.0;\n\treturn length(p.xy) - 1.25;   \n}\n\nfloat sphere (vec3 p) {\n    return length(p) - 7.0;\n}\n\nvec2 scene (vec3 p) {\n    float m = 9999.0;\n    for (int i = 0; i < 6; ++i) {\n        vec3 pos = p;\n        pos.y += cos(pos.x * 0.25 + iTime*4.0) * 2.0;\n        pos.y -= 8.0 * exp(-dot(pos.xz, pos.xz) * 0.0125);\n        pos.x += sin(pos.z * 0.25 + iTime*4.0) * 2.0;\n        pos.xz = pos.xz * rotate(float(i)*PI2/6.0);\n     \tm = min(m, cilinder(pos));   \n    }\n    \n    float s = sphere(p-vec3(0.0, 9.0, 0.0));\n    float blend = smin(m, s, 0.25);\n    \n    float plane = p.y+7.0;\n    \n    vec2 ret = vec2(min(blend, plane), blend > plane ? 1.0 : 0.0);\n    \n \treturn ret;   \n}\n\nvec3 normal (vec3 p) {\n \tvec2 eps = vec2(0.001, 0.0);\n    return normalize(vec3(\n    \tscene(p + eps.xyy).x - scene(p - eps.xyy).x,\n        scene(p + eps.yxy).x - scene(p - eps.yxy).x,\n        scene(p + eps.yyx).x - scene(p - eps.yyx).x\n    ));\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv*2.0-1.0;\n \tuv.x *= iResolution.x / iResolution.y;\n    \n    vec3 color = vec3(0.0);\n    \n    vec3 ro = vec3(uv, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    \n    ro.y = 12.0;\n    float r = 24.0 + 8.0*sin(iTime);\n    ro.z = -r * cos(iTime * 0.25);\n    ro.x = -r * sin(iTime * 0.25);\n    rd.xz *= rotate(-iTime * 0.25);\n    \n    float h = 0.0;\n    float last = 9999.0;\n    for (int i = 0; i < 100; ++i) {\n    \tif (h > 1000.0) break;\n        vec3 p = ro + h * rd;\n        vec2 dist = scene(p);\n        if (dist.x < 0.5) {\n         \t last = dist.x;  \n        } else {\n            if (last < 0.5) {\n                color = vec3(0.0, 0.0, 0.0);\n                break;\n            } else last = 9999.0;\n        }\n        h += max(0.01, dist.x);\n        \n        if (dist.x < 0.001) {\n            vec3 n = normal(p);\n            float sun = clamp(dot(n, vec3(0.0, 1.0, 0.0)), 0.0, 1.0);\n            float fog = exp(-length(ro-p) * 0.0125);\n            color = vec3(1.0);\n            if (dist.y > 0.5) {\n                    color = vec3(1.0);//texture(iChannel1, p.xz*0.025).rgb;\n                \t// hard shadow\n                \tfloat sh = 0.1;\n                \tfloat shadow = 1.0;\n               \t \tfor (int i = 0; i < 32; ++i) {\n    \t\t\t\t\tif (sh > 16.0) break;\n                        vec3 pp = p + sh*vec3(0.0, 1.0, 0.0);\n                        float sc = scene(pp).x;\n                        sh += max(0.01, sc);\n                        if (sc < 0.0001) {\n                            shadow = 0.0;\n                            break;\n                        } else {\n                         \tshadow = min(2.0*sc/sh, shadow);   \n                        }\n                    }\n                color*=mix(0.05, 1.0, shadow);\n                \n             \t   /*color += rand(floor(p.xz * 0.125)) * 0.25;\n             \t   color += rand(floor(p.xz * 0.25)) * 0.25;\n             \t   color += rand(floor(p.xz * 0.5)) * 0.25;\n             \t   color += rand(floor(p.xz)) * 0.25;*/\n            } else {\n                color = vec3(1.0);//texture(iChannel0, p.xz * 0.01).rgb;//vec3(1.0, 0.7, 0.28);\n             \tfloat spec = pow(clamp(dot(n, normalize(ro-p)), 0.5, 1.0), 8.0);\n                //color += spec*4.0;\n            }\n            color *= mix(0.125, 1.0, sun) * fog;\n         \tbreak;   \n        }\n    }\n    \n\tfragColor = vec4(pow(color, vec3(1.0/1.678)), 1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtfGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 68, 68, 139], [141, 141, 168, 168, 253], [256, 256, 281, 281, 331], [333, 333, 356, 356, 386], [388, 388, 409, 409, 962], [964, 964, 986, 986, 1209], [1211, 1211, 1231, 1231, 1303], [1305, 1305, 1362, 1362, 3780]], "test": "untested"}
{"id": "Mtj3Rh", "name": "Xor - Triangles", "author": "Xor", "description": "2D procedural infinite scrolling triangles.", "tags": ["procedural", "2d", "triangles"], "likes": 20, "viewed": 551, "published": "Public", "date": "1426960512", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float r(float n)\n{\n \treturn fract(abs(sin(n*55.753)*367.34));   \n}\nfloat r(vec2 n)\n{\n    return r(dot(n,vec2(2.46,-1.21)));\n}\nfloat cycle(float n)\n{\n \treturn cos(fract(n)*2.0*3.141592653)*0.5+0.5;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float a = (radians(60.0));\n    float zoom = 96.0;\n\tvec2 c = (fragCoord.xy+vec2(iTime*zoom,0.0))*vec2(sin(a),1.0);\n    c = ((c+vec2(c.y,0.0)*cos(a))/zoom)+vec2(floor(4.*(c.x-c.y*cos(a))/zoom),0.0);\n    float n = cycle(r(floor(c*4.0))*0.2+r(floor(c*2.0))*0.3+r(floor(c))*0.5+iTime*0.125);\n\tfragColor = vec4(n*2.0,pow(n,2.0),0.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtj3Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 66], [67, 67, 84, 84, 125], [126, 126, 148, 148, 198], [199, 199, 256, 256, 594]], "test": "untested"}
{"id": "Mtj3z1", "name": "Simple Raytracing Example", "author": "seabre", "description": "Just me going through this video with Inigo (iq) livecoding a raytracer and me porting to shadertoy as I followed along: https://www.youtube.com/watch?v=9g8CdctxmeU", "tags": ["raytracing", "sphere", "iq"], "likes": 5, "viewed": 374, "published": "Public", "date": "1427064739", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 nSphere(in vec3 pos, in vec4 sph) {\n    return (pos - sph.xyz) / sph.w;\n}\n\nvec3 nPlane(in vec3 pos) {\n    return vec3(0.0, 1.0, 0.0);\n}\n\nfloat iSphere(in vec3 ro, in vec3 rd, in vec4 sph) {\n    /*\n      So a sphere centered at the origin has an equation |xyz| = r\n      meaning |xyz| ^ 2 = r^2 , meaning <xyz, xyz> = r^2\n      now xyz = ro + t * rd, therefore |ro| ^ 2 + t^2 + 2<ro, rd>t - r ^ 2 = 0\n    */\n    vec3 oc = ro - sph.xyz;\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sph.w * sph.w;\n    float h = b * b - 4.0  * c;\n    if (h < 0.0) return -1.0;\n    float t = (-b - sqrt(h)) / 2.0;\n    return t;\n}\n\nvec4 sph1 = vec4(0.0, 1.0, 0.0, 1.0);\nfloat iPlane(in vec3 ro, in vec3 rd) {\n    // equation of a plane, y = 0 = ro.y + t * rd.y\n    return -ro.y/rd.y;\n}\n\nfloat intersect(in vec3 ro, in vec3 rd, out float resT) {\n    resT = 1000.0;\n    float id = -1.0;\n    float tsph = iSphere(ro, rd, sph1); // intersect with a sphere\n    float tpla = iPlane(ro, rd); //intersect with a plane\n    if (tsph > 1.0) {\n        id = 1.0;\n        resT = tsph;\n    }\n    \n    if (tpla > 0.0 && tpla < resT) {\n      id = 2.0;\n      resT = tpla;\n    }\n    return id;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 light = normalize(vec3(0.57703));\n    // uv are the pixel coordinates from 0 to 1\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    sph1.x = 0.5 * cos(iTime);\n    sph1.z = 0.5 * sin(iTime);\n    \n    // we generate a ray with origin ro and direction rd\n    vec3 ro = vec3(0.0, 0.5, 3.0);\n    vec3 rd = normalize(vec3((-1.0 + 2.0 * uv) * vec2(1.78, 1.0), -1.0));\n    \n    // we intersect the ray with the 3d scene\n    float t;\n    float id = intersect(ro, rd, t);\n    \n    // We need to do some lighting\n    // and for that we need normals\n    \n    vec3 col = vec3(0.7);\n    \n    if (id > 0.5 && id < 1.5) {\n      // if we hit the sphere\n      vec3 pos = ro + t * rd;\n      vec3 nor = nSphere(pos, sph1); \n      float dif = clamp(dot(nor, light), 0.0, 1.0);\n      float ao = 0.5 + 0.5  * nor.y;\n      col = vec3(0.9, 0.8, 0.6) * dif * ao + vec3(0.1, 0.2, 0.4) * ao;\n    } else if (id > 1.5) {\n        // we hit the plane\n        vec3 pos = ro + t * rd;\n        vec3 nor = nPlane(pos);\n        float dif = clamp(dot(nor, light), 0.0, 1.0);\n        float amb = smoothstep(0.0, 2.0 * sph1.w, length(pos.xz - sph1.xz));\n        col = vec3(amb * 0.7);\n    \n    }\n    \n    col = sqrt(col);\n    \n\tfragColor = vec4(col, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtj3z1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 78], [80, 80, 106, 106, 140], [142, 142, 194, 411, 629], [669, 669, 707, 759, 784], [786, 786, 843, 843, 1175], [1177, 1177, 1234, 1234, 2467]], "test": "untested"}
{"id": "Mtl3WX", "name": "Mixing Lights", "author": "felixisdev", "description": "lots of lights mixing together", "tags": ["light"], "likes": 5, "viewed": 159, "published": "Public", "date": "1425836844", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sine(float value)\n{\n    return (sin(value) + 1.0) / 2.0;\n}\n\nconst int amount = 8;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 mix = vec3(0.0, 0.0, 0.0);\n    \n    for (int i = 0; i < amount; i++)\n    {\n        float lx = sin(iTime * 1.43 + float(i) * 5.43) * 665.0;\n        float ly = sin(iTime * 1.76 + float(i) * 7.34) * 454.0;\n        float lgx = iResolution.x / 2.0 - fragCoord.x - lx;\n        float lgy = iResolution.y / 2.0 - fragCoord.y - ly;\n        float mul = (1.0 - (lgx * lgx + lgy * lgy) / (100000.0 + sin(iTime * 0.35 + float(i) * 324.0) * 40000.0));\n        if (mul > 0.0) mix += vec3(sine(float(i) * 2.43 + 0.42), sine(float(i) * 4.24 + 1.54), sine(float(i) * 5.82 + 1.43)) * mul;\n    }\n    \n    fragColor = vec4(mix, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mtl3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 64], [89, 89, 146, 146, 817]], "test": "untested"}
{"id": "MtlGDs", "name": "Mandel Deep Zoom - Double P", "author": "Razaekel", "description": "Attempted Deep Zoom into the Mandelbrot set with emulated double precision.\n\nSingle Precision version: https://www.shadertoy.com/view/MlsGWs", "tags": ["procedural", "2d", "mandelbrot", "deepzoom"], "likes": 2, "viewed": 279, "published": "Public", "date": "1426388780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by nick whitney - nwhit/2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Uses Double Precision floats, so it should develop errors after zoom level ~42. \n// Seems to have the same issue with float precision as the Single P version, however.\n// I don't know if this is because of WebGL or Nvidia cards or something else.\n\n// I would use a ds_div function instead of the (1. / var), but the ds_div function causes\n// an error but no error messages show up.\n\n// Attemping to stop NVidia cards from reverting to singleP\n#pragma optionNV(fastmath off)\n#pragma optionNV(fastprecision off)\n\n/////////////////////////////////\n// Zoom Centers\n/////////////////////////////////\nconst vec2 fillErUp = vec2(0.3585614710926859372,\n                           0.3229491840959411351);\n\nconst vec2 sunflowers = vec2(-1.985540371654130485531439267191269851811165434636382820704394766801377,\n                             0.000000000000000000000000000001565120217211466101983496092509512479178);\n\nconst vec2 sunflowersX = vec2(-1.9855403900146484375,\n                              0.000000018360517951968560732808730148188834565363617179);\n\nconst vec2 sunflowersY = vec2(0.000000000000000000000000000001565120228882564491389030362389781052341234098969,\n                              0.);\n#define FILLERUP\n//#define SUNFLOWERS\n\n/////////////////////////////////\n// General Constants\n/////////////////////////////////\nconst int maxIterations = 4000;\nconst float zoomSpeed = .35;\nconst float radius = 20.;\n\n/////////////////////////////////\n// Emulation based on Fortran-90 double-single package. See http://crd.lbl.gov/~dhbailey/mpdist/\n\n// Add: res = ds_add(a, b) => res = a + b\nvec2 ds_add(vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float t1, t2, e;\n\n    t1 = dsa.x + dsb.x;\n    e = t1 - dsa.x;\n    t2 = ((dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y + dsb.y;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n    return dsc;\n}\n\n// Subtract: res = ds_sub(a, b) => res = a - b\nvec2 ds_sub(vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float e, t1, t2;\n\n    t1 = dsa.x - dsb.x;\n    e = t1 - dsa.x;\n    t2 = ((-dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y - dsb.y;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n    return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat ds_compare(vec2 dsa, vec2 dsb)\n{\n    if (dsa.x < dsb.x) return -1.;\n    else if (dsa.x == dsb.x) \n    {\n        if (dsa.y < dsb.y) return -1.;\n        else if (dsa.y == dsb.y) return 0.;\n        else return 1.;\n    }\n    else return 1.;\n}\n\n// Multiply: res = ds_mul(a, b) => res = a * b\nvec2 ds_mul(vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float c11, c21, c2, e, t1, t2;\n    float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n    cona = dsa.x * split;\n    conb = dsb.x * split;\n    a1 = cona - (cona - dsa.x);\n    b1 = conb - (conb - dsb.x);\n    a2 = dsa.x - a1;\n    b2 = dsb.x - b1;\n\n    c11 = dsa.x * dsb.x;\n    c21 = a2 * b2 + (a2 * b1 + (a1 * b2 + (a1 * b1 - c11)));\n\n    c2 = dsa.x * dsb.y + dsa.y * dsb.x;\n\n    t1 = c11 + c2;\n    e = t1 - c11;\n    t2 = dsa.y * dsb.y + ((c2 - e) + (c11 - (t1 - e))) + c21;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n\n    return dsc;\n}\n\n// create double-single number from float\nvec2 ds_set(float a)\n{\n    vec2 z;\n    z.x = a;\n    z.y = 0.0;\n    return z;\n}\n\n// End Double-Single Emulation Section\n//////////////////////////////////////\n\n//////////////////////////////////////\n// Begin Main Section\n//////////////////////////////////////\n// Calculate and return the iteration depth for the current pixel\nfloat ds_Mandelbrot(vec2 px, vec2 py, vec2 cx1, vec2 cy1, float zoom)\n{       \n    //calculate the initial real and imaginary part of z, based on the pixel location and zoom and position values        \n    vec2 ds_invZoom = ds_set(1. / zoom);\n    \n    vec2 cx = ds_add(ds_mul(px, ds_invZoom), cx1);\n    vec2 cy = ds_add(ds_mul(py, ds_invZoom), cy1);\n    \n    vec2 zx = cx;\n    vec2 zy = cy;\n    \n    vec2 ds_two = ds_set(2.);\n    \n    vec2 ds_radius = ds_set(radius * radius);\n      \n    //start the iteration process\n    for(int i = 0; i < maxIterations; i++)\n    {     \n        vec2 oldzx = zx;\n        zx = ds_add(ds_sub(ds_mul(zx, zx), ds_mul(zy, zy)), cx);\n    \tzy = ds_add(ds_mul(ds_two, ds_mul(oldzx, zy)), cy);\n        \n        if(ds_compare(ds_add(ds_mul(zx, zx), ds_mul(zy, zy)), ds_radius) > 0.) \n        {\n            //float modulus = sqrt(z.x*z.x + z.y*z.y);\n            \n            //return(float(i) + 1. - log(log(modulus)) / log(2.));\n            return float(i);\n        }\n    }    \n    \n    return 0.;\n}\n\n// generates a color based on the iteration depth\nvec3 stepColor(float iter)\n{   \n    //vec3 color = vec3(mod(iter, 255.), sin(iter), cos(iter));\n    \n    vec3 color = vec3((-cos(0.025*float(iter))+1.0)/2.0,\n                      (-cos(0.08*float(iter))+1.0)/2.0,\n                      (-cos(0.12*float(iter))+1.0)/2.0);\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 one = ds_set(1.0);\n    vec2 two = ds_set(2.0);\n    \n    //vec2 p = 2.0 * fragCoord.xy / iResolution - 1.;\n\n    vec2 p = fragCoord.xy / iResolution.xy;\n        \n    vec2 px = ds_sub(ds_mul(two, ds_set(p.x)), one);\n    vec2 py = ds_sub(ds_mul(two, ds_set(p.y)), one);\n    \n    float ratio = iResolution.x/iResolution.y;\n    vec2 ds_ratio = ds_set(ratio);\n    \n    px = ds_mul(px, ds_ratio);\n\n    // animation\t\n    float zoom = pow( 0.5, -zoomSpeed * mod(iTime, 30. / zoomSpeed) );\n    \n    vec2 invRes = vec2(1.0) / iResolution.xy;\n    vec2 iResX = ds_set(iResolution.x);\n    vec2 iResY = ds_set(iResolution.y);\n    \n    #ifdef FILLERUP\n    vec2 cx = ds_set(fillErUp.x);\n    vec2 cy = ds_set(fillErUp.y);\n    #else\n    vec2 cx = sunflowersX;\n    vec2 cy = sunflowersY;\n    #endif\n    \n    float iter = float(ds_Mandelbrot(px, py, cx, cy, zoom));\n    \n    vec3 col = stepColor(iter);\n    \n   \tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlGDs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1674, 1716, 1749, 1749, 1961], [1963, 2010, 2043, 2043, 2256], [2258, 2347, 2385, 2385, 2591], [2593, 2640, 2673, 2673, 3234], [3236, 3278, 3300, 3300, 3356], [3437, 3603, 3674, 3804, 4626], [4628, 4678, 4706, 4773, 4973], [4975, 4975, 5032, 5032, 5967]], "test": "untested"}
{"id": "MtlGWs", "name": "test and learn", "author": "thu_yumeng", "description": "test and learn", "tags": ["thankstothecrossshaderjustcopyofothersworkandatest"], "likes": 0, "viewed": 182, "published": "Public", "date": "1426301323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* \nIf you think this shader is an useful example, \nplease like it :-)\n\nreference:\nhttps://www.shadertoy.com/view/Mdl3Rr\n\nchange log:\n- 2013-04-10 initial release\n*/\n\n#define LIGHT_ANIMATION\n#define LOW_QUALITY\t\t// uncomment this if this shader runs too slow on your PC\n//#define ULTRA_QUALITY \t// uncomment this if you have a really fast GPU :-)\n//#define SMOKE\t\t\t\t// comment this if you think the smoke effect is too annoying\n\nstruct Ray\n{\n\tvec3 org;\n\tvec3 dir;\n};\n\t\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\nfloat udRoundBox( in vec3 p, in vec3 b, in float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( in vec3 p, in vec4 n )\n{\n\t// n must be normalized\n\treturn dot( p, n.xyz ) + n.w;\n}\n\nfloat sdSphere(vec3 p,float s)\n{\n    return length(p) - s;\n}\n\nfloat sdCapsule(vec3 p ,vec3 a,vec3 b,float r)\n{\n    vec3 pa = p - a,ba = b-a;\n    float h = clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);\n    return length(pa -ba*h) - r;\n}\n\nfloat opU( in float d1, in float d2 )\n{\n\treturn min(d1,d2);\n}\n\nvec3 translate( in vec3 v, in vec3 t )\n{\n\treturn v - t;\n}\n\nfloat scene( in vec3 pos )\n{\n\tvec4 plane = vec4( 0.0, 0.1, 0.0, 0.0 ); // xyz, d\n\t\n\tvec4 boxd1 = vec4( 0.5, 3.5, 0.5, 0.25 ); // sxyz, r\n\tvec4 boxp1 = vec4( 0.0, 2.5, 3.0, 0.0 ); // xyz, 0\n\tboxd1.xyz -= boxd1.w;\n\t\n\tvec4 boxd2 = vec4( 3.0, 0.5, 0.5, 0.25 ); // sxyz, r\n\tvec4 boxp2 = vec4( 0.0, 4.5, 0.0, 0.0 ); // xyz, 0\n    vec4 ballp2 = vec4(0.0, 4.0,3.0, 0.5);\n\tboxd2.xyz -= boxd2.w;\n\t\n\t\n\tfloat d = 99999.0;\n\t/*\n\td = opU( d, udRoundBox( translate( pos, boxp1.xyz ), boxd1.xyz, boxd1.w ) );\n\td = opU( d, udRoundBox( translate( pos, boxp2.xyz ), boxd2.xyz, boxd2.w ) );\n\td = opU( d, sdPlane( pos, plane ) );\n\t*/\n    d = opU(d, sdSphere( translate(pos,boxp1.xyz), 1.25));\n    d = opU(d ,sdSphere( translate(pos,ballp2.xyz),0.5));\n    \n    vec3 p = vec3(3.5,3.5,2.0);\n    vec3 a = vec3(2.0,3.5,2.0);\n    vec3 b = vec3(2.5,3.6,2.0);\n    float r = .5;\n    d  = opU(d, sdCapsule(pos,a,b,r));\n    \n    a = vec3(-2.0,3.5,2.0);\n    b = vec3(-2.5,3.6,2.0);\n    d = opU(d, sdCapsule(pos,a,b,r));\n    d = opU(d, sdPlane( pos, plane));\n\treturn d;\n}\n\nvec3 sceneNormal( in vec3 pos )\n{\n    vec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor;\n\tnor.x = scene( pos + eps.xyy ) - scene( pos - eps.xyy );\n\tnor.y = scene( pos + eps.yxy ) - scene( pos - eps.yxy );\n\tnor.z = scene( pos + eps.yyx ) - scene( pos - eps.yyx );\n\treturn normalize( nor );\n}\n\nbool raymarch( in Ray ray, in int maxSteps, out vec3 hitPos, out vec3 hitNrm )\n{\n\tconst float hitThreshold = 0.0001;\n\n\tbool hit = false;\n\thitPos = ray.org;\n\n\tvec3 pos = ray.org;\n\n\tfor ( int i = 0; i < 256; i++ )\n\t{\n\t\tif ( i >= maxSteps )\n\t\t\tbreak;\n\t\tfloat d = scene( pos );\n\n\t\tif ( d < hitThreshold )\n\t\t{\n\t\t\thit = true;\n\t\t\thitPos = pos;\n\t\t\thitNrm = sceneNormal( pos );\n\t\t\tbreak;\n\t\t}\n\t\tpos += d * ray.dir;\n\t}\n\treturn hit;\n}\n\n#ifdef LOW_QUALITY\n#define INSCATTER_STEPS 24\n#else\n#\tifdef ULTRA_QUALITY\n#define INSCATTER_STEPS 64\n#\telse\n#define INSCATTER_STEPS 48\n#\tendif\n#endif\n\n\nfloat raySphereIntersect( in vec3 ro, in vec3 rd, in vec4 sph )\n{\n\tvec3 oc = ro - sph.xyz; // looks like we are going place sphere from an offset from ray origin, which is = camera\n\tfloat b = 2.0 * dot( oc, rd );\n\tfloat c = dot( oc, oc ) -  sph.w * sph.w; // w should be size\n\tfloat h = b * b - 4.0 * c;\n\tif ( h < 0.0 )\n\t{\n\t\treturn -10000.0;\n\t}\n\tfloat t = (-b - sqrt(h)) / 2.0;\n\t\n\treturn t;\n}\n\nvec3 inscatter( in Ray rayEye, in vec4 light, in vec3 screenPos, in float sceneTraceDepth )\n{\n\tvec3 rayEeyeNDir = normalize( rayEye.dir );\n\t\n\t// the eye ray does not intersect with the light, so skip computing\n\tif ( raySphereIntersect( rayEye.org, rayEeyeNDir, light ) < -9999.0 )\n\t\treturn vec3( 0.0 );\n\t\n\tfloat scatter = 0.0;\n\tfloat invStepSize = 1.0 / float( INSCATTER_STEPS );\n\t\n\tvec3 hitPos, hitNrm;\n\tvec3 p = rayEye.org;\n\tvec3 dp = rayEeyeNDir * invStepSize * sceneTraceDepth;\n\t\n\t// apply random offset to minimize banding artifacts.\n\tp += dp * noise( screenPos ) * 1.5;\n\t\n\tfor ( int i = 0; i < INSCATTER_STEPS; ++i )\n\t{\n\t\tp += dp;\n\t\t\n\t\tRay rayLgt;\n\t\trayLgt.org = p;\n\t\trayLgt.dir = light.xyz - p;\n\t\tfloat dist2Lgt = length( rayLgt.dir );\n\t\trayLgt.dir /= 8.0;\n\t\t\n\t\tfloat sum = 0.0;\n\t\tif ( !raymarch( rayLgt, 16, hitPos, hitNrm ) )\n\t\t{\n\t\t\t// a simple falloff function base on distance to light\n\t\t\tfloat falloff = 1.0 - pow( clamp( dist2Lgt / light.w, 0.0, 1.0 ), 0.125 );\n\t\t\tsum += falloff;\n\t\t\t\n#ifdef SMOKE\n\t\t\tfloat smoke = noise( 1.25 * ( p + vec3( iTime * 0.5, 0.0, 0.0 ) ) ) * 0.375;\n\t\t\tsum += smoke * falloff;\n#endif\n\t\t}\n\t\t\n\t\tscatter += sum;\n\t}\n\t\n\tscatter *= invStepSize; // normalize the scattering value\n\tscatter *= 8.0; // make it brighter\n\t\n\treturn vec3( scatter );\n}\n\nfloat softshadow( in Ray ray, in float mint, in float maxt, in float k )\n{\n\tfloat t = mint;\n\tfloat res = 1.0;\n    for ( int i = 0; i < 128; ++i )\n    {\n        float h = scene( ray.org + ray.dir * t );\n        if ( h < 0.001 )\n            return 0.0;\n\t\t\n\t\tres = min( res, k * h / t );\n        t += h;\n\t\t\n\t\tif ( t > maxt )\n\t\t\tbreak;\n    }\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 ndcXY = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\tfloat aspectRatio = iResolution.x / iResolution.y;\n\t\n\t// camera XYZ in world space\n\tvec3 camWsXYZ = vec3( 0.0, 3.0, 5.0 );\n\t\n\t// construct the ray in world space\n\tRay ray;\n\tray.org = camWsXYZ;\n\tray.dir = vec3( ndcXY * vec2( aspectRatio, 1.0 ), -1.0 ); // OpenGL is right handed\n\t\n\t// define the point light in world space (XYZ, range)\n\tvec4 lightWs = vec4( 0.0, 4.5, -4.0, 10.0 );\n#ifdef LIGHT_ANIMATION\n\tlightWs.x += sin( iTime * 0.5 ) * 2.0;\n\tlightWs.y += cos( iTime * 0.5 ) * 2.0;\n#endif\n\t\n\tvec3 sceneWsPos;\n\tvec3 sceneWsNrm;\n\t\n\tvec4 c = vec4( 0.0 );\n\t\n\tif ( raymarch( ray, 128, sceneWsPos, sceneWsNrm ) )\n\t{\n\t\t// apply simple depth fog\n\t\tfloat viewZ = sceneWsPos.z - camWsXYZ.z;\n\t\tfloat fog = clamp( ( viewZ + 20.0 ) / 5.0 , 0.0, 1.0 );\n\t\tfog = fog * fog;\n\t\tc.rgb = vec3( 0.125 * fog );\n\t}\n\t\n\t// apply scattering of the\n\tc.rgb += inscatter( ray, lightWs, vec3( fragCoord.xy, 0.0 ), 12.0 );\n\t\n\t// color correction - Sherlock color palette\n\tc.r = smoothstep( 0.0, 1.0, c.r + 0.2);\n\tc.g = smoothstep( 0.0, 1.0, c.g - 0.1 );\n\tc.b = smoothstep(-0.3, 1.3, c.b );\n\t\n\tfragColor = c;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtlGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[270, 469, 491, 491, 527], [529, 529, 554, 554, 890], [892, 892, 946, 946, 985], [987, 987, 1026, 1051, 1084], [1086, 1086, 1118, 1118, 1146], [1148, 1148, 1196, 1196, 1313], [1315, 1315, 1354, 1354, 1376], [1378, 1378, 1418, 1418, 1435], [1437, 1437, 1465, 1465, 2473], [2475, 2475, 2508, 2508, 2761], [2763, 2763, 2843, 2843, 3185], [3339, 3339, 3404, 3404, 3731], [3733, 3733, 3826, 3826, 5012], [5014, 5014, 5088, 5088, 5369], [5371, 5371, 5428, 5428, 6568]], "test": "untested"}
{"id": "Mts3Dl", "name": "line motion blur - shadeADay", "author": "kig", "description": "Simple motion blur, #shadeADay for March 13 2015", "tags": ["2d", "motionblur", "shadeaday"], "likes": 14, "viewed": 386, "published": "Public", "date": "1426298208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MOTION_BLUR\n\nfloat lineSegDist(vec2 uv, vec2 lineDir, vec2 linePoint, float r) {\n    vec2 ba = -lineDir * r;\n    vec2 pa = uv - linePoint + ba;\n    ba *= 2.0;\n    return length(pa - ba*clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0));\n}\n\nfloat aa(float dist, float threshold)\n{\n    float pixelSize = 2.0 / iResolution.y;\n\treturn dist < threshold-pixelSize ? 0.0 : 1.0-(threshold-dist)/pixelSize;\n}\n\nfloat scene(vec2 uv, float t)\n{\n    vec2 p = vec2(sin(t*40.3), cos(t*10.0)*0.4);\n\n    vec2 v = normalize(vec2(sin(t*8.0), cos(t*8.0)));\n\tvec2 p2 = vec2(sin(1.0+t*50.0), cos(0.7+t*24.0)*0.4);\n\n    return clamp(min(\n        aa(length(uv-p), 0.05),\n    \taa(lineSegDist(uv, v, p2, 0.5), 0.05)\n        ), 0.0, 1.0);\n}\n\nfloat hash( vec2 v ) {\n    return texture(iChannel0, v, 0.0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(iResolution.x/iResolution.y, 1.0) * (-1.0 + 2.0*fragCoord.xy / iResolution.xy);\n\t#ifdef MOTION_BLUR\n\t    fragColor = vec4(0.0);\n        for (float i=0.0; i<12.0; i++) {\n            float r = hash(mod(fragCoord+vec2(i,0.0), 64.0) / 64.0);\n            fragColor += (1.0-scene(uv, iTime+(1.0/58.5)*((i+r)/12.0))) * vec4(abs(uv)+0.3,0.5+0.5*sin(20.0*iTime),1.0);\n        }\n        fragColor /= 12.0;\n    #else\n\t\tfragColor = (1.0-scene(uv, iTime)) * vec4(abs(uv)+0.3,0.5+0.5*sin(iTime),1.0);\n    #endif\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mts3Dl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 88, 88, 238], [240, 240, 279, 279, 399], [401, 401, 432, 432, 713], [715, 715, 737, 737, 780], [782, 782, 839, 839, 1355]], "test": "untested"}
{"id": "MtS3Rz", "name": "Bats", "author": "gaz", "description": "3d", "tags": ["raymarching", "de"], "likes": 14, "viewed": 1158, "published": "Public", "date": "1426682802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2\tPI * 2.0\n\n\nmat2 rotate(in float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nfloat hash(in vec3 p){\n\tp  = fract(p * vec3(.16532,.17369,.15787));\n    p += dot(p.xyz, p.yzx + 19.19);\n    return fract(p.x * p.y * p.z);\n}\n\nfloat smin(in float a, in float b, in float k)\n{   \n    float res = exp(-k * a) + exp(-k * b);\n    return -log(res) / k;   \n}\n\nvec2 TE1(in vec2 p)\n{\n\tp.y -= 1.5 * pow(p.x, 2.0) + 0.2;\n    return p;\n}\n\nvec2 TE2(in vec2 p)\n{\n    vec2 q = p;\n    p.x = abs(p.x) - 0.3; \t\n \tp.x += 0.4 * p.y;\n    p.x = abs(p.x - 0.5) - 0.25; \t\n\tp.x += 0.4 * p.y;\n\tp.x = abs(p.x); \t\n    p.y += clamp(3.0 * pow(p.x - 0.2, 2.0), 0.0, 0.5) + 0.1;\n    p.y -= abs(0.2 * q.x);\n    return p;\n}\n\nvec2 TE3(in vec2 p)\n{\n    p.x =abs(p.x);\n    p.x += 0.8 * pow(p.y + 0.2, 2.0);\n    p.x += 0.7 * p.y;\n    p.x -= 1.6;\n    return p;\n}\n\nvec2 TE4(in vec2 p, in float t)\n{\n    t = t * PI2 + iTime * 2.5;\n    p.x -= 0.2 * sin(t) * p.y * p.y;\n    float a = PI / 2.0 + 0.4 * sin(t);\n    p *= rotate(-a + PI / 2.0);\n    vec2 v = vec2(cos(a), sin(a));\n    p -= 2.0 * min(0.0, dot(p, v)) * v;\n    return p;    \n}\n\nfloat DEBat(in vec3 p, in float t)\n{\n    vec2 te1 = TE1(p.xy);\n    vec2 te2 = TE2(p.xy);\n    vec2 te3 = TE3(p.xy);\n    p.zx = TE4(p.zx, t);\n\tfloat de1 = max(abs(p.z) - 0.005, max(te1.y, max(-te2.y, min(1.0, te3.x))));\n    float de2 = min(min(\n       max(te3.x, length(vec2(te1.y, p.z)) - 0.01),\n       max(-te2.y, length(vec2(te2.x, p.z)) - 0.01)),\n       max(te1.y, max(-te2.y, length(vec2(te3.x, p.z)) - 0.01)));   \n    p.y *= 0.7 * pow(p.y, 0.7);\n    p.y -= 0.1;\n    p.y -=  0.15 * smoothstep(0.1, 0.0, length(abs(p.zx) - vec2(0.0, 0.15))) * step(0.0, p.y);       \n    float de3 = length(p) - 0.12;\n    return smin(smin(de1, de2, 30.0), de3, 30.0);\n}\n\nfloat DE(in vec3 p)\n{   \n    p *= 0.8;\n    p.yz *= rotate(iTime * 0.3123);\n    p.zx *= rotate(iTime * 0.5123);\n    p.x += 0.5 * sin(iTime);\n    // Sparse grid (https://www.shadertoy.com/view/XlfGDs)\n    const float c = 4.5;\n\tvec3 ip = floor(p / c);\n    p = mod(p, c) - c / 2.0;\n    float rnd = hash(ip);\n   \tfloat de = 1.0;\n    if (length(ip) - 3.0 < 0.0)\n    if (rnd > 0.6)\n    {\n        p.yz *= rotate(PI * 0.4);\n        de = min(de, DEBat(p, rnd));\n    }\n    return de;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tDE(p + e.xyy) - DE(p - e.xyy),\n\t\tDE(p + e.yxy) - DE(p - e.yxy),\n\t\tDE(p + e.yyx) - DE(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 32.0;\n\tconst float precis = 0.005;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = DE(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p2 = (fragCoord.xy * 2.0 - iResolution.xy) / iResolution.y;\n    //vec3 col = 0.6 * length(p2) * texture(iChannel0, vec2(length(p2), atan(p2.y, p2.x) / PI2) * 2.0).rgb;\n    float d = inversesqrt(length(p2));\n    //vec3 col = 0.5 * d * texture(iChannel0, vec2(d * 2.0, atan(p2.y, p2.x) / PI2) * 2.0).rgb;\n    vec3 col = 0.75 * (2.0 - d) * texture(iChannel0, vec2(d * 2.0, atan(p2.y, p2.x) / PI2) * 2.0).rgb;\n    col = clamp(col, 0.0, 0.6);\n  \tvec3 rd = normalize(vec3(p2, -1.5));\n\tvec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 p3 = ro + t * rd;\n        vec3 n = calcNormal(p3);\n\t\tfloat dif = clamp((dot(n, li) + 0.5) * 0.7, 0.3, 1.0);\n        //col = vec3(0.15) * dif;\n        col = vec3(0.3,0.1,0.1) * dif;\n        col += pow(max(dot(reflect(rd,n),li),0.), 60.);\n \t}\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtS3Rz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 73, 73, 123], [125, 125, 147, 147, 265], [267, 267, 315, 315, 392], [394, 394, 415, 415, 466], [468, 468, 489, 489, 730], [732, 732, 753, 753, 864], [866, 866, 899, 899, 1133], [1135, 1135, 1171, 1171, 1788], [1790, 1790, 1811, 1811, 2264], [2266, 2266, 2294, 2294, 2456], [2458, 2458, 2495, 2495, 2788], [2790, 2790, 2847, 2847, 3752]], "test": "untested"}
{"id": "Mts3Wl", "name": "4D Grid Slice", "author": "TekF", "description": "A 3D slice through a 4D grid. ", "tags": ["4d"], "likes": 26, "viewed": 1479, "published": "Public API", "date": "1426289073", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hazel Quantock 2015\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// https://creativecommons.org/licenses/by-nc-sa/3.0/\n\n// consts\nconst float tau = 6.2831853;\nconst float phi = 1.61803398875;\n\nvec2 Noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec4 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 );\n\treturn mix( rg.yw, rg.xz, f.z );\n}\n\n\n\nvec4 Map( vec3 p3 )\n{\n    // construct an orthonormal frame for the slice\n//\tum... there's no 4D cross product, is there? There can't be! Would need 3 inputs. balls.\n    vec4 i = vec4(1,0,0,0);\n    vec4 j = vec4(0,1,0,0);\n    vec4 k = vec4(0,0,1,0);\n    \n    // rules for rotation should still behave afaik\n    float a,c;\n    vec2 s;\n    a = iTime*.1;\n    c = cos(a); s = vec2(1,-1)*sin(a);\n    i.xz = i.xz*c + i.zx*s;\n    j.xz = j.xz*c + j.zx*s;\n    k.xz = k.xz*c + k.zx*s;\n    i.yw = i.yw*c + i.wy*s;\n    j.yw = j.yw*c + j.wy*s;\n    k.yw = k.yw*c + k.wy*s;\n    i.xw = i.xw*c + i.wx*s;\n    j.xw = j.xw*c + j.wx*s;\n    k.xw = k.xw*c + k.wx*s;\n    i.yz = i.yz*c + i.zy*s;\n    j.yz = j.yz*c + j.zy*s;\n    k.yz = k.yz*c + k.zy*s;\n    \n    // form a basis perp to vec4(1,1,1,1)\n//    actually easier than it sounds, just make it so dot prods sum to 0\n/*    vec4 i = vec4(1,1,-1,-1)/2.0;\n    vec4 j = vec4(-1,1,-1,1)/2.0;\n    vec4 k = vec4(1,-1,-1,1)/2.0;*/\n    \n    //vec4 p = vec4(p3,0);\n    vec4 p = i*p3.x + j*p3.y + k*p3.z;// + vec4(1,1,1,1)*.5*.25;\n\n    return p;\n}\n    \nfloat DistanceField( vec3 p3 )\n{\n    vec4 p = Map(p3);\n    \n    // offset to centre of cell\n    float f = 100.0;\n    \n    // cells\n    vec4 o = .5 - abs(fract(p+.5)-.5);\n    f = min(f, .2 - min(min(min(o.x, o.y), o.z), o.w ) );\n        \n\t// or grid edges (is this meaningful? - apparently, yes)\n    f = min(f, min(min(min(min(min(length(o.xy),length(o.xz)),length(o.xw)),length(o.yz)),length(o.yw)),length(o.zw)) - .03);\n    \n    p = abs(p);\n    return max( f, max(max(max(p.x,p.y),p.z),p.w)-1.53 );\n}\n\n\n\n\nvec3 Sky( vec3 ray )\n{\n\treturn mix( vec3(.8), vec3(0), exp2(-(1.0/max(ray.y,.01))*vec3(.4,.6,1.0)) );\n}\n\n\nvec3 Shade( vec3 pos, vec3 ray, vec3 normal, vec3 lightDir, vec3 lightCol, float shadowMask, float distance )\n{\n    vec4 p = Map(pos);\n\n    vec4 c = (p+1.5)/3.0;\n    //vec3 albedo = (c.xyz);// + c.www)*.5;//vec3(.25);\n//    vec3 albedo = vec3(.75,0,0)*c.x + vec3(.25,.5,0)*c.y + vec3(0,.5,.25)*c.z + vec3(0,0,.75)*c.w;\n    \n    vec4 o = .5 - abs(fract(p+.5)-.5);\n    vec3 albedo = mix( vec3(1,0,0), vec3(1), step(.1,min(min(min(o.x, o.y), o.z), o.w )) );\n\n\n\t// direct light\n\tfloat ndotl = max(.0,dot(normal,lightDir));\n\tfloat lightCut = smoothstep(.0,.1,ndotl);//pow(ndotl,2.0);\n\tvec3 light = lightCol*shadowMask*ndotl;\n\n\n\t// ambient light\n\tvec3 ambient = mix( vec3(.2,.27,.4), vec3(.4), (-normal.y*.5+.5) ); // ambient\n\n\t// ambient occlusion, based on my DF Lighting: https://www.shadertoy.com/view/XdBGW3\n\tfloat aoRange = distance/20.0;\n\tfloat occlusion = max( 0.0, 1.0 - DistanceField( pos + normal*aoRange )/aoRange ); // can be > 1.0\n\tocclusion = exp2( -2.0*pow(occlusion,2.0) ); // tweak the curve\n\tambient *= occlusion;\n\n\n\t// subsurface scattering\n\tfloat transmissionRange = 0.1;\n\tfloat transmission = DistanceField( pos + lightDir*transmissionRange )/transmissionRange;\n\tvec3 sslight = lightCol * smoothstep(0.0,1.0,transmission);\n\tvec3 subsurface = vec3(1,.8,.5) * sslight;\n\n\n\t// specular\n\tfloat specPower = 400.0;\n\t\n\tvec3 h = normalize(lightDir-ray);\n    float specFres = mix( .02, 1.0, pow( 1.0 - dot(h,lightDir), 5.0 ) );\n\tvec3 specular = lightCol*shadowMask*pow(max(.0,dot(normal,h))*lightCut, specPower)*specFres*(specPower+6.0)/32.0;\n\t\n\n\t// reflections\n\tvec3 rray = reflect(ray,normal);\n\tvec3 reflection = Sky( rray );\n\t\n\t// reflection occlusion, adjust the divisor for the gradient we expect\n\tfloat specOcclusion = max( 0.0, 1.0 - DistanceField( pos + rray*aoRange )/(aoRange*max(.01,dot(rray,normal))) ); // can be > 1.0\n\tspecOcclusion = exp2( -2.0*pow(specOcclusion,2.0) ); // tweak the curve\n\t\n\t// prevent sparkles in heavily occluded areas\n\tspecOcclusion *= occlusion;\n\n\treflection *= specOcclusion; // could fire an additional ray for more accurate results\n\t\n\t// fresnel\n\tfloat fresnel = pow( 1.0+dot(normal,ray), 5.0 );\n\tfresnel = mix( .02, 1.0, fresnel );\n\t\n\tvec3 result = vec3(0);\n\n\t\n\t// Combine all shading stages\n\t// comment these out to toggle various parts of the effect\n\tlight += ambient;\n\n//\tlight = mix( light, subsurface, .5 );\n\t\n\tresult = light*albedo;\n\n//\tresult = mix( result, reflection, fresnel );\n\t\n\tresult += specular;\n\n\treturn result;\n}\n\n\n\n\n// Isosurface Renderer\n#ifdef FAST\nconst int traceLimit=40;\nconst float traceSize=.005;\n#else\nconst int traceLimit=100;\nconst float traceSize=.001;//before *t: .002;\n#endif\t\n\nfloat Trace( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tif ( h < traceSize*t || t > traceEnd )\n\t\t\tbreak;\n\t\tt = t+h;\n\t}\n\t\n\tif ( t > traceEnd )//|| h > .001 )\n\t\treturn 0.0;\n\t\n\treturn t;\n}\n\nfloat TraceMin( vec3 pos, vec3 ray, float traceStart, float traceEnd )\n{\n\tfloat Min = traceEnd;\n\tfloat t = traceStart;\n\tfloat h;\n\tfor( int i=0; i < traceLimit; i++ )\n\t{\n\t\th = DistanceField( pos+t*ray );\n\t\tif ( h < .001 || t > traceEnd )\n\t\t\tbreak;\n\t\tMin = min(h,Min);\n\t\tt = t+max(h,.1);\n\t}\n\t\n\tif ( h < .001 )\n\t\treturn 0.0;\n\t\n\treturn Min;\n}\n\nvec3 Normal( vec3 pos, vec3 ray, float t )\n{\n\t// in theory we should be able to get a good gradient using just 4 points\n\n\tfloat pitch = .2 * t / iResolution.x;\n#ifdef FAST\n\t// don't sample smaller than the interpolation errors in Noise()\n\tpitch = max( pitch, .005 );\n#endif\n\t\n\tvec2 d = vec2(-1,1) * pitch;\n\n\tvec3 p0 = pos+d.xxx; // tetrahedral offsets\n\tvec3 p1 = pos+d.xyy;\n\tvec3 p2 = pos+d.yxy;\n\tvec3 p3 = pos+d.yyx;\n\t\n\tfloat f0 = DistanceField(p0);\n\tfloat f1 = DistanceField(p1);\n\tfloat f2 = DistanceField(p2);\n\tfloat f3 = DistanceField(p3);\n\t\n\tvec3 grad = p0*f0+p1*f1+p2*f2+p3*f3 - pos*(f0+f1+f2+f3);\n\t\n\t// prevent normals pointing away from camera (caused by precision errors)\n\tfloat gdr = dot ( grad, ray );\n\tgrad -= max(.0,gdr)*ray;\n\t\n\treturn normalize(grad);\n}\n\n\n// Camera\n\nvec3 Ray( float zoom, vec2 fragCoord )\n{\n\treturn vec3( fragCoord.xy-iResolution.xy*.5, iResolution.x*zoom );\n}\n\nvec3 Rotate( inout vec3 v, vec2 a )\n{\n\tvec4 cs = vec4( cos(a.x), sin(a.x), cos(a.y), sin(a.y) );\n\t\n\tv.yz = v.yz*cs.x+v.zy*cs.y*vec2(-1,1);\n\tv.xz = v.xz*cs.z+v.zx*cs.w*vec2(1,-1);\n\t\n\tvec3 p;\n\tp.xz = vec2( -cs.w, -cs.z )*cs.x;\n\tp.y = cs.y;\n\t\n\treturn p;\n}\n\n\n// Camera Effects\n\nvoid BarrelDistortion( inout vec3 ray, float degree )\n{\n\t// would love to get some disperson on this, but that means more rays\n\tray.z /= degree;\n\tray.z = ( ray.z*ray.z - dot(ray.xy,ray.xy) ); // fisheye\n\tray.z = degree*sqrt(ray.z);\n}\n\nvec3 LensFlare( vec3 ray, vec3 lightCol, vec3 light, float lightVisible, float sky, vec2 fragCoord )\n{\n\tvec2 dirtuv = fragCoord.xy/iResolution.x;\n\t\n\tfloat dirt = 1.0-texture( iChannel1, dirtuv ).r;\n\t\n\tfloat l = (dot(light,ray)*.5+.5);\n\t\n\treturn (\n\t\t\t((pow(l,30.0)+.05)*dirt*.1\n\t\t\t+ 1.0*pow(l,200.0))*lightVisible + sky*1.0*pow(l,5000.0)\n\t\t   )*lightCol\n\t\t   + 5.0*pow(smoothstep(.9999,1.0,l),20.0) * lightVisible * normalize(lightCol);\n}\n\n\nfloat SmoothMax( float a, float b, float smoothing )\n{\n\treturn a-sqrt(smoothing*smoothing+pow(max(.0,a-b),2.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ray = Ray( .7, fragCoord );\n\t\n\tBarrelDistortion( ray, .5 );\n\t\n\tray = normalize(ray);\n\tvec3 localRay = ray;\n\n    vec2 rot = vec2(.2,0.0);\n    \n\tfloat T = iTime*.13;\n\tvec2 mouse = vec2(.2,.5);\n\tif ( iMouse.z > .0 )\n\t\trot += vec2(1.0,-6.3) * (vec2(.5)-iMouse.yx/iResolution.yx);\n    else\n        rot -= vec2(0,1)*T;\n\t\t\n    float dist = 7.0;// * (-sin(iTime/10.0)+1.0);\n\tvec3 pos = dist*Rotate( ray, rot );\n\t//pos += vec3(0,.3,0) + T*vec3(0,0,-1);\n\t\n\tvec3 col;\n\n\tvec3 lightDir = normalize(vec3(3,1,-2));\n\t\n\tvec3 lightCol = vec3(1.1,1,.9)*1.0;\n\t\n\t// can adjust these according to the scene, even per-pixel to a bounding volume\n\tfloat near = .0;\n\tfloat far = 40.0;\n\t\n\tfloat t = Trace( pos, ray, near, far );\n\tif ( t > .0 )\n\t{\n\t\tvec3 p = pos + ray*t;\n\t\t\n\t\t// shadow test\n\t\tfloat s = 0.0;\n\t\t//s = TraceMin( p, lightDir, .05, far );\n        s = Trace( p, lightDir, .01*t, far );\n\t\t\n\t\tvec3 n = Normal(p, ray, t);\n\t\tcol = Shade( p, ray, n, lightDir, lightCol,\n\t\t\t\t\t//smoothstep( .0, .01, s ),\n                    step( s, .001 ),\n                    t );\n\t\t\n\t\t// fog\n\t\tfloat f = 200.0;\n\t\tcol = mix( vec3(.8), col, exp2(-t*vec3(.4,.6,1.0)/f) );\n\t}\n\telse\n\t{\n\t\tcol = Sky( ray );\n\t}\n\t\n\t// lens flare\n\tfloat s = TraceMin( pos, lightDir, .5, 40.0 );\n\tcol += LensFlare( ray, lightCol, lightDir, smoothstep(.01,.1,s), step(t,.0), fragCoord );\n\t\n\t// vignetting:\n\tcol *= smoothstep( 1.0, .0, dot(localRay.xy,localRay.xy) );\n\t\n\t// compress bright colours, ( because bloom vanishes in vignette )\n\tvec3 c = (col-1.0);\n\tc = sqrt(c*c+.05); // soft abs\n\tcol = mix(col,1.0-c,.48); // .5 = never saturate, .0 = linear\n\t\n\t// grain\n\tvec2 grainuv = fragCoord.xy + floor(iTime*60.0)*vec2(37,41);\n\tvec2 filmNoise = texture( iChannel0, .5*grainuv/iChannelResolution[0].xy ).rb;\n\tcol *= mix( vec3(1), mix(vec3(1,.5,0),vec3(0,.5,1),filmNoise.x), .1*filmNoise.y );\n\t\n\t// compress bright colours\n\tfloat l = max(col.x,max(col.y,col.z));//dot(col,normalize(vec3(2,4,1)));\n\tl = max(l,.01); // prevent div by zero, darker colours will have no curve\n\tfloat l2 = SmoothMax(l,1.0,.01);\n\tcol *= l2/l;\n\t\n\tfragColor = vec4(pow(col,vec3(1.0/2.2)),1);\n}\n", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Mts3Wl.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[165, 238, 263, 263, 470], [474, 474, 495, 639, 1540], [1546, 1546, 1578, 1578, 2047], [2052, 2052, 2074, 2074, 2155], [2158, 2158, 2269, 2269, 4634], [4639, 4814, 4883, 4883, 5122], [5124, 5124, 5196, 5196, 5462], [5464, 5464, 5508, 5583, 6231], [6234, 6245, 6285, 6285, 6355], [6357, 6357, 6394, 6394, 6609], [6612, 6631, 6686, 6757, 6864], [6866, 6866, 6968, 6968, 7303], [7306, 7306, 7360, 7360, 7420], [7422, 7422, 7479, 7479, 9588]], "test": "untested"}
{"id": "MtS3zz", "name": "STYLE?4", "author": "Branch", "description": "STYLE?4", "tags": ["style4"], "likes": 2, "viewed": 1007, "published": "Public API", "date": "1426624141", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float roundBox(vec2 coord, vec2 pos, vec2 b ){\n  return length(max(abs(coord-pos)-b,0.05));\n}\nfloat circle(vec2 coord, vec2 pos, float size){\n    return min(floor(distance(coord,pos)-size),0.);\n}\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r ){\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return min(floor(length( pa - ba*h ) - r),0.);\n}\n\nmat2 rotate(float Angle){\n    mat2 rotation = mat2(\n        vec2( cos(Angle),  sin(Angle)),\n        vec2(-sin(Angle),  cos(Angle))\n    );\n\treturn rotation;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\n\tfloat aspectCorrection = (iResolution.x/iResolution.y);\n\tvec2 coordinate_entered = 2.0 * p - 1.0;\n\tvec2 coord = vec2(aspectCorrection,1.0) *coordinate_entered;\n    coord *= 0.7+sin(iTime)*0.2;\n    coord *= rotate(sin(iTime*0.7)*0.1);\n\tfloat vignette = 1.0 / max(0.25 + 0.3*dot(coord,coord),1.);\n\tvec3 COLOR =vec3(1.0);\n    \n    \n    for(float i = -2.0; i < 3.0; i++){\n        \n        vec2 cloud_pilar_position_A = vec2( (0.2-abs(i)*.015)*i, 0.0);\n        vec2 cloud_pilar_position_B = vec2(  (0.2-abs(i)*.015)*i, 0.3-abs(i)*.1);\n        if(coord.y>0.0 && sdCapsule( coord, cloud_pilar_position_A, cloud_pilar_position_B, 0.11-abs(i)*.02)<0.0)\n            COLOR = vec3(\t(0.0/225.0), \n                            (125.0/225.0), \n                            (207.0/225.0) );\n\n        vec2 rain_pilar_position_A =vec2( i*0.19, 0.0);\n        vec2 rain_pilar_position_B = vec2(  i*0.19, -1.);\n        if(sdCapsule( coord, rain_pilar_position_A, rain_pilar_position_B, 0.03)<0.0)\n            COLOR = vec3(\t(0.0/225.0), \n                            (125.0/225.0), \n                            (207.0/225.0) );\n        \n    }\n    \n    for(float i = -3.0; i < 4.0; i++){\n        \n        vec2 box_position = vec2( i*0.5, -1.0+sin(i*i*111.6346361+iTime*3.0)*0.1);\n        vec2 box_size = vec2(0.15,0.3);\n        if(roundBox(coord, box_position, box_size )<0.1)\n            COLOR = vec3(\t(222.0/225.0), \n                            (0.0/225.0), \n                            (104.0/225.0) );\n        \n    }\n    \n    for(float i = -7.0; i < 13.0; i++){\n        float tip = mod(i + iTime * 0.6 + 7.0, 14.0) - 7.0;\n        vec2 circle_position =vec2( tip * 0.3 + sin(tip) * 0.1, 1.0 + sin(i + tip * tip) * 0.1);\n        if(circle(coord, circle_position, 0.3 - sin(tip) * 0.1)<0.0)\n            COLOR = vec3(\t(1.0/225.0), \n                            (11.0/225.0), \n                            (23.0/225.0) );\n    }\n\tfragColor = vec4( COLOR*vignette\n         \t\t\t\t,1.0);\n} ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtS3zz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 93], [94, 94, 141, 141, 195], [196, 196, 247, 247, 389], [391, 391, 416, 416, 548], [549, 549, 605, 605, 2603]], "test": "untested"}
{"id": "MtsGDf", "name": "TrollsCave", "author": "FatumR", "description": "My experiments with 3D noise, water should be added.", "tags": ["procedural", "3d", "raymarching", "fractal", "noise", "cave"], "likes": 17, "viewed": 855, "published": "Public", "date": "1427155670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCTAVES  8\n#define HIGH_QUALITY (1)\n#define DARK_FORCE (0)\n\n#if HIGH_QUALITY\n#define MAX_STEPS  128\n#else\n#define MAX_STEPS  64\n#endif\n#define THRESHOLD .00001\n\n\nconst float fogDensity = .15;\n\n\nfloat rand(in vec2 co){\n   return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand2(in vec2 co){\n   return fract(cos(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nfloat rand3(in vec3 co){\n   return fract(sin(dot(co.xyz ,vec3(12.9898,78.233,213.576))) * 43758.5453);\n}\n\nfloat valueNoiseSimple3D(in vec3 vl) {\n    const vec2 helper = vec2(0., 1.);\n    vec3 grid = floor(vl);\n    vec3 interp = smoothstep(vec3(0.), vec3(1.), fract(vl));\n    \n    float interpY0 = mix(mix(rand3(grid),\n                         \t rand3(grid + helper.yxx),\n                         \t interp.x),\n                        mix(rand3(grid + helper.xyx),\n                         \trand3(grid + helper.yyx),\n                         \tinterp.x),\n                        interp.y);\n    \n    \n    float interpY1 = mix(mix(rand3(grid + helper.xxy),\n                         \t rand3(grid + helper.yxy),\n                         \tinterp.x),\n                        mix(rand3(grid + helper.xyy),\n                         \trand3(grid + helper.yyy),\n                         \tinterp.x),\n                        interp.y);\n    \n    return -1. + 2.*mix(interpY0, interpY1, interp.z);\n}\n\nfloat fractalNoise(in vec3 vl) {\n    const float persistance = 2.;\n    const float persistanceA = 2.;\n    float amplitude = .5;\n    float rez = 0.0;\n    float rez2 = 0.0;\n    vec3 p = vl;\n    \n    for (int i = 0; i < OCTAVES / 2; i++) {\n        rez += amplitude * valueNoiseSimple3D(p);\n        amplitude /= persistanceA;\n        p *= persistance;\n    }\n    \n    float h = smoothstep(0., 1., vl.y*.5 + .5 );\n    if (h > 0.01) { // small optimization, since Hermit polynom has low front at the start\n        // God is in the details\n        for (int i = OCTAVES / 2; i < OCTAVES; i++) {\n            rez2 += amplitude * valueNoiseSimple3D(p);\n            amplitude /= persistanceA;\n            p *= persistance;\n        }\n        rez += mix(0., rez2, h);\n    }\n    \n    return rez;\n}\n\nvec2 helix(vec3 p, float r, float width) {\n    return vec2(r*cos(p.z/ width), r*sin(p.z/ width));\n}\n\nfloat scene(in vec3 a) {\n   \n   float zVal = fractalNoise(a.xyz);\n\n   return -length(a.xy - helix(a, .25, 1.5)) + 1.\n#if HIGH_QUALITY\n       + zVal * 1.5;\n#else\n       + zVal * 1.1;\n#endif\n\n}\n\nvec3 snormal(in vec3 a) {\n   const vec2 e = vec2(.0001, 0.);\n   float w = scene(a);\n\n   return normalize(vec3(\n       scene(a+e.xyy) - w,\n       scene(a+e.yxy) - w,\n       scene(a+e.yyx) - w ));\n\n}\n\nfloat trace(in vec3 O, in vec3 D, out float hill) {\n    float L = 0.;\n    float d = 0.;\n    \n#if DARK_FORCE\n    L = 2.5;\n#endif\n\n    float L_prev = 0.;\n\n    for (int i = 0; i < MAX_STEPS; ++i) {\n#if HIGH_QUALITY\n       d = scene(O + D*L) * .25;\n#else\n       d = scene(O + D*L) * .45;\n#endif\n        \n\n        L_prev = L;\n        L += d;\n        if (abs(d) < THRESHOLD * L)\n            break;\n    }\n    \n    hill = d;\n    return L;\n}\n\nfloat occluded(in vec3 p, in float len, in vec3 dir) {\n    return max(0., len - scene(p + len * dir));\n}\n\nfloat occlusion(in vec3 p, in vec3 normal) {\n    vec3 rotZccw = vec3(-normal.y, normal.x, normal.z);\n    vec3 rotZcw = vec3(normal.y, -normal.x, normal.z);\n    \n    vec3 rotXccw = vec3(normal.x, normal.z, -normal.y);\n    vec3 rotXcw = vec3(normal.x, -normal.z, normal.y);\n    \n    vec3 rotYccw = vec3(normal.z, normal.y, -normal.x);\n    vec3 rotYcw = vec3(-normal.z, normal.y, normal.x);\n    \n    float rez = 0.;\n    const float dst = .15;\n\n   \trez+= occluded(p, dst, normal);\n    \n    rez+= occluded(p, dst, rotXccw);\n    rez+= occluded(p, dst, rotXcw);\n\n    rez+= occluded(p, dst, rotYccw);\n    rez+= occluded(p, dst, rotYcw);\n\n    rez+= occluded(p, dst, rotZccw);\n    rez+= occluded(p, dst, rotZcw);\n\n    return (1. - min(rez, 1.));\n}\n\nvec3 enlight(in vec3 p, in vec3 normal, in vec3 eye, in vec3 lightPos) {\n    \n    float normDir = .5 * dot(normal, vec3(0., 1., 0.));\n    float down = .5 - normDir;\n    float up = normDir + .5;\n    \n    vec3 dir = lightPos - p;\n    vec3 eyeDir = eye - p;\n    vec3 I = normalize(dir);\n\n    float mxB = valueNoiseSimple3D( (p.zxy - sin(p.z) * 0.1)*20. + valueNoiseSimple3D(\n        \t\t\t\t\t\t\t\t\t\t\t\t\tp * 55. +\n        \t\t\t\t\t\t\t\t\t\t\t\t\tvalueNoiseSimple3D(\n                                                                p*500. +\n                                                                valueNoiseSimple3D(\n                                                                    p*1000.)\n                                                            )\n    \t\t\t\t\t\t\t\t\t\t\t\t\t));\n    \n    /*\n    float mxB = valueNoiseSimple3D( p.zxy*20. + valueNoiseSimple3D(\n        \t\t\t\t\t\t\t\t\t\t\t\t\tp * 55. +\n        \t\t\t\t\t\t\t\t\t\t\t\t\tvalueNoiseSimple3D(\n                                                                p*500. +\n                                                                valueNoiseSimple3D(p*1000.)\n                                                            )\n    \t\t\t\t\t\t\t\t\t\t\t\t\t));\n    */\n    mxB = abs(mxB);\n    \n    vec3 grass = mix(vec3(0.258823529, 0.317647059, 0.062745098),\n                     vec3(0.835294118, 0.898039216, 0.611764706),\n                     mxB\n    );\n    \n    vec3 cave = vec3(0.850980392,\n                     0.592156863,\n                     0.294117647\n    );\n    \n    vec3 cave2 = vec3(0.505882353,\n                      0.31372549,\n                      0.156862745\n                     );\n    \n    float val1 = (p.x + p.y* 3. + p.z) * 100. +\n                                  2. * valueNoiseSimple3D(p * 80.);\n    float val2 = 1.5 * valueNoiseSimple3D(p * 160.);\n    float val3 = .75 * valueNoiseSimple3D(p * 320.);\n    \n   \n    vec3 ceilClr = mix(cave2, cave, abs(sin(val1 + val2 + val3)));\n    vec3 color = mix(vec3(.0), ceilClr, abs(down));\n    color = mix(cave, color, .5 + abs(normDir));\n    color = mix(color, grass, abs(up));\n    \n    vec3 ambient = color;\n    vec3 diffuse = max(dot(normal, I), 0.) * color.rgb;\n\n    return clamp(diffuse * 0.75 + ambient * occlusion(p, normal), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 centered_uv = uv * 2. - 1.;\n    centered_uv.x *= iResolution.x / iResolution.y;\n\n    float timeOffset = iTime / 2.;\n    \n    vec3 O = vec3(0., -0.2, 1. - timeOffset);\n    O.xy += helix(O, .25, 1.5);\n    \n    vec3 D = normalize(vec3(centered_uv, -3.0));\n\n    float hill;\n    float path = trace(O, D, hill);\n    vec3 coord = O + path * D;\n    \n    vec3 resColor;\n    vec3 skyBlueColor = vec3(0.529411765, 0.807843137, 0.980392157);\n    vec3 bgColor = mix(vec3(1.), skyBlueColor, clamp(centered_uv.y, 0., 1.));\n\n    vec3 lightPos = vec3(0., 0., 1. - timeOffset);\n    lightPos.xy += O.xy;\n    vec3 normal = snormal(coord);\n\n    resColor = enlight(coord, normal, O, lightPos);\n    resColor = mix(resColor, bgColor, min(hill, 1.));\n\n    // Calc some fog\n    float fogFactor = exp(-pow(abs(fogDensity * (coord.z - .75 + timeOffset)), 6.0));\n    fogFactor = clamp(fogFactor, 0.0, 1.0);\n\n    resColor = mix(bgColor, resColor, fogFactor);\n\n\tfragColor = vec4(resColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 202, 225, 225, 296], [298, 298, 322, 322, 393], [395, 395, 419, 419, 499], [501, 501, 539, 539, 1376], [1378, 1378, 1410, 1410, 2159], [2161, 2161, 2203, 2203, 2260], [2262, 2262, 2286, 2286, 2453], [2455, 2455, 2480, 2480, 2652], [2654, 2654, 2705, 2705, 3086], [3088, 3088, 3142, 3142, 3192], [3194, 3194, 3238, 3238, 3931], [3933, 3933, 4005, 4005, 6143], [6145, 6145, 6202, 6202, 7218]], "test": "untested"}
{"id": "MtsGWj", "name": "The Hassle of Relative Scale", "author": "florian", "description": "A classic ray marcher of sphere plus noise of sorts, using emulated somewhat double precision. I've tracked down the floating point precision loss all the way except for IQ's noise, which still is single float and lossy. Uncomment the #defines to see diff", "tags": ["singledouble", "relativescale", "detail", "flopsgalore"], "likes": 5, "viewed": 243, "published": "Public", "date": "1425343593", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// For the love of relative scale.\n//\n// This shader drills down into floating point precision loss in a sdf raymarcher\n//\n// Credits to IQ and whoever wrote some of these single double functions\n// I've added a few to the list.\n//\n// -Floseph\n//\n\n#define USE_DOUBLESINGLE 1\n#define ANIMATE 1\n\n// some double single code found on the web all over the place\nvec2 ds_set(float a) \n{\n    vec2 z;\n    z.x = a;\n    z.y = 0.0;\n    return z;\n}\n\nvec2 ds_add (vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float t1, t2, e;\n\n    t1 = dsa.x + dsb.x;\n    e = t1 - dsa.x;\n    t2 = ((dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y + dsb.y;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n    return dsc;\n}\n\nvec2 ds_sub (vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float e, t1, t2;\n\n    t1 = dsa.x - dsb.x;\n    e = t1 - dsa.x;\n    t2 = ((-dsb.x - e) + (dsa.x - (t1 - e))) + dsa.y - dsb.y;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n    return dsc;\n}\n\nvec2 ds_mul (vec2 dsa, vec2 dsb)\n{\n    vec2 dsc;\n    float c11, c21, c2, e, t1, t2;\n    float a1, a2, b1, b2, cona, conb, split = 8193.;\n\n    cona = dsa.x * split;\n    conb = dsb.x * split;\n    a1 = cona - (cona - dsa.x);\n    b1 = conb - (conb - dsb.x);\n    a2 = dsa.x - a1;\n    b2 = dsb.x - b1;\n\n    c11 = dsa.x * dsb.x;\n    c21 = a2 * b2 + (a2 * b1 + (a1 * b2 + (a1 * b1 - c11)));\n\n    c2 = dsa.x * dsb.y + dsa.y * dsb.x;\n\n    t1 = c11 + c2;\n    e = t1 - c11;\n    t2 = dsa.y * dsb.y + ((c2 - e) + (c11 - (t1 - e))) + c21;\n\n    dsc.x = t1 + t2;\n    dsc.y = t2 - (dsc.x - t1);\n\n    return dsc;\n}\n\n// Compare: res = -1 if a < b\n//              = 0 if a == b\n//              = 1 if a > b\nfloat ds_compare(vec2 dsa, vec2 dsb)\n{\n    if (dsa.x < dsb.x) return -1.;\n    else if (dsa.x == dsb.x) {\n        if (dsa.y < dsb.y) return -1.;\n        else if (dsa.y == dsb.y) return 0.;\n        else return 1.;\n    }\n    else return 1.;\n}\n\nstruct dsvec3\n{\n    vec2 x;\n    vec2 y;\n    vec2 z;\n};\n\ndsvec3 set(vec3 v)\n{\n    return dsvec3(vec2(v.x, 0.0), vec2(v.y, 0.0), vec2(v.z, 0.0));\n}\n\ndsvec3 calcRayPos(vec3 ro, vec3 rd, vec2 t)\n{\n    dsvec3 dsrd = set(rd);\n    dsvec3 dsrp = set(ro);\n    dsrd.x = ds_mul(dsrd.x, t);\n    dsrd.y = ds_mul(dsrd.y, t);\n    dsrd.z = ds_mul(dsrd.z, t);\n    dsrp.x = ds_add(dsrp.x, dsrd.x);\n    dsrp.y = ds_add(dsrp.y, dsrd.y);\n    dsrp.z = ds_add(dsrp.z, dsrd.z);\n    return dsrp;\n}\n\nvec2 ds_sqrt(vec2 d)\n{\n    //\n\t// sqrt(d) = (d * x) + 0.5 * [d - (d * x)^2] * x (approx.)\n    //\n    vec2 x = vec2(inversesqrt(d.x), 0.0);\n    vec2 dtx = ds_mul(d, x);\n    return ds_add(dtx, ds_mul(vec2(0.5, 0.0), ds_mul(ds_sub(d, ds_mul(dtx, dtx)), x)));\n}\n\nvec2 ds_length(dsvec3 p)\n{\n    return ds_sqrt(ds_add(ds_add(ds_mul(p.x, p.x), ds_mul(p.y, p.y)), ds_mul(p.z, p.z)));\n}\n\nvec2 ds_min(vec2 a, vec2 b)\n{\n    return (ds_compare(a, b) < 0.0) ? a : b;\n}\n\ndsvec3 ds_mul(dsvec3 p, float a)\n{\n    return dsvec3(ds_mul(p.x, vec2(a, 0.0)), ds_mul(p.y, vec2(a, 0.0)), ds_mul(p.z, vec2(a, 0.0)));\n}\n\n// IQ's noise\nfloat hash( float n )\n{\n    return fract(sin(n)*43758.5453);\n}\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n    return mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n                   mix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n               mix(mix( hash(n+113.0), hash(n+114.0),f.x),\n                   mix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n}\n\n\n\n#ifdef USE_DOUBLESINGLE\n\nvec2 rmf(dsvec3 p, float f, float l)\n{\n    p = ds_mul(p, f);\n    float s = 0.0;\n    vec2 v  = vec2(0.0);\n    float w = 1.0;\n    float h = 1.0;\n    float fs = 1.0;\n\n    for (int i=0; i < 8; i++) \n    {\n        s = noise(vec3(p.x.x+p.x.y, p.y.x+p.y.y, p.z.x+p.z.y));\n        s = pow(1.0 - abs(s), 2.0) * w;\n        w = clamp(0.0, 1.0, s * 16.0);\n        v = ds_add(v, vec2(s * pow(fs, -1.0), 0.0));\n        fs *= l;\n        p = ds_mul(p, l);\n    }\n    \n    return v;\n}\n\nvec2 sdf(dsvec3 p)\n{\n    vec2 s0 = ds_sub(ds_length(p), vec2(1.0, 0.0));\n    dsvec3 q = dsvec3(ds_sub(p.x, vec2(0.141, 0.0)), ds_sub(p.y, vec2(0.1, 0.0)), ds_sub(p.z, vec2(0.9, 0.0)));\n    vec2 s1 = ds_sub(ds_length(q), vec2(0.2, 0.0));\n\n    vec2 sd = ds_min(s0, s1);\n    vec2 n = ds_mul(rmf(p, 512.0, 2.0), vec2(0.00025, 0.0));\n    n = ds_sub(sd, n);\n    return n;\n    \n}\ndsvec3 grad(dsvec3 p, vec2 coneR)\n{\n    vec2 f = sdf(p);\n    dsvec3 q = p;\n    q.x = ds_add(q.x, coneR);\n    vec2 g0 = sdf(q);\n    q.x = p.x;\n    q.y = ds_add(q.y, coneR);\n    vec2 g1 = sdf(q);\n    q.y = p.y;\n    q.z = ds_add(q.z, coneR);\n    vec2 g2 = sdf(q);\n    q.x = ds_sub(g0, f);\n    q.y = ds_sub(g1, f);\n    q.z = ds_sub(g2, f);\n    return q;//(g-f) / coneR;\n}\n\n#else\nfloat rmf(vec3 p, float f, float l)\n{\n    p *= f;\n    float s = 0.0;\n    float v  = 0.0;\n    float w = 1.0;\n    float h = 1.0;\n    float fs = 1.0;\n\n    for (int i=0; i < 8; i++) \n    {\n        s = noise(p);\n        s = pow(1.0 - abs(s), 2.0) * w;\n        w = clamp(0.0, 1.0, s * 16.0);\n        v += (s * pow(fs, -1.0));\n        fs *= l;\n        p *= l;\n    }\n    \n    return v;\n}\nfloat sdf(vec3 p)\n{\n    return min(length(p)-1.0, length(p-vec3(0.141, 0.1, 0.9))-0.2) - rmf(p, 512.0, 2.0)*0.00025;\n}\nvec3 grad(vec3 p, float coneR)\n{\n    vec3 f = vec3(sdf(p));\n    vec3 g = vec3(sdf(p+vec3(coneR, 0.0, 0.0)),\n                  sdf(p+vec3(0.0, coneR, 0.0)),\n                  sdf(p+vec3(0.0, 0.0, coneR)));\n    return (g-f) / coneR;\n}\n\n#endif\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n    //vec2 m = 2.0*(mouse * 2.0 - 1.0) * vec2(iResolution.x / iResolution.y, 1.0);\n    #ifdef ANIMATE\n\tvec3 ro = vec3(0.0, 0.0, 1.1-sin(iTime*0.5)*0.0989);\n    #else\n    vec3 ro = vec3(0.0, 0.0, 1.1-0.0989);\n    #endif\n    \n    vec2 coord = vec2(fragCoord.xy);\n    vec2 v = vec2(coord / iResolution.xy) * 2.0 - 1.0;\n    float camAspect = iResolution.x/iResolution.y;\n    float fov_y_scale = tan(radians(30.0));\n    vec3 rd = normalize(vec3(v.x*fov_y_scale*camAspect, v.y*fov_y_scale, -1.0));\n    \n    #ifdef USE_DOUBLESINGLE\n    vec2 t = vec2(0.0);    \n    vec2 coneR;\n    vec2 sd;\n    #else\n    float t = 0.0;\n    float coneR = 0.0;\n    float sd;\n    #endif\n    \n    float coneScale = tan(radians(30.0)/iResolution.y);\n    \n    for (int i=0; i<256; i++)\n    {\n\n        #ifdef USE_DOUBLESINGLE\n        coneR = ds_mul(vec2(coneScale, 0.0), t);\n        dsvec3 rp = calcRayPos(ro, rd, t);\n        #else\n        vec3 rp;\n        coneR = coneScale * t;\n        rp = ro+rd*t;\n        #endif\n        \n        sd = sdf(rp);\n        \n        #ifdef USE_DOUBLESINGLE        \n        if (ds_compare(abs(sd), coneR) < 0.0)\n        {\n            dsvec3 g = grad(rp, coneR);\n            vec3 N = normalize(vec3(g.x.x, g.y.x, g.z.x));\n            fragColor = vec4(N*0.5+0.5, 1.0);\n            return;\n        }\n        else if (t.x > 3.0)\n        {\n            break;\n        }\n        t = ds_add(t, sd);\n        #else\n        if (abs(sd) < coneR)\n        {\n            vec3 N = normalize(grad(rp, coneR));\n            fragColor = vec4(N*0.5+0.5, 1.0);\n            return;\n        }\n        else if (t > 3.0)\n        {\n            break;\n        }\n        t += sd;\n        #endif\n        \n    }\n    \n    fragColor = vec4(0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsGWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 360, 383, 383, 439], [441, 441, 475, 475, 687], [689, 689, 723, 723, 936], [938, 938, 972, 972, 1533], [1535, 1624, 1662, 1662, 1863], [1921, 1921, 1941, 1941, 2010], [2012, 2012, 2057, 2057, 2337], [2339, 2339, 2361, 2435, 2596], [2598, 2598, 2624, 2624, 2716], [2718, 2718, 2747, 2747, 2794], [2796, 2796, 2830, 2830, 2932], [2934, 2948, 2971, 2971, 3010], [3012, 3012, 3038, 3038, 3405], [5392, 5392, 5450, 5450, 7278]], "test": "untested"}
{"id": "MtsGWX", "name": "Flying boat", "author": "gaz", "description": "3d", "tags": ["raymarching", "de"], "likes": 6, "viewed": 191, "published": "Public", "date": "1425829746", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nbool cflag = false;\nint id;\n\nmat2 rotate(float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix(vec3(1.0), clamp((abs(fract(\n    h + vec3(3.0, 2.0, 1.0) / 3.0) * 6.0 - 3.0) - 1.0), 0.0, 1.0), s) * v;\n}\n\nfloat map0(in vec3 p) // body\n{   \n    // postion\n    p.y -= -0.3;\n   \tp.z -= 1.2;\n    //de\n    p.x *= 0.8;\n    float a =  atan(-p.y, p.z);\n    p.yz *= (abs(cos(0.5 * a)) + 0.08);\n    return length(p) - 0.25;\n}\n\nfloat map1(in vec3 p) // engine\n{   \n    // postion\n    p.y -= 0.82;\n    p.z -= 0.05;\n    // de\n    return length(max(abs(p) - vec3(0.15, 0.15, 0.25), 0.0)) - 0.1;\n}\n\nfloat map2(in vec3 p) //propeller\n{   \n    // position\n    p.y -= 0.8;\n    p.z -= 0.5;\n    // de\n    p.xy *= rotate(iTime);\n    vec3 q = p;\n    p.x *= 0.2;\n    p.x = abs(p.x)-0.05;\n    p.yz *= rotate(sign(q.x) * 0.8 - q.x *  1.5);\n    q.z -= -0.02;\n    q.z *= 0.6;\n    return min(\n        max(abs(p.z) - 0.01,length(p.xy) - 0.05),\n        max(-q.z,length(q) - 0.08));\n}\n\nfloat map3(in vec3 p) // main wing\n{   \n    // postion\n    p.y -= 0.3;\n    // de\n    p.y *= 2.0;\n    p.z += 0.2 * abs(p.x);\n    p.z *= 0.4;\n    float r = 0.15;\n    p.x = abs(p.x) -2.0;\n    return min(length(p) - r, max(p.x, length(p.zy) - r));\n}\n\nfloat map4(in vec3 p) // folat\n{   \n    // postion\n    p.y -= -0.4;\n    p.z -= -0.1;\n    p.x = abs(p.x) - 1.5;\n    // de\n    p.x *= 0.8;\n    float a =  atan(-p.y, p.z);\n    p.yz *= (abs(cos(0.5 * a)) + 0.3);\n\treturn length(p) - 0.2;\n}\n\nfloat map5(in vec3 p) // vertical tail\n{   \n    // postion\n    p.y -= -0.3;\n    p.z -= -1.8;\n    // de\n    p *= 2.0;\n    p.z += 0.2 * p.y;\n    p.y *= 0.1;\n    p.z *= 0.3;\n    return max(abs(p.y - 0.06) - 0.06, length(p) - 0.1);\n}\n\n\nfloat map6(in vec3 p) // horizontal tail\n{   \n    // postin\n    p.y -=- 0.2;\n    p.z -= -1.8;\n    // de\n    p.z += 0.2 * abs(p.x);\n    p.z *= 0.6;\n    float r = 0.1;\n    p.x = abs(p.x) - 0.3;\n    return min(length(p) - r, max(p.x, length(p.zy) - r));\n}\n\nfloat map7(in vec3 p) // engine stay\n{   \n    // position\n    p.y -= 0.3;\n    p.x = abs(p.x) - 0.4;\n    // de\n    p.x += 0.6 * abs(p.y);\n    vec3 q = p;\n    p.z += -0.2 * p.y;\n\tp.z = abs(p.z) - 0.2;\n    q.z -= -0.2;\n    q.z += -1.0 * abs(q.y);\n\treturn min(\n        max(abs(p.y) - 0.5,length(p.zx) - 0.05),\n        max(abs(q.y) - 0.5,length(q.zx) - 0.03));\n}\n\nfloat map8(in vec3 p) // float stay\n{   \n    // postion\n    p.y -= -0.4;\n    p.z -= -0.3;\n    p.x = abs(p.x) - 1.5;\n    // de\n\tp.z += -0.1 * p.y;\n\tp.z = abs(p.z) - 0.2;\n    p.z += -0.1 * p.y;\n    vec3 q = p;\n    q.x +=  0.6 * q.y;\n\treturn min(\n        max(abs(p.y - 0.3) - 0.3,length(p.zx) - 0.05),\n        max(abs(q.y - 0.3) - 0.3,length(q.zx) - 0.03));\n}\n\nfloat map(in vec3 p)\n{       \n    p *= 0.7;  // weight\n    // bounding box\n    vec3 bb = vec3(2.3, 1.3, 2.2);\n    if (any(greaterThan(abs(p), bb))) return length(max(abs(p) - bb, 0.0)) + 0.2;\n    const int n = 9;\n    float res = 100.0;\n    float de[n];\n    de[0] = map0(p);\n    de[1] = map1(p);\n    de[2] = map2(p);\n    de[3] = map3(p);\n    de[4] = map4(p);\n    de[5] = map5(p);\n    de[6] = map6(p);\n    de[7] = map7(p);\n    de[8] = map8(p);\n    for(int i = 0; i < n; i++) res = min(res, de[i]);\n    if (cflag)\n    {\n\t\tid = n - 1;        \n   \t\tfor(int i = 0; i < n - 1; i++)\n    \t{\n            bool f = true;\n            for(int j = 1; j < n; j++)\n            {\n                if (de[i] > de[j])  f = false;\n            }\n            if (f) \n            {\n                id = i;\n                break;\n            }\n        }\t     \n    }    \n    return res;\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd)\n{\n\tfloat res = 1.0;\n    float t = 0.02;\n    for(int i = 0; i < 64; i++)\n    {\n\t\tfloat h = map(ro + rd * t);\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.1);\n        if(h < 0.001 || t > 1.5) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 30.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvec3 coloring(in vec3 p)\n{\n    cflag = true;\n    map(p);\n    vec3 col0 = hsv(0.0, 0.9, 0.8);\n    if (id == 0) \n    {\n        return col0;\n    }\n    if (id == 1)\n    {\n        return col0;\n    }\n    if (id == 2) \n    {\n        return hsv(0.2, 0.8, 0.6);\n    }\n    if (id == 3) \n    {\n        return col0;\n    }\n    if (id == 4) \n    {\n        return col0;\n    }\n    if (id == 5) \n    {\n        return col0;\n    }\n    if (id == 6) \n    {\n        return col0;\n    }\n    if (id == 7) \n    {\n        return col0;\n    }\n    if (id == 8) \n    {\n        return col0;\n    }\n    return vec3(0.0);\n}\n\nmat3 lookat(in vec3 fw, in vec3 up)\n{\n\tfw = normalize(fw);\n    vec3 rt = normalize(cross(fw, up));\n    return mat3(rt, cross(rt, fw), fw);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p2d = (2.0 * fragCoord - iResolution.xy) / iResolution.y;   \n    float time = 0.3 * iTime;\n    /*\n    float a = 0.0;\n    float h = -0.3;\n    float d = 6.0;\n    a = (a + 0.5)*PI;\n    vec3 ro = vec3(cos(a), h, sin(a))* d;\n\t*/\n\tvec3 ro = vec3(cos(time), 0.6, sin(time))* 6.0;\n    vec3 rd = normalize(vec3(p2d, 2.0));\n\trd = lookat(-ro, vec3(0.0, 1.0, 0.0)) * rd;\n    vec3 lig = normalize(ro + vec3(0.5, 0.8, 3.0)); \n    vec3 col = hsv(0.4, 0.8, 0.2);\n    col = mix(col, hsv(0.6, 0.3, 0.15), smoothstep(0.0, 2.0, length(p2d)));\n    float t = march(ro, rd);\n    if(t > -0.01)\n    {\n        vec3 p3d = ro + t * rd;\n        vec3 n = calcNormal(p3d);\n\t\tfloat dif = clamp((dot(n, lig) + 0.5) * 0.7, 0.2, 1.0);\n        dif *= clamp(softshadow(p3d, lig), 0.2, 1.0);\n        col = coloring(p3d) * dif;\n\t}\n   \tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtsGWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[80, 80, 102, 102, 152], [154, 154, 191, 191, 310], [312, 312, 343, 361, 522], [524, 524, 557, 575, 689], [691, 691, 726, 745, 1060], [1062, 1062, 1098, 1116, 1307], [1309, 1309, 1341, 1359, 1543], [1545, 1545, 1585, 1603, 1774], [1777, 1777, 1819, 1836, 2029], [2031, 2031, 2069, 2088, 2388], [2390, 2390, 2427, 2445, 2746], [2748, 2748, 2770, 2770, 3609], [3611, 3611, 3639, 3639, 3806], [3808, 3808, 3850, 3850, 4108], [4110, 4110, 4147, 4147, 4441], [4443, 4443, 4469, 4469, 5031], [5033, 5033, 5070, 5070, 5173], [5175, 5175, 5232, 5232, 6064]], "test": "untested"}
{"id": "MtSGzz", "name": "shadeaday ( 3 / 16 / 2015 )", "author": "cabbibo", "description": "trying to make something real, and than mod", "tags": ["glsl"], "likes": 0, "viewed": 109, "published": "Public", "date": "1426621380", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 40;\n\t\nvec4 spherePos[20];\n  \n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 noiseVec( vec3 p ){\n    \n    float x = rand( p.xy );\n    float y = rand( p.yz);\n    float z = rand( p.zx );\n \n    return normalize(normalize(vec3( x , y , z )) - vec3( .5 ));\n    \n}\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p )\n{\n    \n    float f = sin( p.z * 5. ) * sin( p.x * 5. );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y - (abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\n\nfloat sdNoiseSphere( vec3 p, float s )\n{\n  return length(p)-( s * (.7 + .9* triNoise3D( p * .16, .4 ) ));\n}\n\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    pos = mod( pos + .5 , 1. ) - .5 ;\n   \tvec2 res = vec2( 10000. , 0.);// vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    \n    for( int i = 0; i < 20; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , .2 ) ,  .1);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n    vec2 res2 = vec2( sdNoiseSphere( (pos) , .6 ) , 3.);\n    \n    res = opU( res , res2 );\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    for( int i =0; i < 20; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n        \n        vec3  p = vec3( x , y , z );\n        p = normalize( p ) * 1.3;\n        \n    \tspherePos[i] = vec4( p.x ,  p.y ,  p.z , .2  );\n        \n        \n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n    vec3 lightPos = vec3( 2. , 1. , 0. );\n    \n    vec3 col = vec3( 0. );//vec3( .8 , .8 , .8 ); \n   \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n        vec3 pos = ro + rd * res.x;\n        vec3 nor = calcNormal( pos );\n\n        vec3 lightDir = lightPos - pos;\n        lightDir = normalize( lightDir );\n        \n        vec3 lightRefl = reflect( lightDir , nor );\n        float reflMatch = pow( max( 0. , dot( rd , lightRefl )) , 10. );\n        \n\n\n        float AO = calcAO( pos , nor );\n\n        float match = max( 0. , dot( nor , lightDir ));\n        \n        float rim = pow( 1. - max( 0. , dot( -nor , rd ) ) , 5.);\n\n        if( res.y < 2. ){\n    \n           // float c = pow(( 1.-AO) , 5.)*  10.;\n            float c = 0.;\n            //c += pow((1.- match),4.) * 1.;\n            c += pow(( 1.-AO) , 5.)*  2.;\n           // col = vec3( c );// * .4 * ( nor * .5 + .5 );\n\n           // col = hsv( c ,1.,1.) * c;\n            col += vec3( 1. , .2 , 0.6 ) * pow(( 1.-AO) , 2.); \n            col += vec3( 1. , .8, .2 ) * rim;\n            col += vec3( .3 , .5 , 1. ) * reflMatch;\n            \n            //* pow( match , 3.) * hsv(abs(sin(match*1.)) , 1. , 1. );\n            //col += pow( shinyMatch , 5. ) * hsv(abs(sin(shinyMatch*10.)) , 1. , 1. );\n        }else{\n          \n        \tvec3 refl = normalize( reflect( rd , nor ));\n            \n            vec3 ro2 = pos + refl * .01;\n            vec3 rd2 = refl;\n            \n            vec2 res2 = calcIntersection( ro2 , rd2  );\n            \n            col += vec3( 1. , .8 , .2 ) * rim;\n            \n            if( res2.y > -.5 ){\n                \n                \n                \n\n                vec3 pos2 = ro2 + rd2 * res2.x;\n        \t\tvec3 nor2 = calcNormal( pos2 );\n\n                vec3 lightDir = lightPos - pos2;\n                lightDir = normalize( lightDir );\n\n                vec3 lightRefl = reflect( lightDir , nor2 );\n                float reflMatch = pow( max( 0. , dot( rd2 , lightRefl )) , 10. );\n                \n                float AO = calcAO( pos2 , nor2 );\n                col += vec3( 1. , .2 , .6 ) * pow(( 1.-AO) , 2.); \n                \n                float r2 = pow( 1. - max( 0. , dot( -nor2 , rd2 ) ) , 5.);\n                col += vec3( 1. , .8 , .2 ) * r2;\n                \n                col += vec3( .3 , .5 , 1. ) * reflMatch;\n            \n            }\n            \n          \n            \n        }\n        //col = vec3( shinyMatch );\n       /* if( res.y < .5 ){\n            \n            float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n            col *= abs( f );\n            col /= pow( length( pos ), 4.);\n        }*/\n    }\n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtSGzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[353, 405, 427, 427, 452], [453, 453, 474, 474, 554], [590, 642, 685, 685, 988], [990, 990, 1027, 1027, 1159], [1161, 1161, 1181, 1181, 1253], [1255, 1255, 1279, 1279, 1441], [1443, 1443, 1508, 1508, 1692], [1695, 1695, 1740, 1740, 1780], [1782, 1782, 1807, 1807, 1977], [1981, 1981, 2016, 2016, 2040], [2043, 2043, 2083, 2083, 2150], [2153, 2153, 2191, 2191, 2362], [2364, 2395, 2459, 2459, 2637], [2639, 2639, 2722, 2722, 2835], [2840, 2934, 2963, 2963, 3006], [3008, 3044, 3085, 3085, 3156], [3158, 3158, 3193, 3193, 3232], [3233, 3317, 3338, 3338, 3906], [3910, 3910, 3958, 3958, 4425], [4427, 4540, 4571, 4571, 4797], [4800, 4800, 4874, 4874, 5135], [5138, 5138, 5180, 5180, 5479], [5482, 5482, 5538, 5538, 9413]], "test": "untested"}
{"id": "MtXGDf", "name": "Water Landscape", "author": "jimmikaelkael", "description": "My first procedural landscape: a water land.", "tags": ["sea", "water", "rocks", "lanscape"], "likes": 13, "viewed": 2219, "published": "Public", "date": "1425640102", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// many thanks to IQ for his useful articles !\n\nvec3 sunColor = vec3(1.8, 1.1, 0.6);\nvec3 skyColor = vec3(0.4, 0.6, 0.85);\nvec3 sunLightColor = vec3(1.5, 1.25, 0.9);\nvec3 skyLightColor = vec3(0.15, 0.2, 0.3);\nvec3 indLightColor = vec3(0.4, 0.3, 0.2);\nvec3 cloudsColor = vec3(1.0, 1.0, 1.0);\nvec3 horizonColor = vec3(0.7, 0.75, 0.8);\nvec3 fogColorB = vec3(0.7, 0.8, 0.9);\nvec3 fogColorR = vec3(0.8, 0.7, 0.6);\n\nvec3 sunDirection = normalize(vec3(0.6, 0.8, 0.5));\n\nfloat cloudsHeight = 800.0;\nfloat cloudsDensity = 0.3;\nfloat cloudsCover = 0.2;\n\nfloat noiseT(in vec2 p) {\n    return texture(iChannel0, p / 256.0, -100.0).x * 2.0 - 1.0;\n}\n\nfloat noiseW(in vec2 p) {\n    return texture(iChannel0, (p - 16.0) / 256.0, -100.0).x;\n}\n\nfloat fBm(in vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    for(int i = 0; i < 4; i++) {\n        sum += amp * noiseT(p);\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    return sum;\n}\n\nfloat fBmC(in vec2 p) {\n    float sum = 0.0;\n    float amp = 1.0;\n    for(int i = 0; i < 5; i++) {\n        sum += amp * noiseT(p);\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    return sum;\n}\n\nfloat fBmW(in vec2 p) {\n    float sum = 0.0;\n    float amp = 0.5;\n    for(int i = 0; i < 5; i++) {\n        sum += amp * noiseT(p);\n        amp *= 0.5;\n        p *= 2.0;\n    }\n    return sum * 0.2;\n}\n\nfloat raymarchTerrain(in vec3 ro, in vec3 rd, in float tmin, in float tmax) {\n    float t = tmin;\n    for (int i = 0; i < 300; i++) {\n        vec3 p = ro + rd * t;\n        float d = p.y - fBm(p.xz);\n        if (d < (0.001 * t) || t > tmax)\n            break;\n        t += 0.2 * d;\n    }\n    return t;\n}\n\nvec3 getTerrainNormal(in vec3 p, float t) {\n    float eps = 0.025;\n    return normalize(vec3(fBm(vec2(p.x - eps, p.z)) - fBm(vec2(p.x + eps, p.z)),\n                          2.0 * eps,\n                          fBm(vec2(p.x, p.z - eps)) - fBm(vec2(p.x, p.z + eps))));\n}\n\nvec3 getWaterNormal(in vec3 p, float t) {\n    float eps = 0.025;\n    return normalize(vec3(fBmW(vec2(p.x - eps, p.z)) - fBmW(vec2(p.x + eps, p.z)),\n                          2.0 * eps,\n                          fBmW(vec2(p.x, p.z - eps)) - fBmW(vec2(p.x, p.z + eps))));\n}\n\nfloat raymarchAO(in vec3 ro, in vec3 rd, float tmin) {\n    float ao = 0.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        float t = tmin + pow(i / 5.0, 2.0);\n        vec3 p = ro + rd * t;\n        float d = p.y - fBm(p.xz);\n        ao += max(0.0, t - 0.5 * d - 0.05);\n    }\n    return 1.0 - 0.4 * ao;\n}\n\nfloat raymarchWaterAO(in vec3 ro, in vec3 rd, float tmin) {\n    float ao = 0.0;\n    for (float i = 0.0; i < 5.0; i++) {\n        float t = tmin + pow(i / 5.0, 2.0);\n        vec3 p = ro + rd * t;\n        float d = p.y - fBmW(p.xz);\n        ao += max(0.0, t - 0.5 * d - 0.05);\n    }\n    return 1.0 - 0.4 * ao;\n}\n\nfloat raymarchShadow(in vec3 ro, in vec3 rd, float tmin, float tmax) {\n    float sh = 1.0;\n    float t = tmin;\n    for(int i = 0; i < 50; i++) {\n        vec3 p = ro + rd * t;\n        float d = p.y - fBm(p.xz);\n        sh = min(sh, 16.0 * d / t);\n        t += 0.5 * d;\n        if (d < (0.001 * t) || t > tmax)\n            break;\n    }\n    return sh;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n    vec2 p = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n\n    vec3 eye = vec3(0.0, 2.0, 1.0);\n    vec2 rot = 6.2831 * (vec2(0.0, 0.25) + vec2(1.0, 0.25) * (iMouse.xy - iResolution.xy * 0.5) / iResolution.x);\n    eye.yz = cos(rot.y) * eye.yz + sin(rot.y) * eye.zy * vec2(-1.0, 1.0);\n    eye.xz = cos(rot.x) * eye.xz + sin(rot.x) * eye.zx * vec2(1.0, -1.0);\n\n    vec3 ro = eye + vec3(cos(iTime * 0.1) * 1.25, sin(iTime * 0.1) * 0.5 + 0.15, iTime * 0.5);\n    ro.y += 2.5;\n    vec3 ta = vec3(0.0, -0.75, 0.0);\n\n    // build camera matrix\n    vec3 cw = normalize(ta - eye);\n    vec3 cu = normalize(cross(vec3(0.0, 1.0, 0.0), cw));\n    vec3 cv = normalize(cross(cw, cu));\n    mat3 cam = mat3(cu, cv, cw);\n\n    // compute ray direction\n    vec3 rd = cam * normalize(vec3(p.xy, 1.0));\n\n    // the powerful sun dot\n    float sunDot = clamp(dot(sunDirection, rd), 0.0, 1.0);\n\n    // terrain marching\n    float tmin = 0.1;\n    float tmax = 50.0;\n    float t = raymarchTerrain(ro, rd, tmin, tmax);\n    vec3 color = vec3(0.0);\n    if (t < tmax) {\n        vec3 tpos = ro + rd * t;\n\n        if (tpos.y < 0.15 - sin(iTime) * 0.005) {\n            tpos += -rd * (tpos.y / rd.y);\n            tpos += fBmW(tpos.xz + iTime * 0.15) - fBmW(tpos.xz + 32.0 - iTime * 0.15);\n            vec3 tnorm = getWaterNormal(tpos, t);\n            vec3 ref = reflect(rd, tnorm);\n            vec2 p = tpos.xz + vec2(ref.x + ref.z, ref.y - ref.z);\n            float surface = noiseW(p * 0.5) * noiseW(p) * noiseW(p * 4.0) * noiseW(p * 5.0) * noiseW(p * 6.0) * noiseW(p * 8.0);\n            // light from skydome\n            float sky = clamp(pow(0.5 + 0.5 * tnorm.y, 100.0), 0.0, 1.0);\n            // water AO\n            float occ = clamp(raymarchWaterAO(tpos, tnorm, 0.25), 0.0, 1.0);\n            // terrain shadows on water\n            float sha = 0.25 * clamp(raymarchShadow(tpos, sunDirection, 0.5, 50.0), 0.0, 1.0);\n            // amount of sun reflecting\n            float sun = 10.0 * sha * clamp(pow(dot(sunDirection, ref), 1000.0), 0.0, 1.0);\n\n            // water\n            color = vec3(sky * 0.01 + sun * 0.7 + 0.02 + surface, sky * 0.02 + sun * 0.6 + 0.05 + surface, sky * 0.05 + sun * 0.4 + 0.035 + surface) * occ;\n            color = mix(color, pow(vec3(sha), vec3(1.0, 0.8, 0.8)), 0.05);\n            // foam\n            float foam = fBmC(32.0 * tpos.xz) * 0.4 + 0.2;\n            color = mix(color, 0.75 * vec3(1.0), 0.5 * smoothstep(0.66 + cos(iTime) * 0.01, 1.0, foam));\n            foam = fBmC(16.0 * tpos.xz) * 0.3 + 0.2;\n            color = mix(color, 0.75 * vec3(1.0), 0.5 * smoothstep(0.43 + cos(iTime) * 0.01, 1.0, foam));\n\n        } else {\n            vec3 tnorm = getTerrainNormal(tpos, t);\n\n            // light from sun direction\n            float sun = clamp(dot(sunDirection, tnorm), 0.0, 1.0);\n            // light from skydome\n            float sky = clamp(0.5 + 0.5 * tnorm.y, 0.0, 1.0);\n            // indirect light reflected back in opposite direction of the sun\n            float ind = clamp(dot(vec3(-sunDirection.x, 0.0, -sunDirection.z), tnorm), 0.0, 1.0);\n            // raymarching AO\n            float occ = clamp(raymarchAO(tpos, tnorm, 0.1), 0.0, 1.0);\n            // raymarching penumbra shadows\n            float sha = clamp(raymarchShadow(tpos, sunDirection, 0.5, 50.0), 0.0, 1.0);\n            // light color\n            vec3 lightColor = 1.2 * sun * sunLightColor;\n            lightColor *= pow(vec3(sha), vec3(1.0, 1.2, 1.5));\n            lightColor += 0.7 * sky * skyLightColor * occ;\n            lightColor += 0.3 * ind * indLightColor * occ;\n            \n            // rock\n            color = texture(iChannel0, tpos.xz * 0.7).xyz;\n            color = mix(0.2 * vec3(0.25, 0.2, 0.15), color, 0.2); // gray with dots from noise\n            color = mix(0.15 * vec3(0.25, 0.2, 0.15), color, 2.0 * texture(iChannel0, 0.002 * vec2(tpos.x + noiseT(tpos.xz) * 80.0, tpos.y * 80.0 + noiseT(tpos.xz) * 8.0)).x); // stripes\n            color = mix(0.15 * vec3(0.15, 0.2, 0.05), color, (tpos.y + 0.0));\n            color *= 1.0 * lightColor;\n        }\n\n        // fog\n        vec3 fogColor = mix(fogColorB, fogColorR, pow(sunDot, 4.0));\n        color = mix(color, 0.8 * fogColor, 1.0 - exp(-0.0005 * t * t));\n\n    } else {\n        // sky and sun\n        float sky = clamp(0.6 * (1.0 - 0.8 * rd.y), 0.0, 1.0);\n        float diffuse = clamp(0.4 * sunDot, 0.0, 1.0);\n        color = sky * skyColor + pow(sunDot, 800.0) * sunColor + diffuse * skyLightColor;\n\n        // clouds\n        t = (cloudsHeight - ro.y) / rd.y;\n        if (t > 0.0) {\n            vec3 pos = ro + rd * t;\n            pos.z += iTime * 20.0;\n            float clouds = fBmC(0.0025 * pos.xz) * cloudsDensity + cloudsCover;\n            color = mix(color, mix(cloudsColor * 1.1, sunColor + diffuse * sunLightColor, 0.25), 0.8 * smoothstep(0.1, 0.9, clouds));\n        }\n\n        // horizon\n        color = mix(color, horizonColor, pow(1.0 - rd.y, 4.0));\n    }\n\n    // gamma correction\n    vec3 gamma = vec3(1.0 / 2.2);\n    fragColor = vec4(pow(color, gamma), 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MtXGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 544, 569, 569, 635], [637, 637, 662, 662, 725], [727, 727, 749, 749, 918], [920, 920, 943, 943, 1112], [1114, 1114, 1137, 1137, 1312], [1314, 1314, 1391, 1391, 1616], [1618, 1618, 1661, 1661, 1887], [1889, 1889, 1930, 1930, 2160], [2162, 2162, 2216, 2216, 2464], [2466, 2466, 2525, 2525, 2774], [2776, 2776, 2846, 2846, 3126], [3128, 3128, 3185, 3185, 8220]], "test": "untested"}
{"id": "XdfXRN", "name": "Tether: Blur Effect", "author": "jonobr1", "description": "http://tether.plaid.co.uk/ is an interactive web application where the track is accompanied by a series of graphic shapes that gradually evolve as the music progresses. This is one effect that is composited on top of the 2D visualization.", "tags": ["gradient", "metaball", "vignette", "smooth"], "likes": 4, "viewed": 2087, "published": "Public API", "date": "1427151674", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * @author jonobr1 / http://jonobr1.com\n * https://creativecommons.org/publicdomain/zero/1.0/\n */\n\nfloat noise(vec2 x) {\n\treturn sin(1.5 * x.x) * sin(1.5 * x.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\n\n\t// time / speed\n\tfloat time = iTime / 2.0;\n\t\n\tfloat c = cos(time), s = sin(time);\t\n\tvec2 metaballs[4];\n\n\tvec4 gray = vec4(0.1, 0.1, 0.1, 1.0);\n\t\n\tvec4 sum = vec4(0.0);\n\tfloat radius = iResolution.y * 3.0;\n\t\n\t// TODO: Create uniforms from this\n\tmetaballs[0] = vec2(c * 200. + 300., s * 150. + 200.);\n\tmetaballs[1] = vec2(c * 250. + 350., sin(time * 0.25) * 100. + 200.);\n\tmetaballs[2] = vec2(cos(time * 0.33) * 300. + 350., sin(time * 1.5) * 150. + 200.);\n\tmetaballs[3] = vec2(s * 200. + 300., c * 150. + 200.);\t\n\n\t// Add all the metaball data up\n\tfor (int i = 0; i < 4; i++) {\n\t\tsum += mix(sum, gray, radius / distance(fragCoord.xy, metaballs[i]));\n\t}\n\n\t// Smooth out contrasts in metaballs\n\tfloat t = (sum.r + sum.g + sum.b) / 3.0;\n\tsum = mix(gray, sum, t);\n\tsum = 1.0 - pow(sum, vec4(0.1));\n\t\n\t// Add Vignette\n\tvec4 vignette = vec4(0.0);\n\tvignette.a = clamp(1.0 - pow((iResolution.y / 2.0) / (distance(fragCoord.xy, iResolution.xy / 2.0)), 0.33), 0., 1.);\n\n\t// Add Noise\n//\tsum = vec4(mix(sum.rgb, vignette.rgb, vignette.a), 1.0);\n//\tsum *= noise(fragCoord.xy);\n\t\n\tfragColor = sum;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdfXRN.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[0, 103, 124, 124, 167], [169, 169, 226, 245, 1316]], "test": "untested"}
{"id": "Xl23zR", "name": "[NV15] UFBs", "author": "andr00", "description": "Who are these mysterious invaders? What do they want?", "tags": ["space", "nv15", "unidentified"], "likes": 0, "viewed": 1029, "published": "Public API", "date": "1426863086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash2( vec2 p ) {\n\treturn texture( iChannel0, (p+0.5)/256.0, -100.0 ).xy;\n}\n\nvoid rY(inout vec3 p, float a) {\n\tfloat c,s;vec3 q=p;\n\tc = cos(a); s = sin(a);\n\tp.x = c * q.x + s * q.z;\n\tp.z = -s * q.x + c * q.z;\n}\n\nfloat sphere(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s) {\n    return length(max(abs(p) - s, 0.0));\n}\n\nfloat mod1(inout float x, float m) {\n\tfloat r = floor(x/m);\n\tx = mod(x,m) - 0.5 * m;\n\treturn r;\n}\n\nfloat aUfb(vec3 pos) {\n    return \n\t\tmax(\n        min(\n        sphere(pos - vec3(-1.0,0.0,0.0), 2.0)\n        ,sphere(pos - vec3(1.0,0.0,0.0), 2.0)\n\t\t),\n       box(pos - vec3(0.0, 1.9,1.0), vec3(3.0,1.0,3.0))\n        )\n        ;\t\n\n}\n\nfloat regularUfbs(vec3 pos) {\n\tpos.x -= iTime * 5.0;\n\tpos.y += 7.1;\n\tmod1(pos.x, 12.0);\n\tmod1(pos.z, 12.0);\n\trY(pos, iTime * 0.5);\n    return aUfb(pos);\n}\n\nvoid wavey( inout vec3 p )\n{\n\tp.y += (sin(length(p-vec3(100.0,0.0,-100.0)) - iTime * 5.0) * 0.1)\n\t\t+ sin(length(p-vec3(-100.0,0.0,-100.0)) - iTime * 5.0) * 0.1\n;\n}\n\nfloat xzplane(vec3 pos,float y) {\n\treturn abs(pos.y - y);\n}\n\nfloat waterplane(vec3 pos) {\n\twavey(pos);\n\treturn xzplane(pos,12.0);\n}\n\nfloat distFunc(vec3 pos) {\n    return min(regularUfbs(pos),waterplane(pos));\n}\n\nvec3 distNorm(vec3 pos) {\n    const vec2 eps = vec2(0.0, 0.1);\n    return normalize(vec3(\n\t\t\t distFunc(pos + eps.yxx) - distFunc(pos - eps.yxx),\n\t\t\t distFunc(pos + eps.xyx) - distFunc(pos - eps.xyx),\n\t\t\t distFunc(pos + eps.xxy) - distFunc(pos - eps.xxy)));\n}\n\nvec4 lightUfb(vec3 pos, vec3 lig, vec3 rayDir) {\n\tvec3 normal = distNorm(pos);\n\n\tfloat ndl = clamp( dot(normal, lig), 0.0, 1.0 );\n\tfloat diffuse = max(0.0, dot(-rayDir, normal));\n//\tvec3 bcolor = vec3(1.0); // NASA\n  vec3 bcolor = vec3(0.92, 0.82, 0.63); // strangely peachy\n//\tvec3 bcolor = vec3(0.92, 0.82, 0.01); // maybe these are minions\n\n    vec3 color = bcolor * 0.1 + bcolor * ndl + ndl * 0.05 * pow(clamp(dot(normalize(-rayDir+lig),normal),0.0,1.0),1.0);\n\n\treturn vec4(color, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = fragCoord.xy / iResolution.xx;    \n    float t = iTime;\n\n\tvec3 cameraOrigin = vec3(2.0, 4.0, 2.0);\n\n    // You probably want to zero this out if you're viewing this in VR\n    vec2 cameraNoise = hash2(vec2(iTime * 0.0001, iTime));\n\n    vec3 cameraTarget = vec3(cameraNoise.xy * pow(sin(iTime),2.0) + vec2(0.0,3.0), 0.0);\n       \n    vec3 upDirection = normalize(vec3(0.1 - cameraNoise.x * 0.3, 1.0, 0.0));\n\n\tvec3 cameraDir = normalize(cameraTarget - cameraOrigin);    \n    \n\tvec3 cameraRight = normalize(cross(upDirection, cameraOrigin));\n\tvec3 cameraUp = cross(cameraDir, cameraRight);\n\tvec2 screenPos = -1.0 + 2.0 * fragCoord.xy / iResolution.xy; \n\tscreenPos.x *= iResolution.x / iResolution.y;\n\n\tvec3 rayDir = normalize(cameraRight * screenPos.x + cameraUp * screenPos.y + cameraDir);\n\n\n\tconst int MAX_ITER = 100; // 30 = eerie\n\tconst float MAX_DIST = 800.0; \n\tconst float EPSILON = 0.001;\n\n\tfloat totalDist = 0.0;\n\tvec3 pos = cameraOrigin;\n\tfloat dist = EPSILON;\n\n    vec2 cCoord = vec2(0.5,0.5);\n    \n    float d2 = pow(length(p-cCoord),2.0);\n\n    float moreShade = clamp(0.5 - abs(0.3 - d2),0.0,1.0);\n    vec4 halo = vec4(moreShade * 0.2);\n\n\n\tfloat reflectcount = 0.0;    \n\tfloat ix = 0.0;\n\tconst float iterStep = 1.0 / float(MAX_ITER);\n\n\tfor (float ix = 0.0; ix <= 1.0; ix += iterStep) {\n\n\t    if ((dist < EPSILON) || (totalDist > MAX_DIST))\n     \t   break;\n\n        dist = distFunc(pos);\n        totalDist += dist;\n        pos += dist * rayDir; \n\n        vec3 lig = normalize( vec3(5.0, -1.4, 2.0) );\n\t\t\n        if (dist < EPSILON) {\n            if(waterplane(pos) < EPSILON && (reflectcount < 1.0)) {\n\t\t\treflectcount += 1.0;\n\n\t\t\tpos.y -= 0.04; // corny\n\t\t\trayDir = reflect(rayDir, distNorm(pos));\n\t\t\tdist = distFunc(pos);\n            } else {\n                // it's a ufb              \n\t            fragColor = lightUfb(pos, lig, rayDir);            \n\t\t\t   fragColor += vec4(ix);\n\t\t  }\n\n        } else {\n\t\t\tfragColor = vec4(ix,ix,ix*0.8 + 0.2,1.0);\n\t\t}\n\t}\n\tfragColor += halo;\n    \n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl23zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 80], [82, 82, 114, 114, 215], [217, 217, 248, 248, 276], [278, 278, 305, 305, 348], [350, 350, 386, 386, 447], [449, 449, 471, 471, 680], [682, 682, 711, 711, 836], [838, 838, 866, 866, 1001], [1003, 1003, 1036, 1036, 1062], [1064, 1064, 1092, 1092, 1134], [1136, 1136, 1162, 1162, 1214], [1216, 1216, 1241, 1241, 1474], [1476, 1476, 1524, 1524, 1968], [1971, 1971, 2028, 2028, 4033]], "test": "untested"}
{"id": "Xl2GzD", "name": "findoff's-sincos2", "author": "findoff", "description": "sin cos play", "tags": ["findoffssincos"], "likes": 2, "viewed": 120, "published": "Public", "date": "1427318829", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define DO_DISCARD\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float x = (uv.x-0.5);\n    float y = (uv.y-0.5);\n    vec4 tex = texture(iChannel0, uv, 0.);\n    bool do_disort = true;mod(iTime,10.)<5.;\n    \n    if(do_disort) {\n    \ty *= sin(tex.r+x*60.);\n        x *= 1.+sin(tex.g+y*(40.+sin(iTime*0.25)*20.));\n    } else {\n    \ty *= sin(x*60.);\n        //x *= 1.+sin(y*60.);\n        x *= 1.+sin(y*(40.+sin(iTime*0.25)*20.));\n    }\n    \n    y *= (iResolution.y/iResolution.x);\n    float r;\n    //r = (sin(iTime*1.)+1.)/2.;\n    r = (sin(iTime*1.)+1.)/2. *0.2+0.2;\n    r = sqrt(x*x+y*y)*2./r;\n    float br = r*1.;\n    float e = 0.5;\n    float f = 5.;\n    br = 1./( e+ ((br<e)?(e-br):(br-e)) *f);\n    fragColor = vec4(0.4, ((sin(iTime*2.)+1.)/2.)*0.1+2., 0.9, 1.)*br;\n#if defined(DO_DISCARD)\n    if(br<0.7)\n        fragColor = vec4(0.,0.5,0.,1.);// discard;\n#endif\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2GzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 79, 79, 923]], "test": "untested"}
{"id": "Xl2Gzm", "name": "wavez", "author": "isosphere", "description": "shadertoy test", "tags": ["2d", "test", "sinus"], "likes": 1, "viewed": 131, "published": "Public", "date": "1427729668", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float value = sin(fragCoord.x / 100.0 + iTime * 5.0) * (iResolution.y / 2.0) + iResolution.y / 2.0 - fragCoord.y;\n    float value2 = sin(fragCoord.x / 100.0 + iTime * 3.0) * (iResolution.y / 2.0) + iResolution.y / 2.0 - fragCoord.y;\n    float value3 = cos(fragCoord.x / 100.0 + iTime * 2.0) * (iResolution.y / 2.0) + iResolution.y / 2.0 - fragCoord.y;\n    float thickness = 2.0;\n    float full_1 = abs(value - value2);\n    if (value2 < thickness && value > -thickness)\n        fragColor = vec4(value / full_1, 0.0, 0.0, 1.0);    \n    \n    if (value < thickness && value2 > -thickness)\n        fragColor += vec4(0.0, value2 / full_1, 0.0, 1.0);\n    \n    float full_2 = abs(value3 - value2);\n    if (value3 < thickness && value2 > -thickness)\n        fragColor += vec4(0.0, 0.0, value2 / full_2, 1.0);   \n    // v2 below    \n    \n    if (value2 > thickness && value3 > -thickness)\n        fragColor += vec4(full_2 / value2 * 0.4, 0.0, 0.0, 1.0) / 2.0;     \n    \n    if (value > thickness && value2 > -thickness)\n        fragColor += vec4(0.0, 0.0 , full_1 / value2 * 0.4, 1.0);   \n    \n    if (value2 < thickness && value < -thickness)\n        fragColor = vec4(value2 / value * 0.3,  (value3 / value2)* 0.5, value / value2 * 0.3, 1.0);  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xl2Gzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1388]], "test": "untested"}
{"id": "XlB3zW", "name": "Xor - Infinite Voronoi Noise", "author": "Xor", "description": "My first voronoi noise shader.\nRemade in 2016.\nUpdated again in 2021", "tags": ["2d", "voronoi", "simple", "xor"], "likes": 8, "viewed": 399, "published": "Public", "date": "1427117295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float h1(vec2 p)\n{\n \treturn fract(cos(p.x*89.42-p.y*75.7)*343.42);\n}\nvec2 h2(vec2 p)\n{\n \treturn fract(cos(p*mat2(89.4,-75.7,-81.9,79.6))*343.42);; \n}\nfloat voronoi(vec2 n,float s)\n{\n    float i = 0.0;\n    float dis = 2.0;\n    for(int x = -1;x<=1;x++)\n    for(int y = -1;y<=1;y++)\n    {\n        vec2 p = floor(n/s)+vec2(x,y);\n        float d = length(h2(p)+vec2(x,y)-fract(n/s));\n        if (dis>d)\n        {\n            dis = d;\n            i = h1(p);\n        }\n    }\n    return i;\n\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 coord = fragCoord.xy+iTime*32.0;\n\tfragColor = vec4(vec3(voronoi(coord,32.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlB3zW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 68], [69, 69, 86, 86, 149], [150, 150, 181, 181, 485], [486, 486, 543, 543, 634]], "test": "untested"}
{"id": "XlBGRw", "name": "Julia Island", "author": "paf31", "description": "Messing around", "tags": ["fractal"], "likes": 2, "viewed": 116, "published": "Public", "date": "1427423313", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 stepj(in vec2 cx, in vec2 p) {\n    return vec2(cx.x * cx.x - cx.y * cx.y + p.x, cx.x * cx.y + cx.y * cx.x + p.y);\n}\n\nfloat iter(vec2 cx) \n{\n    for (int i = 0; i < 200; i++) {\n        float s = iTime;\n        float r = 0.48;\n    \tfloat t = s;\n           \n    \tvec2 p = vec2(r * cos(t) - 0.25, r * sin(t));\n           \n        cx = stepj(cx, p);\n    }\n  \n    return length(cx);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    vec2 cx = fragCoord.xy / iResolution.xy * 3.0 - vec2(1.5, 1.5);\n    \n    float d = iter(cx) / iter (stepj(cx, vec2(0.0, 0.0)));\n    \n    fragColor = vec4(d * 0.45, d * 0.05, d * 0.95, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBGRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 120], [122, 122, 144, 144, 386], [388, 388, 445, 445, 652]], "test": "untested"}
{"id": "XlBGRz", "name": "atomic motion", "author": "kig", "description": "Putting motion blur to use with lots of shake and fury. #shadeADay for 2015-03-15", "tags": ["2d", "motionblur", "shadeaday"], "likes": 24, "viewed": 987, "published": "Public", "date": "1426464993", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MOTION_BLUR\n\nfloat lineSegDist(vec2 uv, vec2 lineDir, vec2 linePoint, float r) {\n    vec2 ba = -lineDir * r;\n    vec2 pa = uv - linePoint + ba;\n    ba *= 2.0;\n    return length(pa - ba*clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0));\n}\n\nfloat aa(float dist, float threshold)\n{\n    float pixelSize = 2.0 / iResolution.y;\n\treturn dist < threshold-pixelSize ? 0.0 : min(1.0, 1.0-(threshold-dist)/pixelSize);\n}\n\nfloat scene(vec2 uv, float t)\n{\n    vec2 p = vec2(sin(t*40.3), cos(t*10.0)*0.4);\n\n    vec2 v = normalize(vec2(sin(t*8.0), cos(t*8.0)));\n\tvec2 p2 = vec2(sin(1.0+t*50.0), cos(0.7+t*24.0)*0.4);\n\n    vec2 p3 = vec2(sin(t*37.3+2.0)*1.2, sin(t*2.0)*0.2+cos(1.0+t*21.0)*0.4);\n\n    float r = (0.3);\n    vec2 p4 = vec2(cos(t*60.0), sin(t*64.0)) * r*2.5;\n    vec2 p5 = vec2(-cos(t*60.0+3.14159*2.0*0.3333), sin(t*65.0+3.14159*2.0*0.3333)) * r*2.0;\n    vec2 p6 = vec2(cos(t*50.0+3.14159*2.0*0.6666), sin(t*55.0+3.14159*2.0*0.6666)) * r;\n    vec2 p7 = vec2(cos(t*181.0)*0.03, cos(t*81.4)*0.02+sin(t*42.0)*0.02);\n\n    return min(aa(length(uv-p6), 0.03*(1.0+0.5*sin(t*50.0+3.14159*2.0*0.6666))),\n           min(aa(length(uv-p5), 0.04*(1.0+0.5*-sin(t*60.0+3.14159*2.0*0.3333))),\n           min(aa(length(uv-p4), 0.05*(1.0+0.5*sin(t*60.0))),\n           min(aa(length(uv-p3), 0.03),\n           min(aa(length(uv-p), 0.05),\n           min(aa(abs(length(uv-p7)-0.18-0.01*cos(t*150.0)), 0.01+0.0001*tan(0.1*t)),\n               aa(lineSegDist(uv, v, p2, 0.5), 0.05)\n              ))))));\n}\n\nfloat hash( vec2 v ) {\n    return texture(iChannel0, v, 0.0).r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(iResolution.x/iResolution.y, 1.0) * (-1.0 + 2.0*fragCoord.xy / iResolution.xy);\n\t#ifdef MOTION_BLUR\n\t    fragColor = vec4(0.0);\n        for (float i=0.0; i<12.0; i++) {\n            float r = hash(mod(fragCoord+vec2(i,0.0), 64.0) / 64.0);\n            fragColor += (1.0-scene(uv, iTime+(1.0/58.5)*((i+r)/12.0))) * vec4(abs(uv)+0.3,0.5+0.5*sin(20.0*iTime),1.0);\n        }\n        fragColor /= 12.0;\n    #else\n\t\tfragColor = (1.0-scene(uv, iTime)) * vec4(abs(uv)+0.3,0.5+0.5*sin(iTime),1.0);\n    #endif\n}", "image_inputs": [{"id": "4sf3Rn", "previewfilepath": "/media/ap/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0a40562379b63dfb89227e6d172f39fdce9022cba76623f1054a2c83d6c0ba5d.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlBGRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 88, 88, 238], [240, 240, 279, 279, 409], [411, 411, 442, 442, 1478], [1480, 1480, 1502, 1502, 1545], [1547, 1547, 1604, 1604, 2120]], "test": "untested"}
{"id": "XlfGDf", "name": "Phase Engine", "author": "mpcomplete", "description": "Creating patterns by combining different geometric transforms onto a point on a circle.", "tags": ["transforms"], "likes": 7, "viewed": 1319, "published": "Public API", "date": "1427164494", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define DEBUG 1\n#define time (iTime*.9)\n\n// 2D rotation matrix.\nmat2 rotate(float angle)\n{\n    return mat2(\n        vec2( cos(angle), sin(angle)),\n        vec2(-sin(angle), cos(angle)));\n}\n\n// Transform a point on square to a circle.\nvec2 mapSquare(in vec2 p)\n{\n    vec2 ap = abs(p);\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return r*vec2(cos(angle), sin(angle));\n}\n\n// Make a pattern of squares in a repeating grid.\nvec2 dupSquares(in vec2 p)\n{\n    vec2 ap = abs(sin(p*6.));\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return r*vec2(cos(angle), sin(angle));\n}\n\n// Duplicate pattern in dupSquaresConcentric squares.\nvec2 dupSquaresConcentric(in vec2 p)\n{\n    vec2 ap = abs(p);\n    float r = max(ap.x, ap.y);\n    float angle = atan(p.y, p.x);\n\n    return sin(3.*r)*vec2(cos(angle), sin(angle));\n}\n\n// Duplicate pattern in a repeating grid.\nvec2 dupGrid(in vec2 p)\n{\n    return abs(sin(p*4.));\n}\n\nfloat numPhases = 6.;\nvec2 getTransform(in vec2 p, float t)\n{\n    int which = int(mod(t, numPhases));\n\n    if (which == 0) {\n        p = mapSquare(p);\n        p = pow(vec2(.3), abs(p));\n        p = rotate(time*.1)*p;\n        p += .1*sin(time*.2);\n        p = dupSquares(p);\n        p -= .1*sin(time*.2);\n        p = dupSquares(p);\n    } else if (which == 1) {\n        p = pow(abs(p), vec2(.5));\n        p = mapSquare(p);\n        p = pow(abs(p), vec2(3.));\n        p += .1*sin(time*.2);\n        p = dupSquares(p);\n        p = rotate(time*.1)*p;\n        p = dupGrid(p);\n        p -= .1;\n        p = rotate(time*.1)*p;\n    } else if (which == 2) {\n        p = mapSquare(p);\n        p = dupGrid(p*.5);\n        p += .2 + .1*sin(time*.2);\n        p = dupSquares(p);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n    } else if (which == 3) {\n        p = mapSquare(p);\n        p = dupGrid(p*.7);\n        p = dupSquaresConcentric(p);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n        p += .3*sin(time*.2);\n        p = pow(abs(p), vec2(.5));\n        p = dupSquares(p);\n    } else if (which == 4) {\n        p = pow(vec2(.3), abs(p));\n        p = mapSquare(p);\n        p = dupGrid(p);\n        p = dupSquaresConcentric(p);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n        p += .3*sin(time*.2);\n        p = pow(abs(p), vec2(.5));\n        p = dupSquares(p);\n    } else if (which == 5) {\n        p = pow(vec2(.3), abs(p));\n        p = mapSquare(p);\n        p = dupGrid(p);\n        p = dupSquaresConcentric(p);\n        p += .3*sin(time*.2);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n        p = pow(abs(p), vec2(.5));\n        p = dupSquares(p);\n    }\n#if 0  // REJECTS\n    } else {\n        p = mapSquare(p);\n        p = dupSquares(p*.5);\n        p = dupGrid(p);\n        p = dupSquares(p*.5);\n        p = rotate(time*.1)*p;\n        p = dupSquares(p);\n\n    }\n#endif\n    return p;\n}\n\nvec2 applyTransform(in vec2 p)\n{\n    float t = time*.05;\n#ifdef DEBUG\n    if (iMouse.z > .001) t = iMouse.x/iResolution.x * numPhases;\n#endif\n    float pct = smoothstep(0., 1., mod(t, 1.));\n    return mix(getTransform(p, t), getTransform(p, t+1.), pct);\n}\n\nmat3 rotation(float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * a.x * a.x + c,        oc * a.x * a.y - a.z * s,  oc * a.z * a.x + a.y * s,\n                oc * a.x * a.y + a.z * s,  oc * a.y * a.y + c,        oc * a.y * a.z - a.x * s,\n                oc * a.z * a.x - a.y * s,  oc * a.y * a.z + a.x * s,  oc * a.z * a.z + c);\n}\n\n// Fuzzy unit circle.\nfloat circle(in vec2 p)\n{\n    float r = length(p);\n    float angle = atan(p.y, p.x);\n    if (1.-r < 0.)\n        return 0.;\n    return step(r, 1.) * pow(1.-r, .5);\n}\n\nvec3 recolor(vec3 c)\n{\n    vec3 axis = vec3(0.454,0.725,0.372);\n    c = rotation(2.0*length(axis)*sin(time), axis)*c;\n    return c;\n}\n\nvec4 applyColor(vec2 p)\n{\n    float c1 = circle(p);\n#if 0\n    float c2 = circle(p*1.7);\n    float c3 = circle(p*1.3);\n#else\n    float c2 = circle(p*1.7 + .25*vec2(sin(time*.6), cos(time*.4)));\n    float c3 = circle(p*1.3 - .15*vec2(sin(time*.5), cos(time*.5)));\n#endif\n\treturn vec4(recolor(vec3(c1, c2, c3)), 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    p *= 1.3;\n\n    p = applyTransform(p);\n\tfragColor = applyColor(p);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlfGDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[43, 66, 92, 92, 190], [192, 236, 263, 263, 396], [398, 448, 476, 476, 617], [619, 673, 711, 711, 852], [854, 896, 921, 921, 950], [974, 974, 1013, 1013, 2670], [2877, 2877, 2909, 2909, 3132], [3134, 3134, 3173, 3173, 3565], [3567, 3589, 3614, 3614, 3753], [3755, 3755, 3777, 3777, 3888], [3890, 3890, 3915, 3915, 4206], [4208, 4208, 4265, 4265, 4434]], "test": "untested"}
{"id": "Xlj3Rm", "name": "sines - ps3 crossbar like", "author": "the23", "description": "variant of https://www.shadertoy.com/view/MtB3zw . Created by a colleague...", "tags": ["sine", "colormix", "saturated"], "likes": 20, "viewed": 504, "published": "Public", "date": "1427717885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float speed = 0.8;\nconst float widthFactor = 4.0;\n\nvec3 calcSine(vec2 uv, \n              float frequency, float amplitude, float shift, float offset,\n              vec3 color, float width, float exponent)\n{\n    float angle = iTime * speed * frequency + (shift + uv.x) * 6.2831852;\n    \n    float y = sin(angle) * amplitude + offset;\n    \n    float scale = pow(smoothstep(width * widthFactor, 0.0, distance(y, uv.y)), exponent);\n    \n    return color * scale;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    color += calcSine(uv, 0.20, 0.15, 0.0, 0.5, vec3(0.0, 0.0, 1.0), 0.2, 15.0);\n    color += calcSine(uv, 0.40, 0.15, 0.0, 0.5, vec3(0.0, 1.0, 1.0), 0.1, 17.0);\n    color += calcSine(uv, 0.60, 0.15, 0.0, 0.5, vec3(0.5, 0.8, 1.0), 0.05, 23.0);\n\n    color += calcSine(uv, 0.18, 0.07, 0.0, 0.7, vec3(0.0, 0.0, 0.7), 0.2, 15.0);\n    color += calcSine(uv, 0.26, 0.07, 0.0, 0.7, vec3(0.0, 0.6, 0.7), 0.1, 17.0);\n    color += calcSine(uv, 0.46, 0.07, 0.0, 0.7, vec3(0.2, 0.4, 0.7), 0.05, 23.0);\n\n    color += calcSine(uv, 0.58, 0.05, 0.0, 0.3, vec3(0.0, 0.0, 0.7), 0.2, 15.0);\n    color += calcSine(uv, 0.34, 0.05, 0.0, 0.3, vec3(0.0, 0.6, 0.7), 0.1, 17.0);\n    color += calcSine(uv, 0.52, 0.05, 0.0, 0.3, vec3(0.2, 0.4, 0.7), 0.05, 23.0);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlj3Rm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[57, 57, 212, 212, 466], [468, 468, 525, 525, 1373]], "test": "untested"}
{"id": "Xlj3zR", "name": "Tet-Oct-Tet Interpolation", "author": "paniq", "description": "Linear interpolation of eight cube corners by treating the cube as a composite of two tetrahedra and one octahedron. Press P to change the cutting plane.", "tags": ["mattdamon"], "likes": 6, "viewed": 1265, "published": "Public API", "date": "1426639314", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec2 m;\n\n// keys are javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nbool ReadKey( int key )//, bool toggle )\n{\n\tbool toggle = true;\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime;\n    float d = 3.0;\n\tcamPos = vec3(d*sin(an),1.2,d*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nfloat cube(vec3 p, float r) {\n    vec3 o = abs(p);\n\tfloat s = o.x;\n\ts = max(s, o.y);\n\ts = max(s, o.z);\n\treturn s-r;\n}\n\nfloat sdf_round_box(vec3 p, vec3 b, float r) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nfloat doModel( vec3 p ) {\n    \n    float mouse_delta = clamp(m.x,0.0,1.0)*2.0-1.0;\n    float plane = p.y  + mouse_delta;\n    if (ReadKey(Key_P)) {\n\t\tplane = ((p.x+p.y+p.z) + mouse_delta)/sqrt(3.0);\n       \tplane = abs(plane)-0.01;\n    }\n    \n    return max(cube(p,1.0), plane);\n  \n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\n\n#define TEST 0\n\nvec3 hue2rgb(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nfloat gray(vec3 color) {\n    return dot(vec3(1.0/3.0), color);\n}\n\n// given three factors in the range (0..1), return the eight interpolants \n// -xyzw, +xyzw required to mix the corners of a cube\nvoid trilinear_interpolants(in vec3 p, out vec4 s, out vec4 t) {\n    vec3 q = 1.0 - p;\n\n    vec2 h = vec2(q.x,p.x);\n    vec4 k = vec4(h*q.y, h*p.y);\n    s = k * q.z;\n    t = k * p.z;\n}\n\n// given three interpolants (0..1) within a tet-oct-tet cube, return the \n// weights required for interpolation.\nvoid fcc_interpolants(vec3 x, out vec4 a, out vec4 b) {\n    float q = x.x+x.y+x.z;\n    if (q < 1.0) {\n        a = vec4(1.0-q,x.x,x.y,0.0);\n        b = vec4(x.z, 0.0, 0.0, 0.0);\n    } else if (q < 2.0) {    \n        vec3 t = x.yzx + x.zxy - 1.0;\n        float d = (1.0 - (abs(t.x)+abs(t.y)+abs(t.z)))/6.0;\n        vec3 u = d+max(-t,0.0);\n        vec3 v = d+max(t,0.0);\n        a = vec4(0.0, u.x, u.y, v.z);\n        b = vec4(u.z, v.y, v.x, 0.0);\n    } else {\n        vec3 t = 1.0-x;\n        a = vec4(0.0, 0.0, 0.0, t.z);\n        b = vec4(0.0, t.y, t.x, q-2.0);\n    }\n}\n\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    // color cube with components swapped\n    // to bring out the discontinuities\n    const vec3 c0 = vec3(1.0,1.0,0.0);\n    const vec3 c1 = vec3(0.0,1.0,0.0);\n    const vec3 c2 = vec3(1.0,0.0,0.0);\n    const vec3 c3 = vec3(0.0,0.0,0.0);\n    const vec3 c4 = vec3(1.0,1.0,1.0);\n    const vec3 c5 = vec3(1.0,0.0,1.0);\n    const vec3 c6 = vec3(0.0,1.0,1.0);\n    const vec3 c7 = vec3(0.0,0.0,1.0);\n    \n    pos = vec3(pos.x, -pos.z, pos.y);\n    \n    vec4 s,t;\n    vec3 col = vec3(0.0);\n\n    vec3 p = pos*0.5+0.5;\n\n    //trilinear_interpolants(p, s, t);\n    fcc_interpolants(p,s,t);\n    \n    col = c0*s.x + c1*s.y + c2*s.z + c3*s.w\n    \t+ c4*t.x + c5*t.y + c6*t.z + c7*t.w;\n    \n    if (ReadKey(Key_C)) {\n    \treturn hue2rgb(gray(col)*4.0);\n    } else {\n        return col;\n    }\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        col = doMaterial( pos, nor );\n\t}\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xlj3zR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[10, 891, 933, 933, 1075], [1077, 1409, 1492, 1492, 1612], [1615, 1846, 1873, 1873, 1908], [1910, 1910, 1939, 1939, 2027], [2029, 2029, 2075, 2075, 2115], [2117, 2117, 2144, 2144, 2175], [2177, 2177, 2204, 2204, 2234], [2236, 2236, 2261, 2261, 2518], [2520, 2890, 2915, 2915, 3024], [3026, 3026, 3050, 3050, 3090], [3092, 3221, 3285, 3285, 3405], [3407, 3520, 3575, 3575, 4086], [4088, 4088, 4133, 4215, 4910], [4912, 4912, 4962, 4962, 5379], [5381, 5381, 5413, 5413, 5825], [5827, 5827, 5891, 5891, 6069], [6071, 6071, 6128, 6128, 7052]], "test": "untested"}
{"id": "XljGRW", "name": "wavy 2d pattern prints", "author": "public_int_i", "description": "idk", "tags": ["2d", "pattern", "weird", "some"], "likes": 2, "viewed": 149, "published": "Public", "date": "1427253435", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    \n    uv *= 100.;\n    uv += vec2(cos(uv.x/2.)*5.,cos(uv.y/2.)*5.);\n    \n\tfloat f = (cos(uv.x)*.2+cos(uv.y)*.2)*cos((uv.x+uv.y)*length(uv))*5.;\n    if (f > .7) {\n        f-=.7;\n        if (cos((uv.x+uv.y+iTime*10.)*sin(uv.y)) > .5) {\n        fragColor = vec4(.85,.26,1.39,1.)*f;\n        } else {\n        fragColor = vec4(.1,.2,.3,1.)*f;    \n        }\n    } else {\n        fragColor = vec4(.0);\n    }\n}", "image_inputs": [{"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XljGRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 501]], "test": "untested"}
{"id": "XllGDs", "name": "2d line distance - shadeADay", "author": "kig", "description": "Finally figured out the distance from a point to a 2D line :D\n#shadeADay for 12 March 2015", "tags": ["2d", "antialias", "shadeaday"], "likes": 8, "viewed": 342, "published": "Public", "date": "1426224693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tThere are probably some mistakes in the below.\n\n\tImagine a triangle with uv and linePoint as two of the vertices.\n\tThe other sides of the triangle are the line defined by lineDir\n\tthat passes through linePoint, and the normal of the line that \n\tpasses through uv.\n\n\n\t              uv_\n\t             /|  \\\n\t            /b|  |\n\t           /  |  |-- distance of uv to line\n\t          /a  | _/\n\tlinePoint --------------- > lineDir\n\t              |\n\t              v\n\t       normal of lineDir\n\n\n\tuv - linePoint = hypotenuse of the triangle\n\n\tFrom the hypotenuse, we can solve the distance side with a bit of trig.\n\n\tsin(a) * length(hypotenuse) = distance\n\tor\n\tcos(b) * length(hypotenuse) = distance\n\n\tTo get the angles, we can use the dot product:\n\tdot(u, v) = cos(angle_u_to_v) * length(u) * length(v)\n\n\ta = acos( dot(lineDir, hypotenuse) / length(lineDir) / length(hypotenuse) );\n\tb = acos( dot(normalOfLineDir, hypotenuse) / length(normalOfLineDir) / length(hypotenuse) );\n\n\tAnd for 2D lines, the normal is (-y, x):\n\n\tnormalOfLineDir = vec2(-lineDir.y, lineDir.x)\n\n\tNow let's plug all this into the distance equation that uses the angle b:\n\n\n\tcos(b) * length(hypotenuse) = distance\n\n\tnml = vec2(-lineDir.y, lineDir.x)\n\thyp = uv - linePoint\n\n\tcos( acos( dot(nml, hyp) * (1.0 / length(nml)) * (1.0 / length(hyp)) ) ) * length(hyp) = distance\n\n\t> cos and acos cancel out\n\n\tdot(nml, hyp) * (1.0 / length(nml)) * (1.0 / length(hyp)) * length(hyp) = distance\n\n\t> (1.0 / length(hyp)) * length(hyp) = 1.0\n\t> and let's assume that lineDir and nml are unit vectors, so length(nml) = 1.0\n\t> 1.0 / length(nml) = 1.0\n\n\tdot(nml, hyp) * 1.0 * 1.0 = distance\n\tdot(nml, hyp) = dot(vec2(-lineDir.y, lineDir.x), uv - linePoint) = distance\n\n\t> This is a signed distance though. For unsigned distance, use abs(distance)\n\n\n\tAnd there we go.\n\n*/\nfloat lineDistCos(vec2 uv, vec2 lineDir, vec2 linePoint) {\n    return abs(dot(vec2(-lineDir.y, lineDir.x), uv - linePoint));\n}\n\n// sin(x) = sqrt(1.0 - cos^2(x)) | http://www.wolframalpha.com/input/?i=relation+between+sin%28x%29+and+cos%28x%29\nfloat lineDistSin(vec2 uv, vec2 lineDir, vec2 linePoint) {\n    float len = length(uv - linePoint);\n\tfloat c = clamp(dot(lineDir, uv - linePoint) / len, -1.0, 1.0);\n    return sqrt(1.0 - c*c) * len;\n}\n\nfloat crossLen(vec2 a, vec2 b)\n{\n    return abs(a.x*b.y - a.y*b.x);\n}\n\nfloat crossLen(vec3 a, vec3 b)\n{\n   \tfloat x = a.y*b.z - a.z*b.y;\n    float y = a.z*b.x - a.x*b.z;\n    float z = a.x*b.y - a.y*b.x;\n    return sqrt(x*x + y*y + z*z);\n}\n\nvec4 closestPoint(vec4 uv, vec4 lineDir, vec4 linePoint)\n{\n    vec4 uvL = uv - linePoint;\n    return linePoint + dot(uvL, lineDir) * lineDir;\n}\n\n// Cross product line distance from valentingalea in comments, thanks!\n// cross(a,b) = normal(a,b) * sin(theta) * length(a) * length(b) \nfloat lineDistCross(vec2 uv, vec2 lineDir, vec2 linePoint) {\n    return crossLen(lineDir, uv-linePoint); \n    \n    // With vec3 cross product\n    //return crossLen(vec3(lineDir, 0.0), vec3(uv-linePoint, 0.0));\n    \n    // With vec4 normal calculation (???)\n    //return length(\n    //    vec4(uv, 0.0, 0.0) - \n    //    closestPoint(vec4(uv, sin(iTime), cos(iTime*0.2)), normalize(vec4(lineDir, -0.3*cos(iTime*2.0), sin(iTime*0.2)*1.0)), vec4(linePoint, 0.3, 0.2))\n    //    );\n\n    // With vec2 normal calculation\n    //vec2 uvL = uv - linePoint;\n    //return length(uvL - dot(uvL, lineDir)*lineDir);\n}\n\nfloat lineDist(vec2 uv, vec2 lineDir, vec2 linePoint) {\n    float mt = mod(iTime*5.0, 3.0);\n    return mt > 1.0\n        ? (mt > 2.0 ? lineDistCross(uv, lineDir, linePoint) : lineDistSin(uv, lineDir, linePoint))\n        : lineDistCos(uv, lineDir, linePoint);\n}\n\n// Optimized lineSegDist from iq in the comments, thanks!\nfloat lineSegDist(vec2 uv, vec2 lineDir, vec2 linePoint, float r) {\n    vec2 ba = -lineDir * r;\n    vec2 pa = uv - linePoint + ba;\n    ba *= 2.0;\n    return length(pa - ba*clamp( dot(pa, ba)/dot(ba, ba), 0.0, 1.0));\n\n    /*\n    vec2 nml = vec2(-lineDir.y, lineDir.x);\n    vec2 uvL = linePoint - uv;\n\tfloat signedDist = dot(nml, uvL);\n    float t = length(uvL - nml * signedDist);\n    if (t > r) {\n        return length(uvL - lineDir*r*sign(dot(uvL, lineDir)));\n    } else {\n        return abs(signedDist);\n    }\n\t*/\n}\n\nfloat aa(float dist, float threshold)\n{\n    float pixelSize = 2.0 / iResolution.y;\n\treturn dist < threshold-pixelSize ? 0.0 : 1.0-(threshold-dist)/pixelSize;\n}\n\nfloat scene(vec2 uv)\n{\n    vec2 v = normalize(vec2(sin(iTime), cos(iTime)));\n    vec2 p = vec2(sin(iTime*2.3), cos(iTime)*0.4);\n\tvec2 p2 = vec2(sin(1.0+iTime*2.3), cos(0.7+iTime)*0.4);\n\n    return min(\n        aa(lineDist(uv, v, p), 0.01),\n    \taa(lineSegDist(uv, v, p2, 0.3*abs(sin(iTime*3.0))), 0.05)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = vec2(iResolution.x/iResolution.y, 1.0) * (-1.0 + 2.0*fragCoord.xy / iResolution.xy);\n\tfragColor = (1.0 - scene(uv)) * vec4(abs(uv)+0.3,0.5+0.5*sin(iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XllGDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1824, 1882, 1882, 1950], [1952, 2067, 2125, 2125, 2266], [2268, 2268, 2300, 2300, 2337], [2339, 2339, 2371, 2371, 2506], [2508, 2508, 2566, 2566, 2651], [2653, 2790, 2850, 2850, 3393], [3395, 3395, 3450, 3450, 3654], [3656, 3714, 3781, 3781, 4231], [4233, 4233, 4272, 4272, 4392], [4394, 4394, 4416, 4416, 4705], [4707, 4707, 4764, 4764, 4937]], "test": "untested"}
{"id": "Xls3Rl", "name": "Wave it", "author": "TomoAlien", "description": "Uh.\n\nI don't know what to say about this :P", "tags": ["2d", "wave", "blue", "purple"], "likes": 4, "viewed": 229, "published": "Public", "date": "1425484670", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float x = uv.x*2.0;\n    float y = uv.y;\n    float n = iTime*4.0;\n    float bom = (x*32.0+atan(y*8.0-4.+sin(n/4.0+sin(x*2.0+sin(y*2.0)))*4.)*32.0+n);\n    float abe = cos((bom)/4.);\n    float clo = clamp(abe,0.,1.);\n    float cla = clamp(-abe,0.,1.);\n\tfragColor = vec4(-clo*0.75+abs(sin(x-n/3.))*cla*0.7,sin(x+n/4.)*cla,abs(abe),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xls3Rl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 438]], "test": "untested"}
{"id": "XlS3zD", "name": "Basic BW Mandelbrot", "author": "DimitryK", "description": "Yet another mandelbrot for the masses...", "tags": ["fractal"], "likes": 1, "viewed": 123, "published": "Public", "date": "1427151956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    float t = iTime;\n    \n    float zoom = 0.65 + 0.38*cos(0.3*t);\n    zoom = pow( zoom,8.0);\n    uv *= zoom;\n    float x = -1.1649;\n    float y = 0.25587;\n    uv += vec2(x - x * zoom,y - y * zoom);\n    //uv += vec2(x,y);\n    \n    float def = 0.02;\n    float scale = (1.0/(t*10.0));\n    scale = scale < def ? scale > 0.00001 ? scale : 0.00001 : def;\n    \n    vec2 z = vec2(0.0);\n    vec3 c = vec3(0.0);\n    float val = 0.0;\n    \n    for(int i=0; i < 512; i++)\n    {\n        if( (z.x*z.x + z.y*z.y) >= 4.0 ) break;\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + uv;\n        if( (z.x*z.x + z.y*z.y) >= 2.0 )\n        {\n        \tc = vec3(sin(float(i)*0.13));\n        }\n    }\n    \n\tfragColor = vec4(c,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlS3zD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 831]], "test": "untested"}
{"id": "XlX3Ws", "name": "Faster distance march", "author": "moshev", "description": "Marching using linear approximation", "tags": ["raymarch"], "likes": 1, "viewed": 149, "published": "Public", "date": "1426095476", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float TAU = 6.2831853;\nconst float TAU_2 = 3.141592653589793;\nconst float TAU_4 = 1.5707963267948966;\nconst float GRAD_EPS = 0.0001;\n\nfloat asqrt(float x) {\n\treturn x > 0.0 ? sqrt(x) : 0.0;\n}\n\n\n\nvec4 ellipj(float u, float m) {\n    const float eps = 0.0001;\n    float ai, b, phi, t, twon;\n    float a[9];\n    float c[9];\n    \n    if (m < eps) {\n        t = sin(u);\n        b = cos(u);\n        ai = 0.25 * m * (u - t * b);\n    \treturn vec4(\n            t - ai * b,\n      \t\tb + ai * t,\n      \t\t1.0 - 0.5 * m * t * t,\n      \t\tu - ai\n            );\n    }\n    \n    if (m >= 1.0 - eps) {\n    \tai = 0.25 * (1.0 - m);\n    \tb = cosh(u);\n    \tt = tanh(u);\n    \tphi = 1.0 / b;\n    \ttwon = b * sinh(u);\n    \treturn vec4(\n            t + ai * (twon - u) / (b * b),\n      \t\tphi - ai * t * phi * (twon - u),\n      \t\tphi + ai * t * phi * (twon + u),\n      \t\t2.0 * atan(exp(u)) - TAU_4 + ai * (twon - u) / b\n            );\n    }\n    \n    a[0] = 1.0;\n    a[1] = 0.0;\n    a[2] = 0.0;\n    a[3] = 0.0;\n    a[4] = 0.0;\n    a[5] = 0.0;\n    a[6] = 0.0;\n    a[7] = 0.0;\n    a[8] = 0.0;\n    \n    c[0] = sqrt(m);\n    c[1] = 0.0;\n    c[2] = 0.0;\n    c[3] = 0.0;\n    c[4] = 0.0;\n    c[5] = 0.0;\n    c[6] = 0.0;\n    c[7] = 0.0;\n    c[8] = 0.0;\n    \n    b = sqrt(1.0 - m);\n    twon = 1.0;\n    for (int i = 0; i < 8; i++) {\n        ai = a[i];\n        c[i + 1] = 0.5 * (ai - b);\n        a[i + 1] = 0.5 * (ai + b);\n        b = asqrt(ai * b);\n        twon *= 2.0;\n    }\n    phi = twon * a[8] * u;\n    for (int i = 0; i < 8; i++) {\n        b = phi;\n   \t\tt = c[8 - i] * sin(b) / a[8 - i];\n    \tphi = 0.5 * (asin(t) + phi);\n    }\n    t = cos(phi);\n    return vec4(sin(phi), t, t / cos(phi - b), phi);\n}\n\nconst float SQRT2 = 1.4142135623730951;\nconst float SQRT2_2 = 0.7071067811865476;\n\nvec2 rotate(vec2 v, float alpha) {\n    float c = cos(alpha);\n    float s = sin(alpha);\n    mat2 m = mat2(c, s, -s, c);\n    return m * v;\n}\n\nvec2 quincuncial_intermediate(vec2 p) {\n    if (abs(p.x) > 2.0 || abs(p.y) > 1.0) {\n        return vec2(0.0);\n    }\n    \n}\n\nfloat mixfix(float a, float b, float t) {\n    // this piece is nonsensical but without it\n    // we get a black screen, fuck you nVidia\n    // fuck you with a rusty rake\n    // (pls fix your floating point)\n    float u;\n    t = clamp(t, 0.0, 1.0);\n    u = 1.0 - t;\n    u = clamp(u, 0.0, 1.0);\n    return a * u + b * t;\n}\n\n/*acutally a half-space*/\nfloat plane(vec3 p, vec3 c, vec3 n) {\n    return dot(n, p) - dot(n, c);\n}\n\nfloat dplaneray_dt(vec3 p, vec3 c, vec3 n, vec3 ray) {\n    return dot(n, ray);\n}\n\n/*cube with 3 lengths*/\nfloat cube(vec3 p, vec3 c, vec3 vr) {\n    vec3 bmin = c - vr;\n    vec3 bmax = c + vr;\n    vec3 dmin = bmin - p;\n    vec3 dmax = p - bmax;\n    vec3 max1 = max(dmin, dmax);\n    vec2 max2 = max(max1.xy, max1.z);\n    return max(max2.x, max2.y);\n}\n\nfloat dcuberay_dt(vec3 p, vec3 c, vec3 vr, vec3 ray) {\n    // differentiate everything and you're just left with\n    // finding the max coordinate of -ray\n    // which is what you'd expect given that we're\n    // computing the intersection of 6 \"plane\"s\n    // note: actually half-spaces\n    vec3 max1 = -ray;\n    vec2 max2 = max(max1.xy, max1.z);\n    return -max(max2.x, max2.y);\n}\n\n/*proper cube*/\nfloat cube(vec3 p, vec3 c, float r) {\n    vec3 vr = vec3(r, r, r);\n    return cube(p, c, vr);\n}\n\nfloat dcuberay_dt(vec3 p, vec3 c, float r, vec3 ray) {\n    vec3 vr = vec3(r, r, r);\n    return dcuberay_dt(p, c, vr, ray);\n}\n\n/*sphere*/\nfloat sphere(vec3 p, vec3 c, float r) {\n    return distance(c, p) - r;\n}\n\nfloat dsphereray_dt(vec3 p, vec3 c, float r, vec3 ray) {\n    // okay so the derivative for the sphere is a bit shitty\n    // vector from p + t*ray to centre\n    vec3 vt = p - c;\n    return dot(vt, ray) / length(vt);\n}\n\n/*torus*/\n/*rc - radius to centre of tube*/\n/*rt - radius of tube*/\nfloat torus(vec3 p, vec3 c, vec3 n, float rc, float rt) {\n    // equation is\n    // (rmax - sqrt(dot(p.xy))) ** 2 + z**2 - rmin**2\n    // for torus symmetric around z\n    float z = dot(p, n) - dot(c, n);\n    vec3 p1 = p - z * n;\n    float xy2 = dot(p1 - c, p1 - c);\n    float b = rc - sqrt(xy2);\n    return sqrt(b * b + z * z) - rt;\n}\n\nfloat dtorusray_dt(vec3 p, vec3 c, vec3 n, float rc, float rt, vec3 ray) {\n    // lol goodenough\n    float e = 0.5 * GRAD_EPS;\n    return (torus(p + e * ray, c, n, rc, rt) - torus(p - e * ray, c, n, rc, rt)) / GRAD_EPS;\n}\n\n/*cylinder with spherical caps at ends*/\n/* a, b - centres of the caps, r - radius */\nfloat cylinder_caps(vec3 p, vec3 a, vec3 b, float r) {\n    vec3 n = normalize(b - a);\n    vec3 p1 = p - a;\n    float d = dot(n, p1);\n    vec3 c = d * n;\n    if (dot(n, c) < 0.0) {\n        return sphere(p, a, r);\n    }\n    if (dot(n, c) > distance(a, b)) {\n        return sphere(p, b, r);\n    }\n    float daxis = length(p1 - d * n);\n    return daxis - r;\n}\n\nfloat dcylinder_capsray_dt(vec3 p, vec3 a, vec3 b, float r, vec3 ray) {\n    // nope not calculating this today\n    return -1.0;\n}\n\n/* tile vec3 around the centre with radius r */\nvec3 tile(vec3 p, vec3 r) {\n    return 2.0 * (fract((p + r) / (2.0 * r)) - vec3(0.5, 0.5, 0.5)) * r;\n}\n\nfloat timing(float seconds) {\n    return fract(iTime / seconds);\n}\n\nfloat timing2(float seconds) {\n    return 1.0 - 2.0 * abs(timing(seconds) - 0.5);\n}\n\nfloat dist_object_1(vec3 p) {\n    return max(\n        mix(\n        \ttorus(p, vec3(0.1, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.5, 0.0625),\n\t        cube(p, vec3(0.1, 0.0, 0.0), 0.45),\n\t        timing2(30.0)),\n        -sphere(p, vec3(0.5, 0.5, 0.5), 0.43));\n}\n\nvoid dist_dt_object_1(out float dist, out float dt, in vec3 p, in vec3 ray) {\n    float d1 = mix(\n        torus(p, vec3(0.1, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.5, 0.0625),\n        cube(p, vec3(0.1, 0.0, 0.0), 0.45),\n        timing2(30.0));\n    float d2 = -sphere(p, vec3(0.5, 0.5, 0.5), 0.43);\n    if (d1 > d2) {\n        dist = d1;\n        dt = mix(\n        \tdtorusray_dt(p, vec3(0.1, 0.0, 0.0), vec3(0.0, 1.0, 0.0), 0.5, 0.0625, ray),\n        \tdcuberay_dt(p, vec3(0.1, 0.0, 0.0), 0.45, ray),\n        \ttiming2(30.0));\n    } else {\n        dist = d2;\n        dt = -dsphereray_dt(p, vec3(0.5, 0.5, 0.5), 0.43, ray);\n    }\n    dt = -1.0;\n}\n\nfloat dist_object_2(vec3 p) {\n\treturn plane(p, vec3(0.0, -0.7, 0.0), vec3(0.0, 1.0, 0.0));\n}\n\nfloat dist_object_any(vec3 p) {\n    return min(dist_object_1(p), dist_object_2(p));\n}\n\nfloat ddist_object_2ray_dt(vec3 p, vec3 ray) {\n\tfloat e = GRAD_EPS * 0.5;\n    return (dist_object_2(p + e * ray) - dist_object_2(p - e * ray)) / GRAD_EPS;\n}\n\n/* gradient */\nvec3 grad_1(vec3 p) {\n    float eps = GRAD_EPS;\n    return normalize(vec3(\n                dist_object_1(p - vec3(eps, 0.0, 0.0)) - dist_object_1(p + vec3(eps, 0.0, 0.0)),\n                dist_object_1(p - vec3(0.0, eps, 0.0)) - dist_object_1(p + vec3(0.0, eps, 0.0)),\n                dist_object_1(p - vec3(0.0, 0.0, eps)) - dist_object_1(p + vec3(0.0, 0.0, eps))));\n}\n\n/* gradient */\nvec3 grad_2(vec3 p) {\n    float eps = GRAD_EPS;\n    return normalize(vec3(\n                dist_object_2(p - vec3(eps, 0.0, 0.0)) - dist_object_2(p + vec3(eps, 0.0, 0.0)),\n                dist_object_2(p - vec3(0.0, eps, 0.0)) - dist_object_2(p + vec3(0.0, eps, 0.0)),\n                dist_object_2(p - vec3(0.0, 0.0, eps)) - dist_object_2(p + vec3(0.0, 0.0, eps))));\n}\n\n/* trace from point p along ray r */\nvec4 trace_1(vec3 p, vec3 r) {\n    vec3 p1 = p;\n    float epsilon = 2.0e-04;\n    float t = 0.0;\n    float d;\n    float ddray_dt;\n    dist_dt_object_1(d, ddray_dt, r, p1);//, r, d, ddray_dt);\n    for (int i = 0; i < 128; i++) {\n        // escape if too long\n        if (dot(p1 - p, p1 - p) > 16.0 * 16.0) {\n            return vec4(p1, 0.0);\n        }\n        if (abs(d) < epsilon) {\n            break;\n        }\n        t = t - d / ddray_dt;\n        p1 = p + t * r;\n        dist_dt_object_1(d, ddray_dt, r, p1);\n    }\n    if (abs(d) > epsilon) {\n        return vec4(p1, 0.0);\n    } else {\n        return vec4(p1, 1.0);\n    }\n}\n\n/* trace from point p along ray r */\nvec4 trace_2(vec3 p, vec3 r) {\n    vec3 p1 = p;\n    float epsilon = 2.0e-04;\n    float t = 0.0;\n    float d;\n    float ddray_dt;\n    d = dist_object_2(p1);//, r, d, ddray_dt);\n    for (int i = 0; i < 64; i++) {\n        // escape if too long\n        if (dot(p1 - p, p1 - p) > 16.0 * 16.0) {\n            return vec4(p1, 0.0);\n        }\n        if (abs(d) < epsilon) {\n            break;\n        }\n        ddray_dt = ddist_object_2ray_dt(p1, r);\n        ddray_dt = clamp(ddray_dt, -1.0, -0.9);\n        t = t - d / ddray_dt;\n        p1 = p + t * r;\n\t    d = dist_object_2(p1);//, r, d, ddray_dt);\n    }\n    if (abs(d) > epsilon) {\n        return vec4(p1, 0.0);\n    } else {\n        return vec4(p1, 1.0);\n    }\n}\n\nvec4 trace_any(vec3 p, vec3 r) {\n    vec3 p1 = p;\n    float epsilon = 2.0e-04;\n    float t = 0.0;\n    float d;\n    d = dist_object_any(p1);//, r, d, ddray_dt);\n    for (int i = 0; i < 64; i++) {\n        // escape if too long\n        if (dot(p1 - p, p1 - p) > 16.0 * 16.0) {\n            return vec4(p1, 0.0);\n        }\n        if (abs(d) < epsilon) {\n            break;\n        }\n        t = t + d;\n        p1 = p + t * r;\n\t    d = dist_object_any(p1);//, r, d, ddray_dt);\n    }\n    if (abs(d) > epsilon) {\n        return vec4(p1, 0.0);\n    } else {\n        return vec4(p1, 1.0);\n    }\n}\n\nvec3 texgen_1(vec3 p, vec3 n) {\n//    return (vec3(1.0, 1.0, 1.0) + n) * 0.5;\n//    return vec3(1.0, 1.0, 1.0);\n    \n    // glTexGen GL_SPHERE_MAP\n    vec3 u = normalize(p);\n    vec3 f = u - 2.0 * dot(n, u) * n;\n    float m = 2.0 * sqrt(f.x * f.x + f.y * f.y + (f.z + 1.0) * (f.z + 1.0));\n    vec2 t = f.xy / m + vec2(0.5, 0.5);\n\n    // :/\n//    float sblue = sin(dot(t, t) * 18 * TAU);\n//    sblue = (sblue + 1) * 0.5;\n    //float sblue = step(0.5, fract((t.x * t.x + t.y * t.y) * 1.5));\n    //float sblue = step(0.5, fract((t.x + t.y) * 1.5));\n    //return mix(srgb(89, 132, 50), srgb(148, 174, 22), sblue);\n    //return mix(srgb(246, 200, 44), srgb(250, 236, 147), sblue);\n    //return vec3(t, 0.3 + 0.4 * timing2(12345));\n    float c = distance(vec2(0.5, 0.5), t) * 1.8;\n    return vec3(1.0, 1.0 - c, 1.0 - c);\n}\n\nvec3 texgen_2(vec3 p, vec3 n) {\n    return vec3(0.5, 0.5, 0.5);\n}\n\nconst vec3 light1 = vec3(-0.0, -1, -0.0);\nconst vec3 light2 = vec3(0.7071067811865475, -0.7071067811865475, -0.0);\nvec3 light3_pos = vec3(-0.2, 0, 2.5);\nvec3 shade_any(vec3 p, vec3 n) {\n    vec3 light3 = normalize(p - light3_pos);\n    vec4 m1 = trace_any(p - light1 * 0.05, -light1);\n    vec4 m2 = trace_any(p - light2 * 0.05, -light2);\n    vec4 m3 = trace_any(light3_pos, light3);\n    m3.xyz -= p;\n    float see1 = 1.0 - m1.w;\n    float see2 = 1.0 - m2.w;\n    float see3 = (1.0 - step(0.01, dot(m3.xyz, m3.xyz)) * m3.w);\n    float factor1 = see1 * dot(n, light1);\n    float factor2 = see2 * dot(n, light2);\n    float factor3 = see3 * dot(n, light3);\n\n/*\n    vec3 light1c = vec3(1, 1, 1);\n    vec3 light2c = vec3(1, 1, 1);\n    vec3 light3c = vec3(1, 1, 1);\n*/\n    vec3 light1c = vec3(0.9, 0.1, 0.1);\n    vec3 light2c = vec3(0.1, 0.9, 0.1);\n    vec3 light3c = vec3(0.1, 0.1, 0.9);\n    // no light shadows only\n//    return c * ((2.0 - m1.w - m2.w) * 2.0 / 3.0 + 1.0 / 3.0);\n    // three lights\n//*\n     return (\n     max(factor1, 0.0) * light1c +\n     max(factor2, 0.0) * light2c +\n     max(factor3, 0.0) * light3c\n     ) / (light1c + light2c + light3c);\n//*/\n    // debug normals\n//    return 0.5 * (vec3(1.0, 1.0, 1.0) + n);\n    // debug shadows\n//    return vec3(see1, see2, see3);\n    // debug space\n//    return 0.5 * (vec3(1.0, 1.0, 1.0) + p);\n}\n\nvec4 go(vec3 p, vec3 ray) {\n    // wavy effect1\n    \n    /*\n    float phi = TAU * 2.0 * (ray.x + ray.y);\n    p.z += sin(phi) * cos(phi) * 0.01;\n    //*/\n\n    // wavy effect2\n    /*\n    float phi = TAU * timing2(15.0);\n    ray.x *= sin(phi + ray.x);\n    //*/\n\n    vec4 q1 = trace_1(p, ray);\n    vec4 q2 = trace_2(p, ray);\n    if (q1.w < 1.0 && q2.w < 1.0) {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    vec3 c;\n    vec3 n;\n    float lq1 = distance(p, q1.xyz);\n    float lq2 = distance(p, q2.xyz);\n    if (q2.w > 0.0 && (lq2 < lq1 || q1.w < 1.0)) {\n        p = q2.xyz;\n        n = grad_2(p);\n        c = texgen_2(p, n);\n    } else {\n        p = q1.xyz;\n        n = grad_1(p);\n        c = texgen_1(p, n);\n    }\n    vec3 lightness = shade_any(p, n);\n    return vec4(lightness * c, 1.0);\n}\n\nvec3 srgb_from_rgb(vec3 rgb) {\n    vec3 a = vec3(0.055, 0.055, 0.055);\n    vec3 ap1 = vec3(1.0, 1.0, 1.0) + a;\n    vec3 g = vec3(2.4, 2.4, 2.4);\n    vec3 ginv = 1.0 / g;\n    vec3 select = vec3(greaterThan(rgb, vec3(0.0031308, 0.0031308, 0.0031308)));\n    vec3 lo = rgb * 12.92;\n    vec3 hi = ap1 * pow(rgb, ginv) - a;\n    return select * hi + (vec3(1.0, 1.0, 1.0) - select) * lo;\n}\n\nvec3 rgb_from_srgb(vec3 srgb) {\n    vec3 a = vec3(0.055, 0.055, 0.055);\n    vec3 ap1 = vec3(1.0, 1.0, 1.0) + a;\n    vec3 g = vec3(2.4, 2.4, 2.4);\n\tvec3 select = vec3(greaterThan(srgb, vec3(0.04045, 0.04045, 0.04045)));\n    vec3 hi = srgb / 12.92;\n    vec3 lo = pow((srgb + a) / ap1, g);\n    return select * hi + (vec3(1, 1, 1) - select) * lo;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 lookat = vec3(0.1, 0.0, 0.0);\n    vec2 angle = vec2(-0.1, 0.0) * TAU;\n    //(iMouse.yx / iResolution.yx - vec2(0.5)) * TAU;\n    vec2 sa = sin(angle);\n    vec2 ca = cos(angle);\n    mat3 rotmat = mat3(\n        vec3( ca.y,  sa.x * sa.y,  ca.x * sa.y),\n        vec3(    0,         ca.x,        -sa.x),\n        vec3(-sa.y,  sa.x * ca.y,  ca.x * ca.y));\n    vec3 e1 = rotmat[0];\n    vec3 e2 = rotmat[1];\n    vec3 e3 = rotmat[2];\n    vec2 pixelcentre = fragCoord;\n    pixelcentre /= max(iResolution.x, iResolution.y);\n    vec2 midpoint = 0.5 * iResolution.xy / max(iResolution.x, iResolution.y);\n    pixelcentre = (pixelcentre - midpoint) * 2.0;\n    vec3 gm = lookat - 2.0 * e3;\n    vec3 p = pixelcentre.x * e1 + pixelcentre.y * e2 + gm;\n    vec3 t = lookat - 2.8 * e3;\n\n    //light3_pos = lookat - light3_pos.x * e1 - light3_pos.z * e3;\n    //light3_pos = (vec4(light3_pos, 1.0)).xyz;\n    //p = (camera * vec4(p, 1.0)).xyz;\n\n    vec3 tr;\n    vec3 ray = normalize(p - t);\n    vec4 result = go(p, ray);\n\tfragColor = vec4(srgb_from_rgb(result.xyz), result.w);\n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlX3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 162, 162, 197], [201, 201, 232, 232, 1669], [1754, 1754, 1788, 1788, 1892], [1894, 1894, 1933, 1933, 2016], [2018, 2018, 2059, 2224, 2338], [2340, 2366, 2403, 2403, 2439], [2441, 2441, 2495, 2495, 2521], [2523, 2547, 2584, 2584, 2789], [2791, 2791, 2845, 3078, 3173], [3175, 3191, 3228, 3228, 3286], [3288, 3288, 3342, 3342, 3412], [3414, 3425, 3464, 3464, 3497], [3499, 3499, 3555, 3655, 3716], [3718, 3786, 3843, 3952, 4120], [4122, 4122, 4196, 4218, 4343], [4345, 4431, 4485, 4485, 4786], [4788, 4788, 4859, 4898, 4917], [4919, 4967, 4994, 4994, 5069], [5071, 5071, 5100, 5100, 5137], [5139, 5139, 5169, 5169, 5222], [5224, 5224, 5253, 5253, 5476], [5478, 5478, 5555, 5555, 6113], [6115, 6115, 6144, 6144, 6207], [6209, 6209, 6240, 6240, 6294], [6296, 6296, 6342, 6342, 6452], [6454, 6469, 6490, 6490, 6838], [6840, 6855, 6876, 6876, 7224], [7226, 7263, 7293, 7293, 7888], [7890, 7927, 7957, 7957, 8634], [8636, 8636, 8668, 8668, 9222], [9224, 9224, 9255, 9370, 10040], [10042, 10042, 10073, 10073, 10107], [10262, 10262, 10294, 10294, 11459], [11461, 11461, 11488, 11718, 12251], [12253, 12253, 12283, 12283, 12634], [12636, 12636, 12667, 12667, 12980], [12982, 12982, 13039, 13039, 14101]], "test": "untested"}
{"id": "XlXGW2", "name": "Acid Tunnel", "author": "mpcomplete", "description": "Playing with tunnel effects.\n\nBased on https://www.shadertoy.com/view/lslGRj .", "tags": ["tunnel"], "likes": 18, "viewed": 1534, "published": "Public API", "date": "1425589867", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define time (iTime*.9)\n\nvec4 gradient(float f)\n{\n    vec4 c = vec4(0);\n\tf = mod(f, 1.5);\n    for (int i = 0; i < 3; ++i)\n        c[i] = pow(.5 + .5 * sin(2.0 * (f +  .2*float(i))), 10.0);\n    return c;\n}\n\nfloat offset(float th)\n{\n    return .5*sin(25.*th)*sin(time);\n}\n\nvec4 tunnel(float th, float radius)\n{\n\treturn gradient(offset(th + .25*time) + 3.*log(3.*radius) - time);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n\tfragColor = tunnel(atan(p.y, p.x), 2.0 * length(p));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 49, 49, 204], [206, 206, 230, 230, 269], [271, 271, 308, 308, 378], [380, 380, 437, 437, 590]], "test": "untested"}
{"id": "XlXGWf", "name": "EiffieBox", "author": "eiffie", "description": "EiffieBox by eiffie... its a box... it says eiffie...  so I called it that.", "tags": ["volumelight"], "likes": 43, "viewed": 6242, "published": "Public API", "date": "1425500649", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define ANIMANDELPRO\n//#define BOXPLORER2\n//#define FRAGMENTARIUM\n#define SHADERTOY\n//#define GLSLSANDBOX\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n\nfloat DERRect(in vec3 z, vec4 radii){return length(max(abs(z)-radii.xyz,0.0))-radii.w;}\nfloat DERect(in vec2 z, vec2 r){return max(abs(z.x)-r.x,abs(z.y)-r.y);}\nfloat DEEiffie(in vec3 z){\n\tfloat d1=DERect(z.yz,vec2(0.25,0.9));//I\n\tfloat d2=min(DERect(z.xz,vec2(0.25,0.9)),min(DERect(z.xz+vec2(0.25,0.7),vec2(0.5,0.2)),DERect(z.xz+vec2(0.25,0.0),vec2(0.5,0.2))));//F\n\tfloat d3=min(DERect(z.xy,vec2(0.25,0.9)),min(DERect(z.xy+vec2(0.25,0.7),vec2(0.5,0.2)),min(DERect(z.xy+vec2(0.25,0.0),vec2(0.5,0.2)),DERect(z.xy+vec2(0.25,-0.7),vec2(0.5,0.2)))));//E\n\treturn min(d1,min(d2,d3));\n}\n\nfloat DE(in vec3 z){\n\treturn max(DERRect(z,vec4(0.95,0.95,0.95,0.05)),-DEEiffie(z));\n}\nfloat sinNoise3d(in vec3 p){\n\tfloat s=0.5,r=0.0;\n\tfor(int i=0;i<3;i++){\n\t\tp+=p+sin(p.yzx*0.8+sin(p.zxy*0.9));\n\t\ts*=0.5;\n\t\tr+=sin(p.z+1.5*sin(p.y+1.3*sin(p.x)))*s;\n\t}\n\treturn r;\n}\nfloat volLiteMask(vec3 rd){\n\tvec3 ar=abs(rd);\n\tvec2 pt;\n\tfloat d=100.0;\n\tif(ar.x>ar.y && ar.x>ar.z)pt=rd.yz/ar.x;\n\telse{\n\t\tif(ar.y>ar.z)pt=rd.xz/ar.y;\n\t\telse {\n\t\t\tpt=rd.xy/ar.z;\n\t\t\td=DERect(pt+vec2(0.25,-0.7),vec2(0.5,0.2));\n\t\t}\n\t\td=min(d,min(DERect(pt+vec2(0.25,0.7),vec2(0.5,0.2)),DERect(pt+vec2(0.25,0.0),vec2(0.5,0.2))));\n\t}\n\td=min(d,DERect(pt,vec2(0.25,0.9)));\n\treturn (d<0.0)?1.0:0.0;\n}\nfloat rand(vec2 c){return fract(sin(c.x+2.4*sin(c.y))*34.1234);}\nmat3 lookat(vec3 fw){\n\tfw=normalize(fw);vec3 rt=normalize(cross(-fw,vec3(0.0,1.0,0.0)));return mat3(rt,cross(rt,fw),fw);\n}\nvec4 scene(vec3 ro, vec3 rd) {\n\tfloat t=0.0,d=0.0;\n\tfor(int i=0;i<48;i++){\n\t\tt+=d=DE(ro+rd*t);\n\t\tif(t>10.0 || d<0.01)break;\n\t}\n\tfloat lt=pow(dot(rd,normalize(-ro)),10.0);\n\tfloat t2=0.2*rand(gl_FragCoord.xy);\n\tvec3 sum=vec3(0.0);\n\tfor(int i=0;i<48;i++){\n\t\tt2+=0.2+t2*t2*0.01;\n\t\t//if((t2>t && d<0.2) || t2>100.0)break;\n        if(t2>t && d<0.2)break;\n        //t2=min(t2,10.0);\n        if(t2>9.0)t2-=0.75+0.25*sin(float(i*2));\n\t\tvec3 vr=normalize(ro+rd*t2);\n\t\tif(vr==vr)sum+=(vr*0.5+0.5)*volLiteMask(vr)*(0.1+0.2*sinNoise3d((ro+rd*t2)));\n\t}\n\tvec3 col=clamp(lt*sum,0.0,1.0);\n\treturn vec4(col,t);\n}\nvoid AnimateCamera(in vec2 uv, in float tym, inout vec3 ro, inout vec3 rd){\n\tro=vec3(cos(tym),sin(tym*0.7),sin(tym))*4.0;\n\trd=lookat(vec3(sin(tym*0.8),cos(tym*0.3),0.0)-ro)*normalize(vec3(uv,1.0));\n}\n#ifdef ANIMANDELPRO\nvarying vec3 dir; //from vertex shader\nuniform vec3 eye; //camera position\nuniform ivec2 size;//size of image in pixels\nuniform float time;//timing\nvoid main(){\n\tvec2 uv=(2.0*gl_FragCoord.xy-size.xy)/size.y;\n\tvec3 ro,rd;\n\t//AnimateCamera(uv, time, ro, rd);\n\tvec3 ro=eye,rd=normalize(dir);\n\tvec4 scn=scene(ro,rd);\n\tgl_FragColor = vec4(scn.rgb,1.0);\n}\n#endif\n#ifdef BOXPLORER2\n//#include \"setup.inc\"\nvoid main(){\n\tvec3 ro,rd;\n\tif (!setup_ray(eye, dir, ro, rd)) return;\n\tvec4 scn=scene(ro,rd);\n\twrite_pixel(dir, scn.a, scn.rgb);\n}\n#endif\n#ifdef FRAGMENTARIUM\n//#include \"3DKn-1.0.1.frag\"\nvec3 color(SRay Ray){\n\tvec4 scn=scene(Ray.Origin, Ray.Direction);\n\treturn scn.rgb;\n}\n#endif\n#ifdef SHADERTOY\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\tvec3 ro,rd;\n\tAnimateCamera(uv, iTime, ro, rd);\n\tvec4 scn=scene(ro,rd);\n\tfragColor = vec4(scn.rgb,1.0);\n}\n#endif\n#ifdef GLSLSANDBOX\nuniform float time;\nuniform vec2 resolution;\nvoid main(){\n\tvec2 uv=(2.0*gl_FragCoord.xy-resolution.xy)/resolution.y;\n\tvec3 ro,rd;\n\tAnimateCamera(uv, time, ro, rd);\n\tvec4 scn=scene(ro,rd);\n\tgl_FragColor= vec4(scn.rgb,1.0);\n}\n#endif\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XlXGWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[86, 155, 192, 192, 242], [243, 243, 275, 275, 314], [315, 315, 341, 341, 733], [735, 735, 755, 755, 821], [822, 822, 850, 850, 1000], [1001, 1001, 1028, 1028, 1393], [1394, 1394, 1413, 1413, 1458], [1459, 1459, 1480, 1480, 1581], [1582, 1582, 1612, 1612, 2176], [2177, 2177, 2252, 2252, 2376]], "test": "untested"}
{"id": "Xt23RR", "name": "Pseudo kleinian fluid", "author": "guil", "description": "A gavoronoise fluidified by a pseudo kleinian vector field\nFluid technique based on Fluid with Obstacles by Effie and 2D fluids by andregc (https://www.shadertoy.com/view/4llGWl)", "tags": ["fluid", "kleinian"], "likes": 19, "viewed": 460, "published": "Public", "date": "1426631369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S.Guillitte\n//Fluid technique based on Fluid with Obstacles by Effie and 2D fluids by andregc (https://www.shadertoy.com/view/4llGWl)\n\n\n#define PI 3.14159265358979\n\n\nfloat hash( in vec3 p ) \n{\n    return fract(sin(p.x*15.32758341+p.y*39.786792357+p.z*59.4583127+7.5312) * 43758.236237153)-.5;\n}\n\nvec3 hash3( in vec3 p )\n{\n    return vec3(hash(p),hash(p+1.5),hash(p+2.5));\n}\n\n//mat2 m2= mat2(.8,.6,-.6,.8);\n\n// Gabor/Voronoi mix 3x3 kernel (some artifacts for v=1.)\nfloat gavoronoi3(in vec3 p)\n{    \n    vec3 ip = floor(p);\n    vec3 fp = fract(p);\n    float f = 12.*PI;//frequency\n    float v = .8;//cell variability <1.\n    float dv = .9;//direction variability <1.\n    vec3 dir = vec3(.1);\n    float va = 0.0;\n   \tfloat wt = 0.0;\n    for (int i=-1; i<=1; i++) \n\tfor (int j=-1; j<=1; j++) \n    for (int k=-1; k<=1; k++)    \n\t{\t\t\n        vec3 o = vec3(i, j, k)-.5;\n        vec3 h = hash3((ip - o));\n        vec3 pp = fp +o  -h;\n        float d = dot(pp, pp);\n        float w = exp(-d*4.);\n        wt +=w;\n        h = dv*h+dir;//h=normalize(h+dir);\n        va += cos(dot(pp,h)*f/v)*w;\n\t}    \n    return va/wt;\n}\n\n\nvec3 field (in vec3 p){\n    p=p/4.;\n\tfor (int i=0; i<=5; i++)p=abs(p)/dot(p,p)-1.;  \n    return p;\n}\n\nfloat noise( vec3 p)\n{   \n    return gavoronoi3(p);\n}\n\n\n\nvec3 euler(vec3 uv, float t) {\n\tt /= 6.;\n\tfor(int i = 0; i < 6; ++i) {\n\t\tuv -= field(uv)*t;\n\t}\n\treturn uv;\n}\n\nvec3 rk4(vec3 uv, float t) {\n    t /= 3.;\n    for(int i = 0; i < 3; ++i) {\n        \n        \tvec3 k1 = -field(uv);\n        \tvec3 k2 = -field(uv + k1*t/2.);\n        \tvec3 k3 = -field(uv + k2*t/2.);\n\t        vec3 k4 = -field(uv + k3*t);\n    \t    uv = uv + t/6.*(k1+2.*k2+2.*k2+k3);\n        \n    }\n\t\n    return uv;\n}\n\nfloat fluid(vec3 uv, float t) {\n\tfloat t1 = t*0.5;\n\tfloat t2 = t1 + 0.5;\n\tvec3 uv1 = rk4(uv, t1);\n\tvec3 uv2 = rk4(uv, t2);\n\tfloat c1 = noise(uv1);\n\tfloat c2 = noise(uv2);\n\treturn 4.*mix(c2,c1,t);\n    \n}\n\n\nfloat map(vec3 p){\n\tfloat t = fract(iTime);\n    return fluid(p,t);\n    \n}\n\n\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\nvec2 iSphere( in vec3 ro, in vec3 rd, in vec4 sph )//from iq\n{\n\tvec3 oc = ro - sph.xyz;\n\tfloat b = dot( oc, rd );\n\tfloat c = dot( oc, oc ) - sph.w*sph.w;\n\tfloat h = b*b - c;\n\tif( h<0.0 ) return vec2(-1.0);\n\th = sqrt(h);\n\treturn vec2(-b-h, -b+h );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tif( iMouse.z>0.0 )m = iMouse.xy/iResolution.xy*3.14;\n    m-=.5;\n\n    // camera\n\n    vec3 ro = vec3(4.);\n    ro.yz*=rot(m.y);\n    ro.xz*=rot(m.x+ 0.1*time);\n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n\n    \n    vec2 tmm = iSphere( ro, rd, vec4(0.,0.,0.,2.) );\n\n\tfloat c;\n    \n   \tif (tmm.x<0.)c = -1.;\n    else c=abs( map(ro+rd*tmm.x)*1.);\n    vec3 col = .3 + .7*sin(vec3(1.,2.,3.)+c);\n    if(c<0.)col=vec3(.4);\n\t\n\t// shade\n    \n    \n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n}\n\t\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt23RR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 267, 293, 293, 395], [397, 397, 422, 422, 474], [508, 566, 595, 595, 1210], [1213, 1213, 1236, 1236, 1313], [1315, 1315, 1337, 1337, 1368], [1372, 1372, 1402, 1402, 1480], [1482, 1482, 1510, 1510, 1795], [1797, 1797, 1828, 1828, 1999], [2002, 2002, 2020, 2020, 2075], [2078, 2078, 2097, 2097, 2144], [2146, 2146, 2208, 2208, 2394], [2396, 2396, 2453, 2453, 3288]], "test": "untested"}
{"id": "Xt23zh", "name": "Orbs of light", "author": "Eddh", "description": "Just playing around with colors and math", "tags": ["2d", "light", "sinus"], "likes": 2, "viewed": 116, "published": "Public", "date": "1426887808", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//useful function from iq\nfloat expStep( float x, float k, float n )\n{\n    return exp( -k*pow(x,n) );\n}\n\nfloat f(float x){\nreturn 1.0/(10.0*x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = vec2(1.0,1.0)/iResolution.xy;\n    vec2 center = vec2(0.5, 0.5);\n    \n    float r = 0.0, g = 0.0, b = 0.0;\n    \n    \n    b = 1.0/(length(uv-center+0.5*vec2(cos(iTime), sin(iTime)))*10.0);\n    g = 1.2*b*b;\n \n        r = 1.2*b*b;\n    b += 1.5*expStep(0.2*sin(iTime*3.0)+length(0.1*sin(iTime*2.5)+uv-center+0.5*vec2(sin(iTime*3.0), cos(iTime*3.0)))*10.0, 3.0+0.7*sin(iTime*50.0), 2.0);\n    g += 0.8*b;\n    r += 0.8*b;\n\tfragColor = vec4(r, g, b,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt23zh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 26, 70, 70, 103], [105, 105, 122, 122, 145], [147, 147, 204, 204, 707]], "test": "untested"}
{"id": "Xt2GRh", "name": "RingsOfFire", "author": "Passion", "description": "fire like effect", "tags": ["2d", "noise", "fire", "turbulence"], "likes": 8, "viewed": 327, "published": "Public", "date": "1426902833", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float t = iTime;\n//noise and hash funtions by iq\nvec2 hash( vec2 p ) \n{                       // rand in [-1,1]\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1. + 2.*fract(sin(p+20.)*53758.5453123);\n}\nfloat noise( in vec2 p ) \n{\n    vec2 i = floor((p)), f = fract((p));\n    vec2 u = f*f*(3.-2.*f);\n    return mix( mix( dot( hash( i + vec2(0.,0.) ), f - vec2(0.,0.) ), \n                     dot( hash( i + vec2(1.,0.) ), f - vec2(1.,0.) ), u.x),\n                mix( dot( hash( i + vec2(0.,1.) ), f - vec2(0.,1.) ), \n                     dot( hash( i + vec2(1.,1.) ), f - vec2(1.,1.) ), u.x), u.y);\n}\n//turbulence fuction from:\n//http://developer.download.nvidia.com/SDK/9.5/Samples/samples.html\n//from: 'Cg Explosion Effect'\n//A lot more pdf/whitepapers there...\nfloat turbulence(vec3 p, int octaves, float lacunarity, float gain)\n{\n    float sum = 0.;\n    float amp = 1.;\n    \n    for(int i=0; i<4; i++) \n    {\n        sum += amp * abs(noise(p.xy));\n        p *= lacunarity;\n        amp *= gain;\n    }\n    \n    return sum;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x*=1.6;\n    uv.x-=.3;\n    //uv.x+=sin(t*.5)/15.+noise(vec2(t,t*.2))/5.;\n    //uv.y+=cos(t)/10.;\n\n    float tb3= turbulence(vec3((uv*(14.))-t*5.,1.0),0,.05,.7);\n\t\n    uv=length((uv)-.5)-vec2(.5,.8+noise(vec2(uv.x,uv.y+tb3))/8.);\n    \n    float tb = turbulence(vec3((uv*(13.))-t,1.0),0,.05,.5); \n    float tb2= turbulence(vec3((uv*(5.))-t*.5,1.0),0,.04,.4);\n\n\ttb=tb+tb2;\n\tfragColor = vec4(uv+tb,0.0,1.0)*1.9;\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2GRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[17, 49, 71, 111, 248], [249, 249, 276, 276, 647], [648, 811, 880, 880, 1073], [1075, 1075, 1132, 1132, 1599]], "test": "untested"}
{"id": "Xt2Gzz", "name": "ngTweet2", "author": "netgrind", "description": "another tweet sized shader", "tags": ["tweet", "netgrind"], "likes": 2, "viewed": 1037, "published": "Public API", "date": "1426662718", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat i=iTime;vec2 uv=sin(fragCoord.xy*.02);float a=atan(uv.y,uv.x);fragColor=vec4(sin(i+a*sin(uv.yxy)*a*length(uv+sin(i+a*a))),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xt2Gzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 194]], "test": "untested"}
{"id": "XtBGzm", "name": "shadeaday ( 3 / 27 / 2015 )", "author": "cabbibo", "description": "seeing what is possible with simple steps", "tags": ["raytrace"], "likes": 2, "viewed": 113, "published": "Public", "date": "1427505239", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_TRACE_STEPS = 50;\n\t\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\nfloat sdSphere( vec3 p, float s , float offset)\n{\n\n\n    float d1 = length(p) - .1*smoothstep(0.0,1.0,iTime);;\n    d1 *= .8;\t\n    \n   // vec3 nP = vec3( x , y , z );\n    return d1 -s;\n}\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec3 centerPos = vec3( .5 , 0. ,0. );\n    \n    vec3 col = vec3( 0. );\n   \n    float oMatch = 1.;\n    float match = 1.;\n    float matchRing = 0.;\n    for( int i = 0; i < NUM_TRACE_STEPS; i++ ){\n       \n        vec3 pos = ro + rd * (float( i ) / MAX_TRACE_DISTANCE);\n        \n        vec3 dif = pos - centerPos;\n        \n        oMatch = match;\n        match = dot( -dif , rd );\n        if( length( dif ) < 1. ){\n         col += vec3( 1. ) * match * triNoise3D( pos / length( dif ), .1 ); ;\n         break;\n        }\n        \n        if( match < 0.  ){\n\n         matchRing += 1.;\n        }\n        \n        if( matchRing == 1. && length( dif )  < 1.3 ){\n        \tcol += vec3( 1. , 0., 0.) * triNoise3D( pos / length( dif ), .1 );\n        }\n        \n        if( matchRing == 2. && length( dif )  < 1.5 ){\n        \tcol += vec3( 0. , 1., 0.) * triNoise3D( pos / length( dif ), .1 );\n        }\n        \n        if( matchRing == 3. && length( dif )  < 1.8 ){\n        \tcol += vec3( 0. , 0., 1.)* triNoise3D( pos / length( dif ) , .1 );\n            break;\n        }\n        \n        \n        \n    }\n    \n\n  \n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtBGzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[330, 382, 404, 404, 429], [430, 430, 451, 451, 531], [567, 619, 662, 662, 965], [968, 968, 1017, 1017, 1152], [1155, 1186, 1250, 1250, 1428], [1430, 1430, 1513, 1513, 1626], [1631, 1631, 1687, 1687, 3367]], "test": "untested"}
{"id": "XtjGRD", "name": "Color Circles", "author": "purton", "description": "Hypnotic color circles.", "tags": ["2d", "circles", "rainbow", "hypnotic"], "likes": 5, "viewed": 323, "published": "Public", "date": "1427391501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(in vec2 pos, in float t, in float mult)\n{\n    vec2 center = vec2(0.5, 0.5 * iResolution.y / iResolution.x);\n    vec2 v = vec2(center.x + cos(t) * 0.1, center.y + sin(t) * 0.1) - pos;\n    \n    float dist2 = dot(v, v);\n    float circles = 0.5 + cos(dist2 * mult) * 0.5;\n    float darkening = smoothstep(0.0, 0.5, 1.0 - length(v) * 2.0);\n    \n    return circles * darkening;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pos = fragCoord.xy / iResolution.x;\n    float t = iTime * 0.25;\n\n    float r = circle(pos, t + 0.0,  100.0 + sin(t * 0.6 + 1.0) * 100.0);\n    float g = circle(pos, t + 0.5,  100.0 + sin(t * 0.6 + 2.0) * 100.0);\n    float b = circle(pos, t + 1.0,  100.0 + sin(t * 0.6 + 3.0) * 100.0);\n    float w = circle(pos, t + 1.5, 1000.0 + sin(t + 4.0) * 200.0) * 0.35;\n    \n    fragColor = vec4(r+w, g+w, b+w, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjGRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 386], [388, 388, 443, 443, 859]], "test": "untested"}
{"id": "XtjGRh", "name": "UK Eclipse", "author": "P_Malin", "description": "Yes, there was a solar eclipse today. This is what it looked like to me from the northwest of England (cloudy).\n", "tags": ["eclipse", "cloudy"], "likes": 11, "viewed": 380, "published": "Public", "date": "1426863706", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// UK Eclipse - @P_Malin\n\n// There was a solar eclipse today. This is what it looked like to me from the northwest of England (cloudy).\n\nconst vec3 sunCol = vec3(1.0, 0.9, 0.66);\nvec3 cloudColA = vec3(0.32, 0.4, 0.6);\nvec3 cloudColB = vec3(0.6, 0.4, 0.5);\nvec3 cloudColC = vec3(0.54, 0.53, 0.46);\n\nfloat kExposure = 1.7;\n\nvec3 sunLight = sunCol.rgb * 10000.0;\n\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat Hash2D(vec2 p)\n{\n\treturn Hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat Noise2D( vec2 p )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = Hash2D( fl + vec2(0.0, 0.0) );\n\tfloat h10 = Hash2D( fl + vec2(1.0, 0.0) );\n\tfloat h01 = Hash2D( fl + vec2(0.0, 1.0) );\n\tfloat h11 = Hash2D( fl + vec2(1.0, 1.0) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat Crescent( const in vec2 uv )\n{    \n    float r= 0.15;\n    float offset = 0.02;\n    float d1 = distance( uv, vec2(0.5, 0.5)) / r - 0.5;\n    float d2 = distance( uv, vec2(0.5 + offset, 0.51)) / r - 0.5;\n    \n    float d = min( -d1, d2 ) * 0.03;\n    \n    return clamp(d, 0.0, 1.0);\n}\n\nfloat Glow( const in vec2 uv )\n{\n    float glow_dist = distance( uv, vec2(0.46, 0.45)) - 0.2;\n    float glow = exp2(glow_dist * -3.5) * 0.001;\n    glow += exp2(glow_dist * -7.0) * 0.0002;\n    return glow;    \n}\n\nfloat Cloud( const in vec2 uv )\n{\n\tfloat s = 0.0;\n    float a = 1.0, t = 0.0;\n    vec2 p = uv;\n    p = p * 2.5;\n    for(int i=0;i<5;i++)\n    {\n        s += Noise2D(p) * a;\n        t += a;\n        p *= 2.0;\n        a *= 0.5;\n        \n        p.x += iTime * 0.05;\n    }\n    s = s / t;    \n    return s;\n}\n\n////////////////\n\nvec3 ApplyVignetting( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec2 vOffset = (vUV - 0.5) * sqrt(2.0);\n\t\n\tfloat fDist = dot(vOffset, vOffset);\n\t\n\tconst float kStrength = 1.0;\n\tconst float kPower = 0.2;\n\n\treturn vInput * ((1.0 - kStrength) +  kStrength * pow(1.0 - fDist, kPower));\n}\n\nvec3 ApplyTonemap( const in vec3 vLinear )\n{    \n    if(iTime < 2.0)\n    {\n        kExposure *= iTime / 2.0;\n    }\n    \n    kExposure *= 0.5;\n    \t\n\treturn 1.0 - exp2(vLinear * -kExposure);\t\n}\n\nvec3 ApplyGamma( const in vec3 vLinear )\n{\n\tconst float kGamma = 2.2;\n\n\treturn pow(vLinear, vec3(1.0/kGamma));\t\n}\n\nvec3 ApplyBlackLevel( const in vec3 vColour )\n{\n    float fBlackLevel = 0.1;\n    return vColour / (1.0 - fBlackLevel) - fBlackLevel;\n}\n\nvec3 ApplyPostFX( const in vec2 vUV, const in vec3 vInput )\n{\n\tvec3 vTemp = ApplyVignetting( vUV, vInput );\t\n\t\n\tvTemp = ApplyTonemap(vTemp);\n\t\n\tvTemp = ApplyGamma(vTemp);\t\t\n    \n    vTemp = ApplyBlackLevel(vTemp);\n    \n    return vTemp;\n}\n\n////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;     \n    vec2 bodyUV = (uv - 0.5) * vec2(ratio, 1.0) + 0.5;\n\n    bodyUV -= 0.1; // offset the sun\n\t\n    float cloudAmount = Cloud(uv * vec2(1.0, 1.75));\n            \n    float glow = Glow(bodyUV);\n    vec3 glowCol = glow * sunLight;\n\n    vec3 col = Crescent(bodyUV) * sunLight;\n\n    vec3 cloudCol = mix(cloudColA.rgb, mix(cloudColB.rgb, cloudColC.rgb, uv.y), cloudAmount);\n    cloudCol = cloudCol * cloudCol;\n    cloudCol += glowCol * (1.0 - cloudAmount * 0.5) * 0.25;\n\tcol = mix(col, cloudCol, cloudAmount);\n    \n    col = ApplyPostFX( uv, col );\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtjGRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 361, 382, 382, 524], [526, 526, 548, 548, 594], [596, 596, 621, 621, 1043], [1045, 1045, 1081, 1081, 1331], [1333, 1333, 1365, 1365, 1543], [1545, 1545, 1578, 1578, 1847], [1849, 1867, 1932, 1932, 2153], [2155, 2155, 2199, 2199, 2347], [2349, 2349, 2391, 2391, 2462], [2464, 2464, 2511, 2511, 2598], [2600, 2600, 2661, 2661, 2838], [2840, 2858, 2915, 2915, 3595]], "test": "untested"}
{"id": "Xtl3DX", "name": "sand dunes", "author": "boinx", "description": "hacking this to make dunes:\nhttps://www.shadertoy.com/view/Ms2SD1\nwormsign!", "tags": ["hack", "dunes", "sand"], "likes": 5, "viewed": 1628, "published": "Public API", "date": "1425767697", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Seascape\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// hacked into dunes by boinx\n// \n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.1415;\nconst float EPSILON\t= 1e-3;\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.766;\nconst float SEA_CHOPPY = 1.8;\nconst float SEA_SPEED = 0.50;\nconst float SEA_FREQ = 0.056;\nconst vec3 SEA_BASE = vec3(0.4650,0.3850,0.250);\nconst vec3 SEA_WATER_COLOR = vec3(0.87,0.780,0.670);\nmat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = max(e.y,0.0);\n    vec3 ret;\n    ret.x = pow(1.0-e.y,1.0);\n    ret.y = 1.0-e.y;\n    ret.z = 0.6+(1.0-e.y)*0.24;\n    return ret;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    float SEA_TIME = iTime * SEA_SPEED;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    float SEA_TIME = iTime * SEA_SPEED;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = 1.0 - max(dot(n,-eye),0.0);\n    fresnel = pow(fresnel,3.0) * 0.65;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n*.5));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) return tx;   \n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3 + iMouse.x*0.01;\n    float EPSILON_NRM\t= 0.1 / iResolution.x;\n\n        \n    // ray\n    //vec3 ang = vec3(sin(3.0)*0.01,sin(1.0)*0.02+0.3,.7);\n    vec3 ang = vec3(.010,.3,.758);\n    vec3 ori = vec3(0.0,3.5,time*5.0*.012);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.0715;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori ;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.10,1.0,0.8)); \n             \n    // color\n    vec3 color = mix(\n        getSkyColor(dir),\n        //getSeaColor(p,n,light,dir,dist)* .75,\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.675,dir.y),0.23));\n        \n    // post\n\tfragColor = vec4(pow(color,vec3(0.85)), .5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtl3DX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[584, 592, 618, 618, 964], [965, 965, 987, 987, 1067], [1068, 1068, 1094, 1094, 1395], [1397, 1409, 1447, 1447, 1489], [1490, 1490, 1536, 1536, 1640], [1642, 1649, 1675, 1675, 1814], [1816, 1823, 1864, 1864, 2035], [2037, 2037, 2056, 2056, 2540], [2542, 2542, 2570, 2570, 3054], [3056, 3056, 3119, 3119, 3609], [3611, 3622, 3657, 3657, 3848], [3850, 3850, 3906, 3906, 4418], [4420, 4428, 4485, 4485, 5442]], "test": "untested"}
{"id": "Xtl3Wf", "name": "mappedsinewaves", "author": "felixisdev", "description": "Just messing around", "tags": ["sine"], "likes": 1, "viewed": 136, "published": "Public", "date": "1425763704", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//lots of sine\n//~ felixisdev\n\n//PI Constant\nconst float pi = 3.14159265359;\n\n//Get the sine wave in the range of 0.0 - 1.0 instead of -1.0 - 1.0\nfloat sine(float v)\n{\n\treturn (sin(v) + 1.0) / 2.0;\n}\n\n//Get the current color at v (0.0 - 1.0)\n//Change this for a different palette, final function to determine color\nvec4 getMap(float v)\n{\n    return vec4(sine(v * 5.0 + (2.123 + sin(iTime * 0.2) * 1.0)), \n                sine(v * 5.0 + (2.546 + sin(iTime * 0.21) * 1.0)), \n                sine(v * 5.0 + (2.742 + sin(iTime * 0.22) * 1.0)), 1.0);\n}\n\n//sine variables (factors)\nfloat sines[8];\n\n//x and y variables for the equation\nfloat xp;\nfloat yp;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //get x and y vars for equation\n    xp = fragCoord.x - iResolution.x / 2.0;\n    yp = fragCoord.y - iResolution.y / 2.0;\n    \n    xp /= 4.0;\n    yp /= 4.0;\n    \n    //set equation factors based on time\n    for (int ss = 0; ss < 8; ss++)\n    {\n        sines[ss] = (ss < 4 ? 1.0 : 0.25) + sine((iTime * float(ss) / 4.0) / 4.0 + float(ss) * 6.43326) * (ss < 4 ? 30.0 : 1.5);\n    }\n    \n    //fragColor = get map (equation)\n\tfragColor = getMap(\n  \t  sine((xp / sines[0]) + sin((yp / sines[1]) + sin((xp / sines[2]) + sin((yp / sines[3]) * sines[4]) * sines[5]) * sines[6]) * sines[7])\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtl3Wf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 146, 167, 167, 199], [201, 315, 337, 337, 547], [593, 651, 708, 708, 1348]], "test": "untested"}
{"id": "Xtl3Ws", "name": "shadeaday ( 3 / 12 / 2015 )", "author": "cabbibo", "description": "more glitter work", "tags": ["shadeaday"], "likes": 2, "viewed": 1067, "published": "Public", "date": "1426204781", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ALL TAKEN FROM IQs AMAZING SITE / TUTORIALS / SHADERS:\n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\nconst float MAX_TRACE_DISTANCE = 10.0;           // max trace distance\nconst float INTERSECTION_PRECISION = .0001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 80;\n\t\nvec4 spherePos[10];\n    \nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec3 noiseVec( vec3 p ){\n    \n    float x = rand( p.xy );\n    float y = rand( p.yz);\n    float z = rand( p.zx );\n \n    return normalize(normalize(vec3( x , y , z )) - vec3( .5 ));\n    \n}\n\nvec4 texCube( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n    vec3 w = pow( abs(n), vec3(k) );\n\treturn (x*w.x + y*w.y + z*w.z) / (w.x+w.y+w.z);\n}\n\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdPlane( vec3 p )\n{\n    \n    float f = sin( p.z * 5. ) * sin( p.x * 5. );\n    //f = 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n\treturn p.y - (abs( f) * .3)/ max( 1. , pow( length( p ), 1.));\n\n}\n\n\n\nfloat sdSphere( vec3 p, float s , float offset)\n{\n\n\n    float d1 = length(p) - .1*smoothstep(0.0,1.0,iTime);;\n    d1 *= .8;\t\n    \n   // vec3 nP = vec3( x , y , z );\n    return d1 -s;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n\n    float d1 = -p.y-c.z;\n    float d2 = max( dot(q,c.xy), p.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n\n}\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n\tcamPos = vec3(3.5*sin(an),1.0,3.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\nfloat opBlend( vec2 d1, vec2 d2 )\n{\n\n    return smin( d1.x , d2.x , 8.);\n}\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n   \tvec2 res = vec2( 10000. , 0.);// vec2( sdPlane( pos - vec3( 0. , -1. , 0. )), 0.0 );\n   \n    for( int i = 0; i < 20; i++ ){\n   \t\t\n        vec2 res2 = vec2( sdSphere( (pos - spherePos[i].xyz) , spherePos[i].w  , float( i )) , float(i) + 1.);\n        //vec2 res2 = vec2( udRoundBox( (pos - spherePos[i].xyz) , vec3( spherePos[i].w  ) ,spherePos[i].w * .2 ) , float(i) + 1.);\n   \t\tres.x = opBlend( res ,  res2 );\n        \n   \t}\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n}\n\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 20.*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + 0.612*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.5;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n\n    for( int i =0; i < 20; i++ ){\n        \n        float x = 1. * cos(iTime *.13 * (float( i )+2.));\n        float y = 1. * sin(iTime * .075 * (float( i )+4.));\n        float z = 1. * sin(iTime * .1 * (float( i )+3.3));\n        float r = .1 * ( sin( iTime * .1  *( float( i) +1.))+2.);\n    \tspherePos[i] = vec4( x ,  y ,  z , r  );\n        \n        \n    }\n\n    \n    \n    \n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    vec2 res = calcIntersection( ro , rd  );\n    \n    \n    vec3 lightPos = vec3( 2. , 1. , 0. );\n    \n    vec3 col = vec3( 0. );//vec3( .8 , .8 , .8 ); \n   \n    // If we have hit something lets get real!\n    if( res.y > -.5 ){\n\n    \tvec3 pos = ro + rd * res.x;\n    \tvec3 nor = calcNormal( pos );\n        \n        vec3 lightDir = lightPos - pos;\n        lightDir = normalize( lightDir );\n        \n        vec3 shinyNorm = normalize( noiseVec( pos * .04) * .2 + nor);\n        \n        vec3 shinyRefl = reflect( lightDir , shinyNorm );\n        float shinyMatch = max( 0. , dot( shinyRefl , rd ) );\n        \n        float AO = calcAO( pos , nor );\n        \n        float match = max( 0. , dot( shinyNorm , lightDir ));\n        \n\n       // float c = pow(( 1.-AO) , 5.)*  10.;\n        float c = 0.;\n        //c += pow((1.- match),4.) * 1.;\n        c += pow(( 1.-AO) , 5.)*  2.;\n       // col = vec3( c );// * .4 * ( nor * .5 + .5 );\n       \n       // col = hsv( c ,1.,1.) * c;\n        col += pow(( 1.-AO) , 2.) * pow( match , 3.) * hsv(abs(sin(match*1.)) , 1. , 1. );\n        col += pow( shinyMatch , 5. ) * hsv(abs(sin(shinyMatch*10.)) , 1. , 1. );\n        //col = vec3( shinyMatch );\n       /* if( res.y < .5 ){\n            \n            float f = sin( pos.z * 5. ) * sin( pos.x * 5. );\n            //col *= 5. * smoothstep( abs(f) , 0.4 , 0.8 );\n            col *= abs( f );\n            col /= pow( length( pos ), 4.);\n        }*/\n    }\n    // apply gamma correction\n    col = pow( col, vec3(0.4545) );\n\n    fragColor = vec4( col , 1. );\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xtl3Ws.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[188, 356, 393, 393, 525], [527, 527, 547, 547, 619], [621, 621, 645, 645, 807], [809, 809, 874, 874, 1058], [1061, 1061, 1106, 1106, 1146], [1148, 1148, 1173, 1173, 1343], [1347, 1347, 1396, 1396, 1531], [1533, 1533, 1571, 1571, 1742], [1744, 1775, 1839, 1839, 2017], [2019, 2019, 2102, 2102, 2215], [2220, 2314, 2343, 2343, 2386], [2388, 2424, 2465, 2465, 2536], [2538, 2538, 2573, 2573, 2612], [2613, 2697, 2718, 2718, 3182], [3186, 3186, 3234, 3234, 3701], [3703, 3816, 3847, 3847, 4073], [4076, 4076, 4150, 4150, 4411], [4414, 4414, 4456, 4456, 4755], [4758, 4758, 4814, 4814, 7258]], "test": "untested"}
{"id": "XtlGDl", "name": "3D !?", "author": "gaz", "description": "3d", "tags": ["raymarching", "bezier", "de"], "likes": 5, "viewed": 198, "published": "Public", "date": "1426258307", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nmat2 rotate(in float a)\n{\n\treturn mat2(cos(a), sin(a), -sin(a), cos(a));\t\n}\n\nfloat Cross(in vec2 a, in vec2 b ) \n{\n    return a.x * b.y - b.x * a.y;\n}\n\n// from https://www.shadertoy.com/view/XsX3zf\nfloat deBezier(in vec2 p, in vec2 b0, in vec2 b1, in vec2 b2) \n{\n  b0 -= p; b1 -= p; b2 -= p;\t\n  float a=Cross(b0,b2), b=2.0*Cross(b1,b0), d=2.0*Cross(b2,b1);\n  float f=b*d-a*a;\n  vec2 d21=b2-b1, d10=b1-b0, d20=b2-b0;\n  vec2 gf=2.0*(b*d21+d*d10+a*d20);\n  gf=vec2(gf.y,-gf.x);\n  vec2 pp=-f*gf/dot(gf,gf);\n  vec2 d0p=b0-pp;\n  float ap=Cross(d0p,d20), bp=2.0*Cross(d10,d0p);\n  float t=clamp((ap+bp)/(2.0*a+b+d), 0.0 ,1.0);\n  return length(mix(mix(b0,b1,t),mix(b1,b2,t),t));\n\n}\n\nfloat deStreamline(in vec2 p, in vec2 control, in vec2 offset, in float size)\n{\n    vec2 controlR = vec2(size + offset.x, 0.0);\n    vec2 controlL = vec2(-(size + offset.y), 0.0);\n    vec2 deltaR = controlR - control;\n    vec2 deltaL = controlL - control;\n    float t = 1.0 - 2.0 * offset.x / (controlR.x - control.x);\n    vec2 jointR = control + deltaR * t;\n    t = 1.0-2.0 * offset.y / (control.x - controlL.x);\n    vec2 jointL = control + deltaL * t;    \n    return min(min(min(\n        deBezier(p, jointR, controlR, jointR*vec2(1.0,-1.0)),\n    \tdeBezier(p, jointL, controlL, jointL*vec2(1.0,-1.0))),\n\t\tdeBezier(p, jointL, control, jointR)),\n    \tdeBezier(p, jointL * vec2(1.0, -1.0), control * vec2(1.0, -1.0), jointR * vec2(1.0, -1.0)));\n}\n\nfloat deExclamationMark(in vec3 p)\n{\n    // bounding box\n    vec3 bb = vec3(1.0, 3.2, 1.0);\n    if (any(greaterThan(abs(p), bb))) return length(max(abs(p) - bb, 0.0)) + 0.2;\n    vec2 control = vec2(0.7, 0.7);\n    vec2 offset = vec2(0.2, 0.2);\n    float size = 1.55;\n    p.xz *= rotate(atan(p.z,p.x));\n    return min(deStreamline(0.8 * p.yx, control, offset, size), length(p - vec3(0.0,-2.7, 0.0)) - 0.3);\n}\n\nfloat deQuestionMark(in vec3 p)\n{\n    // bounding box\n    vec3 bb = vec3(1.5, 3.2, 0.4);\n    if (any(greaterThan(abs(p), bb))) return length(max(abs(p) - bb, 0.0)) + 0.2;\n    vec2 v = vec2(0.0, -1.2);\n    vec2 h = vec2(0.0, 0.7);\n    vec2 a0 = v + h;\n    vec2 a1 = v * rotate(PI2 / 6.0) + h;\n    vec2 a2 = v * rotate(PI2 * 2.0 / 6.0) + h;\n    vec2 a3 = v * rotate(PI2 * 3.0 / 6.0) + h;\n    vec2 a4 = v * rotate(PI2 * 4.0 / 6.0) + h;\n    vec2 a5 = v * rotate(PI2 * 5.0 / 6.0) + h;\n    //vec2 b0 = a0 + 0.5 * (a1 - a0);\n    vec2 b1 = a1 + 0.5 * (a2 - a1);\n    vec2 b2 = a2 + 0.5 * (a3 - a2);\n    vec2 b3 = a3 + 0.5 * (a4 - a3);\n    vec2 b4 = a4 + 0.5 * (a5 - a4);\n    vec2 b5 = a5 + 0.5 * (a0 - a5);    \n    float de = 100.0;\n    //de = min(de, deBezier(p, b0, a1, b1));\n    de = min(de, deBezier(p.xy, b1, a2, b2));\n    de = min(de, deBezier(p.xy, b2, a3, b3));\n    de = min(de, deBezier(p.xy, b3, a4, b4));\n    de = min(de, deBezier(p.xy, b4, a5, b5));\n\tde = min(de, deBezier(p.xy, b5, a0, vec2(0.0,-1.8)));\n\treturn min(length(vec2(de,p.z))-0.3, length(p - vec3(0.0,-2.7, 0.0)) - 0.3);\n}\n\nfloat map(in vec3 p)\n{\n    p.x += 6.0;\n    p.y -= 0.4;\n    p.zx *= rotate(iTime * -0.5);\n    float s = 6.0;\n    float a = PI / s - atan(p.z, p.x);\n    float n = PI2 / s;\n    a = floor(a / n) * n;\n    p.zx *= rotate(a);\n    p.x -= 8.0 ;\n    return min(\n        deExclamationMark(p + vec3(1.2, 0.0, 0.0)),\n        deQuestionMark(p - vec3(1.2, 0.0, 0.0)));\n}\n\nvec3 calcNormal(in vec3 p)\n{\n\tconst vec2 e = vec2(0.0001, 0.0);\n\treturn normalize(vec3(\n\t\tmap(p + e.xyy) - map(p - e.xyy),\n\t\tmap(p + e.yxy) - map(p - e.yxy),\n\t\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tconst float maxd = 20.0;\n\tconst float precis = 0.001;\n    float h = precis * 2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for(int i = 0; i < 64; i++)\n    {\n        if(h < precis || t > maxd) break;\n\t    h = map(ro + rd * t);\n        t += h;\n    }\n    if(t < maxd) res = t;\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n\tvec3 col = vec3(0.15 + p.y * 0.2);\n   \tvec3 rd = normalize(vec3(p, -1.8));\n\tvec3 ro = vec3(0.0, 0.0, 8.0);\n    vec3 li = normalize(vec3(0.5, 0.8, 3.0));\n    float t = march(ro, rd);\n    if(t > -0.001)\n    {\n        vec3 pos = ro + t * rd;\n        vec3 n = calcNormal(pos);\n\t\tfloat dif = clamp((dot(n, li) + 0.5) * 0.7, 0.3, 1.0);\n   \t\tcol = vec3(0.8) * dif;\n    }\n   \tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 76, 76, 126], [128, 128, 165, 165, 201], [203, 249, 313, 313, 722], [724, 724, 803, 803, 1467], [1469, 1469, 1505, 1525, 1875], [1877, 1877, 1910, 1930, 2964], [2966, 2966, 2988, 2988, 3321], [3323, 3323, 3351, 3351, 3519], [3521, 3521, 3558, 3558, 3852], [3854, 3854, 3911, 3911, 4375]], "test": "untested"}
{"id": "XtlGW2", "name": "cut mandelbox closeup", "author": "kig", "description": "Going back to the old shader, this is a mandelbox with a sphere cutting", "tags": ["shadeaday"], "likes": 3, "viewed": 195, "published": "Public", "date": "1425251450", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AA_SIZE 2.0\n\nmat3 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);  \n}\n\nvec3 shadeBg(vec3 nml, vec2 fragCoord)\n{\n\tvec2 aspect = vec2(iResolution.x/iResolution.y, 1.0);\n\tvec2 uv = (2.0 * fragCoord.xy / iResolution.xy - 1.0) * aspect;\n    float t = 16.0;\n\tvec3 bgLight = normalize(vec3(\n\t\tcos(t*0.2/0.954929658551372)*4.0, \n\t\tsin(t/1.1936620731892151)*3.0 - 4.0, \n\t\tsin(t*0.2/0.954929658551372)*8.0\n\t));\n\tvec3 sun = vec3(2.0, 1.5, 1.0)*0.75;\n\tfloat bgDiff = dot(nml, vec3(0.0, -1.0, 0.0));\n\tfloat sunPow = dot(nml, bgLight);\n\tfloat sp = max(sunPow, 0.0);\n\tvec3 bgCol = max(0.0, bgDiff)*2.0*vec3(0.4, 0.7, 0.65);\n\tbgCol += max(0.0, -bgDiff)*vec3(0.4, 0.55, 0.9);\n\tbgCol += vec3(0.2, 0.5, 0.7)*((0.5*pow(1.0-abs(bgDiff), 5.0)*(5.0-dot(uv,uv))));\n\tbgCol += sun*(0.5*pow( sp, 3.0)+pow( sp, 256.0));\n\tbgCol += vec3(0.5, 0.2, 0.15)*(pow( sp, 8.0) + pow( sp, abs(bgLight.y)*128.0));\n    //bgCol += vec3(1.9,0.,0.9) * ((1.0-pow(abs(bgDiff), 0.6)) * 0.5);\n\treturn pow(max(vec3(0.0), bgCol), vec3(1.9));\n}\n\nfloat mandelbox_dist(vec3 pos) {\n    vec4 p = vec4(pos, 1.0), p0 = p;\n    float minRad2 = 0.25;\n    vec4 scale = vec4(2.0) / minRad2;\n    float absScalem1 = abs(2.0 - 1.0);\n    float AbsScaleRaisedTo1mIters = pow(abs(2.0), (1.0 - 20.0));\n    for (int i=0; i<20; i++) {\n        p.xyz = clamp(p.xyz, -1.0, 1.0) * 2.0 - p.xyz;\n        float r2 = dot(p.xyz, p.xyz);\n        p *= clamp(max(minRad2/r2, minRad2), 0.0, 1.0);\n        p = p * scale + p0;\n    }\n    return ((length(p.xyz) - absScalem1) / p.w - AbsScaleRaisedTo1mIters);\n}\n\nfloat scene(vec3 p) {\n    return max(length(p)-7.5, mandelbox_dist(p));\n}\n\nvec3 normal(vec3 p, float d)\n{\n\tfloat e = 0.005;\n\tfloat dx = scene(vec3(e, 0.0, 0.0) + p) - d;\n\tfloat dy = scene(vec3(0.0, e, 0.0) + p) - d;\n\tfloat dz = scene(vec3(0.0, 0.0, e) + p) - d;\n\treturn normalize(vec3(dx, dy, dz));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    for (float x = 0.0; x < AA_SIZE; x++) {\n    for (float y = 0.0; y < AA_SIZE; y++) {\n\n        vec2 uv = (vec2(x/AA_SIZE, y/AA_SIZE) + fragCoord.xy) / iResolution.xy;\n        uv = (0.5 - uv) * 2.0;\n        uv.x *= iResolution.x / iResolution.y;\n\n        float time = iTime; //406.9;\n        float a = cos(time/3.53423*0.5);\n        float ca = cos(a), sa = sin(a);\n        uv *= mat2(ca, sa, -sa, ca);\n        mat3 rot = rotationMatrix(normalize(vec3(1.0, -0.5, 0.5)),time*0.05);\n        vec3 ro = rot*vec3(0,0,-15.0);\n        vec3 rd = rot*normalize(vec3(uv, 5.5));\n        ro += rd * 4.0;\n        vec3 transmit = vec3(1.0);\n        float bounce = 0.0;\n\n        for (int i=0; i<70; i++) {\n            float t = scene(ro);\n            if (t < 0.0025) {\n                vec3 nml = normal(ro, t);\n                rd = normalize(reflect(rd, nml));\n                ro += rd * 0.005;\n                transmit *= vec3(0.75, 0.8, 0.9)*0.7 - float(i)/70.0;\n                bounce++;\n                break;\n            } else {\n                ro += rd * t;\n            }\n            if (t > 17.0) {\n                break;\n            }\n        }\n        if (bounce == 0.0) {\n            transmit *= 0.0;\n        }\n        fragColor += vec4(1.0-exp(-1.6*transmit*shadeBg(-rd, fragCoord)), 1.0);\n    }\n    }\n    fragColor /= AA_SIZE*AA_SIZE;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlGW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[21, 21, 66, 66, 540], [542, 542, 582, 582, 1463], [1465, 1465, 1497, 1497, 1993], [1995, 1995, 2016, 2016, 2068], [2070, 2070, 2100, 2100, 2295], [2297, 2297, 2354, 2354, 3721]], "test": "untested"}
{"id": "XtlGWs", "name": "Galactic Dance", "author": "Sinuousity", "description": "I got sidetracked. ", "tags": ["procedural", "2d", "distortion", "spiral"], "likes": 40, "viewed": 3725, "published": "Public", "date": "1426192082", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14\n#define tao 6.28\n\n#define overbright 2.0\n\n#define armCount 3.0\n#define armRot 1.6\n\n#define innerColor vec4(2.0,0.5,0.1,1.0)\n#define outerColor vec4(0.8,0.6,1.0,1.0)\n#define white vec4(1.0,1.0,1.0,1.0)\n\n\nfloat saturate (in float f)\n{\n    return clamp(f,0.0,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n    \n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    //constant slow rotation\n    float cost = cos(-time*0.2);\n    float sint = sin(-time*0.2);\n    mat2 trm = mat2 (cost,sint,-sint,cost);\n    \n    //scale 0.0-1.0 uv to -1.0-1.0 p\n    vec2 p = uv*2.0 - 1.0;\n    //apply slow rotation\n    p = p * trm;\n    \n    //calc distance\n    float d = length(p);\n    \n    //build arm rotation matrix\n    float cosr = cos(armRot*sin(armRot*time));\n    float sinr = sin(armRot*cos(armRot*time));\n    mat2 rm = mat2 (cosr,sinr,-sinr,cosr);\n    \n    //calc arm rotation based on distance\n    p = mix(p,p * rm,d);\n    \n    //find angle to middle\n    float angle = (atan(p.y,p.x)/tao) * 0.5 + 0.5;\n    //add the crinkle\n    angle += sin(-time*5.0+fract(d*d*d)*10.0)*0.004;\n    //calc angle in terms of arm number\n    angle *= 2.0 * armCount;\n    angle = fract(angle);\n    //build arms & wrap the angle around 0.0 & 1.0\n    float arms = abs(angle*2.0-1.0);\n    //sharpen arms\n    arms = pow(arms,10.0*d*d + 5.0);\n    //calc radial falloff\n    float bulk = 1.0 - saturate(d);\n    //create glowy center\n    float core = pow(bulk,9.0);\n    //calc color\n    vec4 color = mix(innerColor,outerColor,d*2.0);\n    \n\tfragColor = bulk * arms * color + core + bulk*0.25*mix(color,white,0.5);\n    fragColor = (overbright * fragColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtlGWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[219, 219, 248, 248, 279], [281, 281, 338, 338, 1669]], "test": "untested"}
{"id": "Xts3DX", "name": "Fire revisited", "author": "guil", "description": "A remake of Fire by @301z with sine wave noise (https://www.shadertoy.com/view/Xsl3zN)", "tags": ["2d", "noise", "fire"], "likes": 14, "viewed": 647, "published": "Public", "date": "1425720657", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Adapted by S.Guillitte from Fire by @301z\n\nconst mat2 m2 = mat2(.8,.6,-.6,.8);\n\n\nfloat noise(in vec2 p){\n\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 2; i++ ) \n\t{\t\t\n        p=m2*p*f+.6;     \n        f*=1.2;\n        res+=sin(p.x+sin(2.*p.y));\n\t}        \t\n\treturn abs(res/4.);\n}\n\nfloat fbm(in vec2 p){\n\t\n    float res=0.;\n    float f=1.;\n\tfor( int i=0; i< 7; i++ ) \n\t{\n        res+=noise(f*p)/f;\n        f*=2.;\n\t}        \t\n\treturn res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n\tvec2 p = fragCoord.xy * 8.0 / iResolution.xx;\n    float t = iTime;\n\tfloat q = fbm(p - t * 0.1);\n\tvec2 r = vec2(fbm(q - p.yx + t * 0.7 ), fbm(p + q - t * 0.4));\n    float s = fbm(p + r);\n\tvec3 c = clamp(vec3(0.1+s*.7+r.x-.7*r.y, r.x-r.y, 0.)*1.1,0.,1.);\n\tfragColor = vec4(c * cos(1.57 * fragCoord.y / iResolution.y), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xts3DX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 171, 194, 194, 374], [376, 376, 397, 397, 533], [535, 535, 592, 592, 919]], "test": "untested"}
{"id": "XtS3Rh", "name": "Monolith Smoke", "author": "cabbibo", "description": "Working on a small effect for @spite", "tags": ["noise"], "likes": 9, "viewed": 497, "published": "Public", "date": "1426731725", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float fadeLR = .5 - abs(uv.x - .5) ;\n    float fadeTB = 1.-uv.y;\n    vec3 pos = vec3( uv * vec2( 3. , 1.) - vec2( 0. , iTime * .03 ) , 1. );\n    float n  = pow((fadeLR * fadeTB) , 1. ) * .4 * triNoise3D( pos , .4 );\n    n  += pow((fadeLR * fadeTB) , 2. ) * triNoise3D( pos  * .2, .4 );\n    \n    \n    vec3 col = hsv( n * 1.4 + .9 , .6 , .9 );\n    \n  \n\tfragColor =  vec4( col * pow( n , 2. ) * 200.  , pow((fadeLR * fadeTB) , 2. ));\n    \n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtS3Rh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 52, 74, 74, 99], [100, 100, 121, 121, 201], [237, 289, 332, 332, 635], [638, 638, 675, 675, 807], [811, 811, 868, 868, 1357]], "test": "untested"}
{"id": "Xts3Wj", "name": "Flervariabel-visualisering", "author": "Nilax", "description": "-", "tags": ["3dvisualizefunctions"], "likes": 2, "viewed": 112, "published": "Public", "date": "1426019993", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Raymarches and renders the function given in f\n\n//Global variables\nvec3 cpos = vec3(80.0, 0.0, 80.0);\nvec3 up = vec3(0.0, 1.0, 0.0);\nvec3 look_at = vec3(0.0, 0.0, 0.0);\n\nvec3 right;\nvec3 front;\n\nfloat max_dist = 120.0;\n////////////////////////////////////\n\n\nfloat snoise(vec3);\n\n//Function to render\n//Change this to render something else!\nfloat f(vec3 pos){\n    \n    \n    //f(x, z) = -(x^2+z^2)/5;\n    return -(3.0*pos.x+pos.z*pos.z)/15.0; \n    \n    //f(x, z) = -(x^2+z^2)+sin(x)+cos(z);\n \t//return -(pos.x*pos.x+pos.z*pos.z)/10.0+sin(pos.x*cos(iTime))+cos(pos.z*sin(iTime/3.0)); \n    \n    //cool\n \t//return -(30.0*pos.x*pos.x+pos.y*pos.z)/10.0+sin(pos.x)+cos(pos.z); \n}\n\nfloat sincos(vec3 pos){\n    return (sin(pos.x*cos(iTime))+cos(pos.z*sin(iTime/3.0)));\n}\n\n    \n//Helper function\nfloat mapFunction(vec3 pos){\n    //Enmantlad hyperboloid -> kon -> tvmantlad hyperboloid\n    //return (pos.x*pos.x+pos.z*pos.z-pos.y*pos.y)/10.0-(80.0-14.0*iTime);\n    \n    \n    return 10.0+(pos.x*pos.x+pos.z*pos.z-pos.y*pos.y)/10.0;//-(80.0-14.0*iTime)+5.0*sincos(pos);\n    \n    //Paraboloid\n    //return pos.y+(pos.x*pos.x+pos.z*pos.z*(1.0-iTime/10.0))/10.0;\n    \n    \n    //return pos.y+(pos.x*pos.x+pos.z*pos.z*(1.0-iTime/10.0))/10.0+3.0*sincos(pos);\n    \n    //return length(pos) - 16.0; //map as sphere with radius 6\n    \n    //Paraboloid + sin/cos\n    //return pos.y - f(pos);\t\t//map f as y = f(x, z)\n}\n\n\n\nvoid move_cam(){\n    vec3 cpos2 = cpos;\n    //Move camera\n    cpos2.x *= cos(iTime);\n    cpos2.z *= sin(iTime);\n    \n    \n    //Makes sure camera isn't in a wall\n    //Get rid of bounce by lerping\n    for(int i=0; i<20; i++){\n        if(mapFunction(cpos2)>0.0)\n            continue;\n    \tcpos2.x = cpos.x*cos(iTime+float(i)/2.0);\n    \tcpos2.z = cpos.z*sin(iTime+float(i)/2.0);\n    }\n    \n    cpos = cpos2;\n    \n    \n    //Set camera vectors\n    look_at.y += 3.0*sin(iTime);\n}\n\n\n\n\n//////////////////////\n//Raymarches the function given in function\n//which is mapped as a distance field in map_function \n\n//Raymarch this ray\n//March along ray until mapFunction(pos+ray*t) < 0\nfloat raymarch(vec3 pos, vec3 ray){\n    float t = 0.2; \t\t//Start time\n    float lim = 0.0;\n\tfloat lt = 0.0;\n\tfloat lh = 0.0;\n\t//int i;\n    for(int i=0; i<160; i++ )\n    {\n\t    float h = mapFunction( pos+ray*t );\n        //if( h<(0.001*t) || t>maxd ) break;\n        //if( h<0 || t>maxd ) break;\n        if( h<lim || t>max_dist ) {\n            if(t<max_dist)\n\t\t\t\tt = mix(t, lt, -h/(lh-h)); //Interpolera t\n\t\t\tcontinue;\n\t\t}\n\t\tlh = h;\n\t\tlt = t;\n        t += h*0.1+0.01*t;\n        //t += max_dist/160.0;\n    }\n\n    if( t>max_dist ) t=-1.0;\n    return t;\n}\n\n//Calculate normal\n//Gradient somethingsomething\nvec3 nor( in vec3 pos, in float t )\n{\n    vec3 eps = vec3( max(0.02,0.001*t),0.0,0.0);\n\treturn normalize( vec3(\n           mapFunction(pos+eps.xyy) - mapFunction(pos-eps.xyy),\n           mapFunction(pos+eps.yxy) - mapFunction(pos-eps.yxy),\n           mapFunction(pos+eps.yyx) - mapFunction(pos-eps.yyx) ) );\n\n}\n\n//Calculate ray for this point of the screen\n//Based on where it is compared to the center of screen\nvec3 getRay(vec2 fragCoord){\n    vec2 center = iResolution.xy/2.0;//Center of screen\n\tvec2 point = (fragCoord.xy - center)/center; // Point compared to mid-screen\n    \n\tfloat angle = atan(point.y, point.x);\n\tfloat len = length(point);\n\tfloat frontMul = 1.0;\n\tvec3 ray = frontMul * front + sin(angle) * len * up + cos(angle) * len * right;\n\tnormalize(ray);\n\treturn ray;\n}\n\n//Calculate sky color (modeled as some kind of gradient)\nvec3 sky_color(vec3 vec){\n \tfloat val = dot(vec, vec3(0.0, 1.0, 0.0));\n    vec3 res = vec3(0.6, 0.6, 0.9);\n    res.x += (sin(vec.x)+cos(vec.y)+sin(vec.z-vec.y))/1.0;\n    res.y += snoise(vec+iTime/20.0)/5.0;\n    res *= (val/2.0+1.0);\n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 sun_pos = vec3(1000.0);\n    \n    move_cam();\n    \n    //Set camera vectors\n    front = normalize(-cpos+look_at);\n    right = normalize(cross(up, front));\n    up = normalize(up);\n    \n    \n    vec3 ray = getRay(fragCoord);\n    \n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    float t =  raymarch(cpos, ray);\n    if(t>0.0){//Did we find an intersection?\n    \tvec3 point = cpos+t*ray;\n        vec3 normal = nor(point, t);\n        \n        //light/shading\n        //amb + diff + spec + sky\n        float amb = 0.0;\n        vec3 ambc = vec3(0.8, 0.8, 0.99);\n        \n        sun_pos = normalize(sun_pos-cpos);\n        float sun = clamp( dot( normal, sun_pos ), 0.0, 1.0 );\n        vec3 sunc = vec3(1.0, 1.0, 0.2);\n        \n \t\tfloat specular = pow(clamp( dot( normalize(reflect(ray, normal)), sun_pos ), 0.0, 1.0 ), 30.0);\n        \n        float sky = 1.0;\n        vec3 skyc = sky_color(normal);\n        \n        //float fog = t/max_dist;\n        //vec3 fogc = vec3(00);\n        \n        \n     \tcolor = (1.0+specular)*(amb*ambc + sun*sunc + sky*skyc)/3.0;\n    }\n   \telse\n        color = vec3(sky_color(ray));\n    \n    fragColor = vec4(color, 1.0);\n}\n\n\n\n//3d simplex noise below\n\n\n\n\n\n//\n// Description : Array and textureless GLSL 2D/3D/4D simplex \n//               noise functions.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//               https://github.com/ashima/webgl-noise\n// \n\n\nvec3 mod289(vec3 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 mod289(vec4 x) {\n  return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\n\nvec4 permute(vec4 x) {\n     return mod289(((x*34.0)+1.0)*x);\n}\n\nvec4 taylorInvSqrt(vec4 r)\n{\n  return 1.79284291400159 - 0.85373472095314 * r;\n}\n\nfloat snoise(vec3 v)\n  { \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n  //   x1 = x0 - i1  + 1.0 * C.xxx;\n  //   x2 = x0 - i2  + 2.0 * C.xxx;\n  //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n  vec3 x1 = x0 - i1 + C.xxx;\n  vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n  vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n\n// Permutations\n  i = mod289(i); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients: 7x7 points over a square, mapped onto an octahedron.\n// The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n  float n_ = 0.142857142857; // 1.0/7.0\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n  //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n  }\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xts3Wj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 342, 360, 400, 673], [675, 675, 698, 698, 762], [769, 787, 815, 954, 1400], [1404, 1404, 1420, 1420, 1879], [2007, 2078, 2113, 2113, 2628], [2630, 2679, 2716, 2716, 2989], [2991, 3092, 3120, 3120, 3462], [3464, 3521, 3546, 3546, 3771], [3773, 3773, 3830, 3830, 4982], [5016, 5411, 5432, 5432, 5481], [5483, 5483, 5504, 5504, 5553], [5555, 5555, 5577, 5577, 5617], [5619, 5619, 5647, 5647, 5699], [5701, 5701, 5725, 5725, 7871]], "test": "untested"}
{"id": "XtS3zh", "name": "Glycerin Plasma", "author": "echophon", "description": "learn & edit shadeaday plasma", "tags": ["plasma", "remix", "shadeaday", "edit"], "likes": 4, "viewed": 167, "published": "Public", "date": "1427162054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Echophon poured some soap onto this.\n// Made into third eye tye-dye by Cale Bradbury - @netgrind 2015\n// Edited version of https://www.shadertoy.com/view/MsfGzM Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\nfloat f(vec3 p) \n{ \n    p.z-=iTime*.05;\n    return length(cos(p)-.001*cos(9.*(p.z*.09*p.x-p.y)+iTime*2.0))-(0.9+sin(iTime)*.1); \n}\n\nfloat g(vec3 p)\n{\n    p.x-=iTime*.08;\n    p.y-=iTime*.13;\n    return 1./(1.-p.x*p.y*p.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat i = iTime;\n    vec3 d = .5-vec3(fragCoord,1.)/iResolution.x;\n    d.y+=sin(0.01*i);\n    vec3 o=d;\n    float l = length(d.xyz)*5.;\n    float a = atan(d.y,d.x)*.2;\n    o.xy*= mat2(cos(i+sin(a+i))*0.1, 1.-sin(i*.05+a*l)*2.0, sin(i+a),cos(i*d.z+l)+2.0);\n    for(int i=0;i<4;i++){\n        o+=f(o)*d-g(d);\n        o*=-d-f(o)-g(d.zxy);\n    }\n    o.z = length(o*d);\n    fragColor=vec4(sin(i+abs((o+d)+length(o.xy*step(o.z,700.0))))*.3+.7,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtS3zh.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 288, 306, 306, 418], [420, 420, 437, 437, 511], [513, 513, 570, 570, 1014]], "test": "untested"}
{"id": "XtSGzh", "name": "impactSoundTest", "author": "cabbibo", "description": "testing bugs.YAY!", "tags": ["sound", "draft", "debug"], "likes": 1, "viewed": 137, "published": "Public", "date": "1426736041", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Mostly taken from \n// http://www.iquilezles.org/www/index.htm\n// https://www.shadertoy.com/user/iq\n\n\nconst float MAX_TRACE_DISTANCE = 6.0;           // max trace distance\nconst float INTERSECTION_PRECISION = 0.001;        // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 40;\n\n\nconst float loopSpeed   = .1;\nconst float loopTime    = 5.;\nconst float impactTime  = 1.;\nconst float impactFade  = .3;\nconst float fadeOutTime = .03;\nconst float fadeInTime  = .4;\nconst float whiteTime   = .3; // fade to white\n    \n  \n  \n\n// Trying to sync by using AND's code from\n// https://www.shadertoy.com/view/4sSSWz\n#define WARMUP_TIME     (2.0)\n\n// Shadertoy's sound is a bit out of sync every time you run it :(\n#define SOUND_OFFSET    (-0.0)\n\n\n\nconst int NUM_PLANETS = 1;\nvec3 planets[ NUM_PLANETS ];\n\nconst vec3 sun = vec3( 0. );\n\nvec2 impactLU[ 58 ];\n\n\n\n\n\n\n\n//-------\n// Extra Util Functions\n//-------\n\n\nvec3 hsv(float h, float s, float v)\n{\n  return mix( vec3( 1.0 ), clamp( ( abs( fract(\n    h + vec3( 3.0, 2.0, 1.0 ) / 3.0 ) * 6.0 - 3.0 ) - 1.0 ), 0.0, 1.0 ), s ) * v;\n}\n\n\n\n\nfloat hash (float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise (in vec3 x)\n{\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\n\tf = f*f*(3.0-2.0*f);\n\n\tfloat n = p.x + p.y*57.0 + 113.0*p.z;\n\n\tfloat res = mix(mix(mix( hash(n+  0.0), hash(n+  1.0),f.x),\n\t\t\t\t\t\tmix( hash(n+ 57.0), hash(n+ 58.0),f.x),f.y),\n\t\t\t\t\tmix(mix( hash(n+113.0), hash(n+114.0),f.x),\n\t\t\t\t\t\tmix( hash(n+170.0), hash(n+171.0),f.x),f.y),f.z);\n\treturn res;\n}\n\n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat tri(in float x){return abs(fract(x)-.5);}\nvec3 tri3(in vec3 p){return vec3( tri(p.z+tri(p.y*1.)), tri(p.z+tri(p.x*1.)), tri(p.y+tri(p.x*1.)));}\n                                 \n\n// Taken from https://www.shadertoy.com/view/4ts3z2\nfloat triNoise3D(in vec3 p, in float spd)\n{\n    float z=1.4;\n\tfloat rz = 0.;\n    vec3 bp = p;\n\tfor (float i=0.; i<=3.; i++ )\n\t{\n        vec3 dg = tri3(bp*2.);\n        p += (dg+iTime*.1*spd);\n\n        bp *= 1.8;\n\t\tz *= 1.5;\n\t\tp *= 1.2;\n        //p.xz*= m2;\n        \n        rz+= (tri(p.z+tri(p.x+tri(p.y))))/z;\n        bp += 0.14;\n\t}\n\treturn rz;\n}\n\n\n\n//----\n// Camera Stuffs\n//----\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time , in float timeInLoop, in float mouseX )\n{\n    float an = 0.3 + 10.0*mouseX;\n    float r = time;\n    \n    float extraSweep =  pow((clamp( timeInLoop , 1. , 3. ) - 3.), 2.);\n    float x = ( timeInLoop/2. + 2. ) *cos( 1.3 + .4 * timeInLoop - .3 * extraSweep );\n    float z = ( timeInLoop/2. + 2. ) *sin( 1.3 + .4 * timeInLoop - .3 * extraSweep );\n    \n   \n\tcamPos = vec3(x,.7,z);\n    camTar = vec3(timeInLoop / 2.,0.0,0.0);\n}\n\n\n\n//----\n// Distance Functions\n// http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//----\n\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)- s* (1.+ .4 * triNoise3D( p * .1 ,.3 ) + .2* triNoise3D( p * .3 ,.3 )) ;\n}\n\n// checks to see which intersection is closer\n// and makes the y of the vec2 be the proper id\nvec2 opU( vec2 d1, vec2 d2 ){\n    \n\treturn (d1.x<d2.x) ? d1 : d2;\n    \n}\n\n\n\n\n//--------------------------------\n// Modelling \n//--------------------------------\nvec2 map( vec3 pos ){  \n    \n    vec3 rot = vec3( 0. );//vec3( iTime * .05 + 1., iTime * .02 + 2. , iTime * .03  );\n    // Rotating box\n   \t//vec2 res = vec2( rotatedBox( pos , rot , vec3( 0.7 ) , .1 ) , 1.0 );\n   \t\n    vec2 res = vec2( sdSphere( pos , .8 ) , 1. );\n    \n    for( int i = 0; i < NUM_PLANETS; i++){\n    \tvec2 res2 = vec2( sdSphere( pos - planets[i] , .1 ), 2. );\n   \t\tres = opU( res , res2 );\n    }\n    \n   \treturn res;\n    \n}\n\n\n\nvec2 calcIntersection( in vec3 ro, in vec3 rd ){\n\n    \n    float h =  INTERSECTION_PRECISION*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    float id = -1.;\n    \n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        \n        if( h < INTERSECTION_PRECISION || t > MAX_TRACE_DISTANCE ) break;\n\t   \tvec2 m = map( ro+rd*t );\n        h = m.x;\n        t += h;\n        id = m.y;\n        \n    }\n\n    if( t < MAX_TRACE_DISTANCE ) res = t;\n    if( t > MAX_TRACE_DISTANCE ) id =-1.0;\n    \n    return vec2( res , id );\n    \n}\n\n// Calculates the normal by taking a very small distance,\n// remapping the function, and getting normal for that\nvec3 calcNormal( in vec3 pos ){\n    \n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t    map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t    map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\treturn normalize(nor);\n    \n}\n\n\n\n//------\n// Volumetric funness\n//------\n\nfloat posToFloat( vec3 p ){\n \n    float f = triNoise3D( p * .2 + vec3( iTime * .01 , 0. , 0.), .1 );\n    return f;\n    \n}\n\n\n\n// box rendering for title at end\nfloat inBox( vec2 p , vec2 loc , float boxSize ){\n \t\n    if( \n        p.x < loc.x + boxSize / 2. &&\n        p.x > loc.x - boxSize / 2. &&\n        p.y < loc.y + boxSize / 2. &&\n        p.y > loc.y - boxSize / 2. \n    ){\n        \n     return 1.;  \n        \n    }\n    \n\n   \n    return 0.;\n    \n    \n}\n\n\nfloat impact( vec2 p , float stillness ){\n  \n\n    float f = 0.;\n    \n    for( int i = 0; i < 58; i++ ){\n    \t\n        for( int j = 0; j < 8; j++ ){\n            \n            float size = (0.+( 20. * float( j ))) * stillness + 10.;\n            vec2 lu = impactLU[ i ] * size;\n            f += inBox( p , vec2( iResolution / 2. ) + lu , size );\n            \n            \n        }\n \n    }\n    \n\n \n  \n    \n    return f/8.;\n    \n    \n}\n\n#define FOG_STEPS 20\nvec4 overlayFog( vec3 ro , vec3 rd , vec2 screenPos , float hit ){\n \n    float lum = 0.;\n    vec3 col = vec3( 0. );\n    \n    float nSize = .002 * hit;\n   \tfloat n = (noise(vec3(2.0*screenPos, abs(sin(iTime * 10. ))*.1))*nSize) -.5* nSize;\n    for( int i = 0; i < FOG_STEPS; i++ ){\n        vec3 p = ro * ( 1. + n )  + rd  * ( MAX_TRACE_DISTANCE / float( FOG_STEPS))  * float( i );\n        \n        vec2 m  = map( p );\n\n        if( m.x < 0.0 ){ return vec4( col , lum ) / float( FOG_STEPS ); }\n        \n        \n      //\tm.x =  pow(clamp( m.x , 0. , 1. ),.1) * 10.;\n        float ss =  pow( clamp(pow( m.x * 10. , 3.)  , 0. , 5. )/5. , 1. );//m.x;// smoothstep( m.x , 0.2, .5 ) / .5;\n        \n        \n        float planetFog = 0.;\n        //planetFog += (1. / length( p-sun ));\n        \n        //for( int i  = 0; i < NUM_PLANETS; i++ ){\n            \n        planetFog += (10./ (length( p-planets[0] ) * length( planets[0] )));\n            \n        //}\n        \n        //Check to see if we\n        \n        if( length( p ) < 1.4 && length( p ) > .8 ){\n           \n            \n         \n            float d = (1.4 - length( p )) / .6;\n            lum += ss * 20. * posToFloat( p * (3. / length( p )) ) * d;//30. / length( p );\n            col += ss * vec3( 1. , 0. , 0. ) * 50. *  d* posToFloat( p* (3. / length( p )) );//* lum;\n        \n        }\n        \n        // TODO: MAKE THIS BETTER!!!!\n        //float fleck = noise( p * 10.);\n        //if( fleck > .99 ){ lum += 10.; col = vec3( 100000. ); }\n        \n        \n        lum += ss * pow( planetFog , 2. ) * .3 * posToFloat( p * .3 * planetFog  + vec3( 100. ));//// + sin( p.y * 3. ) + sin( p.z * 5.);\n        col += ss * planetFog * hsv( lum * .7 * (1. / float( FOG_STEPS))+ .5 , 1. , 1. );\n    }\n    \n    return vec4( col , lum ) / float(FOG_STEPS);\n    \n}\n\n\n\n\n\n/*vec3 doLighting( vec3 ro , vec3 rd ){\n    \n    \n    \n}*/\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    // CREATING 'IMPACT' \n    \n    \n    // I\n    impactLU[0] = vec2( -16. , 2. );\n\timpactLU[1] = vec2( -16. , 1. );\n\timpactLU[2] = vec2( -16. , 0. );\n\timpactLU[3] = vec2( -16. , -1. );\n\timpactLU[4] = vec2( -16. , -2. );\n    \n    \n    // M\n    impactLU[5] = vec2( -12. , 2. );\n\timpactLU[6] = vec2( -12. , 1. );\n\timpactLU[7] = vec2( -12. , 0. );\n\timpactLU[8] = vec2( -12. , -1. );\n\timpactLU[9] = vec2( -12. , -2. );\n    \n    impactLU[10] = vec2( -10. , 2. );\n\timpactLU[11] = vec2( -10. , 1. );\n\timpactLU[12] = vec2( -10. , 0. );\n\timpactLU[13] = vec2( -10. , -1. );\n\timpactLU[14] = vec2( -10. , -2. );\n    \n    impactLU[15] = vec2( -8. , 2. );\n\timpactLU[16] = vec2( -8. , 1. );\n\timpactLU[17] = vec2( -8. , 0. );\n\timpactLU[18] = vec2( -8. , -1. );\n\timpactLU[19] = vec2( -8. , -2. );\n    \n    // P\n    impactLU[20] = vec2( -4. , 2. );\n\timpactLU[21] = vec2( -4. , 1. );\n\timpactLU[22] = vec2( -4. , 0. );\n\timpactLU[23] = vec2( -4. , -1. );\n\timpactLU[24] = vec2( -4. , -2. );\n\n\timpactLU[25] = vec2( -2. , 2. );\n\timpactLU[26] = vec2( -2. , 1. );\n\timpactLU[27] = vec2( -2. , 0. );\n\n  \n\t// A\n    impactLU[28] = vec2( 2. , 2. );\n\timpactLU[29] = vec2( 2. , 1. );\n\timpactLU[30] = vec2( 2. , 0. );\n\timpactLU[31] = vec2( 2. , -1. );\n\timpactLU[32] = vec2( 2. , -2. );\n    \n    impactLU[33] = vec2( 3. , 2. );\n    \n    impactLU[34] = vec2( 4. , 2. );\n\timpactLU[35] = vec2( 4. , 1. );\n\timpactLU[36] = vec2( 4. , 0. );\n\timpactLU[37] = vec2( 4. , -1. );\n\timpactLU[38] = vec2( 4. , -2. );\n    \n    \n    // extra hooks for p and m...\n    impactLU[39] = vec2( -3. , 2. );\n    impactLU[40] = vec2( -11. , 2. );\n    impactLU[41] = vec2( -9. , 2. );\n    \n    \n    // C\n    \n    impactLU[42] = vec2( 8. , 2.  );\n\timpactLU[43] = vec2( 8. , 1.  );\n\timpactLU[44] = vec2( 8. , 0.  );\n\timpactLU[45] = vec2( 8. , -1. );\n\timpactLU[46] = vec2( 8. , -2. );\n    \n    impactLU[47] = vec2( 9. , 2.  );\n\timpactLU[48] = vec2( 10. , 2.  );\n\n    impactLU[49] = vec2( 9. , -2.  );\n\timpactLU[50] = vec2( 10. , -2.  );\n    \n      \n    // T\n    \n    impactLU[51] = vec2( 15. , 2.  );\n\timpactLU[52] = vec2( 15. , 1.  );\n\timpactLU[53] = vec2( 15. , 0.  );\n\timpactLU[54] = vec2( 15. , -1. );\n\timpactLU[55] = vec2( 15. , -2. );\n    \n    impactLU[56] = vec2( 14. , 2.  );\n\timpactLU[57] = vec2( 16. , 2.  );\n\n\n    \n    \n\n\t\n\n\n\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    \n    \n    \n    \n    float time = max(0.0, iTime - WARMUP_TIME);\n\n    float tInput = time;\n    float timeInLoop = loopTime - time * loopSpeed;\n    \n    for( int i = 0; i < 1; i++ ){\n     \n        float f = float( i );\n        //float r = 5. - mod( tInput , 5. );\n        \n        \n    \tfloat extraSweep =  pow((clamp( timeInLoop , 1. , 3. ) - 3.), 2.);\n        //float extraSweep = 2. - clamp( timeInLoop , 1. , 2. );\n        float r = 4.  - extraSweep * 1. ;\n        \n        \n        planets[i].x = r *(cos( .3 + .03 * timeInLoop));\n        planets[i].z = r *(sin( .3 + .03 * timeInLoop ));\n        \n        \n    }\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, tInput , timeInLoop , m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n    \n    //vec2 res = calcIntersection( ro , rd  );\n    \n    vec3 col = vec3( 0. ,0.,0. );\n  \n    if( timeInLoop > impactTime ){ \n        \n        vec2 res = calcIntersection( ro, rd );\n\n        if( res.y == 1. || res.y == 2. ){\n\n           vec3 pos = ro + rd * res.x;\n           vec3 nor = calcNormal( pos );\n\n           vec3 lightDir = pos - planets[0].xyz;\n\n           float lightL = length( lightDir );\n           lightDir = normalize( lightDir );\n\n\n           float match = max(  0. , dot( -nor , lightDir ));\n\n           vec3 refl = reflect( lightDir , nor );\n           float reflMatch = max( 0. , dot( -rd , refl ) );\n\n           //float\n\n           vec3 ambi = vec3( .1 );\n           vec3 lamb = vec3( 1. , .5 , .3 ) * match;\n           vec3 spec = vec3( 1. , .3 , .2 ) * pow(reflMatch,20.);\n           col =  (ambi + lamb + spec) * 3. / lightL; //nor  * .5 + .5;   \n\n        }\n        \n        float hit = 0.;\n        if( res.y == 1. || res.y == 2. ){ hit = 1.; }\n        //vec4 fog = overlayFog( ro , rd , fragCoord.xy , hit );\n        //col += .6 * fog.xyz * fog.w;\n        \n    }\n   \n    \n    // Fading in / fading out\n    float fadeIn = ((loopTime - clamp( timeInLoop , loopTime - fadeInTime , loopTime ))) / fadeInTime;\n    \n    float fadeOut = ((loopTime - clamp( (loopTime- timeInLoop) , loopTime - fadeOutTime , loopTime ))) / fadeOutTime;\n    \n    \n    // Gives us a straight fade to white\n    // to hide some weird noise we were \n    // seeing\n    if( timeInLoop < impactTime + whiteTime ){ col += vec3( 10. * (impactTime + whiteTime - timeInLoop) ); }\n    \n    \n   // if( fadeOut < .99 ){ col = vec3( 1. ); }\n    \n    \n    // TEXT\n    /*if( timeInLoop < impactTime ){ \n        \n        col = vec3( 1. );\n        \n        float imp = impact( fragCoord.xy , max( 0.2 , timeInLoop - fadeOutTime) -.2 );\n        float textFade = pow( max( 0. , timeInLoop - (impactTime - impactFade) ) / impactFade , 2. );\n\t\tcol = vec3( imp ) + vec3( textFade );      \n       // col = vec3( fragCoord.x ,  , 1. );\n        //col = texture( iChannel0 , sin(fragCoord.xy * 10. )).xyz;// vec3( 1. , 1. ,1. ); \n    }*/\n    \n    //col = pow( clamp(col,0.0,1.0), vec3(.8545) );\n   // col += dot(p,p*0.035);\n   // col.r = smoothstep(0.1,1.1,col.r);\n  //  col.g = pow(col.g, 1.1);\n    \n   // col = pow( col , .8 );\n    \n    //float per = ( (loopTime - timeInLoop) / loopTime ); \n    //if(per > .44 && per < .49 ){ col += vec3( 1. , 0. , 0. ); }\n\tfragColor = min( fadeOut , fadeIn )  * vec4(col,1.0);\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtSGzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[866, 912, 949, 949, 1081], [1086, 1086, 1108, 1108, 1144], [1146, 1146, 1171, 1171, 1507], [1510, 1562, 1584, 1584, 1609], [1610, 1610, 1631, 1631, 1711], [1747, 1799, 1842, 1842, 2145], [2149, 2180, 2244, 2244, 2422], [2424, 2424, 2529, 2529, 2910], [2914, 3022, 3057, 3057, 3151], [3153, 3247, 3276, 3276, 3319], [3324, 3408, 3429, 3429, 3849], [3853, 3853, 3901, 3901, 4368], [4370, 4483, 4514, 4514, 4745], [4749, 4790, 4817, 4817, 4911], [4915, 4949, 4998, 4998, 5246], [5249, 5249, 5290, 5290, 5679], [5702, 5702, 5768, 5768, 7516], [7522, 7583, 7639, 7689, 13574]], "test": "untested"}
{"id": "XtX3WX", "name": "Octahedral Interpolation", "author": "paniq", "description": "A method for linear interpolation of six octahedral corners that regresses to simple barycentric interpolation on the faces; drag the mouse for a cutaway; hit P to toggle the cutting plane. Hit N to toggle nearest neighbor interpolation.", "tags": ["mattdamon"], "likes": 5, "viewed": 1492, "published": "Public API", "date": "1425479210", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// linearly interpolates the three axes inside the octahedron with an average\n// of all edges at the center; it's not the most beautiful method\n// for some cases but meshes very well with the regular linear tetrahedral\n// interpolation.\n\n// see doMaterial for the interpolation routine\n\nvec2 m;\n\n// keys are javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nconst int Key_A = 65; const int Key_B = 66; const int Key_C = 67; const int Key_D = 68; const int Key_E = 69;\nconst int Key_F = 70; const int Key_G = 71; const int Key_H = 72; const int Key_I = 73; const int Key_J = 74;\nconst int Key_K = 75; const int Key_L = 76; const int Key_M = 77; const int Key_N = 78; const int Key_O = 79;\nconst int Key_P = 80; const int Key_Q = 81; const int Key_R = 82; const int Key_S = 83; const int Key_T = 84;\nconst int Key_U = 85; const int Key_V = 86; const int Key_W = 87; const int Key_X = 88; const int Key_Y = 89;\nconst int Key_Z = 90;\nconst int Key_0 = 48; const int Key_1 = 49; const int Key_2 = 50; const int Key_3 = 51; const int Key_4 = 52;\nconst int Key_5 = 53; const int Key_6 = 54; const int Key_7 = 55; const int Key_8 = 56; const int Key_9 = 57;\n\nbool ReadKey( int key )//, bool toggle )\n{\n\tbool toggle = true;\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\n//------------------------------------------------------------------------\n// Camera\n//\n// Move the camera. In this case it's using time and the mouse position\n// to orbitate the camera around the origin of the world (0,0,0), where\n// the yellow sphere is.\n//------------------------------------------------------------------------\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 0.3*iTime;\n    float d = 3.0;\n\tcamPos = vec3(d*sin(an),1.2,d*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\n\n//------------------------------------------------------------------------\n// Background \n//\n// The background color. In this case it's just a black color.\n//------------------------------------------------------------------------\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\n// 3D distance of XYZ cross diagonal plane\nfloat octahedron(vec3 p, float r) {\n    vec3 o = abs(p);\n\tfloat s = o.x+o.y+o.z;\n\treturn (s-r)/sqrt(3.0);\n}\n\nfloat sdf_round_box(vec3 p, vec3 b, float r) {\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nfloat doModel( vec3 p ) {\n    \n    float mouse_delta = clamp(m.x,0.0,1.0)*2.0-1.0;\n    float plane = p.y  + mouse_delta;\n    if (ReadKey(Key_P)) {\n\t\tplane = ((p.x+p.y+p.z) + mouse_delta)/sqrt(3.0);\n       \tplane = abs(plane)-0.01;\n    }\n    \n    return max(octahedron(p,1.0), plane);\n  \n}\n\n//------------------------------------------------------------------------\n// Material \n//\n// Defines the material (colors, shading, pattern, texturing) of the model\n// at every point based on its position and normal. In this case, it simply\n// returns a constant yellow color.\n//------------------------------------------------------------------------\n\n#define TEST 0\n\nvec3 hue2rgb(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nfloat gray(vec3 color) {\n    return dot(vec3(1.0/3.0), color);\n}\n\nvec3 doMaterial( in vec3 pos, in vec3 nor )\n{\n    \n#if TEST == 0\n    const vec3 c0 = vec3(1.0,0.5,0.0);\n    const vec3 c3 = vec3(0.0,0.5,1.0);\n    \n    const vec3 c2 = vec3(0.0,0.0,0.0);\n    const vec3 c5 = vec3(1.0,1.0,1.0);   \n    \n    const vec3 c1 = vec3(0.0,1.0,0.25);\n    const vec3 c4 = vec3(1.0,0.0,0.75);\n#elif TEST == 1\n    // edge case\n    const vec3 c0 = vec3(0.0,0.0,0.0);\n    const vec3 c1 = vec3(1.0,1.0,1.0);\n    const vec3 c2 = vec3(1.0,1.0,1.0);\n    const vec3 c3 = vec3(1.0,1.0,1.0);\n    const vec3 c4 = vec3(1.0,1.0,1.0);\n    const vec3 c5 = vec3(1.0,1.0,1.0);\n#else\n    // edge case\n    const vec3 c0 = vec3(1.0,1.0,1.0);\n    const vec3 c1 = vec3(0.0,0.0,0.0);\n    const vec3 c2 = vec3(0.0,0.0,0.0);\n    const vec3 c3 = vec3(0.0,0.0,0.0);\n    const vec3 c4 = vec3(0.0,0.0,0.0);\n    const vec3 c5 = vec3(0.0,0.0,0.0);\n#endif\n    \n    pos = vec3(pos.x, -pos.z, pos.y);\n    if (max(pos.x,max(pos.y,pos.z)) > 1.01)\n        return vec3(0.0);\n    \n    vec3 s,t;\n    vec3 col = vec3(0.0);\n\n    float d = (1.0 - (abs(pos.x)+abs(pos.y)+abs(pos.z)))/6.0;\n\n    s = d-min(pos,0.0);\n    t = d+max(pos,0.0);\n    \n    if (ReadKey(Key_N)) {\n        vec3 ps = floor(1.0+s-max(max(s.yzx,s.zxy),max(t.zxy,max(t.xyz,t.yzx))));\n        vec3 pt = floor(1.0+t-max(max(t.yzx,t.zxy),max(s.zxy,max(s.xyz,s.yzx))));\n        \n        s = ps;\n        t = pt;\n    }\n    \n    \n    col = c0*s.x + c1*s.y + c2*s.z + c3*t.x + c4*t.y + c5*t.z;\n\n#if 0\n    // check if total energy of colors is below 1\n    if ((abs(col.x)+abs(col.y)+abs(col.z)) < 0.99)\n        return vec3(1.0);\n\n#endif\n    \n#if 0\n    if (max(col.x,max(col.y,col.z)) > 1.01)\n        return vec3(1.0,0.0,0.0);\n#endif\n    \n    if (ReadKey(Key_C)) {\n    \treturn hue2rgb(gray(col));\n    } else {\n        return col;\n    }\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           // max trace distance\n\tconst float precis = 0.001;        // precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          // max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t );\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             // precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ) + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ) + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ) + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ) );\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)/iResolution.y;\n    m = iMouse.xy/iResolution.xy;\n\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n    \n    // camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iTime, m.x );\n\n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  // 0.0 is the camera roll\n    \n\t// create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); // 2.0 is the lens length\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t// raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        col = doMaterial( pos, nor );\n\t}\n\t   \n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtX3WX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[297, 1178, 1220, 1220, 1362], [1364, 1696, 1779, 1779, 1899], [1902, 2133, 2160, 2160, 2195], [2197, 2240, 2275, 2275, 2347], [2349, 2349, 2395, 2395, 2435], [2437, 2437, 2464, 2464, 2495], [2497, 2497, 2524, 2524, 2554], [2556, 2556, 2581, 2581, 2844], [2846, 3216, 3241, 3241, 3350], [3352, 3352, 3376, 3376, 3416], [3418, 3418, 3463, 3463, 5189], [5191, 5191, 5241, 5241, 5658], [5660, 5660, 5692, 5692, 6104], [6106, 6106, 6170, 6170, 6348], [6350, 6350, 6407, 6407, 7331]], "test": "untested"}
{"id": "XtXGDl", "name": "ngWaves09", "author": "netgrind", "description": "simple spiral", "tags": ["waves", "spiral", "cool", "netgrind"], "likes": 2, "viewed": 1217, "published": "Public API", "date": "1425973902", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 v, float a){\n\tfloat t = atan(v.y,v.x)+a;\n    float d = length(v);\n    v.x = cos(t)*d;\n    v.y = sin(t)*d;\n    return v;\n}\n\nvec4 hue(vec4 color, float shift) {\n\n    const vec4  kRGBToYPrime = vec4 (0.299, 0.587, 0.114, 0.0);\n    const vec4  kRGBToI     = vec4 (0.596, -0.275, -0.321, 0.0);\n    const vec4  kRGBToQ     = vec4 (0.212, -0.523, 0.311, 0.0);\n\n    const vec4  kYIQToR   = vec4 (1.0, 0.956, 0.621, 0.0);\n    const vec4  kYIQToG   = vec4 (1.0, -0.272, -0.647, 0.0);\n    const vec4  kYIQToB   = vec4 (1.0, -1.107, 1.704, 0.0);\n\n    // Convert to YIQ\n    float   YPrime  = dot (color, kRGBToYPrime);\n    float   I      = dot (color, kRGBToI);\n    float   Q      = dot (color, kRGBToQ);\n\n    // Calculate the hue and chroma\n    float   hue     = atan (Q, I);\n    float   chroma  = sqrt (I * I + Q * Q);\n\n    // Make the user's adjustments\n    hue += shift;\n\n    // Convert back to YIQ\n    Q = chroma * sin (hue);\n    I = chroma * cos (hue);\n\n    // Convert back to RGB\n    vec4    yIQ   = vec4 (YPrime, I, Q, 0.0);\n    color.r = dot (yIQ, kYIQToR);\n    color.g = dot (yIQ, kYIQToG);\n    color.b = dot (yIQ, kYIQToB);\n\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat i = iTime;\n    float scale = 5.0;\n\tvec2 uv = ( fragCoord.xy / iResolution.xy )*scale-scale*.5;\n    uv = rotate(uv,sin(length(uv)+i));\n    vec3 color = vec3(1.0);\n    float d = length(uv)*20.0+500.0;\n    float a = atan(uv.y,uv.x);\n    uv *= mat2(cos(d*sin(a*.01)),sin(-d*cos(a*.2)+i),-sin(d+tan(a*.01)+i),sin(i-d+a*5.0+cos(i+uv.x*3.0*a)));\n    color.gb = uv;\n    color.r = length(uv);\n    color.rgb = mod(color.rgb*.1,vec3(1.0));\n    color = normalize(color);\n\tfragColor = hue(vec4( color, 1.0 ),i);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXGDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 138], [140, 140, 175, 175, 1159], [1161, 1161, 1218, 1218, 1726]], "test": "untested"}
{"id": "XtXGWl", "name": "Fluid Feigenbaum", "author": "jcreed", "description": "Zoom in and out in feigenbaum diagram.", "tags": ["fractal"], "likes": 6, "viewed": 277, "published": "Public", "date": "1425937038", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 40\n#define M_PI 3.1415926535897932384626433832795\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 p = vec2(fragCoord.x / iResolution.x,\n                fragCoord.y / iResolution.y);\n  float z = fract(0.005 * iTime);\n  int acc = 0;\n  float trig = (cos(6. * M_PI * z) + 1.) / 2.;\n  float a = mix(2.5, 3.8, trig) + p.x * mix(1.5, 0.2, trig);\n  \n  float SC = mix(1., 3., trig);\n  float OFF = mix(0., 1., trig);\n  for (int i = 0; i < ITERS; i++) {\n    float zz = SC * z - OFF;\n    acc += (zz > p.y && zz <= p.y + 1. / iResolution.y) ? 1 : 0;\n    z = a * z * (1.-z);\n  }\n  float iters = float(ITERS);\n  float g = 60. * float(acc) / iters;\n\n  fragColor = vec4(1. - g, 1. - g /6., 1. - g / 10.,1.);\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XtXGWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[65, 65, 122, 122, 725]], "test": "untested"}
