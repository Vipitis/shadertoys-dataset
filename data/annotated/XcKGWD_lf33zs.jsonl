{"id": "XcKGWD", "name": "NotSoGreeeen - Quantization", "author": "NotSoGreeeen", "description": "Quantize - to approximate (a continuously varying signal) by one whose amplitude is restricted to a prescribed set of values.", "tags": ["texture", "array", "posterize", "quantize"], "image_code": "vec3 colors[8] = vec3[8] ( //8 color array to store the colors I aim to get\n    vec3(0.),\n    vec3(116, 146, 104) / vec3(256), //The array has to be defined as a definite size\n    vec3(108, 172, 148) / vec3(256), //And then set to a variable array of equal size\n    vec3(1.),                        //The array requires solely real numbers, but does allow math\n    vec3(116, 117, 67) / vec3(256),  //You can adjust the value of any position of the array,\n    vec3(71, 79, 90) / vec3(256),    //but for this it's not necessary.\n    vec3(66, 62, 38) / vec3(256),    //I hope this helps explain arrays to those who are also learning glsl!\n    vec3(134, 179, 130) / vec3(256)\n);\n\nvec3 Quantize(vec3 col) {\n    float dist = distance(colors[0], col); //create a distance, and set it to the first color of the array\n    vec3 tempColor = colors[0]; //create a color placeholder and set it to the first color the of array\n\n    for (int i = 1; i < colors.length(); i++) { //run through each color in the array (aside from the one we already used)\n        if (distance(colors[i], col) < dist) { //if it's color is closer to the actual color:\n            dist = distance(colors[i], col); //set the new distance to the closer distance\n            tempColor = colors[i]; //set the color placeholder to the new color\n        }\n    }\n\n    return tempColor; //update color to be the closest color in the palette\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy; //center the UV for a texture\n    \n    vec3 col = texture(iChannel0, uv).rgb; //grab the texture\n    \n    col = Quantize(col);\n    \n    fragColor = vec4(col, 1.); //display the quantized(or posterized) texture\n}\n\n//as always, feel free to send feedback and criticism.", "image_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcKGWD.jpg", "time_retrieved": "2024-04-28T18:58:52.070310", "access": "api", "wgpu-test": "ok"}
{"id": "4fy3WW", "name": "loopless epicycloid 2", "author": "FabriceNeyret2", "description": "now totally loopless.\nI analytically solve pixel closest to Cycloid_n(t), by same distance to center, and approx same angle.\n\nAny idea how to have less jaggies ?", "tags": ["golf", "loopless", "epicycloid"], "image_code": "// improving https://shadertoy.com/view/XfKGW1\n\n#define CS(a) cos(a+vec2(0,11))                  // (cos(a),sin(a))\n\n            // solves atan( epicycloid(t) ) ~ atan(U) \n#define C  T = t + 6.283/n* round( (atan(U.y,U.x) - t ) *n/6.283 ); \\\n                       /*  epicycloid       */                      \\\n           l = length( CS(T) + r* CS((n+1.)*T) - U ) ;              \\\n           O += smoothstep( 1.5, 0., l/min(.1,fwidth(l)) ) // AA draw\n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    vec2  R = iResolution.xy,\n          U = 2.*( u+u - R ) / R.y;              // normalized coordinates\n    float n = 9., r = .2, T, l,                  // epicycloid parameters\n                                                 // solves | epicycloid(t) | = | U | \n          t = acos( clamp( ( dot(U,U) - 1. - r*r ) *.5/r , -1.,1.) ) / n;\n     O = vec4(0);\n     C; t = -t; C;                               // cos(t) & cos(-t) solutions\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fy3WW.jpg", "time_retrieved": "2024-04-28T18:58:52.250828", "access": "api", "wgpu-test": "ok"}
{"id": "mssfW7", "name": "doublethink", "author": "prishainabox", "description": "starting from scratch\nhttps://www.youtube.com/watch?v=sl9x19EnKng", "tags": ["raymarching"], "image_code": "const int AA = 2; // sqrt(number of samples per pixel) add later\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdBox(in vec3 pt, in vec3 r) {\n    return length(max(abs(pt) - r, 0.0));\n}\n\nfloat sdSphere(vec3 pt, float r) {\n    return length(pt) - r;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n// return vec4( signed distance, pt )\nvec4 sdf(in vec3 pt) {\n\n    float time = iTime;\n    float d = 100.0;\n\n    // center\n    d = sdSphere(pt - vec3(cos(time), sin(time), 0.0) * 3.0, 0.2);\n    \n    // teeth 1\n    {   \n        vec3 q = pt;\n\n        float sectorSize = 6.283185/32.0;\n        float sectorId = round(atan(pt.z, pt.x)/sectorSize);\n        float an = sectorId * sectorSize;\n        \n        // rotate q to x axis\n        q.xz = mat2(cos(an), -sin(an), sin(an), cos(an)) * q.xz;\n        \n        float t = sdBox(q - vec3(1.0, 0, 0), vec3(0.04, 0.05, 0.1)) - 0.05;\n        q.xy = mat2(cos(0.5), -sin(0.5), sin(0.5), cos(0.5)) * q.xy;\n        t = min(t, sdBox(q - vec3(0.9, -0.4, 0), vec3(0.5, 0.01, 0.01)) - 0.01);\n        \n        \n        d = min(d, t);\n        \n    }\n    \n    //experiment\n    {\n        vec3 q = pt - vec3(0.0, -0.2, 0.0);\n        float ex = length(abs(vec2(pt.x, pt.x*pt.x*pt.x*2.0) - q.xy)) - 0.03;\n        ex = max(ex, abs(q.x) - 0.5);\n        ex = max(ex, abs(q.z) - 0.5);\n        d = min(ex, d);\n    }\n\n    return vec4(d, pt);\n\n}\n\nvec3 calcNormal(in vec3 pt) {\n\n    vec2 h = vec2(0.001, 0.0);\n\n    return normalize(vec3(\n        sdf(pt + h.xyy).x - sdf(pt - h.xyy).x,\n        sdf(pt + h.yxy).x - sdf(pt - h.yxy).x,\n        sdf(pt + h.yyx).x - sdf(pt - h.yyx).x\n    ));\n\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec4 raymarch(in vec3 ro, in vec3 rd) {\n\n    vec4 res = vec4(-1);\n    \n    float td = 0.001;\n    float tmax = 5.0;\n    for (int i = 0; i < 128 && td < tmax; i++) {\n        vec4 h = sdf(ro + td*rd);\n        if (abs(h.x) < 0.001) {\n            res = vec4(td, h.yzw);\n            break;\n        }\n        td += h.x;\n    }\n    \n    return res;\n\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nvec3 render(in vec2 uv, in vec3 ro, in vec3 rd) {\n\n    vec3 clr = vec3(0);\n    \n    vec4 intersection = raymarch(ro, rd);\n    float dist = intersection.x;\n    \n    if (dist > 0.0) {\n        clr = 0.5 + 0.5*vec3(calcNormal(ro + rd*dist));\n    }\n   \n    \n    clr.r = smoothstep(0.0, 1.0, clr.r);\n    clr.g = smoothstep(0.0, 1.0, clr.g);\n    clr.b = smoothstep(0.0, 1.0, clr.b);\n    \n    return clr;\n    \n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nvec3 setCamera(in vec2 uv, in vec3 ro, in vec3 target, in float zoom) {\n    vec3 f = normalize(target - ro);\n    vec3 r = normalize(cross(f, vec3(0, 1, 0)));\n    vec3 u = normalize(cross(r, f));\n    return normalize(uv.x * r + uv.y * u + zoom * f);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    // Normalized pixel coordinates\n    vec2 uv = (2.0 * fragCoord - iResolution.xy)/iResolution.y;\n    float time = iTime * 0.5;\n    \n    vec3 ro = vec3(sin(time) * 1.8, 1.0, cos(time) * 1.8);\n    vec3 target = vec3(0);\n    vec3 rd = setCamera(uv, ro, target, 1.2);\n    \n    vec3 clr = render(uv, ro, rd);\n\n    // Output to screen\n    fragColor = vec4(clr, 1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/mssfW7.jpg", "time_retrieved": "2024-04-28T18:58:53.081605", "access": "api", "wgpu-test": "ok"}
{"id": "Dl2yRy", "name": "Ã‹", "author": "me_123", "description": "f", "tags": ["s"], "image_code": "/*\ntest\n*/\n//<^^MAGIC^^>\nvoid mainImage(out vec4 f,in vec2 g){}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Dl2yRy.jpg", "time_retrieved": "2024-04-28T18:58:53.350884", "access": "api", "wgpu-test": "ok"}
{"id": "MfK3Wh", "name": "Coastal Landscape Tribute Fork", "author": "SentientCymatic", "description": "\"I wanted to do something in the spirit of Van Gogh. It looks better on the full screen.\"\n\n... I wanted to pour colors on this and change the motion a little bit. Thanks, this was fun to play with!", "tags": ["2d", "landscape", "vangogh"], "image_code": "/*\n// Author: bitless\n// Title: Coastal Landscape\n\n// Thanks to Patricio Gonzalez Vivo & Jen Lowe for \"The Book of Shaders\"\n// and Fabrice Neyret (FabriceNeyret2) for https://shadertoyunofficial.wordpress.com/\n// and Inigo Quilez (iq) for  https://iquilezles.org/www/index.htm\n// and whole Shadertoy community for inspiration.\n\n#define p(t, a, b, c, d) ( a + b*cos( 6.28318*(c*t+d) ) ) //IQ's palette function (https://www.iquilezles.org/www/articles/palettes/palettes.htm)\n#define sp(t) p(t,vec3(.26,.76,.77),vec3(1,.3,1),vec3(.8,.4,.7),vec3(0,.12,.54)) //sky palette\n#define hue(v) ( .6 + .76 * cos(6.3*(v) + vec4(0,23,21,0) ) ) //hue\n\n// \"Hash without Sine\" by Dave_Hoskins.\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n  vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\n  vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n////////////////////////\n\nvec2 rotate2D (vec2 st, float a){\n    return  mat2(cos(a),-sin(a),sin(a),cos(a))*st;\n}\n\nfloat st(float a, float b, float s) //AA bar\n{\n    return smoothstep (a-s, a+s, b);\n}\n\nfloat noise( in vec2 p ) //gradient noise\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n    \n    vec2 u = f*f*(3.-2.*f);\n\n    return mix( mix( dot( hash22( i+vec2(0,0) ), f-vec2(0,0) ), \n                     dot( hash22( i+vec2(1,0) ), f-vec2(1,0) ), u.x),\n                mix( dot( hash22( i+vec2(0,1) ), f-vec2(0,1) ), \n                     dot( hash22( i+vec2(1,1) ), f-vec2(1,1) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 O, in vec2 g)\n{\n    vec2 r = iResolution.xy\n        ,uv = (g+g-r)/r.y\n        ,sun_pos = vec2(r.x/r.y*.42,-.53) //sun position \n        ,tree_pos = vec2(-r.x/r.y*.42,-.2) //tree position \n        ,sh, u, id, lc, t;\n\n    vec3 f, c;\n    float xd, yd, h, a, l;\n    vec4 C;\n    \n    float sm = 3./r.y; //smoothness factor for AA\n\n    sh = rotate2D(sun_pos, noise(uv+iTime*.25)*.3); //big noise on the sky\n     \n    if (uv.y > -.4) //drawing the sky\n    {\n        u = uv + sh;\n        \n        yd = 60.; //number of rings \n        \n        id =  vec2((length(u)+.01)*yd,0); //segment id: x - ring number, y - segment number in the ring  \n        xd = floor(id.x)*.09; //number of ring segments\n        h = (hash12(floor(id.xx))*.5+.25)*(iTime+10.)*.25; //ring shift\n        t = rotate2D (u,h); //rotate the ring to the desired angle\n    \n        id.y = atan(t.y,t.x)*xd;\n        lc = fract(id); //segment local coordinates\n        id -= lc;\n    \n        // determining the coordinates of the center of the segment in uv space\n        t = vec2(cos((id.y+.5)/xd)*(id.x+.5)/yd,sin((id.y+.5)/xd)*(id.x+.5)/yd); \n        t = rotate2D(t,-h) - sh;\n    \n        h = noise(t*vec2(.5,1)-vec2(iTime*.2,0)) //clouds\n            * step(-.25,t.y); //do not draw clouds below -.25\n        h = smoothstep (.052,.055, h);\n        \n        \n        lc += (noise(lc*vec2(1,4)+id))*vec2(.7,.2); //add fine noise\n        \n        f = mix (sp(sin(length(u)-.1))*.35, //sky background\n                mix(sp(sin(length(u)-.1)+(hash12(id)-.5)*.15),vec3(1),h), //mix sky color and clouds\n                st(abs(lc.x-.5),.4,sm*yd)*st(abs(lc.y-.5),.48,sm*xd));\n    };\n\n    if (uv.y < -.35) //drawing water\n    {\n\n        float cld = noise(-sh*vec2(.5,1)  - vec2(iTime*.2,0)); //cloud density opposite the center of the sun\n        cld = 1.- smoothstep(.0,.15,cld)*.5;\n\n        u = uv*vec2(1,15);\n        id = floor(u);\n\n        for (float i = 1.; i > -1.; i--) //drawing a wave and its neighbors from above and below\n        {\n            if (id.y+i < -5.)\n            {\n                lc = fract(u)-.5;\n                lc.y = (lc.y+(sin(uv.x*12.-iTime*3.+id.y+i))*.25-i)*4.; //set the waveform and divide it into four strips\n                h = hash12(vec2(id.y+i,floor(lc.y))); //the number of segments in the strip and its horizontal offset\n                \n                xd = 6.+h*4.;\n                yd = 30.;\n                lc.x = uv.x*xd+sh.x*9.; //divide the strip into segments\n                lc.x += sin(iTime * (.5 + h*2.))*.5; //add a cyclic shift of the strips horizontally\n                h = .8*smoothstep(5.,.0,abs(floor(lc.x)))*cld+.1; //determine brightness of the sun track \n                f = mix(f,mix(vec3(0,.1,.5),vec3(.35,.35,0),h),st(lc.y,0.,sm*yd)); //mix the color of the water and the color of the track for the background of the water \n                lc += noise(lc*vec2(3,.5))*vec2(.1,.6); //add fine noise to the segment\n                \n                f = mix(f,                                                                         //mix the background color \n                    mix(hue(hash12(floor(lc))*.1+.56).rgb*(1.2+floor(lc.y)*.17),vec3(1,1,0),h)     //and the stroke color\n                    ,st(lc.y,0.,sm*xd)\n                    *st(abs(fract(lc.x)-.5),.48,sm*xd)*st(abs(fract(lc.y)-.5),.3,sm*yd)\n                    );\n            }\n        }\n    }\n    \n    O = vec4(f,1);\n\n    ////////////////////// drawing the grass\n    a = 0.;\n    u = uv+noise(uv*2.)*.1 + vec2(0,sin(uv.x*1.+3.)*.4+.8);\n    \n    f = mix(vec3(.7,.6,.2),vec3(0,1,0),sin(iTime*.2)*.5+.5); //color of the grass, changing from green to yellow and back again\n    O = mix(O,vec4(f*.4,1),step(u.y,.0)); //draw grass background\n\n    xd = 60.;  //grass size\n    u = u*vec2(xd,xd/3.5); \n    \n\n    if (u.y < 1.2)\n    {\n        for (float y = 0.; y > -3.; y--)\n          {\n            for (float x = -2.; x <3.; x++)\n            {\n                id = floor(u) + vec2(x,y);\n                lc = (fract(u) + vec2(1.-x,-y))/vec2(5,3);\n                h = (hash12(id)-.5)*.25+.5; //shade and length for an individual blade of grass\n\n                lc-= vec2(.3,.5-h*.4);\n                lc.x += sin(((iTime*1.7+h*2.-id.x*.05-id.y*.05)*1.1+id.y*.5)*2.)*(lc.y+.5)*.5;\n                t = abs(lc)-vec2(.02,.5-h*.5);\n                l =  length(max(t,0.)) + min(max(t.x,t.y),0.); //distance to the segment (blade of grass)\n\n                l -= noise (lc*7.+id)*.1; //add fine noise\n                C = vec4(f*.25,st(l,.1,sm*xd*.09)); //grass outline                \n                C = mix(C,vec4(f                  //grass foregroud\n                            *(1.2+lc.y*2.)  //the grass is a little darker at the root\n                            *(1.8-h*2.5),1.)    //brightness variations for individual blades of grass\n                            ,st(l,.04,sm*xd*.09));\n                \n                O = mix (O,C,C.a*step (id.y,-1.));\n                a = max (a, C.a*step (id.y,-5.));  //a mask to cover the trunk of the tree with grasses in the foreground\n            }\n        }\n    }\n\n    float T = sin(iTime*.5); //tree swing cycle\n \n    if (abs(uv.x+tree_pos.x-.1-T*.1) < .6) // drawing the tree\n    {\n        u = uv + tree_pos;\n        // draw the trunk of the tree first\n        u.x -= sin(u.y+1.)*.2*(T+.75); //the trunk bends in the wind\n        u += noise(u*4.5-7.)*.25; //trunk curvature\n        \n        xd = 10., yd = 60.; \n        t = u * vec2(1,yd); //divide the trunk into segments\n        h = hash12(floor(t.yy)); //horizontal shift of the segments and the color tint of the segment  \n        t.x += h*.01;\n        t.x *= xd;\n        \n        lc = fract(t); //segment local coordinates\n        \n        float m = st(abs(t.x-.5),.5,sm*xd)*step(abs(t.y+20.),45.); //trunk mask\n        C = mix(vec4(.07) //outline color\n                ,vec4(.5,.3,0,1)*(.4+h*.4) //foreground color \n                ,st(abs(lc.y-.5),.4,sm*yd)*st(abs(lc.x-.5),.45,sm*xd));\n        C.a = m;\n        \n        xd = 30., yd = 15.;\n        \n        for (float xs =0.;xs<4.;xs++) //drawing four layers of foliage\n        {\n            u = uv + tree_pos + vec2 (xs/xd*.5 -(T +.75)*.15,-.7); //crown position\n            u += noise(u*vec2(2,1)+vec2(-iTime+xs*.05,0))*vec2(-.25,.1)*smoothstep (.5,-1.,u.y+.7)*.75; //leaves rippling in the wind\n    \n            t = u * vec2(xd,1.);\n            h = hash12(floor(t.xx)+xs*1.4); //number of segments for the row\n            \n            yd = 5.+ h*7.;\n            t.y *= yd;\n    \n            sh = t;\n            lc = fract(t);\n            h = hash12(t-lc); //segment color shade\n    \n            \n            t = (t-lc)/vec2(xd,yd)+vec2(0,.7);\n            \n            m = (step(0.,t.y)*step (length(t),.45) //the shape of the crown - the top \n                + step (t.y,0.)*step (-0.7+sin((floor(u.x)+xs*.5)*15.)*.2,t.y)) //the bottom\n                *step (abs(t.x),.5) //crown size horizontally\n                *st(abs(lc.x-.5),.35,sm*xd*.5); \n    \n            lc += noise((sh)*vec2(1.,3.))*vec2(.3,.3); //add fine noise\n            \n            f = hue((h+(sin(iTime*.2)*.5+.5))*.2).rgb-t.x; //color of the segment changes cyclically\n    \n            C = mix(C,\n                    vec4(mix(f*.15,f*.6*(.7+xs*.2), //mix outline and foreground color\n                        st(abs(lc.y-.5),.47,sm*yd)*st(abs(lc.x-.5),.2,sm*xd)),m)\n                    ,m);\n        }\n\n        O = mix (O,C,C.a*(1.-a));\n    }\n}\n*/\n\n// Psychedelic Iteration\n#define p(t,a,b,c,d)(a+b*cos(6.28318*(c*t+d)))\n#define sp(t)p(t,vec3(.26,.76,.77),vec3(1,.3,1),vec3(.8,.4,.7),vec3(0,.12,.54))\n#define hue(v)(.6+.76*cos(6.3*(v)+vec4(0,23,21,0)))\nfloat h12(vec2 p){vec3 p3=fract(vec3(p.xyx)*.01);p3+=dot(p3,p3.yzx+33.11);return fract((p3.x+p3.y)*p3.z);}\nvec2 h22(vec2 p){vec3 p3=fract(vec3(p.xyx)*vec3(.1031,.103,.0973));p3+=dot(p3,p3.yzx+33.11);return fract((p3.xx+p3.yz)*p3.zy);}\nvec2 r2D(vec2 st,float a){return mat2(cos(a),-sin(a),sin(a),cos(a))*st;}\nfloat st(float a,float b,float s){return smoothstep(a-s,a+s,b);}\nfloat n(vec2 p){vec2 i=floor(p);vec2 f=fract(p);vec2 u=f*f*(3.-2.*f);return mix(mix(dot(h22(i+vec2(0,0)),f-vec2(0,0)),dot(h22(i+vec2(1,0)),f-vec2(1,0)),u.x),mix(dot(h22(i+vec2(0,1)),f-vec2(0,1)),dot(h22(i+vec2(1,1)),f-vec2(1,1)),u.x),u.y);}\nvoid mainImage(out vec4 O,in vec2 g){vec2 r=iResolution.xy,uv=(g+g-r)/r.y,sun=vec2(r.x/r.y*.42,-.53),tree=vec2(-r.x/r.y*.42,-.2),sh,u,id,lc,t;vec3 f,c;float xd,yd,h,a,l;vec4 C;float sm=3./r.y;sh=r2D(sun,n(uv+iTime*.25)*.3);if(uv.y>-.4){u=uv+sh;yd=75.;id=vec2((length(u)+.01)*yd,0);xd=floor(id.x)*.1;h=(h12(floor(id.xx))*.15+.15)*(iTime+10.)*-.1;t=r2D(u,-h);id.y=atan(t.y,t.x)*xd;lc=fract(id);id-=lc;t=vec2(cos((id.y+.5)/xd)*(id.x+.5)/yd,sin((id.y+.5)/xd)*(id.x+.5)/yd);t=r2D(t,-h)-sh;h=n(t*vec2(.5,1)-vec2(iTime*.2,0))*step(-.25,t.y);h=smoothstep(.052,.055,h);lc+=(n(lc*vec2(1,4)+id))*vec2(.7,.2);f=mix(sp(sin(length(u)-.1))*.3,mix(sp(sin(length(u)-.1)+(h12(id)-.5)*.35),vec3(1),h),st(abs(lc.x-.5),.4,sm*yd)*st(abs(lc.y-.5),.48,sm*xd));}if(uv.y<-.35){float cld=n(-sh*vec2(.5,1)-vec2(iTime*.2,0));cld=1.-smoothstep(.0,.15,cld)*.5;u=uv*vec2(1,15);id=floor(u);for(float i=1.;i>-1.;i--){if(id.y+i<-5.){lc=fract(u)-.5;lc.y=(lc.y+(sin(uv.x*12.-iTime*3.+id.y+i))*.25-i)*4.;h=h12(vec2(id.y+i,floor(lc.y)));xd=6.+h*4.;yd=30.;lc.x=uv.x*xd+sh.x*8.;lc.x+=sin(iTime*(.5+h*2.))*.5;h=.8*smoothstep(5.,.0,abs(floor(lc.x)))*cld+.1;f=mix(f,mix(vec3(0,.15,.9),vec3(.25,.1,0),h),st(lc.y,0.,sm*yd));lc+=n(lc*vec2(3,.5))*vec2(.1,.6);f=mix(f,mix(hue(h12(floor(lc))*.1+.56).rgb*(1.2+floor(lc.y)*.17),vec3(1,1,0),h),st(lc.y,0.,sm*xd)*st(abs(fract(lc.x)-.5),.48,sm*xd)*st(abs(fract(lc.y)-.5),.3,sm*yd));}}}O=vec4(f,1);a=0.;u=uv+n(uv*2.)*.1+vec2(0,sin(uv.x*1.75+2.)*.10+.75);float angle=atan(u.x,u.y);vec3 noiseColor=vec3(sin(angle+iTime*1.0),sin(angle+iTime*1.0+2.094),sin(angle+iTime*1.0+4.188));vec3 rainbowColor=vec3(0.5+0.5*noiseColor.r,0.5+0.5*noiseColor.g,0.5+0.5*noiseColor.b);xd=90.0;u=u*vec2(xd,xd/3.5);if(u.y<1.2){for(float y=0.;y>-3.;y--){for(float x=-2.;x<3.;x++){id=floor(u)+vec2(x,y);lc=(fract(u)+vec2(1.-x,-y))/vec2(5,3);h=(h12(id)-0.5)*0.25+0.5;lc-=vec2(0.3,0.5-h*0.4);lc.x+=sin(((iTime*1.7+h*2.-id.x*0.05-id.y*0.05)*1.1+id.y*0.5)*2.)*(lc.y+0.5)*0.5;t=abs(lc)-vec2(0.02,0.5-h*0.5);l=length(max(t,0.))+min(max(t.x,t.y),0.);vec3 hueShift=vec3(sin((uv.x+iTime*0.2)*5.0),sin((uv.x+iTime*0.2+2.094)*5.0),sin((uv.x+iTime*0.2+4.188)*5.0));hueShift+=vec3(sin((uv.y+iTime*0.1)*10.0)*0.1,sin((uv.y+iTime*0.1+1.047)*10.0)*0.1,sin((uv.y+iTime*0.1+2.094)*10.0)*0.1);vec3 bladeColor=vec3(0.5+0.5*noiseColor.r+0.25*hueShift.r,0.5+0.5*noiseColor.g+0.25*hueShift.g,0.5+0.5*noiseColor.b+0.25*hueShift.b);C=vec4(bladeColor*0.25,st(l,0.1,sm*xd*0.1));C=mix(C,vec4(bladeColor*(1.2+lc.y*2.)*(1.8-h*2.5),1.),st(l,0.04,sm*xd*0.09));O=mix(O,C,C.a*step(id.y,-1.));a=max(a,C.a*step(id.y,-5.));}}}float T=sin(iTime*0.5);if(abs(uv.x+tree.x-0.1-T*0.1)<0.6){u=uv+tree;u.x-=sin(u.y+1.0)*0.2*(T+0.75);u+=n(u*4.5-20.0)*0.25;float xd=10.0;float yd=60.0;vec2 t=u*vec2(1.0,yd);float h=h12(floor(t.yy));t.x+=h*0.01;t.x*=xd;vec2 lc=fract(t);float m=st(abs(t.x-0.5),0.5,sm*xd)*step(abs(t.y+20.0),45.0);vec4 C=mix(vec4(0.07),vec4(0.5,0.3,0,1)*(0.4+h*0.4),st(abs(lc.y-0.5),0.4,sm*yd)*st(abs(lc.x-0.5),0.45,sm*xd));C.a=m;xd=45.0;yd=15.0;for(float xs=0.0;xs<4.0;xs++){u=uv+tree+vec2(xs/xd*0.5-(T+0.75)*0.15,-0.9);u+=n(u*vec2(2.0,1.0)+vec2(-iTime+xs*0.05,0.0))*vec2(-0.25,0.1)*smoothstep(0.5,-1.0,u.y+0.7)*0.75;t=u*vec2(xd,1.3);h=h12(floor(t.xx)+xs*1.4);yd=5.0+h*9.0;t.y*=yd;vec2 sh=t;lc=fract(t);h=h12(t-lc);t=(t-lc)/vec2(xd,yd)+vec2(0.01,0.9);m=(step(0.0,t.y)*step(length(t),0.5)+step(t.y,0.0)*step(-0.7+sin((floor(u.x)+xs*1.0)*50.0)*1.0,t.y))*step(abs(t.x),0.75)*st(abs(lc.x-0.5),0.35,sm*xd*0.5);lc+=n(sh)*vec2(0.2,0.2);vec3 prevF=hue((fract(h+(sin(iTime*0.15)*0.15+0.15)))*0.8).rgb-t.x;vec3 nextF=hue((fract(h+(sin(iTime*0.15)*0.15+0.15)))*0.8).rgb-t.x;vec3 f=mix(prevF,nextF,0.9);C=mix(C,vec4(mix(f*0.15,f*0.6*(0.7+xs*0.2),st(abs(lc.y-0.5),0.47,sm*yd)*st(abs(lc.x-0.5),0.2,sm*xd)),m),m);}O=mix(O,C,C.a*(1.0-a));}}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MfK3Wh.jpg", "time_retrieved": "2024-04-28T18:58:54.762107", "access": "api", "wgpu-test": "ok"}
{"id": "XfK3W1", "name": "simple torn leaf shader", "author": "unnick", "description": "saw https://mas.to/@TodePond/112239788123432054 and decided to do a shader about it", "tags": ["asdf"], "image_code": "// this work is marked with CC0 1.0 universal <https://creativecommons.org/publicdomain/zero/1.0>\n\n#define res iResolution.xy\n\nconst vec3 c1 = vec3(21,25,39) / 255.;\nconst vec3 c2 = vec3(117,252,148) / 255.;\n\nconst float tau = 6.283;\n\nvec2 av(float a) {\n    a *= tau;\n    return vec2(cos(a), sin(a));\n}\n\nfloat linedist(vec2 p, vec2 l, vec2 h) {\n    p -= l;\n    h -= l;\n    return length((h * clamp(dot(p, h) / dot(h,h),0.,1.)) - p);\n}\n\nvoid mainImage(out vec4 col, in vec2 coord){\n    vec2 pos = (coord*2. - res) / min(res.x, res.y);\n    pos.y -= .2;\n    pos.x += pos.y*pos.y*.1;\n    float dist = length(abs(pos)+vec2(.4,0)) - .8;\n    vec2 tmp = pos+vec2(.8,.6);\n    //dist = min(dist, max(abs(length(tmp)-.8)-.03, max(dot(tmp, av(.75-.1)),tmp.y)));\n    dist = min(dist, linedist(pos, vec2(0), vec2(0,-1.)) - .03);\n    dist = max(dist, .1*(1. + cos(pos.x/.4*tau) * .25 - pos.x*.6)-abs(pos.y - mix(-.4, .4, smoothstep(-.5,.5,pos.x))));\n    dist = max(dist, .02-linedist(pos, vec2(0,.25), vec2(0,.55)));\n    dist = max(dist, .02-linedist(pos, vec2(0,-.25), vec2(0,-.55)));\n    col = vec4(mix(c2,c1,smoothstep(-1.,1.,dist / length(vec2(dFdx(dist), dFdy(dist))))),1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfK3W1.jpg", "time_retrieved": "2024-04-28T18:58:55.314629", "access": "api", "wgpu-test": "ok"}
{"id": "XfKGW1", "name": "loopless epicycloid", "author": "FabriceNeyret2", "description": "here loopless means iterationless:\nI analytically solve pixel closest to Cycloid_n(t), yielding 2n solutions whatever the screen resolution.\n\nAny idea how to have less jaggies ?", "tags": ["golf", "loopless", "epicycloid"], "image_code": "#define CS(a) cos(a+vec2(0,11))\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2  R = iResolution.xy, P,\n          U = 2.*( u+u - R ) / R.y,              // normalized coordinates\n          V = U; V.y = -V.y;\n    float n = 9., r = .2, l,                     // epicycloid parameters\n                                                 // solve | P(t) | = | U | \n          t = acos( clamp(.5*( dot(U,U) - 1. - r*r ) / r ,-1.,1.) ) / n;\n          // atan(P) = atan(U) is harder to exploit, but could at leat give a range.\n    for( O = vec4(0 ; t < 6.283; t += 6.283/n )  // all the cos( nt ) solutions\n       P = CS(t) + r*CS((n+1.)*t),               // epicycloid_n(t)\n       l =  min( length(P-U), length(P-V) ),     // cos(t) & cos(-t) solutions\n       O += smoothstep( 1.5, 0., l/fwidth(l) );  // draw\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfKGW1.jpg", "time_retrieved": "2024-04-28T18:58:55.473205", "access": "api", "wgpu-test": "error"}
{"id": "Xfy3Dh", "name": "work in progress starielsl", "author": "starielsl", "description": "i plan to add ocean", "tags": ["terrain", "sun", "clouds"], "image_code": "#define FAR 100.\n#define STEPS 64\nfloat NEAR = .01;\n\nstruct DirectionalLight\n{\n    vec3 position;\n    float intensity;\n    vec3 color;\n};\n\nDirectionalLight light = DirectionalLight(\n    vec3(0, 0, -15),\n    1.,\n    vec3(1)\n);\n\nvec3 ro = vec3(0, 0, 0);\nvec2 uv = vec2(0);\nvec2 fragCoords = vec2(0);\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat WaterPlane(vec3 p, float h)\n{\n    float t = rnoise(p.xz + iTime, 4);\n    return p.y - t / 2. - h;\n}\n\nbool isWater = false;\n\nfloat Scene(vec3 p, bool isLight, bool isVolumetric, bool useBoth)\n{\n     isWater = false;\n     float s = Sphere(p - vec3(0, 0, -10), 1.);\n     p.y += 4.;\n     float t = FAR;\n     if (length(p - ro) < 15.)\n     {\n         t = rnoise(p.xz / 4., 8) * 4.;\n         t = t * sin(length(p.xz - ro.xz) / 15.); // round terrain\n         t = p.y - t;\n     }\n     //float water = FAR;\n     \n     //water = WaterPlane(p, 0.6);\n     //t = min(t, water);\n     //isWater = t == water;\n\n     vec3 q = p - vec3(iTime / 10.,0.1,1.0) * 10.;\n     q.x /= 1.;\n     q.y *= 2.;\n     float g = 0.5+0.5*noise3( q*0.3 );\n\n\tfloat f;\n    f  = 0.50000*noise3( q ); q = q*2.02;\n    f += 0.25000*noise3( q ); q = q*2.23;\n    f += 0.12500*noise3( q ); q = q*2.41;\n    f += 0.06250*noise3( q ); q = q*2.62;\n    f += 0.03125*noise3( q ); \n    \n    f = mix( f*0.1-0.5, f, g*g );\n    f /= (uv.y);\n    f *= 2.;\n    if (uv.y < 0. || f < -5.) f = FAR;\n \n    if (useBoth) return min(f, t);\n    return isVolumetric ? f : t;\n}\n\nbool hit = false;\nbool lightHit = false;\nfloat hitDistance = FAR;\n\nfloat RayMarch(vec3 ro, vec3 rd, bool isLight)\n{\n    if (!isLight) hit = false;\n    else lightHit = false;\n    float ad = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        vec3 p = ro + rd * ad;\n        float d = Scene(p, isLight, false, false);\n        ad += d;\n        if (d < NEAR && !isLight) hit = true;\n        if (d < NEAR && isLight) lightHit = true;\n        if (ad > FAR || d < NEAR) break;\n    }\n    if (hit) hitDistance = ad;\n    return ad;\n}\n\nvec3 GetNormal(vec3 p)\n{ \n    float d = Scene(p, true, false, false);\n    vec2 e = vec2(NEAR / 2., 0);\n    vec3 n = d - vec3(\n        Scene(p - e.xyy, true, false, false),\n        Scene(p - e.yxy, true, false, false),\n        Scene(p - e.yyx, true, false, false)\n    );\n    return normalize(n);\n}\n\nvec3 GetSkyColor(DirectionalLight l, vec3 rd)\n{\n    vec3 color = (l.position.y / length(l.position.xz) + .5) * (rd.y * 2. + .3) * vec3(0.37, 0.55, 1.0); // sky\n    if (l.position.y / length(l.position.xz) > -.1 && l.position.y / length(l.position.xz) < 1.)\n        color.x += (-uv.y - l.position.y / length(l.position.xz));\n    return color;\n}\n\nvec3 GetLight(vec3 p, vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(.05);\n    DirectionalLight l = light;\n    vec3 ld = normalize(l.position - p); \n    vec3 n = GetNormal(p);\n    float dif = dot(n, ld);\n    dif = clamp(dif, 0., 1.) * l.intensity;\n        \n    float d = RayMarch(p + n * NEAR * 2., ld, true); // shadow\n    if (d < length(l.position - p)) dif *= .1;\n        \n    vec3 np = normalize(p);\n    vec3 nl = normalize(l.position);\n    float dpl = .01 / length(nl - np);\n    if (!hit || length(l.position - ro) < length(p - ro)) color += dpl * l.color;\n    else color += .04;\n    \n    vec3 waterCol = (vec3(22.,79.,86.)/255.) + dif * (vec3(0.,214.,10.)/255.) * 0.12; \n\n    if (hit)\n    {\n        float distanceFromCamera = length(ro - p);\n        color -= distanceFromCamera / FAR;\n        color.z += (distanceFromCamera / 8.) / FAR;\n        color.x += .5*((distanceFromCamera / 8.) / FAR);\n        \n        float le = length(p.xz);\n        float sur = -1.;\n        vec2 tuv = vec2(atan(p.z,p.x), ((sur<0.0)?(le+p.y)*0.4:atan(p.y,le)));\n        \n        color = mix(color, texture(iChannel0, tuv * 1.).xyz, n.y + (p.y / 8.));\n            color += clamp(l.position.y / length(l.position.xz), -1., 0.);\n        \n        color = mix(color, l.color, dif);\n    }\n\n    vec3 nld = normalize(l.position - normalize(p));\n    if (!hit)\n    {\n        // color += (l.position.y / length(l.position.xz) + .5) * (rd.y + .5) * vec3(0.37, 0.55, 1.0); // sky\n        color += (l.position.y / length(l.position.xz) + .5) * (rd.y * 2. + .3) * vec3(0.37, 0.55, 1.0); // sky\n        if (l.position.y / length(l.position.xz) > -.1 && l.position.y / length(l.position.xz) < 1.)\n            color.x += (-uv.y - l.position.y / length(l.position.xz));\n    }\n    if (!hit)\n    {\n        float total_density = 0.;\n        float maxDistance = 15.;\n        int steps = 64;\n        float density_step_val = .05;\n        float step_size_f = maxDistance / float(steps);\n        vec3 step_size = rd * step_size_f;\n        vec3 dp = ro;\n        if (uv.y > 0.)\n        {\n            for (int s = 0; s < steps; s++)\n            {\n                vec3 srp = dp;\n                float slrd = 0.;\n                for (int sr = 0; sr < 10; sr++)\n                {\n                    float dst = Scene(srp, true, true, false);\n                    srp += rd * dst;\n                    slrd += dst;\n\n                    if (dst < NEAR)\n                    {\n                        total_density += density_step_val * step_size_f;\n                        break;\n                    }\n                    else if (slrd > maxDistance) break;\n                }\n                dp += step_size;\n                if (total_density > .99) break;\n            }\n\n            if (total_density > .6)\n                color += (l.position.y / length(l.position.xz) + 1.) - clamp(total_density, 0., 1.);\n        }\n            \n        total_density = 0.;\n        dp = ro;\n        for (int s = 0; s < steps; s++)\n        {\n            vec3 srp = dp;\n            float slrd = 0.;\n            for (int sr = 0; sr < 10; sr++)\n            {\n                float dst = Scene(srp, true, true, true);\n                srp += nld * dst;\n                // srp += rd * dst;\n                slrd += dst;\n                \n                if (dst < NEAR)\n                {\n                    total_density += density_step_val * step_size_f;\n                    break;\n                }\n                else if (slrd > maxDistance) break;\n            }\n            dp += step_size;\n        }\n        color *= exp(-total_density);\n    }\n    \n    return color + (l.position.y / length(l.position)) / 3.;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    fragCoords = fragCoord;\n    vec3 color = vec3(0);\n    uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    vec2 mo = vec2(iMouse.xy / iResolution.xy - .5);\n    if (iMouse.z < 1.) mo = vec2(.25, 0);\n    mo.x *= (iResolution.x / iResolution.y);\n    light.position += vec3(mo * abs(light.position.z), 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1));\n    \n    float d = RayMarch(ro, rd, false);\n    vec3 p = ro + rd * d;\n    color = GetLight(p, ro, rd);\n    \n    float starsCol = -clamp(stars(uv), 0., 1.);\n    if (!hit)\n    {\n        float w = light.position.y / length(light.position.xz);\n        if (w < 0.) color = mix(color, vec3(starsCol), w);\n    }\n    fragColor = vec4(color + .25*camera_noise(uv * 50. + 100.*iTime), 1);\n}", "image_inputs": [{"id": 45, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float hash(float h) {\n\treturn fract(sin(h) * 43758.5453123);\n}\n\n//noise by iq\n\nvec2 grad( ivec2 z )\n{\n    int n = z.x+z.y*11111;\n    n = (n<<13)^n;\n    n = (n*(n*n*15731+789221)+1376312589)>>16;\n#if 0\n    return vec2(cos(float(n)),sin(float(n))); \n#else\n    n &= 7;\n    vec2 gr = vec2(n&1,n>>1)*2.0-1.0;\n    return ( n>=6 ) ? vec2(0.0,gr.x) : \n           ( n>=4 ) ? vec2(gr.x,0.0) :\n                              gr;\n#endif                              \n}\n\nfloat noise( in vec2 p )\n{\n    ivec2 i = ivec2(floor( p ));\n     vec2 f =       fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( dot( grad( i+ivec2(0,0) ), f-vec2(0.0,0.0) ), \n                     dot( grad( i+ivec2(1,0) ), f-vec2(1.0,0.0) ), u.x),\n                mix( dot( grad( i+ivec2(0,1) ), f-vec2(0.0,1.0) ), \n                     dot( grad( i+ivec2(1,1) ), f-vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat rnoise( in vec2 uv, int iter )\n{\n    float f = 0., div = 1.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    for (int i = 0; i < iter; i++)\n    {\n        div /= 2.;\n        f  += div*noise( uv ); uv = m*uv;\n    }\n    f = 0.5 + 0.5*f;\n\n    return f;\n}\n\nfloat camera_noise( in vec2 uv )\n{\n    float f = 0., div = 1. / 8.;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    uv *= 32.;\n    f = div*noise( uv ); uv = m*uv;\n    f = 0.5 + 0.5*f;\n\t\n    f *= smoothstep( 0.0, 0.005, abs(uv.x-0.6) );\n    return f;\n}\n\nfloat stars( in vec2 uv )\n{\n    float f = noise(uv * 100.);\n    return f*f*f*f*f;\n}\n\nfloat noise3(vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\n\tfloat n = p.x + p.y * 157.0 + 113.0 * p.z;\n\treturn mix(\n\t\t\tmix(mix(hash(n + 0.0), hash(n + 1.0), f.x),\n\t\t\t\t\tmix(hash(n + 157.0), hash(n + 158.0), f.x), f.y),\n\t\t\tmix(mix(hash(n + 113.0), hash(n + 114.0), f.x),\n\t\t\t\t\tmix(hash(n + 270.0), hash(n + 271.0), f.x), f.y), f.z);\n}\n\nfloat fbm(vec3 p) {\n\tfloat f = 0.0;\n\tf = 0.5000 * noise3(p);\n\tp *= 2.01;\n\tf += 0.2500 * noise3(p);\n\tp *= 2.02;\n\tf += 0.1250 * noise3(p);\n\n\treturn f;\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xfy3Dh.jpg", "time_retrieved": "2024-04-28T18:58:55.476196", "access": "api", "wgpu-test": "ok"}
{"id": "XfVGRh", "name": "Speed freak", "author": "Alie", "description": "From Monday Night Bytes shader jam", "tags": ["raytracing", "motionblur", "quadtree"], "image_code": "const float maxScale = 512.;\nconst int steps = 4;\nconst float samples = 32.;\n#define r2d(p,a) p=cos(a)*p+sin(a)*vec2(-p.y,p.x);\n\nvec3 hash(vec3 p){\n\tp=fract(p*vec3(443.897,441.423,437.195));\n\tp+=dot(p,p.yxz+19.19);\n\treturn fract((p.xxy+p.yxx)*p.zyx);\n}\n\nfloat pDist(vec3 p, vec3 d, vec4 plane) {\n    return dot(plane.xyz * plane.w - p, plane.xyz) / dot(d, plane.xyz);\n}\n\n\t/// Sphere intersection\nvec4 intersectSphere(vec3 p, vec3 d, vec4 sphere){\n\tp -= sphere.xyz;\n\tfloat t = dot(d, p) * 2.,\n\ta = dot(p, p) - sphere.w * sphere.w;\n\ta = t * t - 4. * a;\n\tif (a < 0.) return vec4(1000);\n\ta = (-sqrt(a) - t)  / 2.;\n    return vec4((d * a + p) / sphere.w, a);\n}\n\n\t/// Cube intersection\nvec4 intersectCube(vec3 rp, vec3 rd, vec3 ba, vec3 bb){\n\tvec3 a = (ba-rp) / rd, // near\n\tb = (bb-rp) / rd, // far\n\tf = max(a, b); // furthest\n\tfloat x = min(f.x, min(f.y, f.z)); // nearest in front\n    \n\treturn vec4(\n        normalize(\n            step(0.001,abs(a - x)) - step(0.001,abs(b - x))\n        ) * sign(x),\n        x);\n}\n\nvec3 sCol(vec3 d) {\n    return vec3(d.y * .5 + .5) * vec3(.7, .7, 1.) \n     + pow(max(0., dot(d, normalize(vec3(1,0,-1)))), 20.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    \n    for (int j=0;j<int(samples);j++) {\n        vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.xx;\n        vec3 k = hash(vec3(uv+float(j), fract(iTime)));\n        float t = iTime + k.z * (1./60.) * 3.;\n        if (iMouse.z > 0.) t = 0.;\n        r2d(uv, -.25 + sin(t / 5.) / 4.);\n        //t=iTime;\n        \n        uv = uv*1.5 + (k.xy - .5) * 16. / iResolution.x;\n        vec3 p = vec3(sin(t / 3.) * 10000., cos(t/3.) * 10000., sin(t / 2.) * 250. - 300.),      \n        d = normalize(vec3(uv, 1));\n        \n        r2d(d.yz, cos(t / 2.) / 4. - 1.);\n        r2d(d.xy, -t / 3. - 1.4 + sin(t / 5.) / 2.);\n\n        float dist = pDist(p, d, vec4(0,0,-1,0));\n        if (dist < 0.) {\n            col += sCol(d);\n            continue;\n            \n        } else {\n\n            p += d * dist;\n\n            float scale = maxScale;\n\n            for (int i=0; i<steps; i++) {\n                scale /= 2.;\n                k = hash(vec3(floor(p.xy / scale), .1));\n                if (fract(k.x) > .75) {\n                    break;\n                }\n            }\n            //col += k; continue;\n            \n            vec3 pos = p / float(scale);\n            \n            vec3 iCol = vec3(1), aCol = k * k * .5 + .5, bCol;\n            //k = hash(k);\n            bCol = (1. - k) * .5 + .5;\n            if (k.y>.7) aCol *= 2.;\n                \n            for(int b=0;  b<3; b++) {\n                vec4 sphere = vec4(\n                    floor(pos.x) + k.y, \n                    floor(pos.y) + k.z, \n                    k.x, k.x) * float(scale);\n                vec4 sDist = intersectSphere(p, d, sphere);\n\n                vec3 ba = vec3(floor(pos.xy),0.) * float(scale), bb = vec3(ceil(pos.xy),1) * float(scale);\n                vec4 bDist = intersectCube(p, d, ba, bb);\n\n                bDist = sDist.w < bDist.w ? sDist : bDist;\n    \n                iCol *= bDist.w==sDist.w ? aCol : bCol;\n                if (bDist.w < 0.) continue;\n                p += d * bDist.w;\n                p += bDist.xyz * 0.001;\n                d = reflect(d, bDist.xyz);\n            }\n            iCol *= sCol(d);\n            col += iCol;\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col / samples, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfVGRh.jpg", "time_retrieved": "2024-04-28T18:59:14.064462", "access": "api", "wgpu-test": "ok"}
{"id": "McKGWR", "name": "HexShadows", "author": "rcargou", "description": "HexShadows by rcargou\nHeavily inspired by shane's amazing work : https://www.shadertoy.com/view/MsVfz1\nThere is a loot of idea I wanted to add to this shaders, \nbut I want to keep it about real time, so I am stopping there", "tags": ["sdf", "texture", "lighting", "hexagons"], "image_code": "// HexShadows by rcargou\n// Heavily inspired by shane's amazing work : https://www.shadertoy.com/view/MsVfz1\n// There is a loot of idea I wanted to add to this shaders, \n// but I want to keep it about real time, so I am stopping there\nconst vec2 s = vec2(.866025, 1);\n#define ZERO (min(iFrame,0))\n\n\nfloat sdHexagon(vec2 p, float h, vec3 b, float id) {\n    //h +=  texture(iChannel2, p.xy / 12.).r / 5. * id;\n    p = abs(p);\n    p = vec2(p.x*.866025 + p.y*.5, p.y);\n    float d1 = length(max(abs( vec3( p.x, h, p.y )) - b + .015, 0.)) - .0025;\n    b.xz/=1.5;\n    h -=.01;\n    \n    //b.y += sin(4. * iTime + id * 12.) * id / 3.;\n    float d2 = length(max(abs( vec3( p.x, h, p.y )) - b + .015, 0.)) - .0025;\n    b.xz/=1.5;\n    h -=.01;\n   // b.y += 1.;\n   \n    float d3 = length(max(abs( vec3( p.x, h, p.y )) - b + .015, 0.)) - .0025;\n    //return d1;\n    d1 =  min(d1, d2);\n    return d1;\n    return min(d1, d3);\n}\n\nfloat sdHexagonS(vec2 p, float h, vec3 b, float id) {\n    //h +=  texture(iChannel2, p.xy / 12.).r / 5. * id;\n    p = abs(p);\n    p = vec2(p.x*.866025 + p.y*.5, p.y);\n    float d1 = length(max(abs( vec3( p.x, h, p.y )) - b + .015, 0.)) - .0025;\n    b.xz/=1.5;\n    h -=.1;\n    return d1;\n}\n\n\nvec4 getCellData(vec2 cellID, float y,  float fall) {\n    float h;\n    \n    h = noise3D( vec3(cellID.xy + vec2(iTime / 2., 0.), 0.*(iTime / 1.)) ) * .8;\n    float k = 0.;\n    if (length(cellID/12.) > .3) {\n     ;//   k = 1e10;\n    }\n\n    return vec4(-(h*h), hash21(cellID), cellID.x, k);\n}\n\nvec4 mapC(vec3 p) {\n\n    float s = .1;\n    float r = 1.5;\n    float sdr = .2;\n    vec3 b = vec3(sdr, .1, sdr);\n    vec4 ret;\n//    ret.y = p.z/12.;\n    p.y -= 1.;\n    p.xz *= rotate2d(-.7);\n    float id = floor(p.x / r);\n  \n    p.x = mod(p.x, r) - r/2.;\n    float r2 = 1.;\n      vec3 p2 = p;\n    p2.z += id / 5.;\n    p2.z = mod(p2.z, r2) - r2 / 2.;\n   \n    float d2 = sdHexagonS(p2.xy, p2.z, b, 0.);\n    p.xy += sin(p.z * 150.) / 301.;\n    ret.x =  min(d2, length(p.xy) - s);\n    ret.w = 1.;\n    if (d2 < length(p.xy) - s) {\n        ret.w = 3.;\n    }\n    //ret.x = min(ret.x, sdHexagonS(p.xz, p.y, b + vec3(-.1, 5., -.1), 0. ));\n    return ret;\n}\n\nvec4 mapHexagons(vec3 p, float fall) {\n   // p.z=iTime;\n    float r = .25;\n    vec3 b = vec3(r, .5, r);\n    p.xz*=2.;\n    //p.y -= 2.5;\n    vec4 hC = floor(vec4(p.xz, p.xz - vec2(0, .5))/s.xyxy) + vec4(0, 0, 0, .5);\n    vec4 hC2 = floor(vec4(p.xz - vec2(.5, .25), p.xz - vec2(.5, .75))/s.xyxy) + vec4(.5, .25, .5, .75);\n\n    // Centering the coordinates with the hexagon centers above.\n    vec4 h = vec4(p.xz - (hC.xy + .5)*s, p.xz - (hC.zw + .5)*s);\n    vec4 h2 = vec4(p.xz - (hC2.xy + .5)*s, p.xz - (hC2.zw + .5)*s);\n    vec4 cellData1 = getCellData(hC.xy, p.y, fall);\n    vec4 cellData2 = getCellData(hC.zw, p.y, fall);\n    vec4 cellData3 = getCellData(hC2.xy, p.y, fall);\n    vec4 cellData4 = getCellData(hC2.zw, p.y, fall);\n    \n    vec4 dist = vec4(cellData1.w+sdHexagon(h.xy, p.y + cellData1.x, b, hash21(hC.xy) ), cellData2.w+sdHexagon(h.zw, p.y + cellData2.x, b, hash21(hC.zw) ),\n    cellData3.w+sdHexagon(h2.xy, p.y + cellData3.x, b, hash21(hC2.xy) ),cellData4.w+sdHexagon(h2.zw, p.y + cellData4.x, b, hash21(hC2.zw) ));\n\n    //vec4 dd = vec4(cellData1.w,cellData2.w,cellData3.w,cellData4.w);\n    //dist = max(dd, dist);\n    h = dist.x<dist.y ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw);\n    h2 = dist.z<dist.w ? vec4(h2.xy, hC2.xy) : vec4(h2.zw, hC2.zw);\n\n    vec2 oH = dist.x<dist.y ? vec2(dist.x, 0.) : vec2(dist.y, 0.);\n    vec2 oH2 = dist.z<dist.w ? vec2(dist.z, 0.) : vec2(dist.w, 0.);\n    vec3 dataRet;\n    vec4 DistdataRet;\n    \n    DistdataRet = dist.x<dist.y ? vec4(dist.x, cellData1.yzw) : vec4(dist.y, cellData2.yzw);\n    DistdataRet = dist.z<DistdataRet.x ? vec4(dist.z, cellData3.yzw) : DistdataRet;\n    DistdataRet = dist.w < DistdataRet.x ? vec4(dist.w, cellData4.yzw) : DistdataRet;\n    dataRet = DistdataRet.yzw;\n    //return oH<oH2 ? vec4(h.xy, hC.xy) : vec4(h2.xy, hC2.xy);\n    //return oH.x<oH2.x ? vec4(oH,  h.zw) : vec4(oH2, h2.zw);\n\n    vec4 ret =  vec4(min ( min(dist.x, dist.z), min(dist.w, dist.y)) );\n    ret.yzw = dataRet;\n    return ret;\n}\n\nvec4 mapL(vec3 p) {\n//\n   // p.xz *= rotate2d(p.z / 29.);\n    float r = 3.;\n    \n    p.z+=cos(p.x / 12.) * +12.;\n    \n    p.x=abs(p.x);\n    p.x+= iTime * -6.;\n  //  p.x = mod(p.x, r) -r/2.;\n    return mapHexagons(p.xzy, 0.);\n}\nvec4 map( in vec3 pos )\n{\n    pos.xy*=rotate2d(pos.z / 12.);\n    vec4 res = vec4(1e10, 0.0, 0., 0. );\n    vec3 pf = pos;\n    //pf.y = -abs(pf.y);\n    vec4 r2 = mapHexagons(pf + vec3(.0, +2., .0), 0.);\n    if (r2.x < res.x) {\n        res = r2;\n    }\n    \n    float hole= length( pos - vec3( .4, 0., 5. )) - 2.5;\n    vec3 pw = pos;\n    pw.z = -pw.z;\n    pw.yz *=rotate2d(.5);\n    vec4 r3 = mapHexagons(pw.xzy - vec3(0., -2, .0), 0.);\n    //r3.x = min(r3.x, hole);\n    //r3.x = max(r3.x, - mapC(pos / 2.).x);\n    if (r3.x < res.x) {\n       res = r3;\n    }\n    vec3 ps = pos;\n    ps.x = -abs(ps.x);\n     ps.xy *= rotate2d(-.9);\n    vec4 r4 = mapHexagons(ps.zxy - vec3(0., -3., .0), 0.);\n    if (r4.x < res.x) {\n        res = r4;\n    } \n    /*\n    vec4 r4 = mapL(pos + vec3(0., 0., -42. + -iTime * 4.));\n    \n    if (r4.x < res.x)\n           res = r4;\n           */\n    vec4 r5 = mapC(pos);\n    if (r5.x < res.x)\n        res = r5;\n    vec4 r6 = mapC(pos + vec3(0.5, -1., 0.));\n    if (r6.x < res.x)\n        res = r6;\n        \n    return res;\n}\n\nconst float maxHei = 0.8;\n\nvec4 castRay( in vec3 ro, in vec3 rd )\n{\n    vec4 res = vec4(-1.0,-1.0, 0., 0.);\n    vec4 outlineres = vec4(-1.0,-1.0, 0., 0.);\n    float tmin = 0.0;\n    float tmax = 50.0;\n\n    // raymarch primitives   \n    {\n    \n        float t = tmin;\n        for( int i=0; i<100 && t<tmax; i++ )\n        {\n            vec4 h = map( ro+rd*t );\n            if( abs(h.x)<(0.0001*t) )\n            { \n                 res = vec4(t,h.yzw); \n                 break;\n            }\n            t += h.x;\n        }\n    }\n\n  \n    return res;\n}\n\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max((abs(n) - .2)*7., .001); // n = max(abs(n), .001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\tvec3 tx = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    return tx*tx;\n}\nvec3 texBump( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3(tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(.299, .587, .114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(.299, .587, .114)))/e.x; \n    \n    // Adjusting the tangent vector so that it's perpendicular to the normal -- Thanks to\n    // EvilRyu for reminding me why we perform this step. It's been a while, but I vaguely\n    // recall that it's some kind of orthogonal space fix using the Gram-Schmidt process. \n    // However, all you need to know is that it works. :)\n    g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// https://iquilezles.org/articles/rmshadows\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (maxHei-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n    \n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<16; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\nvec3 bumpMap(vec3 n, vec3 tex) {\n       return normalize( n );\n}\n\nfloat calcOutline(vec3 pos, vec3 nor) {\n    vec4 cellData = map(pos);\n    if ( mod( cellData.z, 2.) == 0.)\n        return 0.;\n    return 1.;\n}\nvec3 render( in vec3 ro, in vec3 rd )\n{ \n    vec3 col = vec3(.0f);\n    vec4 res = castRay(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    vec3 p = ro + rd * res.x;\n    \n\n    vec3 n = calcNormal(p);\n    vec3 tex = tex3D(iChannel0, p * 2.,n).xyz;\n    n = texBump(iChannel0, p * 2., n , .05);\n\n//    n = n + normalize( ( tex3D(iChannel0, p * 1112., n) - .5) * 1.);\n    //vec4 ref = castRay(p, reflect(normalize(p-ro) , n) );\n    vec3 distCol = pal( res.x / 12., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    vec3 idcol = pal( res.y /4. + 62.3 / 4., vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    vec3 posxcol = pal( (p.x /10. + iTime / 2.), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    vec3 posycol = pal( (p.y /10. + iTime / 2.), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    \n    float lt = iTime / 2.;\n    \n    vec3 lightPos = fhash13(floor( lt  )) *vec3(3.,3., 1.5);\n    vec3 plightPos = fhash13(floor( lt  - 1.)) *vec3(3.,3., 1.5);\n    lightPos = mix(plightPos, lightPos, fract(lt) );\n    vec3 lightCol = 2.*pal( hash11(floor(lt)), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    vec3 plightCol = 2.*pal( hash11(floor(lt - 1.)), vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    lightCol = mix(plightCol, lightCol, fract(lt) );\n    float spec = max(0., dot(normalize(p-lightPos), reflect(normalize(ro - p), n )));\n    spec = pow(spec, 5.);\n    //lightPos = vec3( .4, 0., 2. );\n    vec3 albedo = posxcol*posycol + idcol + distCol;//distCol  + idcol + posxcol * posycol;\n    if (res.w == 3.) {\n        albedo += 1.8*vec3(.7, .3, .1);\n    }\n    float s = calcSoftshadow(p, normalize(lightPos - p), 0.01, 20. );\n    float ao = calcAO(p, n);\n    float ndotl = max(0.1, dot(n, normalize(lightPos - p)) );\n    albedo = albedo * tex;\n    if (res.x > .0f) {\n     \tcol =  albedo* ao * 0.01 + s*albedo*spec+ idcol.xxx*albedo * (ndotl) * lightCol * s;// *(.2 +  calcAO(p,n));\n    }else {\n       vec3 c = texture(iChannel1, rd.xy /1.+ vec2(iTime / -9., 0.)).xyz;\n       col = pow(c.rrr, vec3( 3. ) );\n    }\n    \n   \treturn vec3(col);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = vec2(0);//iMouse.xy/iResolution.xy;\n\tfloat time = .0f; //iTime;\n\n    // camera\t\n    vec3 ro = vec3(.0f, .0f, -4.0f);//vec3( 4.6*cos(0.1*time + 6.0*mo.x), 1.0 + 2.0*mo.y, 0.5 + 4.6*sin(0.1*time + 6.0*mo.x) );\n    vec3 ta = vec3( 0.0, -0.4, 0.0 );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n   \n    vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n\n    // ray direction\n    vec3 rd = ca * normalize( vec3(p.xy,2.) );\n\n    // render\t\n    vec3 col = render( ro, rd );\n\n    // gamma\n    col = pow( col, vec3(0.4545) );\n\n    tot += col;\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "mat2 rotate2d(float _angle){\n    return mat2(cos(_angle),-sin(_angle),\n                sin(_angle),cos(_angle));\n}\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 hash13(float p) {\n    float d = dot(        vec3( p*231.4213,\n        p*76.123,\n        p*998.872 )\n, vec3(12.23, 321.2, 321.98));\n\n\nreturn fract(sin(vec3(\n            d/3.312,\n            d/7.321,\n            d/9.321\n        )\n    ) );\n}\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(113, 157, 1);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(3. - 2.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    float n = mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n    return n;//abs(n - .5)*2.;\n}\n\nvec3 hash23(vec2 p) {\n    return fract(sin(vec3(p.x * 123.2, p.y * 1323.31, p.x*p.y * 211.99)) );\n}\n\nfloat hash21(vec2 p){\n   \n    float n = dot(p, vec2(7.163, 157.247)); \n    return fract(sin(n)*43758.5453);\n}\n\nfloat hash11(float p) {\n    return hash21(vec2(p));\n}\n\nvec3 fhash13(float p) {\n    return hash23(vec2(p));\n}\n\nfloat sdPlane( vec3 p )\n{\n\treturn p.y;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n    \n}\n\nfloat sdRoundBox( in vec3 p, in vec3 b, in float r ) \n{\n    vec3 q = abs(p) - b;\n    return min(max(q.x,max(q.y,q.z)),0.0) + length(max(q,0.0)) - r;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat dot2(in vec3 v ) {return dot(v,v);}\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdEquilateralTriangle(  in vec2 p )\n{\n    const float k = 1.73205;//sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x + k*p.y > 0.0 ) p = vec2( p.x - k*p.y, -k*p.x - p.y )/2.0;\n    p.x += 2.0 - 2.0*clamp( (p.x+2.0)/2.0, 0.0, 1.0 );\n    return -length(p)*sign(p.y);\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n    float d1 = q.z-h.y;\n    h.x *= 0.866025;\n    float d2 = sdEquilateralTriangle(p.xy/h.x)*h.x;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\nfloat sdCone( in vec3 p, in vec3 c )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    float d1 = -q.y-c.z;\n    float d2 = max( dot(q,c.xy), q.y);\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\n#if 0\n// bound, not exact\nfloat sdOctahedron(vec3 p, float s ) \n{\n    p = abs(p);\n    return (p.x + p.y + p.z - s)*0.57735027;\n}\n#else\n// exacy distance\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    \n    float m = p.x + p.y + p.z - s;\n    \n\tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    \n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n#endif\n\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length6( vec2 p )\n{\n\tp = p*p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/6.0 );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 1.0/8.0 );\n}\n\nfloat sdTorus82( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length2(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdTorus88( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length8(p.xz)-t.x,p.y);\n    return length8(q)-t.y;\n}\n\nfloat sdCylinder6( vec3 p, vec2 h )\n{\n    return max( length6(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n//------------------------------------------------------------------\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d2,d1);\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec3 opRep( vec3 p, vec3 c )\n{\n    return mod(p,c)-0.5*c;\n}\n\nvec3 opTwist( vec3 p )\n{\n    float  c = cos(10.0*p.y+10.0);\n    float  s = sin(10.0*p.y+10.0);\n    mat2   m = mat2(c,-s,s,c);\n    return vec3(m*p.xz,p.y);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McKGWR.jpg", "time_retrieved": "2024-04-28T18:59:16.008260", "access": "api", "wgpu-test": "error"}
{"id": "XcGGWh", "name": "psy02lines", "author": "maxiie", "description": "trippy", "tags": ["trippy"], "image_code": "\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(1.0, 0.0));\n    float c = random(i + vec2(0.0, 1.0));\n    float d = random(i + vec2(1.0, 1.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(3.0-2.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (1.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\n\nfloat trwv(float fl)\n{\n    return abs(fl-floor(fl+0.5));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ti=sin(iTime/10.)*0.1+0.;\n    float ti2=sin(iTime/3.)*0.25+0.1;\n    float ti3=sin(iTime/1.)*0.28+0.25;\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\n    // Time varying pixel color\n    vec3 col = vec3(sin(pow(abs(uv.x),1.5)*ti),sin(pow(abs(uv.y),2.3)*ti2),sin(pow(length(uv*ti3+vec2(2.,1.)),8.1)));\n\n    vec3 col2 = vec3(sin(uv.x*2.*ti2),sin(uv.y*2.*ti),sin(length(uv*2.*ti3)))+vec3(0.3,0.4,0.5);\n    vec3 col3 = vec3(sin(uv.x*3.*ti3)*pow(iTime,0.71),sin(uv.y*3.*ti2)*pow(iTime,0.72),pow(iTime,0.73)*sin(length(uv*3.*ti)))+vec3(-0.2,-0.4,-0.8);\n      vec3 col4 = vec3(sin(uv.y*5.*ti)*pow(iTime,0.7),sin(uv.x*5.*ti),pow(iTime,1.27)*sin(length(uv*5.*ti2)))+vec3(0.25,0.45,0.85);\n      vec3 col5 = vec3(sin(length(uv*7.*ti))*iTime,sin(length(uv*7.*ti3))*pow(iTime,1.2),pow(iTime,1.45)*sin(length(uv*7.*ti)))+vec3(0.75,0.75,0.75);\n      vec3 col6 = vec3(sin(length(uv*7.5*ti))*pow(iTime,0.5),sin(length(uv*7.5*ti3))*pow(iTime,1.5),pow(iTime,1.53)*sin(length(uv*7.5*ti)))+vec3(1.75,2.75,3.75);\n      vec3 col7 = vec3(sin(uv.y*2.1*ti2),sin(uv.x*2.1*ti),sin(uv.x*2.1*ti))+vec3(0.3,0.4,0.5);\n       vec3 col8=vec3(noise(uv*ti),noise(uv*ti2),noise(uv*ti3));\n      \n     vec3 res=col+col2+col3+col4+col5+col6+col7+col8;\n     res=vec3(trwv(res.x),trwv(res.y),trwv(res.z));\n    // Output to screen\n    fragColor = vec4(res,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcGGWh.jpg", "time_retrieved": "2024-04-28T18:59:16.358324", "access": "api", "wgpu-test": "ok"}
{"id": "lfy3Dz", "name": "psy01lines", "author": "maxiie", "description": "Â´", "tags": ["trippy"], "image_code": "\n\n\nfloat trwv(float fl)\n{\n    return abs(fl-floor(fl+0.5));\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(sin(uv.x*iTime),sin(uv.y*iTime),sin(length(uv*iTime)));\n\n    vec3 col2 = vec3(sin(uv.x*2.*iTime),sin(uv.y*2.*iTime),sin(length(uv*2.*iTime)))+vec3(0.3,0.4,0.5);\n    vec3 col3 = vec3(sin(uv.x*3.*iTime),sin(uv.y*3.*iTime),sin(length(uv*3.*iTime)))+vec3(-0.2,-0.4,-0.8);\n  \n     vec3 res=vec3(trwv(col.x+col2.x),trwv(col.y+col2.y),trwv(col.z+col2.z));\n     res=vec3(trwv(res.x+col3.x),trwv(res.y+col3.y),trwv(res.z+col3.z));\n    // Output to screen\n    fragColor = vec4(res,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lfy3Dz.jpg", "time_retrieved": "2024-04-28T18:59:16.721352", "access": "api", "wgpu-test": "ok"}
{"id": "McV3Wz", "name": "simple gaussian pyramid blur", "author": "oatmealine", "description": "severely underbaked blur w/ gaussian pyramid downscaling method. absolutely could look better but i can't bother to figure that out", "tags": ["2d", "blur", "gaussianpyramid"], "image_code": "#define PI 3.14159265\n\nfloat gaussian( float _x, float _v ) {\n  return 1.0 / sqrt( 2.0 * PI * _v ) * exp( - _x * _x / 2.0 / _v );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    float m = 50.0;\n    //col += texture(iChannel0, uv * 0.5).rgb * gaussian(0.0, m);\n    col += texture(iChannel0, uv * 0.25 + 0.5).rgb * gaussian(1.0, m);\n    col += texture(iChannel0, uv * 0.125 + 0.75).rgb * gaussian(0.0, m);\n    col += texture(iChannel0, uv * 0.0625 + 0.875).rgb * gaussian(1.0, m);\n    col += texture(iChannel0, uv * 0.03125 + 0.9375).rgb * gaussian(2.0, m);\n    col += texture(iChannel0, uv * 0.015625 + 0.96875).rgb * gaussian(3.0, m);\n    col *= 4.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec2 l = vec2(\n      log(2.0 - uv.x * 2.0),\n      log(2.0 - uv.x * 2.0)\n    );\n    vec2 p = floor(1. - l / log(2.));\n    vec2 atlas = fract(uv * vec2(pow(2., p.x), pow(2., p.y))) * 2.0;\n\n    vec3 col = texture(iChannel0, atlas).rgb;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McV3Wz.jpg", "time_retrieved": "2024-04-28T18:59:16.778200", "access": "api", "wgpu-test": "incomplete"}
{"id": "fslfWj", "name": "morph ball lights", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "image_code": "// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-2.25;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-2.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*306./vec2(80000.,80000.), iResolution.y>7200. ? 60. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.005;\n    \n    // 'tone mapping'\n    col = smoothstep(0.1,1.,col);\n    col = pow(col,vec3(.65));\n    \n    // fade in / fade out\n    col *= sat(time*5.) * sat(231.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 8.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t,vec3(20,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.8,5, 59)\n\t\t\t\t\t\t,vec3(21,5, 49)\n\t\t\t\t\t\t,vec3(5,8, 22.885)\n\t\t\t\t\t\t,vec3(31,5, 76)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(2.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-90,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.8)\n\t\t\t\t\t\t);\n\n\tint section = int(time/10.);\n\tfloat rest = mod(time,10.);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*130. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 200.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*84.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.7)*2.,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.1));\n\tbs.xz*= rot(avance*.1);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 0.1 + mval.y;\n\tfloat dofamount=.01;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<0;\n\tbool lightsilver = section>1 && section<2;\n\tbool lightgreen = section>1;\n\tbool lightpink = section>10&& section<8;\n\tbool centerlight = section>0;\n\tbool strips = (section>10);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,2.5);\n     // motion slowing down during the last section\n\tfloat t2=section!=2?time:pow(sat(rest*1.6),.5)*1.5;\n\tif(section==10) {time=1.4; rest=0.2;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*.5 + (fract(mval.z+.4)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>10 && section<13) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>1 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.9);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 10. : 20.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.1; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-13.6-i*1084.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<3; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,1,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+.3)*7.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.1+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 5.-k*rrad;\n\t\t\t\trad2 = 5.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][1];\n                \n\t\t\t\tfloat d2=10000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.4,1);\n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.25+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*5.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .1;\n\t\t\t\t\tcol += alpha * smoothstep(0.4,0.1,fract(time*.5+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.1+floor(r.z*sqsize)*0.02))) * 2. * (rnd33(floor(r*sqsize)+floor(time)*.37)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.2*3.)*10.)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 4. * vec3(1,.2,.3);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*6., localpos.y, length(localpos.xz)*.6);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*20.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*27.33);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<6.5)?.1:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.01;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .7;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375)+fract(time))-.5)*rough);      \n\t\t}\n\t}\n\tcol *= 0.7/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/fslfWj.jpg", "time_retrieved": "2024-04-28T18:59:17.075405", "access": "api", "wgpu-test": "incomplete"}
{"id": "ssffW2", "name": "Fork Sharp bloo firebreath 927", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "image_code": "// Fork of \"Fork Fork Sharp firebreath 969\" by firebreathz. https://shadertoy.com/view/7dBSDt\n// 2021-06-16 10:16:58\n\n// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-2.25;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-20.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*306./vec2(80000.,80000.), iResolution.y>7200. ? 60. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.005;\n    \n    // 'tone mapping'\n    col = smoothstep(0.1,1.,col);\n    col = pow(col,vec3(.65));\n    \n    // fade in / fade out\n    col *= sat(time*5.) * sat(231.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 8.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t,vec3(20,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.8,5, 59)\n\t\t\t\t\t\t,vec3(21,5, 49)\n\t\t\t\t\t\t,vec3(5,8, 22.885)\n\t\t\t\t\t\t,vec3(31,5, 76)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(2.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-90,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.8)\n\t\t\t\t\t\t);\n\n\tint section = int(time/10.);\n\tfloat rest = mod(time,10.);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*130. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 200.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*84.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.7)*2.,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.1));\n\tbs.xz*= rot(avance*.1);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 0.1 + mval.y;\n\tfloat dofamount=.0001;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<2;\n\tbool lightsilver = section>6 && section<12;\n\tbool lightgreen = section>1;\n\tbool lightpink = section>6 && section<8;\n\tbool centerlight = section>0;\n\tbool strips = (section>2);\n\tbool bluelight = section >= 0;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,2.);\n     // motion slowing down during the last section\n\tfloat t2=section!=1?time:pow(sat(rest*1.6),.5)*1.5;\n\tif(section==16) {time=1.4; rest=0.2;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*.5 + (fract(mval.z+.4)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>1 && section<3) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>1?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.2;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.9);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 10. : 20.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.1; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-13.6-i*1084.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<3; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,1,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+.3)*7.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.1+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 5.-k*rrad;\n\t\t\t\trad2 = 5.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][1];\n                \n\t\t\t\tfloat d2=10000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.9,0.1,abs(fract(r.x*9.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.4,1);\n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.25+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*5.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .1;\n\t\t\t\t\tcol += alpha * smoothstep(0.4,0.1,fract(time*.5+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.1+floor(r.z*sqsize)*0.02))) * 2. * (rnd33(floor(r*sqsize)+floor(time)*.37)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.2*3.)*10.)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 4. * vec3(1,.2,.3);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*6., localpos.y, length(localpos.xz)*.6);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*20.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .0005*rnd31(id*27.33);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<6.5)?.002:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.05;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .7;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375)+fract(time))-.5)*rough);      \n\t\t}\n\t}\n\tcol *= 0.7/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ssffW2.jpg", "time_retrieved": "2024-04-28T18:59:17.402530", "access": "api", "wgpu-test": "incomplete"}
{"id": "4fV3Dz", "name": "Shader337", "author": "kashircevpetr", "description": "Shader!", "tags": ["shader"], "image_code": "// Rotation around the Y axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n// Rotation around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n// Rotation around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\n\nvec3 past(vec3 a, float xs, float ys, float zs){\n    return a * rotateX(-xs * iTime) * rotateY(-ys * iTime) * rotateZ(-zs * iTime);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(0.5, 0.5);\n    uv *= vec2(iResolution.x/iResolution.y, 1.0);\n    vec2 uv1 = uv; //- vec2(0.1*sin(2.0*iTime), 0.2*cos(3.0*iTime));\n    vec3 col = vec3(0.7, 0.7, 0.7), coordP;\n    \n    if (abs(uv.x) <= 0.3 && -0.4 <= uv.y && uv.y <= 0.0){col = vec3(0.3, 0.3, 0.3);}\n    \n    float xs = 0.01*sin(iTime), ys = 0.0, zs = -0.01*cos(iTime), nz;\n    if (abs(uv1.x) <= 0.18 && -0.18 <= uv1.y && uv.y <= 0.0){\n    for (float z = 174.0; z >= 0.0; z -= 1.0){\n        nz = z / 1000.0;\n        coordP = past(vec3(uv1, nz), xs, ys, zs);\n        if (abs(coordP.z - 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.y) <= 0.1){\n            col = vec3(0.0, 0.0, 1.0);\n            break;\n        }\n        if (abs(coordP.z + 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.y) <= 0.1){\n            col = vec3(0.0, 1.0, 0.0);\n            break;\n        }\n        if (abs(coordP.x - 0.1) <= 0.001 && abs(coordP.z) <= 0.1 && abs(coordP.y) <= 0.1){\n            col = vec3(1.0, 0.0, 0.0);\n            break;\n        }\n        if (abs(coordP.x + 0.1) <= 0.001 && abs(coordP.z) <= 0.1 && abs(coordP.y) <= 0.1){\n            col = vec3(0.0, 1.0, 1.0);\n            break;\n        }\n        if (abs(coordP.y - 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.z) <= 0.1){\n            col = vec3(1.0, 0.0, 1.0);\n            break;\n        }\n        if (abs(coordP.y + 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.z) <= 0.1){\n            col = vec3(1.0, 1.0, 0.0);\n            break;\n        }\n    }}\n    \n    if (abs(uv1.x) <= 0.18 && 0.0 < uv.y && uv1.y <= 0.18){\n    for (float z = 174.0; z >= -174.0; z -= 1.0){\n        nz = z / 1000.0;\n        coordP = past(vec3(uv1, nz), xs, ys, zs);\n        if (abs(coordP.z - 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.y) <= 0.1){\n            col = vec3(0.0, 0.0, 1.0);\n            break;\n        }\n        if (abs(coordP.z + 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.y) <= 0.1){\n            col = vec3(0.0, 1.0, 0.0);\n            break;\n        }\n        if (abs(coordP.x - 0.1) <= 0.001 && abs(coordP.z) <= 0.1 && abs(coordP.y) <= 0.1){\n            col = vec3(1.0, 0.0, 0.0);\n            break;\n        }\n        if (abs(coordP.x + 0.1) <= 0.001 && abs(coordP.z) <= 0.1 && abs(coordP.y) <= 0.1){\n            col = vec3(0.0, 1.0, 1.0);\n            break;\n        }\n        if (abs(coordP.y - 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.z) <= 0.1){\n            col = vec3(1.0, 0.0, 1.0);\n            break;\n        }\n        if (abs(coordP.y + 0.1) <= 0.001 && abs(coordP.x) <= 0.1 && abs(coordP.z) <= 0.1){\n            col = vec3(1.0, 1.0, 0.0);\n            break;\n        }\n    }}\n    \n    float q;\n    float x1 = -0.4 * abs(sin(iTime / 2.3)) + 0.8;\n    float y1 = -0.8 * abs(cos(iTime / 2.3)) + 0.4;\n    float r = 0.1;\n\n   \n    if ((uv.x - x1) * (uv.x - x1) + (uv.y - y1) * (uv.y - y1) <= r * r){\n\n        col = vec3(uv.x * uv.y, uv.x * uv.x + uv.y, uv.y*uv.y) + vec3(0.9, 0.0, 0.4);\n\n    }\n    \n    \n    //Ð´Ð»Ñ Ð¿ÑÑ‚Ð¸ÑƒÐ³Ð¾Ð»ÑŒÐ½Ð¸ÐºÐ°:\n    //5x\n    //0.8+0.2x\n    //0.7-0.25x\n    //2-3x\n    //0.1+1.5x\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fV3Dz.jpg", "time_retrieved": "2024-04-28T18:59:17.563100", "access": "api", "wgpu-test": "ok"}
{"id": "XcV3Dz", "name": "Proton Scattering", "author": "wyatt", "description": "Scattering of a proton beam", "tags": ["physics"], "image_code": "Main {\n    float p = 0.;\n    for (float i = 0.; i < N; i++) {\n        \n        p += 1./length(U-A(.5+vec2(i,0)).xy);\n    }\n    \n    Q = sin(-2.+B(U).x+p+vec4(1,2,3,4));\n    Q.yz -= .2*C(U).x;\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define N 80.\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)", "buffer_a_code": "Main {\n    Q = A(U);\n    \n    vec4 n = B(Q.xy+vec2(0,1));\n    vec4 e = B(Q.xy+vec2(1,0));\n    vec4 s = B(Q.xy-vec2(0,1));\n    vec4 w = B(Q.xy-vec2(1,0));\n    \n    vec2 g = vec2(e.x-w.x,n.x-s.x);\n    \n    Q.zw += -3.*g;\n    Q.xy += g+3.*Q.zw*inversesqrt(1.+dot(Q.zw,Q.zw));\n    \n    if (iFrame < 1) {\n        \n        Q = vec4(-U.x*50.,sin(U.x)*10.+.5*R.y,20,0);\n        \n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\nQ = vec4(0);\n    if (U.x >.5*R.x) {\n        U.y += 10.*floor(U.x/20.);\n        U = mod(U,20.)-10.;\n\n        Q.x = 4./length(U)-1./(4.+length(U));\n    }\n}", "buffer_b_inputs": [], "buffer_c_code": "Main {\n    float p = 0.;\n    for (float i = 0.; i < N; i++) {\n        \n        p += 1./length(U-A(.5+vec2(i,0)).xy);\n    }\n    \n    Q = max(B(U),p);\n\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcV3Dz.jpg", "time_retrieved": "2024-04-28T18:59:17.639895", "access": "api", "wgpu-test": "incomplete"}
{"id": "XcK3DR", "name": "eclipseÍ", "author": "01000001", "description": "I didn't get to see the eclipse so I made my own ):<\n\nInspired by [url=WdBXWV]this shader[/url]\nand a [url=https://tinyurl.com/yvw2v3xj]picture[/url] my friend took\n\nnoise function grabbed from [url=csKBzc]here[/url]", "tags": ["space", "eclipse", "static", "art", "render"], "image_code": "const float pi = 3.1415926;\n#define time iTime * 0.2\n\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nfloat noise(float t, int p){\n    float x = 0.;\n    \n    for (int i = 0; i++<p;){\n        vec3 h = hash(uvec3(i, 2<<i, 5*i));\n        x += sin(h.x * t * float(i) + h.y*pi*2.) * h.z / float(i<<1);\n    }\n\n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = 2.*(2.*U-r)/r.y;\n    vec2 auv = uv;\n    \n    float t = atan(uv.y,uv.x); //Thanks fad\n    //if (uv.y==0.) t=0.;\n    float x;\n    \n    \n    if (length(uv) > 1.){\n        \n        float d = noise(t*2., 2<<6)*2.+1.1;\n        d *= 1./(1.+pow(abs(uv.y), 2.));\n        x = 0.1*d/((length(uv)-1.));\n\n    } else {\n        x = (1.-length(uv))*5e2;\n        x = 1./sqrt(x);\n    }\n    \n    \n    uv.x += \n    //*\n        abs(uv.y)>=1.?1e3:sqrt(1. - pow(abs(uv.y), 2.));\n    /*/\n        1.;\n    //*/\n   \n    if (uv.y == 0.) uv.y = 1./r.y;\n    x += 0.5*(sin(time)+1.)/(abs(uv.x)*abs(uv.y)) / ((abs(500.*uv.y)+1.)*(abs(200.*uv.x)+2.));\n\n    O = mix(\n        mix(\n            vec4(\n                sqrt(x), \n                x, \n                x*x, \n                1\n            ), \n            vec4(\n                x*x,\n                x,\n                sqrt(x),\n                1\n            ), \n            smoothstep(1., 2.5, length(auv))\n        ),\n        vec4(x),\n    0.8);\n    \n    O*= 2.;\n    O = O/(O+vec4(1));\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcK3DR.jpg", "time_retrieved": "2024-04-28T18:59:17.762567", "access": "api", "wgpu-test": "ok"}
{"id": "4fGGDz", "name": " Truck", "author": "wyatt", "description": "Arrow Keys", "tags": ["game", "physics", "vehicle", "truck"], "image_code": "vec3 pos[16];\nfloat S;\nfloat map (vec3 p,vec3 mean, mat3 ori) {\n    vec3 pc = p;\n    float c =car((20.*ori*pc-vec3(0,-.5,0)),S)/20.;\n\n\n     p += mean;\n\n   /*for (int i = 0; i < 4; i++)\n     c = min(c,length(p-pos[i])-.01);\n    for (int i = 4; i < 16; i++)\n     c = min(c,length(p-pos[i])-.005);*/\n     \n     float h = texture(iChannel1,.5+.25*p.xy).x;\n\n    return min(c,abs(p.z-h)-.05);\n}\nvec3 normal(vec3 p,vec3 mean, mat3 ori) {\n   vec2 e = vec2(1e-3,0);\n   return normalize(vec3(\n       map(p+e.xyy,mean,ori)-map(p-e.xyy,mean,ori),\n       map(p+e.yxy,mean,ori)-map(p-e.yxy,mean,ori),\n       map(p+e.yyx,mean,ori)-map(p-e.yyx,mean,ori)\n   ));\n}\nMain {\n    vec3 p = vec3(0,0,-.1);\n    vec3 d = normalize(vec3(2.*(U-.5*R)/R.y,1));\n    \n    vec3 mean = vec3(0);\n    vec3 mean0 = vec3(0);\n    mat3 ori = mat3(0);\n    for (int i = 0; i < 16; i++) {\n        pos[i] = T(vec2(i,0)).xyz;\n        mean += pos[i]/16.;\n    }\n    float up = texelFetch(iChannel2,ivec2(38,0),0).x;\n    float left = texelFetch(iChannel2,ivec2(37,0),0).x;\n    float right = texelFetch(iChannel2,ivec2(39,0),0).x;\n    float down = texelFetch(iChannel2,ivec2(40,0),0).x;\n    S = 0.;\n    if (left>0.) S = +.2;\n    if (right>0.) S = -.2;\n    ori[0] = normalize(pos[5]-pos[4]);\n    ori[1] = normalize(pos[6]-pos[4]);\n    ori[2] = normalize(pos[7]-pos[4]);\n    ori = inverse(ori);\n    p.yz *= ei(3.14*.25);\n    d.yz *= ei(3.14*.25);\n    p.xy*=ei(-3.14159*.5);\n    d.xy*=ei(-3.14159*.5);\n\n    \n    for (float i = 0.; i < 80.; i++) {\n    \n        p += .5*d*map(p,mean,ori);\n        \n    \n    }\n    \n    Q.xyz = .5-.5*normal(p,mean,ori);\n    vec3 light = vec3(vec3(0,1,2));\n    vec3 d0 = d;\n    d = normalize(p-light);\n    Q *= 1.-dot(d,d0);\n    p += .001*d;\n    for (float i = 0.; i < 50.; i++) {\n    \n        p += .5*d*min(map(p,mean,ori),length(p-light)-.01);\n        \n    }\n    Q *= 1.-.5*exp(-.01*length(p-light));\n    \n    \n}", "image_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R);\n#define T(U) texelFetch(iChannel0,ivec2(U),0)\n#define Main void mainImage(out vec4 Q, in vec2 U) \n\n#define ei(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define w_1 vec3(.02,-.02,-.01)\n#define w_2 vec3(-.02,-.02,-.01)\n#define w_3 vec3(.02,.02,-.01)\n#define w_4 vec3(-.02,.02,-.01)\n\n#define p_1 vec3(-.03,.015,-.025)\n#define p_2 vec3(-.03,-.015,-.025)\n#define p_3 vec3(+.03,-.015,-.025)\n#define p_4 vec3(+.03,+.015,-.025)\n#define p_5 vec3(-.007,.012,-.036)\n#define p_6 vec3(-.007,-.012,-.036)\n#define p_7 vec3(+.007,-.012,-.036)\n#define p_8 vec3(+.007,+.012,-.036)\n#define _0 vec3(.0,.0,-.02)\n#define _x vec3(.01,.0,-.02)\n#define _z vec3(.0,0.01,-.02)\n#define _y vec3(.0,.0,-.03)\n\n    #define P0 vec3[16] (w_1,w_2,w_3,w_4,_0,_x,_y,_z,p_1,p_2,p_3,p_4,p_5,p_6,p_7,p_8)\n\nfloat iPlane (vec3 p, vec3 d, vec3 n) {\n    return -dot(p,n)/dot(d,n);\n}\n\nfloat segment (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float segment(vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n    }\n    float line (vec2 p, vec2 a, vec2 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec3 p, vec3 a, vec3 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\n    float line (vec4 p, vec4 a, vec4 b) {\n        return length(p-a-(b-a)*dot(p-a,b-a)/dot(b-a,b-a));\n    }\nfloat cylinder( vec3 p, vec2 h )\n\t\t{\n\t\t    h.y *= 0.5;\n\t\t    vec2 d = abs(vec2(length(p.xy),p.z)) - h;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat cylinder( vec3 p, float r, float h )\n\t\t{\n\t\t    return cylinder(p,vec2(r,h));\n\t\t}\n\t\tfloat sign_side (vec2 p1, vec2 p2, vec2 p3)\n        {\n            return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n        }\n        float PointInTriangle (vec2 pt, vec2 v1, vec2 v2, vec2 v3)\n        {\n            float d1, d2, d3;\n            bool has_neg, has_pos;\n        \n            d1 = sign_side(pt, v1, v2);\n            d2 = sign_side(pt, v2, v3);\n            d3 = sign_side(pt, v3, v1);\n        \n            has_neg = (d1 < 0.) || (d2 < 0.) || (d3 < 0.);\n            has_pos = (d1 > 0.) || (d2 > 0.) || (d3 > 0.);\n        \n            return float((has_neg && has_pos))*2.-1.;\n        }\n        float triangle (vec2 p, vec2 a, vec2 b, vec2 c) {\n            return PointInTriangle(p.xy,a,b,c)*min(segment(p,a,b),min(segment(p,b,c),segment(p,c,a)));\n        }\n        float triPrism(vec3 p, vec2 a, vec2 b, vec2 c, float h) {\n          vec2 d = vec2(triangle(p.xy,a,b,c),abs(p.z)-.5*h);\n          \n          return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n        }\n\t\tfloat triPrism( vec3 p, vec2 h )\n        {\n          vec3 q = abs(p);\n          return max(q.z-.5*h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n        }\n        float segment ( vec3 p, vec3 a, vec3 b, float r )\n        {\n          vec3 pa = p - a, ba = b - a;\n          float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n          return length( pa - ba*h ) - r;\n        }\n\t\tfloat box(vec2 p, vec2 b) {\n\t\t\tvec2 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box( vec3 p, vec3 b )\n\t\t{\n\t\t    vec3 d = abs(p) - b*0.5;\n\t\t    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n\t\t}\n\t\tfloat box(vec3 p, float w, float h, float l) {return box(p,vec3(w,h,l));}\n\t\tfloat box(vec2 p, float w, float h) {return box(p,vec2(w,h));}\n\t\tfloat roundBox ( vec3 p, vec3 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return cylinder(p,vec2(r,b.z));\n\t\t}\n\t\tfloat roundBox ( vec2 p, vec2 b, float r) \n\t\t{\n\t\t    vec2 h = 0.5*vec2(b.x,b.y)-r;\n\t\t    p.xy = abs(p.xy);\n\t\t    p.xy = p.xy-clamp(p.xy,-h,h);\n\t\t    return length(p)-r;\n\t\t}\n\t\tfloat roundBox(vec3 p, float w, float h, float l, float r) {return roundBox(p,vec3(w,h,l),r);}\n\t\tfloat roundBox(vec2 p, float w, float h, float r) {return roundBox(p,vec2(w,h),r);}\n\t\t\n        \n        \n        \n        \n        \nfloat wheels (vec3 p, float s) {\n    vec3 q = p;\n    p = abs(p)-vec3(.3,0,.3);\n    s *= 2.*sign(-q.z);\n    \n    if (q.x<0.) p.xz *= mat2(cos(s),sin(s),-sin(s),cos(s));\n    return max(cylinder(p,.1,.1),-cylinder(p-vec3(0,.0,0),.07,.15));\n}\nfloat car (vec3 p, float s) {\n    float d = 1e9;\n    p *= .8;\n    float w = wheels(p-vec3(0,.2,0),s);\n    d = min(d,roundBox(p-vec3(0,.3,0),vec3(1.,.2,.6),.02));\n    d = min(d,triPrism(p,vec2(-.3,.4),vec2(-.1,.4),vec2(-.1,.6),.45));\n    d = min(d,roundBox(p-vec3(.02,.5,0),vec3(.25,.2,.45),.02));\n    d = max(d,min(w-.06,-roundBox(p-vec3(.3,.4,0),vec3(.3,.14,.45),.02)));\n    d = min(max(d,-w+.05),w);\n    p.z = abs(p.z);\n    d = min(d,roundBox(p.zyx-vec3(.3,.44,-.25),vec3(.1,.05,.01),.01));\n    return d/.8-.014;\n}", "buffer_a_code": "Main {\n    U = floor(U);\n    \n    if (U.y>=2.||U.x>=16.) discard;\n    \n    \n    \n    vec3 P[16]; vec3 V[16]; vec3 F[16];\n    for (int i = 0; i < 16; i++){ \n        P[i] = T(vec2(i,0)).xyz;\n        V[i] = T(vec2(i,1)).xyz;\n    }\n    \n    for (int k = 0; k < 60; k++) {\n        for (int i = 0; i < 16; i++) {\n            float mass = i < 4? 20.:5.;\n            F[i] = vec3(0,0,.0000001*mass);\n            for (int j = 0; j < 16; j++) {\n                if (i!=j) {\n\n                    vec3 r = P[j]-P[i];\n                    vec3 r0= P0[j]-P0[i];\n                    float l = length(r);\n                    float l0 = length(r0);\n                    vec3 dv = (V[j]-V[i]);\n                    if (l > 0.) {\n                    F[i] += r/l*(l-l0)/16.;\n                    if (length(dv)>0.){\n                        F[i] += dv*pow(abs(dot(normalize(dv),r/l)),3.)/16.;\n                    }\n                    }\n\n                }\n                float l = i < 4?.01:.008;\n                vec4 h = texture(iChannel1,.5+.25*P[i].xy);\n\n                if (abs(P[i].z-h.x)-.05<l) {\n                    F[i] +=  (abs(P[i].z-h.x)-.05-l)*h.yzw;\n                    \n                    if (i < 4) {\n                        vec3 dr = P[7]-P[4];\n                        F[i] -= .5*normalize(dr)*dot(dr,V[i]);\n                        dr = P[6]-P[4];\n                        F[i] -= .5*normalize(dr)*dot(dr,V[i]);\n                    } else {\n                        vec3 dr = P[7]-P[4];\n                        F[i] -= .33*normalize(dr)*dot(dr,V[i]);\n                        dr = P[5]-P[4];\n                        F[i] -= .33*normalize(dr)*dot(dr,V[i]);\n                        dr = P[6]-P[4];\n                        F[i] -= .33*normalize(dr)*dot(dr,V[i]);\n                    }\n                    \n                }\n\n\n            }\n        }\n        for (int i = 0; i < 16; i++ ){\n            float mass = i < 4? 20.:5.;\n            V[i] += F[i]/mass- .0001*V[i];\n            P[i] += F[i]/mass + V[i];\n        }\n    }\n    \n    if (iFrame < 1) {\n        P = P0;\n        for (int i = 0; i < 16; i++ )V[i] = 0.*vec3(-.0001,0,0);\n    }\n    \n    float up = texelFetch(iChannel2,ivec2(38,0),0).x;\n    float left = texelFetch(iChannel2,ivec2(37,0),0).x;\n    float right = texelFetch(iChannel2,ivec2(39,0),0).x;\n    float down = texelFetch(iChannel2,ivec2(40,0),0).x;\n    for (int i = 0;i < 16; i++) {\n        float s = 1.;\n        if (up>0.&&iFrame>10) \n            V[i] -= .000001*normalize(P[5]-P[4]);\n        if (down>0.&&iFrame>10) \n            V[i] += .000001*normalize(P[5]-P[4]),s = -1.;;\n            \n       \n        if (right>0.&&iFrame>1&&i!=4) \n            V[i] -= s*.0000005*cross(normalize(P[i]-P[4]),normalize(P[6]-P[4]));\n            \n        if (left>0.&&iFrame>1&&i!=4) \n            V[i] += s*.0000005*cross(normalize(P[i]-P[4]),normalize(P[6]-P[4]));\n    }\n    \n    for (int i = 0; i < 16; i++) {\n        if (U.x==float(i)&&U.y==0.) Q.xyz = P[i];\n        if (U.x==float(i)&&U.y==1.) Q.xyz = V[i];\n    }\n\n\n}", "buffer_a_inputs": [{"id": 33, "src": "/presets/tex00.jpg", "ctype": "keyboard", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    float h = texture(iChannel1,U/R).x;\n     h += .5*texture(iChannel1,2.*U/R).x;\n     h += 3.*texture(iChannel1,.25*U/R).x;\n     h += 20.*texture(iChannel1,.125*U/R).x;\n     \n     \n     \n     Q = vec4(.007*h);\n     Q *= 1.-exp(-.001*U.x*U.x);\n     Q *= 1.-exp(-.001*(R.x-U.x)*(R.x-U.x));\n     Q *= 1.-exp(-.001*U.y*U.y);\n     Q *= 1.-exp(-.001*(R.y-U.y)*(R.y-U.y));\n     Q += .2;\n     vec4 n = A(U+vec2(0,1));\n     vec4 e = A(U+vec2(1,0));\n     vec4 s = A(U-vec2(0,1));\n     vec4 w = A(U-vec2(1,0));\n     Q.x = .2*Q.x + (.8)*0.25*(n+e+s+w).x;\n     Q.yzw = normalize(vec3(w.x-e.x,s.x-n.x,1));\n}", "buffer_b_inputs": [{"id": 2, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fGGDz.jpg", "time_retrieved": "2024-04-28T18:59:18.470672", "access": "api", "wgpu-test": "incomplete"}
{"id": "XcKGDR", "name": "Influence between two circles", "author": "Umbre", "description": "Use mouse. Influence between two circles. Influence between two circles. Calculated with the Apollonius circle.", "tags": ["influence"], "image_code": "vec3 sdgCircle( in vec2 p, in float r ) \n{\n    float d = length(p);\n    return vec3( d-r, p/d );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    m.x *= iResolution.x/iResolution.y;\n\n    //construction objet1\n    float radius1 = 0.34;\n    vec2 point1 = vec2(-0.19,0.1221);\n    float size1 = -sdgCircle(vec2(0.),radius1).x;\n    vec3 grad1 = sdgCircle(uv-point1,radius1);\n    float influence1 = -grad1.x/size1;\n    //construction objet2\n    float radius2 = 0.65;\n    vec2 point2 = m;\n    float size2 = -sdgCircle(vec2(0.),radius2).x;\n    vec3 grad2 = sdgCircle(uv-point2,radius2);\n    float influence2 = -grad2.x/size2;\n    \n    // on trie les objets dans l'ordre d'influence\n    float r1, r2;\n    vec2 p1, p2;\n    float s1, s2;\n    vec3 g1, g2;\n    float i1, i2;\n    if(influence1 > influence2)\n    {\n        r1 = radius1;\n        p1 = point1;\n        s1 = size1;\n        g1 = grad1;\n        i1 = influence1;\n        \n        r2 = radius2;\n        p2 = point2;\n        s2 = size2; \n        g2 = grad2;\n        i2 = influence2;\n        \n    }\n    else\n    {\n        r2 = radius1;\n        p2 = point1;\n        s2 = size1;\n        g2 = grad1;\n        i2 = influence1;\n        \n        r1 = radius2;\n        p1 = point2;\n        s1 = size2; \n        g1 = grad2;\n        i1 = influence2;\n    }\n    //Distance to the Apollonius circle:\n    float k = r1/r2;\n    vec2 centerApollonius = vec2(p1.x-k*k*p2.x,p1.y-k*k*p2.y)/(1.-k*k);\n    float radiusApollonius = distance(p1,p2)*k/abs(k*k-1.);\n    float ApolloniusDelta = abs(radiusApollonius - distance(uv,centerApollonius));\n    \n    vec3 col = vec3(min(i1,ApolloniusDelta/r1));\n\n    //colors :\n    col = cos(50.*clamp(col,0.,1.));\n    if(p1==point1)\n    {\n        col*= vec3(0.8,0.2,0.2);\n    }\n    else\n    {\n        col*= vec3(0.2,0.8,0.8);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcKGDR.jpg", "time_retrieved": "2024-04-28T18:59:19.365279", "access": "api", "wgpu-test": "ok"}
{"id": "Mfy3DR", "name": "MIP map chain UV", "author": "Zavie", "description": "Just a very quick shader for MIP mapping chain generation and other pyramid based post-processing.\nNote: it is currently incomplete as it's not very useful without a fonction to convert coordinates between the different levels.", "tags": ["uv", "mipmap"], "image_code": "//\n// This shader is a quick test at splitting the available renderbuffer\n// into MIP chain sub-buffers.\n//\n\n#define DIAGONAL 0\n#define SPIRAL 1\n#define MODE SPIRAL\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    int stop = 10;\n    while (true)\n    {\n#if MODE == SPIRAL\n        uv = vec2(uv.y, 1.0 - uv.x * 2.0);\n#elif MODE == DIAGONAL\n        uv = vec2(1.0 - uv.y, 1.0 - 2.0 * uv.x);\n#endif\n\n        if (uv.y < 0.)\n        {\n            uv.y += 1.;\n            break;\n        }\n        if (stop-- < 0) break;\n    }\n\n    float dUV = length(fwidth(uv));\n#if MODE == SPIRAL\n    float d = length(uv - vec2(0.0, 1.0));\n    float pattern = 1.0 - smoothstep(-dUV, dUV, abs(d - 1.) - dUV);\n#elif MODE == DIAGONAL\n    float d = uv.y + 2.0 * uv.x - 2.0;\n    float pattern = 1.0 - smoothstep(-dUV, dUV, abs(d) - dUV);\n#endif\n    vec3 color = mix(vec3(uv, 0.0), vec3(1.0), pattern);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mfy3DR.jpg", "time_retrieved": "2024-04-28T18:59:19.392207", "access": "api", "wgpu-test": "ok"}
{"id": "McG3DR", "name": "2d sdf soft shadow", "author": "breeze028", "description": "\n", "tags": ["2d", "sdf", "shadow", "light"], "image_code": "float circleDist(vec2 p, float radius)\n{\n    return length(p) - radius;\n}\n\nfloat boxDist(vec2 p, vec2 size, float radius)\n{\n\tsize -= vec2(radius);\n\tvec2 d = abs(p) - size;\n  \treturn min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - radius;\n}\n\nfloat starDist(in vec2 p, in float r, in float m)\n{\n    const vec2 k1 = vec2(0.809016994375, -0.587785252292);\n    const vec2 k2 = vec2(-k1.x, k1.y);\n    \n    p.x = abs(p.x);\n    p -= 2.0 * max(dot(k1, p), 0.0) * k1;\n    p -= 2.0 * max(dot(k2, p), 0.0) * k2;\n    p.x = abs(p.x);\n    p.y -= r;\n    vec2 ab = m * vec2(-k1.y, k1.x) - vec2(0, r); \n    float h = clamp(dot(p, ab) / dot(ab, ab), 0.0, 1.0 );\n    return length(p - ab * h) * sign(p.y * ab.x - p.x * ab.y);\n}\n\nfloat sceneDist(vec2 p)\n{\n    float dist = 100.0;\n\n    // circle\n    vec2 p1 = p;\n    float dist1 = circleDist(p1, 0.15);\n    dist = min(dist, dist1);\n\n    // rectangle\n    vec2 p2 = p + vec2(-0.5, -0.5);\n    float dist2 = boxDist(p2, vec2(0.10, 0.18), 0.01);\n    dist = min(dist, dist2);\n\n    // star\n    vec2 p3 = p + vec2(0.2, 0.55);\n    float dist3 = starDist(p3, 0.2, 0.08);\n    dist = min(dist, dist3);\n\n    return dist;\n}\n\nfloat shadow(vec2 p, vec2 lightPos)\n{\n    float res = 1.0;\n    vec2  dir = normalize(lightPos - p);\n    float t   = 0.0;                      // travel distance\n\n    for (int i = 0; i < 64; i++)\n    {\n        float h = sceneDist(p + t * dir);\n\n        if (t > distance(p, lightPos))\n            break;\n\n        if (h < 0.001)\n            return 0.0;\n\n        res = min(res, 32.0 * h / t);\n        t += h;\n    }\n\n    return res;\n}\n\nvec3 drawLight(vec2 p, vec2 lightPos, vec3 lightColor, float range)\n{\n    // distance to light\n\tfloat ld = length(p - lightPos);\n\t\n\t// out of range\n\tif (ld > range) return vec3(0.0);\n\t\n\t// shadow and falloff\n\tfloat shad = shadow(p, lightPos);\n\tfloat fall = (range - ld)/range;\n\tfall *= fall;\n\tfloat source = clamp(-circleDist(p - lightPos, 0.05), 0.0, 1.0);\n\treturn (shad * fall + source) * lightColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // x: -aspectRatio ~ aspectRatio, y: -1 ~ 1\n    vec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    \n    // lightPos set-up\n    vec2 light1Pos = 1.0 * vec2(cos(iTime), sin(iTime));\n    vec2 light2Pos = 0.3 * vec2(cos(2.0 * iTime), sin(-2.0 * iTime));\n    \n    // light & shadow\n    vec3 color = vec3(0.0);\n    color += drawLight(uv, light1Pos, vec3(0.5, 0.75, 1.0), 2.0);\n    color += drawLight(uv, light2Pos, vec3(1.0, 0.75, 0.5), 1.5);\n\n    // fill\n    color = mix(vec3(1.0, 0.4, 0.0), color, smoothstep(-0.001, 0.001, sceneDist(uv)));\n    // border\n    color = mix(vec3(0.0, 0.0, 0.0), color, smoothstep(0.000, 0.003, abs(sceneDist(uv))));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McG3DR.jpg", "time_retrieved": "2024-04-28T18:59:19.410159", "access": "api", "wgpu-test": "ok"}
{"id": "McGGz1", "name": "Too much repetition", "author": "morimea", "description": "Copy of visual look from [url]https://mastodon.gamedev.place/@daniFMdev/112223202797686927[/url]", "tags": ["3d", "raymarching", "radial", "repetition"], "image_code": "\n// Created by Danil (2022+) https://github.com/danilw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\n// using https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// https://iquilezles.org/articles/normalsSDF\n// https://iquilezles.org/articles/rmshadows\n// using http://mercury.sexy/hg_sdf/\n// using sdf repetition fix from https://www.shadertoy.com/view/WtXcWB\n// using VXAA from https://www.shadertoy.com/view/WdGBDw\n\n\n// copy of visual look from \n// https://mastodon.gamedev.place/@daniFMdev/112223202797686927\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 col = texture(iChannel3, fragCoord.xy/iResolution.xy).rgb;\n    float a = 1.-smoothstep(0.,0.01,dot(col.rgb,vec3(1.)));\n    col=1./0.975*(col.rgb-0.025);\n    col = clamp(col,0.0,1.);\n    \n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    float c = sl(uv*2.5,0.017,0.2,0.2); \n    c+= sl((uv.yx+31.433)*5.5,0.017,0.15,0.1);\n    \n    fragColor = vec4(col+c*a,1.);\n\n    \n}\n\n\n\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "\n\n#define PI 3.14159265\n\n#define FIX_FRACT_HASH 1000.\n\nfloat hash12(vec2 p)\n{\np = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash22(vec2 p)\n{\np = sign(p)*(floor(abs(p))+floor(fract(abs(p))*FIX_FRACT_HASH)/FIX_FRACT_HASH);\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nfloat sl(vec2 p, float sz, float gr, float x){\n    vec2 ip = 3.33+floor(p/gr)*11.31;\n    float b = hash12(ip*100.13);\n    float a = b*0.3*sz*hash12(ip*33.13);\n    return (1.-smoothstep(a,a+sz*0.15+sz*0.55*b,length(mod(p,gr)-gr*0.5+sz*hash22(ip*20.33))))*step(hash12(ip*1.13),x);\n}\n\nfloat pModInterval1(inout float p, float size, float start, float stop) {\n\tfloat halfsize = size*0.5;\n\tfloat c = floor((p + halfsize)/size);\n\tp = mod(p+halfsize, size) - halfsize;\n\tif (c > stop) { //yes, this might not be the best thing numerically.\n\t\tp += size*(c - stop);\n\t\tc = stop;\n\t}\n\tif (c <start) {\n\t\tp += size*(c - start);\n\t\tc = start;\n\t}\n\treturn c;\n}\n\n\n// http://mercury.sexy/hg_sdf/\n\nfloat pModPolar(inout vec2 p, float repetitions) {\n\tfloat angle = 2.*PI/repetitions;\n\tfloat a = atan(p.y, p.x) + angle/2.;\n\tfloat r = length(p);\n\tfloat c = floor(a/angle);\n\ta = mod(a,angle) - angle/2.;\n\tp = vec2(cos(a), sin(a))*r;\n\t// For an odd number of repetitions, fix cell index of the cell in -x direction\n\t// (cell index would be e.g. -5 and 5 in the two halves of the cell):\n\tif (abs(c) >= (repetitions/2.)) c = abs(c);\n\treturn c;\n}\n\n\n// first object gets a v-shaped engraving where it intersect the second\nfloat fOpEngrave(float a, float b, float r) {\n\treturn max(a, (a + r - abs(b))*sqrt(0.5));\n}\n\n// first object gets a capenter-style groove cut out\nfloat fOpGroove(float a, float b, float ra, float rb) {\n\treturn max(a, min(a + ra, rb - abs(b)));\n}\n\n// first object gets a capenter-style tongue attached\nfloat fOpTongue(float a, float b, float ra, float rb) {\n\treturn min(a, max(a - ra, abs(b) - rb));\n}\n\nfloat fOpUnionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r - a,r - b), vec2(0));\n\treturn max(r, min (a, b)) - length(u);\n}\n\nfloat fOpPipe(float a, float b, float r) {\n\treturn length(vec2(a, b)) - r;\n}\n\nfloat fOpIntersectionRound(float a, float b, float r) {\n\tvec2 u = max(vec2(r + a,r + b), vec2(0));\n\treturn min(-r, max (a, b)) + length(u);\n}\n\nfloat fOpIntersectionChamfer(float a, float b, float r) {\n\treturn max(max(a, b), (a + r + b)*sqrt(0.5));\n}\n\n// Difference can be built from Intersection or Union:\nfloat fOpDifferenceChamfer (float a, float b, float r) {\n\treturn fOpIntersectionChamfer(a, -b, r);\n}\n\nfloat fOpUnionChamfer(float a, float b, float r) {\n\treturn min(min(a, b), (a - r + b)*sqrt(0.5));\n}\n\nfloat fOpDifferenceRound (float a, float b, float r) {\n\treturn fOpIntersectionRound(a, -b, r);\n}\n\n\n\n\n\n", "buffer_a_code": "// Created by Danil (2022+) https://github.com/danilw\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n\n// using https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// https://iquilezles.org/articles/normalsSDF\n// https://iquilezles.org/articles/rmshadows\n// using http://mercury.sexy/hg_sdf/\n// using sdf repetition fix from https://www.shadertoy.com/view/WtXcWB\n// using VXAA from https://www.shadertoy.com/view/WdGBDw\n\n\n// copy of visual look from \n// https://mastodon.gamedev.place/@daniFMdev/112223202797686927\n\n\n// angle loop fix\n#define ANGLE_loop (min(iFrame,0))\n//#define ANGLE_loop 0\n\n#define MIN_DIST 0.000001\n#define MAX_DIST 100.\n\n#define MAX_MARCHING_STEPS 512\n#define epsilon_step 0.0001\n\n#define MAX_SHADOW_STEPS 64\n\n#define MD(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\n\nconst float obj_SKY_id = -1.;\nconst float obj_1_id = 1.;\nconst float obj_2_id = 2.;\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 map( in vec3 p)\n{\n    vec2 res = vec2( MAX_DIST, obj_SKY_id);\n    p.yx*=MD(-iTime*0.015-1.6);\n    {\n        const float rb = 1.75;\n        const float rbh = 1.7;\n        const float rbo = 1.85;\n        float td = sdCappedCylinder(p.xzy, rbh, rb );\n        td = min(td, sdCappedCylinder(p.xzy, rbo, 1.2 ));\n\n        td = fOpIntersectionRound(td, -sdCappedCylinder(p.xzy, 2., 0.8 ), 0.025);\n        td = min(td, max(sdCappedCylinder(p.xzy, rbo-0.05, 1. ), -sdCappedCylinder(p.xzy, 2., 0.77 )));\n        td = fOpGroove(td, sdCappedCylinder(p.xzy, 2., 1. ), 0.035, 0.15);\n\n        float ttd = fOpIntersectionRound(sdCappedCylinder(p.xzy, rbh+0.05, rb-0.15 ),\n        -sdCappedCylinder(p.xzy, 2., rb-0.25 ),0.15)-0.05;\n\n        td = fOpUnionRound(td, ttd, 0.25);\n\n        td = max(td,min(sdCappedCylinder(p.xzy, rbh+0.105, rb ),sdCappedCylinder(p.xzy, 2., 1.4 )));\n        \n        td = min(td,sdCappedCylinder(p.xzy+vec3(0.,0.,1.4),rbo+0.15,0.0045));\n        td = min(td,sdCappedCylinder(p.xzy+vec3(-sign(p.x)*1.3,0.,0.2),rbo+0.2,0.0035));\n        td = min(td,sdCappedCylinder(p.xzy+vec3(0.8,0.,-sign(p.y)*0.4),rbo+0.25,0.0045));\n        \n        res = opU( res, vec2(td, obj_1_id ) );\n    }\n    {\n        float idp = pModPolar(p.xy, 125.);\n        float idl = pModInterval1(p.z, 0.163, -10., 10.);\n        float th = 0.015+0.135*hash12(vec2(idp,idl)*234.);\n\n        // repetition sdf fix from https://www.shadertoy.com/view/WtXcWB\n        float td = sdBox(p+vec3(-1.75-th,0.,0.0), vec3(th,0.032,0.032));\n        float tdn = sdBox(p+vec3(-1.75-0.15,-sign(p.y)*0.163*0.5*1.25,0.0), vec3(0.15,0.032,0.032));\n        float tdk = sdBox(p+vec3(-1.75-0.15,0.0,-sign(p.z)*0.163*0.5*2.), vec3(0.15,0.032,0.032));\n        td=min(td,(abs(idl)<9.5)?min(tdn,tdk):min(td,tdn));\n        res = opU( res, vec2(td, obj_2_id ) );\n    }\n\n    \n    return res;\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd){\n    vec2 res = vec2( MAX_DIST, obj_SKY_id);\n\n    float tmin = MIN_DIST;\n    float tmax = MAX_DIST;\n    float t = tmin;\n    for( int i=ANGLE_loop; i<MAX_MARCHING_STEPS && t<tmax; i++ )\n    {\n        vec2 h = map( ro+rd*t);\n        if( abs(h.x)<(epsilon_step*t) )\n        { \n            res = vec2(t,h.y); \n            break;\n        }\n        t += h.x;\n    }\n    \n    return res;\n}\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax)\n{\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ANGLE_loop; i<MAX_SHADOW_STEPS; i++ )\n    {\n\t\tvec2 th = map( ro + rd*t );\n        float h = th.x; float m = float(th.y==obj_1_id);\n        float s = clamp((20.0+100.*m)*h/t,0.0,1.0);\n        res = min( res, s );\n        t += (1.-0.4*m)*clamp( h, 0.01, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    res = clamp( res, 0.0, 1.0 );\n    return res*res*(3.0-2.0*res);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec3 n = vec3(0.0);\n    for( int i=ANGLE_loop; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n    }\n    return normalize(n);   \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ANGLE_loop; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec2 toPolar(vec2 v)\n{\n    v.y+=0.0001*(1.-abs(sign(v.y)));\n    return vec2(atan(v.y, v.x)/3.14159265, length(v));\n}\n\nfloat boxmap(in vec3 p, in vec3 n, in float tsc)\n{\n    p.yx*=MD(-iTime*0.015+0.6);\n\tfloat x = 0.;\n\tfloat y = 0.;\n    float z = 0.;\n    if(abs(n.z)<0.75){x=hash12(floor((vec2(toPolar(p.yx).x*(1.+2.*step(0.4,length(p.xy))),p.z))*tsc*64.*0.5)*64.);y=x;}\n\telse z = hash12( floor(toPolar(p.xy)*tsc*64.)*64.);\n    vec3 m = pow( abs(n), vec3(8.) );\n\treturn (x*m.x + y*m.y + z*m.z) / (m.x + m.y + m.z);\n}\n\nvec4 render( in vec3 ro, in vec3 rd)\n{ \n    // sky\n    vec3 col = vec3(0.);\n    float a = 0.;\n    vec2 res = raycast(ro, rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    vec3 pos = ro + t*rd;\n    vec3 nor = calcNormal( pos );\n\n    float mat_s = 0.;\n    if(m==obj_1_id){\n        vec3 tno=abs(nor);\n        mat_s = boxmap(pos*.15, nor, .75 );\n        float om = mat_s;\n        mat_s+= boxmap(pos*.25, nor, 1. );\n        mat_s*= boxmap(pos*.35, nor, 1.5 );\n        mat_s+= om*boxmap(pos*.47, nor, 3. );\n        mat_s = smoothstep(.25,1.+1.5*step(abs(nor.z)+step(0.85,length(pos.yx)),0.15),(mat_s*mat_s));\n    \n    }\n    \n    mat_s=(mat_s*2.-1.)*.25-0.15;\n    vec2 tp = mod(pos.xy,0.1);\n    \n\n    if( m>obj_SKY_id )\n    {\n        vec3 ref = reflect( rd, nor );    \n        col = (obj_1_id==m)?vec3(0.3):vec3(0.21);\n        a=1.;\n        float occ = calcAO( pos, nor );\n\t\tvec3 lin = vec3(0.0);\n\n        {\n            const vec3 lightDir = normalize(vec3(0.5, 1.4, -0.85));\n            vec3  hal = normalize( lightDir-rd );\n            float dif = clamp( dot( nor, lightDir ), 0.0, 1.0 );\n            occ = occ*mix(mat_s+.5,1.,0.9*(1.-dif));\n\n        \tdif *= calcSoftshadow( pos, lightDir, 0.02, 20.5 );\n\n            vec3 sunColor = vec3(lightDir.y);\n            lin += col*2.20*dif*sunColor*(0.05+0.95*1./max(0.41,mat_s+0.5));\n        }\n        \n        {\n            float tmat_s=1.-(mat_s+0.5);\n            if(m==obj_1_id)\n            {\n                float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                dif *= occ;\n            \n                lin += col*0.60*dif*(mix(vec3(0.75),vec3(0.),tmat_s)+0.25);\n            }\n        }\n        \n        col = lin;\n        \n    }\n\n\treturn vec4(col,a);\n}\n\nvoid SetCamera(vec2 uv, out vec3 ro, out vec3 rd)\n{\n    ro = vec3(-6.08, 5.4, -9.25);\n    vec2 m = vec2(0.637, -0.463);\n    m.y = -m.y;\n    float fov=20.;\n    float aspect = iResolution.x / iResolution.y;\n    float screenSize = (1.0 / (tan(((180.-fov)* (3.1415926 / 180.0)) / 2.0)));\n    rd = vec3(uv*screenSize, 1./aspect);\n\n    rd = normalize(rd);\n    mat3 rotX = mat3(1.0, 0.0, 0.0, 0.0, cos(m.y), sin(m.y), 0.0, -sin(m.y), cos(m.y));\n    mat3 rotY = mat3(cos(m.x), 0.0, -sin(m.x), 0.0, 1.0, 0.0, sin(m.x), 0.0, cos(m.x));\n    rd = (rotY * rotX) * rd;\n}\n//-------------------------\n\n\nvec3 ACESFilm(vec3 x){\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n    return (x*(a*x+b))/(x*(c*x+d)+e);\n}\nvec3 srgb_encode (vec3 v) {\n  return mix(12.92*v,1.055*pow(v,vec3(.41666))-.055,step(.0031308,v));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nfragCoord.xy += (iFrame % 2 == 0) ? vec2(0.5, 0.5) : vec2(0.0, 0.0);\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.y *= iResolution.y/iResolution.x;\n    \n    vec3 ro; vec3 rd;\n    SetCamera(uv, ro, rd);\t\n    vec4 color = render( ro, rd );\n    \n    color.rgb = ACESFilm(color.rgb);\n    color.rgb = srgb_encode(color.rgb);\n    \n    color.rgb = clamp(color.rgb,0.,1.);\n    fragColor = vec4(color.rgb*0.975+0.025*color.a, 1.0 );\n}\n\n\n\n", "buffer_a_inputs": [], "buffer_b_code": "/*\n\n    Copyright 2020 UAA Software\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n    associated documentation files (the \"Software\"), to deal in the Software without restriction,\n    including without limitation the rights to use, copy, modify, merge, publish, distribute,\n    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial\n    portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n    NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES\n    OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define VXAA_TEXTURE_CURRENT iChannel0\n#define VXAA_TEXTURE_PREV iChannel1\n\n#define VXAA_TEMPORALEDGE_THRES 0.08\n#define VXAA_TEMPORALEDGE_TIME_MIN 0.0000001\n#define VXAA_TEMPORALEDGE_TIME_MAX 1.5\n#define VXAA_SPATIAL_FLICKER_TIME 2.75\n\n#define VXAA_W 0\n#define VXAA_E 1\n#define VXAA_N 2\n#define VXAA_S 3\n#define VXAA_NW 0\n#define VXAA_NE 1\n#define VXAA_SW 2\n#define VXAA_SE 3\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nvec4 pow3( vec4 x, float y )\n{\n    return vec4( pow( x.x, y ), pow( x.y, y ), pow( x.z, y ), x.w );\n}\n\nfloat VXAALuma( vec3 c )\n{\n    return dot( c, vec3( 0.2126, 0.7152, 0.0722 ) );\n}\n\nfloat VXAALumaDiff( vec3 x, vec3 y )\n{\n    float l1 = dot( x, vec3( 0.2126, 0.7152, 0.0722 ) );\n    float l2 = dot( y, vec3( 0.2126, 0.7152, 0.0722 ) );\n    return abs( l1 - l2 );\n}\n\nvec3 VXAAClampHistory( vec3 history, vec4 currN[4] )\n{\n    vec3 cmin = min( min( currN[0].rgb, currN[1].rgb ), min( currN[2].rgb, currN[3].rgb ) );\n    vec3 cmax = max( min( currN[0].rgb, currN[1].rgb ), max( currN[2].rgb, currN[3].rgb ) );\n    return vec3(\n        clamp( history.r, cmin.r, cmax.r ),\n        clamp( history.g, cmin.g, cmax.g ),\n        clamp( history.b, cmin.b, cmax.b )\n    );\n}\n\nvec2 VXAADifferentialBlendWeight( vec4 n[4] )\n{\n    float diffWE = VXAALumaDiff( n[ VXAA_W ].rgb, n[ VXAA_E ].rgb );\n    float diffNS = VXAALumaDiff( n[ VXAA_N ].rgb, n[ VXAA_S ].rgb );\n    return diffWE < diffNS ? vec2( 0.5, 0.0 ) : vec2( 0.0, 0.5 );\n}\n\nvec4 VXAADifferentialBlend( vec4 n[4], vec2 w )\n{\n    vec4 c = vec4( 0.0 );\n    c += ( n[ VXAA_W ] + n[ VXAA_E ] ) * w.x;\n    c += ( n[ VXAA_N ] + n[ VXAA_S ] ) * w.y;\n    return c;\n}\n\nvoid VXAAUpsampleT4x( out vec4 vtex[4], vec4 current, vec4 history, vec4 currN[4], vec4 histN[4] )\n{\n    vec4 n1[4], n2[4];\n    \n    n1[VXAA_W] = currN[VXAA_W];\n    n1[VXAA_E] = current;\n    n1[VXAA_N] = history;\n    n1[VXAA_S] = histN[VXAA_S];\n    \n    n2[VXAA_W] = history;\n    n2[VXAA_E] = histN[VXAA_E];\n    n2[VXAA_N] = currN[VXAA_N];\n    n2[VXAA_S] = current;\n    \n    \n    vec4 weights = vec4( VXAADifferentialBlendWeight( n1 ), VXAADifferentialBlendWeight( n2 ) );\n    vtex[VXAA_NW] = history;\n    vtex[VXAA_NE] = VXAADifferentialBlend( n2, weights.zw );\n    vtex[VXAA_SW] = VXAADifferentialBlend( n1, weights.xy );\n    vtex[VXAA_SE] = current;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Sample scene and neighbourhood.\n    \n    vec4 current = clamp( vec4( texture( VXAA_TEXTURE_CURRENT, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    vec4 history = clamp( vec4( texture( VXAA_TEXTURE_PREV, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    current.a = VXAALuma( current.rgb ); history.a = VXAALuma( history.rgb );\n    \n    vec4 currN[4];\n    currN[VXAA_W] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2( -1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_E] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_N] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_S] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_W].a = VXAALuma( currN[ VXAA_W ].rgb );\n    currN[VXAA_E].a = VXAALuma( currN[ VXAA_E ].rgb );\n    currN[VXAA_N].a = VXAALuma( currN[ VXAA_N ].rgb );\n    currN[VXAA_S].a = VXAALuma( currN[ VXAA_S ].rgb );\n    \n    vec4 histN[4];\n    histN[VXAA_W] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2( -1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_E] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  1.0f,  0.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_N] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_S] = clamp( texture( VXAA_TEXTURE_PREV, uv + vec2(  0.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_W].a = VXAALuma( histN[ VXAA_W ].rgb );\n    histN[VXAA_E].a = VXAALuma( histN[ VXAA_E ].rgb );\n    histN[VXAA_N].a = VXAALuma( histN[ VXAA_N ].rgb );\n    histN[VXAA_S].a = VXAALuma( histN[ VXAA_S ].rgb );\n    history.rgb = VXAAClampHistory( history.rgb, currN );\n   \n    \n    // Temporal checkerboard upsample pass.\n    vec4 vtex[4];\n    VXAAUpsampleT4x( vtex, current, history, currN, histN );\n    \n    // Average all samples.\n    fragColor = ( vtex[VXAA_NW] + vtex[VXAA_NE] + vtex[VXAA_SW] + vtex[VXAA_SE] ) * 0.25f;\n    //if( iMouse.x > fragCoord.x ) fragColor = current;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "/*\n\n    Copyright 2020 UAA Software\n\n    Permission is hereby granted, free of charge, to any person obtaining a copy of this software and\n    associated documentation files (the \"Software\"), to deal in the Software without restriction,\n    including without limitation the rights to use, copy, modify, merge, publish, distribute,\n    sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is\n    furnished to do so, subject to the following conditions:\n\n    The above copyright notice and this permission notice shall be included in all copies or substantial\n    portions of the Software.\n\n    THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT\n    NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES\n    OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n    CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n*/\n\n#define VXAA_TEXTURE_CURRENT iChannel1\n#define VXAA_TEXTURE_PREV iChannel2\n\n#define VXAA_TEMPORALEDGE_THRES 0.05\n#define VXAA_TEMPORALEDGE_TIME_MIN 0.0000001\n#define VXAA_TEMPORALEDGE_TIME_MAX 1.15\n#define VXAA_SPATIAL_FLICKER_TIME 2.35\n#define VXAA_MORPHOLOGICAL_STRENGTH 0.42\n#define VXAA_MORPHOLOGICAL_SHARPEN 0.13\n\n#define VXAA_W 0\n#define VXAA_E 1\n#define VXAA_N 2\n#define VXAA_S 3\n#define VXAA_NW 0\n#define VXAA_NE 1\n#define VXAA_SW 2\n#define VXAA_SE 3\n\nfloat saturate( float x )\n{\n    return clamp( x, 0.0, 1.0 );\n}\n\nvec4 pow3( vec4 x, float y )\n{\n    return vec4( pow( x.x, y ), pow( x.y, y ), pow( x.z, y ), x.w );\n}\n\nfloat VXAALuma( vec3 c )\n{\n    return dot( c, vec3( 0.2126, 0.7152, 0.0722 ) );\n}\n\nfloat VXAALumaDiff( vec3 x, vec3 y )\n{\n    float l1 = dot( x, vec3( 0.2126, 0.7152, 0.0722 ) );\n    float l2 = dot( y, vec3( 0.2126, 0.7152, 0.0722 ) );\n    return abs( l1 - l2 );\n}\n\nfloat VXAATemporalContrast( float currentLuma, float historyLuma )\n{\n    float x = saturate( abs( historyLuma - currentLuma ) - VXAA_TEMPORALEDGE_THRES );\n    float x2 = x * x, x3 = x2 * x;\n    return saturate( 3.082671957671837 * x - 3.9384920634917364 * x2 + 1.8518518518516354 * x3 );\n}\n\nfloat VXAAMorphStrengthShaper( float x )\n{\n    return 1.3 * x - 0.3 * x * x;\n}\n\nfloat VXAASpatialContrast( vec2 spatialLumaMinMax )\n{\n    float spatialContrast = spatialLumaMinMax.y - spatialLumaMinMax.x;\n    return mix( 0.0f, 1.0f, spatialContrast );\n}\n\nfloat VXAATemporalFilterAlpha( float fpsRcp, float convergenceTime )\n{\n    return exp( -fpsRcp / convergenceTime );\n}\n\nvec3 VXAAClampHistory( vec3 history, vec4 currN[4] )\n{\n    vec3 cmin = min( min( currN[0].rgb, currN[1].rgb ), min( currN[2].rgb, currN[3].rgb ) );\n    vec3 cmax = max( min( currN[0].rgb, currN[1].rgb ), max( currN[2].rgb, currN[3].rgb ) );\n    return vec3(\n        clamp( history.r, cmin.r, cmax.r ),\n        clamp( history.g, cmin.g, cmax.g ),\n        clamp( history.b, cmin.b, cmax.b )\n    );\n}\n\nvec4 VXAASharpen( vec4 history, vec4 histN[4] )\n{\n    vec4 nh = histN[VXAA_NW] + histN[VXAA_NE] + histN[VXAA_SW] + histN[VXAA_SE];\n    return mix( history, history * 5.0f - nh, VXAA_MORPHOLOGICAL_SHARPEN );\n}\n\nvec4 VXAAMorphological( vec2 uv, vec4 current, vec4 currN[4], float strength )\n{\n    if ( strength < 0.1f ) return current;\n    float lumaNW = currN[VXAA_NW].a, lumaNE = currN[VXAA_NE].a,\n        lumaSW = currN[VXAA_SW].a, lumaSE = currN[VXAA_SE].a;\n    lumaNE += 0.0025;\n    float lumaMin = min( current.a, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\n    float lumaMax = max( current.a, max( max( lumaNW, lumaNE ), max( lumaSW, lumaSE ) ) );\n    \n    vec2 dir;\n    dir.x = ( lumaSW - lumaNE ) + ( lumaSE - lumaNW );\n    dir.y = ( lumaSW - lumaNE ) - ( lumaSE - lumaNW );\n    vec2 dirN = normalize( dir );\n    \n    vec4 n1 = texture( VXAA_TEXTURE_CURRENT, uv - dirN * strength / iResolution.xy );\n    vec4 p1 = texture( VXAA_TEXTURE_CURRENT, uv + dirN * strength / iResolution.xy );\n    return ( n1 + p1 ) * 0.5;\n}\n\nvec4 VXAAFilmic( vec2 uv, vec4 current, vec4 history, vec4 currN[4], vec4 histN[4] )\n{\n    // Temporal contrast weight.\n    float temporalContrastWeight = VXAATemporalContrast( current.a, history.a );\n\n    // Spatial contrast weight.\n    vec2 spatialLumaMinMaxC = vec2(\n        min( min( currN[0].a, currN[1].a ), min( currN[2].a, currN[3].a ) ),\n        max( max( currN[0].a, currN[1].a ), max( currN[2].a, currN[3].a ) )\n    );\n    vec2 spatialLumaMinMaxH = vec2(\n        min( min( histN[0].a, histN[1].a ), min( histN[2].a, histN[3].a ) ),\n        max( max( histN[0].a, histN[1].a ), max( histN[2].a, histN[3].a ) )\n    );\n    float spatialContrastWeightC = VXAASpatialContrast( spatialLumaMinMaxC );\n    float spatialContrastWeightH = VXAASpatialContrast( spatialLumaMinMaxH );\n    float spatialContrastWeight = abs( spatialContrastWeightC - spatialContrastWeightH );\n    \n    // Evaluate convergence time from weights.\n    float convergenceTime = mix( VXAA_TEMPORALEDGE_TIME_MIN, VXAA_TEMPORALEDGE_TIME_MAX, temporalContrastWeight );\n    convergenceTime = mix( convergenceTime, VXAA_SPATIAL_FLICKER_TIME, spatialContrastWeight );\n    float alpha = VXAATemporalFilterAlpha( iTimeDelta, convergenceTime );\n    \n    // Apply morpholigical AA filter and sharpen.\n    float strength = VXAAMorphStrengthShaper( spatialContrastWeightC * 4.0 ) * VXAA_MORPHOLOGICAL_STRENGTH;\n    current = VXAAMorphological( uv, current, currN, strength );\n    current = VXAASharpen( current, currN );\n    \n    // Clamp history to neighbourhood, and apply filmic blend.\n    history.rgb = VXAAClampHistory( history.rgb, currN );\n    current = mix( current, history, alpha );\n    return current;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // Sample scene and neighbourhood.\n    \n    vec4 current = clamp( vec4( texture( VXAA_TEXTURE_CURRENT, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    vec4 history = clamp( vec4( texture( VXAA_TEXTURE_PREV, uv ).rgb, 1.0 ), vec4( 0.0f ), vec4( 1.0f ) );\n    current.a = VXAALuma( current.rgb ); history.a = VXAALuma( history.rgb );\n    \n    vec4 currN[4];\n    currN[VXAA_NW] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2( -1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_NE] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2(  1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_SW] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2( -1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_SE] = clamp( texture( VXAA_TEXTURE_CURRENT, uv + 0.6f * vec2(  1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    currN[VXAA_NW].a = VXAALuma( currN[VXAA_NW].rgb );\n    currN[VXAA_NE].a = VXAALuma( currN[VXAA_NE].rgb );\n    currN[VXAA_SW].a = VXAALuma( currN[VXAA_SW].rgb );\n    currN[VXAA_SE].a = VXAALuma( currN[VXAA_SE].rgb );\n    \n    vec4 histN[4];\n    histN[VXAA_NW] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2( -1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_NE] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2(  1.0f,  1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_SW] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2( -1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_SE] = clamp( texture( VXAA_TEXTURE_PREV, uv + 0.6f * vec2(  1.0f, -1.0f ) / iResolution.xy ), vec4( 0.0f ), vec4( 1.0f ) );\n    histN[VXAA_NW].a = VXAALuma( histN[VXAA_NW].rgb );\n    histN[VXAA_NE].a = VXAALuma( histN[VXAA_NE].rgb );\n    histN[VXAA_SW].a = VXAALuma( histN[VXAA_SW].rgb );\n    histN[VXAA_SE].a = VXAALuma( histN[VXAA_SE].rgb );\n    \n    \n    // Filmic pass.    \n    fragColor = VXAAFilmic( uv, current, history, currN, histN );\n    //if( iMouse.x > fragCoord.x ) fragColor = current;\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "/**\n* Creative Commons CC0 1.0 Universal (CC-0)\n*\n* A basic TAA implementation based on the variance clipping technique by Marco Salvi (Nvidia).\n*\n*/\n\n#define TEXTURE_CURRENT iChannel2\n#define TEXTURE_PREV iChannel3\n\nconst ivec2 offsets[8u] = ivec2[]\n(\n    ivec2(-1,-1), ivec2(-1, 1), \n\tivec2(1, -1), ivec2(1, 1), \n\tivec2(1, 0),  ivec2(0, -1), \n\tivec2(0, 1),  ivec2(-1, 0)\n);\n\nconst float gaussian[8u] = float[]\n(\n    .0625, .0625,\n    .0625, .0625,\n    .125,  .125,\n    .125,  .125\n);\n\nvec3 RGBToYCoCg(vec3 RGB)\n{\n    float Y = dot(RGB, vec3(1, 2,  1))  * .25;\n    float Co= dot(RGB, vec3(2, 0, -2))  * .25 + (.5 * 256./255.);\n    float Cg= dot(RGB, vec3(-1, 2, -1)) * .25 + (.5 * 256./255.);\n    return vec3(Y, Co, Cg) * (1. / (1. + Y)); // tonemap\n}\n\nvec3 YCoCgToRGB(vec3 YCoCg)\n{\n    YCoCg *= 1. / (1. - YCoCg.x); // tonemap\n\tfloat Y= YCoCg.x;\n\tfloat Co= YCoCg.y - (.5 * 256. / 255.);\n\tfloat Cg= YCoCg.z - (.5 * 256. / 255.);\n\tfloat R= Y + Co - Cg;\n\tfloat G= Y + Cg;\n\tfloat B= Y - Co - Cg;\n\treturn vec3(R, G, B);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec3 currentBuffer = RGBToYCoCg(textureLod(TEXTURE_CURRENT, uv, 0.).rgb);\n    vec3 historyBuffer = RGBToYCoCg(textureLod(TEXTURE_PREV, uv, 0.).rgb);\n\n    vec3 mean = currentBuffer;\n    vec3 variance = currentBuffer * currentBuffer;\n    vec3 filtered = currentBuffer * .25;\n    \n    // Marco Salvi's Implementation (by Chris Wyman)\n    for(int i = 0; i < 8; i++)\n    {\n        vec3 neighborTexel = RGBToYCoCg(texelFetch(TEXTURE_CURRENT, ivec2(fragCoord.xy) + offsets[i], 0).rgb);\n        mean += neighborTexel;\n        variance += neighborTexel * neighborTexel;\n        filtered += neighborTexel * gaussian[i];\n    }\n    \n    mean /= 9.;\n    variance /= 9.;\n    const float stDevMultiplier = 1.5;\n\tvec3 sigma = sqrt(abs(variance - mean * mean));\n\tvec3 colorMin = min(filtered, mean - stDevMultiplier * sigma);\n\tvec3 colorMax = max(filtered, mean + stDevMultiplier * sigma);\n    \n    historyBuffer = clamp(historyBuffer, colorMin, colorMax);\n    \n    vec3 outColor = mix(historyBuffer, filtered, .05);\n\n\tfragColor = vec4(YCoCgToRGB(outColor), 1.);\n    \n    fragColor = clamp(fragColor,0.,1.);\n}\n\n", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McGGz1.jpg", "time_retrieved": "2024-04-28T18:59:19.476980", "access": "api", "wgpu-test": "incomplete"}
{"id": "4fyGWR", "name": "Unreal Engine 1 Texture Filter", "author": "peterekepeter", "description": "This is a reimplementation of the unreal engine 1 software texture filtering.\nUse mouse to move around, pause the shader to stop the animation.\nHold left click to switch to nearest filtering.", "tags": ["2d", "texture", "filter"], "image_code": "\n// The trick is to use nearest sampling but to offset the texel fetch using the screen space pixel.\n// This is still 1 texel fetch per pixel so it's next to 0 cost to do this even on a CPU\n// With GPU this is easily replimeneted in a GPU shader\n// For shadertoy I'm using texelFetch so that I bypass the default filtering\nvec3 textureWithUnreal1SoftwareFiltering(vec2 uv, vec2 fragCoord, bool bFilter)\n{\n    ivec2 pcoord = ivec2(fragCoord);\n    pcoord.x&=1;\n    pcoord.y&=1;\n   \n    vec2 offset=vec2(\n        pcoord.yx*ivec2(2,2)\n        +pcoord.xy*ivec2(1,-1)\n    )*0.25\n    + vec2(-0.125-0.25,-0.125);\n    \n    if (!bFilter) offset *= vec2(0);\n    \n    vec2 fcoord = mod(uv + offset, iChannelResolution[0].xy); \n    int lod = 0;\n    vec3 col = texelFetch(iChannel0, ivec2(fcoord), lod).xyz;\n    return col;\n}\n\nmat2 rotate(float a) { \n    float c=cos(a);\n    float s=sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    uv.xy-=0.5;\n    uv.xy*=rotate(iTime*0.1);\n    uv = uv*(20.0+sin(iTime)*15.0)+iMouse.xy;\n    \n    bool bFilter = iMouse.z < 0.5; // disable on mouse click\n    \n    vec3 col = textureWithUnreal1SoftwareFiltering(uv, fragCoord, bFilter);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fyGWR.jpg", "time_retrieved": "2024-04-28T18:59:19.788147", "access": "api", "wgpu-test": "ok"}
{"id": "4cV3zm", "name": "Pixel Alphabets", "author": "cmzw", "description": "Pixel alphabets using a 5x5 pixel grid\n\nClick and drag â†” to browse through every glyph", "tags": ["cc0", "fonts", "glyphs", "english", "alphabets"], "image_code": "// Pixel Alphabets - License: CC0\n\n#define GLYPH_SCALE .9\n#define GRID_SCALE 4.\n\n// #define OFFSET_ROWS\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += iDate.z;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat p(vec2 uv, int i) {\n    float ic = float(i);\n\tvec2 gr = 1.0 - abs(uv*7.-0.5 - vec2(mod(ic,7.), floor(ic/7.)));\n\treturn smoothstep(0.25, 0.5, min(gr.x,gr.y));\n}\n\nfloat b(int n, int b) { return float(mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0); }\n\nfloat pa(vec2 uv, int g) {\n\tconst ivec3 n[] = ivec3[](\n\t\tivec3(0x9F00, 0x27C8, 0x0112),\n        ivec3(0x8F00, 0x27C8, 0x00F2),\n        ivec3(0x9F00, 0x2040, 0x01F0),\n        ivec3(0x8F00, 0x2448, 0x00F2),\n        ivec3(0x9F00, 0x27C0, 0x01F0),\n        ivec3(0x9F00, 0x27C0, 0x0010),\n        ivec3(0x9F00, 0x2340, 0x01F2),\n        ivec3(0x9100, 0x27C8, 0x0112),\n        ivec3(0x1F00, 0x8102, 0x01F0),\n        ivec3(0x1F00, 0x2204, 0x00F1),\n        ivec3(0x9100, 0x21C4, 0x0111),\n        ivec3(0x8100, 0x2040, 0x01F0),\n        ivec3(0x9100, 0x254D, 0x0112),\n        ivec3(0x9100, 0x2549, 0x0113),\n        ivec3(0x9F00, 0x2448, 0x01F2),\n        ivec3(0x9F00, 0x27C8, 0x0010),\n        ivec3(0x9F00, 0x2548, 0x0171),\n        ivec3(0x9F00, 0xA7C8, 0x0190),\n        ivec3(0x9F00, 0x07C0, 0x01F2),\n        ivec3(0x1F00, 0x8102, 0x0040),\n        ivec3(0x9100, 0x2448, 0x01F2),\n        ivec3(0x9100, 0x4448, 0x0041),\n        ivec3(0x9100, 0xA548, 0x00A2),\n        ivec3(0x1100, 0x4105, 0x0111),\n        ivec3(0x1100, 0x8105, 0x0040),\n        ivec3(0x1F00, 0x4104, 0x01F0)\t\n\t);\n\t\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tr = max(r, p(uv, i   )*b(n[g].x,i));\n\t\tr = max(r, p(uv, i+16)*b(n[g].y,i));\n\t\tr = max(r, p(uv, i+32)*b(n[g].z,i));\n\t}\n\treturn r;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = vec2(1,-1) * (2.*I - iResolution.xy) / iResolution.y;\n    vec2 grid = ( uv + vec2(iTime*0.05,0.0))*GRID_SCALE;\n    \n    #ifdef OFFSET_ROWS\n    grid -= vec2(mod(floor(grid).y,2.0)*0.5,0.0);\n    #endif\n    \n    float glyph = pa(1.0/GLYPH_SCALE*(fract(grid)-0.5)+0.5,\n        int(hash12(floor(grid))*26.));\n\n    if(iMouse.z > 0.)\n        glyph = pa(uv*0.5 + .5,int(iMouse.x/iResolution.x*26.));\n\n    O = vec4(glyph);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cV3zm.jpg", "time_retrieved": "2024-04-28T18:59:19.825048", "access": "api", "wgpu-test": "error"}
{"id": "4fyGz1", "name": "Rounded boxes comparison 3D", "author": "iq", "description": "Comparing different corner shapes to achieve rounded boxes. Only the Cosine and the Cubic produce C2 continuous surfaces, which you can see by a smooth lighting transition. See [url]https://www.shadertoy.com/view/4cG3R1[/url] for a 2D version. ", "tags": ["3d", "sdf", "squircle", "superellipse", "roundedbox", "roundedbox"], "image_code": "// The MIT License\n// Copyright Â© 2024 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n// Comparing different corner shapes to achieve rounded boxes\n// (motivated by https://www.shadertoy.com/view/lcyGRz). Here\n// I show a Circle, Parabola, Cosine and Cubic corner shapes.\n// Skipped hyperbola in this example, it doesn't help really.\n// But Superellipse is given for convenience even though it's\n// not a rounded box.\n//\n// Note how only the Cosine and the Cubic produce C2 continuous\n// surfaces (and the Superellipse), whilc the Circle and Parabola\n// do not.\n//\n// See https://www.shadertoy.com/view/4cG3R1 for a 2D version.\n\n// 0: persp angled camera\n// 1: ortho aligned camera\n#define CAMERA 0\n\n\nfloat sdCornerCircle( in vec2 uv )\n{\n    return length(uv-vec2(0.0,-1.0)) - sqrt(2.0);\n}\n\nfloat sdCornerParabola( in vec2 uv )\n{\n    // https://www.shadertoy.com/view/ws3GD7\n    float y = (0.5 + uv.y)*(2.0/3.0);\n    float h = uv.x*uv.x + y*y*y;\n    float w = pow( uv.x + sqrt(abs(h)), 1.0/3.0 );\n    float x = w - y/w;\n    vec2  q = vec2(x,0.5*(1.0-x*x));\n    return length(uv-q)*sign(uv.y-q.y);\n}\n\nfloat sdCornerCosine( in vec2 uv )\n{\n    // https://www.shadertoy.com/view/3t23WG\n    const float kPI = 3.1415927;\n    uv *= (3.1415927/2.0);\n\n    float ta = 0.0, tb = kPI/2.0;\n    for( int i=0; i<8; i++ )\n    {\n        float t = 0.5*(ta+tb);\n        float y = t-uv.x+sin(t)*(uv.y-cos(t));\n        if( y<0.0 ) ta = t; else tb = t;\n    }\n    vec2  qa = vec2(ta,cos(ta)), qb = vec2(tb,cos(tb));\n    vec2  pa = uv-qa, di = qb-qa;\n    float h = clamp( dot(pa,di)/dot(di,di), 0.0, 1.0 );\n    return length(pa-di*h) * sign(pa.y*di.x-pa.x*di.y) / (3.1415927/2.0);\n}\n\nfloat sdCornerCubic( in vec2 uv )\n{\n    float ta = 0.0, tb = 1.0;\n    for( int i=0; i<12; i++ )\n    {\n        float t = 0.5*(ta+tb);\n        float c = (t*t*(t-3.0)+2.0)/3.0;\n        float dc = t*(t-2.0);\n        float y = (uv.x-t) + (uv.y-c)*dc;\n        if( y>0.0 ) ta = t; else tb = t;\n    }\n    vec2  qa = vec2(ta,(ta*ta*(ta-3.0)+2.0)/3.0);\n    vec2  qb = vec2(tb,(tb*tb*(tb-3.0)+2.0)/3.0);\n    vec2  pa = uv-qa, di = qb-qa;\n    float h = clamp( dot(pa,di)/dot(di,di),0.0,1.0 );\n    return length(pa-di*h) * sign(pa.y*di.x-pa.x*di.y);\n}\n\nfloat sdRoundBox(in vec2 p, in vec2 b, in vec4 r, int type)\n{\n    // select corner radius\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n\n    // box coordinates\n    vec2 q = abs(p)-b+r.x;\n    \n    // distance to sides\n    if( min(q.x,q.y)<0.0 ) return max(q.x,q.y)-r.x;\n\n    // rotate 45 degrees, offset by r and scale by r*sqrt(0.5)\n    // to canonical corner coordinates\n    vec2 uv = vec2( abs(q.x-q.y), q.x+q.y-r.x )/r.x;\n\n    // compute distance to corner shape\n    float d;\n         if( type==0 ) d = sdCornerCircle( uv );\n    else if( type==1 ) d = sdCornerParabola( uv );\n    else if( type==2 ) d = sdCornerCosine( uv );\n    else if( type==3 ) d = sdCornerCubic( uv );\n    // undo scale\n    return d * r.x*sqrt(0.5);\n}\n\n// note this approximation is really bad, do not use in production\nfloat approx_sdSquircle(vec2 p, vec2 s, float n)\n{\n    p = abs(p);\n    float w = pow(p.x/s.x,n) + pow(p.y/s.y,n);\n    float b = 2.0*n-2.0;\n    float a = 1.0-1.0/n;\n    float c = 2.0*n;\n    return (w-pow(w,a)) * inversesqrt( pow(p.x,b)/pow(s.x,c) + pow(p.y,b)/pow(s.y,c) );\n}\n\n// https://www.shadertoy.com/view/4lyfzw\nfloat extrude( in float d, float z, in float h ) \n{\n    vec2 q = vec2(d,abs(z)-h);\n    float ma = min(q.x,q.y);\n    float di = max(q.x,q.y);\n    return min(di,0.0) + length(max(q,0.0));\n}\n\nfloat map( in vec3 p, int type )\n{\n    // 2d shape\n    vec2 b = vec2(0.9,0.5);\n    vec4 r = vec4(0.3);\n    float d;\n    if( type<4 )\n    {\n        // normalize radii, usually NOT needed, here just for demo purposes\n        #if 1\n        const float kNorm[4] = float[4]( sqrt(2.0)-1.0, 1.0/2.0, 2.0/3.1415927, 2.0/3.0 );\n        r = r*kNorm[type]/kNorm[0]; \n        #endif\n        d = sdRoundBox( p.xz, b, r, type );\n    }\n    else\n    {\n        d = approx_sdSquircle(p.xz,b,6.0);\n    }\n\n    // extrude\n    #if CAMERA==0\n    const float ex = 0.4;\n    #else\n    const float ex = 1.0;\n    #endif\n    return extrude( d, p.y, ex );\n}\n\n// https://iquilezles.org/articles/normalsSDF\nvec3 calcNormal( in vec3 pos, int type )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.00025;\n    return normalize( e.xyy*map( pos + e.xyy*eps, type ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps, type ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps, type ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps, type ) );\n}\n\nfloat print( in float sdf, inout vec2 p, in int str[12])\n{\n    if( p.y<0.0|| p.y>1.0 ) return sdf;\n    float d = 1e20;\n    for( int i=0; i<str.length(); i++ )\n    {\n        int c = str[i];\n        if( c==0 ) break;\n        if( p.x>0.0 && p.x<1.0 )\n        {\n            vec2 q = p/16.0;\n            d = min(d,textureGrad( iChannel0, vec2(c,15-c/16)/16.0+q, dFdx(q), dFdy(q) ).w);\n        }\n        p.x -= 0.5;\n    }\n    return min(d,sdf);\n}\n\nfloat shapeName( int type, in vec2 q )\n{\n    float text = 1e20;\n          if( type==0 )  text = print(text,q,int[12](67,105,114, 99,108,101,  0,  0,  0,  0,  0,  0));\n    else  if( type==1 )  text = print(text,q,int[12](80, 97,114, 97, 98,111,108, 97,  0,  0,  0,  0));\n    else  if( type==2 )  text = print(text,q,int[12](67,111,115,105,110,101,  0,  0,  0,  0,  0,  0));\n    else  if( type==3 )  text = print(text,q,int[12](67,117, 98,105, 99,  0,  0,  0,  0,  0,  0,  0));\n    else/*if( type==4 )*/text = print(text,q,int[12](83,117,112,101,114,101,108,108,105,112,115,101));\n    return text;\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #if CAMERA==0\n    int type = int( iTime/2.0 ) % 5;\n    // camera movement\t\n\tfloat an = 1.0;//0.5*(iTime-10.0);\n\tvec3 ro = 3.0*vec3( 1.0*sin(an), 0.3, 1.0*cos(an) );\n    vec3 ta = vec3( 0.0, -0.15, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    #else\n    float py = fragCoord.y/iResolution.y;\n    int type = int( floor(5.0*py) );\n    #endif\n\n    // render    \n    vec3 tot = vec3(0.0);\n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        #if CAMERA==0\n        vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n        #else\n        vec3 ro = vec3( p*0.75, 3.0 );\n        vec3 rd = vec3( 0.0, 0.0, -1.0 );\n        #endif\n\n        // raymarch from t=2 to t=5\n        const float tmin = 2.0;\n        const float tmax = 5.0;\n        float t = tmin;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos, type);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n        \n        // shading/lighting\t\n        vec3 col = vec3(0.0);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos, type);\n\n            // material\n            vec3 mate = vec3(0.25); //vec3 mate = (0.5+0.5*nor.xyz)*(0.5+0.5*nor.zxy);\n            #if CAMERA==0\n            const float ks = 0.5;\n            #else\n            const float ks = 0.5;\n            #endif\n            \n            // ambient light\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,1.0,0.0));\n            col = mate*vec3(0.2,0.3,0.4)*amb;\n            // key light\n            vec3 lig = normalize(vec3(1.0,0.3,0.2));\n            vec3 hal = normalize(lig-rd);\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            float spe = clamp( dot(nor,hal), 0.0, 1.0 );\n            col += mate*vec3(0.85,0.75,0.65)*dif;\n            col += ks*pow(spe,8.0)*dif;\n        }\n\n        // gamma (before accumulation/filtering)\n        col = pow( col, vec3(0.4545) );\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    \n    // grid lines\n    #if CAMERA==1\n    tot *= 1.0-smoothstep(0.95,1.0,abs(2.0*fract(py*5.0)-1.0));\n    #endif\n    \n    // draw text\n    {\n        vec2 p = fragCoord/iResolution.y;\n    \n        #if CAMERA==0\n        const float text_scale = 0.075;\n        vec2 q = (p-vec2(0.05,0.05))/text_scale;\n        float text = shapeName( type, q );\n        tot = mix(tot,vec3(1.0),1.0-smoothstep(-0.01,0.01,text-0.5));\n        #else\n        const float text_scale = 0.05;\n        p.y -= 0.35/5.0;\n        vec2 q = (p-vec2(0.6,floor(py*5.0)/5.0))/text_scale;\n        \n        float text = shapeName( type, q );\n        tot = mix(tot,vec3(0.0),1.0-smoothstep( 0.06,0.08,text-0.5));\n        tot = mix(tot,vec3(1.0),1.0-smoothstep(-0.01,0.01,text-0.5));\n        #endif\n    }\n\n    // output\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4fyGz1.jpg", "time_retrieved": "2024-04-28T18:59:21.477627", "access": "api", "wgpu-test": "ok"}
{"id": "4cG3R1", "name": "Rounded boxes comparison 2D", "author": "iq", "description": "Comparing different corner shapes to achieve rounded boxes. Only the Cosine and the Cubic produce C2 continuous surfaces. See [url]https://www.shadertoy.com/view/4fyGz1[/url] for a 3D version.", "tags": ["2d", "sdf", "squircle", "superellipse", "roundedbox", "roundedbox"], "image_code": "// The MIT License\n// Copyright Â© 2024 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// https://www.youtube.com/c/InigoQuilez\n// https://iquilezles.org\n\n\n// Comparing different corner shapes to achieve rounded boxes\n// (motivated by https://www.shadertoy.com/view/lcyGRz). Here\n// I show a Circle, Parabola, Cosine and Cubic corner shapes.\n// Skipped hyperbola in this example, it doesn't help really.\n// But Superellipse is given for convenience even though it's\n// not a rounded box.\n//\n// The yellow shade is the laplacian, a measure of the second\n// derivatives. When that's discontinuous so will be lighting\n// on a 3D shape extruded from this. Note how only the Cosine\n// and the Cubic produce C2 continuous surfaces.\n//\n// See https://www.shadertoy.com/view/4fyGz1 for a 3D version.\n//\n// Related:\n//   Rounded Box : https://www.shadertoy.com/view/4llXD7\n//   Squircle    : https://www.shadertoy.com/view/7stcR4\n\n\n\nfloat sdCornerCircle(   in vec2 p ); // c(t) = sqrt(2-t^2)-1\nfloat sdCornerParabola( in vec2 p ); // c(t) = (1-t^2)/2\nfloat sdCornerCosine(   in vec2 p ); // c(t) = (2/PI)*cos(t*PI/2)\nfloat sdCornerCubic(    in vec2 p ); // c(t) = (t^3-3t^2+2)/3\n\nfloat sdRoundBox( in vec2 p, in vec2 b, in vec4 r, in int type )\n{\n    // select corner radius\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    // box coordinates\n    vec2 q = abs(p)-b+r.x;\n    // distance to sides\n    if( min(q.x,q.y)<0.0 ) return max(q.x,q.y)-r.x;\n    // rotate 45 degrees, offset by r and scale by r*sqrt(0.5) to canonical corner coordinates\n    vec2 uv = vec2( abs(q.x-q.y), q.x+q.y-r.x )/r.x;\n    // compute distance to corner shape\n    float d;\n         if( type==0 ) d = sdCornerCircle( uv );\n    else if( type==1 ) d = sdCornerParabola( uv );\n    else if( type==2 ) d = sdCornerCosine( uv );\n    else if( type==3 ) d = sdCornerCubic( uv );\n    // undo scale\n    return d * r.x*sqrt(0.5);\n}\n\nfloat sdCornerCircle( in vec2 p )\n{\n    return length(p-vec2(0.0,-1.0)) - sqrt(2.0);\n}\n\nfloat sdCornerParabola( in vec2 p )\n{\n    // https://www.shadertoy.com/view/ws3GD7\n    float y = (0.5 + p.y)*(2.0/3.0);\n    float h = p.x*p.x + y*y*y;\n    float w = pow( p.x + sqrt(abs(h)), 1.0/3.0 ); // note I allow a tiny error in the very interior of the shape so that I don't have to branch into the 3 root solution\n    float x = w - y/w;\n    vec2  q = vec2(x,0.5*(1.0-x*x));\n    return length(p-q)*sign(p.y-q.y);\n}\n\nfloat sdCornerCosine( in vec2 uv )\n{\n    // https://www.shadertoy.com/view/3t23WG\n    const float kPI = 3.1415927;\n    uv *= (3.1415927/2.0);\n\n    float ta = 0.0, tb = kPI/2.0;\n    for( int i=0; i<8; i++ )\n    {\n        float t = 0.5*(ta+tb);\n        float y = t-uv.x+sin(t)*(uv.y-cos(t));\n        if( y<0.0 ) ta = t; else tb = t;\n    }\n    vec2  qa = vec2(ta,cos(ta)), qb = vec2(tb,cos(tb));\n    vec2  pa = uv-qa, di = qb-qa;\n    float h = clamp( dot(pa,di)/dot(di,di), 0.0, 1.0 );\n    return length(pa-di*h) * sign(pa.y*di.x-pa.x*di.y) / (3.1415927/2.0);\n}\n\nfloat sdCornerCubic( in vec2 uv )\n{\n    float ta = 0.0, tb = 1.0;\n    for( int i=0; i<12; i++ )\n    {\n        float t = 0.5*(ta+tb);\n        float c = (t*t*(t-3.0)+2.0)/3.0;\n        float dc = t*(t-2.0);\n        float y = (uv.x-t) + (uv.y-c)*dc;\n        if( y>0.0 ) ta = t; else tb = t;\n    }\n    vec2  qa = vec2(ta,(ta*ta*(ta-3.0)+2.0)/3.0);\n    vec2  qb = vec2(tb,(tb*tb*(tb-3.0)+2.0)/3.0);\n    vec2  pa = uv-qa, di = qb-qa;\n    float h = clamp( dot(pa,di)/dot(di,di),0.0,1.0 );\n    return length(pa-di*h) * sign(pa.y*di.x-pa.x*di.y);\n}\n\nfloat approx_sdSuperEllipse( vec2 p, vec2 b, vec4 r )\n{\n    // select corner radius\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    \n    float n = r.x;\n    \n    p = abs(p);\n    \n    #if 0\n        // cheap linearliation of the basic implicit formula\n        n = 2.0/n;\n        float w = pow(p.x/b.x,n) + pow(p.y/b.y,n);\n        float kb = 2.0*n - 2.0;\n        float ka = 1.0-1.0/n;\n        float kc = 2.0*n;\n        return (w-pow(w,ka)) * inversesqrt( pow(p.x,kb)/pow(b.x,kc) + pow(p.y,kb)/pow(b.y,kc) );\n    #else\n        // bisection root finder for distance minimizer\n        float xa = 0.0, xb = 6.283185/4.0;\n        if( p.x-b.x>p.y-b.y ) xb*=0.5; // hack for interior distances, still wrong\n        for( int i=0; i<12; i++ ) \n        {\n            float x = 0.5*(xa+xb);\n            float c = cos(x);\n            float s = sin(x);\n            float cn = pow(c,n);\n            float sn = pow(s,n);\n            float y = (p.x-b.x*cn)*b.x*cn*s*s - (p.y-b.y*sn)*b.y*sn*c*c;\n            if( y<0.0 ) xa = x; else xb = x;\n        }\n        vec2  qa = b*pow(vec2(cos(xa),sin(xa)),vec2(n));\n        vec2  qb = b*pow(vec2(cos(xb),sin(xb)),vec2(n));\n        vec2  pa = p-qa, ba = qb-qa;\n        float h = clamp( dot(pa,ba)/dot(ba,ba),0.0,1.0);\n        return length( pa - ba*h ) * sign(pa.x*ba.y-pa.y*ba.x);\n    #endif\n}\n\nconst float kNorm[4] = float[4]( sqrt(2.0)-1.0, 1.0/2.0, 2.0/3.1415927, 2.0/3.0 );\nfloat map( in vec2 p, in int type )\n{\n\tvec2 si = vec2(1.2,0.6);\n    vec4 ra = vec4(0.42,0.05,0.3,0.2);\n    \n    // normalize radii, usually NOT needed, here just for demo purposes\n    #if 1\n    if( type<4 ) ra *= kNorm[type]/kNorm[0]; \n    #endif\n\n    return (type==4) ? approx_sdSuperEllipse( p, si, ra) : \n                       sdRoundBox( p, si, ra, type );\n}\n\n/*\nfloat lapRoundBox( in vec2 p, in vec2 b, in vec4 r, int type )\n{\n    r.xy = (p.x>0.0)?r.xy : r.zw;\n    r.x  = (p.y>0.0)?r.x  : r.y;\n    vec2 q = abs(p)-b+r.x;\n    if( min(q.x,q.y)<0.0 ) return 0.0;\n    vec3 uv = vec2( abs(q.x-q.y), q.x+q.y-r.x )/r.x;\n    \n    float l;\n         if( type==0 ) l = inversesqrt(uv.x*uv.x+(uv.y+1.0)*(uv.y+1.0));\n    else if( type==1 ) l = 0.0; // TODO\n    else if( type==2 ) l = 0.0; // TODO\n    else if( type==3 ) l = 0.0; // TODO\n\n    return l/r.x/sqrt(0.5);  // note laplacian is rotational invariant, we only need to take care of scale\n}\n\nfloat calcLaplacian( in vec2 p, int type )\n{\n\tconst vec2 si = vec2(1.2,0.6);\n    const vec4 ra = vec4(0.42,0.05,0.3,0.2);\n    return (type==4) ? approx_sdSuperEllipse( p, si, ra) : \n                       lapRoundBox( p, si, ra, type );\n}\n*/\n\nfloat print( in float sdf, inout vec2 p, in int str[12] )\n{\n    if( p.y<0.0|| p.y>1.0 ) return sdf;\n    float d = 1e20;\n    for( int i=0; i<str.length(); i++ )\n    {\n        int c = str[i];\n        if( c==0 ) break;\n        if( p.x>0.0 && p.x<1.0 )\n        {\n            vec2 q = p/16.0;\n            d = min(d,textureGrad( iChannel0, vec2(c,15-c/16)/16.0+q, dFdx(q), dFdy(q) ).w);\n        }\n        p.x -= 0.5;\n    }\n    return min(d,sdf);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 m = (2.0*iMouse.xy-iResolution.xy)/iResolution.y;\n\n    int type = int( iTime/2.0 ) % 5;\n    bool showLaplacian = (int( iTime/10.0) & 1 ) == 1;\n\n    // compute SDF\n\tfloat d = map( p, type );\n\n    // central differenes based laplacian (note skeleton artifacts, could use\n    const vec2 eps = vec2(0.005,0.0);   // true derivatives of autodiff)\n    float laplacian = ( map( p-eps.xy, type ) + \n                        map( p+eps.xy, type ) +\n                        map( p-eps.yx, type ) + \n                        map( p+eps.yx, type ) - 4.0*d )/(eps.x*eps.x);\n                        \n    //laplacian = calcLaplacian( p, type ); // analytical laplacian\n\n    // colors\n    vec3 col = (d>0.0) ? vec3(0.9,0.6,0.3) : vec3(0.65,0.85,1.0);\n    if( showLaplacian ) col.xy += 0.15*abs(laplacian);\n\tcol *= 1.0 - exp(-6.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(150.0*d);\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.01,abs(d)) );\n\n    // mouse interaction\n    if( iMouse.z>0.001 )\n    {\n        d = map(m,type);\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, abs(length(p-m)-abs(d))-0.0025));\n        col = mix(col, vec3(1.0,1.0,0.0), 1.0-smoothstep(0.0, 0.005, length(p-m)-0.015));\n    }\n\n    // draw text\n    {\n        const float text_scale = 0.15;\n        vec2 q = (p-vec2(-0.5,-0.9))/text_scale;\n        float text = 1e20;\n              if( type==0 )  text = print(text,q,int[12](67,105,114, 99,108,101,  0,  0,  0,  0,  0,  0));\n        else  if( type==1 )  text = print(text,q,int[12](80, 97,114, 97, 98,111,108, 97,  0,  0,  0,  0));\n        else  if( type==2 )  text = print(text,q,int[12](67,111,115,105,110,101,  0,  0,  0,  0,  0,  0));\n        else  if( type==3 )  text = print(text,q,int[12](67,117, 98,105, 99,  0,  0,  0,  0,  0,  0,  0));\n        else/*if( type==4 )*/text = print(text,q,int[12](83,117,112,101,114,101,108,108,105,112,115,101));\n        col = mix(col,vec3(0.0),1.0-smoothstep( 0.06,0.08,text-0.5));\n        col = mix(col,vec3(1.0),1.0-smoothstep(-0.01,0.01,text-0.5));\n    }\n\n    // output\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4cG3R1.jpg", "time_retrieved": "2024-04-28T18:59:23.376546", "access": "api", "wgpu-test": "error"}
{"id": "lcVGRm", "name": "Fractal Spaceport", "author": "dr2", "description": "Menger ring based space station", "tags": ["fractal", "space", "menger", "satellite"], "image_code": "// \"Fractal Spaceport\" by dr2 - 2024\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 4.0\n\n// Menger ring based space station\n\n// (Bits from \"Space Elevator\", \"Suborbital Flight\", \"Menger Ring\".)\n\n#define AA  1   // (= 0/1) optional antialiasing\n\n#define VAR_ZERO min (nFrame, 0)\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrTorusDf (vec3 p, float ri, float rc);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nvec2 Rot2D (vec2 q, float a);\nmat3 StdVuMat (float el, float az);\nfloat Noisefv2 (vec2 p);\nfloat Noisefv3 (vec3 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit;\nfloat tCur, dstFar;\nint nFrame, idObj;\nconst float pi = 3.1415927;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q, b;\n  float dMin, d, r, a, rt, objSzFac, nIt, mSclFac;\n  objSzFac = 1./5.;\n  nIt = 3.;\n  mSclFac = 2.2;\n  dMin = dstFar / objSzFac;\n  p /= objSzFac;\n  p.xy = Rot2D (p.xy, -0.2 * pi);\n  p.xz = Rot2D (p.xz, 0.05 * pi * tCur);\n  b = (mSclFac - 1.) * vec3 (1., 1.125, 0.625);\n  rt = 64. / (2. * pi);\n  q = p;\n  r = length (q.xz);\n  a = (r > 0.) ? atan (q.z, - q.x) / (2. * pi) : 0.;\n  q.xz = vec2 (2. * fract (8. * a + 0.5) - 1., r - rt);\n  for (float n = 0.; n < nIt; n ++) {\n    q = abs (q);\n    q.xy = mix (q.xy, q.yx, step (q.x, q.y));\n    q.xz = mix (q.xz, q.zx, step (q.x, q.z));\n    q.yz = mix (q.yz, q.zy, step (q.y, q.z));\n    q = mSclFac * q - b;\n    q.z += b.z * step (q.z, -0.5 * b.z);\n  }\n  d = PrBoxDf (q, vec3 (1.)) / pow (mSclFac, nIt);\n  d = max (PrTorusDf (p.xzy, 0.9, rt), - d);\n  DMINQ (1);\n  q = p;\n  d = PrCylDf (q.xzy, 0.6, 2.2);\n  DMINQ (2);\n  q.y = abs (q.y) - 2.2;\n  d = PrSphDf (q, 0.9);\n  DMINQ (3);\n  q = p;\n  q.xz = Rot2D (q.xz, (0.5 + floor (7. * a)) * (2. * pi / 7.));\n  q.x -= - 0.5 * rt;\n  d = PrCylDf (vec3 (q.z, abs (q.y) - 0.3, q.x), 0.15, 0.5 * rt - 0.8);\n  DMINQ (4);\n  return objSzFac * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = 1e-4 * vec2 (1., -1.);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.05;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.01) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec4 SphHit (vec3 ro, vec3 rd, float rad)\n{\n  vec3 vn;\n  float b, d, w;\n  b = dot (rd, ro);\n  w = b * b + rad * rad - dot (ro, ro);\n  d = dstFar;\n  if (w > 0.) {\n    d = - b - sqrt (w);\n    vn = (ro + d * rd) / rad;\n  }\n  return vec4 (d, vn);\n}\n\nvec3 StarPat (vec3 rd, float scl)\n{\n  vec3 tm, qn, u;\n  vec2 q;\n  float f;\n  tm = -1. / max (abs (rd), 1e-4);\n  qn = - sign (rd) * step (tm.zxy, tm) * step (tm.yzx, tm);\n  u = Maxv3 (tm) * rd;\n  q = atan (vec2 (dot (u.zxy, qn), dot (u.yzx, qn)), vec2 (1.)) / pi;\n  f = 0.57 * (Fbm2 (11. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 131.13 * scl * q) +\n      Fbm2 (13. * dot (0.5 * (qn + 1.), vec3 (1., 2., 4.)) + 171.13 * scl * q.yx));\n  return 8. * vec3 (1., 1., 0.8) * pow (f, 16.);\n}\n\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 dSph4, col4;\n  vec3 col, vn, vnh, roo, mDir, stCol;\n  float dstObj, sh, nDotL, dstGrnd, dstCld, h, s, spRad, clDens, mRad, bs, ts;\n  roo = ro;\n  dstGrnd = dstFar;\n  col = vec3 (0.);\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    if (idObj == 1) {\n      col4 = vec4 (0.8, 0.8, 0.9, 0.1);\n    } else if (idObj == 2) {\n      col4 = mix (vec4 (0.8, 0.8, 0.2, -1.), vec4 (0.85, 0.88, 0.85, 0.1),\n         step (0.2, length (qHit.xz)));\n    } else if (idObj == 3) {\n      col4 = mix (vec4 (0.8, 0.8, 0.2, -1.), vec4 (0.85, 0.88, 0.85, 0.1),\n         step (0.2, length (qHit.xz)));\n      col4 *= 1. - 0.4 * step (0., sin (14. * atan (qHit.z, - qHit.x))) *\n         (1. - step (0.1, abs (qHit.y)));\n    } else if (idObj == 4) {\n      col4 = mix (vec4 (0.8, 0.8, 0.2, -1.), vec4 (0.85, 0.88, 0.85, 0.1),\n         step (0.1, fract (qHit.x - tCur)));\n    }\n    if (col4.a >= 0.) {\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n      nDotL = max (dot (vn, sunDir), 0.);\n      col = col4.rgb * (0.2 + 0.2 * vec3 (0.5, 0.8, 1.) * max (- vn.y, 0.) +\n         0.7 * sh * nDotL * nDotL) + col4.a * vec3 (1., 1., 0.) * step (0.95, sh) *\n         pow (max (dot (reflect (sunDir, vn), rd), 0.), 32.);\n    } else {\n      col = col4.rgb * (0.3 + 0.7 * max (dot (- rd, vn), 0.));\n    }\n  }\n  if (dstObj >= dstFar) {\n    ro = roo;\n    spRad = 200.;\n    dSph4 = SphHit (ro - vec3 (0., - spRad - 5., 0.), rd, spRad);\n    dstGrnd = dSph4.x;\n    if (dstGrnd < dstFar && dstGrnd > 0.) {\n      ro += dstGrnd * rd;\n      vnh = dSph4.yzw;\n      ro.xz += vec2 (0., 0.5 * tCur);\n      h = Fbm2 (vec2 (0.23, 0.2) * ro.xz);\n      vn = VaryNf ((4. - 2. * step (0.45, h)) * ro, vnh, (0.1 + 2.9 * max (h - 0.45, 0.)) *\n         smoothstep (0.03, 0.1, - dot (vnh, rd)));\n      s = Noisefv2 (32. * ro.xz);\n      col4 = vec4 (0., 0.2, 1., 0.3) * (1. - 0.2 * s);\n      col4 = mix (col4, vec4 (0.8, 0.5, 0.2, 0.1) * (1. - 0.1 * s), step (0.45, h));\n      col4 = mix (col4, vec4 (0.4, 0.8, 0.4, 0.1) * (1. - 0.1 * s), smoothstep (0.46, 0.54, h));\n      col4 = mix (col4, vec4 (0.5, 0.7, 0.5, 0.1) * (1. - 0.2 * s), smoothstep (0.6, 0.7, h));\n      col4 = mix (col4, vec4 (1., 1., 1., 0.3) * (1. - 0.2 * s), smoothstep (0.75, 0.8, h));\n      col4.rgb = mix (col4.rgb, vec3 (1., 1., 0.8), 0.2);\n      col4 = mix (vec4 (0.6, 0.6, 0.9, 0.), col4, smoothstep (0.03, 0.1, - dot (vnh, rd)));\n      col4 = mix (vec4 (0.05, 0.05, 0.05, 0.), col4, smoothstep (0., 0.03, - dot (vnh, rd)));\n      col = col4.rgb * (0.2 + 0.8 * max (dot (vn, sunDir), 0.)) +\n         col4.a * pow (max (dot (sunDir, reflect (rd, vn)), 0.), 8.);\n      ro.xz += 0.1 * atan (sunDir.xz, sunDir.yy);\n      clDens = clamp (1.6 * Fbm2 (vec2 (0.4, 0.7) * ro.xz) - 0.4, 0., 1.);\n      col *= 1. - 0.3 * clDens;\n    }\n    ro = roo;\n    spRad = 250.;\n    dSph4 = SphHit (ro - vec3 (0., - spRad - 5., 0.), rd, spRad);\n    dstCld = dSph4.x;\n    if (dstCld < dstFar && dstCld > 0.) {\n      ro += dstCld * rd;\n      vnh = dSph4.yzw;\n      ro.xz += vec2 (0., 0.5 * tCur);\n      clDens = clamp (1.6 * Fbm2 (vec2 (0.4, 0.7) * ro.xz) - 0.4, 0., 1.);\n      col = mix (col, vec3 (1.) * (0.2 + 0.8 * max (dot (vnh, sunDir), 0.)), clDens *\n         smoothstep (0.11, 0.14, - dot (vnh, rd)));\n    }\n  }\n  if (length (col) < 0.03) {\n    mDir = normalize (vec3 (-0.5, -0.02, 0.2));\n    mRad = 0.03;\n    stCol = vec3 (0.02, 0.02, 0.04);\n    bs = dot (rd, mDir);\n    ts = bs * bs - dot (mDir, mDir) + mRad * mRad;\n    if (ts > 0.) {\n      ts = bs - sqrt (ts);\n      if (ts > 0.) {\n        vn = normalize ((ts * rd - mDir) / mRad);\n        stCol += vec3 (1., 0.9, 0.5) * clamp (dot (vec3 (0.5, 0.4, -0.77), vn) *\n           (1. - 0.3 * Noisefv3 (4. * vn)), 0., 1.);\n      }\n    } else stCol += StarPat (rd, 10.);\n    col = mix (col, stCol, step (Maxv3 (col), 0.4 * Maxv3 (stCol)));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  nFrame = iFrame;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  } else {\n    az += 1.1 * pi * SmoothBump (0.25, 0.75, 0.22, fract (0.005 * tCur)) *\n       sign (fract (0.0025 * tCur) - 0.5);\n    el -= 0.15 * pi * cos (0.012 * pi * tCur);\n  }\n  vuMat = StdVuMat (el, az);\n  ro = vuMat * vec3 (0., 0., -15. + 6. * cos (0.015 * pi * tCur));\n  zmFac = 4.;\n  sunDir = normalize (vec3 (1., 0.5, -1.));\n  dstFar = 120.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif\n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float aa = float (VAR_ZERO); aa < naa; aa ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * aa + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrTorusDf (vec3 p, float ri, float rc)\n{\n  return length (vec2 (length (p.xy) - rc, p.z)) - ri;\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (mod (dot (p, cHashVA2) + vec2 (0., cHashVA2.x), 2. * pi)) * cHashM);\n}\n\nvec4 Hashv4v3 (vec3 p)\n{\n  vec3 cHashVA3 = vec3 (37., 39., 41.);\n  return fract (sin (mod (dot (p, cHashVA3) + vec4 (0., cHashVA3.xy, cHashVA3.x + cHashVA3.y),\n     2. * pi)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Noisefv3 (vec3 p)\n{\n  vec4 t;\n  vec3 ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp *= fp * (3. - 2. * fp);\n  t = mix (Hashv4v3 (ip), Hashv4v3 (ip + vec3 (0., 0., 1.)), fp.z);\n  return mix (mix (t.x, t.y, fp.x), mix (t.z, t.w, fp.x), fp.y);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec4 v;\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  for (int j = VAR_ZERO; j < 4; j ++)\n     v[j] = Fbmn (p + ((j < 2) ? ((j == 0) ? e.xyy : e.yxy) : ((j == 2) ? e.yyx : e.yyy)), n);\n  g = v.xyz - v.w;\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0 AND proprietary-license", "thumbnail": "https://www.shadertoy.com/media/shaders/lcVGRm.jpg", "time_retrieved": "2024-04-28T18:59:25.254521", "access": "api", "wgpu-test": "error"}
{"id": "XfVGRm", "name": "Distances to the edge.", "author": "Umbre", "description": "Use the mouse...\nIt doesn't work. It is difficult to maintain distances from a deformed edge. Does anyone know how to do it? I thought the 2d distances and gradients from Inigo Quilez might be helpful, but I don't know how.", "tags": ["voronoi"], "image_code": "vec3 sdgCircle( in vec2 p, in float r ) \n{\n    float d = length(p);\n    return vec3( d-r, p/d );\n}\n\nvec3 sdgBox( in vec2 p, in vec2 b )\n{\n    vec2 w = abs(p)-b;\n    vec2 s = vec2(p.x<0.0?-1:1,p.y<0.0?-1:1);\n    float g = max(w.x,w.y);\n    vec2  q = max(w,0.0);\n    float l = length(q);\n    return vec3(   (g>0.0)?l  :g,\n                s*((g>0.0)?q/l:((w.x>w.y)?vec2(1,0):vec2(0,1))));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    vec2 m = iMouse.xy / iResolution.xy * 2.0 - 1.0;\n    m.x *= iResolution.x/iResolution.y;\n\n    //construction objet1\n    vec2 param1 = vec2(0.26,0.34);\n    vec2 point1 = vec2(-0.19,0.1221);\n    float size1 = -sdgBox(vec2(0.),param1).x;\n    vec3 grad1 = sdgBox(uv-point1,param1);\n    float influence1 = -grad1.x/size1;\n    //construction objet2\n    float param2 = 0.65;\n    vec2 point2 = m;\n    float size2 = -sdgCircle(vec2(0.),param2).x;\n    vec3 grad2 = sdgCircle(uv-point2,param2);\n    float influence2 = -grad2.x/size2;\n    \n    // on trie les objets dans l'ordre d'influence\n    vec2 p1, p2;\n    float s1, s2;\n    vec3 g1, g2;\n    float i1, i2;\n    if(influence1 > influence2)\n    {\n        p1 = point1;\n        s1 = size1;\n        g1 = grad1;\n        i1 = influence1;\n        \n        p2 = point2;\n        s2 = size2; \n        g2 = grad2;\n        i2 = influence2;\n        \n    }\n    else\n    {\n        p2 = point1;\n        s2 = size1;\n        g2 = grad1;\n        i2 = influence1;\n        \n        p1 = point2;\n        s1 = size2; \n        g1 = grad2;\n        i1 = influence2;\n    }\n    \n    //???? \n    vec3 col = vec3(min(i1,1.-i2/i1));\n\n    //coulors :\n    col = cos(30.*clamp(col,0.,1.));\n    if(p1==point1)\n    {\n        col*= vec3(0.8,0.2,0.2);\n    }\n    else\n    {\n        col*= vec3(0.2,0.8,0.8);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfVGRm.jpg", "time_retrieved": "2024-04-28T18:59:25.260506", "access": "api", "wgpu-test": "ok"}
{"id": "XcV3zm", "name": "Fire Oscillo", "author": "orblivius", "description": "glow shader test for effect. Intended to generate a glowing border around n-gons.", "tags": ["glowfire"], "image_code": "// Fork of \"glow shader test\" by remonvv. https://shadertoy.com/view/MdjfRK\n// 2024-04-08 08:52:24\n\n\nfloat rand(vec2 n) {\n    return fract(sin(dot(n, vec2(12.9898,12.1414))) * 83758.5453);\n}\n\nfloat noise(vec2 n) {\n    const vec2 d = vec2(0.0, 1.0);\n    vec2 b = floor(n);\n    vec2 f = mix(vec2(0.0), vec2(1.0), fract(n));\n    return mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\n\nvec3 ramp(float t) {\n\treturn t <= .5 ? vec3( 1. - t * 1.4, .2, 1.05 ) / t : vec3( .3 * (1. - t) * 2., .2, 1.05 ) / t;\n}\n\nfloat fire(vec2 n) {\n    return noise(n) + noise(n * 2.1) * .6 + noise(n * 5.4) * .42;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\t\n    float t = iTime;\n    vec2 uv = fragCoord / iResolution.y;\n    \n    float f = 1. * texture(iChannel0, vec2(.5*uv.x, .75)).r;  \n    uv.y = abs(uv.y - f);\n    uv *= 5.0;\n    \n    float q = fire(vec2(uv.x - t * .013, uv.y  + f - t * .013)) / 2.0;\n    \n \n    vec2 r = vec2(fire(vec2(uv.x + q / 2.0 + t - uv.x - uv.y, uv.y + q / 2.0 + t - uv.x - uv.y - f)), fire(vec2(uv.x + q - t, uv.y + q - t - f))) ;\n   \n    vec3 color = vec3(1.0 / (pow(vec3(0.5, 0.0, .05) + 1.61, vec3(4.0))));\n         \n    float grad = pow((r.y + r.y + f) * max(.0, uv.y) + .05, 1.3);\n\n    color = ramp(grad);\n    color /= (1.50 + max(vec3(0), color));\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcV3zm.jpg", "time_retrieved": "2024-04-28T18:59:25.287433", "access": "api", "wgpu-test": "incomplete"}
{"id": "4fyGzw", "name": "Sunset Cloud Formation", "author": "wyatt", "description": "Sunset", "tags": ["fluid", "physics"], "image_code": "Main {\n    vec4 a = A(U);\n    Q = (.5+a.w)*(.5+.5*sin(-7.+20.*atan(U.x+4.*R.x,U.y+R.y)+vec4(1,2,3,4)));\n    Q += .2*exp(-4.*U.y/R.y);\n    for (float i = 0.; i < 200.; i++) {\n        Q -= .005*Q*pow(A(U-(U-vec2(-.1,.5)*R)*i/200.).w,3.); \n    }\n    Q = atan(2.*Q);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n\n#define Main void mainImage(out vec4 Q, in vec2 U) \n\nuint baseHash(uvec2 p){\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nvec3 hash(vec2 x){\n    uint n = baseHash(floatBitsToUint(x));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n\n#define pi 3.141592659", "buffer_a_code": "vec4 T (vec2 U) {\n    U -= .5*A(U).xy;\n    U -= .5*A(U).xy;\n    U -= .5*A(U).xy;\n    U -= .5*A(U).xy;\n    U -= .5*A(U).xy;\n    U -= .5*A(U).xy;\n    U -= .5*A(U).xy;\n    U -= .5*A(U).xy;\n    return A(U);\n}\nMain {\n\n    Q = T(U);\n    \n    vec4 n = T(U+vec2(0,1));\n    vec4 e = T(U+vec2(1,0));\n    vec4 s = T(U-vec2(0,1));\n    vec4 w = T(U-vec2(1,0));\n    \n    Q.z = 0.25*(n.z+e.z+s.z+w.z+(n.y-s.y+e.x-w.x));\n    Q.xy += .25*vec2(e.z-w.z,n.z-s.z);\n    \n    Q.y -= .001*(.5-Q.w)*abs(.5-Q.w);\n    Q.w *= .9995;\n    Q.xy *= .995;\n    //if (length(U-iMouse.xy)<10.) Q.w = 1.;\n    \n    Q.w += .05*B(U+.5*iTime).x*exp(-100.*abs(U.y-.25*R.y)/R.y)*exp(-3.*abs(U.x-.5*R.x)/R.x);\n    \n    if (U.x<1.||R.x-U.x<1.||U.y<1.||R.y-U.y<1.) Q *= 0.;\n\n}", "buffer_a_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec4 T (vec2 U) {\n    return A(U);\n}\nMain {\n\n    Q = T(U);\n    \n    vec4 n = T(U+vec2(0,1));\n    vec4 e = T(U+vec2(1,0));\n    vec4 s = T(U-vec2(0,1));\n    vec4 w = T(U-vec2(1,0));\n    \n    Q.z = 0.25*(n.z+e.z+s.z+w.z+(n.y-s.y+e.x-w.x));\n    Q.xy += .25*vec2(e.z-w.z,n.z-s.z);\n\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "vec4 T (vec2 U) {\n    return A(U);\n}\nMain {\n\n    Q = T(U);\n    \n    vec4 n = T(U+vec2(0,1));\n    vec4 e = T(U+vec2(1,0));\n    vec4 s = T(U-vec2(0,1));\n    vec4 w = T(U-vec2(1,0));\n    \n    Q.z = 0.25*(n.z+e.z+s.z+w.z+(n.y-s.y+e.x-w.x));\n    Q.xy += .25*vec2(e.z-w.z,n.z-s.z);\n    \n\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "vec4 T (vec2 U) {\n    return A(U);\n}\nMain {\n\n    Q = T(U);\n    \n    vec4 n = T(U+vec2(0,1));\n    vec4 e = T(U+vec2(1,0));\n    vec4 s = T(U-vec2(0,1));\n    vec4 w = T(U-vec2(1,0));\n    \n    Q.z = 0.25*(n.z+e.z+s.z+w.z+(n.y-s.y+e.x-w.x));\n    Q.xy += .25*vec2(e.z-w.z,n.z-s.z);\n    \n\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fyGzw.jpg", "time_retrieved": "2024-04-28T18:59:25.513828", "access": "api", "wgpu-test": "incomplete"}
{"id": "McKGzD", "name": "Channel-independent Game of Life", "author": "pwyr", "description": "Just another simple implementation of Conway's Game of Life.", "tags": ["gameoflife"], "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    fragColor = texture(iChannel0, uv);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Conway's Game of Life\n// ------------------------\n// The rules are the usual but the cellular automaton\n// runs independently on each color channel.\n\nvec4 fetchColor(vec2 coord) {\n    return texelFetch(iChannel0, ivec2(coord), 0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // initialization via texture pixel color quantization\n    if (iFrame == 0 || fetchColor(vec2(0.0)).w < 1.0) {\n        fragColor = vec4(0.0);\n        \n        if (iChannelResolution[1].x > 0.0) {\n            vec2 uv = fragCoord/iResolution.xy;\n            fragColor = vec4(round(texture(iChannel1, uv)).xyz, 1.0);\n        }\n        return;\n    }\n    \n    vec3 ctrColor = fetchColor(fragCoord).xyz;\n    \n    vec3 counts = -ctrColor;\n    for (int i = -1; i <= 1; ++i) {\n        for (int j = -1; j <= 1; ++j) {\n            counts += fetchColor(fragCoord+vec2(i,j)).xyz;\n        }\n    }\n    vec3 color = ctrColor * vec3(equal(counts,vec3(2.0))) + vec3(equal(counts,vec3(3.0)));\n    fragColor = vec4(clamp(color, 0.0, 1.0), 1.0);   \n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McKGzD.jpg", "time_retrieved": "2024-04-28T18:59:25.586633", "access": "api", "wgpu-test": "incomplete"}
{"id": "MfV3RW", "name": "5-pass Kawase blur", "author": "pwyr", "description": "A simple Kawase blur implementation with samples taken at lower resolution. Configuration inspired by:\nhttps://www.intel.com/content/www/us/en/developer/articles/technical/an-investigation-of-fast-real-time-gpu-based-image-blur-algorithms.html", "tags": ["blur", "filter", "kawaseblur"], "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = kawaseBlur(iChannel0, fragCoord, iResolution.xy, 3.5); \n}", "image_inputs": [{"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 kawaseBlur(sampler2D tex, vec2 fragCoord, vec2 res, float d)\n{\n    vec2 s0 = (fragCoord + vec2(d, d)) / res;\n    vec2 s1 = (fragCoord + vec2(d, -d)) / res;\n    vec2 s2 = (fragCoord + vec2(-d, d)) / res;\n    vec2 s3 = (fragCoord + vec2(-d, -d)) / res;\n\n    float lod = 1.5;\n    return (textureLod(tex,s0,lod)+textureLod(tex,s1,lod)+textureLod(tex,s2,lod)+textureLod(tex,s3,lod)) / 4.0;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = kawaseBlur(iChannel0, fragCoord, iResolution.xy, 0.5); \n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = kawaseBlur(iChannel0, fragCoord, iResolution.xy, 1.5); \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = kawaseBlur(iChannel0, fragCoord, iResolution.xy, 2.5); \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = kawaseBlur(iChannel0, fragCoord, iResolution.xy, 2.5); \n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MfV3RW.jpg", "time_retrieved": "2024-04-28T18:59:25.588627", "access": "api", "wgpu-test": "error"}
{"id": "4fV3Rh", "name": "Multi-pass box blur", "author": "pwyr", "description": "Simple approximation of a Gaussian blur using multiple passes of a box blur with different filter kernel sizes.", "tags": ["blur", "filter", "boxblur"], "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = boxFilter(iChannel0, fragCoord, iResolution.xy, 8);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 boxFilter(sampler2D tex, vec2 fragCoord, vec2 res, int hw)\n{\n    vec2 uv = fragCoord/res;\n    \n    vec4 color = vec4(0);\n    for (int u = -hw; u <= hw; ++u) {\n        for (int v = -hw; v <= hw; ++v) {\n            color += texture(tex, (fragCoord + vec2(u,v)) / res); \n        }\n    }\n    color /= float((2*hw+1)*(2*hw+1));\n    return color;\n}", "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = boxFilter(iChannel0, fragCoord, iResolution.xy, 2);\n}", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = boxFilter(iChannel0, fragCoord, iResolution.xy, 5);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fV3Rh.jpg", "time_retrieved": "2024-04-28T18:59:25.589625", "access": "api", "wgpu-test": "error"}
{"id": "MfG3z1", "name": "Separated Gaussian blur", "author": "pwyr", "description": "Simple implementation of a Gaussian blur using two 1D filter kernels.", "tags": ["blur", "filter", "gaussianblur"], "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 dir = vec2(0,1);\n    fragColor = gaussian1D(iChannel0, dir, fragCoord, iResolution.xy);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 dir = vec2(1,0);\n    fragColor = gaussian1D(iChannel0, dir, fragCoord, iResolution.xy);\n}", "buffer_a_inputs": [{"id": 4, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec4 gaussian1D(sampler2D tex, vec2 dir, vec2 fragCoord, vec2 res)\n{\n    // normal distribution values with standard deviation 2\n    float vals[13] = float[](\n        0.00222, 0.00876, 0.02700, 0.06476, 0.12099, 0.17603, 0.19947, \n        0.17603, 0.12099, 0.06476, 0.02700, 0.00876, 0.00222);\n\n    vec4 color = vec4(0);\n    for (int i = -6; i <= 6; ++i) {\n        color += vals[i+6] * texture(tex, (fragCoord+float(i)*dir)/res);\n    }\n    \n    return color;\n}", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/MfG3z1.jpg", "time_retrieved": "2024-04-28T18:59:25.590623", "access": "api", "wgpu-test": "error"}
{"id": "4cy3Rh", "name": "Trivial box blur", "author": "pwyr", "description": "A simple box blur implementation with configurable filter kernel size.", "tags": ["blur", "boxblur"], "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    int hw = 5; // filter kernel half width\n    \n    vec4 col = vec4(0);\n    for (int u = -hw; u <= hw; ++u) {\n        for (int v = -hw; v <= hw; ++v) {\n            col += texture(iChannel0, uv + vec2(float(u)/float(iResolution.x), float(v)/float(iResolution.y))); \n        }\n    }\n    col *= 1.0 / float((2*hw+1)*(2*hw+1));\n    \n    fragColor = col;\n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cy3Rh.jpg", "time_retrieved": "2024-04-28T18:59:25.591619", "access": "api", "wgpu-test": "ok"}
{"id": "msdfR4", "name": "ball in a circle", "author": "Dolfun", "description": "bouncing ball", "tags": ["circle", "physics"], "image_code": "void mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = (frag_coord * 2.0 - iResolution.xy) / iResolution.y;\n    vec2 pos = fetch(iChannel0, STATE_ADDR).xy;\n    vec2 vel = fetch(iChannel0, STATE_ADDR).zw;\n    \n    vec3 color = vec3(0.2);\n    \n    color = mix(vec3(0.9), color, smoothstep(0.0, aa, abs(length(uv) - R) - aa));\n    color = mix(vec3(0.9), color, smoothstep(0.0, aa, length(uv - pos) - r - aa));\n    \n    vec3 trail = fetch(iChannel1, frag_coord).rgb;\n    color += trail;\n    \n    frag_color = vec4(color, 1.0);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define fetch(buf, addr) texelFetch(buf, ivec2(addr), 0)\n#define to_store(buf_pos, addr) (ivec2(buf_pos) == addr)\n\nconst ivec2 STATE_ADDR = ivec2(0, 0);\nconst ivec2 PREV_STATE_ADDR = ivec2(1, 0);\n\nconst vec4 state_0 = vec4(0.0, 0.0, 1.0, 3.0);\n\nconst float r = 0.02;\nconst float R = 0.9;\nconst float g = 9.81;\nconst float e = 0.99;\n\n// anti-aliasing\n#define aa (3./iResolution.y)\n\nfloat sdf_seg_old(vec2 p, vec2 a, vec2 b, float r) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba)/dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba*h) - r;\n}\n\n// SDF recommeded by: https://www.shadertoy.com/user/FabriceNeyret2\nfloat sdf_seg(vec2 p, vec2 a,vec2 b, float r) { \n    p -= a, b -= a;\n    float h = dot(p, b) / dot(b, b),\n          c = clamp(h, 0., 1.);\n    return h==c ? length(p - b * h) -r : 1e5; \n}", "buffer_a_code": "void mainImage(out vec4 state, in vec2 frag_coord) {\n    if (to_store(frag_coord, STATE_ADDR) || to_store(frag_coord, PREV_STATE_ADDR)) {\n        state = state_0;\n    }\n    if (iFrame > 0) {\n        if (to_store(frag_coord, STATE_ADDR)) {\n            state = fetch(iChannel0, STATE_ADDR);\n            float dt = iTimeDelta;\n            \n            vec2 pos = state.xy;\n            vec2 vel = state.zw;\n            \n            vel.y -= g * dt;\n            \n            if (length(pos + vel * dt) > R - r) {\n                vec2 n = normalize(pos);\n                vel -= (1.0 + e) * dot(vel, n) * n;\n            }\n            \n            pos += vel * dt;\n            state = vec4(pos, vel);\n        } else if (to_store(frag_coord, PREV_STATE_ADDR)) {\n            state = fetch(iChannel0, STATE_ADDR);\n        }\n    }\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "void mainImage(out vec4 frag_color, in vec2 frag_coord) {\n    vec2 uv = (frag_coord * 2.0 - iResolution.xy) / iResolution.y;\n    float dt = iTimeDelta;\n    vec2 curr = fetch(iChannel0, STATE_ADDR).xy;\n    vec2 prev = fetch(iChannel0, PREV_STATE_ADDR).xy;\n    \n    float d;\n    if (iMouse.z > 0.0f) d = sdf_seg_old(uv, curr, prev, 0.005);\n    else d = sdf_seg(uv, curr, prev, 0.005);\n    float t = smoothstep(0.0, aa, d);\n    \n    vec3 color = fetch(iChannel1, frag_coord).rgb;\n    if (color.x > 0.0) color -= 0.25 * dt;\n    color = mix(vec3(0.4), color, t);\n    \n    frag_color = vec4(color, 1.0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/msdfR4.jpg", "time_retrieved": "2024-04-28T18:59:25.762163", "access": "api", "wgpu-test": "incomplete"}
{"id": "XcK3RW", "name": "peaky/floffy Perlin hypertexture", "author": "FabriceNeyret2", "description": "Perlin turbulence combines abs(base_noise).   here, used to perturbates distance to disc, as for hypertextures.\nabs() gives a floffy look, \n1.-abs() gives a peaky look.\nplay with the multiplier !", "tags": ["perlinnoise", "hypertexture", "short", "gradientnoise", "isovalue"], "image_code": "// from https://www.shadertoy.com/view/4cVGRW\n\n#define R       iResolution\n#define rot(a)  mat2(cos(a+vec4(0,11,33,0)))                      // rotation \n\n// Perlin noise adapted from https://shadertoy.com/view/wtf3R2\n#define P       ( v = smoothstep(0.,1.,fract(V)), 2.*abs(mix( Pz(0), Pz(1), v.z)) )\n#define Pz(z)     mix( Py(0,z), Py(1,z), v.y)\n#define Py(y,z)   mix( Px(0,y,z), Px(1,y,z), v.x)\n#define Px(x,y,z) dot( H( C = floor(V) + vec3(x,y,z) ), V-C )\n#define H(p)    ( 2.* fract(sin( (p) * mat3(R,73.-R,R.zxy))*3758.54) -1.)\n\nfloat map(vec3 V)\n{\n    float l =  length(V) -.6 ;             // disc\n    vec3 C, v; V.y += .2*iTime;\n    float i,s=1., p;\n    for ( ; i++ < 4. ; V *= 2., s *= 2. )  // Perline turbulence\n        p += P/s;\n    p /= 2.; p -= .274;                    // mean: .274 std: .217\n // p *= 1. + (iMouse.x/R.x -.5)*3.;       // mouse gain ( â†’ comment 34 mouse cam )\n    if ( fract(iTime/5.) < .5 )\n        l +=  1.5* p ;                     // make peaky\n    else\n         l -=  1.* p ;                     // make floffy\n    return l;\n}\n\nvoid mainImage(out vec4 O, vec2 U)\n{\n    float t=9.;\n    vec3  D = normalize(vec3(U+U, -12.*R.y) - R),          // ray direction\n          p = vec3(0,0,15), q, r,                          // marching point along ray \n          M = iMouse.z > 0. ? iMouse.xyz/R -.5 :           // comment for no mouse cam\n                 vec3( .15,.07,0) * cos(.3*iTime + vec3(0,11,0)); \n          \n    for (O=vec4(1); O.x > 0. && t > .01 && p.z>-5.; O-=.01)// march scene\n        q = p,\n        q.yz *= rot(-6.*M.y),                              // rotations\n        q.xz *= rot(-6.*M.x-1.57),\n     // t = 9.,\n        t = min(t, map(q)),                                // full 3D shape, \n        p += .5*t*D;                                       // step forward = dist to obj          \n\n   O *= O * 1.1;                                           // color scheme\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcK3RW.jpg", "time_retrieved": "2024-04-28T18:59:26.072334", "access": "api", "wgpu-test": "ok"}
{"id": "4cVGRW", "name": "peaky/floffy Perlin ", "author": "FabriceNeyret2", "description": "Perlin turbulence combines abs(base_noise).   here, used to perturbates distance to disc, as for hypertextures.\nright: abs() gives a floffy look, \nleft: 1.-abs() gives a peaky look.\n( mouse to sweep )\n3D version here: https://www.shadertoy.com/view/XcK3RW", "tags": ["perlinnoise", "hypertexture", "short", "gradientnoise", "isovalue"], "image_code": "// Perlin noise adapted from https://shadertoy.com/view/wtf3R2\n#define P     ( v = smoothstep(0.,1.,fract(V)), 2.*abs(mix( Py(0), Py(1), v.y)) )\n#define Px(x,y) dot( H( C = floor(V) + vec2(x,y) ), V-C )\n#define Py(y)   mix( Px(0,y), Px(1,y), v.x)\n#define H(p)  ( 2.* fract(sin( (p) * mat2(127.1,311.7,269.5,183.3))*43758.54) -1.)\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         M = iMouse.xy,\n         U = u / R.y, V = 4.*U, C, v; V.y += iTime;\n    if (M==vec2(0)) M = R/2.;\n    \n    float i,s=1., p;\n    for ( ; i++ < 5. ; V *= 2., s *= 2. )  // Perline turbulence\n        p += P/s;\n    p /= 2.; p -= .274;                    // mean: .274 std: .217\n\n    float l =  length(u+u-R)/R.y -.6 ;     // disc\n    if ( u.x < M.x )\n        l +=  1.5*p ;                      // make peaky\n    else \n        l -=  1. *p ;                      // make floffy\n    O = vec4( smoothstep( 12./R.y, 0., l ) );\n    if (int(M)==int(u)) O = vec4(1,0,0,0); // red separator\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cVGRW.jpg", "time_retrieved": "2024-04-28T18:59:26.501186", "access": "api", "wgpu-test": "ok"}
{"id": "4cKGRW", "name": "Windows terminal Mandelmapping", "author": "mrange", "description": "CC0: Windows Terminal - Mandelmapping\n Shader prepared for Windows Terminal Shader Gallery\n https://github.com/mrange/windows-terminal-shader-gallery\n", "tags": ["2d"], "image_code": "// CC0: Windows Terminal - Mandelmapping\n//  Shader prepared for Windows Terminal Shader Gallery\n//  https://github.com/mrange/windows-terminal-shader-gallery\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6;\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\nvec3 palette(float a){\n  return (1.+(sin(vec3(0., 1., 2.)+a)));\n}\n\nvec3 effect(vec2 p) {\n  float tm = -TIME*0.25;\n  const float MaxIter = 22.;\n  const float zz= 1.;\n  const float b = 0.1;\n\n  vec2 op = p;\n  p = p.yx;\n\n  vec2 center = vec2(-0.4, 0.);\n  vec2 c = center+p*0.5;\n  vec2 z = c;\n\n  vec2 z2;\n\n  float s = 1.;\n  float i = 0.;\n  for (; i < MaxIter; ++i) {\n    z2 = z*z;\n    float ss = sqrt(z2.x+z2.y);\n    if (ss > 2.) break;\n    s *= 2.;\n    s *= ss;\n    z = vec2(z2.x-z2.y, 2.*z.x*z.y)+c;\n  }\n\n  vec2 p2 = z/zz;\n  float a = 0.1*tm;\n  p2 *= ROT(a);\n  p2 += sin(vec2(1., sqrt(0.5))*a*b)/b;\n\n  const float gfo = 0.5;\n  float fo = (gfo*1E-3)+s*(gfo*3E-3);\n  vec2 c2 = p2;\n  hextile(c2);\n\n  float gd0 = length(c2)-0.25;\n  float gd1 = abs(c2.y);\n  const vec2 n2 = ROT(radians(60.))*vec2(0.,1.);\n  const vec2 n3 = ROT(radians(-60.))*vec2(0.,1.);\n  float gd2 = abs(dot(n2, c2));\n  float gd3 = abs(dot(n3, c2));\n  gd1 = min(gd1, gd2);\n  gd1 = min(gd1, gd3);\n  float gd = gd0;\n  gd = pmax(gd, -(gd1-0.025), 0.075);\n  gd = min(gd, gd1);\n  gd = pmin(gd, gd0+0.2, 0.025);\n  gd = abs(gd);\n  gd -= fo;\n\n  vec3 col = vec3(0.);\n\n  if (i < MaxIter) {\n  } else {\n    float gf = (gfo*1E-2)/max(gd, fo);\n//    gf *= sqrt(gf);\n    col += gf*palette(tm+(p2.x-p2.y)+op.x);\n  }\n\n  float div = 6.*max(round(RESOLUTION.y/1080.0), 1.);\n\n  col *= sqrt(0.5)*(0.5+0.5*sin(op.y*RESOLUTION.y*TAU/div));\n  col = aces_approx(col);\n  col = sqrt(col);\n  \n  return col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cKGRW.jpg", "time_retrieved": "2024-04-28T18:59:27.589274", "access": "api", "wgpu-test": "ok"}
{"id": "lfGGzD", "name": "Temple ruins path traced", "author": "FifthStateOfMatter", "description": "Path traced version of \"Temple ruins\" shader (https://www.shadertoy.com/view/ld2GWy)", "tags": ["3d", "raymarch", "dof", "pathtrace"], "image_code": "/*\nI noticed the \"Temple ruins\" shader on shader of the week so I decided to try path tracing it\n\nI only spent a couple hours on this\nand I have the attention span of a carrot\nso there is much room for improvement that\nI will never find motivation to add.\nI may or may not implement suggestions\n\nCurrently running at around 40fps on RTX 4060 at 1800 x 1013\n\nCredit to the original shader by avix for the temple model and triplanar mapping (https://www.shadertoy.com/view/ld2GWy)\nCredit to Poisson for utility functions (https://www.shadertoy.com/user/Poisson)\n*/\n\n// ACES color space mapping from Poisson (https://www.shadertoy.com/view/dssXRj)\nvec3 ACES(vec3 x) {\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.1;\n    float d = 0.7;\n    float e = 0.12;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n    vec4 col = texelFetch(iChannel0, ivec2(fragCoord), 0);\n    col.rgb /= col.a;\n    col.rgb = ACES(col.rgb);\n    fragColor = vec4(pow(col.rgb, vec3(1.0 / 2.2)), 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// Hash borrowed from Poisson (https://www.shadertoy.com/view/dssXRj)\nfloat seed;\n\nfloat hash1() {\n    return fract(sin(seed += 0.1) * 4568.7564);\n}\n\nvec2 hash2() {\n    return vec2(hash1(), hash1());\n}\n\nvec3 hash3() {\n    return vec3(hash1(), hash1(), hash1());\n}\n\nvec2 randomDirection2D() {\n    vec2 d;\n    while(true) {\n        d = hash2() * 2.0 - 1.0;\n        if(length(d) <= 1.0) return normalize(d);\n    }\n}\n\nvec3 randomDirection() {\n    vec3 d;\n    while(true) {\n        d = hash3() * 2.0 - 1.0;\n        if(length(d) <= 1.0) return normalize(d);\n    }\n}\n\nvec3 rotate2D(vec3 p, vec2 t){\n    float stx = sin(t.x);\n    float ctx = cos(t.x);\n    float sty = sin(t.y);\n    float cty = cos(t.y);\n    mat3 xRotation;\n    xRotation[0] = vec3(1, 0, 0);\n    xRotation[1] = vec3(0, ctx, -stx);\n    xRotation[2] = vec3(0, stx, ctx);\n    \n    mat3 yRotation;\n    yRotation[0] = vec3(cty, 0, -sty);\n    yRotation[1] = vec3(0, 1, 0);\n    yRotation[2] = vec3(sty, 0, cty);\n    return p*xRotation*yRotation;\n}\n\n// SDF code from original (https://www.shadertoy.com/view/ld2GWy)\nfloat sdrBox(vec3 p, vec3 b, float r) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0)) - r;\n}\n\nfloat sdCylinder(vec3 p, vec2 h) {\n    return max(length(p.xz) - h.x, abs(p.y) - h.y);\n}\n\nfloat ruins(vec3 p) {\n    vec3 q = p;\n    \n    //bumps\n    float o = texture(iChannel0, p.xy * 0.1).x * texture(iChannel0, p.yz * 0.1).x * 0.005;\n\n    //pillars bottom\n    p.x = clamp(p.x, -8.0, 8.0);                                     //limit x\n    if((p.z < 2.0 && p.z > -2.0) && (p.x < 0.0 && p.x > -4.0)) p.x = 0.0; //chop hole in middle \n\n    p.x = mod(p.x, 2.0) - 0.5 * 2.0;                                    //rep x\n\n    p.z = clamp(p.z, -4.0, 4.0);                                     //limit z\n    if(q.x > 2.0 || q.x < -6.0) p.z = clamp(p.z, -2.0, 2.0);\n    p.z = mod(p.z, 2.0) - 0.5 * 2.0;                                    //rep z\n\n    float r = 0.5 - clamp(sin(p.y * 1.2 + 1.58) * 0.5, 0.0, 0.05);\n    float d = sdCylinder(p, vec2(r, 1.5)) - o;\n\n    //pillars top\n    p.y -= 2.8;\n    r = 0.4 - clamp(sin(p.y * 1.8 + 0.8) * 0.5, 0.0, 0.05);\n    \n    float h = 1.5;\n    if(q.x > 2.0) {\n        p.y -= 0.5;\n        h = 2.0;\n        r = 0.4 - clamp(sin(p.y * 1.15 + 1.1) * 0.5, 0.0, 0.05);\n    } //pull first 3x2 pillars up\n    float t = sdCylinder(p, vec2(r, h)) - o;    \n\n    //mid platform\n    q.y -= 1.8;\n    float c = sdrBox(q, vec3(7.45, 0.25, 1.45), 0.05) - o;\n    q.x += 2.0;\n    c = min(c, sdrBox(q, vec3(3.45, 0.25, 3.45), 0.05) - o);\n\n    //bottom platform\n    q.y += 3.55;\n    c = min(c, sdrBox(q, vec3(3.65, 0.2, 3.65), 0.05) - o);\n    q.x -= 2.0;\n    c = min(c, sdrBox(q, vec3(7.65, 0.2, 1.65), 0.05) - o);\n    \n    //ground platform\n    q.x += 2.0;\n    q.y += 0.8;\n    c=min(c, sdrBox(q, vec3(4.65, 0.6, 4.65), 0.05) - o);\n    q.x -= 2.0;\n    c = min(c, sdrBox(q, vec3(8.65, 0.6, 2.65), 0.05) - o);\n    \n    //top part\n    q.y -= 8.0;\n    q.x -= 5.0;\n    c = min(c, sdrBox(q, vec3(2.45, 0.15, 1.45), 0.05) - o);\n    c = max(c, -sdrBox(q, vec3(1.45, 0.25, 0.45), 0.05) - o);    //left hole\n    \n    //top right part\n    q.y += 1.0;\n    q.x += 6.0;\n    c = min(c, sdrBox(q, vec3(4.50, 0.15, 1.65), 0.05) - o);\n    q.x += 1.0;\n    q.z -= 0.85;\n    c = min(c, sdrBox(q, vec3(3.45, 0.15, 2.5), 0.05) - o);\n    q.z += 0.85;\n    c = max(c, -sdrBox(q, vec3(2.25, 4.5, 2.25), 0.05) - o);    \n    \n    d = min(min(c, d), t);\n\t\n    return d * 0.8;\n}\n\n// Just used a flat surface here because it was starting to get laggy\nfloat terrain(vec3 p) {\n    return sdrBox(p - vec3(0, -6, 0), vec3(50, 3, 50), 0.0) * 0.7;\n}\n\nfloat scene(vec3 p) {\n    return min(terrain(p), ruins(p));\n}\n\n// Triplanar mapping function from original (https://www.shadertoy.com/view/ld2GWy)\nvec3 tex3D(vec3 pos, vec3 nor, sampler2D s) {\n\treturn texture(s, pos.yz).xyz * abs(nor.x) +\n\t       texture(s, pos.xz).xyz * abs(nor.y) +\n\t       texture(s, pos.xy).xyz * abs(nor.z);\n}\n\nfloat raymarch(vec3 o, vec3 d, inout bool hit) {\n    float t = 0.0;\n    for(int i = 0; i < 100 && t <= 30.0 && !hit; i++) {\n        float s = scene(o + d * t);\n        t += s;\n        if(abs(s) <= 0.003 * t && t >= 0.0) hit = true;\n    }\n    return t;\n}\n\nvec3 getNormal(vec3 p) {\n    vec2 e = vec2(0, 0.001);\n    return normalize(vec3(\n        scene(p + e.yxx) - ruins(p - e.yxx),\n        scene(p + e.xyx) - ruins(p - e.xyx),\n        scene(p + e.xxy) - ruins(p - e.xxy)\n    ));\n}\n\nvec3 pathtrace(vec3 o, vec3 d) {\n    vec3 col = vec3(1);\n    vec3 mat;\n    float t;\n    float initT;\n    bool hit = false;\n    vec3 p;\n    vec3 n;\n    for(int i = 0; i < 6; i++) {\n        hit = false;\n        t = raymarch(o, d, hit);\n        if(i < 1) initT = t;\n        if(hit) {\n            p = o + d * t;\n            n = getNormal(p);\n            o = p + n * 0.005;\n            d = randomDirection();\n            d *= sign(dot(n, d));\n            if(p.y <= -3.0 + 0.1) {\n                mat = mix(vec3(0.5, 0.1, 0), vec3(0.1, 0.5, 0), texture(iChannel2, p.xz * 0.01).r);\n            } else {\n                mat = (tex3D(p * 0.3, n, iChannel1) * 0.75 + tex3D(p * 0.3, n, iChannel2).grb) / 2.0;\n            }\n            col *= mat * 0.5 * dot(n, d) * 2.0;\n        } else {\n            col *= (i > 1 ? 2.0 : 1.0) * vec3(0.8, 0.9, 1);\n            break;\n        }\n    }\n    return mix(col, vec3(0.8, 0.9, 1), 1.0 - exp(-initT * vec3(0.005, 0.0051, 0.0054)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    \n    seed = iTime + dot(sin(fragCoord), vec2(443.712, 983.234));\n    seed += hash1() * 434.251;\n    \n    vec3 o = rotate2D(vec3(0, 0, -14), -iMouse.yx * 0.005 + vec2(radians(60.0), radians(0.0)));\n    vec3 d = rotate2D(normalize(vec3(uv, 1.0)), -iMouse.yx * 0.005 + vec2(radians(60.0), radians(0.0)));\n    vec3 focalPoint = o + d * 10.0;\n    \n    o += rotate2D(vec3(randomDirection2D(), 0), -iMouse.yx * 0.005 + vec2(radians(60.0), radians(0.0))) * 0.1;\n    vec3 shiftedDir = normalize(focalPoint - o);\n    \n    // Progression borrowed from Poisson (https://www.shadertoy.com/view/dssXRj)\n    vec3 col = pathtrace(o, shiftedDir);\n    vec4 data = texelFetch(iChannel3, ivec2(fragCoord), 0);\n    if(iMouse.z > 0.0){\n        data *= 0.0;\n    }\n    data += vec4(col, 1);\n    \n    fragColor = data;\n}", "buffer_a_inputs": [{"id": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 2, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lfGGzD.jpg", "time_retrieved": "2024-04-28T18:59:27.855561", "access": "api", "wgpu-test": "incomplete"}
{"id": "lcyGzW", "name": "Bezier01", "author": "kenshin", "description": "Bezier", "tags": ["bezier"], "image_code": "float circle(vec2 p, vec2 c, float r)\n{\n    float d = length(p - c) - r;\n    return smoothstep(0.009, .0, d);\n}\n\nfloat line(vec2 p, vec2 a, vec2 b)\n{\n    vec2 ap = p - a;\n    vec2 ab = b - a;\n    float t = clamp(dot(ap, ab) / dot(ab, ab), .0, 1.);\n    vec2 c = a + ab * t;\n    float d = length(p - c);\n    return smoothstep(.004, .0, d);\n}\n\nvec2 bezier(vec2 a, vec2 b, vec2 c, float t)\n{\n    return mix(mix(a, c, t), mix(c, b, t), t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy * .5)/iResolution.y;\n    vec3 col = vec3(.0);\n    float t = sin(iTime * .5) * .5 + .5;\n    vec2 A = vec2(-.8, -.4);\n    vec2 B = vec2(0.8, 0.4);\n    vec2 C = (iMouse.xy - iResolution.xy * .5)/iResolution.y;\n    vec2 D = mix(A, C, t);\n    vec2 E = mix(C, B, t);\n    vec2 F = mix(D, E, t);\n    col += vec3(1,0,0) * circle(uv, A, .01);\n    col += vec3(0,0,1) * circle(uv, B, .01);\n    col += vec3(1,1,1) * circle(uv, C, .01);\n\n    col += vec3(1,1,0) * circle(uv, F, .01);\n    \n    float SEGMENT_NUMS = 100.;\n    vec2 p, pp = A;\n    for(float i = 0.; i <= SEGMENT_NUMS; i++)\n    {\n        t = float(i / SEGMENT_NUMS);\n        p = bezier(A, B, C, t);\n        col += vec3(sin(t) * cos(t), sin(t), cos(t)) * line(uv, pp, p);\n        pp = p;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcyGzW.jpg", "time_retrieved": "2024-04-28T18:59:27.872516", "access": "api", "wgpu-test": "ok"}
{"id": "lcGGRD", "name": "Caustic After 5k Frames", "author": "wyatt", "description": "Interact for 10 seconds (at 8x speed) and then see the caustic", "tags": ["fluid", "caustic"], "image_code": "// Fork of \"Nothing New\" by wyatt. https://shadertoy.com/view/Xf33zX\n// 2024-04-06 01:33:32\n\nMain {\n    Q = .8*atan(2.*D(U)/float(iFrame - M));\n    if (iFrame < M) Q = A(U).wwww;\n }", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define M 5000\n\n#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n\n#define vel(v) (v)*inversesqrt(1.+dot(v,v))\n\n#define inside(v) ((v).x>0.&&(v).y>0.&&(v).x<R.x&&(v).y<R.y)\n\nfloat ln (vec3 p, vec3 a, vec3 b) { \n    return length(p-a-(b-a)*(dot(p-a,b-a)/dot(b-a,b-a)));\n}\n #define UIF (1.0 / float(0xffffffffU))\nuint baseHash(uvec2 p){\n    p = 1103515245U*((p >> 1U)^(p.yx));\n    uint h32 = 1103515245U*((p.x)^(p.y>>3U));\n    return h32^(h32 >> 16);\n}\nvec3 hash(vec2 x){\n    uint n = baseHash(floatBitsToUint(x));\n    uvec3 rz = uvec3(n, n*16807U, n*48271U);\n    return vec3((rz >> 1) & uvec3(0x7fffffffU))/float(0x7fffffff);\n}\n#define pi 3.141592659", "buffer_a_code": "Main {\n\n    Q = A(U);\n    for (int x = -1; x <= 1; x++)\n    for (int y = -1; y <= 1; y++)\n    if (x*x+y*y<=4)\n    if (x!=0||y!=0) {\n        vec2 v = vec2(x,y);\n        vec4 q = A(U+v);\n        if (inside(U+v))\n        Q.xy += .01*q.w*(1.-q.w)*v/dot(v,v);\n    }\n    Q.y -= .1/R.y;\n    if (U.x<1.||U.y<1.||R.x-U.x<1.||R.y-U.y<1.)Q.xy *= 0.;\n    if (iFrame < 1) {\n        Q.z = U.x/R.x;\n        Q.w = step(U.y,.25*R.x);\n        Q.w -= step(abs(U.x-.5*R.x),.05*R.x);\n        Q.w = max(Q.w,0.);\n    }\n    if (iMouse.z>0.&&length(U-iMouse.xy)< 10.) Q.w = 1.,Q.x = .5,Q.z=1.;\n    \n    if (iFrame > M) Q = B(U);\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\nQ = A(U);\nvec4 dQ = vec4(0);\n#define K (1./8.)\nfor (int x = -1; x <= 1; x++)\nfor (int y = -1; y <= 1; y++)\nif (x!=0||y!=0) {\n    vec2 v = vec2(x,y);\n    vec2 W = U+v;\n    vec4 q = A(W);\n\n    vec2 a = vel(Q.xy),\n         b = vel(q.xy)+v;\n    float ab = dot(v,b-a);\n    if (inside(W)&&abs(ab)>0.) {\n        float i = dot(v,(0.5*v-a))/ab;\n        float j = .5+.25*clamp(1.-q.w,0.,1.);\n        float k = .5+.25*clamp(1.-Q.w,0.,1.);\n        float wa = K*Q.w*min(i,j)/j;\n        float wb = K*q.w*max(k+i-1.,0.)/k;\n        dQ += vec4(Q.xyz,1)*wa+vec4(q.xyz,1)*wb;\n    } else {\n        dQ += K*Q.w*vec4(Q.xyz,1);\n    }\n\n}\nif (dQ.w>0.) dQ.xyz /= dQ.w;\nQ = dQ;\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    \n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,0));\n    vec4 w = A(U-vec2(0,0));\n    Q.xy = 1.-A(U).ww;\n    Q.z = e.w-w.w;\n    Q.w = n.w-s.w;\n    \n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = A(U);\n    vec3 h = hash(U+float(iFrame)*R);\n    \n    vec2 d = vec2(cos(h.x*2.*pi),sin(h.x*2.*pi));\n    \n    U -= d*h.y;\n    if (iFrame > M) \n    for (float i = 0.; i < 400.; i++) {\n        \n        U += 2.*d;\n        vec4 b = B(U);\n        d = normalize(d+2.*(.5+.5*h.z)*b.zw);\n        float s = (R.y-U.y<1.)?1.:0.;\n        vec4 q = pow(max(d.y,0.),4.)*s*max(sin(6.*h.z-3.+vec4(1,2,3,4)),0.);\n        Q += q/20.;\n    \n    }\n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_d_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcGGRD.jpg", "time_retrieved": "2024-04-28T18:59:27.909418", "access": "api", "wgpu-test": "incomplete"}
{"id": "lfy3RW", "name": "Block Glitch Shader", "author": "Lego0_77", "description": "I don't care if you use this shader, but you should credit me.", "tags": ["glitch"], "image_code": "// Shader was shown in Baldi's Basics Randomizer, Edited some stuff to make more cooler\n\n// the glitch amp.\nfloat amp = 0.01;\n// the glitch block's offset.\nfloat glitchOffset = 0.0125;\n// the glitch block's count.\nfloat glitchBlocks = 20.0;\n\nfloat texStuff(vec2 uv, int number, float offset)\n{\n    float offsetREAL = 0.0;\n    if (floor(mod(uv.y * glitchBlocks, 2.0)) == 0.0)\n    {\n        if (floor(mod(uv.y * glitchBlocks, 4.0)) == 0.0)\n            offsetREAL = glitchOffset;\n        else\n            offsetREAL = -glitchOffset;\n    }\n    return texture(iChannel0, vec2((uv.x + offset) + offsetREAL, uv.y))[number];\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 col;\n    col.r = texStuff(uv, 0, -amp);\n    col.g = texStuff(uv, 1, 0.0);\n    col.b = texStuff(uv, 2, amp);\n    col.a = texStuff(uv, 3, 0.0);\n    fragColor = col;\n}\n\n// game engine shader convert thing.\n\n/* Unity Shader (Surface Shader, you can apply it to game objects.)\nShader \"Custom/Glitch\"\n{\n    Properties\n    {\n        _Color (\"Color\", Color) = (1,1,1,1)\n        _MainTex (\"Albedo (RGB)\", 2D) = \"white\" {}\n        _Glossiness (\"Smoothness\", Range(0,1)) = 0.5\n        _Metallic (\"Metallic\", Range(0,1)) = 0.0\n        _Amp (\"Amp\", float) = 0.0\n        _GlitchOffset (\"Glitch Offset\", float) = 0.0\n        _GlitchBlocks (\"Glitch Blocks\", float) = 10.0\n    }\n    SubShader\n    {\n        Tags { \"RenderType\"=\"Opaque\" }\n        LOD 200\n\n        CGPROGRAM\n        // Physically based Standard lighting model, and enable shadows on all light types\n        #pragma surface surf Standard fullforwardshadows\n\n        // Use shader model 3.0 target, to get nicer looking lighting\n        #pragma target 3.0\n\n        sampler2D _MainTex;\n\n        struct Input\n        {\n            float2 uv_MainTex;\n        };\n\n        half _Glossiness;\n        half _Metallic;\n        fixed4 _Color;\n        float _Amp;\n        float _GlitchOffset;\n        float _GlitchBlocks;\n\n        float texStuff(fixed2 uv, int number, float offset)\n        {\n            float offsetREAL = 0.0;\n            if (floor(uv.y * _GlitchBlocks % 2.0) == 0.0)\n            {\n                if (floor(uv.y * _GlitchBlocks % 4.0) == 0.0)\n                    offsetREAL = _GlitchOffset;\n                else\n                    offsetREAL = -_GlitchOffset;\n            }\n            return tex2D(_MainTex, fixed2((uv.x + offset) + offsetREAL, uv.y))[number];\n        }\n\n        // Add instancing support for this shader. You need to check 'Enable Instancing' on materials that use the shader.\n        // See https://docs.unity3d.com/Manual/GPUInstancing.html for more information about instancing.\n        // #pragma instancing_options assumeuniformscaling\n        UNITY_INSTANCING_BUFFER_START(Props)\n            // put more per-instance properties here\n        UNITY_INSTANCING_BUFFER_END(Props)\n\n        void surf (Input IN, inout SurfaceOutputStandard o)\n        {\n            fixed4 col;\n            col.r = texStuff(IN.uv_MainTex, 0, -_Amp);\n            col.g = texStuff(IN.uv_MainTex, 1, 0.0);\n            col.b = texStuff(IN.uv_MainTex, 2, _Amp);\n            col.a = texStuff(IN.uv_MainTex, 3, 0.0);\n            col *= _Color;\n            clip(col.a - 0.5);\n            o.Albedo = col.rgb;\n            // Metallic and smoothness come from slider variables\n            o.Metallic = _Metallic;\n            o.Smoothness = _Glossiness;\n            o.Alpha = col.a;\n        }\n        ENDCG\n    }\n    FallBack \"Diffuse\"\n}\n*/\n\n/* Haxe Shader\nuniform float amp;\nuniform float glitchOffset;\nuniform float glitchBlocks;\n\nfloat texStuff(vec2 uv, int number, float offset)\n{\n    float offsetREAL = 0.0;\n    if (floor(mod(uv.y * glitchBlocks, 2.0)) == 0.0)\n    {\n        if (floor(mod(uv.y * glitchBlocks, 4.0)) == 0.0)\n            offsetREAL = glitchOffset;\n        else\n            offsetREAL = -glitchOffset;\n    }\n    return texture2D(bitmap, vec2((uv.x + offset) + offsetREAL, uv.y))[number];\n}\n\nvoid main()\n{\n    vec2 uv = openfl_TextureCoordv;\n    vec4 col;\n    col.r = texStuff(uv, 0, -amp);\n    col.g = texStuff(uv, 1, 0.0);\n    col.b = texStuff(uv, 2, amp);\n    col.a = texStuff(uv, 3, 0.0);\n    gl_FragColor = col;\n}\n*/", "image_inputs": [{"id": 36, "src": "/media/a/35c87bcb8d7af24c54d41122dadb619dd920646a0bd0e477e7bdc6d12876df17.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lfy3RW.jpg", "time_retrieved": "2024-04-28T18:59:28.610542", "access": "api", "wgpu-test": "incomplete"}
{"id": "lcyGRW", "name": "jump animation", "author": "jorge2017a2", "description": "jump animation", "tags": ["2d", "animation", "jump"], "image_code": "//por jorge2017a2\n//jump animation\n//---6-abril-2024\n//referencia\n//https://iquilezles.org/articles/distfunctions2d\n///\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),0. , d - (b) )\n#define S2(d,b) smoothstep(antialiasing(0.5),0. , d - (b) )\n\n#define PI     3.14159265\n#define TWO_PI 6.28318530\n\n\nstruct TLinea\n{  vec2 A;\n   vec2 B;\n};\nTLinea arr[15];\n\n\nvec2 pt1_1[30]=vec2[](\nvec2(0.065,0.728),vec2(0.062,0.715),\nvec2(0.065,0.728),vec2(0.062,0.715),\nvec2(0.062,0.715),vec2(0.066,0.639),\nvec2(0.062,0.715),vec2(0.038,0.676),\nvec2(0.038,0.676),vec2(0.046,0.634),\nvec2(0.046,0.634),vec2(0.053,0.626),\nvec2(0.062,0.715),vec2(0.085,0.676),\nvec2(0.085,0.676),vec2(0.113,0.656),\nvec2(0.113,0.656),vec2(0.122,0.65),\nvec2(0.066,0.639),vec2(0.066,0.577),\nvec2(0.066,0.577),vec2(0.033,0.599),\nvec2(0.033,0.599),vec2(0.021,0.579),\nvec2(0.066,0.639),vec2(0.098,0.595),\nvec2(0.098,0.595),vec2(0.104,0.544),\nvec2(0.104,0.544),vec2(0.122,0.54)\n);\n\nvec2 pt1_2[30]=vec2[](\nvec2(0.17,0.766),vec2(0.167,0.754),\nvec2(0.17,0.766),vec2(0.167,0.754),\nvec2(0.167,0.754),vec2(0.172,0.677),\nvec2(0.167,0.754),vec2(0.143,0.715),\nvec2(0.143,0.715),vec2(0.151,0.672),\nvec2(0.151,0.672),vec2(0.158,0.664),\nvec2(0.167,0.754),vec2(0.183,0.707),\nvec2(0.183,0.707),vec2(0.212,0.722),\nvec2(0.212,0.722),vec2(0.22,0.717),\nvec2(0.172,0.677),vec2(0.15,0.624),\nvec2(0.15,0.624),vec2(0.115,0.606),\nvec2(0.115,0.606),vec2(0.103,0.586),\nvec2(0.172,0.677),vec2(0.216,0.672),\nvec2(0.216,0.672),vec2(0.213,0.621),\nvec2(0.213,0.621),vec2(0.231,0.616)\n);\n\nvec2 pt1_3[30]=vec2[](\nvec2(0.25,0.817),vec2(0.246,0.805),\nvec2(0.25,0.817),vec2(0.246,0.805),\nvec2(0.246,0.805),vec2(0.251,0.729),\nvec2(0.246,0.805),vec2(0.234,0.757),\nvec2(0.234,0.757),vec2(0.265,0.761),\nvec2(0.265,0.761),vec2(0.272,0.753),\nvec2(0.246,0.805),vec2(0.281,0.823),\nvec2(0.281,0.823),vec2(0.287,0.866),\nvec2(0.287,0.866),vec2(0.287,0.879),\nvec2(0.251,0.729),vec2(0.236,0.671),\nvec2(0.236,0.671),vec2(0.199,0.675),\nvec2(0.199,0.675),vec2(0.187,0.655),\nvec2(0.251,0.729),vec2(0.293,0.707),\nvec2(0.293,0.707),vec2(0.309,0.661),\nvec2(0.309,0.661),vec2(0.327,0.656)\n);\n\nvec2 pt1_4[30]=vec2[](\nvec2(0.379,0.869),vec2(0.376,0.857),\nvec2(0.379,0.869),vec2(0.376,0.857),\nvec2(0.376,0.857),vec2(0.381,0.78),\nvec2(0.376,0.857),vec2(0.34,0.844),\nvec2(0.34,0.844),vec2(0.31,0.855),\nvec2(0.31,0.855),vec2(0.317,0.847),\nvec2(0.376,0.857),vec2(0.339,0.848),\nvec2(0.339,0.848),vec2(0.31,0.863),\nvec2(0.31,0.863),vec2(0.31,0.876),\nvec2(0.381,0.78),vec2(0.377,0.719),\nvec2(0.377,0.719),vec2(0.343,0.74),\nvec2(0.343,0.74),vec2(0.331,0.721),\nvec2(0.381,0.78),vec2(0.388,0.719),\nvec2(0.388,0.719),vec2(0.352,0.728),\nvec2(0.352,0.728),vec2(0.37,0.724)\n);\n\n\nvec2 pt1_5[30]=vec2[](\nvec2(0.508,0.856),vec2(0.505,0.844),\nvec2(0.508,0.856),vec2(0.505,0.844),\nvec2(0.505,0.844),vec2(0.51,0.767),\nvec2(0.505,0.844),vec2(0.499,0.895),\nvec2(0.499,0.895),vec2(0.479,0.928),\nvec2(0.479,0.928),vec2(0.486,0.92),\nvec2(0.505,0.844),vec2(0.512,0.895),\nvec2(0.512,0.895),vec2(0.501,0.936),\nvec2(0.501,0.936),vec2(0.501,0.949),\nvec2(0.51,0.767),vec2(0.518,0.706),\nvec2(0.518,0.706),vec2(0.486,0.732),\nvec2(0.486,0.732),vec2(0.474,0.712),\nvec2(0.51,0.767),vec2(0.532,0.714),\nvec2(0.532,0.714),vec2(0.514,0.669),\nvec2(0.514,0.669),vec2(0.532,0.665)\n);\n\nvec2 pt1_6[30]=vec2[](\nvec2(0.619,0.843),vec2(0.616,0.831),\nvec2(0.619,0.843),vec2(0.616,0.831),\nvec2(0.616,0.831),vec2(0.621,0.754),\nvec2(0.616,0.831),vec2(0.648,0.857),\nvec2(0.648,0.857),vec2(0.628,0.89),\nvec2(0.628,0.89),vec2(0.635,0.882),\nvec2(0.616,0.831),vec2(0.652,0.84),\nvec2(0.652,0.84),vec2(0.642,0.881),\nvec2(0.642,0.881),vec2(0.642,0.894),\nvec2(0.621,0.754),vec2(0.665,0.744),\nvec2(0.665,0.744),vec2(0.665,0.692),\nvec2(0.665,0.692),vec2(0.683,0.688),\nvec2(0.621,0.754),vec2(0.665,0.76),\nvec2(0.665,0.76),vec2(0.647,0.715),\nvec2(0.647,0.715),vec2(0.665,0.711)\n);\n\nvec2 pt1_7[30]=vec2[](\nvec2(0.73,0.779),vec2(0.727,0.767),\nvec2(0.73,0.779),vec2(0.727,0.767),\nvec2(0.727,0.767),vec2(0.732,0.69),\nvec2(0.727,0.767),vec2(0.762,0.749),\nvec2(0.762,0.749),vec2(0.777,0.787),\nvec2(0.777,0.787),vec2(0.785,0.794),\nvec2(0.727,0.767),vec2(0.759,0.741),\nvec2(0.759,0.741),vec2(0.786,0.763),\nvec2(0.786,0.763),vec2(0.792,0.773),\nvec2(0.732,0.69),vec2(0.773,0.711),\nvec2(0.773,0.711),vec2(0.773,0.66),\nvec2(0.773,0.66),vec2(0.792,0.655),\nvec2(0.732,0.69),vec2(0.77,0.721),\nvec2(0.77,0.721),vec2(0.752,0.676),\nvec2(0.752,0.676),vec2(0.77,0.672)\n);\n\nvec2 pt1_8[30]=vec2[](\nvec2(0.823,0.74),vec2(0.819,0.728),\nvec2(0.823,0.74),vec2(0.819,0.728),\nvec2(0.819,0.728),vec2(0.824,0.651),\nvec2(0.819,0.728),vec2(0.816,0.677),\nvec2(0.816,0.677),vec2(0.832,0.639),\nvec2(0.832,0.639),vec2(0.837,0.628),\nvec2(0.819,0.728),vec2(0.832,0.68),\nvec2(0.832,0.68),vec2(0.848,0.642),\nvec2(0.848,0.642),vec2(0.854,0.632),\nvec2(0.824,0.651),vec2(0.866,0.673),\nvec2(0.866,0.673),vec2(0.898,0.647),\nvec2(0.898,0.647),vec2(0.91,0.667),\nvec2(0.824,0.651),vec2(0.863,0.682),\nvec2(0.863,0.682),vec2(0.891,0.649),\nvec2(0.891,0.649),vec2(0.9,0.672)\n);\n\nvec2 pt1_9[30]=vec2[](\nvec2(0.915,0.689),vec2(0.912,0.677),\nvec2(0.915,0.689),vec2(0.912,0.677),\nvec2(0.912,0.677),vec2(0.917,0.6),\nvec2(0.912,0.677),vec2(0.909,0.626),\nvec2(0.909,0.626),vec2(0.936,0.647),\nvec2(0.936,0.647),vec2(0.94,0.659),\nvec2(0.912,0.677),vec2(0.924,0.629),\nvec2(0.924,0.629),vec2(0.952,0.65),\nvec2(0.952,0.65),vec2(0.96,0.657),\nvec2(0.917,0.6),vec2(0.961,0.6),\nvec2(0.961,0.6),vec2(0.967,0.549),\nvec2(0.967,0.549),vec2(0.986,0.547),\nvec2(0.917,0.6),vec2(0.96,0.589),\nvec2(0.96,0.589),vec2(0.967,0.539),\nvec2(0.967,0.539),vec2(0.985,0.539)\n);\n\nvec3 DrawFigSolo(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S( distObj,0.0)); return colOut; }\n\nvec3 D2(vec3 pColObj, vec3 colOut, float distObj ) \n{  colOut = mix(colOut,pColObj ,S2( distObj,0.0)); return colOut; }\n\n\nfloat sdCircle( vec2 p, float r )\n{ return length(p) - r;}\n\nfloat divf(float a, float b)\n{   //evita crash por 1/0.0 =Infinito=error, en compilar\n    if(b==0.0)\n    {b=0.00001;}\n    return a/b;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{  vec2 pa = p-a, ba = b-a;\n    float h = clamp( divf( dot(pa,ba),dot(ba,ba)), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\nvec3 hacerCuerpo(vec2 p, vec3 colout,vec3 colin,  int poc, float rc)\n{\n    vec2 a, b;\n    int k,op;\n    k=0;\n    op=int(mod((iTime+float(poc))*3.0,9.0));\n    \n    for(int i=0;i<30;i++)\n    {\n        \n        if(op==0)\n        {  a=pt1_1[i];arr[k].A=a;b=pt1_1[i+1];arr[k].B=b;i++;k++;}\n        \n        if(op==1)\n        {  a=pt1_2[i]; arr[k].A=a; b=pt1_2[i+1];  arr[k].B=b;i++; k++;}\n        \n        if(op==2)\n        {  a=pt1_3[i]; arr[k].A=a; b=pt1_3[i+1];  arr[k].B=b; i++; k++;}\n        \n        if(op==3)\n        {  a=pt1_4[i]; arr[k].A=a; b=pt1_4[i+1];  arr[k].B=b; i++; k++; }\n        \n        if(op==4)\n        {  a=pt1_5[i]; arr[k].A=a; b=pt1_5[i+1];  arr[k].B=b; i++; k++; }\n        \n        if(op==5)\n        {  a=pt1_6[i]; arr[k].A=a; b=pt1_6[i+1];  arr[k].B=b; i++; k++;}\n        \n        if(op==6)\n        {  a=pt1_7[i]; arr[k].A=a; b=pt1_7[i+1];  arr[k].B=b; i++; k++;}\n        \n        if(op==7)\n        {  a=pt1_8[i]; arr[k].A=a; b=pt1_8[i+1];  arr[k].B=b; i++; k++; }\n        \n        if(op==8)\n        {  a=pt1_9[i]; arr[k].A=a; b=pt1_9[i+1];  arr[k].B=b;i++; k++; }\n\n    }\n    \n \n   float d2= sdCircle( p-arr[0].A-vec2(0.0,0.035), rc );\n   colout=D2( colin, colout,abs(d2)-0.01);\n    \n    float dfin,d1;\n    dfin=9999.9;\n    bool blncol;\n    \n    blncol=false;\n    \n   \n    for(int i=0;i<15;i++)\n    {\n        a=arr[i].A;\n        b=arr[i].B;\n        d1=sdSegment(p, a,b );\n        dfin=min(dfin,d1);\n\n         if(i==3)\n        {\n            colout=D2(vec3(1.0,1.0,0.0), colout,abs(d1)-0.01); }\n        else if(i==6)  //brazo der\n        {\n            colout=D2(vec3(0.0,1.0,0.0), colout,abs(d1)-0.01); }\n        else if(i==9) //rodilla izq\n        {\n            colout=D2(vec3(1.0,.0,1.0), colout,abs(d1)-0.01); }\n        else if(i==12) //rodilla der\n        {\n            colout=D2(vec3(0.0,1.0,1.0), colout,abs(d1)-0.01); }\n        else\n        {   colout=D2(colin, colout,abs(d1)-0.01); }\n          \n    }\n    \n   return  colout; \n}\n\nvec3 suelo(vec2 p, vec3 colout)\n{\n    float d1=0.01*sin(p.x*20.0+iTime)+1.15+p.y;\n    float d2=0.01*sin(p.x*20.0+iTime)+1.10+p.y;\n    float d3=0.01*sin(p.x*20.0+iTime)-0.25+p.y;\n    //float d3=p.y-0.35;\n    d1=abs(d1)-1.7;\n    d2=abs(d2)-1.6;\n    \n    colout=D2(vec3(0.0,1.0,0.0),colout,d1);\n    colout=D2(vec3(0.0,0.8,0.0),colout,d2);\n    colout=D2(vec3(0.0,0.0,0.0),colout,d3);\n    return colout;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ( 2. * fragCoord - iResolution.xy ) / iResolution.y;\n    uv-=vec2(0.15,-1.25);\n    float esc=0.6;\n    uv*=esc;\n    vec2 uv0=uv;\n    float t=iTime;\n    vec3 col=vec3(1.0); \n    \n    //https://www.shadertoy.com/view/Xcd3Rl\n    float d = 0.7/length(uv-vec2(0.0,1.5));\n    col = vec3(0.2,0.5,1.0);  //Azul\n    col *= d;\n    col=suelo(uv, col);\n    col= hacerCuerpo(uv-vec2(-1.0,0.0),col,vec3(0.0),0,0.015);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcyGRW.jpg", "time_retrieved": "2024-04-28T18:59:28.630488", "access": "api", "wgpu-test": "ok"}
{"id": "4cy3zD", "name": "Particle Beam", "author": "wyatt", "description": "...", "tags": ["physics", "paritcles"], "image_code": "Main {\n\n    Q = 10.*abs(D(U))*vec4(1,.7,1,1);\n    \n    Q += .2*abs(vec4(C(U).x,0,C(U).y,1));\n    Q += 2.*C(U).w;\n    Q *= .1;\n    if (length(Q.xyz)>1.) Q.xyz = normalize(Q.xyz);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define k 1.\n\n#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define C(U) texture(iChannel2,(U)/R)\n#define D(U) texture(iChannel3,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)", "buffer_a_code": "Main {\n\n\n    Q = A(U);\n    vec4 b = B(U);\n    vec4 c = C(U);\n    vec4 d = D(U);\n    vec4 n = C(U+vec2(0,1));\n    vec4 e = C(U+vec2(1,0));\n    vec4 s = C(U-vec2(0,1));\n    vec4 w = C(U-vec2(1,0));\n    vec4 L = 0.25*(n+e+s+w)-c;\n    \n    Q.w += L.w + k*c.w/1.*(-1./6./(1.+length(c.w)) + 1./6./(1.+length(c.xy)+length(c.w)+length(d.xyz)));\n    \n    Q.xy += L.xy + k*c.xy/2.*(-2./6./(1.+length(c.xy)) + 1./6./(1.+length(c.xy)+length(c.w)+length(d.xyz)));\n    \n    \n    \n\n}", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n\n\n    Q = B(U);\n    vec4 a = A(U);\n    vec4 c = C(U);\n    vec4 d = D(U);\n    vec4 n = D(U+vec2(0,1));\n    vec4 e = D(U+vec2(1,0));\n    vec4 s = D(U-vec2(0,1));\n    vec4 w = D(U-vec2(1,0));\n    vec4 L = 0.25*(n+e+s+w)-d;\n    \n    Q.xyz += L.xyz + k*d.xyz/3.*(-3./6./(1.+length(d.xyz)) + 1./6./(1.+length(c.xy)+length(c.w)+length(d.xyz)));\n    \n    \n    \n    \n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = C(U);\n    \n    Q += .5*A(U);\n    \n    \n   if (U.y < .7*R.y\n        &&U.y>.3*R.y&&U.x<20.) \n    Q.xyw += .5*cos(-.1*U.x+.5*vec3(1.1,1.2,.4)*float(iFrame));\n        \n     if (U.x < .3*R.x&&U.y>.25*R.y&&U.y<.75*R.y&&abs(U.y-.5*R.y)>.05*R.y)\n         Q *= 0.;\n         \n       if (iMouse.z>0. && length(U-iMouse.xy) < 30.) Q.xyz+=sin(.05*float(iFrame)+vec3(1,2,3));\n       \n       \n     if (U.x < 14.||R.x-U.x<14.||R.y-U.y<14.||U.y<14.) Q *= 0.95;\n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "Main {\n    Q = D(U);\n    \n    Q += .5*B(U);\n    \n    \n    if (U.y < .7*R.y\n        &&U.y>.3*R.y&&U.x<20.) \n    Q.xyz += .5*cos(-.01*U.x+.1*vec3(1.1,1.2,1.3)*float(iFrame));\n    \n    if (U.x < .3*R.x&&U.y>.25*R.y&&U.y<.75*R.y&&abs(U.y-.5*R.y)>.05*R.y)\n         Q *= 0.;\n    \n       if (iMouse.z>0. && length(U-iMouse.xy) < 30.) Q.xyz+=sin(.05*float(iFrame)+vec3(1,2,3));\n         \n         \n     if (U.x < 14.||R.x-U.x<14.||R.y-U.y<14.||U.y<14.) Q *= 0.95;\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cy3zD.jpg", "time_retrieved": "2024-04-28T18:59:28.776099", "access": "api", "wgpu-test": "incomplete"}
{"id": "4fG3zD", "name": "Simple Water Ripple Test", "author": "yyf1994", "description": "my first pixel shader on ShaderToy !", "tags": ["noise", "reflection", "water", "ripple"], "image_code": "// Fork of \"Simple Water Ripple \" by Ricku. https://shadertoy.com/view/4sXXRj\n// 2024-04-07 02:39:49\n\n#define tile_factor 0.2\n#define noise_factor 0.03\n\nfloat hash11(float x)\n{\n    float y = fract(sin(x)*100000.0);\n    return y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) \n{\n\tvec2 position = fragCoord.xy / iResolution.xy;\n\tvec2 p = position  ;// vec2((position.x + 1.0)/2.0, position.y);\n\n \n\t\t// On Water Surface\n\t\tp.y=1.0-p.y;\n        \n        \n        float i = floor( iTime/10.0); // æ•´æ•°ï¼ˆi ä»£è¡¨ integerï¼‰\n        float f = fract( iTime/10.0); // å°æ•°ï¼ˆf ä»£è¡¨ fractionï¼‰\n\n\n        float t = fract(  iTime/30000.0 ) ;\n\n        t =  mix(hash11(i), hash11(i + 1.0), f);\n        \n \t\n\t\tvec2 waterCoord = vec2(p.x, 1.0-position.y);\n\t\tvec2 texCoordNormal0 = waterCoord * tile_factor;\n\t\ttexCoordNormal0 += t ;\n\t\t\n\t\tvec2 texCoordNormal1 = waterCoord * tile_factor;\n\t\ttexCoordNormal1.s -= t ;\n\t\ttexCoordNormal1.t += t ;\n\t\t\n\t\tvec3 normal0 = texture(iChannel1, texCoordNormal0).rgb * 2.0 - 1.0;\n\t\tvec3 normal1 = texture(iChannel1, texCoordNormal1).rgb * 2.0 - 1.0;\n\t\tvec3 normal = normalize(normal0 + normal1);\n\t\t\n\t\t//the final texture cooridnate is disturbed using the normal texture with some noise factor \n\t\tp += noise_factor * normal.xy;\n\t \n\tfragColor = texture(iChannel0, p);\n\t\n} ", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fG3zD.jpg", "time_retrieved": "2024-04-28T18:59:28.794051", "access": "api", "wgpu-test": "ok"}
{"id": "4ftGzl", "name": "Fork Triangle T htlsky 776", "author": "htlsky", "description": "A 2d shader. had some fun with procedurally generated triangles.", "tags": ["procedural", "triangle", "varonoi"], "image_code": "// The MIT License\n// Copyright Â© 2018 Patryk Ozga\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions: The above copyright\n// notice and this permission notice shall be included in all copies or\n// substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\",\n// WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n// TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n// NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n// FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n// TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR\n// THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfloat rand(vec2 co) {\n  return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 randPt(vec2 co) {\n  float f1 = rand(co);\n  float f2 = rand(co * f1);\n  return vec2(f1 * .8 + .1, f2 * .8 + .1);\n}\n\nvec2 sqPoint(vec2 sq) {\n  float time = 2. * iTime + 1.;\n  //time = 2.;\n  vec2 curPt = randPt(floor(sq) * floor(time));\n  vec2 nextPt = randPt(floor(sq) * floor(time + 1.));\n  return fract(time) * (nextPt - curPt) + curPt;\n}\n\nfloat sdLine(in vec2 p, in vec2 a, in vec2 b) {\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n  return length(pa - ba * h);\n}\n\nfloat distToShade(float d) {\n  float time = (1. + .3 * cos(3. * iTime));\n  //time = 1.;\n  return smoothstep(0.01, 1., 1. / (100. * time * d));\n}\n\nfloat cross2d(vec2 u, vec2 v) { return u.x * v.y - u.y * v.x; }\n\nfloat triArea(vec2 a, vec2 b, vec2 c) { return cross2d(b - a, c - a) / 2.; }\n\nconst vec3[4] palette = vec3[4](vec3(0.5, 0.5, 0.5), vec3(0.5, 0.5, 0.5),\n                                vec3(2.0, 1.0, 0.0), vec3(0.5, 0.20, 0.25));\n\nconst float _2PI = 6.28318;\n\nvec3 pal(in float t, in vec3[4] pal) {\n  return pal[0] + pal[1] * cos(_2PI * (pal[2] * t + pal[3]));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = (-iResolution.xy + 2.0 * fragCoord) / iResolution.y;\n\n  float scale = 1.25 *(pow(sin( iTime/8.) + 4., 1.5));\n  //scale = 2.;\n  vec2 sq = uv * scale + 1.;\n  vec2 uvSq = fract(sq);\n  vec2 sqPt = sqPoint(sq);\n  float c = 0.;\n  vec3 col = vec3(0.);\n  vec2[] offsets = vec2[](vec2(-1, -1), vec2(-1, 0), vec2(0, 1), vec2(1, 1),\n                          vec2(1, 0), vec2(0, -1)\n                          // vec2(-1, 1),\n                          // vec2(0, 0),\n                          // vec2(1, -1),\n  );\n\n  vec2 sqPtLast = sqPoint(sq + offsets[5]) + offsets[5];\n  for (int i = 0; i < 6; ++i) {\n    vec2 off = offsets[i];\n    vec2 sq2 = sq + off;\n    vec2 sqPt2 = sqPoint(sq2) + off;\n\n    //vec2 triCenter = (sqPt2 + sqPtLast + sqPt) / 3.;\n\n    float a = triArea(sqPt, sqPt2, sqPtLast);\n    // col.g += smoothstep(.1, 0., length(triCenter - uvSq));\n    float r1 = cross2d(uvSq - sqPt, sqPtLast - sqPt);\n    float r2 = cross2d(sqPt2 - sqPt, uvSq - sqPt);\n    \n      r1 = smoothstep(0., .001, r1);\n    r2 = smoothstep(0., .001, r2);\n    col += r1 * r2 * pal(a, palette);\n\n    float d = sdLine(uvSq, sqPt, sqPt2);\n    c += distToShade(d);\n\n    sqPtLast = sqPt2;\n  }\n\n  vec2[] diagOffsets = vec2[](vec2(-1, 0), vec2(0, 1),\n                              // vec2(-1, 0), vec2(0, -1),\n                              // vec2(1, 0), vec2(0, 1),\n                              vec2(1, 0), vec2(0, -1));\n  for (int i = 0; i < 4; i += 2) {\n    vec2 off1 = diagOffsets[ i];\n    vec2 sq1 = sq + off1;\n    vec2 sqPt1 = sqPoint(sq1) + off1;\n    vec2 vPt1 = sqPt1 - uvSq;\n\n    vec2 off2 = diagOffsets[ i + 1];\n    vec2 sq2 = sq + off2;\n    vec2 sqPt2 = sqPoint(sq2) + off2;\n\n    vec2 off3 = vec2(off1.x, off2.y);\n    vec2 sq3 = sq + off3;\n    vec2 sqPt3 = sqPoint(sq3) + off3;\n\n    float a = triArea(sqPt1,sqPt2, sqPt3);\n    \n    float r1 = cross2d(uvSq - sqPt2, sqPt1 - sqPt2);\n    float r2 = smoothstep(.01, 0., r1);\n    r1 = smoothstep(0., .001, r1);\n    col *= r2;\n    col += r1*pal(a, palette);\n\n    float d = sdLine(uvSq, sqPt1, sqPt2);\n    c += distToShade(d);\n  }\n\n  col -= vec3(c);\n  fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "mit", "thumbnail": "https://www.shadertoy.com/media/shaders/4ftGzl.jpg", "time_retrieved": "2024-04-28T18:59:28.832946", "access": "api", "wgpu-test": "error"}
{"id": "lcKGz1", "name": "Peak and Valley Detector", "author": "Hatchling", "description": "Illustrates peaks with light pixels, valleys with dark pixels, each one pixel across, with antialiasing.", "tags": ["edge", "aa", "canny"], "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 c0 = texture(iChannel0, uv);\n    vec4 c1 = texture(iChannel1, uv);\n    c1 /= c1.a;\n    vec4 c2 = texture(iChannel2, uv);\n    vec4 c3 = texture(iChannel3, uv);\n    \n    \n    //fragColor = texture(iChannel1, uv) * pow(vec4(1)-fragColor, vec4(5.0));\n    \n    fragColor = c1.xyxy *(c0.zzzz)*0.5 + 0.5;// ;\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\n// Constants ----------------------------------\n\nconst float Pi = 3.14159265358979;\nconst float Tau = Pi * 2.0;\nconst float InvPi = 1.0 / 3.14159265358979;\n\n// HLSL support -------------------------------\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define half  float\n#define half2 vec2\n#define half3 vec3\n#define half4 vec4\n\n#define fixed  float\n#define fixed2 vec2\n#define fixed3 vec3\n#define fixed4 vec4\n\n#define int2 ivec2\n#define int3 ivec3\n#define int4 ivec4\n\n#define bool2 bvec2\n#define bool3 bvec3\n#define bool4 bvec4\n\n#define lerp mix\n\n#define decl_saturate(type)            \\\ntype saturate(type x)                  \\\n{                                      \\\n    return clamp(x, type(0), type(1)); \\\n} \n\ndecl_saturate(float)\ndecl_saturate(vec2)\ndecl_saturate(vec3)\ndecl_saturate(vec4)\n\n// Boolean -------------------------------\n\nbool  isinf2(float v) { return isinf(v); } \nbvec2 isinf2(vec2 v)\n{\n    return bvec2\n    (\n        isinf(v.x),\n        isinf(v.y)\n    );\n}\nbvec3 isinf2(vec3 v)\n{\n    return bvec3\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z)\n    );\n}\nbvec4 isinf2(vec4 v)\n{\n    return bvec4\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z),\n        isinf(v.w)\n    );\n}\n\nbool  isnan2(float v) { return isnan(v); } \nbvec2 isnan2(vec2 v)\n{\n    return bvec2\n    (\n        isnan(v.x),\n        isnan(v.y)\n    );\n}\nbvec3 isnan2(vec3 v)\n{\n    return bvec3\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z)\n    );\n}\nbvec4 isnan2(vec4 v)\n{\n    return bvec4\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z),\n        isnan(v.w)\n    );\n}\n\nbool bnot(bool b) { return !b; }\nbvec2 bnot(bvec2 b) \n{ \n    return bvec2(!b.x, !b.y); \n}\nbvec3 bnot(bvec3 b) \n{ \n    return bvec3(!b.x, !b.y, !b.z); \n}\nbvec4 bnot(bvec4 b) \n{ \n    return bvec4(!b.x, !b.y, !b.z, !b.w); \n}\n\nbool band(bool a, bool b) { return a && b; }\nbvec2 band(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x && b.x,\n        a.y && b.y\n    ); \n}\nbvec3 band(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z\n    ); \n}\nbvec4 band(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z,\n        a.w && b.w\n    ); \n}\n\nbool bor(bool a, bool b) { return a || b; }\nbvec2 bor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x || b.x,\n        a.y || b.y\n    ); \n}\nbvec3 bor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z\n    ); \n}\nbvec4 bor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z,\n        a.w || b.w\n    ); \n}\n\nbool bxor(bool a, bool b) { return a != b; }\nbvec2 bxor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x != b.x,\n        a.y != b.y\n    ); \n}\nbvec3 bxor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z\n    ); \n}\nbvec4 bxor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z,\n        a.w != b.w\n    ); \n}\n\n#define decl_isfinite(retType, type) \\\nretType isfinite(type v)             \\\n{                                    \\\n    return band                      \\\n    (                                \\\n        bnot(isinf2(v)),             \\\n        bnot(isnan2(v))              \\\n    );                               \\\n} \ndecl_isfinite(bool, float)\ndecl_isfinite(bvec2, vec2)\ndecl_isfinite(bvec3, vec3)\ndecl_isfinite(bvec4, vec4)\n\nfloat select(bool s, float a, float b)\n{\n    return s ? a : b;\n}\n\nvec2 select(bvec2 s, vec2 a, vec2 b)\n{\n    return vec2\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y\n    );  \n}\n\nvec3 select(bvec3 s, vec3 a, vec3 b)\n{\n    return vec3\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z\n    );  \n}\n\nvec4 select(bvec4 s, vec4 a, vec4 b)\n{\n    return vec4\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z,\n        s.w ? a.w : b.w\n    );  \n}\n\n// Vector math -------------------\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) \\\nretType lengthSqr(type a)             \\\n{                                     \\\n    return dot2(a,a);                 \\\n}                                     \n\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) \\\nretType distSqr(type a, type b)     \\\n{                                   \\\n    type diff = a-b;                \\\n    return lengthSqr(diff);         \\\n}                                   \n\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// Borrowed from UnityEngine\n#define decl_safeNormalize(type)                 \\\ntype safeNormalize(type inVec)                   \\\n{                                                \\\n    float dp3 = max(0.001f, dot2(inVec, inVec)); \\\n    return inVec / sqrt(dp3);                    \\\n}\ndecl_safeNormalize(vec2)\ndecl_safeNormalize(vec3)\ndecl_safeNormalize(vec4)\n\n// Trig Math ----------------------\n\n#define decl_cosToTan(type)\\\ntype cosToTan(type cosine)\\\n{\\\n    return (sqrt(type(1.0)-cosine)*sqrt(cosine+type(1.0))) / cosine;\\\n}\ndecl_cosToTan(float)\ndecl_cosToTan(vec2)\ndecl_cosToTan(vec3)\ndecl_cosToTan(vec4)\n\n#define decl_tanToCos(type)\\\ntype tanToCos(type tangent)\\\n{\\\n    return type(1.0)/sqrt(tangent*tangent+type(1.0));\\\n}\ndecl_tanToCos(float)\ndecl_tanToCos(vec2)\ndecl_tanToCos(vec3)\ndecl_tanToCos(vec4)\n\n// Misc. math --------------------\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type)              \\\nretType floorToInt(type a)                          \\\n{                                                   \\\n    return retType(floor(a) + sign(a) * type(0.5)); \\\n}                                                   \n\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n\n#define decl_invMix(type) \\\ntype invMix(type a, type b, type t) \\\n{                                   \\\n    type result = (t-a)/(b-a);      \\\n    return select(isfinite(result), result, type(0.5)); \\\n}\n\ndecl_invMix(float)\ndecl_invMix(vec2)\ndecl_invMix(vec3)\ndecl_invMix(vec4)\n\n#define invLerp invMix\n\n#define decl_square(type)\\\ntype square(type a)\\\n{\\\n    return a*a;\\\n}\n\ndecl_square(int)\ndecl_square(ivec2)\ndecl_square(ivec3)\ndecl_square(ivec4)\ndecl_square(float)\ndecl_square(vec2)\ndecl_square(vec3)\ndecl_square(vec4)\n\nhalf Pow5 (half x)\n{\n    return x*x * x*x * x;\n}\n\nhalf2 Pow5 (half2 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf3 Pow5 (half3 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf4 Pow5 (half4 x)\n{\n    return x*x * x*x * x;\n}\n\n// RNG ----------------------------------------\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 uniform01ToGauss(vec2 value)\n{\n    float magnitude = sqrt(-2.0 * log(value.x));\n    \n    value.y *= 6.28318530718;\n    vec2 direction = vec2(cos(value.y),sin(value.y));\n    return magnitude * direction;\n}\n\nvec4 sampleRandom(sampler2D tex, vec2 fragCoord, inout uint rngState)\n{\n    fragCoord /= vec2(textureSize(tex, 0));\n    fragCoord += vec2\n    (\n        RandomFloat01(rngState),\n        RandomFloat01(rngState)\n    );\n    \n    return textureLod(tex, fragCoord, 0.0);\n}\n\nvec4 sampleBlueNoise(sampler2D blueNoiseTex, vec2 fragCoord, inout uint rngState)\n{\n    vec4 value = sampleRandom(blueNoiseTex, fragCoord, rngState);\n    \n    // The blue noise texture is limited to integer steps between\n    // 0 and 255 (inclusive).\n    // We need to add randomization to fill in the missing\n    // intermediate values.\n    value = mix(vec4(0.5 / 255.0), vec4(254.5 / 255.0), value);\n    value += \n    (\n        vec4\n        (\n            RandomFloat01(rngState), RandomFloat01(rngState),\n            RandomFloat01(rngState), RandomFloat01(rngState)\n        ) - 0.5\n    ) * (1.0 / 255.0);\n    \n    return value;\n}\n\n// Color -------------------------------\n\n#define decl_linearToGamma(type) \\\ntype linearToGamma(type v)       \\\n{                               \\\n    return pow(v, type(1.0 / 2.2));   \\\n}\n\ndecl_linearToGamma(float)\ndecl_linearToGamma(vec2)\ndecl_linearToGamma(vec3)\ndecl_linearToGamma(vec4)\n\n#define decl_gammaToLinear(type)    \\\ntype gammaToLinear(type v)          \\\n{                                   \\\n    return pow(v, type(2.2)); \\\n}\n\ndecl_gammaToLinear(float)\ndecl_gammaToLinear(vec2)\ndecl_gammaToLinear(vec3)\ndecl_gammaToLinear(vec4)\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cube(samplerCube cube, vec2 uv)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return texture(cube, ray);\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\nstruct quaternion\n{\n    vec4 value;\n};\n\nstruct bounds\n{\n    vec3 mini, maxi;\n};\n\nbool rayIntersectBounds\n(\n    bounds b, \n    vec3 rayOrig, \n    vec3 rayDir,\n    out vec3 nearHit,\n    out vec3 farHit\n)\n{\n    b.mini -= rayOrig;\n    b.maxi -= rayOrig;\n    \n    vec3 signs = sign(rayDir);\n    \n   \n    b.mini *= signs;\n    b.maxi *= signs;\n    rayDir *= signs;\n    \n    vec3 maxBounds = max((b.mini), (b.maxi));\n    \n    rayDir *= max(max(maxBounds.x, maxBounds.y),maxBounds.z) * 2.0; \n    \n    \n    \n    {\n        farHit = rayDir;\n        vec3 clamped = min(farHit, maxBounds);\n    \n        vec3 scale = max(vec3(0.0), clamped / farHit);\n        float minScale = min(min(scale.x, scale.y),scale.z); \n        farHit = (farHit * minScale) * signs + rayOrig;\n    }\n    \n    /*{\n        nearHit = -rayDir;\n        vec3 clamped = clamp(nearHit, b.mini, b.maxi);\n    \n        vec3 scale = abs(clamped / nearHit);\n        float minScale = max(max(scale.x, scale.y),scale.z); \n        nearHit = nearHit * minScale + rayOrig;\n    }*/\n    \n    nearHit = rayOrig;\n\n    return true;\n}\n\nquaternion mul(quaternion a, quaternion b)\n{\n    quaternion q;\n    q.value = vec4\n    (\n        a.value.wwww * b.value \n      + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) * vec4(1.0, 1.0, 1.0, -1.0) \n      - a.value.zxyz * b.value.yzxz\n    );\n    return q;\n}\n\nvec3 mul(quaternion q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.value.xyz, v);\n    return v + vec3(q.value.w * t) + cross(q.value.xyz, t);\n}\n\nquaternion FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis);\n    float halfAngle = mag * 0.5;\n    float scalar = sin(halfAngle) / max(mag, 0.00001);\n        \n    quaternion q;\n    q.value = vec4(angleAxis * scalar, cos(halfAngle));\n    return q;\n}\n\nquaternion FromToRotation(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float w = sqrt(dot(from, from) * dot(to, to)) + dot(from, to);\n    vec4 value = vec4(xyz, w);\n    quaternion q;\n    q.value = normalize(value);\n    return q;\n}\n\nquaternion LookRotation(float3 forward, float3 up)\n{\n    quaternion q;\n    forward = safeNormalize(forward);\n    q = FromToRotation(vec3(0,0,1), forward);\n    up = up - dot(forward, up) * forward;\n    vec3 upFrom = mul(q, vec3(0,1,0));\n    q = mul(FromToRotation(upFrom, up), q);\n    return q;\n}\n\nvoid sincos(vec3 x, out vec3 s, out vec3 c)\n{\n    s = sin(x);\n    c = cos(x);\n}\n        \nquaternion EulerZXY(float3 xyz)\n{\n    vec3 s, c;\n    sincos(vec3(0.5) * xyz, s, c);\n\n    return quaternion\n    (\n        vec4(s.xyz, c.x) * c.yxxy * c.zzyz \n      + s.yxxy * s.zzyz * vec4(c.xyz, s.x) * vec4(1, -1, -1, 1)\n    );\n}\n\nmat4x4 RotationMatrix(quaternion q)\n{\n    float q0 = q.value.x;\n    float q1 = q.value.y;\n    float q2 = q.value.z;\n    float q3 = q.value.w;\n        \n    /*# First row of the rotation matrix\n    r00 = 2 * (q0 * q0 + q1 * q1) - 1\n    r01 = 2 * (q1 * q2 - q0 * q3)\n    r02 = 2 * (q1 * q3 + q0 * q2)\n     \n    # Second row of the rotation matrix\n    r10 = 2 * (q1 * q2 + q0 * q3)\n    r11 = 2 * (q0 * q0 + q2 * q2) - 1\n    r12 = 2 * (q2 * q3 - q0 * q1)\n     \n    # Third row of the rotation matrix\n    r20 = 2 * (q1 * q3 - q0 * q2)\n    r21 = 2 * (q2 * q3 + q0 * q1)\n    r22 = 2 * (q0 * q0 + q3 * q3) - 1*/\n        \n    float r00 = 2. * (q0 * q0 + q1 * q1) - 1.;\n    float r01 = 2. * (q1 * q2 - q0 * q3);\n    float r02 = 2. * (q1 * q3 + q0 * q2);\n                                        \n    float r10 = 2. * (q1 * q2 + q0 * q3);\n    float r11 = 2. * (q0 * q0 + q2 * q2) - 1.;\n    float r12 = 2. * (q2 * q3 - q0 * q1);\n                                         \n    float r20 = 2. * (q1 * q3 - q0 * q2);\n    float r21 = 2. * (q2 * q3 + q0 * q1);\n    float r22 = 2. * (q0 * q0 + q3 * q3) - 1.;\n                             \n    return mat4x4\n    (\n        mul(q, vec3(1,0,0)), 0,\n        mul(q, vec3(0,1,0)), 0,\n        mul(q, vec3(0,0,1)), 0,\n        0,   0,   0,   1\n    );\n}\n\nmat4x4 TRS(vec3 translation, quaternion rotation, vec3 scale)\n{\n    mat4x4 float3x = RotationMatrix(rotation);\n    return mat4x4\n    (\n        vec4(float3x[0] * scale.x), \n        vec4(float3x[1] * scale.y), \n        vec4(float3x[2] * scale.z), \n        vec4(translation, 1)\n    );\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvoid drawSDF(vec3 diff_dist, inout vec4 color)\n{\n    float d = diff_dist.z;\n    vec2 grad = diff_dist.xy/(d);\n    \n    vec3 c = normalize(vec3(grad,sign(d))) * 0.5 + 0.5;\n\tc *= 1. - exp2(-12. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n\n    color.rgb = c;\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\nvec3 getNoise(int iFrame)\n{\n    vec3 noise = vec3(0);\n\n    // Calculate oising over time.\n    vec3 temporalNoise;\n    {\n        // Use the golden ratio as it should land\n        // on all fractional values eventually.\n        temporalNoise = vec3(iFrame, iFrame+1, iFrame+2);\n        temporalNoise *= vec3(0.7548776662, 0.56984029, 0.618033988749);\n\n        // We floor this one early to prevent\n        // loss of precision when iFrame becomes large.\n        temporalNoise -= floor(noise);\n    }\n    noise += temporalNoise;\n\n    #ifdef SPATIAL_NOISE\n    // Add noising over space.\n    // (Currently disabled; messes up the\n    // gradient and especially the curvature\n    // of the resulting map.)\n    vec3 spatialNoise;\n    {\n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n\n        vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        spatialNoise = texture(iChannel1, noiseUV).r;\n    }\n    noise += spatialNoise;\n    #endif\n\n    // Wrap values around from 0 to 1.\n    noise -= floor(noise);\n\n    // Center the sampling position offset\n    // to a range within -0.5 to +0.5.\n    noise.xy -= 0.5f;\n    \n    return noise;\n}\n\n// PBR Lighting ------------------------------\n// Borrowed from UnityEngine\nstruct MaterialMetallic\n{\n    fixed3 albedo;      // base (diffuse or specular) color\n    half metallic;      // 0=non-metal, 1=metal\n    half smoothness;    // 0=rough, 1=smooth\n};\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 specColor;\n    float oneMinusReflectivity;\n    float smoothness;\n};\n\nstruct Light\n{\n    half3 color;\n    half3 dir;\n};\n\nstruct Indirect\n{\n    half3 diffuse;\n    half3 specular;\n};\n\nconst float4 dielectricSpec = float4(0.04, 0.04, 0.04, 1.0 - 0.04);\n\nhalf OneMinusReflectivityFromMetallic(half metallic)\n{\n    half oneMinusDielectricSpec = dielectricSpec.a;\n    return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nhalf3 DiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)\n{\n    specColor = lerp (dielectricSpec.rgb, albedo, metallic);\n    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n    return albedo * oneMinusReflectivity;\n}\n\nMaterial toMaterial(MaterialMetallic i)\n{\n    Material o;\n    \n    o.albedo = i.albedo;\n    o.smoothness = i.smoothness;\n    \n    half oneMinusReflectivity;\n    half3 specColor;\n    o.albedo = DiffuseAndSpecularFromMetallic (o.albedo, i.metallic, o.specColor, o.oneMinusReflectivity);\n    \n    return o;\n}\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1.0 - smoothness);\n}\n\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\nhalf DisneyDiffuse(half NdotV, half NdotL, half LdotH, half perceptualRoughness)\n{\n    half fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    half lightScatter   = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotL));\n    half viewScatter    = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotV));\n\n    return lightScatter * viewScatter;\n}\n\nfloat PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n    // Original formulation:\n    //  lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\n    //  lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\n    //  G           = 1 / (1 + lambda_v + lambda_l);\n\n    // Reorder code to be more optimal\n    half a          = roughness;\n    half a2         = a * a;\n\n    half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\n    half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\n\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);  // This function is not intended to be running on Mobile,\n                                                // therefore epsilon is smaller than can be represented by half\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return InvPi * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\nhalf3 FresnelTerm (half3 F0, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return F0 + (1.0-F0) * t;\n}\n\nhalf3 FresnelLerp (half3 F0, half3 F90, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return lerp (F0, F90, t);\n}\n\n\nhalf3 brdf (half3 albedo, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    Light light, Indirect gi)\n{\n    float perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness);\n    float3 halfDir = safeNormalize(float3(light.dir) + viewDir);\n\n    // The amount we shift the normal toward the view vector is defined by the dot product.\n    half shiftAmount = dot(normal, viewDir);\n    normal = shiftAmount < 0.0f ? normal + viewDir * (-shiftAmount + 1e-5f) : normal;\n    normal = normalize(normal);\n\n    float nv = saturate(dot(normal, viewDir)); // TODO: this saturate should no be necessary here\n\n    float nl = saturate(dot(normal, light.dir));\n    float nh = saturate(dot(normal, halfDir));\n\n    half lv = saturate(dot(light.dir, viewDir));\n    half lh = saturate(dot(light.dir, halfDir));\n\n    // Diffuse term\n    half diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl / 3.1415927;\n\n    // Specular term\n    float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    \n    // GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\n    roughness = max(roughness, 0.002);\n    float V = SmithJointGGXVisibilityTerm (nl, nv, roughness);\n    float D = GGXTerm (nh, roughness);\n\n    float specularTerm = V*D; // Torrance-Sparrow model, Fresnel is applied later\n\n    // specularTerm * nl can be NaN on Metal in some cases, use max() to make sure it's a sane value\n    specularTerm = max(0.0, specularTerm * nl);\n\n    // surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\n    half surfaceReduction;\n    surfaceReduction = 1.0 / (roughness*roughness + 1.0);           // fade \\in [0.5;1]\n\n    // To provide true Lambert lighting, we need to be able to kill specular completely.\n    //specularTerm *= (specColor != vec3(0)) ? 1.0 : 0.0;\n\n    half grazingTerm = saturate(smoothness + (1.0-oneMinusReflectivity));\n    half3 color =   albedo * (gi.diffuse + light.color * diffuseTerm)\n                    + specularTerm * light.color * FresnelTerm (specColor, lh)\n                    + surfaceReduction * gi.specular * FresnelLerp (specColor, vec3(grazingTerm), nv)\n                    ;\n\n    return half3(color);\n}\n\nvec3 lighting(MaterialMetallic mat, vec3 normal, vec3 viewDir, Light light, Indirect indirect)\n{\n    Material m = toMaterial(mat);\n    \n    return brdf(m.albedo, m.specColor, m.oneMinusReflectivity, m.smoothness,\n    normal, viewDir, light, indirect);\n}\n\n// RAYTRACING -----------------------------\n// Taken from https://www.shadertoy.com/view/MtcXWr\n// Credit: Zavie\n\nstruct Ray\n{\n    vec3 origin;\t\n    vec3 direction;\t\t\n};\n\nstruct Hit\n{\n    float distance;\n    vec3 normal;\t\n};\nconst Hit noHit = Hit(1e10, vec3(0.));\n\nstruct Plane\n{\n    float offset;\n    vec3 normal;\n};\n\nstruct Sphere\n{\n\tfloat radius;\n    vec3 center;\n};\n\nstruct Cone\n{\n    float cosa;\t// cosine of half cone angle\n    float height;\n    float thickness;\n    vec3 origin;\n    vec3 axis;\n};\n\nstruct Capsule\n{\n    vec3 start;\n    vec3 end;\n    float startRadius;\n    float endRadius;\n};\n\nstruct HeightPlane\n{\n    mat4x4 localToWorld;\n    vec2 uvOffset;\n};\n\nvec3 getPoint(in Ray r, float dist)\n{\n    return r.origin + r.direction * dist;\n}\n\nvec3 getPoint(in Ray r, in Hit hit)\n{\n    return r.origin + r.direction * hit.distance;\n}\n\nbool swapIfCloser(inout Hit current, Hit candidate)\n{\n    if (candidate.distance < current.distance && candidate.distance >= 0.0)\n    {\n        current = candidate;\n        return true;\n    }\n    return false;\n}\n\nHit intersectPlane(Plane plane, Ray ray)\n{\n    float dotnd = -dot(plane.normal, ray.direction);\n    float heightAbovePlane = dot(ray.origin, plane.normal) - plane.offset;\n\n    float t = heightAbovePlane / dotnd;\n    //if(!(t >= 0.0))\n    //    return noHit;\n        \n    return Hit(t, plane.normal * sign(dotnd));\n}\n\nHit intersectSphere(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.center - ray.origin;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n\n    return Hit(t, (ray.origin + t*ray.direction - sphere.center) / sphere.radius);\n}\n\nHit intersectCapsule(Capsule capsule, Ray ray)\n{\n    vec3 rayDirection = ray.direction;\n    vec3 relativeOrigin = ray.origin - capsule.start;\n    vec3 coneDirection = normalize(capsule.end - capsule.start);\n    float coneLength = distance(capsule.end, capsule.start);\n    float changeInRadiusWithLength = (capsule.endRadius - capsule.startRadius) / coneLength;\n    float whatever = 1.0 - square(changeInRadiusWithLength);\n    \n    if(whatever <= 0.0)\n    {\n    \tif(capsule.endRadius < capsule.startRadius)\n    \t{\n    \t\tSphere s = Sphere(capsule.startRadius, capsule.start);\n    \t\treturn intersectSphere(s, ray);    \n        }\n   \t\telse\n        {\n            Sphere s = Sphere(capsule.endRadius, capsule.end);\n            return intersectSphere(s, ray);   \n        } \n    }\n    \n    float sideB = sqrt(whatever);\n    float changeInThicknessWithLength = changeInRadiusWithLength / sideB;\n    \n    float radiusToThickness = changeInThicknessWithLength/changeInRadiusWithLength;\n    float startThickness = capsule.startRadius * radiusToThickness;\n    float endThickness = capsule.endRadius * radiusToThickness;\n    \n    if((coneLength+capsule.endRadius) < capsule.startRadius)\n    {\n    \tSphere s = Sphere(capsule.startRadius, capsule.start);\n    \treturn intersectSphere(s, ray);    \n    }\n    if((coneLength+capsule.startRadius) < capsule.endRadius)\n    {\n    \tSphere s = Sphere(capsule.endRadius, capsule.end);\n    \treturn intersectSphere(s, ray);    \n    }\n    \n    float c = lengthSqr(relativeOrigin)\n            - square(dot(relativeOrigin, coneDirection))\n            - square(dot(relativeOrigin, coneDirection*changeInThicknessWithLength))\n            - square(startThickness) \n            - 2.0*changeInThicknessWithLength*startThickness*dot(relativeOrigin, coneDirection);\n\n    float b = 2.0*dot(relativeOrigin, rayDirection)\n            - 2.0*dot(relativeOrigin, coneDirection)*dot(rayDirection, coneDirection)\n            - 2.0*dot(relativeOrigin, coneDirection*changeInThicknessWithLength)*dot(rayDirection, coneDirection*changeInThicknessWithLength)\n            - 2.0*changeInThicknessWithLength*startThickness*dot(rayDirection, coneDirection);\n\n    float a = 1.0\n            - square(dot(rayDirection, coneDirection))\n            - square(dot(rayDirection, coneDirection*changeInThicknessWithLength));\n        \n    float det = b*b - 4.*a*c;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return noHit;\n    \n    vec3 relativeRayHit = ray.origin + t*ray.direction - capsule.start;\n    float actualDistanceOfPointAlongAxis = dot(relativeRayHit, coneDirection);\n    float distanceOfPointAlongAxis = actualDistanceOfPointAlongAxis;//square(fract(iTime * 0.25 / coneLength)) * coneLength;//dot(relativeRayHit, coneDirection);\n    \n    \n    float thicknessAtPoint = distanceOfPointAlongAxis * changeInThicknessWithLength + startThickness;\n    \n    Hit hit1;\n    \n    if(actualDistanceOfPointAlongAxis < distanceOfPointAlongAxis)\n    {\n    \thit1 = Hit(t*0.25, vec3(1));    \n    }\n    else\n    {\n    \thit1 = Hit(t, vec3(-1));  \n    }\n    \n    float distanceOfSphereAlongAxis = distanceOfPointAlongAxis + (thicknessAtPoint * changeInRadiusWithLength / sideB);\n    \n    distanceOfSphereAlongAxis = clamp(distanceOfSphereAlongAxis, 0.0, coneLength);\n\n    float sphereRadius = distanceOfSphereAlongAxis * changeInRadiusWithLength + capsule.startRadius;\n\n    Sphere s = Sphere(sphereRadius, capsule.start + coneDirection * distanceOfSphereAlongAxis);\n    \n    Hit hit2 = intersectSphere(s, ray);\n    hit2.distance *= 0.5;\n    swapIfCloser(hit1, hit2);\n    \n    return hit2;\n}\n\nHit intersectHeightPlane(HeightPlane plane, Ray ray, sampler2D heightMap, vec2 heightMapSize)\n{\n    Ray origRay = ray;\n    mat4x4 worldToLocal = inverse(plane.localToWorld);\n\n    ray.origin = (worldToLocal * vec4(ray.origin, 1)).xyz; \n    ray.direction = normalize((worldToLocal * vec4(ray.direction, 0)).xyz); \n\n    Plane maxPlane = Plane(-1.0, vec3(0,0,1));\n    Plane minPlane = Plane( 0.0, vec3(0,0,1));\n    \n    Hit maxHit = intersectPlane(maxPlane, ray);\n    Hit minHit = intersectPlane(minPlane, ray);\n    \n    \n    //if(maxHit == noHit || minHit == noHit)\n    //    return noHit;\n    \n    float nearDist = min(minHit.distance, maxHit.distance);\n    float farDist  = max(minHit.distance, maxHit.distance);\n    \n    if(farDist < 0.0)\n        return noHit;\n        \n    if(nearDist < 0.0)\n        nearDist = 0.0;\n        \n    //return maxHit;\n    \n    //vec3 nearHit = ray.origin + ray.direction * nearDist;\n    //vec3 farHit = ray.origin + ray.direction * farDist;\n    \n    vec3 hitPos;\n    \n    \n    bool hit = false;\n    float increment = max(0.00001, 0.0001 / abs(nearDist-farDist));\n    for(float i = 0.0; i <= 1.0; i += increment)\n    {\n        float marchDist = mix(nearDist, farDist, i);\n        hitPos = ray.origin + ray.direction * marchDist;\n        \n        vec2 uv = hitPos.xy;\n        float depth = textureLod(heightMap, uv + plane.uvOffset, 0.0).r*1.0 - 1.0;\n        \n        if(hitPos.z <= depth)\n        {\n            hitPos.z = depth;\n            farDist = marchDist;\n            hit = true;\n            break;\n        }\n        else\n        {\n            nearDist = marchDist;\n        }\n    }\n    \n    if(!hit) return noHit;\n    \n    farDist = (nearDist + farDist) * 0.5;\n    float stepSize = (farDist - nearDist) * 0.5;\n    for(int i = 0; i < 12; i++, stepSize *= 0.5)\n    {\n        hitPos = ray.origin + ray.direction * farDist;\n        \n        vec2 uv = hitPos.xy;\n        float depth = textureLod(heightMap, uv + plane.uvOffset, 0.0).r - 1.0;\n        \n        if(hitPos.z > depth)\n        {\n            nearDist = farDist;\n            farDist += stepSize;\n        }\n        else\n        {\n            hitPos.z = depth;\n            farDist -= stepSize;\n        }\n    }\n    \n    ray = origRay;\n    \n    const float sampleSpacing = 0.5;\n    vec4 uvOffset = vec4(-sampleSpacing, -sampleSpacing, sampleSpacing, sampleSpacing) / heightMapSize.xyxy;\n    \n    vec3 p00, p10, p01, p11;\n    p00 = vec3(hitPos.xy + uvOffset.xy, 0);\n    p10 = vec3(hitPos.xy + uvOffset.zy, 0);\n    p01 = vec3(hitPos.xy + uvOffset.xw, 0);\n    p11 = vec3(hitPos.xy + uvOffset.zw, 0);\n    \n    p00.z = textureLod(heightMap, p00.xy + plane.uvOffset, 0.0).r - 1.0;\n    p10.z = textureLod(heightMap, p10.xy + plane.uvOffset, 0.0).r - 1.0;\n    p01.z = textureLod(heightMap, p01.xy + plane.uvOffset, 0.0).r - 1.0;\n    p11.z = textureLod(heightMap, p11.xy + plane.uvOffset, 0.0).r - 1.0;\n    \n    p00 = (plane.localToWorld * vec4(p00, 1)).xyz;\n    p10 = (plane.localToWorld * vec4(p10, 1)).xyz;\n    p01 = (plane.localToWorld * vec4(p01, 1)).xyz;\n    p11 = (plane.localToWorld * vec4(p11, 1)).xyz;\n    \n    Hit outHit;\n    outHit.normal = cross(p11 - p00, p01 - p10);\n    \n    hitPos = (plane.localToWorld * vec4(hitPos, 1)).xyz; \n    outHit.normal = normalize(outHit.normal);\n    outHit.distance = dot(hitPos - ray.origin, ray.direction);\n    \n    return outHit;\n}\n\nvec2[4] getMSAACoords()\n{\n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n    return msaa;\n}\n\nRay uvToRay(vec2 uv, float aspect, float zoom, vec2 offset)\n{\n    uv = uv * vec2(2.0) - 1.0;\n    uv.x *= aspect;\n    uv += offset;\n    return Ray(vec3(0), normalize(vec3(uv,zoom)));\n}\n\n#define render(color, scene, camtf, frag, res, zoom, msaa, count, data)\\\n{\\\n    color = vec3(0.);\\\n    vec2 r = res;\\\n    vec2 f = frag;\\\n    vec2 uv = f / r;\\\n    const int c = count;\\\n    vec2[c] m = msaa;\\\n    float weight = 1.0 / float(c);\\\n    for (int i = 0; i < c; ++i)\\\n    {\\\n        Ray r = uvToRay\\\n        (\\\n            uv,\\\n            r.x/r.y,\\\n            zoom,\\\n            m[i] / r.y\\\n        );\\\n        r = camtf(r,f,data);\\\n        color += scene(r,f,data);\\\n    }\\\n    color *= weight;\\\n}\nvec2 conv2(vec2 samples[9], float weights[9])\n{\n    vec2 result;\n    for(int i = 0; i < 9; i++)\n    {\n        result += samples[i] * weights[i];\n    }\n    \n    return result;\n}\nvec3 conv3(vec3 samples[9], float weights[9])\n{\n    vec3 result;\n    for(int i = 0; i < 9; i++)\n    {\n        result += samples[i] * weights[i];\n    }\n    \n    return result;\n}\n\nvec2 sqrtComplex(vec2 z) {\n    float magnitude = sqrt(z.x * z.x + z.y * z.y); // |z|\n    float x = sqrt((magnitude + z.x) / 2.0);\n    float y = z.y / (2.0 * x);\n    return vec2(x, y); // Returns one of the square roots\n}\n", "buffer_a_code": "// Gradient\n\nvec4 getColor(vec2 uv)\n{\nreturn texture(iChannel0, uv);\n    return vec4(sin(length(uv-vec2(0.5f))*100.0)); //texture(iChannel0, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 uvAndOffset = vec4(fragCoord,1,1) / iChannelResolution[0].xyxy;\n    \n    vec3 samples[9];\n    int i = 0;\n    for(int y = -1; y <= 1; y++)\n    for(int x = -1; x <= 1; x++)\n    {\n        samples[i] = getColor(uvAndOffset.xy + uvAndOffset.zw * vec2(x,y)).rgb;\n        i++;\n    }    \n    \n    const float hKern[9] = float[9]\n    (\n        -1. / 8., 0., 1. / 8.,\n        -2. / 8., 0., 2. / 8.,\n        -1. / 8., 0., 1. / 8.\n    );\n    \n    const float vKern[9] = float[9]\n    (\n         1. / 8., 2. / 8., 1. / 8.,\n         0., 0., 0.,\n        -1. / 8.,-2. / 8.,-1. / 8.\n    );\n\n    vec3 h = conv3(samples, hKern);\n    vec3 v = conv3(samples, vKern);\n    \n    vec2 vec = vec2( dot(h,vec3(1)), dot(v,vec3(1)) );\n     \n    fragColor = vec4(safeNormalize(vec), length(vec), 1);\n}", "buffer_a_inputs": [{"id": 8, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec2 squareNormalized(vec2 x) {\n    float new_x = x.x * x.x - x.y * x.y;\n    float new_y = 2.0 * x.x * x.y;\n    return vec2(new_x, new_y);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    vec4 uvAndOffset = vec4(fragCoord,1,1) / iChannelResolution[0].xyxy;\n    \n    vec2 samples[9];\n    int i = 0;\n    for(int y = -1; y <= 1; y++)\n    for(int x = -1; x <= 1; x++)\n    {\n        samples[i] = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2(x,y)).xy;\n        i++;\n    }    \n    \n    const float hKern[9] = float[9]\n    (\n        -1. / 8., 0., 1. / 8.,\n        -2. / 8., 0., 2. / 8.,\n        -1. / 8., 0., 1. / 8.\n    );\n    \n    const float vKern[9] = float[9]\n    (\n         1. / 8., 2. / 8., 1. / 8.,\n         0., 0., 0.,\n        -1. / 8.,-2. / 8.,-1. / 8.\n    );\n\n    vec2 h = conv2(samples, hKern);\n    vec2 v = conv2(samples, vKern);\n    \n    /*vec2 c  = texture(iChannel0, uvAndOffset.xy                               ).xy;\n    vec2 hp = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2( 1, 0)).xy;\n    vec2 hn = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2(-1, 0)).xy;\n    vec2 vp = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2( 0, 1)).xy;\n    vec2 vn = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2( 0,-1)).xy;\n     \n    vec2 h = hp-hn;\n    vec2 v = vp-vn;*/\n     \n    fragColor = vec4((squareNormalized(safeNormalize(samples[4].xy))), sqrt(dot(h,h) + dot(v,v)), 1);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define TECHNIQUE 1\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if TECHNIQUE == 0\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 dir = texture(iChannel0, uv).xy / iResolution.xy;\n    \n    float center = texture(iChannel0, uv).z;\n    float pos = texture(iChannel0, uv + dir).z;\n    float neg = texture(iChannel0, uv - dir).z;\n    \n    fragColor = vec4(vec3(max(0., center * 2. - pos - neg)), 1);\n#elif TECHNIQUE == 1    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvWithOffset = uv;\n    \n    uint rngState = uint\n    (\n        uint(iFrame) * uint(1973) \n    ) | uint(1);\n    \n    // Using time-varying blue noise as subpixel offsets \n    // will kill persistent moire patterns.\n    // If you modify the shader to accumulate,\n    // it'll converge on a nice image with no aliasing.\n    // (It uses gaussian windowing, not an ideal lowpass filter however.)\n    vec4 blueNoise = sampleBlueNoise(iChannel2, fragCoord, rngState);\n    uvWithOffset += uniform01ToGauss(blueNoise.xy) * 0.5 / iResolution.xy; \n    \n    vec2 dir = sqrtComplex(safeNormalize(texture(iChannel0, uvWithOffset).xy));\n    dir.x = -dir.x;\n    vec2 uvOffs = dir / iResolution.xy;\n    float center = texture(iChannel0, uvWithOffset).z;\n    float pos = texture(iChannel0, uvWithOffset + uvOffs).z;\n    float neg = texture(iChannel0, uvWithOffset - uvOffs).z;\n    \n    \n    vec2 posGrad = safeNormalize(texture(iChannel1, uvWithOffset + uvOffs).xy);\n    vec2 negGrad = safeNormalize(texture(iChannel1, uvWithOffset - uvOffs).xy);\n    \n    posGrad.x = -posGrad.x;\n    negGrad.x = -negGrad.x;\n    float posSign = dot(posGrad, dir);\n    float negSign = dot(negGrad, -dir);\n    \n    float val = (posSign + negSign) >= 0. ? 1. : -1.;\n    \n    \n    fragColor = texture(iChannel3, uv) + vec4(vec3(center > pos && center > neg ? val : 0.), 1);\n#endif\n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcKGz1.jpg", "time_retrieved": "2024-04-28T18:59:28.834941", "access": "api", "wgpu-test": "error"}
{"id": "4fG3RW", "name": "Gyroid Mitosis", "author": "itishappy", "description": "boy do I love oscillatory structures", "tags": ["gyroid", "phase", "biblicallyaccurate"], "image_code": "# define PI 3.141592\n\nfloat gyroid( vec3 v ) {\n    return dot(sin(v), cos(v.yzx));\n}\n\nfloat wave( vec2 v, float t ) {\n    return gyroid(vec3(3. * v, length(12. * v) - t));\n}\n\nvoid mainImage( out vec4 col, in vec2 coord ) {\n    vec2 r = iResolution.xy,\n         v = (2. * coord - r) / min(r.x, r.y);\n    \n    float t = iTime,\n          i, d, s, a;\n    \n    for (i; i < 6.; i++) {\n        d = mod(i, 2.) * 2. - 1.;\n        s += wave(v - vec2(cos(i), sin(i)), d * t);\n    }\n    \n    a = 1.1 * cos(1620. * exp(.0001 * s * s));\n    \n    col.xyz = a * a * a * a * (.5 + .5 * cos(t + v.xyx + vec3(0, 2, 4)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fG3RW.jpg", "time_retrieved": "2024-04-28T18:59:28.837933", "access": "api", "wgpu-test": "ok"}
{"id": "4ct3Rj", "name": "speedometers", "author": "LLB", "description": "Some simple meters", "tags": ["draft", "meter", "speedometer"], "image_code": "const float PI = acos(-1.);\n\n\nvec3 meter(vec2 uv, float value) {\n    float lines = smoothstep(0.3, 0.4, mod(uv.y, 0.02)/0.02);\n    vec3 baseCol = mix(vec3(1, 1, 0), vec3(1, 0, 0), uv.y);\n    baseCol = mix(baseCol, vec3(0.3, 0, 0), smoothstep(value-0.001, value, uv.y));\n    vec3 col = lines * baseCol;\n    return col;\n}\n\nfloat rect(vec2 uv, float x1, float y1, float x2, float y2) {\n  return float(uv.x > x1 && uv.x < x2 && uv.y > y1 && uv.y < y2);\n}\n\nfloat segment(vec2 uv, vec2 A, vec2 B, float r) \n{\n    vec2 g = B - A;\n    vec2 h = uv - A;\n    float d = length(h - g * clamp(dot(g, h) / dot(g,g), 0.0, 1.0));\n\treturn smoothstep(r, 0.5*r, d);\n}\n\nvec3 meter2(vec2 uv, float value) {\n  float len = length(uv);\n  float angle = atan(uv.y, uv.x);\n  float outer = 1. - smoothstep(0.01, 0.015, abs(len-0.1));\n  \n  float sh = outer * smoothstep(0.007, 0.011, abs(len-0.1));\n  sh += outer * smoothstep(0.9, 0.95, mod(degrees(angle), 18.)/18.);\n  \n  sh *= smoothstep(0., 1., degrees(angle) + 38.);\n\n  vec3 baseCol = mix(vec3(1, 1, 0), vec3(1, 0, 0), 1. - angle/4.);\n\n  value = (value * 1.2 - 0.5) * PI;\n  vec2 point = vec2(sin(value), cos(value)) * 0.1;\n  vec3 line = segment(uv, vec2(0), point, 0.005) * vec3(0, 0, 1);\n\n  return sh * baseCol + line;\n}\n\nvec3 meter3(vec2 uv, float value) {\n    uv.y *= 1. - smoothstep(0., 1., uv.x);\n    float r = rect(uv, 0., 0., 0.5, 0.05);\n    value *= 0.5;\n\n    float lines = smoothstep(0.3, 0.4, mod(uv.x, 0.02)/0.02);\n    vec3 baseCol = mix(vec3(1, 1, 0), vec3(1, 0, 0), uv.x*2.);\n    baseCol = mix(baseCol, vec3(0.3, 0, 0), smoothstep(0., 0.001, uv.x - value));\n    vec3 col = lines * baseCol;\n    return r * col;\n}\n\nvec3 meter4(vec2 uv, float value) {\n  float len = length(uv);\n  float angle = atan(uv.y, uv.x);\n\n  float lines =\n    smoothstep(0.7, 1., mod(angle, 0.25)/0.25) *\n    smoothstep(0., 0.01, abs(angle + 0.7) - 0.7) * // hide bottom-right\n    smoothstep(0., 0.01, 0.1 - length(uv)) *\n    smoothstep(0., 0.01, length(uv) - 0.06);\n\n  value = (value * 1.5 - 1.) * PI;\n  vec2 point = vec2(sin(value), cos(value)) * 0.07;\n  float line = segment(uv, vec2(0), point, 0.003);\n\n  vec3 col = vec3(0.1, 0.1, 0.8) * lines;\n  col += vec3(0.9, 0.6, 0.9) * line;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 col = vec3(1,0,0);\n\n    vec2 uv2 = uv;\n    uv2.x += 0.2*cos(3.*pow(uv.y, 1.5));\n    float r = rect(uv2, 0.2, 0., 0.3, 1.);\n    col = r * meter(uv2, 0.5+0.5*sin(iTime*4.));\n    \n    r = rect(uv2, 0.5, 0., 0.6, 1.);\n    col += r * meter(uv2, 0.5+0.5*sin(iTime*4.+0.5));\n\n\n    col += meter2(uv-vec2(0.85,0.4), 0.5+0.5*sin(iTime));\n\n    col += meter3(uv - vec2(0.6, 0.15), 0.5+0.5*sin(iTime*3.+1.5));\n\n    col += meter4(uv - vec2(1.3, 0.3), 0.5+0.5*sin(iTime*2.+1.5));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ct3Rj.jpg", "time_retrieved": "2024-04-28T18:59:29.063330", "access": "api", "wgpu-test": "error"}
{"id": "McK3zh", "name": "Radiation Therapy", "author": "wyatt", "description": "Radiation can be columnated more than the resolution of the screen, resulting in straighter beam. ", "tags": ["waves", "physics", "cancer"], "image_code": "Main {\n\n    Q = A(U).xywz;\n    ;\n   \n\n    Q = C(U)+.1*B(U).x-2.*C(U)*B(U).x*vec4(.5,1,.5,0);\n\n\n    //Q = abs(A(U).wwww)*length(A(U).xy);\n\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "Main {\n    \n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n\n    \n    Q.x += .5*(s.w-n.w);\n    Q.y += .5*(e.w-w.w);\n\n    if (U.x < 1.||R.x-U.x<1.||R.y-U.y<1.||U.y<1.) Q *= 0.;\n\n}", "buffer_a_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "Main {\n    \n    Q = A(U);\n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n\n    \n    Q.w -= .5*(n.x-s.x-e.y+w.y);\n    Q.xy *= 1.-.1*B(U).x*length(Q.xy)*abs(Q.w);\n    \n    if (U.y < .7*R.y\n        &&U.y>.3*R.y&&U.x<3.) \n    for (float i = 0.; i < 5.; i++) \n        Q.w += 2.*cos(U.x+3.14159*i/5.*float(iFrame));\n        \n     if (U.x < .3*R.x&&U.y>.25*R.y&&U.y<.75*R.y&&abs(U.y-.5*R.y)>.05*R.y)\n         Q *= 0.;\n    \n\n\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define Main void mainImage(out vec4 Q, in vec2 U)\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\nfloat ln (vec2 p, vec2 a, vec2 b) { \n    return length(p-a-(b-a)*clamp(dot(p-a,b-a)/dot(b-a,b-a),0.,1.));\n}", "buffer_c_code": "Main {\n    if (iFrame >1) discard;\n    U = 6.*(U-.5*R)/R.y;\n    U -= vec2(2.5,-.5);\n    U = U.yx;\n    U.y = abs(U.y);\n    Q = vec4(0);\n    float a = -.5;\n    U.xy *= mat2(cos(a),sin(a),-sin(a),cos(a));\n    float l = length(U-vec2(-.1,.5));\n    Q += .5*smoothstep(.05,0.03,abs(l-1.4));\n    Q += .2*smoothstep(.1,.05,l-1.4);\n    for (float i = 3.; i < 20.; i++) {\n        \n        Q += smoothstep(.05*i,.05,ln(U,vec2(0,0),vec2(0,.5)))/(i);\n        \n        U.x = abs(U.x);\n        U.y -= .5;\n        \n        float a = -.5-.02*i;\n        \n        U.xy *= (1.5-.02*i)*mat2(cos(a),sin(a),-sin(a),cos(a));\n        \n        \n        \n    }\n    \n    \n\n}", "buffer_c_inputs": [], "buffer_d_code": "Main {\n    Q = B(U)*.999;\n    vec4 a = A(U);\n    \n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,1));\n    vec4 w = A(U-vec2(1,0));\n    \n    a = .25*(n+e+s+w);\n    Q += .01*length(a.xy*a.w);\n\n}", "buffer_d_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McK3zh.jpg", "time_retrieved": "2024-04-28T18:59:29.064327", "access": "api", "wgpu-test": "incomplete"}
{"id": "4ft3Ds", "name": "Biblically Accurate Angel", "author": "codeinsilence", "description": "Raymarched geometry used to create an \"Angel\", an eyeball surrounded by golden rings, flying through the sky.", "tags": ["raymarching"], "image_code": "#define NUM_LOOPS 500\n#define MAX_DIST 100.0\n#define MIN_STEP 0.001\n\n// Scene distance\nSurface map(vec3 p, vec2 fragCoord) {\n\n     // SPHERE(S) TO BE USED ON THE RINGS\n     vec3 q_sph = p;     \n     float spiral_rate = 10.0;\n     float spiral_width = 20.0;\n     q_sph.x += spiral_width*cos(spiral_rate*iTime);\n     q_sph.y += spiral_width*sin(spiral_rate*iTime);\n     q_sph.z -= spiral_rate*iTime;\n     q_sph = fract(q_sph/2.0) - 0.5;\n     vec3 sphere_pos = vec3(0,0,0);\n     float sphere_dist = sdSphere(q_sph - sphere_pos, 0.1);\n     Surface sphere = Surface(sphere_dist, WHITE);\n \n    // === PART I: CREATING THE EYE ===\n    // SPHERE EYEBALL\n    vec3 q = p;\n    //q = fract(q/2.0) - 0.5;\n    vec3 eyelid_pos = vec3(0,0,0);\n    float eyelid_dist = sdSphere(q - eyelid_pos, 1.0);\n    Surface eyelid = Surface(eyelid_dist, FLESH);\n\n    //SOLID ANGLE INTERSECTION TO MAKE \"WHITE\" OF THE EYE\n    vec3 eyeball_pos = eyelid_pos;\n    float eyeball_radian = PI/3.0;\n    vec3 q_1 = p;\n    vec3 q_2 = p;\n    float diff = 0.55 - 0.01 * (1.0 - (0.5 * sin(iTime) + 0.5)); // 0.45\n    q_1.yz *= rot2D(HALF_PI - diff);\n    q_2.yz *= rot2D(HALF_PI + diff);\n    q_1.xy *= rot2D(0.5 * sin(iTime));\n    q_2.xy *= rot2D(0.5 * sin(iTime));\n    float eyeball_1 = sdSolidAngle(q_1 - eyeball_pos, vec2(sin(eyeball_radian),cos(eyeball_radian)), 1.001);\n    float eyeball_2 = sdSolidAngle(q_2 - eyeball_pos, vec2(sin(eyeball_radian),cos(eyeball_radian)), 1.001);\n    \n    Surface eyeball_visible = Surface(opIntersection(eyeball_1, eyeball_2), WHITE);\n    \n    // SOLID ANGLE TO MAKE THE IRIS OF THE EYE\n    vec3 iris_pos = eyelid_pos;\n    float iris_radian = PI/8.0;\n    vec3 q_iris = p;\n    q_iris.yz *= rot2D(HALF_PI);\n    q_iris.xy *= rot2D(sin(iTime));\n    float iris_dist = sdSolidAngle(q_iris - iris_pos, vec2(sin(iris_radian),cos(iris_radian)), 1.002);\n    Surface iris = Surface(iris_dist, LIGHT_GREEN);\n    \n    // SOLID ANGLE TO MAKE THE PUPIL OF THE EYE\n    vec3 pupil_pos = eyelid_pos;\n    float pupil_radian = PI/16.0;\n    vec3 q_pupil = p;\n    q_pupil.yz *= rot2D(HALF_PI);\n    q_pupil.xy *= rot2D(sin(iTime));\n    float pupil_dist = sdSolidAngle(q_pupil - pupil_pos, vec2(sin(pupil_radian),cos(pupil_radian)), 1.003);\n    Surface pupil = Surface(pupil_dist, BLACK);\n    \n    // Output color of the mapping\n    Surface eye_surface = minWC(pupil, minWC(iris, minWC(eyeball_visible, eyelid)));\n    \n    // === PART II: CREATING THE RINGS ===\n    #define RING_SPEED 0.15\n    //INNER TORUS\n    vec3 torus_pos = vec3(0,0,0);//vec3(0,time_scale*cos(time_speed*(iTime)),6);\n    vec3 q_tor = p;\n    q_tor.yz *= rot2D(2.0 * PI * (RING_SPEED * iTime));\n    //q_tor.xy *= rot2D((cos(0.05*iTime)+iTime) + PI);\n    //q_tor += fract(p/2.0) - 0.5;\n    float torus_dist = sdTorus(q_tor - torus_pos, vec2(2.25,0.075));\n    Surface tor_in = Surface(torus_dist, GOLD);\n    //INNER TORUS 2\n    q_tor.yz *= rot2D(PI/2.0);\n    torus_dist = sdTorus(q_tor - torus_pos, vec2(2.25,0.075));\n    Surface tor_in_2 = Surface(torus_dist, GOLD);\n    \n    //OUTER TORUS\n    q_tor = p;\n    q_tor.yz *= rot2D(2.0 * PI * 0.25);\n    q_tor.xy *= rot2D(2.0 * PI * (RING_SPEED*iTime));\n    torus_dist = sdTorus(q_tor - torus_pos, vec2(2.75,0.075));\n    Surface tor_out = Surface(torus_dist, GOLD);\n    //OUTER TORUS 2\n    q_tor.xy *= rot2D(PI/2.0);\n    torus_dist = sdTorus(q_tor - torus_pos, vec2(2.75,0.075));\n    Surface tor_out_2 = Surface(torus_dist, GOLD);\n    // smoothed together\n    Surface inner_smooth = Surface(smin(tor_in.sd, tor_in_2.sd, 0.5), GOLD);\n    Surface outer_smooth = Surface(smin(tor_out.sd, tor_out_2.sd, 0.5), GOLD);\n    \n    Surface ring_surface = minWC(outer_smooth, inner_smooth);\n\n    float ringball_dist = smin(ring_surface.sd,sphere.sd,1.0);\n    Surface ringball = Surface( opSmoothSubtraction(sphere.sd,ringball_dist,0.2),YELLOW);\n    \n    // === PART III: CREATING THE WALL ===\n    #define UV_C vec2(0.5,0.5)\n    #define WALL_SPEED 2.0\n    vec2 uv = fragCoord/iResolution.xy;\n    vec4 ichan_col = texture(iChannel0, uv);\n    vec2 sites[3] = vec2[3](\n                    UV_C + 0.5*vec2(cos(WALL_SPEED*iTime),sin(WALL_SPEED*iTime)),\n                    UV_C + 0.5*vec2(cos(WALL_SPEED * (iTime + (2.0*PI/3.0)) ),sin( WALL_SPEED *(iTime + (2.0*PI/3.0) ))),\n                    UV_C + 0.5*vec2(cos(WALL_SPEED * (iTime + (4.0*PI/3.0)) ),sin(WALL_SPEED * (iTime + (4.0*PI/3.0) )))\n                    );\n    \n    vec3 wall_col = LIGHT_BLUE;//vec3(0,0,0);\n    \n    float noise = ichan_col.r * 0.024;\n    \n    float dist_site = smin(distance(min(uv + noise,uv), sites[0]), smin(\n                        distance(min(uv + noise,uv), sites[2]),\n                        distance(min(uv + noise,uv), sites[1]), 1.0 + 0.5 * cos(iTime*3.0)\n                        ),1.0 + 0.5 * sin(iTime*3.0));\n    \n    wall_col += 3.5*dist_site*dist_site;\n    \n    //if(uv.x > 0.5){wall_col = vec3(0,1,0);}\n    \n    vec3 wall_pos = vec3(0,0,0);\n    Surface wall = Surface(\n                    sdPlane( p - wall_pos, vec3(0,0,-1), 5.0),\n                    wall_col);\n    \n    return minWC(wall, minWC(ringball,eye_surface));\n}\n\nvec3 calcNormal( in vec3 pos, in vec2 fragCoord){\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.0005;\n    float xyy = map( pos + e.xyy*eps , fragCoord).sd;\n    float yyx = map( pos + e.yyx*eps , fragCoord).sd;\n    float yxy = map( pos + e.yxy*eps , fragCoord).sd;\n    float xxx = map( pos + e.xxx*eps , fragCoord).sd;\n    return normalize( e.xyy * xyy + \n\t\t\t\t\t  e.yyx*yyx + \n\t\t\t\t\t  e.yxy* yxy+ \n\t\t\t\t\t  e.xxx*yxy );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n\n    // Initialization\n    vec3 ro = vec3(cos(iTime), sin(iTime), -5.0 + 0.5*cos(iTime + PI));         // ray origin\n    vec3 rd = normalize(vec3(uv, 1)); // ray direction\n    vec3 col = vec3(0);               // final pixel color\n\n    float t = 0.; // total distance travelled\n    \n    vec3 map_color = vec3(1,1,1);\n    float diffuse = 0.0;\n    // Raymarching\n    for (int i = 0; i < NUM_LOOPS; i++) {\n        vec3 p = ro + rd * t;     // position along the ray\n        vec3 norm = calcNormal(p, fragCoord);\n        //p.xz *= rot2D((2.0 * PI * -(iMouse.xy/iResolution.xy).x)+PI); // rotate with mouse\n        vec3 light_dir = normalize(vec3(-1,1,0));\n        diffuse = clamp( dot(norm,light_dir), 0.0, 1.0 );\n        Surface map_surface = map(p, fragCoord);\n\n        map_color = map_surface.col;\n        float d = map_surface.sd;       // current distance to the scene\n\n        t += d;                   // \"march\" the ray\n\n        if (d < MIN_STEP) break;      // early stop if close enough\n        if (t > MAX_DIST) break;      // early stop if too far\n    }\n    \n    // Coloring\n    col = map_color - vec3(t * .01);           // color based on distance\n    col += vec3(0.7) * diffuse;\n    //col += ;\n    fragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "// LIBRARY OF METHODS TO GENERATE GEOMETRY\n// Signed distance functions and their operations taken from Inigo Quilez's work\n// https://iquilezles.org/articles/distfunctions/\n// Additional functions provided by kishimisu - An introduction to Raymarching\n// https://www.youtube.com/watch?v=khblXafu7iA\n#define PI      3.141592653589793\n#define HALF_PI 1.5707964\n\n// COLORS\n#define RED vec3(1,0,0)\n#define LIGHT_GREEN vec3(0.471, 0.851, 0.514)\n#define GREEN vec3(0,1,0)\n#define BLUE vec3(0,0,1)\n#define LIGHT_BLUE vec3(0.5,0.5,1)\n#define FLESH vec3(1,0.796,0.643)\n#define GOLD vec3(0.831, 0.686, 0.217)\n#define YELLOW vec3(1, 0.89, 0.141)\n#define BLACK vec3(0,0,0)\n#define WHITE vec3(1,1,1)\n\n// === SURFACE STUFF ===\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nSurface minWC(Surface obj1, Surface obj2) {\n  if (obj2.sd < obj1.sd) return obj2; // The sd component of the struct holds the \"signed distance\" value\n  return obj1;\n}\n\n// === SIGNED DISTANCE FUNCTIONS (SDF) ===\n\n// Sphere SDF\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n// Torus SDF\nfloat sdTorus( vec3 p, vec2 t ){\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n// Plane SDF\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  // n must be normalized\n  return dot(p,n) + h;\n}\n// Solid Angle\n// c = vec2(sin(theta),cos(theta))\nfloat sdSolidAngle(vec3 p, vec2 c, float ra){\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float l = length(q) - ra;\n\tfloat m = length(q - c*clamp(dot(q,c),0.0,ra) );\n    return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\n// Revolved Vesica SDF\nfloat sdVesicaSegment( in vec3 p, in vec3 a, in vec3 b, in float w ){\n    vec3  c = (a+b)*0.5;\n    float l = length(b-a);\n    vec3  v = (b-a)/l;\n    float y = dot(p-c,v);\n    vec2  q = vec2(length(p-c-y*v),abs(y));\n    \n    float r = 0.5*l;\n    float d = 0.5*(r*r-w*w)/w;\n    vec3  h = (r*q.x<d*(q.y-r)) ? vec3(0.0,r,0.0) : vec3(-d,0.0,d+w);\n \n    return length(q-h.xy) - h.z;\n}\n\n// +++ GEOMETRIC OPERATIONS +++\n\n// UNION\nfloat opUnion( float d1, float d2 ){\n    return min(d1,d2);\n}\n// SUBTRACTION\nfloat opSubtraction( float d1, float d2 ){\n    return max(-d1,d2);\n}\n// INTERSECTION\nfloat opIntersection( float d1, float d2 ){\n    return max(d1,d2);\n}\n// EXCLUSIVE OR\nfloat opXor(float d1, float d2 ){\n    return max(min(d1,d2),-max(d1,d2));\n}\n\n// SMOOTH UNION\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n// SMOOTH SUBTRACTION\nfloat opSmoothSubtraction( float d1, float d2, float k ){\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h);\n}\n// SMOOTH INTERSECTION\nfloat opSmoothIntersection( float d1, float d2, float k ){\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h);\n}\n// ONION\nfloat opOnion( in float sdf, in float thickness ){\n    return abs(sdf)-thickness;\n}\n// ==== ROTATIONS ====\n\n// Rodrigues' rotation formula\nvec3 rot3D(vec3 p, vec3 axis, float angle){\n    return mix(dot(axis, p) * axis, p, cos(angle)) + cross(axis, p) * sin(angle);\n}\n\n// 2D rotation\nmat2 rot2D(float angle){\n    float s = sin(angle);\n    float c = cos(angle);\n    return mat2(c,-s,s,c);\n}\n\n// === OTHER METHODS ===\n\n// Smooth minimum function\nfloat smin(float a, float b, float k){\n    float h = max(k-abs(a-b),0.0)/k;\n    return min(a,b) - h*h*h*k*(1.0/6.0);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ft3Ds.jpg", "time_retrieved": "2024-04-28T18:59:29.920038", "access": "api", "wgpu-test": "ok"}
{"id": "lfKGzh", "name": "Tinkering with mandelbrot mappin", "author": "mrange", "description": "Tinkering with mandelbrot mapping", "tags": ["2d"], "image_code": "// CC0: Tinkering with mandelbrot mapping\n\n// Added a truchet variant for Paul\n//#define TRUCHET\n\n#define TIME        iTime\n#define RESOLUTION  iResolution\n#define PI          3.141592654\n#define TAU         (2.0*PI)\n#define ROT(a)      mat2(cos(a), sin(a), -sin(a), cos(a))\n\nvec3 palette(float a){\n  return (1.+(sin(vec3(0., 1., 2.)+a)));\n}\n\n// License: Unknown, author: Martijn Steinrucken, found: https://www.youtube.com/watch?v=VmrIDyYiJBA\nvec2 hextile(inout vec2 p) {\n  // See Art of Code: Hexagonal Tiling Explained!\n  // https://www.youtube.com/watch?v=VmrIDyYiJBA\n  const vec2 sz       = vec2(1.0, sqrt(3.0));\n  const vec2 hsz      = 0.5*sz;\n\n  vec2 p1 = mod(p, sz)-hsz;\n  vec2 p2 = mod(p - hsz, sz)-hsz;\n  vec2 p3 = dot(p1, p1) < dot(p2, p2) ? p1 : p2;\n  vec2 n = ((p3 - p + hsz)/sz);\n  p = p3;\n\n  n -= vec2(0.5);\n  // Rounding to make hextile 0,0 well behaved\n  return round(n*2.0)*0.5;\n}\n\n// License: Unknown, author: Matt Taylor (https://github.com/64), found: https://64.github.io/tonemapping/\nvec3 aces_approx(vec3 v) {\n  v = max(v, 0.0);\n  v *= 0.6;\n  float a = 2.51;\n  float b = 0.03;\n  float c = 2.43;\n  float d = 0.59;\n  float e = 0.14;\n  return clamp((v*(a*v+b))/(v*(c*v+d)+e), 0.0, 1.0);\n}\n\n// License: MIT, author: Inigo Quilez, found: https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat pmin(float a, float b, float k) {\n  float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);\n  return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat pmax(float a, float b, float k) {\n  return -pmin(-a, -b, k);\n}\n\nfloat pabs(float a, float k) {\n  return -pmin(a, -a, k);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat hash(vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec3 effect(vec2 p) {\n  const float MaxIter = 22.;\n#ifdef TRUCHET\n  const float zz= 0.125;\n#else\n  const float zz= 0.25;\n#endif\n  const float b = 0.1;\n  \n  vec2 op = p;\n  p.x = pabs(p.x, 0.125);  \n  p = p.yx;\n  vec3 col = vec3(0.);\n  vec2 center = vec2(-0.4, 0.);\n  vec2 c = center+p*0.5;\n  vec2 z = c;\n\n  vec2 z2;\n\n  float s = 1.;\n  float i = 0.;\n  for (; i < MaxIter; ++i) {\n    z2 = z*z;\n    float ss = sqrt(z2.x+z2.y);\n    if (z2.x+z2.y > 1E3) break;\n    s *= 2.;\n    s *= ss;\n    z = vec2(z2.x-z2.y, 2.*z.x*z.y)+c;\n  }\n\n  vec2 p2 = z/zz;\n  float a = 0.1*TIME;\n  p2 *= ROT(a);\n  p2 += sin(vec2(1., sqrt(0.5))*a*b)/b;\n\n#ifdef TRUCHET\n  float fo = 1E-3+7E-3*s*s;\n  vec2 n2 = round(p2);\n  vec2 c2 = p2-n2;\n  float h = hash(n2);\n  if (h > 0.5) c2 = vec2(c2.y, -c2.x);\n  \n  float gd0 = length(c2-0.5)-0.5;\n  float gd1 = length(c2+0.5)-0.5;\n  float gd = min(gd0, gd1);\n  gd = abs(gd);\n  gd -= fo;\n#else\n  float fo = 1E-3+s*3E-3;\n  vec2 c2 = p2;\n  hextile(c2);\n\n  float gd0 = length(c2)-0.25;\n  float gd1 = abs(c2.y);\n  const vec2 n2 = ROT(radians(60.))*vec2(0.,1.);\n  const vec2 n3 = ROT(radians(-60.))*vec2(0.,1.);\n  float gd2 = abs(dot(n2, c2));\n  float gd3 = abs(dot(n3, c2));\n  gd1 = min(gd1, gd2);\n  gd1 = min(gd1, gd3);\n  float gd = gd0;\n  gd = pmax(gd, -(gd1-0.025), 0.075);\n  gd = min(gd, gd1);\n  gd = abs(gd);\n  gd -= fo;\n#endif\n  float f = i-log2(log2(dot(z2, z2)));\n\n  if (i < MaxIter) {\n  } else {\n    float gf = 1E-2/max(gd, fo);\n#ifdef TRUCHET\n#else\n    gf *= sqrt(gf);\n#endif    \n    col += gf*palette(TIME+(p2.x-p2.y)+op.x);\n  }\n\n  col = aces_approx(col);\n  col = sqrt(col);\n  \n  return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/RESOLUTION.xy;\n  vec2 p = -1. + 2. * q;\n  p.x *= RESOLUTION.x/RESOLUTION.y;\n  vec3 col = effect(p);\n  \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lfKGzh.jpg", "time_retrieved": "2024-04-28T18:59:31.776072", "access": "api", "wgpu-test": "ok"}
{"id": "McSXDV", "name": "Funky Pattern", "author": "yonibr", "description": "Funky *and* fresh!", "tags": ["2d", "pattern"], "image_code": "#define VARY_DELTA_T\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\n#define NUM_OCTAVES 6\n#define H 0.75\n\nfloat hash(vec2 p)\n{\n    p  = fract( p*0.6180339887 );\n    p *= 25.0;\n    return fract( p.x*p.y*(p.x+p.y) );\n}\n\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = hash(p+vec2(0,0));\n\tfloat b = hash(p+vec2(1,0));\n\tfloat c = hash(p+vec2(0,1));\n\tfloat d = hash(p+vec2(1,1));\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nfloat fbm( in vec2 x)\n{    \n    float G = exp2(-H);\n    float f = 1.0;\n    float a = 1.0;\n    float t = 0.0;\n    for( int i=0; i<NUM_OCTAVES; i++ )\n    {\n        t += a*noise(f*x);\n        f *= 2.0;\n        a *= G;\n    }\n    return t;\n}\n\n\nfloat pattern(vec2 p, float m_t1, float m_t2, float y_mult)\n{\n    float t1 = cos(iTime * m_t1 * 0.3);\n    float t2 = sin(iTime * m_t2 * 0.3);\n    vec2 t1_v = vec2(t1, t1 * y_mult);\n    vec2 t2_v = vec2(t2, t2 * y_mult);\n\n    vec2 q = vec2(fbm(p + vec2(t2, t1) * 0.2), fbm(p + vec2(5.2, 1.3) * t1_v));\n    vec2 r = vec2(fbm(p + 4.0 * q + vec2(1.7, 9.2) * t2_v), fbm(p + 4.0 * q + vec2(8.3, 2.8) * t2_v));\n\n    return fbm(p + 4.0 * r);\n}\n\n\nvec3 get_background(vec2 uv, float multiplier) {\n    return normalize(\n        vec3(\n            pattern(uv, 1.0 / 58.0, 1.0 / 6.0, 2.5),\n            pattern(uv, 1.0 / 69.0, 1.0 / 5.0, 2.5),\n            pattern(uv, 1.0 / 43.0, 1.0 / 9.0, 2.5)\n        )\n    ) * multiplier;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#ifdef VARY_DELTA_T\n    float time = iTime + cos(iTime);\n#else\n    float time = iTime;\n#endif\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    vec2 uv_rot1 = rotate(uv, time);\n    vec2 uv_rot2 = rotate(uv, -time);\n    vec2 uv_rot3 = rotate(uv, time * 1.5);\n    vec2 uv_rot4 = rotate(uv, -time * 1.5);\n\n    vec3 col = vec3(0.0);\n    \n    col += vec3(0.5, 0.0, 0.0) * max(0.0, 10.0 * (0.1 - smoothstep(0.0, 0.1, abs(uv_rot1.x - uv_rot1.y))));\n    col += vec3(0.5, 0.0, 0.0) * max(0.0, 10.0 * (0.1 - smoothstep(0.0, 0.1, abs(uv_rot2.x + uv_rot2.y))));\n    col += vec3(0.4, 0.0, 0.4) * max(0.0, 10.0 * (0.1 - smoothstep(0.0, 0.1, abs(sqrt(abs(uv_rot1.x)) - abs(uv_rot1.y)))));\n    col += vec3(0.0, 0.5, 0.0) * max(0.0, 10.0 * (0.1 - smoothstep(0.0, 0.1, abs(abs(uv_rot2.x) - sqrt(abs(uv_rot2.y))))));\n    col += vec3(0.0, 0.0, 0.5) * max(0.0, 10.0 * (0.1 - smoothstep(0.0, 0.1, abs(uv.x * uv.x - uv.y * uv.y - 0.25 * abs(sin(time))))));\n    col += vec3(0.0, 0.0, 0.5) * max(0.0, 10.0 * (0.1 - smoothstep(0.0, 0.1, abs(uv.x * uv.x - uv.y * uv.y + 0.25 * abs(sin(time))))));\n    col += vec3(0.0, 0.5, 0.5) * max(0.0, 20.0 * (0.05 - smoothstep(0.0, 0.05, abs(uv.x * uv.x + uv.y * uv.y - 0.25 * abs(cos(time))))));\n\n    col += vec3(0.2, 0.8, 0.6) * max(0.0, 10.0 * (0.1 - smoothstep(0.0, 0.1, abs(pow(uv_rot3.x, 2.0) - abs(uv_rot3.y)))));\n    col += vec3(0.7, 0.7, 0.5) * max(0.0, 10.0 * (0.1 - smoothstep(0.0, 0.1, abs(abs(uv_rot4.x) - pow(uv_rot4.y, 2.0)))));\n\n    float len2 = dot(col, col);\n    if (len2 < 0.15) {\n        col += max(vec3(0.0), cos(iTime+uv.xyx+vec3(0,2,4))) * (len2 / 0.2);\n    }\n    if (dot(col, col) < 0.1) {\n        col += get_background(uv, 0.9);\n    }\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/McSXDV.jpg", "time_retrieved": "2024-04-28T18:59:31.863837", "access": "api", "wgpu-test": "ok"}
{"id": "XfK3R1", "name": "VoronoÃ¯ influence", "author": "Umbre", "description": "An approach with free entities of variable sizes. Intersections are calculated using Apollonius circles. Performance is highly dependent on the number of circles. Optimizations may be possible. Please let me know in the comments.", "tags": ["voronoi"], "image_code": "//Returns a random real number between -1 and 1.\nfloat random1(vec2 co)\n{\n    return 2.*(fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453)-0.5);\n}\nfloat random2(vec2 co)\n{\n    return 2.*(fract(sin(dot(co.xy, vec2(143.9898, 99.233))) * 5453.43758)-0.5);\n}\nvec2 randomVec(vec2 co)\n{\n    return vec2(random1(co), random2(co));\n}\n\n//distance between M and the bisector of [AB].\nfloat dist_mediatrice(vec2 A, vec2 B, vec2 M)\n{\n    vec2 dir = B-A;\n    dir = vec2(dir.y,-dir.x);\n    vec2 O = (B+A)/2.;\n    vec2 OM = M-O;\n    float pvect = OM.x*dir.y - OM.y*dir.x;\n    return abs(pvect)/length(dir);\n}\n\n//colors \nvec3 pal( in float t)\n{\n    return vec3(0.358, 0.028, -2.222)+ vec3(0.488, 0.585, 0.585)*sin(6.28318*(vec3(2.000, 1.000, 1.000)*t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n\n    //Number of circles\n    int n = 40;\n    //Random seed :\n    vec2 seed = vec2(-0.362,0.11);\n    \n    //Search for the center with the most influence\n    float d1 = 999.;\n    float r1;\n    vec2 p1;\n    vec2 randVec = seed;\n    \n    for(int i = 0; i < n; ++i)\n    {\n        //Construction of the circle\n        vec2 mvt_centre = randomVec(randVec);\n        float mvt_dist = 3.*random1(mvt_centre);\n        float radius = max(random2(randVec)/ 2.0,0.05);\n        vec2 point = mvt_centre + mvt_dist * vec2(cos(iTime*random1(randVec)),sin(iTime*random2(mvt_centre)));\n        \n        float delta = distance(uv, point)/radius;\n        if(delta < d1)\n        {\n            d1 = delta;\n            p1 = point;\n            r1 = radius;\n        }\n        //New random vector\n        randVec = randomVec(randVec);\n    }\n    \n    //Search for the nearest boundary\n    randVec = seed;\n    float d2 = abs(r1 - distance(uv,p1));\n    \n    for(int i = 0; i < n; ++i)\n    {\n        //Construction of the circle\n        vec2 mvt_centre = randomVec(randVec);\n        float mvt_dist = 3.*random1(mvt_centre);\n        float radius = max(random2(randVec)/ 2.0,0.05);\n        vec2 point = mvt_centre + mvt_dist * vec2(cos(iTime*random1(randVec)),sin(iTime*random2(mvt_centre)));\n        \n        //Distance to the Apollonius circle:\n        float k = r1/radius;\n        vec2 centerApollonius = vec2(p1.x-k*k*point.x,p1.y-k*k*point.y)/(1.-k*k);\n        float radiusApollonius = distance(p1,point)*k/abs(k*k-1.);\n        float ApolloniusDelta = abs(radiusApollonius - distance(uv,centerApollonius));\n        \n        //We handle a special case: if the two radii are equal,\n        //the Apollonius circle has an infinite radius (a line).\n        if(abs(r1-radius) <0.001)\n        {\n            ApolloniusDelta = dist_mediatrice(p1,point,uv);\n        }\n        \n        if(ApolloniusDelta < d2)\n        {\n           d2 = ApolloniusDelta;\n        }\n        //New random vector\n        randVec = randomVec(randVec);\n    }\n    \n    float grad;\n    if(distance(uv,p1)< r1)\n    {\n        grad = clamp(d2/r1,0.,1.);\n    }\n    vec3 col = pal(grad);\n    \n    //Filter for the black background\n    if(distance(col, vec3(0.358, 0.028, -2.222)) < 0.0001)\n    {\n        col = vec3(0.);\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfK3R1.jpg", "time_retrieved": "2024-04-28T18:59:32.173010", "access": "api", "wgpu-test": "ok"}
{"id": "XfK3z1", "name": "tentacles", "author": "wyatt", "description": "particles", "tags": ["particles", "physics", "forces"], "image_code": "// Fork of \"Particular Fractals\" by wyatt. https://shadertoy.com/view/XXlXD7\n// 2024-04-06 15:31:30\n\n// Fork of \" Metal\" by wyatt. https://shadertoy.com/view/l3XSDN\n// 2024-03-05 03:55:02\n\nMain\n    Q = vec4(0);\n    for (float x = -1.;x <= 1.; x++)\n    for (float y = -1.;y <= 1.; y++) {\n        vec2 u = vec2(x,y);\n        vec4 b = B(U+u);\n        for (int k = 0; k < 4; k++) if (b[k]>0.) {\n               vec2 u = _21(b[k]);\n               vec4 a = A(u);\n               Q += .25*exp(-.5*length(U-a.xy))*sin(-2.+3.*length(a.zw)+vec4(1,2,3,4));\n        }\n    }\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "vec2 R; vec4 M; float T; int I;\n#define Main void mainImage(out vec4 Q, vec2 U){UNIS\n#define UNIS R=iResolution.xy;M=iMouse;T=iTime;I=iFrame;\n#define A(U) texelFetch(iChannel0,ivec2(U),0)\n#define B(U) texelFetch(iChannel1,ivec2(U),0)\n#define C(U) texelFetch(iChannel2,ivec2(U),0)\n#define D(U) texelFetch(iChannel3,ivec2(U),0)\n\n#define G(x) 0.3989422804/std*exp(-x*x/std/std)\n\nfloat building(vec2 U) {\n    U = 2.*(U-.5*R)/R.y;\n    \n    float a = atan(U.y,U.x);\n    float l = length(U);\n    \n    return step(l-.1-.8*abs(sin(30.*a)),0.);\n    \n}\nbool cell (vec2 u) {\n    return u.x>=0.&&u.y>=0.&&u.x<1.&&u.y<1.;\n}\nfloat _12(vec2 U) {\n    U = floor(U);\n    return U.x+U.y*R.x;\n}\nvec2 _21(float i) {\n    return .5+vec2(mod(i,R.x),floor(i/R.x));\n}\nfloat G2 (float w, float s) {\n    return 0.15915494309*exp(-.5*w*w/s/s)/(s*s);\n}\n#define normaliz(v) (length(v)>0.?normalize(v):vec2(0))", "buffer_a_code": "Main\n    float bu = building(U);\n    if (bu==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n    vec4 d = D(Q.xy-.5);\n    vec2 f = vec2(0,-.03/R.y);\n    \n    for (int x=-4;x<=4;x++)\n    for (int y=-4;y<=4;y++) {\n       vec4 b = B(Q.xy+vec2(x,y)-.5);\n       for (int k = 0; k < 4; k++) if (b[k]>0.) {\n           vec2 u = _21(b[k]);\n           vec4 a = A(u);\n           vec2 r = a.xy-Q.xy;\n           float l = length(r);\n           float L = length(U-u);\n           if (l>0.){\n               if (abs(L-l)<10.) {\n                   f -= .05*r/l*(L-l);\n               }\n               f += (r/l*(\n               -10.*smoothstep(2.5,0.,length(r))\n               )+.4*(a.zw-Q.zw)*pow(dot(normaliz(a.zw-Q.zw),normalize(r)),4.)\n               ) \n               *G2(length(r),4.);\n           }\n           \n       }\n    }\n    Q.zw += f;\n    Q.xy += Q.zw;\n    \n    if (Q.y<5.) Q.w += .1;\n    if (Q.x<5.) Q.z += .1;\n    if (R.y-Q.y<5.) Q.w -= .1;\n    if (R.x-Q.x<5.) Q.z -= .1;\n\n    if (M.z>0.) Q.zw -= (M.xy-Q.xy)/(1.+dot((M.xy-Q.xy),(M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U-.5,.5*normalize(U-.5*R));\n        // if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_a_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "\nMain\n    Q = vec4(-1);\n    int i = 0;\n    for (int x=-2;x<=2;x++)\n    for (int y=-2;y<=2;y++) {\n       vec4 b = B(U+vec2(x,y));\n       for (int k = 0; k < 4; k++) if (b[k]>0.) {\n           vec2 u = _21(b[k]);\n           vec4 a = A(u);\n           if (cell(a.xy-U))\n               Q[i++] = b[k];\n           if (i>3) break;\n       }\n       if (i>3) break;\n    }\n    \n    if (I<1) Q = vec4(_12(U),0,0,0);\n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main\n    float bu = building(U);\n    if (bu==0.) {Q = vec4(0); return;}\n\n    Q = A(U);\n    vec4 d = D(Q.xy-.5);\n    vec2 f = vec2(0,-.03/R.y);\n    \n    for (int x=-4;x<=4;x++)\n    for (int y=-4;y<=4;y++) {\n       vec4 b = B(Q.xy+vec2(x,y)-.5);\n       for (int k = 0; k < 4; k++) if (b[k]>0.) {\n           vec2 u = _21(b[k]);\n           vec4 a = A(u);\n           vec2 r = a.xy-Q.xy;\n           float l = length(r);\n           float L = length(U-u);\n           if (l>0.){\n               if (abs(L-l)<10.) {\n                   f -= .05*r/l*(L-l);\n               }\n               f += (r/l*(\n               -10.*smoothstep(2.5,0.,length(r))\n               )+.4*(a.zw-Q.zw)*pow(dot(normaliz(a.zw-Q.zw),normalize(r)),4.)\n               ) \n               *G2(length(r),4.);\n           }\n           \n       }\n    }\n    Q.zw += f;\n    Q.xy += Q.zw;\n    \n    if (Q.y<5.) Q.w += .1;\n    if (Q.x<5.) Q.z += .1;\n    if (R.y-Q.y<5.) Q.w -= .1;\n    if (R.x-Q.x<5.) Q.z -= .1;\n\n    if (M.z>0.) Q.zw -= (M.xy-Q.xy)/(1.+dot((M.xy-Q.xy),(M.xy-Q.xy)));\n\n    if(I<1) {\n    \n        Q = vec4(U-.5,.5*normalize(U-.5*R));\n        // if (length(U-vec2(.9)*R)<.02*R.x) Q.zw = vec2(-2.5,-1.5);\n    }\n    \n}", "buffer_c_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "\nMain\n    Q = vec4(-1);\n    int i = 0;\n    for (int x=-2;x<=2;x++)\n    for (int y=-2;y<=2;y++) {\n       vec4 b = B(U+vec2(x,y));\n       for (int k = 0; k < 4; k++) if (b[k]>0.) {\n           vec2 u = _21(b[k]);\n           vec4 a = A(u);\n           if (cell(a.xy-U))\n               Q[i++] = b[k];\n           if (i>3) break;\n       }\n       if (i>3) break;\n    }\n    \n    if (I<1) Q = vec4(_12(U),0,0,0);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfK3z1.jpg", "time_retrieved": "2024-04-28T18:59:32.543021", "access": "api", "wgpu-test": "incomplete"}
{"id": "XfKGzh", "name": "Volumetric God Rays - starielsl", "author": "starielsl", "description": "Volumetric God Rays", "tags": ["raymarching", "godrays", "antialias"], "image_code": "#define FAR 100.\n#define STEPS 256\nfloat NEAR = .001;\n\nstruct DirectionalLight\n{\n    vec3 position;\n    float intensity;\n    vec3 color;\n};\n\nDirectionalLight light = DirectionalLight(\n    vec3(0, 0, -15),\n    1.,\n    vec3(1)\n);\n\nfloat Sphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat Scene(vec3 p, bool isLight)\n{\n     float s = Sphere(p - vec3(0, 0, -10), 1.);\n     return s;\n}\n\nbool hit = false;\nbool lightHit = false;\n\nfloat RayMarch(vec3 ro, vec3 rd, bool isLight)\n{\n    if (!isLight) hit = false;\n    else lightHit = false;\n    float ad = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        vec3 p = ro + rd * ad;\n        float d = Scene(p, isLight);\n        ad += d;\n        if (d < NEAR && !isLight) hit = true;\n        if (d < NEAR && isLight) lightHit = true;\n        if (ad > FAR || d < NEAR) break;\n    }\n    return ad;\n}\n\nvec3 GetNormal(vec3 p)\n{ \n    float d = Scene(p, true);\n    vec2 e = vec2(NEAR / 2., 0);\n    vec3 n = d - vec3(\n        Scene(p - e.xyy, true),\n        Scene(p - e.yxy, true),\n        Scene(p - e.yyx, true)\n    );\n    return normalize(n);\n}\n\nvec3 GetLight(vec3 p, vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(.05);\n    DirectionalLight l = light;\n    vec3 ld = normalize(l.position - p); \n    vec3 n = GetNormal(p);\n    float dif = dot(n, ld);\n    dif = clamp(dif, 0., 1.) * l.intensity;\n        \n    float d = RayMarch(p + n * NEAR * 2., ld, true); \n    if (d < length(l.position - p)) dif *= .1;\n\n    color = mix(color, l.color, dif);\n        \n    vec3 np = normalize(p);\n    vec3 nl = normalize(l.position);\n    float dpl = .01 / length(nl - np);\n    if (!hit || length(l.position - ro) < length(p - ro)) color += dpl * l.color;\n    else color += .04;\n    \n    vec3 nld = normalize(l.position - normalize(p));\n    if (!hit)\n    { // God Rays by andrew741\n        float total_density = 0.;\n        float maxDistance = 10.;\n        int steps = 256;\n        float step_size_f = maxDistance / float(steps);\n        vec3 step_size = rd * step_size_f;\n        vec3 dp = ro;\n        for (int s = 0; s < steps; s++)\n        {\n            vec3 srp = dp;\n            float slrd = 0.;\n            for (int sr = 0; sr < 10; sr++)\n            {\n                float dst = Scene(srp, true);\n                srp += nld * dst;\n                slrd += dst;\n                \n                if (dst < NEAR)\n                {\n                    total_density += 0.15 * step_size_f;\n                    break;\n                }\n                else if (slrd > maxDistance) break;\n            }\n            dp += step_size;\n        }\n        \n        color += rd.y;\n        color *= exp(-total_density);\n    }\n    \n    return color;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 color = vec3(0);\n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0);\n    vec2 mo = vec2(iMouse.xy / iResolution.xy - .5);\n    if (iMouse.z < 1.) mo = vec2(.25, 0);\n    mo.x *= (iResolution.x / iResolution.y);\n    light.position += vec3(mo * abs(light.position.z), 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1));\n    for (int i = 0; i < 4; i++)\n    {\n        float d = RayMarch(ro, rd, false);\n        vec3 p = ro + rd * d;\n        vec3 light = GetLight(p, ro, rd);\n        if (i > 0 && hit) color = mix(color, light, .5); // Antialias\n        else color = light;\n        NEAR *= 2.; // Not sure if this is the best way to do it\n    }\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfKGzh.jpg", "time_retrieved": "2024-04-28T18:59:32.667686", "access": "api", "wgpu-test": "ok"}
{"id": "4cKGRh", "name": "Fork MÃ¶bius bal firebreath 620", "author": "firebreathz", "description": "Simple raymarched mÃ¶bius band with interlaced spheres, shaded with image based lighting.\n\nwith reactive lights to music", "tags": ["raymarching", "domainrepetition", "imagebasedlighting", "moebius"], "image_code": "float pi = 3.141592;\n\nvec2 r(vec2 v,float y)\n{\n    return cos(y)*v+sin(y)*vec2(-v.y,v.x);\n}\n \nvec3 textureAVG(samplerCube tex, vec3 tc) {\n    const float diff0 = 0.35;\n    const float diff1 = 0.12;\n \tvec3 s0 = texture(tex,tc).xyz;\n    vec3 s1 = texture(tex,tc+vec3(diff0)).xyz;\n    vec3 s2 = texture(tex,tc+vec3(-diff0)).xyz;\n    vec3 s3 = texture(tex,tc+vec3(-diff0,diff0,-diff0)).xyz;\n    vec3 s4 = texture(tex,tc+vec3(diff0,-diff0,diff0)).xyz;\n    \n    vec3 s5 = texture(tex,tc+vec3(diff1)).xyz;\n    vec3 s6 = texture(tex,tc+vec3(-diff1)).xyz;\n    vec3 s7 = texture(tex,tc+vec3(-diff1,diff1,-diff1)).xyz;\n    vec3 s8 = texture(tex,tc+vec3(diff1,-diff1,diff1)).xyz;\n    \n    return (s0 + s1 + s2 + s3 + s4 + s5 + s6 + s7 + s8) * 0.111111111;\n}\n\nfloat somestep(float t)\n{\n    return pow(t, 4.0);\n}\n\nvec3 smin(vec3 a, vec3 b)\n{\n    if (a.x < b.x)\n        return a;\n    \n    return b;\n}\n\nvec3 smax(vec3 a, vec3 b)\n{\n\tif (a.x > b.x)\n        return a;\n    \n    return b;\n}\n\nvec3 sinv(vec3 a)\n{\n\treturn vec3(-a.x, a.y, a.z);    \n}\n\nvec3 textureBlured(samplerCube tex, vec3 tc) {\n   \tvec3 r = textureAVG(tex,vec3(1.0,0.0,0.0));\n    vec3 t = textureAVG(tex,vec3(0.0,1.0,0.0));\n    vec3 f = textureAVG(tex,vec3(0.0,0.0,1.0));\n    vec3 l = textureAVG(tex,vec3(-1.0,0.0,0.0));\n    vec3 b = textureAVG(tex,vec3(0.0,-1.0,0.0));\n    vec3 a = textureAVG(tex,vec3(0.0,0.0,-1.0));\n        \n    float kr = dot(tc,vec3(1.0,0.0,0.0)) * 0.5 + 0.5; \n    float kt = dot(tc,vec3(0.0,1.0,0.0)) * 0.5 + 0.5;\n    float kf = dot(tc,vec3(0.0,0.0,1.0)) * 0.5 + 0.5;\n    float kl = 1.0 - kr;\n    float kb = 1.0 - kt;\n    float ka = 1.0 - kf;\n    \n    kr = somestep(kr);\n    kt = somestep(kt);\n    kf = somestep(kf);\n    kl = somestep(kl);\n    kb = somestep(kb);\n    ka = somestep(ka);    \n    \n    float d;\n    vec3 ret;\n    ret  = f * kf; d  = kf;\n    ret += a * ka; d += ka;\n    ret += l * kl; d += kl;\n    ret += r * kr; d += kr;\n    ret += t * kt; d += kt;\n    ret += b * kb; d += kb;\n    \n    return ret / d;\n}\n\n//repeat around y axis n times\nvoid rp(inout vec3 p, float n) {\n\tfloat w = 2.0*pi/n;\n\tfloat a = atan(p.z, p.x);\n\tfloat r = length(p.xz);\n\ta = mod(a+pi*.5, w)+pi-pi/n;\n\tp.xz = r*vec2(cos(a),sin(a));\n}\n\nvec3 moebius(vec3 p, vec3 q)\n{\n  float a = atan(p.z,p.x);\n  vec2 p2 = vec2(length(p.xz),p.y);\n  p2.x -= q.z;\n  p2 = r(p2, a*0.5);\n  vec2 p3 = r(p2, pi/4.0);\n  vec2 tc = vec2(p3.y,a);\n  float d = abs(p2.y)-q.x;\n  d = max(d,abs(p2.x)-q.y);\n  return vec3(d, tc);\n}\n \nvec3 dualmoebius(vec3 p)\n{\n\tfloat bandSize = 1.5;\n\tfloat radius = 5.0;\n\tfloat bandThickness = 0.75;\n\treturn smax(moebius(p, vec3(bandSize, bandThickness, radius)), sinv(moebius(p, vec3(bandSize - bandThickness, bandThickness+0.1, radius))));\n}\n \nvec3 sphere(vec3 p, float r)\n{\n    vec3 n = normalize(p);\n    vec2 tc = asin(n.xz)/pi + 0.5;\n\treturn vec3(length(p) - r, tc * 2.0);\n}\n\nvec3 spheres(vec3 p)\n{\n\trp(p, 12.0);\n\tp.x += 5.0;\n\treturn sphere(p, 0.75);\t\n}\n\nvec3 f( vec3 p )\n{\n\tvec2 mouse = vec2(sin(iTime), cos(iTime));//iMouse.xy / iResolution.xy;\n\t//p.xz = r(p.xz, mouse.x);\n\tp.yz = r(p.yz, 0.1 * iTime);\n    \n    vec3 q = p;\n\tq.xz = r(q.xz, 0.5 * iTime);\n    \n\treturn smin(sphere(p, 3.0), smin(spheres(q), dualmoebius(q)));\n}\n\nvec4 getcolor(vec3 hit, vec3 ray, vec3 normal, float t, vec3 d) \n{\n    vec4 background = vec4(texture(iChannel0, ray).xyz, 0.0);\n    if( t < 26.0 )\n    {\n        // material\n        float fresnel_pow = 2.0;\n        float fresnel_bias = 0.125;\n        float color_intensity = 1.5;\n        float roughness_bias = 1.5;\n        float roughness_coverage = 0.2;\n        float shininess = 0.6;\n        \n        vec3 color_mod = (0.5+0.5*texture(iChannel1, d.yz).rgb) * color_intensity;\n                \n        // IBL\n        vec3 ibl_diffuse = textureBlured(iChannel0,normal);\n        \n        // fresnel\n        float fresnel = fresnel_bias + (1.0 - fresnel_bias) * max(1.0 - dot(normal,-ray), 0.0);\n        fresnel = pow(fresnel,fresnel_pow);\n        \n        // surface roughness\n        float rough = (1.0 - roughness_bias) + roughness_bias * length(texture(iChannel2, d.yz * 0.1).rgb);\n        rough = 1.0 - ((1.0-rough) * smoothstep(0.4, 0.6, length(ibl_diffuse)));\n        rough *= min(1.0, pow(length(color_mod), 2.0));\n        \n        vec4 foreground = vec4(((1.0 - roughness_coverage) + roughness_coverage * rough) * ibl_diffuse * color_mod, max(0.0, min(1.0, shininess * fresnel * rough)));\n        return mix(foreground, background, smoothstep(0.0, 0.005, dot(normal, ray)));\n    } \n    else \n    {   \n        return background;\n    }\n}\n\n// ao\nfloat ao(vec3 v, vec3 n) \n{\n    const int ao_iterations = 10;\n    const float ao_step = 0.2;\n    const float ao_scale = 0.75;\n    \n\tfloat sum = 0.0;\n\tfloat att = 1.0;\n\tfloat len = ao_step;\n    \n\tfor (int i = 0; i < ao_iterations; i++)\n    {\n\t\tsum += (len - f(v + n * len).x) * att;\t\t\n\t\tlen += ao_step;\t\t\n\t\tatt *= 0.5;\n\t}\n\t\n\treturn 1.0 - max(sum * ao_scale, 0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor.xyz = vec3(0);\n    \n    vec3 q = vec3((fragCoord.xy / iResolution.xy - 0.5), 1.0); \n    q.x *= iResolution.x / iResolution.y;\n    vec3 p = vec3(0, 0.0, -10.0);\n    q = normalize(q);\n\n    p.xz = r(p.xz, 0.05*iTime);\n    q.xz = r(q.xz, 0.05*iTime);\n\n    const int reflectionCount = 3;\n    const int raymarchingSteps = 80;\n    vec3 colors[reflectionCount];\n    float factors[reflectionCount];\n    int reflections = 0;\n    for (int iter = 0; iter < reflectionCount; ++iter)\n    {\n        float t=0.;\n        vec3 d = vec3(0);\n        float steps = 0.0;\n        for (int tt=0; tt < raymarchingSteps; ++tt )\n        {\n            d = f(p+q*t);\n            t += d.x * 0.95;\n            if( !(t<=26.0)||d.x<=0.000001)\n            {\n                break;\n            }\n            steps = float(tt);\n        }\n\n        vec3 hit = p+q*t;\n\n        vec2 e = vec2(0.001, 0.00);\n        vec3 normal= vec3( f(hit + e.xyy).x - f(hit - e.xyy).x, f(hit + e.yxy).x - f(hit - e.yxy).x, f(hit + e.yyx).x - f(hit - e.yyx).x);\n        normal= normalize(normal);\n        \n        vec4 color = getcolor(hit, q, normal, t, d);\n        colors[iter] = color.rgb * (1.0 - color.w) * ao(hit, normal);\n        factors[iter] = color.w;\n        if (t >= 26.0)\n            break;\n\n        ++reflections;\n        q = reflect(q, normal);\n        p = hit + q * 0.001;   \n    }\n\n    float factor = 1.0;\n    for (int i = 0; i < reflectionCount; ++i)\n    {\n        fragColor.xyz += factor * colors[i];\n        factor *= factors[i] * 1.5;\n\n        if (i >= reflections)\n            break;        \n    }\n}", "image_inputs": [{"id": 23, "src": "/media/a/793a105653fbdadabdc1325ca08675e1ce48ae5f12e37973829c87bea4be3232.png", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "// Fork of \"Fork Vinyl Visu firebreath 917\" by firebreathz. https://shadertoy.com/view/clKGD3\n// 2023-05-22 19:50:36\n\n#define BARS 30.\n\n#define PI 3.14159265359\n\n// rotation transform\nvoid tRotate(inout vec2 p, float angel) {\n    float s = sin(angel), c = cos(angel);\n\tp *= mat2(c, -s, s, c);\n}\n\n// circle distance\nfloat sdCircle(vec2 p, float r) {\n    return length(p) - r;\n}\n\n// union\nfloat opU(float a, float b) {\n    return min(a, b);\n}\n\n// substraction\nfloat opS(float a, float b) {\n    return max(a, -b);\n}\n\n// distance function of half of an ark\n// parameters: inner radius, outer radius, angle\nfloat sdArk(vec2 p, float ir, float or, float a) {\n    \n    // add outer circle\n    float d = sdCircle(p, or);\n        \n    // substract inner circle\n    d = opS(d, sdCircle(p, ir));\n    \n    // rotate with angle\n    tRotate(p, -a * PI / 4.);\n    \n    // clip the top\n    d = opS(d, -p.y);\n    \n    // add circle to the top\n    d = opU(d, sdCircle(p - vec2((or + ir) / 1., 0.), (or - ir) / 1.));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy * 2. - 1.;\n    \n    // I wanted it to look good on my phone vertically :P\n    if (iResolution.x > iResolution.y) uv.x *= iResolution.x / iResolution.y; else uv.y *= iResolution.y / iResolution.x;\n    \n    // little white padding\n    uv *= 1.05;\n    \n    // add circles\n    float d = sdCircle(uv, 1.);\n    d = opS(d, sdCircle(uv, .15));\n    d = opU(d, sdCircle(uv, .04));\n    \n    // calculate position of the bars\n    float barsStart = .20;\n    float barsEnd = .90;\n    float barId = floor((length(uv) -barsStart) / (barsEnd - barsStart) * BARS);\n    \n    // only go forward if we're in a bar\n    if (barId >= 0. && barId < BARS) {\n        \n        float barWidth = (barsEnd - barsStart) / BARS;\n        float barStart = barsStart + barWidth * (barId + .06);\n        float barAngel = texture(iChannel0, vec2(0.6 - barId / BARS, .01)).x * .9;\n\n        // add a little rotation to completely ruin the beautiful symmetry\n        tRotate(uv, -barAngel * .9 * sin(barId + iTime));\n        \n        // mirror everything\n    \tuv = abs(uv);\n        \n        // add the bars\n        d = opS(d, sdArk(uv, barStart, barStart + barWidth / 2., barAngel));\n    }\n    \n    // use the slope to render the distance with antialiasing\n    float w = min(fwidth(d), .01);\n\tfragColor = vec4(vec3(smoothstep(-w, w, d)),1.0);\n}", "buffer_b_inputs": [{"id": 35, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "#define WAVES 16.0\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n\n\tfloat time = iTime * 1.0;\n\t\n\tvec3 color = vec3(0.0);\n\n\tfor (float i=0.0; i<WAVES + 1.0; i++) {\n\t\tfloat freq = texture(iChannel0, vec2(i / WAVES, 0.0)).x * 17.0;\n\n\t\tvec2 p = vec2(uv);\n\n\t\tp.x += i * 0.04 + freq * 0.03;\n\t\tp.y += sin(p.x * 10.0 + time) * cos(p.x * 2.0) * freq * 0.2 * ((i + 1.0) / WAVES);\n\t\tfloat intensity = abs(0.01 / p.y) * clamp(freq, 0.35, 2.0);\n\t\tcolor += vec3(1.0 * intensity * (i / 5.0), 0.5 * intensity, 3.75 * intensity) * (3.0 / WAVES);\n\t}\n\n\tfragColor = vec4(color, 1.0);\n}", "buffer_a_inputs": [{"id": 34, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cKGRh.jpg", "time_retrieved": "2024-04-28T18:59:34.188617", "access": "api", "wgpu-test": "error"}
{"id": "ftB3zh", "name": "Fork Fork Latti firebreath 050", "author": "firebreathz", "description": "A warped lattice structure, very loosely based on the 256b Puls demo by Rrrola.", "tags": ["raymarch", "warp", "edges", "lattice"], "image_code": "/*\n\n\tLattice Framework\n\t------------------\n\n\tI coded up a simple lattice the other day, complete with some joins to jazz it up a \n\tbit. At that point, I realized that it had a bit of a \"Puls 256b\" feel, so added in \n\tsome bolts to complete the process. I've never looked at the original Puls code, but \n\tit'd be interesting to see if it's more efficient. At 256 bytes, it's definitely \n\tmore compact. :)\n\n\tThe structure in this particular example is wrapped around a path then rotated about \n\tthe XY plane according to Z distance. Other than that, it's a very rudimentary scene.\n\n\tFor anyone interested, the relevant code is contained in the distance function.\n\n\t// Very cool 256b demo, and definitely worth a look, if you haven't seen it before.\n\tPuls (256b) by Rrrola\n\thttp://www.pouet.net/prod.php?which=53816\n\n\t// Cool and informative lattice example.\n\tCC / FCC / BCC Lattices - Paniq\n\thttps://www.shadertoy.com/view/llfGRj\n\n*/\n\n#define FAR 30. // Far plane, or maximum distance.\n\nfloat objID = 0.; // Object ID - Lattice: 0.; Joins: 1.; Bolts: 2..\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: http://http.developer.nvidia.com/GPUGems3/gpugems3_ch01.html\nvec3 tpl( sampler2D t, in vec3 p, in vec3 n ){\n   \n    n = max(abs(n), 0.001);\n    n /= (n.x + n.y + n.z );  \n\tp = (texture(t, p.yz)*n.x + texture(t, p.zx)*n.y + texture(t, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n\n// Camera path. Arranged to coincide with the frequency of the lattice.\nvec3 camPath(float t){\n  \n    //return vec3(0, 0, t); // Straight path.\n    return vec3(-sin(t/2.), sin(t/2.)*.5 + 1.57, t); // Windy path.\n    \n}\n\n\n// The lattice structure.\nfloat map(in vec3 p){\n    \n    // Using the Z value to offset the structure by the camera path. Pretty standard.\n    p.xy -= camPath(p.z).xy;\n    \n    // Rotating the structure about the XY plane by an angle dependent on the Z value.\n    // Also a pretty standard move that you'll see from time to time.\n\tvec2 a = sin(vec2(1.57, 0) + p.z*1.57/10.);\n    p.xy = mat2(a, -a.y, a.x)*p.xy;\n    \n    // Rounded cubes, just for fun, and to help visualize things.\n    //p = abs(fract(p) - .5);\n    //return max(p.x, max(p.y, p.z))*.7 + length(p)*.3 - .2;\n    \n    // Using repeat properties to produce the octahedral joins. There's probably a \n    // clever way to do both simultaneously, but the following works well enough.\n    vec3 q = abs(fract(p + vec3(.5, 0, .5)) - .5);\n    float joins = (q.x + q.y + q.z) - .16; // Half of the joins.\n    \n    p = abs(fract(p + vec3(0, .5, 0)) - .5);\n    joins =  min(joins, (p.x + p.y + p.z) - .16); // The other half.\n    \n    \n    // Reusing \"p\" above to produce the lattice structure. This particular one is called\n    // a body-centered lattice, which I think relates back to some form of nomenclature\n    // regarding crystalline structure. I was already familiar with the structure, but \n    // learned that it had a fancy name via Paniq's really informative shader here:\n    //\n    // CC / FCC / BCC Lattices - https://www.shadertoy.com/view/llfGRj\n    //\n    // Body-centered lattice. My take on it, anyway. I like it because it's cheap and it\n    // looks interesting. Basically, you get your money's worth. :)\n    //p = abs(p - dot(p, vec3(.333)));\n    //float lat = dot(p, vec3(.5)) - 0.034;\n    p = abs(p - (p.x + p.y + p.z)*.3333);\n    float lat = (p.x + p.y + p.z)*.8 - 0.034;\n    \n    // Bolts. Constructed by enlarging the lattice tubes and the octahedral joins, then\n    // taking the difference.\n    float bolts = max(lat - .015, -(joins - .48));\n    \n    // Object ID. Octahedral joins are blue, and the lattice itself will be white.\n    objID = step(joins, lat) + step(bolts, lat)*2.;\n    \n    // Combined objects and joins.\n    return min(min(joins, lat), bolts);\n    \n    \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cao(in vec3 p, in vec3 n)\n{\n\tfloat sca = 1., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.35/4.;        \n        float dd = map(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n\n\n// The normal function with some edge detection rolled into it.\nvec3 nr(vec3 p, inout float edge) { \n\t\n    vec2 e = vec2(.003, 0);\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*2.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 1., sqrt(edge/e.x*2.));\n\t\n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.0, h;\n    for(int i = 0; i < 128; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.001*max(t*.25, 1.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.85;\n        \n    }\n\n    return min(t, FAR);\n}\n\n\n\n// Shadows.\nfloat sha(in vec3 ro, in vec3 rd, in float start, in float end, in float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 13; \n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    for (int i=0; i<maxIterationsShad; i++){\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.0, 1.0, k*h/dist));\n\n        dist += clamp(h, 0.005, 0.16);\n        \n        // There's some accuracy loss involved, but early exits from accumulative distance function can help.\n        if (abs(h)<0.01 || dist > end) break; \n    }\n    \n    return min(max(shade, 0.) + 0.1, 1.0); \n}\n\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total.\nvec3 db( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.01, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tpl(tx, p - e.xyy, n), tpl(tx, p - e.yxy, n), tpl(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tpl(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(3. - 2.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*43758.5453), fract(sin(h + s.x)*43758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.5;\n    rd *= 2.;\n    \n    //vec3 tx = tpl(iChannel1, rd/3., sn).zyx;\n    //tx = smoothstep(0.2, 1., tx*2.); \n    //float c = dot(tx, vec3(.299, .587, .114));\n    \n    float c = n3D(rd)*.57 + n3D(rd*2.)*.28 + n3D(rd*4.)*.15; // Noise value.\n    c = smoothstep(0.1, 0.5, c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    vec3 col = vec3(min(c*1.5, 1.), pow(c, 2.5), pow(c, 12.)); // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*.5+.5); \n    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \n\t// Screen coordinates.\n\tvec2 u = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n\t// Camera Setup.\n    float speed = 0.8;\n    vec3 o = camPath(iTime*speed); // Camera position, doubling as the ray origin.\n    vec3 lk = camPath(iTime*speed + .1);  // \"Look At\" position.\n    vec3 l = camPath(iTime*speed + 1.); // Light position, somewhere near the moving camera.\n\t\n    // Light postion offset. Since the lattice structure is rotated about the XY plane, the light\n    // has to be rotated to match. See the \"map\" equation.\n    vec3 loffs =  vec3(0, 1, 0);\n    vec2 a = sin(vec2(1.57, 0) - l.z*1.57/10.);\n    loffs.xy = mat2(a, -a.y, a.x)*loffs.xy; \n    l += loffs;\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 4.14159/3.; ///3. FOV - Field of view.\n    vec3 fwd = normalize(lk-o);\n    vec3 rgt = normalize(vec3(fwd.z, 0., -fwd.x )); \n    vec3 up = cross(fwd, rgt);\n\n    // Unit direction ray.\n    vec3 r = normalize(fwd + FOV*(u.x*rgt + u.y*up));\n    // Lens distortion.\n    //vec3 r = fwd + FOV*(u.x*rgt + u.y*up);\n    //r = normalize(vec3(r.xy, (r.z - length(r.xy)*.25)));\n\n\n    // Raymarch.\n    float t = trace(o, r);\n    \n    // Save the object ID directly after the raymarching equation, since other equations that\n    // use the \"map\" function will distort the results. I leaned that the hard way. :)\n    float sObjID = objID;\n\n    // Initialize the scene color to the background.\n    vec3 col = vec3(0);\n    \n    // If the surface is hit, light it up.\n    if(t<FAR){\n    \n        // Position and normal.\n        vec3 p = o + r*t;\n        \n        float ed; // Edge variable.\n        vec3 n = nr(p, ed);\n        \n        // Texture bump the normal.\n        float sz = 2./1.;\n        n = db(iChannel0, p*sz, n, .01/(1. + t/FAR));\n\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        float d = max(length(l), 0.001); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n        \n        float at = 1./(1. + d*.25 + d*d*.1); // Light attenuation.\n        \n        // Ambient occlusion and shadowing.\n        float ao =  cao(p, n);\n        float sh = sha(p, l, 0.04, d, 8.);\n        \n        // Diffuse, specular, fresnel. Only the latter is being used here.\n        float di = max(dot(l, n), 0.);\n        float sp = pow(max( dot( reflect(r, n), l ), 0.0 ), 16.); // Specular term.\n        //float fr = clamp(1.0 + dot(r, n), 0.0, 1.0); // Fresnel reflection term.\n        \n        // Texturing the surface with some tri-planar mapping..\n        vec3 tx = tpl(iChannel0, p*sz, n); // Lattice coloring.\n        if(sObjID>1.5) tx *= vec3(1.5); // Lighten the bolts a bit.\n        else if(sObjID>.5) tx *= vec3(.5, .7, 1);// Color the joins blue.\n\n\t\t// Very simple coloring.\n        col = tx*(di + vec3(.75, .75, 1) + vec3(.5, .7, 1)*sp*3.);\n        \n        // Edges.\n        col *= 1. - ed*.7; // Darker edges.\n        //col += ed*.5; // Lighter edges.\n\n        // Fake environment mapping.\n        vec3 em = eMap(reflect(r, n), n); \n        col += col*em*2.;\n        \n        // Apply some shading.\n        col *= ao*sh*at;\n\n        \n    }\n    \n    // If we've hit the far plane, calulate \"l\" only.\n    if(t>=FAR) l = normalize(l - o - r*FAR);\n \t\n    // Produce some colored fog.\n    vec3 bg = mix(vec3(.5, .7, 1), vec3(1, .5, .6), l.y*.5 + .5);\n    col = mix(clamp(col, 0., 1.), bg, smoothstep(0., FAR-2., t));\n    \n     \n    \n    // Rough gamma correction, and we're done.\n    fragColor = vec4(sqrt(clamp(col, 0., 1.)), 1.);\n    \n    \n}", "image_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/ftB3zh.jpg", "time_retrieved": "2024-04-28T18:59:36.008747", "access": "api", "wgpu-test": "error"}
{"id": "7d2BRR", "name": "Awesome steel ball", "author": "firebreathz", "description": "Steel Spin by NuSan, PC 4k intro made for Novoque 2020", "tags": ["intro", "4k", "novoque"], "image_code": "// Steel Spin by NuSan\n// PC 4k intro made for Novoque 2020\n\n// Unfortunately, the GPU Synthesizer I made cannot be ported on shadertoy, as it uses a second audio pass to compute reverbs\n// So only soundcloud for now ...\n\n// Original Tools: Leviathan, custom GPU synth, Shader Minifier, Crinkler\n// https://www.pouet.net/prod.php?which=85684\n// https://youtu.be/OjZVSqhReqA\n\n// if sound doesn't start or seems desynchronised:\n// try clicking pause/start button in the \"soundcloud\" square in the bottom right\n// then press rewind just under the shader picture on the left\n\n///////////////////////\n// POST-PROCESS PASS //\n///////////////////////\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\t\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = frag/iResolution.xy;\n\t\n\tfloat time = iTime-2.25;\n    \n    vec3 col = texture(iChannel0, uv).xyz;\n    \n    // Bloom computation\n    vec3 cumul = vec3(0);\n\tfor(float i=-2.; i<=2.5; ++i) {\n\t\tfor(float j=-2.; j<=2.5; ++j) {\n\t\t\tvec4 cur = textureLod(iChannel1, uv + (vec2(i,j))*306./vec2(80000.,80000.), iResolution.y>7200. ? 60. : 4.);\n\t\t\tcumul += cur.xyz;\n\t\t}\n\t}\n    \n    // use more bloom for brighter values\n\tcol += cumul * clamp(dot(cumul.xyz,vec3(.01))-.3,0.,1.)*0.005;\n    \n    // 'tone mapping'\n    col = smoothstep(0.1,1.,col);\n    col = pow(col,vec3(.65));\n    \n    // fade in / fade out\n    col *= sat(time*5.) * sat(231.-time);\n\t\t\t\t\t\n\tfragColor = vec4(col, 1);\n}", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "float pi=acos(-1.);\n\nfloat sat(float t) { return clamp(t, 0.,1.); }\n\n//DAVE HOSKINS' HASH FUNCTIONS\n// we use them mainly because they don't contain any sin/cos and so should be more consistent accross hardware\n//https://www.shadertoy.com/view/4djSRW\nfloat rnd(float p)\n{\n    p = fract(p * 0.1031);\n    p *= p + 33.33;\n    return fract(2.*p*p);\n}\n\nvec3 rnd23(vec2 p)\n{\n\tvec3 p3 = fract(p.xyx * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nfloat rnd31(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat rnd21(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 rnd33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nmat2 rot(float a) {return mat2(cos(a),sin(a),-sin(a),cos(a));}", "buffer_a_code": "\n// Uncomment that value if you want to change the quality\n#define SAMPLE_COUNT 8.\n\n#define res iResolution\n\n//////////////////////\n// PATHTRACING PASS //\n//////////////////////\n\n// we use globals for most parameters, it save space\n// s is starting position, r is ray direction\n// n is normal at intersection point and d is distance to the intersection\nvec3 s,p,r;\nfloat s0,ds2;\nvec3 planen;\nfloat planediv, planedist, planewidth, planemaxdiv, planeoffset, rad1, rad2;\n\n// compute the 2 sides of a planar cut section\nvoid planecut(inout float d, inout vec3 n) {\n  float rpd = abs(dot(-p,planen)-planedist);\n  if(rpd>planediv*.5-planewidth) {\n    return;\n  }\n          \n  float dn = dot(r,planen);\n  float dwd = dot(-s,planen)-planedist;\n  dwd += sign(dn)*(planediv*.5-planewidth);\n      \n  d=dwd/dn;\n  n=planen*sign(dn);\n}\n\n// compute intersections with a sphere (size d) and it's plane cuts along axis n\nbool spheretest(inout float d, inout vec3 n) {\n  \n\tfloat c1 = rad1*rad1 - ds2;\n\tif(c1<=0.) return false;\n  \n    // compute both intersections with the sphere\n\tfloat cd1 = sqrt(c1);\n\tfloat d1a = s0-cd1;\n\tfloat d1b = s0+cd1;\n  \n    // start with the first intesection with the sphere\n\td=max(0.,d1a);\n\tp=s+r*d;\n\tn=normalize(-p);\n\n    // plane cut repetition (div) and size (dist)\n    // code is pretty messy, didn't have time to clean it up\n\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\tfloat basediv=planediv;\n\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n    \n    // compute plane cuts side with first intersection with the sphere\n\tplanecut(d,n);\n  \n\tfloat c2 = rad2*rad2 - ds2;\n\tif(c2>0.) {\n        // if we got through the first intersection, check the second one\n\t\tfloat cd2 = sqrt(c2);\n\t\tfloat d2a = s0-cd2;\n\t\tfloat d2b = s0+cd2;\n\t\tif(d2b>0. && d2a<d) {\n      \n\t\t\td=d2b;\n\t\t\tp=s+r*d;\n      \n\t\t\tfloat tmpprog = dot(p,planen)+planeoffset;\t\n\t\t\tplanediv = (basediv/(floor(rnd(floor(tmpprog/basediv))*planemaxdiv)+1.));\n\t\t\tplanedist = -((floor(tmpprog/planediv)+.5))*planediv+planeoffset;\n\n            // compute plane cuts side with second intersection with the sphere\n\t\t\tplanecut(d,n);\n\t\t}\n\t}\n  \n    // if we got through the sphere completely, show the sky\n\tif(d>d1b) {\n\t\td=10000.;\n\t\tn=vec3(0);\n\t}\n  \n\treturn true;\n}\n\nmat3 rotxy(float a) {\n\treturn mat3(cos(a),sin(a),0,-sin(a),cos(a),0,0,0,1);\n}\nmat3 rotxz(float a) {\n\treturn mat3(cos(a),0,sin(a),0,1,0,-sin(a),0,cos(a));\n}\n\nfloat tick(float t) {\n\treturn floor(t) + pow(smoothstep(0.,1.,fract(t)),10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 frag = fragCoord.xy;\n\tvec2 uv = (frag-res.xy*0.5)/res.y;\n\t\n\tfloat time = iTime-.5;\n\n\t// Main way to control the intro (camera, DOF focus, shape)\n    // Each vec3 is a section of the intro\n    // first value is the seed of the camera motionpath/speed/FOV, fractionnal part is a time offset, negative values subdivide the section in two parts\n    // second value is the focus distance for the DOF, relative to the center of the sphere\n    // third value is the shape seed and it's motion, integer value is the shape, fractionnal part is a time offset\n\tvec3 mot[17] = vec3[17]( \n\t\t\t\t\t\t vec3(4.4,5, 22.885)\n\t\t\t\t\t\t,vec3(8.1,5, 34.1)\n\t\t\t\t\t\t,vec3(-30.3,3.3, 73.1)\n\t\t\t\t\t\t,vec3(20,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(22.8,5, 59)\n\t\t\t\t\t\t,vec3(21,5, 49)\n\t\t\t\t\t\t,vec3(5,8, 22.885)\n\t\t\t\t\t\t,vec3(31,5, 76)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(2.4,5, 59.01)\n\t\t\t\t\t\t,vec3(30.6,5, 69.6)\n\t\t\t\t\t\t,vec3(-26.5,5, 6.3)\n\t\t\t\t\t\t,vec3(27,4, 78)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(28,3, 72)\n\t\t\t\t\t\t,vec3(-90,5, 34.2)\t\t\t\t\t\t\n\t\t\t\t\t\t,vec3(15,4, 6)\n\t\t\t\t\t\t,vec3(40,3, 102)\n\t\t\t\t\t\t// --------------\n\t\t\t\t\t\t,vec3(65,7, 22.8)\n\t\t\t\t\t\t);\n\n\tint section = int(time/10.);\n\tfloat rest = mod(time,10.);\n\n\tvec3 mval = mot[section];\n\n\tvec3 pcam = rnd23(vec2(round(abs(mval.x)),0.3));\n\tvec3 pshape = rnd23(vec2(round(abs(mval.z)),0.7));\n\n\t//////// MOTION ////////\n\n\tfloat avance = pcam.x*130. + (rest+(fract(mval.x+.5)-.5)*16.) * (pcam.y-0.2);\n\tif(mval.x<0. && rest>4.) avance += 200.;\n\n\tfloat camdist = sin(avance*fract(pcam.z*84.52))*5.+10.;\n\tvec3 bs=vec3(0,0,-camdist);\n\tvec3 target=vec3(sin(avance*.7)*2.,0,0);\n  \n\t//////// CAMERA ANIMATION ////////\n\n\tbs.yz*= rot(sin(avance*.1));\n\tbs.xz*= rot(avance*.1);\n\t  \n\t//////// CAMERA COMPUTE ////////\n\tvec3 cz=normalize(target-bs);\n\tvec3 cx=normalize(cross(cz,vec3(0,1,0)));\n\tvec3 cy=cross(cz,cx);\n  \n\tfloat fov = pcam.z+0.1;\n\tfloat focusdist=camdist - 0.1 + mval.y;\n\tfloat dofamount=.0001;//mval.y>0 ? .15 : .35;\n    \n\tvec3 col=vec3(0);\n  \n    // all of the code bellow is very messy as deadline was very close, sorry about that\n    \n    // light activations\n\tbool lightsky = section<1;\n\tbool lightsilver = section>17 && section<17;\n\tbool lightgreen = section>2;\n\tbool lightpink = section>10 && section<8;\n\tbool centerlight = section>0;\n\tbool strips = (section>2);\n\tbool bluelight = section >= 0;\n    bool lightawesome = section>1 && section<5;\n  \n    // special case tweaks for some sections\n\tif(section==0) rest=max(rest,2.);\n     // motion slowing down during the last section\n\tfloat t2=section!=1?time:pow(sat(rest*1.6),.5)*1.5;\n\tif(section==16) {time=1.4; rest=0.2;}\n    \n    // shape motion time\n\tfloat t = rest*pshape.x*.5 + (fract(mval.z+.4)-.5)*4.;\n    // bending of the shape during a few section\n    // we just offset the time according to the pixel uvs and it makes the shape bend without touching at the collision intersection\n\tif(section>11 && section<15) t += (uv.y*2. + sin(uv.x*5.+rest*0.3)*.5) * (section>12?sat((111.-time)*.5):pow(smoothstep(0.,1.,sin(rest*pi*4.+.1)*.5+.5),10.) * sat((time-100.)*.25));\n\t  \n    // parameters of the shape\n\tfloat rdiv = pshape.y*10.+1.;\n\tfloat roff = max(0.,fract(pshape.y*37.21)*2.-1.);\n\tif(lightpink || (section>11 && section<16)) roff += tick(time)*.5;\n\tfloat rmax = max(0.,pshape.z*8.-4.);\n\tfloat rok = fract(pshape.z*841.52)*2.-.1;\n\tfloat rrad = .3;\n\tfloat rrad2 = fract(pshape.y*74.81);\n\n\tconst int sphnumb = 10;\n\tint sphmax = 10;\n\tif(section==2) sphmax=4; // this section was too slow because very zoomed in ...\n\t  \n    // cache each sphere rotation as a matrix\n\tmat3 planemat[sphnumb];\n\tplanemat[0]=mat3(1,0,0,0,1,0,0,0,1);\n\tfor(int k=0;k<sphnumb; ++k) {\n\t\tif(k>0){\n\t\t\tplanemat[k] = planemat[k-1];\n\t\t}\n\t\tplanemat[k] *= rotxy(t);\n\t\tplanemat[k] *= rotxz(t*.9);\n\t}\n  \n    // the first part was slower, so I just reduced the sample count\n    // with just the smooth sky, there is not much noise\n\tfloat steps=section<2 ? 10. : 20.;\n    #ifdef SAMPLE_COUNT\n    \tsteps=SAMPLE_COUNT;\n    #endif\n    \n\t// Main path tracing loop, do many samples to reduce the noise\n\tfor(float i=0.1; i<steps; ++i) {\n    \n\t\ts=p=bs;\n    \t\n\t\tvec2 h = rnd23(frag-13.6-i*1084.7).xy;\n\t\t// DOF just by offsetting the rays randomly\n\t\tvec3 voff = sqrt(h.x)*(cx*sin(h.y*6.283)+cy*cos(h.y*6.283))*dofamount;\n\t\ts-=voff;\n\t\tvec2 uv2 = uv + (h.yx-.5)/res.y;\n\t\tr=normalize(uv2.x*cx+uv2.y*cy+fov*cz + voff*fov/(focusdist));\n\t\t\n\t\t        \n\t\tfloat alpha = 1.0;\n    \t// number of bounces is 3\n\t\tfor(int j=0; j<6; ++j) {\n        \n            // as all the sphere part have the same center, I can precompute some things\n\t\t\ts0 = dot(-s,r);\n\t\t\tvec3 ns = s+r*s0;\n\t\t\tds2 = dot(ns,ns);\n      \n\t\t\tplanen = normalize(vec3(0,1,0));\n      \n\t\t\tfloat d=10000.;\n\t\t\tvec3 n=vec3(0);\n\t\t\tint circ=0;\n            \n            // iterate on each sphere\n\t\t\tfor(int k1=0; k1<sphmax; ++k1) {\n        \t\tfloat k=float(k1);\n                // change settings of the repeating cut plane\n\t\t\t\tplanediv = rdiv;\n\t\t\t\tplanemaxdiv = rmax;\n\t\t\t\tplaneoffset = rnd(k+.3)*7.*roff;\n\t\t\t\tif(rok<0.) {\n\t\t\t\t\tplanewidth = 0.1+k*.1;\n\t\t\t\t} else {\n\t\t\t\t\tplanewidth = rok;\n\t\t\t\t}\n\t\t\t\trad1 = 5.-k*rrad;\n\t\t\t\trad2 = 5.-(k+rrad2)*rrad;\n        \n                // axis of the plane from the cache\n\t\t\t\tplanen = planemat[k1][1];\n                \n\t\t\t\tfloat d2=10000.;\n\t\t\t\tvec3 n2=vec3(0);\n                // if we get an intersection, early out of the loop\n\t\t\t\tif(!spheretest(d2,n2)) break;\n        \n\t\t\t\tif(d2<d) {\n\t\t\t\t\td=d2;\n\t\t\t\t\tn=n2;\n\t\t\t\t\tcirc=k1;\n\t\t\t\t}\n\t\t\t}\n      \n\t\t\t// sky sphere\n\t\t\tif(d>1000.) {\n\t\t\t\tif(lightsky) col += alpha * mix(vec3(0.6,0.8,1)*0.8, vec3(1,0.7,0.5) * 2., max(r.x+r.z*.3-r.y*.7,0.)*.7);\n\t\t\t\tif(lightpink) { \n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.x*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+rnd(floor(r.x*5.)))) * vec3(0.5,.4,1);\n                    col += alpha * smoothstep(0.5,0.3,abs(fract(r.z*5.)-.5))*smoothstep(0.8,0.9,fract(time*.5+.25+rnd(floor(r.z*5.)+7.3))) * vec3(1,.2,.3);\n\t\t\t\t}\n\t\t\t\tif(lightsilver) {\n                    vec3 ttt = rnd23(floor(r.xy*5.));\n                    col += pow(fract(floor(ttt.x*8.)/8.-time*0.25),2.) * (.7+ttt.y*vec3(.3,.5,1)+vec3(1,.5,.3)*ttt.z);\n\t\t\t\t}\n\t\t\t\tif(lightgreen) {\n\t\t\t\t\tfloat sqsize = .1;\n\t\t\t\t\tcol += alpha * smoothstep(0.4,0.1,fract(time*.5+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.1+floor(r.z*sqsize)*0.02))) * 2. * (rnd33(floor(r*sqsize)+floor(time)*.37)*.3+.7);\n\t\t\t\t}\n                if(lightawesome) {\n\t\t\t\t\tfloat sqsize = .9;\n\t\t\t\t\tcol += alpha * smoothstep(0.4,0.1,fract(time*.5+rnd(floor(r.x*sqsize)+floor(r.y*sqsize)*0.1+floor(r.z*sqsize)*0.02))) * 2. * (rnd33(floor(r*sqsize)+floor(time)*.37)*.3+.7);\n\t\t\t\t}\n\t\t\t\tbreak;\n\t\t\t}\n      \n            // go to the collision position\n\t\t\ts = s + r * d;\n            \n            // emissive lights\n            float circ2 = float(circ);\n\t\t\tif(bluelight && circ2==floor(fract(-t2*.2*3.)*10.)) col += alpha * 4. * vec3(.2,.3,1);\n\t\t\tif(centerlight && circ2==9.) col += alpha * 4. * vec3(1,.2,.3);\n      \n            // slight increase in perf, get out before computing rebound direction in the last rebound\n\t\t\tif(j==2) break;\n      \n            // get local position (rotating with the shape) depending on which sphere has been intersected\n\t\t\tvec3 localpos = s*planemat[circ];\n\t\t\tvec3 sphuv = vec3(atan(localpos.x,localpos.z)*6., localpos.y, length(localpos.xz)*.6);\n\n            // roughness compute as squares of random roughness\n\t\t\tvec3 rpos = sphuv*20.-.1;\n\t\t\tvec3 id = floor(rpos);\n\t\t\tvec3 grid = fract(rpos);\n\t\t\tfloat rough = .005*rnd31(id*27.33);\n            // stripes on the shape are just changes off roughness\n\t\t\tif(strips) rough = (fract(sphuv.x)<6.5)?.05:rough;\n\t\t\t\n            // slight offset so we get out of the surface before rebound\n\t\t\ts-=r*0.01;\n      \t\t\n            // next rebound will be a bit less bright\n\t\t\talpha *= .7;\n      \n            // random rebound direction according to roughness parameter\n\t\t\tr=normalize(reflect(r,n) + normalize(rnd23(frag+vec2(i*277.,j*375)+fract(time))-.05)*rough);      \n\t\t}\n\t}\n\tcol *= 0.7/steps;\n\n\tfragColor = vec4(col, 1);\n}", "buffer_a_inputs": [], "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/7d2BRR.jpg", "time_retrieved": "2024-04-28T18:59:36.309941", "access": "api", "wgpu-test": "incomplete"}
{"id": "lfG3zh", "name": "Ticket pointable heat map", "author": "Arkitu", "description": "C'est pas trÃ¨s beau mais c'est le mieux que j'ai pu faire", "tags": ["math"], "image_code": "vec3 palette( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 gradient( in float t)\n{\n    return palette(\n        t,\n        vec3(0.500, 0.198, 0.368),\n        vec3(0.500, 0.500, 0.228),\n        vec3(0.818, 1.488, 0.588),\n        vec3(0.388, 0.333, 1.178)\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 size = iResolution.xy - 100.;\n    //vec2 size = vec2(550., 100.);\n    vec2 pointB = iMouse.xy - 50.;\n    //vec2 pointB = vec2(mod(floor(iTime/(size.y/25.))* size.y/25. * 5., size.x), mod(iTime * 25. , size.y));\n    \n    vec2 point = fragCoord - 50.;\n    \n    float maxD = length(size);\n    \n    if (sqrt(pow(point.x-pointB.x, 2.) + pow(point.y-pointB.y, 2.)) < 5.) {\n        fragColor = vec4(1., 1., 1., 1.);\n        return;\n    }\n    \n    if (point.x > size.x || point.x < 0. || point.y > size.y || point.y < 0.) {\n        fragColor = vec4(0., 0., 0., 1.);\n        return;\n    }\n    \n    vec2 left = vec2(-pointB.x, pointB.y);\n    float d1 = sqrt(pow(point.x-left.x, 2.) + pow(point.y-left.y, 2.));\n    \n    vec2 right = vec2((size.x*2.)-pointB.x, pointB.y);\n    float d2 = sqrt(pow(point.x-right.x, 2.) + pow(point.y-right.y, 2.));\n    \n    vec2 up = vec2(pointB.x, (size.y*2.)-pointB.y);\n    float d3 = sqrt(pow(point.x-up.x, 2.) + pow(point.y-up.y, 2.));\n    \n    vec2 down = vec2(pointB.x, -pointB.y);\n    float d4 = sqrt(pow(point.x-down.x, 2.) + pow(point.y-down.y, 2.));\n    \n    float d = smoothstep(0., 1., min(d1, min(d2, min(d3, d4)))/maxD);\n    \n    fragColor = vec4(gradient(d), 1.);\n    return;\n    \n    if (d1 < d2 && d1 < d3 && d1 < d4) {\n        fragColor = vec4(1., 0., .839, 1.);\n    } else if (d2 < d3 && d2 < d4) {\n        fragColor = vec4(0., 1., .341, 1.);\n    } else if (d3 < d4) {\n        fragColor = vec4(0., .341, 1., 1.);\n    } else {\n        fragColor = vec4(1., .478, 0., 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lfG3zh.jpg", "time_retrieved": "2024-04-28T18:59:36.312933", "access": "api", "wgpu-test": "ok"}
{"id": "lcG3Rh", "name": "DOF cube", "author": "panic", "description": "an attempt at analytic depth of field for infinitesimal line segments", "tags": ["dof", "bokeh", "depthoffield"], "image_code": "// intensity of infinitesimal line\n#define K 0.0015\n// aperture size\n#define A 0.04\n// distance of camera from center of object\n#define D 4.\n// focused distance\n#define F (D-1.75)\n// zoom\n#define Z 1.\n\nfloat dof(vec2 uv, vec3 start, vec3 end)\n{\n    // add camera distance and perform perspective division.\n    start.z += D;\n    end.z += D;\n    start.xy /= start.z;\n    end.xy /= end.z;\n    // convert z coordinate to circle of confusion radius using the aperture A and focused distance F.\n    start.z = A * (start.z - F) / start.z;\n    end.z = A * (end.z - F) / end.z;\n    // find the interval of the line that contributes to the pixel at uv.\n    vec3 off = end - start;\n    float a = abs(off.x * off.x + off.y * off.y - off.z * off.z);\n    float b = -2. * (start.z * off.z + uv.x * off.x - start.x * off.x + uv.y * off.y - start.y * off.y);\n    float c = uv.x * uv.x - 2. * start.x * uv.x + start.x * start.x + uv.y * uv.y - 2. * start.y * uv.y + start.y * start.y - start.z * start.z;\n    float discrim = b * b - 4. * a * c;\n    if (discrim < 0.)\n        return 0.;\n    float d = sqrt(discrim);\n    float t0 = clamp((-b + d) / (2. * a), 0., 1.);\n    float t1 = clamp((-b - d) / (2. * a), 0., 1.);\n    if (t0 == t1)\n        return 0.;\n    // a circle of confusion of radius r contributes 1/r^2 intensity -- integrate this quantity over the interval.\n    vec3 p0 = start + off * t0;\n    vec3 p1 = start + off * t1;\n    float len = length(p1.xy - p0.xy);\n    return K * len / (p1.z * p0.z);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = Z*(fragCoord - iResolution.xy * 0.5)/iResolution.yy;\n    float t = iTime;\n    mat3x3 rot = mat3x3(\n        1, 0, 0,\n        0, cos(t), -sin(t),\n        0, sin(t), cos(t)\n    );\n    rot *= mat3x3(\n        cos(t * 0.37), -sin(t * 0.37), 0,\n        sin(t * 0.37), cos(t * 0.37), 0,\n        0, 0, 1\n    );\n    float color = 0.;\n    color += dof(uv,\n        rot * vec3(1, 1, 1),\n        rot * vec3(-1, 1, 1)\n    );\n    color += dof(uv,\n        rot * vec3(-1, 1, 1),\n        rot * vec3(-1, -1, 1)\n    );\n    color += dof(uv,\n        rot * vec3(-1, -1, 1),\n        rot * vec3(1, -1, 1)\n    );\n    color += dof(uv,\n        rot * vec3(1, -1, 1),\n        rot * vec3(1, 1, 1)\n    );\n    color += dof(uv,\n        rot * vec3(1, 1, -1),\n        rot * vec3(-1, 1, -1)\n    );\n    color += dof(uv,\n        rot * vec3(-1, 1, -1),\n        rot * vec3(-1, -1, -1)\n    );\n    color += dof(uv,\n        rot * vec3(-1, -1, -1),\n        rot * vec3(1, -1, -1)\n    );\n    color += dof(uv,\n        rot * vec3(1, -1, -1),\n        rot * vec3(1, 1, -1)\n    );\n    color += dof(uv,\n        rot * vec3(1, 1, 1),\n        rot * vec3(1, 1, -1)\n    );\n    color += dof(uv,\n        rot * vec3(-1, 1, 1),\n        rot * vec3(-1, 1, -1)\n    );\n    color += dof(uv,\n        rot * vec3(-1, -1, 1),\n        rot * vec3(-1, -1, -1)\n    );\n    color += dof(uv,\n        rot * vec3(1, -1, 1),\n        rot * vec3(1, -1, -1)\n    );\n    fragColor = vec4(vec3(sqrt(1. - color)), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcG3Rh.jpg", "time_retrieved": "2024-04-28T18:59:36.898366", "access": "api", "wgpu-test": "ok"}
{"id": "lcyGRh", "name": "Red and gray rug (music)", "author": "jarble", "description": "A red and gray rug pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\nfloat scale = 1.5;\n\nvoid transform(inout vec2 uv, inout vec2 t2, inout vec3 col,inout float c1){\n        t2.y +=\n            1./4.\n            //1./3.\n            //1./8.\n        ;\n        //if(t2.y>1./4.)\n        uv = (uv+t2)/scale;\n        \n        \n \n        //if(t2.y<1./4.)\n        uv = ((vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        \n        t2 = triangle_wave(uv+.5);\n        uv =\n            t2/2.-triangle_wave(uv.yx)\n        ;\n        \n        {t2.x = (t2.x+1.*sign(t2.y-t2.x)); }\n\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    float c1=0.;\n    for(int k = 0; k < 12; k++){\n        //kaleidoscope!\n        //if(k>9) uv.x += iTime/2.;\n        \n        transform(uv,t2,col,c1);\n        c1 =\n            //max(abs(t2.y-t2.x)/2.,c1)\n            max(abs(t2.y+t2.x)/2.,c1)\n            //max(sign(t2.y-t2.x)/2.,c1)\n        ;\n        c1 =\n            max(1.-abs(2.*c1-1.),0.)\n        ;\n        col.x =\n            c1\n        ;\n        if(t2.y>t2.x)\n        col =\n            //abs(col-(1.-(c1*(t2.y-t2.x))))\n            //abs(col/2.-((c1*(t2.y-t2.x))))\n            //abs(col/2.-(1.-(c1*(t2.y-t2.x))))\n            //abs(col/2.-(1.-c1))\n            abs(vec3(1.-c1))\n        ;\n        //if(k>9) uv.y= iTime;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 8.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec3 col1 = fractal(uv);\n    fragColor = vec4(col1,1.0);\n    //fragColor = pow(fragColor ,vec4(1./1.8)); //gamma correction\n\n}\n", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/mtSBzV\n\nint gcd(int a, int b) \n{ \n    // Find Minimum of a and b \n    int result = ((a < b) ? a : b); \n    while (result > 0) { \n        // Check if both a and b are divisible by result \n        if (a % result == 0 && b % result == 0) { \n            break; \n        } \n        result--; \n    } \n    // return gcd of a nd b \n    return result; \n}\n#define gcd(a,b) float(gcd(int(a),int(b)))\n\nint collatz(int initial, int steps){\n    //hailstone numbers\n    //makes some interesting rhythms\n    for(int i = 0; i < steps; i++){\n        if(initial%2==0) initial /= 2;\n        else initial = initial*3+1;\n    }\n    return initial;\n}\n\nfloat collatz(float initial, float steps){\n    return float(collatz(int(initial),int(steps)));\n}\n\nfloat mod1(float a,float b){\n    //a += mod(floor(a/16.),16.);\n\n    //a += collatz(mod(a/4.,b),8.);\n    //a += collatz(mod(a/4.,8.),b);\n    \n    return\n        mod(a,b)\n        //mod(a+mod(a,b+3.),b)\n        //mod(a+4.*floor(mod(a/4.,b)),b)\n    ;\n}\n\nvoid distort(inout float a, inout float b){\n    for(float i = 1.; i < mod(floor(a/b),5.); i++){\n        a /= 2.0;\n        //a /= 1.0+mod(floor(a),2.);\n        a += mod1(floor(a/2.),b)*i;\n    }\n}\n\nfloat fmod(float a, float b, float tempo){\n    //a += gcd(a,b);\n    float\n    t1 = mod1(floor(b/2.),2.),\n    a1 =\n        floor(a+t1),\n    a2 = mod1(a1,3.),\n    a3 =\n        mod1(a1+mod(a1/8.,3.)*8.,4.)\n    ;\n    return\n        mod1(a1-a2-a3,b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    return fmod(a,b,1.);\n}\n\nfloat prime_rhythm(float time){\n    //time += mod(floor(time/16.),16.);\n\n    //time += floor(time/8.);\n    return (1.+fmod(time/4.,2.))/(1.+fmod(time/2.,2.));\n}\n\nfloat fmod1(float a, float b){\n\n    //a += collatz(a/8./8.,b);\n    return\n        fmod(a,b)\n        //fmod(a+4.+floor(a/4.)*4.,b)\n    ;\n}\n\n#define fract1(a) (1.-pow(fract(-a),2.))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 banjo(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,6./4.));\n}\n\nvec2 harp(vec2 a, vec2 nb){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.));\n}\n\nvec2 synth_drum(vec2 a, vec2 nb,float m2){\nreturn a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.));\n}\n\nvec2 oud(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 steel_drum(vec2 a, vec2 nb){\nreturn a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n;\n}\n\nvec2 gamelan(vec2 a, vec2 nb){\nreturn\na/16./4.*abs(synth(1./4.,a,1./8.,1.,nb*2.,1./2.)\n  +.5*synth(1./4.,a,1./4.,1.,nb*2.,1./2.)) \n;\n}\n\nvec2 sitar(vec2 a, vec2 nb){\nreturn a/16./2.*abs(log(1./8.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./16.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2./4.)));\n}\n\nvec2 sitar1(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./4.+a*(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar2(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+a*a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      -log(1./2.+(abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n    ;\n}\n\nvec2 sitar3(vec2 a, vec2 nb){\nreturn a/16./4.*abs(log(1./2.+.5*a*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n  -log(1./2.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n;\n}\n\nvec2 sitar5(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./2.+a*a/2.*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 sitar6(vec2 a, vec2 nb){\n    return a*a/16./2.*abs((.5*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -(a/4.*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 mainSound1(int samp, float time,float scale,float duration){\n  //time += mod(floor(time/16.),16.);\n\n  float s1 =\n      8.,\n  tempo1 =\n      prime_rhythm(time)*prime_rhythm(time/2.)*2.\n      //prime_rhythm(time+floor(time/8.))*prime_rhythm(time/2.)*2.\n  ,t = s1*time/4./tempo1,\n  t7 =\n      (1.+fmod(t/8.,2.))\n      //(1.+fmod(t/8.+mod(t/8.,2.),2.))\n  ,\n  t4 = t/prime_rhythm(time+11.)/t7,\n  t1 =\n       fmod(t4,2.)\n       //fmod(t4+floor(time/8.),2.)\n  ,\n  t5 = t*2./prime_rhythm(time+7.),\n  t3 =\n      (1.+fmod(t5,2.))\n      //(1.+fmod(t5+floor(time/4./4./4.),2.))\n\n  ,\n  t6 = time*8./t3,\n  m3 =\n      floor(fmod1(t6+floor(time/20.+1.)*s1/4.,s1/2.)/2.)\n      //floor(fmod1(t6+floor(time/8./4.),s1/2.)/2.)\n\n  ,\n  m2 =\n      1. + fmod1(t/t3/2.+floor(time/20.)*s1/4.,s1/2.)\n      //1. + fmod1(t/t3/2.+floor(time/4./4.),s1/2.)\n  ,note = (\n      (m3+m2-t1*4.)\n      //(m3+m2-t1*4.+fmod(time*2.,2.5)*2.)\n      //(m3+m2-t1*4.+fmod(time,4.))\n      //mod(m3+m2-t1*4.-floor(time/4.)*4.,8.)-4.\n      //(m3+m2-t1*4.+fmod(time/2.,2.))\n      //(m3+m2+t1*4.-2.)\n      //(m3+m2-t1*4.)+mod(m3,2.)\n  )/7.\n  \n  ;\n  vec2 a=\n      duration/2.*(-vec2((log(1./64.+fract1(t/prime_rhythm(time+7.))/4./duration))))\n      \n      //more complex rhythm\n      //-vec2((log(1./64.+fract1(t*t3/2./prime_rhythm(time+14.))/2./duration)),(log(1./64.+fract1(t*t3/prime_rhythm(time+7.))/4./duration)))\n\n  ,\n  nb =\n      t*vec2(pow(2.,note+scale),pow(2.,note+scale))*tempo1\n  ;\n  //nb /= tempo1/2.;\n  return\n      //oud\n      //oud(a,nb)\n      \n\n      //sitar\n      //a/16./2.*abs(\n      //synth(1./4.,a,0.,1.,nb*2.,1./2.)\n      //-.5*synth(1./8.,a,1./8.,1.,nb,1./2.))/2.\n      \n      //sitar\n      //a/16./2.*abs(\n      //synth(1./4.,a,0.,1.,nb*2.,1./2.)\n      //+.5*synth(1./8.,a,1./8.,1./duration,nb,1./2.))/2.\n      \n      //sitar\n      //abs(oud(a,nb)-oud(a,nb*2.)/2.)\n      \n      //banjo\n      //a/16./4.*abs(\n      //synth(1./4.,a,1./8.,1.,nb*4.,4./6.)\n      //+ synth(1./8.,a,1./4.,1.,nb*2.,6./4.))\n      \n      //synth drum\n      //a/16./32.*abs(log(1./4.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))*4.))\n      //+ log(1./2.+a*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/4.)))\n      \n      //sitar3(a,nb)\n      sitar1(a,nb)+sitar1(a,nb/2.)+sitar1(a,nb/4.)\n      //sitar1(a,nb)\n      \n      //jawharp\n      //sitar6(a/2.,nb)-sitar6(a,nb/2.)\n  ;\n  \n}\n\nvec2 mainSound1(int samp, float time,float scale){\n    return mainSound1(samp,time,scale,1.);\n}\n\nvec2 mainSound(int a,float b){\n    float scale = 7.;\n    return\n        //sounds like sitar (using oud)\n        //abs(mainSound1(a,b,6.25,1./2.)-mainSound1(a,b,7.25)/2.)\n        \n        //abs(mainSound1(a,b,6.25,1./2.)-mainSound1(a,b,8.25,1./2.)/4.)\n        \n        //abs(mainSound1(a,b,6.25,1./2.)-(mainSound1(a,b,7.25,1.)/2.-mainSound1(a,b,8.25,2.)/4.))/2.\n\n        //sounds like sitar (using synth drum)\n        //(mainSound1(a,b,4.5,1.)-mainSound1(a,b,5.5,2.)/2.)*2.\n        \n        //using sitar2\n        //(mainSound1(a,b,6.5,1./2.)-mainSound1(a,b,5.5,2.))*2.\n        //(mainSound1(a,b,6.,1.)-mainSound1(a,b,5.,1./4.))*2.\n \n        //sitar6 (sounds like oud)\n        mainSound1(a,b,scale,2.)-mainSound1(a,b,scale,1.)\n        \n        //sitar1\n        //mainSound1(a,b,6.25,1.)\n        \n    ;\n}\n", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcyGRh.jpg", "time_retrieved": "2024-04-28T18:59:36.981145", "access": "api", "wgpu-test": "incomplete"}
{"id": "lcVGzz", "name": "Cloud Diving", "author": "leon", "description": "alternative background of my shader from Revision24 showdown final", "tags": ["short"], "image_code": "\n// alternative background of my shader from Revision24 showdown final\n// original version:\n// https://livecode.demozoo.org/event/2024_03_29_shader_showdown_revision_2024.html\n\nfloat gyroid (vec3 p) { return dot(cos(p),sin(p.yzx)); }\n\nfloat fbm(vec3 p)\n{\n    float result = 0.;\n    float a = .5;\n    for (float i = 0.; i < 7.; ++i)\n    {\n        p += result*.1;\n        p.z += iTime*.1;\n        result += abs(gyroid(p/a)*a);\n        a /= 1.7;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ray = normalize(vec3(uv,.3));\n    \n    vec3 e = vec3(200./iResolution.xy, 0.);\n    \n    #define T(u) fbm(ray+u)\n    vec3 normal = normalize(T(0.)-vec3(T(e.xzz),T(e.zyz),1.));\n    vec3 color = 0.5 + 0.5 * cos(vec3(1,2,3)*5.4 - normal.x+.5);\n    color *= smoothstep(-1.,1.,-normal.z);\n\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcVGzz.jpg", "time_retrieved": "2024-04-28T18:59:37.226489", "access": "api", "wgpu-test": "ok"}
{"id": "lcV3Rz", "name": "Devil Glass", "author": "leon", "description": "alternative version of my shader from Revision24 showdown final", "tags": ["shadershowdown"], "image_code": "\n// alternative version of my shader from Revision24 showdown final\n// original version:\n// https://livecode.demozoo.org/event/2024_03_29_shader_showdown_revision_2024.html\n\nmat2 rot (float a) { float c=cos(a),s=sin(a); return mat2(c,-s,s,c); }\nfloat gyroid (vec3 p) { return dot(cos(p),sin(p.yzx)); }\nfloat fbm(vec3 p)\n{\n  float result = 0.;\n  float a = .5;\n  for (float i = 0.; i < 3.; ++i)\n  {\n    p += result;\n    p.z += iTime*.2;\n    result += abs(gyroid(p/a)*a);\n    a /= 2.;\n  }\n  return result;\n}\n\nfloat map(vec3 p)\n{\n  float dist = 100.;\n  \n  p.xz *= rot(iTime * .2);\n  p.xy *= rot(iTime * .1);\n  vec3 q = p;\n  \n  p = abs(p)-1.3;\n  dist = max(p.x, max(p.y, p.z));\n  dist -= fbm(q)*.2;\n  dist = abs(dist)-.03;\n  \n  return dist * .5;\n}\n\nvec3 getResult(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 color = vec3(smoothstep(1., -1., length(uv)));\n    \n    vec3 pos = vec3(0,0,7);\n    vec3 ray = normalize(vec3(uv, -1.5));\n    float total = 0.;\n    float shade = 0.;\n    for (float i = 100.; i > 0.; --i)\n    {\n        float dist = map(pos);\n        if (dist < .001)\n        {\n            shade += 0.1;\n            dist = 0.002;\n        }\n        if (total > 10.) return color;\n        total += dist;\n        pos += ray * dist;\n    }\n\n    if (total < 10.)\n    {\n        color = 0.5 + 0.5 * cos(vec3(1,2,3)*5.5+shade);\n    }\n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(getResult(fragCoord),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcV3Rz.jpg", "time_retrieved": "2024-04-28T18:59:37.942572", "access": "api", "wgpu-test": "ok"}
{"id": "lfKGzR", "name": "Kaleido Mecha", "author": "leon", "description": "alternative version of my shader from Revision24 showdown round 3", "tags": ["shadershowdown"], "image_code": "\n// alternative version of my shader from Revision24 showdown round 3\n// original version:\n// https://livecode.demozoo.org/event/2024_03_29_shader_showdown_revision_2024.html\n\nmat2 rot(float a)\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat map(vec3 p)\n{\n    float dist = 100.;\n\n    float t = 196. + iTime;\n    float a = 1.;\n\n    for (float i = 0.; i < 8.; ++i)\n    {\n        vec3 e = vec3(.2+.2*sin(i+iTime),.0,0);\n        p.xz = abs(p.xz)-.5*a;\n        p.xz *= rot(t*a);\n        p.yz *= rot(t*a);\n        p = p - clamp(p, -e, e);\n        dist = min(dist, length(p)-.01);\n        a /= 1.8;\n    }\n\n    return dist;\n}\n\nvec3 getResult(vec2 fragCoord)\n{\n    vec2 uv = (fragCoord-iResolution.xy/2.)/iResolution.y;\n    vec3 color = vec3(smoothstep(1., -2., length(uv)));\n    \n    vec3 pos = vec3(0,0,4);\n    vec3 ray = normalize(vec3(uv, -1.));\n    float dist = 100.;\n    float total = 0.;\n    float shade = 1.;\n\n    for (shade = 1.; shade > 0.; shade -= 1./60.)\n    {\n        dist = map(pos);\n        if (dist < .001) break;\n        pos += ray * dist;\n        total += dist;\n        if (total > 10.) return color;\n    }\n    if (total < 10. && shade > .01)\n    {\n        vec2 e = vec2(.001,0);\n        vec3 normal = normalize(dist-vec3(map(pos+e.xyy),map(pos+e.yxy),map(pos+e.yyx)));\n        vec3 tint = 0.5 + 0.5 * cos(vec3(1,2,3)+length(pos)*2.+iTime);\n        float light = dot(reflect(ray, normal), normalize(vec3(0,1,-1)));\n        color = tint*shade+pow(max(light,0.), 4.);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 color;\n    const float samples = 4.;\n    for (float a = 0.; a < 1.; a += 1./samples)\n    {\n        vec2 aa = vec2(cos(a*6.28),sin(a*6.28))*.5;\n        color += getResult(fragCoord+aa)/samples;\n    }\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lfKGzR.jpg", "time_retrieved": "2024-04-28T18:59:38.539975", "access": "api", "wgpu-test": "ok"}
{"id": "XcVGRR", "name": "Debug distance", "author": "Zavie", "description": "Yet another signed distance field visualisation.", "tags": ["sdf", "debug"], "image_code": "/*\n\nThis shader proposes a function to display isolines for a distance field.\nThe line width should appear constant regardless of the distance scale.\n\n- The white background represents positive distance space.\n- The darker background represents negative distance space.\n- The black thick line represents the isoline of distance zero.\n- The thin coloured lines represent the unit distance isolines.\n- The thick coloured lines represent the multiples of 5 distance isolines.\n\n--\nZavie\n\n*/\n\nvec3 debugDistance(vec3 iResolution, float d, vec3 color)\n{\n    float refWidth = iResolution.y / 1080.;\n\n    float dd1 = fwidth(d);\n    float width1 = 2.5 * dd1 * refWidth;\n    \n    float iso1 = smoothstep(-dd1, dd1, abs(fract(d) * 2. - 1.) - (1. - width1));\n\n    float dd5 = fwidth(5. * d);\n    float width5 = 0.75 * dd5 * refWidth;\n    float iso5 = smoothstep(-dd5, dd5, abs(fract(5.*d) * 2. - 1.) - (1. - width5));\n\n    float dd0 = fwidth(d);\n    float width0 = 3. * dd0 * refWidth;\n    float iso0 = smoothstep(-dd0, dd0, width0 - abs(d));\n\n    float isoLines = max(iso0, max(iso1, iso5));\n\n    vec3 background = (d > 0. ? vec3(1.) : mix(vec3(0.8), color, 0.1));\n    vec3 lineColor = mix(color * (d > 0. ? 1. : 0.8), vec3(0.), iso0);\n\n    return mix(background, lineColor, isoLines);\n}\n\n// IQ's colour palette function\n// https://www.shadertoy.com/view/ll2GD3\nvec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d)\n{\n    float pi = acos(-1.);\n    return a + b * cos(2. * pi * (c * t + d));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * vec2(1., iResolution.y / iResolution.x);\n    vec2 c = vec2(0.5) * vec2(1., iResolution.y / iResolution.x);\n\n    float scale = mix(0.5, 10., sin(iTime * 0.25) * 0.5 + 0.5);\n    float d = length(uv - c) * scale - 1.;\n\n    vec3 colouredDistance = debugDistance(iResolution, d, palette(0.1 * iTime, vec3(0.5),vec3(0.5), vec3(1.0, 0.7, 0.4),vec3(0.0, 0.15, 0.20)));\n\n    fragColor = vec4(colouredDistance, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcVGRR.jpg", "time_retrieved": "2024-04-28T18:59:39.337840", "access": "api", "wgpu-test": "ok"}
{"id": "lcdGzl", "name": "finalhomework-2024", "author": "leborgnekevin", "description": "landscape go vrouuum", "tags": ["newlandscape"], "image_code": "float PI = 3.14;\nvec3 ro = vec3(0, -21., -2.);                                          // ray origin that represents camera position\n\n// Rotation matrix around the X axis.\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(1, 0, 0), vec3(0, c, -s), vec3(0, s, c));\n}\n\n// Rotation matrix around the Y axis.\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c, 0, s), vec3(0, 1, 0), vec3(-s, 0, c));\n}\n\n// Rotation matrix around the Z axis.\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(vec3(c, -s, 0), vec3(s, c, 0), vec3(0, 0, 1));\n}\n\n// Identity matrix.\nmat3 identity() {\n    return mat3(vec3(1, 0, 0), vec3(0, 1, 0), vec3(0, 0, 1));\n}\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 100.0;\nconst float PRECISION = 0.004;\nconst float EPSILON = 0.005;\n\nstruct Surface {\n    float sd; // signed distance value\n    vec3 col; // color\n};\n\nvec2 hash22b(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return 2.0 * fract((p3.xx + p3.yz) * p3.zy) - 1.0;\n}\n\nfloat noise(vec2 p) {\n    vec2 ip = floor(p);\n    vec2 fp = fract(p);\n\n    float a = dot(hash22b(ip + vec2(0, 0)), fp - vec2(0, 0));\n    float b = dot(hash22b(ip + vec2(1, 0)), fp - vec2(1, 0));\n    float c = dot(hash22b(ip + vec2(0, 1)), fp - vec2(0, 1));\n    float d = dot(hash22b(ip + vec2(1, 1)), fp - vec2(1, 1));\n\n    vec2 t = smoothstep(vec2(0), vec2(1), fp);\n    float res = mix(mix(a, b, t.x), mix(c, d, t.x), t.y);\n    return 0.5 + 0.5 * res;\n}\n\nfloat fbm(vec2 p) {\n    float res = 0.0;\n    float amp = 0.9;\n    float freq = 0.9;\n    for(int i = 0; i < 10; ++i) {\n        res += amp * noise(freq * p);\n        amp /= 2.0;\n        freq *= 2.0;\n    }\n    return res;\n}\n\nSurface sdFloor(vec3 p) {\n    vec3 col;\n    float d = p.y + 2.;\n\n    // Add some noise\n    d += 2. * fbm(p.xz * 0.5);\n    d += 15. * fbm(p.xz * 0.08);\n    d += 15. * fbm(p.xz * 0.08);\n    float height = p.y + 2. + 2. * fbm(p.xz * 0.5);\n    \n\n    //the sunset effect\n    if (height > -25. && (length(p - ro) >=30.0 )) {\n        // Color gradient: make a gradient color based on the height of the floor from red to orange \n        vec3 gradientColor = mix(vec3(1.0, 0.0, 0.0), vec3(1.0, 0.5, 0.0), smoothstep(-25., -20., height));\n        \n        // Texture blending factor: blend the texture with the gradient color smoothly\n        float textureBlend = smoothstep(-25., -20., height);\n\n        // Use texture from iChannel0\n        vec4 textureColor = texture(iChannel0, p.xz * 0.1); // Adjust texture coordinate as needed\n        \n        // Darken the texture color\n        textureColor.rgb *= 0.5;\n\n        // Blend the texture color with the gradient color\n        col = mix(gradientColor, textureColor.rgb, textureBlend);\n        \n        \n        \n        \n     //add the floor texture   \n    } else if (length(p - ro) < 30.0) { // Check if the distance from the point to the camera is less than 30 units\n        // Use texture from iChannel0\n        vec4 textureColor = texture(iChannel0, p.xz * 0.1); // Adjust texture coordinate as needed\n        \n        // Darken the texture color\n        textureColor.rgb *= 0.6;\n\n        col = textureColor.rgb;\n    }\n\n    return Surface(d, col);\n}\n\nSurface sdSea(vec3 p, vec3 col) {\n    float d = p.y + 18.0;\n    d += 0.003 * sin(10.0 * p.x + iTime) * cos(10.0 * p.z + iTime) + 0.14;\n    col = vec3(0.0, 0.0, 0.7);\n    return Surface(d, col);\n\n}\n\n\n\nSurface sdSphere(vec3 p, float r, vec3 offset, vec3 col) {\n    p = (p - offset);\n    float d = length(p) - r;\n    return Surface(d, col);\n}\n\nSurface sdPandora(vec3 p, float r, vec3 offset, vec3 col) {\n    p = (p - offset);\n    float d = length(p) - r;\n    // Calculate the texture coordinates based on the 3D position of p\n    vec2 texCoord = vec2(atan(p.z, p.x) / (2.0 * PI) + 0.5, asin(p.y / r) / PI + 0.5);\n    vec4 texColor = texture(iChannel2, texCoord); // Sample the texture\n    col = texColor.rgb;\n    return Surface(d, col);\n}\n\nSurface sdlittleBlue(vec3 p, float r, vec3 offset, vec3 col) {\n    p = (p - offset);\n    float d = length(p) - r;\n    // Calculate the texture coordinates based on the 3D position of p\n    vec2 texCoord = vec2(atan(p.z, p.x) / (2.0 * PI) + 0.5, asin(p.y / r) / PI + 0.5);\n    vec4 texColor = texture(iChannel3, texCoord); // Sample the texture\n    col = texColor.rgb;\n    return Surface(d, col);\n}\n\n\n\nSurface opUnion(Surface obj1, Surface obj2) {\n    if(obj2.sd < obj1.sd)\n        return obj2;\n    return obj1;\n}\n\nSurface scene(vec3 p) {\n\n    Surface floor = sdFloor(p + vec3(0., -4., 0.)); // Floor\n    Surface sea = sdSea(p + vec3(0., 10., 0.), vec3(0.0, 0.0, 0.5)); // Sea\n\n    // Combine the floor and sea surfaces\n    Surface combinedSurface = opUnion(floor, sea);\n\n    // Add the Pandora sphere\n    float t = iTime / 3.; // Timer\n    vec3 sphereOffset = vec3(-5.0 + 30.0 * cos(iTime / 16.0), -15.0 + 35. * sin(iTime / 16.0), -120.0); // Offset the sphere position with timer\n    combinedSurface = opUnion(combinedSurface, sdPandora(p, 30., sphereOffset, vec3(1.0, 1.0, 0.0))); // Pandora sphere\n    \n    \n    // Add litle blue sphere\n    float t2 = iTime / 16.; // Timer\n    vec3 sphereOffset2 = vec3( 90.0 * cos(t2-0.75*PI), 5.,-2.0 + 90.0 * sin(t2-0.75*PI));\n    combinedSurface = opUnion(combinedSurface, sdlittleBlue(p, 5., sphereOffset2, vec3(1.0, 1.0, 0.0))); // little blue sphere\n\n  \n\n    return combinedSurface;\n}\n\nSurface rayMarch(vec3 ro, vec3 rd) {\n    float depth = MIN_DIST;\n    Surface co; // closest object\n\n    for(int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        vec3 p = ro + depth * rd;\n        co = scene(p);\n        depth += co.sd;\n        if(co.sd < PRECISION || depth > MAX_DIST)\n            break;\n    }\n\n    co.sd = depth;\n\n    return co;\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(1, -1) * EPSILON;\n    return normalize(e.xyy * scene(p + e.xyy).sd +\n        e.yyx * scene(p + e.yyx).sd +\n        e.yxy * scene(p + e.yxy).sd +\n        e.xxx * scene(p + e.xxx).sd);\n}\n\nfloat softShadow(vec3 ro, vec3 rd, float mint, float tmax) {\n    float res = 1.0;\n    float t = mint;\n\n    for(int i = 0; i < 16; i++) {\n        float h = scene(ro + rd * t).sd;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax)\n            break;\n    }\n\n    return clamp(res, 0.0, 1.0);\n}\n\nvoid drawStars(vec2 uv, inout vec3 background) {\n    float threshold = 0.998; // density\n    float randValue = fract(sin(dot(uv, vec2(12.9898, 78.233))) * 43758.5453);\n\n    if(randValue > threshold) {\n        vec3 starColor = vec3(1.0);\n\n        float sizeRand = 0.1; // Declare and initialize sizeRand variable\n        float starSize = mix(.5, 3.0, sizeRand);\n\n        // Add twinkle effect\n        float twinkle = 1.+sin(iTime * 5. + uv.x * 100.0 + uv.y * 50.0);\n        starColor *= twinkle;\n\n        background += starColor / (starSize * starSize);\n       // float starSize = mix(.5, 3.0, sizeRand);\n\n        background += starColor / (starSize * starSize);\n    }\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n        vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    vec3 rd = normalize(vec3(uv, -1));\n\n    vec3 topColor = vec3(1., 0.25, 0.0); // Color at the top of the gradient (orange)\n    vec3 bottomColor = vec3(0.000, 0.000, 0.000); // Color at the bottom of the gradient (black)\n    vec3 backgroundColor = mix(bottomColor, topColor, rd.y);\n    vec3 fogColor = vec3(0.5, 0.5, 0.5);\n\n    vec3 col = vec3(0);\n\n\n    vec2 mouse;\n    if(iMouse.x == 0. && iMouse.y == 0.) {\n        mouse = vec2(0.0, 0.0); // Replace with your desired initial rotation\n    } else {\n        mouse = iMouse.xy / iResolution.xy - 0.5; // <-0.5,0.5>\n    }\n\n    rd *= rotateY(mouse.x) * rotateX(mouse.y); // apply yaw and pitch\n    Surface co = rayMarch(ro, rd); // closest object\n\n    if(co.sd > MAX_DIST) {\n        col = backgroundColor; // ray didn't hit anything\n        drawStars(uv, col);\n    } else {\n        vec3 p = ro + rd * co.sd; // point discovered from ray marching\n        vec3 normal = calcNormal(p);\n\n        vec3 lightPosition = vec3(10., 0., 10.);\n        vec3 lightDirection = normalize(lightPosition - p);\n\n        float dif = clamp(dot(normal, lightDirection), 0., 1.) + 0.5; // diffuse reflection\n\n        float softShadow = clamp(softShadow(p, lightDirection, 0.02, 2.5), 0.1, 1.0);\n\n        col = dif * co.col * softShadow;\n\n    // Check if the color of the closest object matches the color of the sea\n        vec3 seaColor = vec3(0.0, 0.0, .70); // Replace with the actual color of the sea\n        if(length(co.col - seaColor) < 0.01) {\n        // Calculate the reflected ray\n            vec3 reflection = reflect(rd, normal);\n\n        // Perform a second ray march along the reflected ray\n            float t2 = 0.0;\n            for(int i = 0; i < 256; i++) {\n                vec3 p2 = p + t2 * reflection;\n                Surface co2 = rayMarch(p2, reflection);\n                if(co2.sd < 0.00001 || t2 > 5.0)\n                    break;\n                t2 += co2.sd;\n            }\n\n        // If the second ray march hit something, add the reflection color\n            if(t2 < 5.0) {\n                vec3 reflectionColor = vec3(1.0, 1.0, 1.0); // Color of the reflection\n                float reflectionStrength = 0.5; // Strength of the reflection\n                col = mix(col, reflectionColor, reflectionStrength);\n            }\n        }\n    }\n\n    float fogHeightStart = 0.0; // Set the starting height of the fog\n    float fogHeightEnd = 2.0; // Set the ending height of the fog\n    float fogDensity = 0.00004; // Set the desired fog density\n\n    float fogFactor = .5 - exp(-fogDensity * co.sd * co.sd * co.sd);\n    fogFactor = clamp(fogFactor, 0.0, 1.0); // Clamp the fog factor between 0 and 1\n\n    vec3 p; // Declare the variable 'p' as a vector or structure\n    if(p.y > fogHeightStart && p.y < fogHeightEnd) {\n        fogFactor = 0.0; // Disable fog within the specified height range\n    }\n\n    col = mix(col, fogColor, fogFactor); // Apply fog using the fog color\n    col = pow(col, vec3(1.0 / 2.2)); // Gamma correction\n    fragColor = vec4(col, 1.0);\n   //fragColor = texture(iChannel2,uv);\n}", "image_inputs": [{"id": 48, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "// https://www.shadertoy.com/view/4sfGzS\nfloat noise(in vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = texture( iChannel0, (uv+0.5)/256.0, -100.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nfloat noise2(in vec3 uv) {\n    float p = 2.35;\n    float n = 0.0;\n    \n    n += 0.500000 * noise(uv * p); p *= 2.01;\n    n += 0.250000 * noise(uv * p); p *= 2.02;\n    n += 0.125000 * noise(uv * p); p *= 1.99;\n    n += 0.062500 * noise(uv * p); p *= 1.97;\n    n += 0.031250 * noise(uv * p); p *= 1.98;\n    n += 0.015625 * noise(uv * p);\n    n /= 0.884375;\n    \n    return n;\n}\n\n// https://iquilezles.org/articles/functions\nfloat cpulse(float c, float w, float x)\n{\n    x = abs(x - c);\n    if( x>w ) return 0.0;\n    x /= w;\n    return 1.0 - x*x*(3.0-2.0*x);\n}\n\nvec3 texture(in vec3 uv) {\n    uv += noise2(vec3(noise2(uv - 1532.0), noise2(uv + 786.0), 0.0));\n    float n = noise2(uv);\n    \n    vec3 col = vec3(0.0);\n    \n    col += vec3(96.0, 91.0, 86.0)    / 256.0 * cpulse(0.15, 0.25, n);\n    col += vec3(100.0, 94.0, 157.0)  / 256.0 * cpulse(0.45, 0.15, n);\n    col += vec3(172.0, 193.0, 138.0) / 256.0 * cpulse(0.5, 0.03, n);\n    col += vec3(238.0, 184.0, 104.0) / 256.0 * cpulse(0.55, 0.15, n);\n    col += vec3(73.0, 220.0, 177.0)  / 256.0 * cpulse(0.85, 0.25, n);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = -1.0 + 2.0 * uv;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = texture(vec3(uv - vec2(0.0, 16.0),  64.0));\n    col = sqrt(col);\n    \n\tfragColor = vec4(col, 1.0);\n}", "buffer_a_inputs": [{"id": 30, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_b_code": "vec2 hash2(vec2 p){\n\treturn fract(sin(vec2(dot(p,vec2(123.4,748.6)),dot(p,vec2(547.3,659.3))))*5232.85324);\n}\nfloat hash(vec2 p){\n\treturn fract(sin(dot(p,vec2(43.232,75.876)))*4526.3257);\n}\n\nfloat voronoi(vec2 p){\n\tvec2 n=floor(p);\n\tvec2 f=fract(p);\n\tfloat md=5.0;\n\tvec2 m=vec2(0.0);\n\n\tfor(int i=-1;i<=1;i++){\n\t\tfor(int j=-1;j<=1;j++){\n\t\t\tvec2 g=vec2(i,j);\n\t\t\tvec2 o=hash2(n+g);\n\t\t\to=0.5+0.5*sin(5.038*o);\n\t\t\tvec2 r=g+o-f;\n\t\t\tfloat d=dot(r,r);\n\t\t\tif(d<md){\n\t\t\t\tmd=d;\n\t\t\t\tm=n+g+o;\n\t\t\t}\n\t\t}\n\t}\n\treturn md;\n}\n\nfloat ov(vec2 p){\n\tfloat v=0.0;\n\tfloat a=0.4;\n\tfor(int i=0;i<3;i++){\n\t\tv+=voronoi(p)*a;\n\t\tp*=2.0;\n\t\ta*=0.5;\n\t}\n\treturn v;\n}\n\nvoid mainImage(out vec4 fragColor,in vec2 fragCoord){\n\tvec2 uv=fragCoord.xy/iResolution.xy;\n\tvec4 a=vec4(0.0,0.65,1.0,1.0);\n\tvec4 b=vec4(0.85,0.9,1.0,1.0);\n\tfragColor=vec4(mix(a,b,smoothstep(0.0,0.5,ov(uv*5.0))));\n}", "buffer_b_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcdGzl.jpg", "time_retrieved": "2024-04-28T18:59:41.003383", "access": "api", "wgpu-test": "incomplete"}
{"id": "XfGGzz", "name": "Filling Cubic Bezier 2D Shape.", "author": "Prienast", "description": "I am attempting to write a shader that utilizes a list of points to color a 2D shape composed of cubic Bezier curves. However, it seems to be coloring only specific portions of the shape, determined by the orientation of the object.\n\nCan anyone assist me?", "tags": ["bezier", "cubic", "filling", "cubicbezier"], "image_code": "/*\nExact distance to cubic bezier curve by computing roots of the derivative(s)\nto isolate roots of a fifth degree polynomial and Halley's Method to compute them.\n*/\nconst float eps = .000005;\nconst int halley_iterations = 8;\n\n//lagrange positive real root upper bound\n//see for example: https://doi.org/10.1016/j.jsc.2014.09.038\nfloat upper_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(a0,a1,a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn max_max + max_max2;\n}\n\n//lagrange upper bound applied to f(-x) to get lower bound\nfloat lower_bound_lagrange5(float a0, float a1, float a2, float a3, float a4){\n\n\tvec4 coeffs1 = vec4(-a0,a1,-a2,a3);\n\n\tvec4 neg1 = max(-coeffs1,vec4(0));\n\tfloat neg2 = max(-a4,0.);\n\n\tconst vec4 indizes1 = vec4(0,1,2,3);\n\tconst float indizes2 = 4.;\n\n\tvec4 bounds1 = pow(neg1,1./(5.-indizes1));\n\tfloat bounds2 = pow(neg2,1./(5.-indizes2));\n\n\tvec2 min1_2 = min(bounds1.xz,bounds1.yw);\n\tvec2 max1_2 = max(bounds1.xz,bounds1.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\tfloat max3 = max(max1_2.x,max1_2.y);\n\n\tfloat max_max = max(max3,bounds2);\n\tfloat max_max2 = max(min(max3,bounds2),max(minmax,maxmin));\n\n\treturn -max_max - max_max2;\n}\n\nvec2 parametric_cub_bezier(float t, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\tvec2 a0 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a1 = (3. * p0  -6. * p1 + 3. * p2);\n\tvec2 a2 = (-3. * p0 + 3. * p1);\n\tvec2 a3 = p0;\n\n\treturn (((a0 * t) + a1) * t + a2) * t + a3;\n}\n\nvoid sort_roots3(inout vec3 roots){\n\tvec3 tmp;\n\n\ttmp[0] = min(roots[0],min(roots[1],roots[2]));\n\ttmp[1] = max(roots[0],min(roots[1],roots[2]));\n\ttmp[2] = max(roots[0],max(roots[1],roots[2]));\n\n\troots=tmp;\n}\n\nvoid sort_roots4(inout vec4 roots){\n\tvec4 tmp;\n\n\tvec2 min1_2 = min(roots.xz,roots.yw);\n\tvec2 max1_2 = max(roots.xz,roots.yw);\n\n\tfloat maxmin = max(min1_2.x,min1_2.y);\n\tfloat minmax = min(max1_2.x,max1_2.y);\n\n\ttmp[0] = min(min1_2.x,min1_2.y);\n\ttmp[1] = min(maxmin,minmax);\n\ttmp[2] = max(minmax,maxmin);\n\ttmp[3] = max(max1_2.x,max1_2.y);\n\n\troots = tmp;\n}\n\nfloat eval_poly5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\n\treturn f;\n}\n\n//halley's method\n//basically a variant of newton raphson which converges quicker and has bigger basins of convergence\n//see http://mathworld.wolfram.com/HalleysMethod.html\n//or https://en.wikipedia.org/wiki/Halley%27s_method\nfloat halley_iteration5(float a0, float a1, float a2, float a3, float a4, float x){\n\n\tfloat f = ((((x + a4) * x + a3) * x + a2) * x + a1) * x + a0;\n\tfloat f1 = (((5. * x + 4. * a4) * x + 3. * a3) * x + 2. * a2) * x + a1;\n\tfloat f2 = ((20. * x + 12. * a4) * x + 6. * a3) * x + 2. * a2;\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\nfloat halley_iteration4(vec4 coeffs, float x){\n\n\tfloat f = (((x + coeffs[3]) * x + coeffs[2]) * x + coeffs[1]) * x + coeffs[0];\n\tfloat f1 = ((4. * x + 3. * coeffs[3]) * x + 2. * coeffs[2]) * x + coeffs[1];\n\tfloat f2 = (12. * x + 6. * coeffs[3]) * x + 2. * coeffs[2];\n\n\treturn x - (2. * f * f1) / (2. * f1 * f1 - f * f2);\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quadric(vec2 coeffs, inout vec2 roots){\n\n    // normal form: x^2 + px + q = 0\n    float p = coeffs[1] / 2.;\n    float q = coeffs[0];\n\n    float D = p * p - q;\n\n    if (D < 0.){\n\t\treturn 0;\n    }\n    else if (D > 0.){\n\t\troots[0] = -sqrt(D) - p;\n\t\troots[1] = sqrt(D) - p;\n\n\t\treturn 2;\n    }\n}\n\n//From Trisomie21\n//But instead of his cancellation fix i'm using a newton iteration\nint solve_cubic(vec3 coeffs, inout vec3 r){\n\n\tfloat a = coeffs[2];\n\tfloat b = coeffs[1];\n\tfloat c = coeffs[0];\n\n\tfloat p = b - a*a / 3.0;\n\tfloat q = a * (2.0*a*a - 9.0*b) / 27.0 + c;\n\tfloat p3 = p*p*p;\n\tfloat d = q*q + 4.0*p3 / 27.0;\n\tfloat offset = -a / 3.0;\n\tif(d >= 0.0) { // Single solution\n\t\tfloat z = sqrt(d);\n\t\tfloat u = (-q + z) / 2.0;\n\t\tfloat v = (-q - z) / 2.0;\n\t\tu = sign(u)*pow(abs(u),1.0/3.0);\n\t\tv = sign(v)*pow(abs(v),1.0/3.0);\n\t\tr[0] = offset + u + v;\t\n\n\t\t//Single newton iteration to account for cancellation\n\t\tfloat f = ((r[0] + a) * r[0] + b) * r[0] + c;\n\t\tfloat f1 = (3. * r[0] + 2. * a) * r[0] + b;\n\n\t\tr[0] -= f / f1;\n\n\t\treturn 1;\n\t}\n\tfloat u = sqrt(-p / 3.0);\n\tfloat v = acos(-sqrt( -27.0 / p3) * q / 2.0) / 3.0;\n\tfloat m = cos(v), n = sin(v)*1.732050808;\n\n\t//Single newton iteration to account for cancellation\n\t//(once for every root)\n\tr[0] = offset + u * (m + m);\n    r[1] = offset - u * (n + m);\n    r[2] = offset + u * (n - m);\n\n\tvec3 f = ((r + a) * r + b) * r + c;\n\tvec3 f1 = (3. * r + 2. * a) * r + b;\n\n\tr -= f / f1;\n\n\treturn 3;\n}\n\n// Modified from http://tog.acm.org/resources/GraphicsGems/gems/Roots3And4.c\n// Credits to Doublefresh for hinting there\nint solve_quartic(vec4 coeffs, inout vec4 s){\n\n\tfloat a = coeffs[3];\n\tfloat b = coeffs[2];\n\tfloat c = coeffs[1];\n\tfloat d = coeffs[0];\n\n    /*  substitute x = y - A/4 to eliminate cubic term:\n\tx^4 + px^2 + qx + r = 0 */\n\n    float sq_a = a * a;\n    float p = - 3./8. * sq_a + b;\n    float q = 1./8. * sq_a * a - 1./2. * a * b + c;\n    float r = - 3./256.*sq_a*sq_a + 1./16.*sq_a*b - 1./4.*a*c + d;\n\n\tint num;\n\n\t/* doesn't seem to happen for me */\n    //if(abs(r)<eps){\n\t//\t/* no absolute term: y(y^3 + py + q) = 0 */\n\n\t//\tvec3 cubic_coeffs;\n\n\t//\tcubic_coeffs[0] = q;\n\t//\tcubic_coeffs[1] = p;\n\t//\tcubic_coeffs[2] = 0.;\n\n\t//\tnum = solve_cubic(cubic_coeffs, s.xyz);\n\n\t//\ts[num] = 0.;\n\t//\tnum++;\n    //}\n    {\n\t\t/* solve the resolvent cubic ... */\n\n\t\tvec3 cubic_coeffs;\n\n\t\tcubic_coeffs[0] = 1.0/2. * r * p - 1.0/8. * q * q;\n\t\tcubic_coeffs[1] = - r;\n\t\tcubic_coeffs[2] = - 1.0/2. * p;\n\n\t\tsolve_cubic(cubic_coeffs, s.xyz);\n\n\t\t/* ... and take the one real solution ... */\n\n\t\tfloat z = s[0];\n\n\t\t/* ... to build two quadric equations */\n\n\t\tfloat u = z * z - r;\n\t\tfloat v = 2. * z - p;\n\n\t\tif(u > -eps){\n\t\t\tu = sqrt(abs(u));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tif(v > -eps){\n\t\t\tv = sqrt(abs(v));\n\t\t}\n\t\telse{\n\t\t\treturn 0;\n\t\t}\n\n\t\tvec2 quad_coeffs;\n\n\t\tquad_coeffs[0] = z - u;\n\t\tquad_coeffs[1] = q < 0. ? -v : v;\n\n\t\tnum = solve_quadric(quad_coeffs, s.xy);\n\n\t\tquad_coeffs[0]= z + u;\n\t\tquad_coeffs[1] = q < 0. ? v : -v;\n\n\t\tvec2 tmp=vec2(1e38);\n\t\tint old_num=num;\n\n\t\tnum += solve_quadric(quad_coeffs, tmp);\n        if(old_num!=num){\n            if(old_num == 0){\n                s[0] = tmp[0];\n                s[1] = tmp[1];\n            }\n            else{//old_num == 2\n                s[2] = tmp[0];\n                s[3] = tmp[1];\n            }\n        }\n    }\n\n    /* resubstitute */\n\n    float sub = 1./4. * a;\n\n\t/* single halley iteration to fix cancellation */\n\tfor(int i=0;i<4;i+=2){\n\t\tif(i < num){\n\t\t\ts[i] -= sub;\n\t\t\ts[i] = halley_iteration4(coeffs,s[i]);\n\n\t\t\ts[i+1] -= sub;\n\t\t\ts[i+1] = halley_iteration4(coeffs,s[i+1]);\n\t\t}\n\t}\n\n    return num;\n}\n\nfloat cubic_bezier_dis(vec2 uv, vec2 p0, vec2 p1, vec2 p2, vec2 p3){\n\n\t//switch points when near to end point to minimize numerical error\n\t//only needed when control point(s) very far away\n\t//#if 0\n\tvec2 mid_curve = parametric_cub_bezier(.5,p0,p1,p2,p3);\n\tvec2 mid_points = (p0 + p3)/2.;\n\n\tvec2 tang = mid_curve-mid_points;\n\tvec2 nor = vec2(tang.y,-tang.x);\n\n\tif(sign(dot(nor,uv-mid_curve)) != sign(dot(nor,p0-mid_curve))){\n\t\tvec2 tmp = p0;\n\t\tp0 = p3;\n\t\tp3 = tmp;\n\n\t\ttmp = p2;\n\t\tp2 = p1;\n\t\tp1 = tmp;\n\t}\n\t//#endif\n\n\tvec2 a3 = (-p0 + 3. * p1 - 3. * p2 + p3);\n\tvec2 a2 = (3. * p0 - 6. * p1 + 3. * p2);\n\tvec2 a1 = (-3. * p0 + 3. * p1);\n\tvec2 a0 = p0 - uv;\n    \n    //compute polynomial describing distance to current pixel dependent on a parameter t\n\tfloat bc6 = dot(a3,a3);\n\tfloat bc5 = 2.*dot(a3,a2);\n\tfloat bc4 = dot(a2,a2) + 2.*dot(a1,a3);\n\tfloat bc3 = 2.*(dot(a1,a2) + dot(a0,a3));\n\tfloat bc2 = dot(a1,a1) + 2.*dot(a0,a2);\n\tfloat bc1 = 2.*dot(a0,a1);\n\tfloat bc0 = dot(a0,a0);\n\n\tbc5 /= bc6;\n\tbc4 /= bc6;\n\tbc3 /= bc6;\n\tbc2 /= bc6;\n\tbc1 /= bc6;\n\tbc0 /= bc6;\n    \n    //compute derivatives of this polynomial\n\n\tfloat b0 = bc1 / 6.;\n\tfloat b1 = 2. * bc2 / 6.;\n\tfloat b2 = 3. * bc3 / 6.;\n\tfloat b3 = 4. * bc4 / 6.;\n\tfloat b4 = 5. * bc5 / 6.;\n\n\tvec4 c1 = vec4(b1,2.*b2,3.*b3,4.*b4)/5.;\n\tvec3 c2 = vec3(c1[1],2.*c1[2],3.*c1[3])/4.;\n\tvec2 c3 = vec2(c2[1],2.*c2[2])/3.;\n\tfloat c4 = c3[1]/2.;\n\n\tvec4 roots_drv = vec4(1e38);\n\n\tint num_roots_drv = solve_quartic(c1,roots_drv);\n\tsort_roots4(roots_drv);\n\n\tfloat ub = upper_bound_lagrange5(b0,b1,b2,b3,b4);\n\tfloat lb = lower_bound_lagrange5(b0,b1,b2,b3,b4);\n\n\tvec3 a = vec3(1e38);\n\tvec3 b = vec3(1e38);\n\n\tvec3 roots = vec3(1e38);\n\n\tint num_roots = 0;\n    \n\t//compute root isolating intervals by roots of derivative and outer root bounds\n    //only roots going form - to + considered, because only those result in a minimum\n\tif(num_roots_drv==4){\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) > 0.){\n\t\t\ta[0]=lb;\n\t\t\tb[0]=roots_drv[0];\n\t\t\tnum_roots=1;\n\t\t}\n\n\t\tif(sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1])) != sign(eval_poly5(b0,b1,b2,b3,b4,roots_drv[2]))){\n            if(num_roots == 0){\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=roots_drv[2];\n                num_roots=1;\n            }\n            else{\n            \ta[1]=roots_drv[1];\n\t\t\t\tb[1]=roots_drv[2];\n                num_roots=2;\n            }\n\t\t}\n\n\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[3]) < 0.){\n            if(num_roots == 0){\n                a[0]=roots_drv[3];\n                b[0]=ub;\n                num_roots=1;\n            }\n            else if(num_roots == 1){\n                a[1]=roots_drv[3];\n                b[1]=ub;\n                num_roots=2;\n            }\n            else{\n                a[2]=roots_drv[3];\n                b[2]=ub;\n                num_roots=3;\n            }\n\t\t}\n\t}\n\telse{\n\t\tif(num_roots_drv==2){\n\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_drv[0]) < 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=roots_drv[1];\n\t\t\t\tb[0]=ub;\n\t\t\t}\n\t\t\telse if(eval_poly5(b0,b1,b2,b3,b4,roots_drv[1]) > 0.){\n\t\t\t\tnum_roots=1;\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\t\t\t}\n\t\t\telse{\n\t\t\t\tnum_roots=2;\n\n\t\t\t\ta[0]=lb;\n\t\t\t\tb[0]=roots_drv[0];\n\n\t\t\t\ta[1]=roots_drv[1];\n\t\t\t\tb[1]=ub;\n\t\t\t}\n\n\t\t}\n\t\telse{//num_roots_drv==0\n\t\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\n\t\t\tvec2 roots_trd_drv=vec2(1e38);\n\t\t\tint num_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t\tnum_roots=1;\n\n\t\t\ta[0]=lb;\n\t\t\tb[0]=ub;\n\t\t}\n        \n        //further subdivide intervals to guarantee convergence of halley's method\n\t\t//by using roots of further derivatives\n\t\tvec3 roots_snd_drv=vec3(1e38);\n\t\tint num_roots_snd_drv=solve_cubic(c2,roots_snd_drv);\n\t\tsort_roots3(roots_snd_drv);\n\n\t\tint num_roots_trd_drv=0;\n\t\tvec2 roots_trd_drv=vec2(1e38);\n\n\t\tif(num_roots_snd_drv!=3){\n\t\t\tnum_roots_trd_drv=solve_quadric(c3,roots_trd_drv);\n\t\t}\n\n\t\tfor(int i=0;i<3;i++){\n\t\t\tif(i < num_roots){\n\t\t\t\tfor(int j=0;j<3;j+=2){\n\t\t\t\t\tif(j < num_roots_snd_drv){\n\t\t\t\t\t\tif(a[i] < roots_snd_drv[j] && b[i] > roots_snd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_snd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_snd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tfor(int j=0;j<2;j++){\n\t\t\t\t\tif(j < num_roots_trd_drv){\n\t\t\t\t\t\tif(a[i] < roots_trd_drv[j] && b[i] > roots_trd_drv[j]){\n\t\t\t\t\t\t\tif(eval_poly5(b0,b1,b2,b3,b4,roots_trd_drv[j]) > 0.){\n\t\t\t\t\t\t\t\tb[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse{\n\t\t\t\t\t\t\t\ta[i]=roots_trd_drv[j];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tfloat d0 = 1e38;\n\n    //compute roots with halley's method\n    \n\tfor(int i=0;i<3;i++){\n\t\tif(i < num_roots){\n\t\t\troots[i] = .5 * (a[i] + b[i]);\n\n            for(int j=0;j<halley_iterations;j++){\n\t\t\t\troots[i] = halley_iteration5(b0,b1,b2,b3,b4,roots[i]);\n            }\n\t\t\t\n\n            //compute squared distance to nearest point on curve\n\t\t\troots[i] = clamp(roots[i],0.,1.);\n\t\t\tvec2 to_curve = uv - parametric_cub_bezier(roots[i],p0,p1,p2,p3);\n\t\t\td0 = min(d0,dot(to_curve,to_curve));\n\t\t}\n\t}\n\n\treturn sqrt(d0);\n}\n\nfloat cbrt(float x) {\n    return sign(x) * pow(abs(x), 1.0/3.0);\n}\n\n#define setX(f) if (f>=0. && f<=1. && (pow(1.0 - f, 3.0) * a.x + 3.0 * pow(1.0 - f, 2.0) * f * b.x + 3.0 * (1.0 - f) * pow(f, 2.0) * c.x + pow(f, 3.0) * d.x)>X) odd=!odd;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -0.5 to 0.5)\n    vec2 uv = (fragCoord/iResolution.xy)-0.5;\n    vec3 col = vec3(0.0);\n    \n    //Array of Points\n    //Example: Only colored halve of the Shape.\n    vec2 points[13] = vec2[13](vec2(-0.019059, -0.138985), vec2(-0.004383, -0.092896), vec2(0.130600, -0.025998), vec2(0.131997, 0.016893), vec2(0.150349, 0.083669), vec2(0.020245, 0.063541), vec2(-0.023880, 0.167949), vec2(-0.086191, 0.083313), vec2(-0.162270, 0.066590), vec2(-0.174937, 0.012071), vec2(-0.180603, -0.064884), vec2(-0.057583, -0.048424), vec2(-0.019059, -0.138985));\n\n    //Example: Only colores the outline.\n    //vec2 points[13] = vec2[13](vec2(-0.128753, -0.095351), vec2(-0.085785, -0.073139), vec2(0.056966, -0.121282), vec2(0.088283, -0.091942), vec2(0.148477, -0.057700), vec2(0.042247, 0.020064), vec2(0.084873, 0.125093), vec2(-0.019033, 0.109308), vec2(-0.084654, 0.151278), vec2(-0.132162, 0.121684), vec2(-0.190585, 0.071275), vec2(-0.091957, -0.004073), vec2(-0.128753, -0.095351));\n\n    //Example: This is the expected result. If this would be the result in all direction I would be happy af;\n    //vec2 points[13] = vec2[13](vec2(-0.113397, -0.108439), vec2(-0.073697, -0.080808), vec2(0.074117, -0.109906), vec2(0.101336, -0.076730), vec2(0.156547, -0.034925), vec2(0.041075, 0.028309), vec2(0.069627, 0.138004), vec2(-0.031330, 0.108790), vec2(-0.101868, 0.141837), vec2(-0.145106, 0.106294), vec2(-0.196449, 0.048691), vec2(-0.088830, -0.013139), vec2(-0.113397, -0.108439));\n\n    //Example: Some weird Lines.\n    //vec2 points[13] = vec2[13](vec2(-0.116850, 0.136278), vec2(-0.100436, 0.090779), vec2(-0.166799, -0.044468), vec2(-0.141798, -0.079346), vec2(-0.115707, -0.143495), vec2(-0.024741, -0.048324), vec2(0.073825, -0.104294), vec2(0.071737, 0.000784), vec2(0.121914, 0.060365), vec2(0.098774, 0.111329), vec2(0.056422, 0.175832), vec2(-0.031155, 0.087883), vec2(-0.116850, 0.136278));\n\n    //Example: Also some weird Lines.\n    //vec2 points[13] = vec2[13](vec2(0.057764, -0.117235), vec2(0.047430, -0.069983), vec2(0.130879, 0.055445), vec2(0.110644, 0.093288), vec2(0.093149, 0.160294), vec2(-0.009461, 0.077810), vec2(-0.099878, 0.146167), vec2(-0.111523, 0.041716), vec2(-0.169048, -0.010806), vec2(-0.152758, -0.064355), vec2(-0.119188, -0.133834), vec2(-0.020880, -0.058068), vec2(0.057764, -0.117235));\n\n                      \n    float direc = 1e38;  \n    bool odd = false; //odd means it is inside;\n    float  root1, root2, root3, A,B,C,D, X,Y;\n    \t\n\tfor(int i = 0; i < (13-3); i += 3)\n\t{\n\t\tvec2 a = points[i]; // Begin of the Line\n\t\tvec2 b = points[i + 1]; // Controll Point 1.\n\t\tvec2 c =  points[i + 2]; // Controll Point 2.\n\t\tvec2 d =  points[i + 3]; // End of the Line. This Point is used again in the next Iteration.\n\t\t\n\t\tdirec = min(direc, cubic_bezier_dis(uv,a,b,c,d)); // Bezier cubic line.\n        \n        // Filling using the setX function. That is useing the Method of ray casting.\n        // https://en.wikipedia.org/wiki/Point_in_polygon\n        \n        X = uv.x;\n\t\tY = uv.y;\n    \n        A = d.y - 3.0 * c.y + 3.0 * b.y - a.y;\n        B = 3.0 * c.y - 6.0 * b.y + 3.0 * a.y;\n        C = 3.0 * b.y - 3.0 * a.y;\n        D = a.y - Y;\n    \n        float Q = (3. * A * C - B * B) / (9. * A * A);\n        float R = (9. * A * B * C - 27. * A * A * D - 2. * B * B * B) / (54. * A * A * A);\n        float discriminant = Q * Q * Q + R * R;\n    \n        if (discriminant > 0.) {\n          float sqrt_discriminant = sqrt(discriminant);\n          float S = cbrt(R + sqrt_discriminant);\n          float T = cbrt(R - sqrt_discriminant);\n\n          root1 = -B / (3. * A) + S + T;\n          root2 = -B / (3. * A) - (S + T) / 2.;\n          root3 = -B / (3. * A) - (S + T) / 2.;\n\n          setX(root1);\n          setX(root2);\n          setX(root3);\n        }\n    }\n    \n    float s = 1.0;\n    \n    if(odd) // if odd == inside.\n    {\n        s *= -1.0;\n    }\n    \n    float dist = s*sqrt(direc);\n    col = vec3(clamp(dist/0.069010416666666671, 0.0, 1.0));\n                      \n    // Coloring Corner and Control Points (Red = Corner, Green Control)\n    for(int i = 0; i < 13; i++)\n    {\n        if(distance(uv, points[i]) < 0.005)\n        {\n            if(mod(float(i), 3.) == 0.)\n            {\n                col = vec3(1.0, 0.0, 0.0);\n            }\n            else{\n                col = vec3(0.0, 1.0, 0.0);\n            }\n        }\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XfGGzz.jpg", "time_retrieved": "2024-04-28T18:59:45.428543", "access": "api", "wgpu-test": "error"}
{"id": "XcyGRz", "name": "[Revision 2024] Qualif", "author": "totetmatt", "description": "I hope you had fun at Revision Shadershowdown.\nOne day I'll beat evvvvil, one day !!! :D ", "tags": ["noise", "terrain", "fov"], "image_code": "\nfloat bpm,frw;\n\nvec3 erot(vec3 p,vec3 ax,float t){\n  return mix(dot(ax,p)*ax,p,cos(t))+cross(ax,p)*sin(t);\n  }\nfloat txt(vec2 p){\n  \n  float t=  floor(bpm)+smoothstep(.1,.9,fract(bpm));\n   p = erot(p.xyy,vec3(0.,0.,1),t*(step(.3,length(p))-.5)).xy;\n  return texture(iChannel0,clamp(p*vec2(1.,-1.),-.5,.5)-.5).x;\n  }\nvec3 path(vec3 p){\n  \n   vec3 o = vec3(0.);\n   o.x +=sin(p.z*.01)*30.;\n    o.x +=tanh(cos(p.z*.053)*4.)*5.;;\n   o.y +=cos(p.z*.033)*20.;;\n    o.y +=tanh(sin(p.z*.043)*4.)*5.;;\n   return o;\n  }\nmat3 orth(vec3 p){\n   vec3 z = normalize(p),x=vec3(z.z,0.,-z.x);\n   return mat3(x,cross(z,x),z);\n  }\nfloat box(vec2 p,vec2 b){p=abs(p)-b;return length(max(vec2(0.),p))+min(0.,max(p.x,p.y));}\nvec3 cy(vec3 p,float pump){\n  \n    vec4 s = vec4(0.);\n    mat3 o = orth(vec3(-1.,2.,-3.));\n    for(float i=0.;i++<5.;){\n         p*=o;\n         p+=sin(p.xyz);\n         s+=vec4(cross(sin(p),cos(p.yzx)),1.);\n         s*=pump;\n         p*=2.;\n      }\n      return s.xyz/s.w;\n  }\nvec3 pcg3d(vec3 p){\n  \n   uvec3 q= floatBitsToUint(p)*123457u+1234567890u;\n    q.x +=q.y*q.z;q.y +=q.x*q.z;q.z +=q.y*q.x;\n  q^=q>>16u;\n  q.x +=q.y*q.z;q.y +=q.x*q.z;q.z +=q.y*q.x;\n  return vec3(q)/float(-1U);\n  }\nvec2 sdf(vec3 p){\n  vec3 c = cy(p,2.);\n    vec3 ph =path(p);\n    vec3 hp=p-ph;\n   vec2 h;\n  h.x = box(hp.xy-c.yz*.4,vec2(1.,2.));\n  h.y = 1.+step(.9,fract(p.y))+length(c);\n  \n  vec3 tp=p-c*.4;\n  vec2 t;\n  t.x = dot(vec3(0.,1.,0),tp)-step(-10.,-p.z)*100.+dot(sin(tp*.45),cos(tp.yzx*.12))/.13;\n  h.x = max(-h.x,t.x*.13);\n  \n  \n  tp=p-ph;\n  \n  tp.z = mod(tp.z,10.)-5.;\n  tp=erot(tp,vec3(0.,1.,0),bpm+floor(p.z/10.));\n  vec2 q =vec2((1.-txt(tp.xy))*.1,abs(tp.z));\n  t.x = max(length(tp.xy)-.5, length(max(vec2(0.),q))+min(0.,max(q.x,q.y)));\n  \n  h=t.x< h.x ? t:h;\n  \n  \n    tp=p-ph;\n \n \n  t.x = max(abs(tp.z-frw)-2., length(tp.xy)-abs(length(c)*.7));\n  t.y = -1.;\n  h=t.x< h.x ? t:h;\n  return h;\n  \n  }\n  \n #define q(s) s*sdf(p+s).x\n  vec3 norm(vec3 p,float ee){vec2 e=vec2(-ee,ee);return normalize(q(e.xyy)+q(e.yxy)+q(e.yyx)+q(e.xxx));}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n bpm = 174./60.*iTime;\n frw = bpm *4.;\n    vec3 rnd= pcg3d(vec3(uv,bpm));\n  float wheeeee = clamp(tanh(sin(bpm*.125+rnd.x*.1)*4.),0.,1.);\n\tvec3 col = vec3(0.);\n  uv *= 1.-.5*step(.4,abs(uv.y));\n  \n  uv = erot(uv.xyy,vec3(0.,0.,1),sin(bpm*0.125+cos(bpm*.5))).xy;\n  vec3 ro= vec3(0.5,0.5,-5.+frw),rt=vec3(0.,0.,5.+frw);\n  ro=erot(ro,vec3(0.,0.,1),bpm*.5);\n  ro+=path(ro);\n  rt+=path(rt);\n  vec3 rd= orth(rt-ro)*normalize(vec3(uv,1.-.9*wheeeee));\n  vec3 rp=ro;\n  vec3 acc=vec3(0.);\n  vec3 light =vec3(1.,2.,-3.+frw);\n  light +=path(light);\n  vec2 d;\n  float rl=0.,i=0.;;\n  for(;i++<128.;){\n    \n      d = sdf(rp);\n      if(d.y <=0.){\n            vec3 cc= d.y ==-1. ? sin(vec3(.2,.5,.9)+rp.z)*.5 :vec3(.2,.5,.9);\n           acc+=cc*exp(-abs(d.x))/10.;\n         \n          d.x = max(.001,abs(d.x));\n        }\n      rl+=d.x;\n      rp=ro+rd*rl;\n     if(d.x< .001)break;\n     }\n     if(d.x< .001){\n         vec3 n = norm(rp,.001); \n         vec3 ld = normalize(light-rp);\n        float dif = max(0.,dot(ld,n));\n        float spc = max(0.,pow(dot(reflect(ld,n),rd),32.));\n        float sss = clamp(sdf(rp+ld*.4).x/.4,0.,1.);\n         float fre = pow(1.+dot(rd,n),4.);\n         vec3 cc= d.y >1.9 ? vec3(.9,.5,.2)*sqrt(texture(iChannel1,vec2(fract(iTime+rp.z+d.y))).r)*3.:vec3(.2);\n         col = cc*(dif+sss*.5)+spc*vec3(.9,.5,.2);\n         col = mix(vec3(.1),col,1.-fre);\n       }\n       col = mix(col,mix(vec3(.2,.5,.9),vec3(.9,.5,.2),uv.y),1.-exp(-.0001*rl*rl));\n    \n    // Output to screen\n    fragColor = vec4(col+acc,1.0);\n}", "image_inputs": [{"id": 49, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 37108, "src": "https://soundcloud.com/lug00ber/flipside-lug00ber-lovin-u", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XcyGRz.jpg", "time_retrieved": "2024-04-28T18:59:45.435524", "access": "api", "wgpu-test": "error"}
{"id": "4cyGzR", "name": "Rainbow diamonds", "author": "jarble", "description": "A colorful diamond pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\n    float scale = 1.5;\n\n\nvoid transform(inout vec2 uv, inout vec2 t2, inout vec3 col,inout float c1){\n    uv.y -= 1./4.;\n        \n        uv = (uv+t2)/scale;\n        //if(uv.y>-1./4.)\n        uv = (fract(vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        \n        t2 = triangle_wave(uv-.5);\n        uv =\n            //t2-triangle_wave(uv.yx)+fract(t2/2.)\n            \n            //looks better with more iterations\n            t2-triangle_wave(uv.yx)-fract(t2/2.)-vec2(floor(uv.x),0.)\n        ;\n        \n        //if(uv.x>uv.y)\n\n        //t2.x += floor(uv.x);\n\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    vec3 col1 = col;\n    float c1=0.;\n    for(int k = 0; k < 9; k++){\n        \n        vec2 uv_1 =\n            uv\n            \n            //WOW!\n            //uv-mod(uv,1.)/3.\n            \n            //uv-fract(t2/2.)\n            //uv/2.\n        ;\n        vec2 t2_1 =\n            t2\n            //t2-fract(t2/2.)\n            //t2*2.\n        ;\n        \n        transform(uv,t2,col,c1);\n        transform(uv_1,t2_1,col,c1);\n        \n        //uv_1 = triangle_wave((uv_1.yx+.5)/1.5);\n        \n        c1 =\n            //max(abs(uv.y-uv.x*sign(uv.x-uv.y))/2.,c1)\n            max(abs(uv_1.y+uv_1.x),c1)\n        ;\n        c1 =\n            //max(1.-abs(2.*c1-1.),c1/4.)\n            c1\n            //more colorful\n            //abs(2.*c1-1.)\n            \n            //Spooky!\n            //max(abs(2.*c1-2.),c1/4.)/2.\n        ;\n        col.x =\n            //max(length(uv_1-t2_1-c1)/3.,col.x)\n            \n            //blue and white\n            c1\n            \n            //red and blue and white\n            //max(1.-abs(2.*c1-1.),c1/4.)\n\n            \n            //more colorful\n            //max(length(uv-t2-c1)/3.,1.-col.x)\n            \n            //blue and green\n            //max(length(uv-c1)/3.,col.x)\n           \n            //purple\n            //2. - max((abs(uv.y-uv.x))/3.,col.x)\n           \n            //black and white\n            //col.x\n        ;\n        //if(uv.y<-.25)\n        col =\n            abs(col-(1.-(c1*col.x)))\n            //1.-abs(col.yzx+c1*col.x)\n            //abs(col*c1-(1.-(col.x)))\n            //1.-abs(col-c1*col.x)\n            //c1*col.x-col\n        ;\n        //if(uv.x<-.25)\n        col1 =\n            abs(col1*c1-col-1.).yzx\n            \n            //more colorful\n            //abs(col1-col-1.).yzx\n            \n            //more like a mosaic\n            //abs(col1*c1-col*sign(t2.y-t2.x)-1.).yzx\n            \n            //abs(col1-col*c1-1.).yzx\n            //abs(col1*c1/2.-col).yzx*2.\n        ;\n    }\n    return col1;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 1.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec3 col1 = fractal(uv);\n    fragColor = vec4(col1/2.,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cyGzR.jpg", "time_retrieved": "2024-04-28T18:59:45.474421", "access": "api", "wgpu-test": "ok"}
{"id": "4cGGzR", "name": "Sakura Dance ðŸŒ¸", "author": "Makio64", "description": "Variation on my previous shader Sakura Rain, playing more on the FBM noise", "tags": ["noise", "fbm", "dance", "sakura"], "image_code": "//noise & fbm from : https://www.shadertoy.com/view/Xds3Rj\nfloat hash(float x)\n{\n\treturn fract(21654.6512 * sin(385.51 * x));\n}\n\nfloat hash(vec2 p)\n{\n\treturn fract(21654.65155 * sin(35.51 * p.x + 45.51 * p.y));\n}\n\nfloat lhash(float x, float y)\n{\n\tfloat h = 0.0;\n\t\n\tfor(int i = 0;i < 5;i++)\n\t{\n\t\th += (fract(21654.65155 * float(i) * sin(35.51 * x + 45.51 * float(i) * y * (5.0 / float(i))))* 2.0 - 1.0) / 10.0;\n\t}\n\treturn h / 5.0 + 0.02;\n\treturn (fract(21654.65155 * sin(35.51 * x + 45.51 * y))* 2.0 - 1.0) / 20.0;\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 fl = floor(p);\n\tvec2 fr = fract(p);\n\t\n\tfr.x = smoothstep(0.0,1.0,fr.x);\n\tfr.y = smoothstep(0.0,1.0,fr.y);\n\t\n\tfloat a = mix(hash(fl + vec2(0.0,0.0)), hash(fl + vec2(1.0,0.0)),fr.x);\n\tfloat b = mix(hash(fl + vec2(0.0,1.0)), hash(fl + vec2(1.0,1.0)),fr.x);\n\t\n\treturn mix(a,b,fr.y);\n}\n\n//Fractal Brownian Motion \nfloat fbm(vec2 p)\n{\n\tfloat v = 0.0, f = 1.0, a = 0.5;\n\tfor(int i = 0;i < 5; i++)\n\t{\n\t\tv += noise(p * f) * a;\n\t\tf *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//Fun start here\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.0 -1.0;\n\tuv.x *= iResolution.x / iResolution.y;\t\n    uv.x += sin(iTime);\n    uv.y += cos(iTime);\n\n    //sakura color with some rgb variation\n    float r = noise(uv*2.)*.65+.75;\n    float g = 0.21 + .2 * abs(sin(iTime));\n    float b = 0.25  + .3 * abs(cos(iTime*.7));\n    vec3 sakuraCol = vec3(r,g,b);\n    \n    //start the noise at time 1000, change to 0 to see the dive into the noise\n    vec3 maskRain = vec3( fbm(uv+vec2(0.,iTime+noise(uv*(1000.+iTime*5.)))) );\n\tvec3 col = maskRain;\n\n    float mask = fbm(iTime+vec2(noise(uv*0.5+vec2(sin(iTime*.2),iTime*.1)),iTime+noise(uv*1.7+vec2(0.*0.3,iTime*.1)))*4.);\n    //float mask = fbm(uv+vec2(0.,iTime))+.1;\n    \n    // test\n    col *= sakuraCol;\n    col += sakuraCol * mask;\n    col = max(vec3(.2),col);\n    // col = mix(col, sakuraCol, mask);\n    // col *= mask;\n    \n    //col = vec3(mask); // debug the mask\n    //col = vec3(maskRain + .5); // debug the mask\n    //col = sakuraCol;// debug the sakura\n   \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cGGzR.jpg", "time_retrieved": "2024-04-28T18:59:45.510324", "access": "api", "wgpu-test": "ok"}
{"id": "4cyGRR", "name": "Sakura Rain ðŸŒ¸", "author": "Makio64", "description": "While I was doing some exploration for a client I did this version inspired by the Sakura season mix with gloomy day in Seoul.\nAfter a while the shader start doing some weird stuffs, but as always I kinda like it !\nIts like the day keep going on.", "tags": ["noise", "fbm", "rain", "sakura"], "image_code": "//noise & fbm from : https://www.shadertoy.com/view/Xds3Rj\nfloat hash(float x)\n{\n\treturn fract(21654.6512 * sin(385.51 * x));\n}\n\nfloat hash(vec2 p)\n{\n\treturn fract(21654.65155 * sin(35.51 * p.x + 45.51 * p.y));\n}\n\nfloat lhash(float x, float y)\n{\n\tfloat h = 0.0;\n\t\n\tfor(int i = 0;i < 5;i++)\n\t{\n\t\th += (fract(21654.65155 * float(i) * sin(35.51 * x + 45.51 * float(i) * y * (5.0 / float(i))))* 2.0 - 1.0) / 10.0;\n\t}\n\treturn h / 5.0 + 0.02;\n\treturn (fract(21654.65155 * sin(35.51 * x + 45.51 * y))* 2.0 - 1.0) / 20.0;\n}\n\nfloat noise(vec2 p)\n{\n\tvec2 fl = floor(p);\n\tvec2 fr = fract(p);\n\t\n\tfr.x = smoothstep(0.0,1.0,fr.x);\n\tfr.y = smoothstep(0.0,1.0,fr.y);\n\t\n\tfloat a = mix(hash(fl + vec2(0.0,0.0)), hash(fl + vec2(1.0,0.0)),fr.x);\n\tfloat b = mix(hash(fl + vec2(0.0,1.0)), hash(fl + vec2(1.0,1.0)),fr.x);\n\t\n\treturn mix(a,b,fr.y);\n}\n\n//Fractal Brownian Motion \nfloat fbm(vec2 p)\n{\n\tfloat v = 0.0, f = 1.0, a = 0.5;\n\tfor(int i = 0;i < 5; i++)\n\t{\n\t\tv += noise(p * f) * a;\n\t\tf *= 2.0;\n\t\ta *= 0.5;\n\t}\n\treturn v;\n}\n\n//Fun start here\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv = uv*2.0 -1.0;\n\tuv.x *= iResolution.x / iResolution.y;\t\n\n    //sakura color with some rgb variation\n    float r = noise(uv*2.)*.25+.75;\n    float g = 0.31 + .2 * abs(sin(iTime));\n    float b = 0.5  + .2 *abs(cos(iTime*.7));\n    vec3 sakuraCol = vec3(r,g,b);\n    \n    //start the noise at time 1000, change to 0 to see the dive into the noise\n    vec3 maskRain = vec3( fbm(uv+vec2(0.,iTime+noise(uv*(1000.+iTime*5.)))) );\n\tvec3 col = maskRain;\n\n    //float mask = fbm(iTime+vec2(noise(uv*0.5+vec2(sin(iTime*.2),iTime*.1)),iTime+noise(uv*1.7+vec2(0.*0.3,iTime*.1)))*4.);\n    //float mask = fbm(uv+vec2(0.,iTime))+.1;\n    \n    // test\n    col *= sakuraCol *1.2;\n    // col = mix(col, sakuraCol, mask);\n    // col *= mask;\n    \n    //col = vec3(mask); // debug the mask\n    //col = vec3(maskRain + .5); // debug the mask\n    //col = sakuraCol;// debug the sakura\n   \n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cyGRR.jpg", "time_retrieved": "2024-04-28T18:59:45.817502", "access": "api", "wgpu-test": "ok"}
{"id": "lft3Ds", "name": "awesome sauce", "author": "jaddenki", "description": "this looks cool", "tags": ["blue"], "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n            fragColor = vec4(fragCoord / iResolution.y, 1, 0) - vec4(1.0, 0.5, 0.0, 0.0);\n    \n    vec3 cameraPosition = vec3(0.0, 0.0, iTime * 0.4);\n    \n    for (float i = fragCoord.x + iResolution.x; i >= 0.0; i--)\n    {\n        float singedDistanceField = length(\n           cos(vec3(fragColor.yyy + cameraPosition))\n        );\n        \n        fragColor *= 0.9 + 0.1 * singedDistanceField;\n    }\n    fragColor = (fragColor + fragColor.x) * 0.2;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lft3Ds.jpg", "time_retrieved": "2024-04-28T18:59:46.009988", "access": "api", "wgpu-test": "ok"}
{"id": "Mfc3zs", "name": "Satisfying tubes", "author": "Oman395", "description": "Relatively basic ~~effective reupload of a couple people's work~~ shader made to look somewhat satisfying :3 kinda sorta based on those satisfying animations all over youtube. I could definitely make it a *lot* smaller but ehhhhh I don't rlly feel like it", "tags": ["raymarching", "softshadows", "infinite", "satisfying"], "image_code": "const vec3 CAM = vec3(7, 1, -1);\nconst float PI = 3.14159265;\nconst float FOCUS = 2.5;\n\nconst vec3 BG_COLOR = vec3(240, 198, 198) / 255.0;\nconst vec3 OBJECT_COLOR = vec3(145, 215, 227) / 255.0;\n\nvec3 rotate(vec3 vec, vec2 angles) {\n    angles = angles.yx;\n    vec = vec3(\n        vec.x,\n        vec.y * cos(angles.x) - vec.z * sin(angles.x),\n        vec.y * sin(angles.x) + vec.z * cos(angles.x)\n    );\n    vec = vec3(\n        vec.x * cos(angles.y) + vec.z * sin(angles.y),\n        vec.y,\n        -vec.x * sin(angles.y) + vec.z * cos(angles.y)\n    );\n    return vec;\n}\n\nvec3 camPos(float iTime, vec2 iMouse) {\n    return CAM;\n}\n\nvec2 camDir(float iTime, vec2 iMouse) {\n    return vec2(-PI * 0.6, PI * 0.02);\n}\n\n// Most ray marching code \"borrowed\" from https://www.shadertoy.com/view/Xds3zN, \n// https://iquilezles.org/articles/distfunctions/, and\n// https://iquilezles.org/articles/rmshadows/\n// Inigo Quilez is the absolute most based person in existence tbh\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat sdSphere( vec3 p, float s ) {\n    return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, vec2 h ) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nvec2 map(vec3 p) {\n    float theta = 0.5 * PI * iTime;\n    theta += 0.05 * PI * floor((p.z + 0.5 * iTime) / 2.5);\n    theta *= -1.0;\n    theta += PI * 1.2;\n    p.z = mod(p.z + 0.5 * iTime, 2.5) - 1.25;\n    float cd = sdTorus(p.yzx - vec3(-1.5, 0, -4), vec2(4, 0.5));\n    cd = max(-sdPlane(p - vec3(-4, -1.5, 0), vec3(cos(theta), sin(theta), 0), 0.0), cd);\n    cd = min(sdCylinder(p.yxz - vec3(2.5,-5,0), vec2(0.5, 1.01)), cd);\n    float d = cd;\n    int inter = 0;\n    cd = max(-sdCylinder(p, vec2(0.5, 5.0)), -sdBox(p - vec3(19, 10.5, 0), vec3(22, 11, 50)) + 1.0);\n    if(cd < d) {\n        inter = 1;\n        d = cd;\n    }\n    return vec2(d, inter);\n}\n\nvec2 march( in vec3 ro, in vec3 rd, float mint, float maxt) {\n    float t = mint;\n    int mostRecent = -1;\n    for(int i=0; i<256 && t<maxt; i++) {\n        vec2 ma = map(ro + t*rd);\n        float h = ma.x;\n        mostRecent = int(ma.y);\n        t += h;\n        if(t>maxt ) {\n            return vec2(t, -1);\n        }\n        if(h < mint) break;\n    }\n    return vec2(\n        t,\n        mostRecent\n    );\n}\n\nfloat softShadow( in vec3 ro, in vec3 rd, float mint, float maxt, float w ) {\n    float res = 1.0;\n    float t = mint;\n    int mostRecent = -1;\n    for(int i=0; i<256 && t<maxt; i++) {\n        float h = map(ro + t*rd).x;\n        res = min( res, h/(w*t) );\n        t += clamp(h, 0.005, 0.50);\n        if( res<-1.0 || t>maxt ) break;\n    }\n    res = max(res,-1.0);\n    return 0.25*(1.0+res)*(1.0+res)*(2.0-res);\n}\n\n// Based on code found on a discord server lmfao\nfloat ao(vec3 ro, vec3 norm, float stepSize, int stepCount) {\n\tfloat res = 0.0;\n\tvec3 rp;\n\t// TBH I like vaguely understand how this works but not enough to explain it\n\tfor(int i = 1; i< stepCount; i++) {\n\t\trp = ro + stepSize * float(i) * norm;\n\t\tres += (1.0/pow(2.0,float(i)))*(stepSize*float(i)-(map(rp).x));\n\t}\n\tif(res >= 0.0) {\n\t\treturn 1.0 - clamp(1.0 - stepSize / res, 0.0, 1.0);\n\t}\n    else return 1.0;\n}\n\n\nvec3 normal( in vec3 p ) {\n    const float h = 0.0001;\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\n// https://github.com/glslify/glsl-specular-beckmann/blob/master/distribution.glsl\nfloat beckmannDistribution(float x, float roughness) {\n  float NdotH = max(x, 0.0001);\n  float cos2Alpha = NdotH * NdotH;\n  float tan2Alpha = (cos2Alpha - 1.0) / cos2Alpha;\n  float roughness2 = roughness * roughness;\n  float denom = 3.141592653589793 * roughness2 * cos2Alpha * cos2Alpha;\n  return exp(tan2Alpha / roughness2) / denom;\n}\n\nfloat cookTorranceSpecular(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float fresnel) {\n\n  float VdotN = max(dot(viewDirection, surfaceNormal), 0.0);\n  float LdotN = max(dot(lightDirection, surfaceNormal), 0.0);\n\n  //Half angle vector\n  vec3 H = normalize(lightDirection + viewDirection);\n\n  //Geometric term\n  float NdotH = max(dot(surfaceNormal, H), 0.0);\n  float VdotH = max(dot(viewDirection, H), 0.000001);\n  float x = 2.0 * NdotH / VdotH;\n  float G = min(1.0, min(x * VdotN, x * LdotN));\n  \n  //Distribution term\n  float D = beckmannDistribution(NdotH, roughness);\n\n  //Fresnel term\n  float F = pow(1.0 - VdotN, fresnel);\n\n  //Multiply terms and done\n  return  G * F * D / max(3.14159265 * VdotN * LdotN, 0.000001);\n}\n\n\n// https://github.com/glslify/glsl-diffuse-oren-nayar/blob/master/index.glsl\nfloat orenNayarDiffuse(\n  vec3 lightDirection,\n  vec3 viewDirection,\n  vec3 surfaceNormal,\n  float roughness,\n  float albedo) {\n  \n  float LdotV = dot(lightDirection, viewDirection);\n  float NdotL = dot(lightDirection, surfaceNormal);\n  float NdotV = dot(surfaceNormal, viewDirection);\n\n  float s = LdotV - NdotL * NdotV;\n  float t = mix(1.0, max(NdotL, NdotV), step(0.0, s));\n\n  float sigma2 = roughness * roughness;\n  float A = 1.0 + sigma2 * (albedo / (sigma2 + 0.13) + 0.5 / (sigma2 + 0.33));\n  float B = 0.45 * sigma2 / (sigma2 + 0.09);\n\n  return albedo * max(0.0, NdotL) * (A + B * s / t) / PI;\n}\n\n// https://github.com/dmnsgn/glsl-tone-map/blob/main/aces.glsl\nvec3 aces(vec3 x) {\n  const float a = 2.51;\n  const float b = 0.03;\n  const float c = 2.43;\n  const float d = 0.59;\n  const float e = 0.14;\n  return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvN = (uv - 0.5) * 2.0;\n    uv.x *= iResolution.x / iResolution.y;\n    uvN.x *= iResolution.x / iResolution.y;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    mouse = (mouse - 0.5) * 2.0;\n    mouse.x *= iResolution.x / iResolution.y;\n    vec3 pos = camPos(iTime, mouse);\n    vec2 dir = camDir(iTime, mouse);\n    vec3 rayDir = normalize(vec3(uvN, FOCUS));\n    rayDir = rotate(rayDir, dir);\n    vec3 light = CAM + vec3(0,0,5);\n    vec2 impactData = march(pos, rayDir, 0.01, 20.0);\n    float energy = 1.0;\n    if(impactData.y >= 0.0) {\n        vec3 color;\n        float roughness, diffuseAlbedo;\n        vec3 specular;\n        if(impactData.y == 0.0) {\n            color = OBJECT_COLOR;\n            roughness = 0.1;\n            diffuseAlbedo = 1.0;\n            specular = vec3(1);\n        } else {\n            color = BG_COLOR;\n            roughness = 1.0;\n            diffuseAlbedo = 1.0;\n            specular = vec3(0);\n        }\n        vec3 impactPos = pos + rayDir * impactData.x;\n        vec3 impactNormal = normal(impactPos);\n        vec3 impactToLight = normalize(light - impactPos);\n        vec3 incomingLight = color * orenNayarDiffuse(impactToLight, normalize(pos - impactPos), impactNormal, roughness, diffuseAlbedo); // kd\n        incomingLight += specular * cookTorranceSpecular(impactToLight, normalize(pos - impactPos), impactNormal, roughness, 0.5); // ks\n        incomingLight *= softShadow(impactPos, impactToLight, 0.1, distance(impactPos, light), 0.3);\n        incomingLight /= pow(distance(impactPos, light) / 10.0, 2.0);\n        incomingLight *= energy;\n        \n        incomingLight += 0.8 * color * (0.7 + 0.3 * pow(ao(impactPos, impactNormal, 0.2, 6), 0.5)); // ka\n        fragColor = vec4(aces(incomingLight), 1);\n    } else fragColor = vec4(0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mfc3zs.jpg", "time_retrieved": "2024-04-28T18:59:47.202795", "access": "api", "wgpu-test": "ok"}
{"id": "Xfd3Ds", "name": "Orange planet", "author": "Fakedy", "description": "planet.", "tags": ["raytracing", "planet"], "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float aspect = iResolution.x/iResolution.y;\n    vec2 uv = (fragCoord/vec2(iResolution.x, iResolution.y))*2.0f - 1.0f;\n    uv = vec2(uv.x*aspect,uv.y);\n    vec3 col = vec3(1.0,0.0,1.0);\n   \n    vec3 spherePosition = vec3(0.0f,0.0f, 0.0f);\n    \n    vec3 camera = vec3(uv,2.0f);\n    camera = camera - spherePosition;\n    vec3 lookDir = vec3(0.0f,0.0f,-1.0f);\n    float radius = 0.5f;\n    \n    float a = dot(lookDir, lookDir);\n    float b = 2.0f * dot(camera, lookDir);\n    float c = dot(camera, camera) - (radius*radius);\n    \n    float disc = b*b - 4.0f * a * c;\n    \n    \n    float t = ((-b - sqrt(disc)) / (2.0f * a));\n    c = pow(t,4.8f)/25.0f;\n    vec3 hitPoint = camera + lookDir*t;\n    vec4 temp = texture(iChannel0, vec2(hitPoint.x + iTime/25.0f, hitPoint.y)/0.3f);\n    vec4 temp1 = texture(iChannel1, vec2(hitPoint.x / iTime/25.0f, hitPoint.y*t)/0.8f);\n    vec3 normal = normalize(hitPoint); // normal calculation, sphere in origin no calc needed.\n    \n    vec3 lightDir = vec3(-1.0, 0.3f, 0.8f);\n    float lightIntensity = dot(normal, lightDir);\n\n    \n    // Output to screen\n    fragColor = vec4(vec3(t,c,0.0),1.0)*((temp*t*temp1)*lightIntensity);\n}", "image_inputs": [{"id": 3, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 46, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Xfd3Ds.jpg", "time_retrieved": "2024-04-28T18:59:47.421211", "access": "api", "wgpu-test": "ok"}
{"id": "Mc33WX", "name": "NotSoGreeeen - 2D Sphere", "author": "NotSoGreeeen", "description": "A step above my old sphere, this time it doesn't rely on the same tricks as the last one, which just tricked your brain into thinking it was real\n\nAdded a atmosphere effect on a whim, seems to help the illusion as well.", "tags": ["beginner", "sphere"], "image_code": "vec3 circle(vec2 uv, vec3 color) {\n    return vec3(smoothstep(.85, .8, length(uv.xy))) * color; //draw a sphere :P\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y); //align uv to -1, 1 grid, and keep it square, no matter the dimensions of the screen\n    \n    vec3 lightSphere = circle(uv, vec3(.9, .5, .3)); //sphere for main lighting\n    lightSphere *= smoothstep(1., 0., length(uv - .5)) * .4; //turn it into it's light point\n    \n    vec3 midSphere = circle(uv, vec3(.9, .5, .3) / 4.); //mid-distance lighting sphere\n    midSphere *= smoothstep(1., 0., length(uv /3. - .5)) * 6.6; //apply it's lighting values\n    \n    vec3 col = circle(uv, vec3(.9, .5, .3) / 6.); //draw in the darkest sphere\n    col *= texture(iChannel0, uv * 2. + atan(tan(iTime / 10.))).rgb;\n    col *= texture(iChannel0, uv * 2. + atan(tan((iTime + 2.) / 10.))).rgb;\n    col += midSphere + lightSphere; //apply the two lighting passes\n    \n    vec3 color = vec3(smoothstep(1., .8, length(uv.xy))) * vec3(.3, .5, .9) / 8.3;\n    color += col;\n    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": 17, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mc33WX.jpg", "time_retrieved": "2024-04-28T18:59:47.458112", "access": "api", "wgpu-test": "ok"}
{"id": "XctGWs", "name": "Another Rule 110", "author": "krazykylep", "description": "A scrolling view of a Cellular Automata simulating rule 110", "tags": ["cellularautomata", "rule110"], "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord){\n    fragColor = texture(iChannel0, fragCoord / iResolution.xy);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "float rand(vec2 co) {\n    return fract(sin(dot(co, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    ivec2 iuv = ivec2(fragCoord.xy);\n    if (iFrame < 2 && fragCoord.x < 1.) {\n        // set up initial state\n        fragColor = vec4(round(rand(vec2(fragCoord.y, fract(iDate.w / 1000.)))));\n    } else if (iFrame > 1) {\n        if (fragCoord.x < 1.) {\n            // calculate next gen if we are on column 0\n            vec4 up = texelFetch(iChannel0, iuv + ivec2(0, 1), 0);\n            vec4 center = texelFetch(iChannel0, iuv, 0);\n            vec4 down = texelFetch(iChannel0, iuv + ivec2(0, -1), 0);\n            if ((up.r > 0.5 && center.r > 0.5 && down.r > 0.5) || (up.r > 0.5 && center.r > 0.5 && down.r < 0.5) || (up.r < 0.5 && center.r < 0.5 && down.r < 0.5)) {\n                fragColor = vec4(1.);\n            } else {\n                fragColor = vec4(0.);\n            }\n        } else {\n            // move all other columns towards the right by copying your left neighbor.\n            vec4 pixelLookupL = texelFetch(iChannel0, iuv + ivec2(-1, 0), 0);\n            fragColor = pixelLookupL;\n        }\n    }\n}\n", "buffer_a_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XctGWs.jpg", "time_retrieved": "2024-04-28T18:59:47.492022", "access": "api", "wgpu-test": "incomplete"}
{"id": "4fdGDl", "name": "Deterministic Fireworks", "author": "milkfat", "description": "Fully deterministic large-caliber fireworks. Use the mouse to scrub backward/forward through time.", "tags": ["procedural", "sphere", "glow", "deterministic", "fireworks"], "image_code": "/*\n\nCode written 2021-08-25\n\nPublished 2024-04-04\n\n*/\n\n\n#define PI 3.14159\n//#define TRAILS\n#define NUM_SHELLS 3\n#define TIME iTime\n\nvec2 rotate(vec2 p, float a) {return vec2 (cos(a)*p.x - sin(a)*p.y, sin(a)*p.x + cos(a)*p.y);}\nfloat moda(float r) {return (mod(1.0+r/PI,2.0)-1.0)*PI;}\n\n//float hash(float n) {return fract(n*fract(n*.133929));}\nfloat hash(float p) {\n   // p=isnan(p)?0.0:p;\n    p=fract(p*.917331);\n    uint b = uint(p*123456.7);\n\tb += 0x9e3779b9u;\n\tb ^= b >> 15;\n\tb *= 0x85ebca6bu;\n\tb ^= b >> 13;\n\tb *= 0xc2b2ae3du;\n\tb ^= b >> 16;\n\treturn fract(abs(float(b)/1000000.0));\n}\n\nfloat vf(vec3 p) {return fract(p.x)*fract(p.y)*fract(p.z);}\n\nfloat dist(vec3 p, inout vec3 col, float seed, inout vec3 col2, float time)\n{\n    seed=hash(seed);\n    vec3 mx = vec3(iResolution.xy*(4000.0/iResolution.y),4000);\n    float md = 3.0+seed;\n    float mdx = md;\n    float tmd = mod(time,md);\n    float tid = time/md;\n    float stp = tmd/md;\n    stp=stp*(mdx/(3.0+seed));\n    \n    float rand = hash(seed+1.12*floor(tid));\n    float rand2 = hash(seed+.9713*floor(tid));\n    \n    vec3 loc = vec3(rand*mx.x*.9-mx.x*.45,rand2*mx.y*.5-mx.y*.125,4000); //burst location\n    \n    //rising shell effect\n    float pre_rand = hash(seed+1.12*floor(tid+1.0));\n    float pre_rand2 = hash(seed+.9713*floor(tid+1.0));\n    vec3 pre_loc = vec3(pre_rand*mx.x*.9-mx.x*.45,pre_rand2*mx.y*.5-mx.y*.125,4000); //next burst location\n    pre_loc.y-=(1.0-stp)*(1.0-stp)*(pre_loc.y+mx.y*.5);\n    pre_loc.x-=(pre_loc.x<0.0)?(pre_loc.x+mx.x*.25)*(1.0-stp):(pre_loc.x-mx.x*.25)*(1.0-stp);\n    float d_shell = distance(p,pre_loc)-10.0;\n    \n    \n    p.y+=(stp*stp)*200.0; //gravity\n    \n    float val=stp;\n    val=val*val*val*val*val;\n    val=1.0-val;\n    val*=1.0-pow(1.0-stp,3.0);\n\n    \n    col = vec3(float(rand>.5),float(rand2>.5),float(rand<.5||rand2<.5)); //random color\n    //col = max(col,vec3(.1));\n    \n    p-=loc;\n    float lp = length(p);\n    \n    \n    \n    \n    /*\n    \n    //droop\n    float llp=lp/1000.0;\n    llp=pow(llp,llp*5.0+1.0);\n    llp*=1000.0;\n    p.y+=llp/3.0;\n    */\n    \n    float sz = (500.0+rand2*1000.0); //overall size\n    \n    //atmospheric effect\n    float burst_stp = clamp(1.0-stp*30.0,0.0,1.0);\n    float post_burst_stp = clamp(stp*8.0-1.0/30.0,0.0,1.0);\n    col=col*post_burst_stp*post_burst_stp+vec3(burst_stp*burst_stp*burst_stp);\n    float amt = clamp(((6000.0+sz)-lp)/(6000.0+sz),0.0,1.0);\n    col2+=clamp(val*col*pow(amt,5.0),0.0,1.0)*(hash(vf(p)*stp)*.5+.5)*.02; //atmosphere glow\n    col2+=pow(clamp(burst_stp*burst_stp*pow(amt,8.0),0.0,1.0),1.0)*.15*(1.0+rand2*rand2*3.0); //bright flash\n    \n    //break early\n    if(lp>sz+200.0&&d_shell>0.0){col=vec3(0);return min(d_shell,lp*.3);}\n    \n    //random rotation\n    p.yz=rotate(p.yz,rand*PI*2.0);\n    //p.xy=rotate(p.xy,iTime);\n    p.xz=rotate(p.xz,rand*PI*3.1);\n    \n    //procedurally find the closest star\n    float ang1 = atan(p.y,p.x);\n    vec3 tp = p;\n    tp.xy = rotate(tp.xy, -ang1);\n    float ang2 = atan(tp.z,tp.x);\n    \n    float dense = (11.0+rand2*11.0)/PI; //star density\n\n    ang2 = round(ang2*(dense))/(dense);\n    float h = abs(ang2/PI);\n    h = abs(.5-h);\n    h*=2.0;\n    \n    ang1 = round(ang1*(h*dense))/(h*dense);\n    ang1 = moda(ang1);\n    ang2 = moda(ang2);\n    float h1 = hash(ang1);\n    float h2 = hash(ang2);\n    float h3 = hash(ang1*ang2);\n    ang1+=h2*h3*(.1)-.05; //slightly random star position\n    ang2+=h1*h3*(.1)-.05;\n    \n    p.xy = rotate(p.xy,-ang1);\n    p.xz = rotate(p.xz,-ang2);\n    \n    \n    //variegated colors\n    if(hash(rand2)>.7)\n    col = vec3(h1,h2,h3);\n    \n    //overall size of the firework based on time\n    sz+=h3*40.0*(burst_stp>0.0?10.0:1.0)-20.0; //slightly random star velocity\n    float m = tmd;\n    m/=mdx;\n    m*=.7;\n    m=1.0-m;\n    m=pow(m,m*5.0+1.0); //deceleration\n    m=1.0-m;\n    m=clamp(m,0.0,1.0);\n    m=m*sz;\n    \n    //calculate distance to star\n    float d1 = distance(p,vec3(1.0+m,0,0));\n    #ifdef TRAILS\n    float d2 = length(vec3(max(p.x-m,0.0),p.yz)); //trails\n    float d=(d1<.0)?d1:d2;\n    #else\n    float d = d1;\n    #endif\n    \n    //add some randomness to each star's life/brightness\n    float m2 = tmd;\n    m2/=md;\n    m2+=h3*h3*.3;\n    m2=m2*m2*m2*m2*m2;\n    m2=1.0-m2;\n\n    //add some star glow\n    float cm = 9.0-d;\n    cm/=9.0;\n    cm=clamp(cm,0.0,1.0);\n    cm=pow(cm,2.0);\n    \n    //add some atmospheric glow\n    float cm2 = 100.0-d;\n    cm2/=100.0;\n    cm2=clamp(cm2,0.0,1.0);\n    cm2=pow(cm2,5.0);\n    //col=(abs(ang2)<.1||abs(ang2)>.9)?col:col=vec3(0); //bow tie\n    \n    \n    \n    #ifdef TRAILS\n    if(d1>5.0)\n    {\n        float t = clamp(clamp(p.x/m,0.0,1.0)*2.0-1.0,0.0,1.0)*.08;\n        float v = (col.x+col.y+col.z)/3.0;\n        col=vec3(v*1.2,v*1.1,v);\n        col*=t;\n    }\n    #endif\n    \n    col2 += clamp(cm2*col*m2*1.0,0.0,1.0); //star glow\n    \n    //final star brightness\n    col *= cm*m2*.3; //star light\n    col=max(col,vec3(0));\n    \n    d = min(d_shell,d);\n    if(d==d_shell)col=vec3(pow(clamp(1.0-(d_shell*.1+1.0),0.0,1.0),2.0))*vec3(.04,.02,.02);\n    return d;\n    \n    \n    //float asdf = hash(hash(ang1)*ang2)*2.0-1.0;\n    //return (lp-(500.0-asdf*50.0));\n\n}\n\n\nvoid mainImage( out vec4 F, in vec2 C )\n{\n    C-=iResolution.xy*.5;\n    vec3 p = vec3(C,0.0);\n    vec3 ps = normalize(vec3(C*(4000.0/iResolution.y),4000.0)-p);\n    vec3 col=vec3(0);\n    vec3 col2=vec3(0);\n    float mowss = (iMouse.z>0.0)?(iMouse.x*30.0)/iResolution.x-15.0:0.0;\n    for (int i = 0; i < 200; i++)\n    {\n        float min_d = 10000.0;\n        vec3 c2=vec3(0);\n        for (int j; j<NUM_SHELLS; j++)\n        {\n            vec3 c;\n            float d = max(dist(p, c, hash(float(j)), c2,TIME+mowss),1.0);\n            min_d=min(min_d,d);\n            col+=c;\n        }\n        if(p.z>7500.0)break;\n        col2+=(c2)*min_d*.004;\n        p+=ps*max(min_d,1.0)*.9;\n    }\n    col+=col2*.02;\n    F=vec4(col,0);\n    F*=8.0;\n    F=pow(F,vec4(1./2.2));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fdGDl.jpg", "time_retrieved": "2024-04-28T18:59:48.640013", "access": "api", "wgpu-test": "ok"}
{"id": "lf3GDs", "name": "Greetings, 0b5vr", "author": "Zavie", "description": "This shader draws the logo of the demogroup \"0b5vr\".\n\nMore logos: https://www.shadertoy.com/playlist/NX3yzf", "tags": ["demoscene", "logo"], "image_code": "/*\n\nThis shader draws the logo of the demoscene group \"0b5vr\".\n\n0b5vr:\n > https://0b5vr.com/\n > https://www.shadertoy.com/user/0b5vr\n > https://www.youtube.com/watch?v=3lOptjAeA2w\n\n--\nZavie / Ctrl-Alt-Test\n\n*/\n\nfloat _0b5vrLogo(vec2 p)\n{\n    p = abs(p);\n    float d = max(p.x, p.y) * 4.;\n    d = abs(abs(d) - 0.5) - 0.5;\n    d = abs(d * 2.) - 0.5;\n    d = max(d, min(p.x, p.y) * 8. - 1.5);\n\n    return d / 8.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\n    float d = _0b5vrLogo(uv - vec2(0.9, 0.5));\n\n    fragColor = vec4(draw(iResolution, d), 1.0);\n}\n", "image_inputs": [], "common_code": "#define DEBUG_DISTANCE 0\n\n// See: https://www.shadertoy.com/view/XcVGRR\nvec3 debugDistance(vec3 iResolution, float d, vec3 color)\n{\n    float refWidth = iResolution.y / 1080.;\n\n    float dd1 = fwidth(d);\n    float width1 = 2.5 * dd1 * refWidth;\n    float iso1 = smoothstep(1. - width1 - dd1, 1. - width1 + dd1, abs(fract(d) * 2. - 1.));\n\n    float dd5 = fwidth(5. * d);\n    float width5 = 0.75 * dd5 * refWidth;\n    float iso5 = smoothstep(1. - width5 - dd5, 1. - width5 + dd5, abs(fract(5.*d) * 2. - 1.));\n\n    float dd0 = fwidth(d);\n    float width0 = 3. * dd0 * refWidth;\n    float iso0 = smoothstep(1. - width0 - dd0, 1. - width0 + dd0, 1. - abs(d));\n\n    float isoLines = max(iso0, max(iso1, iso5));\n\n    vec3 background = (d > 0. ? vec3(1.) : mix(vec3(0.8), color, 0.1));\n    vec3 lineColor = mix(color * (d > 0. ? 1. : 0.8), vec3(0.), iso0);\n\n    return mix(background, lineColor, isoLines);\n}\n\nvec3 draw(vec3 iResolution, float d)\n{\n#if DEBUG_DISTANCE\n    return debugDistance(iResolution, 10.*d, vec3(0.8, 0.5, 1.));\n#else\n    float dd = fwidth(d);\n    return vec3(1. - smoothstep(-dd / 2., dd / 2., d));\n#endif\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lf3GDs.jpg", "time_retrieved": "2024-04-28T18:59:48.822462", "access": "api", "wgpu-test": "ok"}
{"id": "Mf33Wl", "name": "Greetings, Alcatraz (official)", "author": "Zavie", "description": "This shader draws the logo of the demogroup \"Alcatraz\".\nIt uses the original logo function, courtesy of LJ/Alcatraz.\n\nMore logos: https://www.shadertoy.com/playlist/NX3yzf", "tags": ["demoscene", "logo"], "image_code": "/*\n\nThis shader draws the logo of the demoscene group \"Alcatraz\".\nThe function is the \"official\" one, courtesy of LJ.\n\nAlcatraz:\n > http://alcatraz.untergrund.net/\n > https://www.youtube.com/watch?v=YK7fbtQw3ZU\n\n--\nZavie / Ctrl-Alt-Test\n\n*/\n\nfloat AlcatrazLogo(vec2 p)\n{\n    vec2 a = abs(p);\n    return min(max(max(\n        min(abs(mod(p.x+.067,.134)-.067),max(a.x, a.y)-.1),\n        -min(length(p-vec2(0,.03))-.06,max(a.x,abs(p.y+.02)-.03)-.04)\n    ),a.x+a.y-.4),abs(a.x+a.y-.41)+.01)-0.02;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\n    float d = AlcatrazLogo(uv - vec2(0.9, 0.5));\n\n    fragColor = vec4(draw(iResolution, d), 1.0);\n}\n", "image_inputs": [], "common_code": "#define DEBUG_DISTANCE 0\n\n// See: https://www.shadertoy.com/view/XcVGRR\nvec3 debugDistance(vec3 iResolution, float d, vec3 color)\n{\n    float refWidth = iResolution.y / 1080.;\n\n    float dd1 = fwidth(d);\n    float width1 = 2.5 * dd1 * refWidth;\n    float iso1 = smoothstep(1. - width1 - dd1, 1. - width1 + dd1, abs(fract(d) * 2. - 1.));\n\n    float dd5 = fwidth(5. * d);\n    float width5 = 0.75 * dd5 * refWidth;\n    float iso5 = smoothstep(1. - width5 - dd5, 1. - width5 + dd5, abs(fract(5.*d) * 2. - 1.));\n\n    float dd0 = fwidth(d);\n    float width0 = 3. * dd0 * refWidth;\n    float iso0 = smoothstep(1. - width0 - dd0, 1. - width0 + dd0, 1. - abs(d));\n\n    float isoLines = max(iso0, max(iso1, iso5));\n\n    vec3 background = (d > 0. ? vec3(1.) : mix(vec3(0.8), color, 0.1));\n    vec3 lineColor = mix(color * (d > 0. ? 1. : 0.8), vec3(0.), iso0);\n\n    return mix(background, lineColor, isoLines);\n}\n\nvec3 draw(vec3 iResolution, float d)\n{\n#if DEBUG_DISTANCE\n    return debugDistance(iResolution, 10.*d, vec3(0.8, 0.5, 1.));\n#else\n    float dd = fwidth(d);\n    return vec3(1. - smoothstep(-dd / 2., dd / 2., d));\n#endif\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mf33Wl.jpg", "time_retrieved": "2024-04-28T18:59:48.839417", "access": "api", "wgpu-test": "ok"}
{"id": "lct3Wf", "name": "SGA Glyphs", "author": "cmzw", "description": "Those glyphs from Minecraft\n\nClick and drag â†” to browse through every glyph", "tags": ["minecraft", "cc0", "fonts", "sga", "glyphs"], "image_code": "// SGA/Standard Galactic Glyphs - License: CC0\n\n#define GLYPH_SCALE .8\n#define GRID_SCALE 4.\n\n// #define OFFSET_ROWS\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += iDate.z;\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat p(vec2 uv, int i) {\n    float ic = float(i);\n\tvec2 gr = 1.0 - abs(uv*7.-0.5 - vec2(mod(ic,7.), floor(ic/7.)));\n\treturn smoothstep(0.2,0.5,min(gr.x,gr.y));\n}\n\nfloat b(int n, int b) { return float(mod(floor(float(n) / exp2(floor(float(b)))), 2.0) != 0.0); }\n\nfloat sga(vec2 uv, int g) {\n\tconst ivec3 n[] = ivec3[](\n\t\tivec3(0x1218, 0x4081, 0x1820),\n        ivec3(0x0408, 0x0102, 0xF901),\n        ivec3(0x0004, 0xC081, 0x2040),\n        ivec3(0x1F00, 0x80C0, 0x0180),\n        ivec3(0x8122, 0x2040, 0xF810),\n        ivec3(0x8000, 0xA00F, 0x0002),\n        ivec3(0x0810, 0x0384, 0x4081),\n        ivec3(0x803E, 0x810F, 0x2040),\n        ivec3(0x0408, 0x8002, 0x2040),\n        ivec3(0x0408, 0x0100, 0x2040),\n        ivec3(0x0408, 0x8542, 0x2040),\n        ivec3(0x0A04, 0x4081, 0x10A0),\n        ivec3(0x1022, 0x0408, 0xF902),\n        ivec3(0x0912, 0x8104, 0x0820),\n        ivec3(0x081E, 0x8104, 0x0820),\n        ivec3(0x0814, 0x4285, 0x5021),\n        ivec3(0x8008, 0x040F, 0xF902),\n        ivec3(0x0012, 0x0000, 0x4800),\n        ivec3(0x0204, 0x8181, 0x2040),\n        ivec3(0x103F, 0x0408, 0x8002),\n        ivec3(0x0000, 0xE005, 0x0003),\n        ivec3(0x0408, 0xE102, 0xF803),\n        ivec3(0x0000, 0x0002, 0x0110),\n        ivec3(0x0822, 0x4104, 0x0820),\n        ivec3(0x0A14, 0x4285, 0x50A1),\n        ivec3(0x8A08, 0x2448, 0x8912)\n\t);\n\t\n\tfloat r = 0.0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tr = max(r, p(uv, i   )*b(n[g].x,i));\n\t\tr = max(r, p(uv, i+16)*b(n[g].y,i));\n\t\tr = max(r, p(uv, i+32)*b(n[g].z,i));\n\t}\n\treturn r;\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    vec2 uv = vec2(1,-1) * (2.*I - iResolution.xy) / iResolution.y;\n    vec2 grid = ( uv + vec2(iTime*0.05,0.0))*GRID_SCALE;\n    \n    #ifdef OFFSET_ROWS\n    grid -= vec2(mod(floor(grid).y,2.0)*0.5,0.0);\n    #endif\n    \n    float glyph = sga(1.0/GLYPH_SCALE*(fract(grid)-0.5)+0.5,\n        int(hash12(floor(grid))*26.));\n\n    if(iMouse.z > 0.)\n        glyph = sga(uv*.8 + .5,int(iMouse.x/iResolution.x*26.));\n\n    O = vec4(glyph);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc0-1.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lct3Wf.jpg", "time_retrieved": "2024-04-28T18:59:49.243336", "access": "api", "wgpu-test": "error"}
{"id": "4fd3Df", "name": "Sphere Sponge", "author": "starielsl", "description": "Sphere Sponge", "tags": ["sponge"], "image_code": "#define FAR 100.\n#define NEAR .0001\n#define STEPS 256\n#define ITERATIONS 6\n\n#define SCALE 3.\n\nvec4 orbitTrap = vec4(FAR);\n\nfloat Scene(vec3 p, bool isLight)\n{\n    if (!isLight) orbitTrap = vec4(FAR);\n    float scale = SCALE;\n\tfloat spongeScale = 2.05;\n\tfloat k = scale;\n\tfloat d = -FAR, md = FAR;\n\tfloat d1, r;\n\n\tfor (int i = 0; i < ITERATIONS; i++) \n    {\n        vec3 z = mod(p * k, 4.) - vec3(.5 * 4.);\n        r = length(z);\n        d1 = (spongeScale - r) / k;\n        k *= scale;\n        d = max(d, d1);\n        if (!isLight)\n        {\n            md = min(md, d);\n            orbitTrap = vec4(md, md, md, r);\n            orbitTrap.z *= sin(iTime);\n            orbitTrap.y *= cos(iTime);\n        }\n    }\n\treturn d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd, bool isLight)\n{\n    float ad = 0.;\n    for (int i = 0; i < STEPS; i++)\n    {\n        vec3 p = ro + rd * ad;\n        float d = Scene(p, isLight);\n        ad += d;\n        if(ad > FAR || d < NEAR) break;\n    }\n    return ad;\n}\n\nvec3 GetNormal(vec3 p)\n{ \n    float d = Scene(p, true);\n    vec2 e = vec2(NEAR, 0);\n    vec3 n = d - vec3(\n        Scene(p - e.xyy, true),\n        Scene(p - e.yxy, true),\n        Scene(p - e.yyx, true)\n    );\n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{ \n    vec3 lp = p + .2;\n    vec3 ld = normalize(lp - p); \n    vec3 n = GetNormal(p);\n   \n    float dif = dot(n, ld);\n    dif = clamp(dif, 0., 1.);\n\n    float d = RayMarch(p + n * NEAR * 2., ld, true); \n    \n    if (d < length(lp - p)) dif *= .1;\n \n    return dif;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord -.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(2. / SCALE, 2. / SCALE, -iTime);\n    vec2 mo = vec2(iMouse.xy / iResolution.xy - .5);\n    if (iMouse.z < 1.) mo = vec2(0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -0.5) + vec3(mo, 0));\n    float d = RayMarch(ro, rd, false);\n    vec3 p = ro + rd * d;\n    float dif = GetLight(p);\n    vec3 color = vec3(orbitTrap.x * 0.2, orbitTrap.y * 0.4, orbitTrap.z * 0.9) * orbitTrap.w + dif + .2;\n    fragColor = vec4(color, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4fd3Df.jpg", "time_retrieved": "2024-04-28T18:59:49.246329", "access": "api", "wgpu-test": "ok"}
{"id": "csKBzc", "name": "sinoiseÍ", "author": "01000001", "description": "it works", "tags": ["experiment"], "image_code": "const float pi = 3.14159;\n//hash by IQ https://www.shadertoy.com/view/XlXcW4\nconst uint k = 1103515245U;\nvec3 hash( uvec3 x )\n{\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    x = ((x>>8U)^x.yzx)*k;\n    \n    return vec3(x)*(1.0/float(0xffffffffU));\n}\n\n\nfloat noise(float t, int p){\n    float x = 0.;\n    \n    for (int i = 0; i++<p;){\n        vec3 h = hash(uvec3(i, 2<<i, 5*i));\n        x += sin(h.x * t * float(i) + h.y*pi*2.) * h.z / float(i<<1);\n    }\n\n    \n    return x;\n}\n\nvoid mainImage( out vec4 O, vec2 U ){\n    vec2 r = iResolution.xy;\n    vec2 uv = U/r;\n    vec2 cuv = (2.*U-r)/r.y;\n    \n    \n    float y;\n    /*\n    y = noise(uv.x*2. + iTime, 2<<9);\n    /*/\n    for (int i = 1; i<11; i++){\n        y = noise(cuv.x + iTime, 2<<i)*.5;\n        \n        if (abs(y - cuv.y) > 1./float(i<<1)) break;\n    }//*/\n    \n    O.x = smoothstep(0., 1./r.y, y-cuv.y);\n    O = O.xxxx;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/csKBzc.jpg", "time_retrieved": "2024-04-28T18:59:49.523587", "access": "api", "wgpu-test": "ok"}
{"id": "lcc3Df", "name": "Antialiased Canny Edge Detection", "author": "Hatchling", "description": "Anti-aliased version of the Canny edge filter with hysteresis.", "tags": ["edge", "aa", "canny"], "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    vec4 c0 = texture(iChannel0, uv); // Gradients\n    vec4 c1 = texture(iChannel1, uv); // Anti-aliased non-maxima suppression\n    vec4 c2 = texture(iChannel2, uv); // Hysteresis via cellular automata\n    c1 /= c1.a; // antialiasing is accumulative.\n    \n    //fragColor = texture(iChannel1, uv) * pow(vec4(1)-fragColor, vec4(5.0));\n    \n    fragColor = vec4(c0.z * c1.x * c2.x);\n}", "image_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 2, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "///////////////////////////////////////////////\n// HELPER FUNCTIONS\n///////////////////////////////////////////////\n\n// Constants ----------------------------------\n\nconst float Pi = 3.14159265358979;\nconst float Tau = Pi * 2.0;\nconst float InvPi = 1.0 / 3.14159265358979;\n\n// HLSL support -------------------------------\n\n#define float2 vec2\n#define float3 vec3\n#define float4 vec4\n\n#define half  float\n#define half2 vec2\n#define half3 vec3\n#define half4 vec4\n\n#define fixed  float\n#define fixed2 vec2\n#define fixed3 vec3\n#define fixed4 vec4\n\n#define int2 ivec2\n#define int3 ivec3\n#define int4 ivec4\n\n#define bool2 bvec2\n#define bool3 bvec3\n#define bool4 bvec4\n\n#define lerp mix\n\n#define decl_saturate(type)            \\\ntype saturate(type x)                  \\\n{                                      \\\n    return clamp(x, type(0), type(1)); \\\n} \n\ndecl_saturate(float)\ndecl_saturate(vec2)\ndecl_saturate(vec3)\ndecl_saturate(vec4)\n\n// Boolean -------------------------------\n\nbool  isinf2(float v) { return isinf(v); } \nbvec2 isinf2(vec2 v)\n{\n    return bvec2\n    (\n        isinf(v.x),\n        isinf(v.y)\n    );\n}\nbvec3 isinf2(vec3 v)\n{\n    return bvec3\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z)\n    );\n}\nbvec4 isinf2(vec4 v)\n{\n    return bvec4\n    (\n        isinf(v.x),\n        isinf(v.y),\n        isinf(v.z),\n        isinf(v.w)\n    );\n}\n\nbool  isnan2(float v) { return isnan(v); } \nbvec2 isnan2(vec2 v)\n{\n    return bvec2\n    (\n        isnan(v.x),\n        isnan(v.y)\n    );\n}\nbvec3 isnan2(vec3 v)\n{\n    return bvec3\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z)\n    );\n}\nbvec4 isnan2(vec4 v)\n{\n    return bvec4\n    (\n        isnan(v.x),\n        isnan(v.y),\n        isnan(v.z),\n        isnan(v.w)\n    );\n}\n\nbool bnot(bool b) { return !b; }\nbvec2 bnot(bvec2 b) \n{ \n    return bvec2(!b.x, !b.y); \n}\nbvec3 bnot(bvec3 b) \n{ \n    return bvec3(!b.x, !b.y, !b.z); \n}\nbvec4 bnot(bvec4 b) \n{ \n    return bvec4(!b.x, !b.y, !b.z, !b.w); \n}\n\nbool band(bool a, bool b) { return a && b; }\nbvec2 band(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x && b.x,\n        a.y && b.y\n    ); \n}\nbvec3 band(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z\n    ); \n}\nbvec4 band(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x && b.x,\n        a.y && b.y,\n        a.z && b.z,\n        a.w && b.w\n    ); \n}\n\nbool bor(bool a, bool b) { return a || b; }\nbvec2 bor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x || b.x,\n        a.y || b.y\n    ); \n}\nbvec3 bor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z\n    ); \n}\nbvec4 bor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x || b.x,\n        a.y || b.y,\n        a.z || b.z,\n        a.w || b.w\n    ); \n}\n\nbool bxor(bool a, bool b) { return a != b; }\nbvec2 bxor(bvec2 a, bvec2 b) \n{ \n    return bvec2\n    (\n        a.x != b.x,\n        a.y != b.y\n    ); \n}\nbvec3 bxor(bvec3 a, bvec3 b) \n{ \n    return bvec3\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z\n    ); \n}\nbvec4 bxor(bvec4 a, bvec4 b) \n{ \n    return bvec4\n    (\n        a.x != b.x,\n        a.y != b.y,\n        a.z != b.z,\n        a.w != b.w\n    ); \n}\n\n#define decl_isfinite(retType, type) \\\nretType isfinite(type v)             \\\n{                                    \\\n    return band                      \\\n    (                                \\\n        bnot(isinf2(v)),             \\\n        bnot(isnan2(v))              \\\n    );                               \\\n} \ndecl_isfinite(bool, float)\ndecl_isfinite(bvec2, vec2)\ndecl_isfinite(bvec3, vec3)\ndecl_isfinite(bvec4, vec4)\n\nfloat select(bool s, float a, float b)\n{\n    return s ? a : b;\n}\n\nvec2 select(bvec2 s, vec2 a, vec2 b)\n{\n    return vec2\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y\n    );  \n}\n\nvec3 select(bvec3 s, vec3 a, vec3 b)\n{\n    return vec3\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z\n    );  \n}\n\nvec4 select(bvec4 s, vec4 a, vec4 b)\n{\n    return vec4\n    (\n        s.x ? a.x : b.x,\n        s.y ? a.y : b.y,\n        s.z ? a.z : b.z,\n        s.w ? a.w : b.w\n    );  \n}\n\n// Vector math -------------------\n\nfloat dot2(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\nfloat dot2(vec3 a, vec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nfloat dot2(vec4 a, vec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\nint dot2(ivec2 a, ivec2 b) { return a.x * b.x + a.y * b.y; }\nint dot2(ivec3 a, ivec3 b) { return a.x * b.x + a.y * b.y + a.z * b.z; }\nint dot2(ivec4 a, ivec4 b) { return a.x * b.x + a.y * b.y + a.z * b.z + a.w * b.w; }\n\n#define decl_lengthSqr(retType, type) \\\nretType lengthSqr(type a)             \\\n{                                     \\\n    return dot2(a,a);                 \\\n}                                     \n\ndecl_lengthSqr(float, vec2)\ndecl_lengthSqr(float, vec3)\ndecl_lengthSqr(float, vec4)\ndecl_lengthSqr(int, ivec2)\ndecl_lengthSqr(int, ivec3)\ndecl_lengthSqr(int, ivec4)\n\n#define decl_distSqr(retType, type) \\\nretType distSqr(type a, type b)     \\\n{                                   \\\n    type diff = a-b;                \\\n    return lengthSqr(diff);         \\\n}                                   \n\ndecl_distSqr(float, vec2)\ndecl_distSqr(float, vec3)\ndecl_distSqr(float, vec4)\ndecl_distSqr(int, ivec2)\ndecl_distSqr(int, ivec3)\ndecl_distSqr(int, ivec4)\n\n// Borrowed from UnityEngine\n#define decl_safeNormalize(type)                 \\\ntype safeNormalize(type inVec)                   \\\n{                                                \\\n    float dp3 = max(0.001f, dot2(inVec, inVec)); \\\n    return inVec / sqrt(dp3);                    \\\n}\ndecl_safeNormalize(vec2)\ndecl_safeNormalize(vec3)\ndecl_safeNormalize(vec4)\n\n// Trig Math ----------------------\n\n#define decl_cosToTan(type)\\\ntype cosToTan(type cosine)\\\n{\\\n    return (sqrt(type(1.0)-cosine)*sqrt(cosine+type(1.0))) / cosine;\\\n}\ndecl_cosToTan(float)\ndecl_cosToTan(vec2)\ndecl_cosToTan(vec3)\ndecl_cosToTan(vec4)\n\n#define decl_tanToCos(type)\\\ntype tanToCos(type tangent)\\\n{\\\n    return type(1.0)/sqrt(tangent*tangent+type(1.0));\\\n}\ndecl_tanToCos(float)\ndecl_tanToCos(vec2)\ndecl_tanToCos(vec3)\ndecl_tanToCos(vec4)\n\n// Misc. math --------------------\n\n// I don't trust int(floor(x)).\n// So, for positive values:\n//\n// x = floor(x)\n//\n// Add 0.5 in case floor(x) rounded it to some floating point garbage like 23.99999\n// x += 0.5\n//\n// ix = int(x) // THEN cast to an int.\n//\n// Similar thing happens for negative values.\n#define decl_floorToInt(retType, type)              \\\nretType floorToInt(type a)                          \\\n{                                                   \\\n    return retType(floor(a) + sign(a) * type(0.5)); \\\n}                                                   \n\ndecl_floorToInt(int, float)\ndecl_floorToInt(ivec2, vec2)\ndecl_floorToInt(ivec3, vec3)\ndecl_floorToInt(ivec4, vec4)\n\n#define decl_invMix(type) \\\ntype invMix(type a, type b, type t) \\\n{                                   \\\n    type result = (t-a)/(b-a);      \\\n    return select(isfinite(result), result, type(0.5)); \\\n}\n\ndecl_invMix(float)\ndecl_invMix(vec2)\ndecl_invMix(vec3)\ndecl_invMix(vec4)\n\n#define invLerp invMix\n\n#define decl_square(type)\\\ntype square(type a)\\\n{\\\n    return a*a;\\\n}\n\ndecl_square(int)\ndecl_square(ivec2)\ndecl_square(ivec3)\ndecl_square(ivec4)\ndecl_square(float)\ndecl_square(vec2)\ndecl_square(vec3)\ndecl_square(vec4)\n\nhalf Pow5 (half x)\n{\n    return x*x * x*x * x;\n}\n\nhalf2 Pow5 (half2 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf3 Pow5 (half3 x)\n{\n    return x*x * x*x * x;\n}\n\nhalf4 Pow5 (half4 x)\n{\n    return x*x * x*x * x;\n}\n\n// RNG ----------------------------------------\n\nuint wang_hash(inout uint seed)\n{\n    seed = uint(seed ^ uint(61)) ^ uint(seed >> uint(16));\n    seed *= uint(9);\n    seed = seed ^ (seed >> 4);\n    seed *= uint(0x27d4eb2d);\n    seed = seed ^ (seed >> 15);\n    return seed;\n}\n\nfloat RandomFloat01(inout uint state)\n{\n    return float(wang_hash(state)) / 4294967296.0;\n}\n\nvec2 uniform01ToGauss(vec2 value)\n{\n    float magnitude = sqrt(-2.0 * log(value.x));\n    \n    value.y *= 6.28318530718;\n    vec2 direction = vec2(cos(value.y),sin(value.y));\n    return magnitude * direction;\n}\n\nvec4 sampleRandom(sampler2D tex, vec2 fragCoord, inout uint rngState)\n{\n    fragCoord /= vec2(textureSize(tex, 0));\n    fragCoord += vec2\n    (\n        RandomFloat01(rngState),\n        RandomFloat01(rngState)\n    );\n    \n    return textureLod(tex, fragCoord, 0.0);\n}\n\nvec4 sampleBlueNoise(sampler2D blueNoiseTex, vec2 fragCoord, inout uint rngState)\n{\n    vec4 value = sampleRandom(blueNoiseTex, fragCoord, rngState);\n    \n    // The blue noise texture is limited to integer steps between\n    // 0 and 255 (inclusive).\n    // We need to add randomization to fill in the missing\n    // intermediate values.\n    value = mix(vec4(0.5 / 255.0), vec4(254.5 / 255.0), value);\n    value += \n    (\n        vec4\n        (\n            RandomFloat01(rngState), RandomFloat01(rngState),\n            RandomFloat01(rngState), RandomFloat01(rngState)\n        ) - 0.5\n    ) * (1.0 / 255.0);\n    \n    return value;\n}\n\n// Color -------------------------------\n\n#define decl_linearToGamma(type) \\\ntype linearToGamma(type v)       \\\n{                               \\\n    return pow(v, type(1.0 / 2.2));   \\\n}\n\ndecl_linearToGamma(float)\ndecl_linearToGamma(vec2)\ndecl_linearToGamma(vec3)\ndecl_linearToGamma(vec4)\n\n#define decl_gammaToLinear(type)    \\\ntype gammaToLinear(type v)          \\\n{                                   \\\n    return pow(v, type(2.2)); \\\n}\n\ndecl_gammaToLinear(float)\ndecl_gammaToLinear(vec2)\ndecl_gammaToLinear(vec3)\ndecl_gammaToLinear(vec4)\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 hsv2rgb(vec3 hsv) \n{\n    vec3 h3 = mod(6.0 * hsv.x + vec3(5.0, 3.0, 1.0), 6.0);\n    h3 = min(h3, 4.0 - h3);\n    h3 = clamp(h3, 0.0, 1.0);\n    return hsv.z - hsv.z * hsv.y * h3;\n}\n\n// Credit: https://www.shadertoy.com/view/DsBGzy by sh1boot\nvec3 palette(int i) \n{\n    float f = float(i);\n    float h =  mod(1.618033988749894848204586834 * f, 1.0);\n    float s = exp(-0.00025 * f) * 0.65 + 0.25;\n    float v = 1.0;\n    return hsv2rgb(vec3(h, s, v));\n}\n\nvec4 cube(samplerCube cube, vec2 uv)\n{\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return texture(cube, ray);\n}\n\nvec4 cubeFetch(samplerCube cube, ivec2 coord, int mip)\n{\n    vec2 uv = (vec2(coord) + vec2(0.5)) / vec2(textureSize(cube, mip));\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, float(mip));\n}\n\nvec4 cubeLod(samplerCube cube, vec2 uv, float mip)\n{\n    //uv = clamp(uv, vec2(0), vec2(1));\n    uv -= floor(uv);\n    uv = uv * 2.0 - 1.0;\n    \n    vec3 ray = vec3(uv, 1);\n    \n    return textureLod(cube, ray, mip);\n}\n\nstruct quaternion\n{\n    vec4 value;\n};\n\nstruct bounds\n{\n    vec3 mini, maxi;\n};\n\nbool rayIntersectBounds\n(\n    bounds b, \n    vec3 rayOrig, \n    vec3 rayDir,\n    out vec3 nearHit,\n    out vec3 farHit\n)\n{\n    b.mini -= rayOrig;\n    b.maxi -= rayOrig;\n    \n    vec3 signs = sign(rayDir);\n    \n   \n    b.mini *= signs;\n    b.maxi *= signs;\n    rayDir *= signs;\n    \n    vec3 maxBounds = max((b.mini), (b.maxi));\n    \n    rayDir *= max(max(maxBounds.x, maxBounds.y),maxBounds.z) * 2.0; \n    \n    \n    \n    {\n        farHit = rayDir;\n        vec3 clamped = min(farHit, maxBounds);\n    \n        vec3 scale = max(vec3(0.0), clamped / farHit);\n        float minScale = min(min(scale.x, scale.y),scale.z); \n        farHit = (farHit * minScale) * signs + rayOrig;\n    }\n    \n    /*{\n        nearHit = -rayDir;\n        vec3 clamped = clamp(nearHit, b.mini, b.maxi);\n    \n        vec3 scale = abs(clamped / nearHit);\n        float minScale = max(max(scale.x, scale.y),scale.z); \n        nearHit = nearHit * minScale + rayOrig;\n    }*/\n    \n    nearHit = rayOrig;\n\n    return true;\n}\n\nquaternion mul(quaternion a, quaternion b)\n{\n    quaternion q;\n    q.value = vec4\n    (\n        a.value.wwww * b.value \n      + (a.value.xyzx * b.value.wwwx + a.value.yzxy * b.value.zxyy) * vec4(1.0, 1.0, 1.0, -1.0) \n      - a.value.zxyz * b.value.yzxz\n    );\n    return q;\n}\n\nvec3 mul(quaternion q, vec3 v)\n{\n    vec3 t = 2.0 * cross(q.value.xyz, v);\n    return v + vec3(q.value.w * t) + cross(q.value.xyz, t);\n}\n\nquaternion FromAngleAxis(vec3 angleAxis)\n{\n    float mag = length(angleAxis);\n    float halfAngle = mag * 0.5;\n    float scalar = sin(halfAngle) / max(mag, 0.00001);\n        \n    quaternion q;\n    q.value = vec4(angleAxis * scalar, cos(halfAngle));\n    return q;\n}\n\nquaternion FromToRotation(vec3 from, vec3 to)\n{\n    vec3 xyz = cross(from, to);\n    float w = sqrt(dot(from, from) * dot(to, to)) + dot(from, to);\n    vec4 value = vec4(xyz, w);\n    quaternion q;\n    q.value = normalize(value);\n    return q;\n}\n\nquaternion LookRotation(float3 forward, float3 up)\n{\n    quaternion q;\n    forward = safeNormalize(forward);\n    q = FromToRotation(vec3(0,0,1), forward);\n    up = up - dot(forward, up) * forward;\n    vec3 upFrom = mul(q, vec3(0,1,0));\n    q = mul(FromToRotation(upFrom, up), q);\n    return q;\n}\n\nvoid sincos(vec3 x, out vec3 s, out vec3 c)\n{\n    s = sin(x);\n    c = cos(x);\n}\n        \nquaternion EulerZXY(float3 xyz)\n{\n    vec3 s, c;\n    sincos(vec3(0.5) * xyz, s, c);\n\n    return quaternion\n    (\n        vec4(s.xyz, c.x) * c.yxxy * c.zzyz \n      + s.yxxy * s.zzyz * vec4(c.xyz, s.x) * vec4(1, -1, -1, 1)\n    );\n}\n\nmat4x4 RotationMatrix(quaternion q)\n{\n    float q0 = q.value.x;\n    float q1 = q.value.y;\n    float q2 = q.value.z;\n    float q3 = q.value.w;\n        \n    /*# First row of the rotation matrix\n    r00 = 2 * (q0 * q0 + q1 * q1) - 1\n    r01 = 2 * (q1 * q2 - q0 * q3)\n    r02 = 2 * (q1 * q3 + q0 * q2)\n     \n    # Second row of the rotation matrix\n    r10 = 2 * (q1 * q2 + q0 * q3)\n    r11 = 2 * (q0 * q0 + q2 * q2) - 1\n    r12 = 2 * (q2 * q3 - q0 * q1)\n     \n    # Third row of the rotation matrix\n    r20 = 2 * (q1 * q3 - q0 * q2)\n    r21 = 2 * (q2 * q3 + q0 * q1)\n    r22 = 2 * (q0 * q0 + q3 * q3) - 1*/\n        \n    float r00 = 2. * (q0 * q0 + q1 * q1) - 1.;\n    float r01 = 2. * (q1 * q2 - q0 * q3);\n    float r02 = 2. * (q1 * q3 + q0 * q2);\n                                        \n    float r10 = 2. * (q1 * q2 + q0 * q3);\n    float r11 = 2. * (q0 * q0 + q2 * q2) - 1.;\n    float r12 = 2. * (q2 * q3 - q0 * q1);\n                                         \n    float r20 = 2. * (q1 * q3 - q0 * q2);\n    float r21 = 2. * (q2 * q3 + q0 * q1);\n    float r22 = 2. * (q0 * q0 + q3 * q3) - 1.;\n                             \n    return mat4x4\n    (\n        mul(q, vec3(1,0,0)), 0,\n        mul(q, vec3(0,1,0)), 0,\n        mul(q, vec3(0,0,1)), 0,\n        0,   0,   0,   1\n    );\n}\n\nmat4x4 TRS(vec3 translation, quaternion rotation, vec3 scale)\n{\n    mat4x4 float3x = RotationMatrix(rotation);\n    return mat4x4\n    (\n        vec4(float3x[0] * scale.x), \n        vec4(float3x[1] * scale.y), \n        vec4(float3x[2] * scale.z), \n        vec4(translation, 1)\n    );\n}\n\n// Drawing helpers --------------------------------\n\nvoid blend(in vec4 src, inout vec4 dest)\n{\n    dest.rgb = mix(dest.rgb, src.rgb, src.a);\n    dest.a = mix(dest.a, 1.0, src.a);    \n}\n\nvoid drawCircle(vec2 center, vec2 frag, float radius, float lineWidth, vec4 lineColor, inout vec4 color)\n{\n    float distanceToEdge = abs(radius - distance(frag, center));\n\n    float circle = smoothstep\n    (\n        0.0, \n        1.0,\n        1.0 - (distanceToEdge / lineWidth) \n    );\n                \n    lineColor.a *= circle;\n    blend(lineColor, color);\n}\n\nvoid drawSDF(vec3 diff_dist, inout vec4 color)\n{\n    float d = diff_dist.z;\n    vec2 grad = diff_dist.xy/(d);\n    \n    vec3 c = normalize(vec3(grad,sign(d))) * 0.5 + 0.5;\n\tc *= 1. - exp2(-12. * abs(d));\n\tc *= .8 + .2 * cos(120.*d);\n\n    color.rgb = c;\n}\n\nvec3 unsignedValueToColor(float value)\n{\n    float valueLog = log2(value + 0.0625);\n    valueLog /= 16.0;\n    //value /= 1. + abs(valueLog);\n    valueLog = valueLog * 0.5 + 0.5;\n    \n    value *= 10.0;\n    value += 0.125;\n    value /= 1. + abs(value);\n    \n    return hsv2rgb(vec3(valueLog, 1, value));\n}\n\n// Font helpers ------------------------------\n#define FONTSAMPLERSIZE vec2(1024, 1024)\n#define FONTSAMPLERSIZEI ivec2(1024, 1024)\n#define FONTELEMENTCOUNT  vec2(16, 16)\n#define FONTELEMENTCOUNTI  ivec2(16, 16)\n#define FONTELEMENTSIZE  vec2(64, 64)\n#define FONTELEMENTSIZEI  ivec2(64, 64)\nvec4 sampleFontElement(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element)\n{\n    vec2 samplerCoordMin = vec2(element * FONTELEMENTSIZEI); \n    vec2 samplerCoordMax = vec2(element * FONTELEMENTSIZEI + FONTELEMENTSIZEI); \n    \n    vec2 elementUV = (fragCoord - samplerCoordMin) / FONTELEMENTSIZE;\n    elementUV -= floor(elementUV);\n    \n    vec2 samplerCoord = mix(samplerCoordMin, samplerCoordMax, elementUV);\n    vec2 samplerUV = samplerCoord / FONTSAMPLERSIZE;\n    \n    return texture(fontSampler, samplerUV);\n}\n\nvec4 sampleFontElementColor(sampler2D fontSampler, in vec2 fragCoord, in ivec2 element, in vec4 color)\n{\n    float opacity = sampleFontElement(fontSampler, fragCoord, element).r;\n    \n    color.a *= opacity;\n    \n    return color;\n}\n\nvec3 getNoise(int iFrame)\n{\n    vec3 noise = vec3(0);\n\n    // Calculate oising over time.\n    vec3 temporalNoise;\n    {\n        // Use the golden ratio as it should land\n        // on all fractional values eventually.\n        temporalNoise = vec3(iFrame, iFrame+1, iFrame+2);\n        temporalNoise *= vec3(0.7548776662, 0.56984029, 0.618033988749);\n\n        // We floor this one early to prevent\n        // loss of precision when iFrame becomes large.\n        temporalNoise -= floor(noise);\n    }\n    noise += temporalNoise;\n\n    #ifdef SPATIAL_NOISE\n    // Add noising over space.\n    // (Currently disabled; messes up the\n    // gradient and especially the curvature\n    // of the resulting map.)\n    vec3 spatialNoise;\n    {\n        // Noise is added to vary the threshold\n        // per pixel to speed up apparent convergence,\n        // but the converged result shouldn't change.\n\n        vec2 noiseUV = fragCoord.xy / iChannelResolution[1].xy;\n        spatialNoise = texture(iChannel1, noiseUV).r;\n    }\n    noise += spatialNoise;\n    #endif\n\n    // Wrap values around from 0 to 1.\n    noise -= floor(noise);\n\n    // Center the sampling position offset\n    // to a range within -0.5 to +0.5.\n    noise.xy -= 0.5f;\n    \n    return noise;\n}\n\n// PBR Lighting ------------------------------\n// Borrowed from UnityEngine\nstruct MaterialMetallic\n{\n    fixed3 albedo;      // base (diffuse or specular) color\n    half metallic;      // 0=non-metal, 1=metal\n    half smoothness;    // 0=rough, 1=smooth\n};\n\nstruct Material\n{\n    vec3 albedo;\n    vec3 specColor;\n    float oneMinusReflectivity;\n    float smoothness;\n};\n\nstruct Light\n{\n    half3 color;\n    half3 dir;\n};\n\nstruct Indirect\n{\n    half3 diffuse;\n    half3 specular;\n};\n\nconst float4 dielectricSpec = float4(0.04, 0.04, 0.04, 1.0 - 0.04);\n\nhalf OneMinusReflectivityFromMetallic(half metallic)\n{\n    half oneMinusDielectricSpec = dielectricSpec.a;\n    return oneMinusDielectricSpec - metallic * oneMinusDielectricSpec;\n}\n\nhalf3 DiffuseAndSpecularFromMetallic (half3 albedo, half metallic, out half3 specColor, out half oneMinusReflectivity)\n{\n    specColor = lerp (dielectricSpec.rgb, albedo, metallic);\n    oneMinusReflectivity = OneMinusReflectivityFromMetallic(metallic);\n    return albedo * oneMinusReflectivity;\n}\n\nMaterial toMaterial(MaterialMetallic i)\n{\n    Material o;\n    \n    o.albedo = i.albedo;\n    o.smoothness = i.smoothness;\n    \n    half oneMinusReflectivity;\n    half3 specColor;\n    o.albedo = DiffuseAndSpecularFromMetallic (o.albedo, i.metallic, o.specColor, o.oneMinusReflectivity);\n    \n    return o;\n}\n\nfloat SmoothnessToPerceptualRoughness(float smoothness)\n{\n    return (1.0 - smoothness);\n}\n\n// Note: Disney diffuse must be multiply by diffuseAlbedo / PI. This is done outside of this function.\nhalf DisneyDiffuse(half NdotV, half NdotL, half LdotH, half perceptualRoughness)\n{\n    half fd90 = 0.5 + 2.0 * LdotH * LdotH * perceptualRoughness;\n    // Two schlick fresnel term\n    half lightScatter   = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotL));\n    half viewScatter    = (1.0 + (fd90 - 1.0) * Pow5(1.0 - NdotV));\n\n    return lightScatter * viewScatter;\n}\n\nfloat PerceptualRoughnessToRoughness(float perceptualRoughness)\n{\n    return perceptualRoughness * perceptualRoughness;\n}\n\nfloat SmithJointGGXVisibilityTerm (float NdotL, float NdotV, float roughness)\n{\n    // Original formulation:\n    //  lambda_v    = (-1 + sqrt(a2 * (1 - NdotL2) / NdotL2 + 1)) * 0.5f;\n    //  lambda_l    = (-1 + sqrt(a2 * (1 - NdotV2) / NdotV2 + 1)) * 0.5f;\n    //  G           = 1 / (1 + lambda_v + lambda_l);\n\n    // Reorder code to be more optimal\n    half a          = roughness;\n    half a2         = a * a;\n\n    half lambdaV    = NdotL * sqrt((-NdotV * a2 + NdotV) * NdotV + a2);\n    half lambdaL    = NdotV * sqrt((-NdotL * a2 + NdotL) * NdotL + a2);\n\n    // Simplify visibility term: (2.0f * NdotL * NdotV) /  ((4.0f * NdotL * NdotV) * (lambda_v + lambda_l + 1e-5f));\n    return 0.5f / (lambdaV + lambdaL + 1e-5f);  // This function is not intended to be running on Mobile,\n                                                // therefore epsilon is smaller than can be represented by half\n}\n\nfloat GGXTerm (float NdotH, float roughness)\n{\n    float a2 = roughness * roughness;\n    float d = (NdotH * a2 - NdotH) * NdotH + 1.0f; // 2 mad\n    return InvPi * a2 / (d * d + 1e-7f); // This function is not intended to be running on Mobile,\n                                            // therefore epsilon is smaller than what can be represented by half\n}\n\nhalf3 FresnelTerm (half3 F0, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return F0 + (1.0-F0) * t;\n}\n\nhalf3 FresnelLerp (half3 F0, half3 F90, half cosA)\n{\n    half t = Pow5 (1.0 - cosA);   // ala Schlick interpoliation\n    return lerp (F0, F90, t);\n}\n\n\nhalf3 brdf (half3 albedo, half3 specColor, half oneMinusReflectivity, half smoothness,\n    float3 normal, float3 viewDir,\n    Light light, Indirect gi)\n{\n    float perceptualRoughness = SmoothnessToPerceptualRoughness (smoothness);\n    float3 halfDir = safeNormalize(float3(light.dir) + viewDir);\n\n    // The amount we shift the normal toward the view vector is defined by the dot product.\n    half shiftAmount = dot(normal, viewDir);\n    normal = shiftAmount < 0.0f ? normal + viewDir * (-shiftAmount + 1e-5f) : normal;\n    normal = normalize(normal);\n\n    float nv = saturate(dot(normal, viewDir)); // TODO: this saturate should no be necessary here\n\n    float nl = saturate(dot(normal, light.dir));\n    float nh = saturate(dot(normal, halfDir));\n\n    half lv = saturate(dot(light.dir, viewDir));\n    half lh = saturate(dot(light.dir, halfDir));\n\n    // Diffuse term\n    half diffuseTerm = DisneyDiffuse(nv, nl, lh, perceptualRoughness) * nl / 3.1415927;\n\n    // Specular term\n    float roughness = PerceptualRoughnessToRoughness(perceptualRoughness);\n    \n    // GGX with roughtness to 0 would mean no specular at all, using max(roughness, 0.002) here to match HDrenderloop roughtness remapping.\n    roughness = max(roughness, 0.002);\n    float V = SmithJointGGXVisibilityTerm (nl, nv, roughness);\n    float D = GGXTerm (nh, roughness);\n\n    float specularTerm = V*D; // Torrance-Sparrow model, Fresnel is applied later\n\n    // specularTerm * nl can be NaN on Metal in some cases, use max() to make sure it's a sane value\n    specularTerm = max(0.0, specularTerm * nl);\n\n    // surfaceReduction = Int D(NdotH) * NdotH * Id(NdotL>0) dH = 1/(roughness^2+1)\n    half surfaceReduction;\n    surfaceReduction = 1.0 / (roughness*roughness + 1.0);           // fade \\in [0.5;1]\n\n    // To provide true Lambert lighting, we need to be able to kill specular completely.\n    //specularTerm *= (specColor != vec3(0)) ? 1.0 : 0.0;\n\n    half grazingTerm = saturate(smoothness + (1.0-oneMinusReflectivity));\n    half3 color =   albedo * (gi.diffuse + light.color * diffuseTerm)\n                    + specularTerm * light.color * FresnelTerm (specColor, lh)\n                    + surfaceReduction * gi.specular * FresnelLerp (specColor, vec3(grazingTerm), nv)\n                    ;\n\n    return half3(color);\n}\n\nvec3 lighting(MaterialMetallic mat, vec3 normal, vec3 viewDir, Light light, Indirect indirect)\n{\n    Material m = toMaterial(mat);\n    \n    return brdf(m.albedo, m.specColor, m.oneMinusReflectivity, m.smoothness,\n    normal, viewDir, light, indirect);\n}\n\n// RAYTRACING -----------------------------\n// Taken from https://www.shadertoy.com/view/MtcXWr\n// Credit: Zavie\n\nstruct Ray\n{\n    vec3 origin;\t\n    vec3 direction;\t\t\n};\n\nstruct Hit\n{\n    float distance;\n    vec3 normal;\t\n};\nconst Hit noHit = Hit(1e10, vec3(0.));\n\nstruct Plane\n{\n    float offset;\n    vec3 normal;\n};\n\nstruct Sphere\n{\n\tfloat radius;\n    vec3 center;\n};\n\nstruct Cone\n{\n    float cosa;\t// cosine of half cone angle\n    float height;\n    float thickness;\n    vec3 origin;\n    vec3 axis;\n};\n\nstruct Capsule\n{\n    vec3 start;\n    vec3 end;\n    float startRadius;\n    float endRadius;\n};\n\nstruct HeightPlane\n{\n    mat4x4 localToWorld;\n    vec2 uvOffset;\n};\n\nvec3 getPoint(in Ray r, float dist)\n{\n    return r.origin + r.direction * dist;\n}\n\nvec3 getPoint(in Ray r, in Hit hit)\n{\n    return r.origin + r.direction * hit.distance;\n}\n\nbool swapIfCloser(inout Hit current, Hit candidate)\n{\n    if (candidate.distance < current.distance && candidate.distance >= 0.0)\n    {\n        current = candidate;\n        return true;\n    }\n    return false;\n}\n\nHit intersectPlane(Plane plane, Ray ray)\n{\n    float dotnd = -dot(plane.normal, ray.direction);\n    float heightAbovePlane = dot(ray.origin, plane.normal) - plane.offset;\n\n    float t = heightAbovePlane / dotnd;\n    //if(!(t >= 0.0))\n    //    return noHit;\n        \n    return Hit(t, plane.normal * sign(dotnd));\n}\n\nHit intersectSphere(Sphere sphere, Ray ray)\n{\n\tvec3 op = sphere.center - ray.origin;\n    float b = dot(op, ray.direction);\n    float det = b * b - dot(op, op) + sphere.radius * sphere.radius;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n\n    return Hit(t, (ray.origin + t*ray.direction - sphere.center) / sphere.radius);\n}\n\nHit intersectCapsule(Capsule capsule, Ray ray)\n{\n    vec3 rayDirection = ray.direction;\n    vec3 relativeOrigin = ray.origin - capsule.start;\n    vec3 coneDirection = normalize(capsule.end - capsule.start);\n    float coneLength = distance(capsule.end, capsule.start);\n    float changeInRadiusWithLength = (capsule.endRadius - capsule.startRadius) / coneLength;\n    float whatever = 1.0 - square(changeInRadiusWithLength);\n    \n    if(whatever <= 0.0)\n    {\n    \tif(capsule.endRadius < capsule.startRadius)\n    \t{\n    \t\tSphere s = Sphere(capsule.startRadius, capsule.start);\n    \t\treturn intersectSphere(s, ray);    \n        }\n   \t\telse\n        {\n            Sphere s = Sphere(capsule.endRadius, capsule.end);\n            return intersectSphere(s, ray);   \n        } \n    }\n    \n    float sideB = sqrt(whatever);\n    float changeInThicknessWithLength = changeInRadiusWithLength / sideB;\n    \n    float radiusToThickness = changeInThicknessWithLength/changeInRadiusWithLength;\n    float startThickness = capsule.startRadius * radiusToThickness;\n    float endThickness = capsule.endRadius * radiusToThickness;\n    \n    if((coneLength+capsule.endRadius) < capsule.startRadius)\n    {\n    \tSphere s = Sphere(capsule.startRadius, capsule.start);\n    \treturn intersectSphere(s, ray);    \n    }\n    if((coneLength+capsule.startRadius) < capsule.endRadius)\n    {\n    \tSphere s = Sphere(capsule.endRadius, capsule.end);\n    \treturn intersectSphere(s, ray);    \n    }\n    \n    float c = lengthSqr(relativeOrigin)\n            - square(dot(relativeOrigin, coneDirection))\n            - square(dot(relativeOrigin, coneDirection*changeInThicknessWithLength))\n            - square(startThickness) \n            - 2.0*changeInThicknessWithLength*startThickness*dot(relativeOrigin, coneDirection);\n\n    float b = 2.0*dot(relativeOrigin, rayDirection)\n            - 2.0*dot(relativeOrigin, coneDirection)*dot(rayDirection, coneDirection)\n            - 2.0*dot(relativeOrigin, coneDirection*changeInThicknessWithLength)*dot(rayDirection, coneDirection*changeInThicknessWithLength)\n            - 2.0*changeInThicknessWithLength*startThickness*dot(rayDirection, coneDirection);\n\n    float a = 1.0\n            - square(dot(rayDirection, coneDirection))\n            - square(dot(rayDirection, coneDirection*changeInThicknessWithLength));\n        \n    float det = b*b - 4.*a*c;\n    if (det < 0.) return noHit;\n\n    det = sqrt(det);\n    float t1 = (-b - det) / (2. * a);\n    float t2 = (-b + det) / (2. * a);\n\n    float t = t1;\n    if (t < 0. || t2 > 0. && t2 < t) t = t2;\n    if (t < 0.) return noHit;\n    \n    vec3 relativeRayHit = ray.origin + t*ray.direction - capsule.start;\n    float actualDistanceOfPointAlongAxis = dot(relativeRayHit, coneDirection);\n    float distanceOfPointAlongAxis = actualDistanceOfPointAlongAxis;//square(fract(iTime * 0.25 / coneLength)) * coneLength;//dot(relativeRayHit, coneDirection);\n    \n    \n    float thicknessAtPoint = distanceOfPointAlongAxis * changeInThicknessWithLength + startThickness;\n    \n    Hit hit1;\n    \n    if(actualDistanceOfPointAlongAxis < distanceOfPointAlongAxis)\n    {\n    \thit1 = Hit(t*0.25, vec3(1));    \n    }\n    else\n    {\n    \thit1 = Hit(t, vec3(-1));  \n    }\n    \n    float distanceOfSphereAlongAxis = distanceOfPointAlongAxis + (thicknessAtPoint * changeInRadiusWithLength / sideB);\n    \n    distanceOfSphereAlongAxis = clamp(distanceOfSphereAlongAxis, 0.0, coneLength);\n\n    float sphereRadius = distanceOfSphereAlongAxis * changeInRadiusWithLength + capsule.startRadius;\n\n    Sphere s = Sphere(sphereRadius, capsule.start + coneDirection * distanceOfSphereAlongAxis);\n    \n    Hit hit2 = intersectSphere(s, ray);\n    hit2.distance *= 0.5;\n    swapIfCloser(hit1, hit2);\n    \n    return hit2;\n}\n\nHit intersectHeightPlane(HeightPlane plane, Ray ray, sampler2D heightMap, vec2 heightMapSize)\n{\n    Ray origRay = ray;\n    mat4x4 worldToLocal = inverse(plane.localToWorld);\n\n    ray.origin = (worldToLocal * vec4(ray.origin, 1)).xyz; \n    ray.direction = normalize((worldToLocal * vec4(ray.direction, 0)).xyz); \n\n    Plane maxPlane = Plane(-1.0, vec3(0,0,1));\n    Plane minPlane = Plane( 0.0, vec3(0,0,1));\n    \n    Hit maxHit = intersectPlane(maxPlane, ray);\n    Hit minHit = intersectPlane(minPlane, ray);\n    \n    \n    //if(maxHit == noHit || minHit == noHit)\n    //    return noHit;\n    \n    float nearDist = min(minHit.distance, maxHit.distance);\n    float farDist  = max(minHit.distance, maxHit.distance);\n    \n    if(farDist < 0.0)\n        return noHit;\n        \n    if(nearDist < 0.0)\n        nearDist = 0.0;\n        \n    //return maxHit;\n    \n    //vec3 nearHit = ray.origin + ray.direction * nearDist;\n    //vec3 farHit = ray.origin + ray.direction * farDist;\n    \n    vec3 hitPos;\n    \n    \n    bool hit = false;\n    float increment = max(0.00001, 0.0001 / abs(nearDist-farDist));\n    for(float i = 0.0; i <= 1.0; i += increment)\n    {\n        float marchDist = mix(nearDist, farDist, i);\n        hitPos = ray.origin + ray.direction * marchDist;\n        \n        vec2 uv = hitPos.xy;\n        float depth = textureLod(heightMap, uv + plane.uvOffset, 0.0).r*1.0 - 1.0;\n        \n        if(hitPos.z <= depth)\n        {\n            hitPos.z = depth;\n            farDist = marchDist;\n            hit = true;\n            break;\n        }\n        else\n        {\n            nearDist = marchDist;\n        }\n    }\n    \n    if(!hit) return noHit;\n    \n    farDist = (nearDist + farDist) * 0.5;\n    float stepSize = (farDist - nearDist) * 0.5;\n    for(int i = 0; i < 12; i++, stepSize *= 0.5)\n    {\n        hitPos = ray.origin + ray.direction * farDist;\n        \n        vec2 uv = hitPos.xy;\n        float depth = textureLod(heightMap, uv + plane.uvOffset, 0.0).r - 1.0;\n        \n        if(hitPos.z > depth)\n        {\n            nearDist = farDist;\n            farDist += stepSize;\n        }\n        else\n        {\n            hitPos.z = depth;\n            farDist -= stepSize;\n        }\n    }\n    \n    ray = origRay;\n    \n    const float sampleSpacing = 0.5;\n    vec4 uvOffset = vec4(-sampleSpacing, -sampleSpacing, sampleSpacing, sampleSpacing) / heightMapSize.xyxy;\n    \n    vec3 p00, p10, p01, p11;\n    p00 = vec3(hitPos.xy + uvOffset.xy, 0);\n    p10 = vec3(hitPos.xy + uvOffset.zy, 0);\n    p01 = vec3(hitPos.xy + uvOffset.xw, 0);\n    p11 = vec3(hitPos.xy + uvOffset.zw, 0);\n    \n    p00.z = textureLod(heightMap, p00.xy + plane.uvOffset, 0.0).r - 1.0;\n    p10.z = textureLod(heightMap, p10.xy + plane.uvOffset, 0.0).r - 1.0;\n    p01.z = textureLod(heightMap, p01.xy + plane.uvOffset, 0.0).r - 1.0;\n    p11.z = textureLod(heightMap, p11.xy + plane.uvOffset, 0.0).r - 1.0;\n    \n    p00 = (plane.localToWorld * vec4(p00, 1)).xyz;\n    p10 = (plane.localToWorld * vec4(p10, 1)).xyz;\n    p01 = (plane.localToWorld * vec4(p01, 1)).xyz;\n    p11 = (plane.localToWorld * vec4(p11, 1)).xyz;\n    \n    Hit outHit;\n    outHit.normal = cross(p11 - p00, p01 - p10);\n    \n    hitPos = (plane.localToWorld * vec4(hitPos, 1)).xyz; \n    outHit.normal = normalize(outHit.normal);\n    outHit.distance = dot(hitPos - ray.origin, ray.direction);\n    \n    return outHit;\n}\n\nvec2[4] getMSAACoords()\n{\n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n    return msaa;\n}\n\nRay uvToRay(vec2 uv, float aspect, float zoom, vec2 offset)\n{\n    uv = uv * vec2(2.0) - 1.0;\n    uv.x *= aspect;\n    uv += offset;\n    return Ray(vec3(0), normalize(vec3(uv,zoom)));\n}\n\n#define render(color, scene, camtf, frag, res, zoom, msaa, count, data)\\\n{\\\n    color = vec3(0.);\\\n    vec2 r = res;\\\n    vec2 f = frag;\\\n    vec2 uv = f / r;\\\n    const int c = count;\\\n    vec2[c] m = msaa;\\\n    float weight = 1.0 / float(c);\\\n    for (int i = 0; i < c; ++i)\\\n    {\\\n        Ray r = uvToRay\\\n        (\\\n            uv,\\\n            r.x/r.y,\\\n            zoom,\\\n            m[i] / r.y\\\n        );\\\n        r = camtf(r,f,data);\\\n        color += scene(r,f,data);\\\n    }\\\n    color *= weight;\\\n}\n", "buffer_b_code": "// Gradient magnitude and direction\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 uvAndOffset = vec4(fragCoord,0.5,0.5) / iChannelResolution[0].xyxy;\n    \n    vec3 hp = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2( 1, 0)).rgb;\n    vec3 hn = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2(-1, 0)).rgb;\n    vec3 vp = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2( 0, 1)).rgb;\n    vec3 vn = texture(iChannel0, uvAndOffset.xy + uvAndOffset.zw * vec2( 0,-1)).rgb;\n     \n    vec3 h = hp-hn;\n    vec3 v = vp-vn;\n    \n    float magnitude = sqrt(dot(h,h) + dot(v,v));\n    vec2 vec = vec2( dot(h,vec3(1)), dot(v,vec3(1)) );\n    float len = max(0.000001,length(vec));\n    vec /= len;\n     \n    fragColor = vec4(vec, magnitude, 1);\n}", "buffer_b_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "#define TECHNIQUE 1\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n#if TECHNIQUE == 0\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    vec2 dir = texture(iChannel0, uv).xy / iResolution.xy;\n    \n    float center = texture(iChannel0, uv).z;\n    float pos = texture(iChannel0, uv + dir).z;\n    float neg = texture(iChannel0, uv - dir).z;\n    \n    fragColor = vec4(vec3(max(0., center * 2. - pos - neg)), 1);\n#elif TECHNIQUE == 1    \n    vec2 uv = fragCoord / iResolution.xy;\n    vec2 uvWithOffset = uv;\n    \n    uint rngState = uint\n    (\n        uint(iFrame) * uint(1973) \n    ) | uint(1);\n    \n    // Using time-varying blue noise as subpixel offsets \n    // will kill persistent moire patterns.\n    // If you modify the shader to accumulate,\n    // it'll converge on a nice image with no aliasing.\n    // (It uses gaussian windowing, not an ideal lowpass filter however.)\n    vec4 blueNoise = sampleBlueNoise(iChannel2, fragCoord, rngState);\n    uvWithOffset += (blueNoise.xy - 0.5)*1.0 / iResolution.xy; \n    \n    vec2 dir = normalize(texture(iChannel0, uvWithOffset).xy) / iResolution.xy;\n    \n    float center = texture(iChannel0, uvWithOffset).z;\n    float pos = texture(iChannel0, uvWithOffset + dir).z;\n    float neg = texture(iChannel0, uvWithOffset - dir).z;\n    \n    fragColor = texture(iChannel3, uv) + vec4(vec3(center > pos && center > neg ? 1. : 0.), 1);\n#endif\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 14854, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture", "channel": 2, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_d_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = fragCoord / iResolution.xy;\n\n    vec4 data = texture(iChannel0, uv);\n    vec2 uvOffs = data.xy / iResolution.xy;\n    \n    uvOffs = uvOffs.yx;\n    uvOffs.y = -uvOffs.y;\n    \n    \n    vec4 posData = texture(iChannel0, uv + uvOffs);// * posMask.x;\n    vec4 negData = texture(iChannel0, uv - uvOffs);// * negMask.x;\n\n    float state = texture(iChannel3, uv).z;\n\n    float posDot = max(0., dot(posData.xy, data.xy));\n    float negDot = max(0., dot(negData.xy, data.xy));\n\n  \n    float pos = texture(iChannel3, uv + uvOffs).z * posDot;// * posMask.x;\n    float neg = texture(iChannel3, uv - uvOffs).z * negDot;// * negMask.x;\n    \n    if(data.z > 0.55)\n        state = 1.;\n    else if(data.z < 0.15)\n        state = 0.;\n    else\n    {\n        if(pos > 0.)\n            state =1.;\n        if(neg > 0.)\n            state = 1.;\n    }\n        \n    fragColor = vec4(state,state,state,state);\n}", "buffer_d_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 260, "src": "/media/previz/buffer03.png", "ctype": "buffer", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lcc3Df.jpg", "time_retrieved": "2024-04-28T18:59:50.032226", "access": "api", "wgpu-test": "error"}
{"id": "lc33Wf", "name": "Greetings, Logicoma", "author": "Zavie", "description": "This shader draws the logo of the demogroup \"Logicoma\".\n\nMore logos: https://www.shadertoy.com/playlist/NX3yzf", "tags": ["demoscene", "logo"], "image_code": "/*\n\nThis shader draws the logo of the demoscene group \"Logicoma\".\n\nLogicoma:\n > https://logicoma.io/\n > https://www.youtube.com/watch?v=QhqT0DhV9yE\n\n-- \nZavie / Ctrl-Alt-Test\n\n*/\n\nfloat LogicomaLogo(vec2 c)\n{\n    float d = length(c) - 0.4;\n    d = max(d, 0.39 - length(c));\n\n    vec2 c2;\n    float r = 0.275;\n    c2 = c + r * vec2(0., 1.0);\n    d = min(d, max(length(c2) - 0.03, 0.02 - length(c2)));\n\n    c2 = c + r * normalize(vec2(1.5, -1.));\n    d = min(d, max(length(c2) - 0.03, 0.02 - length(c2)));\n\n    c2 = c + r * normalize(vec2(-1.5, -1.));\n    d = min(d, max(length(c2) - 0.03, 0.02 - length(c2)));\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    \n    float d = LogicomaLogo(uv - vec2(0.9, 0.5));\n\n    fragColor = vec4(draw(iResolution, d), 1.0);\n}\n", "image_inputs": [], "common_code": "#define DEBUG_DISTANCE 0\n\n// See: https://www.shadertoy.com/view/XcVGRR\nvec3 debugDistance(vec3 iResolution, float d, vec3 color)\n{\n    float refWidth = iResolution.y / 1080.;\n\n    float dd1 = fwidth(d);\n    float width1 = 2.5 * dd1 * refWidth;\n    float iso1 = smoothstep(1. - width1 - dd1, 1. - width1 + dd1, abs(fract(d) * 2. - 1.));\n\n    float dd5 = fwidth(5. * d);\n    float width5 = 0.75 * dd5 * refWidth;\n    float iso5 = smoothstep(1. - width5 - dd5, 1. - width5 + dd5, abs(fract(5.*d) * 2. - 1.));\n\n    float dd0 = fwidth(d);\n    float width0 = 3. * dd0 * refWidth;\n    float iso0 = smoothstep(1. - width0 - dd0, 1. - width0 + dd0, 1. - abs(d));\n\n    float isoLines = max(iso0, max(iso1, iso5));\n\n    vec3 background = (d > 0. ? vec3(1.) : mix(vec3(0.8), color, 0.1));\n    vec3 lineColor = mix(color * (d > 0. ? 1. : 0.8), vec3(0.), iso0);\n\n    return mix(background, lineColor, isoLines);\n}\n\nvec3 draw(vec3 iResolution, float d)\n{\n#if DEBUG_DISTANCE\n    return debugDistance(iResolution, 10.*d, vec3(0.8, 0.5, 1.));\n#else\n    float dd = fwidth(d);\n    return vec3(1. - smoothstep(-dd / 2., dd / 2., d));\n#endif\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lc33Wf.jpg", "time_retrieved": "2024-04-28T18:59:50.035217", "access": "api", "wgpu-test": "ok"}
{"id": "sdjXW1", "name": "MCGA on CRT", "author": "Zavie", "description": "A quick test of CRT post-effect.", "tags": ["postprocessing", "retro", "crt", "mcga"], "image_code": "#define BLUR_LENGTH 100\n#define BLUR_STEPS 50\n\nfloat hash(vec2 co)\n{\n    return fract(sin(dot(co.xy ,vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float v = fragCoord.y / iResolution.y;\n    float rand = hash(fragCoord);\n\n    float epsilon = 0.01;\n    float baseIntensity = pow(epsilon, 1./float(BLUR_STEPS));\n\n    vec3 color = vec3(0.);\n\n    for (int i = 0; i < BLUR_STEPS; ++i)\n    {\n        float offset = (float(i) + rand) * float(BLUR_LENGTH) / float(BLUR_STEPS);\n\n        float u = (fragCoord.x - offset) / iResolution.x;\n\n        float intensity = exp(-float(i) * 5. / offset);\n        color += texture(iChannel1, vec2(u, v)).rgb * pow(baseIntensity, float(i));\n    }\n    color *= 0.3*float(BLUR_LENGTH)/float(BLUR_STEPS);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_a_code": "//\n// Input image, compositing a video with a static texture just so it looks more interesting.\n//\n\nvec3 rgb2hsv(vec3 rgb)\n{\n\tfloat Cmax = max(rgb.r, max(rgb.g, rgb.b));\n\tfloat Cmin = min(rgb.r, min(rgb.g, rgb.b));\n    float delta = Cmax - Cmin;\n\n\tvec3 hsv = vec3(0., 0., Cmax);\n\t\n\tif (Cmax > Cmin)\n\t{\n\t\thsv.y = delta / Cmax;\n\n\t\tif (rgb.r == Cmax)\n\t\t\thsv.x = (rgb.g - rgb.b) / delta;\n\t\telse\n\t\t{\n\t\t\tif (rgb.g == Cmax)\n\t\t\t\thsv.x = 2. + (rgb.b - rgb.r) / delta;\n\t\t\telse\n\t\t\t\thsv.x = 4. + (rgb.r - rgb.g) / delta;\n\t\t}\n\t\thsv.x = fract(hsv.x / 6.);\n\t}\n\treturn hsv;\n}\n\nfloat chromaKey(vec3 color)\n{\n\tvec3 backgroundColor = vec3(0.157, 0.576, 0.129);\n\tvec3 weights = vec3(4., 1., 2.);\n\n\tvec3 hsv = rgb2hsv(color);\n\tvec3 target = rgb2hsv(backgroundColor);\n\tfloat dist = length(weights * (target - hsv));\n\treturn 1. - clamp(3. * dist - 1.5, 0., 1.);\n}\n\nvec3 changeSaturation(vec3 color, float saturation)\n{\n\tfloat luma = dot(vec3(0.213, 0.715, 0.072) * color, vec3(1.));\n\treturn mix(vec3(luma), color, saturation);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\tvec3 color = texture(iChannel0, uv).rgb;\n\tvec3 bg = texture(iChannel1, uv).rgb;\n\t\n\tfloat incrustation = chromaKey(color);\n\t\n\tcolor = changeSaturation(color, 0.5);\n\tcolor = mix(color, bg, incrustation);\n\n    //color = vec3(smoothstep(0.01, 0.009, length(uv*vec2(iResolution.x/iResolution.y, 1.)-0.5)));\n    //color = debugPattern(fragCoord, iResolution.xy);\n\tfragColor = vec4(color, 1.);\n}\n", "buffer_a_inputs": [{"id": 5, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define PIXEL_SIZE 6\n#define COLOR_DEPTH vec3(8)\n", "buffer_b_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = floor(iResolution.xy / float(PIXEL_SIZE));\n\n    vec2 pixel = fract(fragCoord / float(PIXEL_SIZE));\n    vec3 mask = (pixel.x - vec3(0., 2., 4.)/6.) * 3.;\n    mask = 1. - clamp(pow(abs(1. - 2. * mask), vec3(8.)), 0., 1.);\n    mask *= 1. - clamp(pow(abs(1. - 2. * pixel.y), 3.), 0., 1.);\n\n\n    vec2 uv = floor(fragCoord/vec2(PIXEL_SIZE))/resolution;\n    vec3 color = texture(iChannel0, uv).rgb;\n    color = floor(color * COLOR_DEPTH) / COLOR_DEPTH;\n    color *= mask*mask;\n\n\n\n    fragColor = vec4(color, 1.0);\n}\n", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/sdjXW1.jpg", "time_retrieved": "2024-04-28T18:59:50.051174", "access": "api", "wgpu-test": "incomplete"}
{"id": "lfcGDX", "name": "Greetings, Alcatraz", "author": "Zavie", "description": "This shader draws the logo of the demogroup \"Alcatraz\".\n\"Official\" version: https://www.shadertoy.com/view/Mf33Wl\n\nMore logos: https://www.shadertoy.com/playlist/NX3yzf", "tags": ["demoscene", "logo"], "image_code": "/*\n\nThis shader draws the logo of the demoscene group \"Alcatraz\".\n\nAlcatraz:\n > http://alcatraz.untergrund.net/\n > https://www.youtube.com/watch?v=YK7fbtQw3ZU\n\n--\nZavie / Ctrl-Alt-Test\n\n*/\n\nfloat Box(vec2 p, vec2 size)\n{\n    vec2 u = abs(p) - size;\n    return max(u.x, u.y);\n}\n\nfloat AlcatrazLogo(vec2 p)\n{\n    vec2 q = 0.707 * vec2(p.x + p.y, p.x - p.y);\n    float d = -Box(q, vec2(0.2));\n    d = min(d, abs(fract(p.x*11.-0.5) *2.-1.)/20. - 0.015);\n\n    d = min(d, Box(p, vec2(0.1)));\n    d = max(d, -Box(p, vec2(0.015, 0.05)));\n    p.y -= 0.03;\n    d = max(d, 0.03 - length(p));\n\n    d = max(d, Box(q, vec2(0.215)));\n\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\n    float d = AlcatrazLogo(uv - vec2(0.9, 0.5));\n\n    fragColor = vec4(draw(iResolution, d), 1.0);\n}\n", "image_inputs": [], "common_code": "#define DEBUG_DISTANCE 0\n\n// See: https://www.shadertoy.com/view/XcVGRR\nvec3 debugDistance(vec3 iResolution, float d, vec3 color)\n{\n    float refWidth = iResolution.y / 1080.;\n\n    float dd1 = fwidth(d);\n    float width1 = 2.5 * dd1 * refWidth;\n    float iso1 = smoothstep(1. - width1 - dd1, 1. - width1 + dd1, abs(fract(d) * 2. - 1.));\n\n    float dd5 = fwidth(5. * d);\n    float width5 = 0.75 * dd5 * refWidth;\n    float iso5 = smoothstep(1. - width5 - dd5, 1. - width5 + dd5, abs(fract(5.*d) * 2. - 1.));\n\n    float dd0 = fwidth(d);\n    float width0 = 3. * dd0 * refWidth;\n    float iso0 = smoothstep(1. - width0 - dd0, 1. - width0 + dd0, 1. - abs(d));\n\n    float isoLines = max(iso0, max(iso1, iso5));\n\n    vec3 background = (d > 0. ? vec3(1.) : mix(vec3(0.8), color, 0.1));\n    vec3 lineColor = mix(color * (d > 0. ? 1. : 0.8), vec3(0.), iso0);\n\n    return mix(background, lineColor, isoLines);\n}\n\nvec3 draw(vec3 iResolution, float d)\n{\n#if DEBUG_DISTANCE\n    return debugDistance(iResolution, 10.*d, vec3(0.8, 0.5, 1.));\n#else\n    float dd = fwidth(d);\n    return vec3(1. - smoothstep(-dd / 2., dd / 2., d));\n#endif\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lfcGDX.jpg", "time_retrieved": "2024-04-28T18:59:50.149910", "access": "api", "wgpu-test": "ok"}
{"id": "Mf33WX", "name": "Greetings, TBL", "author": "Zavie", "description": "This shader draws the logo of the Swedish demogroup \"TBL\" (The Black Lotus).\n\nMore logos: https://www.shadertoy.com/playlist/NX3yzf", "tags": ["demoscene", "logo"], "image_code": "/*\n\nThis shader draws the logo of the Swedish demoscene group \"The Black Lotus\".\n\nTBL:\n > https://tbl.nu/\n > https://www.youtube.com/watch?v=i1O4_58HVIg\n\n--\nZavie / Ctrl-Alt-Test\n\n*/\n\nfloat TBLLogo(vec2 p)\n{\n    p *= 7.;\n    if (abs(p.x) < 4.5 && abs(p.y) < 1.5)\n    {\n        vec2 ip = floor(p + 0.5);\n        bool skip = false;\n        if (ip != vec2(-4, 1) &&\n            ip != vec2(-4, -1) &&\n            ip != vec2(-2, 1) &&\n            ip != vec2(-2, -1) &&\n            ip != vec2(0, 1) &&\n            ip != vec2(1, 1) &&\n            (ip.x < 3. || ip.y < 0.))\n        {\n            p = mod(p + 0.5, 1.) - 0.5;\n        }\n    }\n    return (length(p) - 0.5) / 6.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.y;\n\n    float d = TBLLogo(uv - vec2(0.9, 0.5));\n\n    fragColor = vec4(draw(iResolution, d), 1.0);\n}\n", "image_inputs": [], "common_code": "#define DEBUG_DISTANCE 0\n\n// See: https://www.shadertoy.com/view/XcVGRR\nvec3 debugDistance(vec3 iResolution, float d, vec3 color)\n{\n    float refWidth = iResolution.y / 1080.;\n\n    float dd1 = fwidth(d);\n    float width1 = 2.5 * dd1 * refWidth;\n    float iso1 = smoothstep(1. - width1 - dd1, 1. - width1 + dd1, abs(fract(d) * 2. - 1.));\n\n    float dd5 = fwidth(5. * d);\n    float width5 = 0.75 * dd5 * refWidth;\n    float iso5 = smoothstep(1. - width5 - dd5, 1. - width5 + dd5, abs(fract(5.*d) * 2. - 1.));\n\n    float dd0 = fwidth(d);\n    float width0 = 3. * dd0 * refWidth;\n    float iso0 = smoothstep(1. - width0 - dd0, 1. - width0 + dd0, 1. - abs(d));\n\n    float isoLines = max(iso0, max(iso1, iso5));\n\n    vec3 background = (d > 0. ? vec3(1.) : mix(vec3(0.8), color, 0.1));\n    vec3 lineColor = mix(color * (d > 0. ? 1. : 0.8), vec3(0.), iso0);\n\n    return mix(background, lineColor, isoLines);\n}\n\nvec3 draw(vec3 iResolution, float d)\n{\n#if DEBUG_DISTANCE\n    return debugDistance(iResolution, 10.*d, vec3(0.8, 0.5, 1.));\n#else\n    float dd = fwidth(d);\n    return vec3(1. - smoothstep(-dd / 2., dd / 2., d));\n#endif\n}\n", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/Mf33WX.jpg", "time_retrieved": "2024-04-28T18:59:50.167862", "access": "api", "wgpu-test": "ok"}
{"id": "lccGWX", "name": "NotSoGreeeen - Solar System", "author": "NotSoGreeeen", "description": "While working my model of a sphere, I went on a side tangent to create a quick solar system.\n\nSoon I will post a new sphere using this model.", "tags": ["circles", "beginner", "solarsystem"], "image_code": "vec3 planet(vec2 uv, float offset, float speed, float dist, vec3 color) {\n    return vec3(smoothstep(.89, .8, length(vec2(uv.x + sin((iTime + offset) * speed) * dist, uv.y + cos((iTime + offset) * speed) * dist)))) * color;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / min(iResolution.x, iResolution.y);\n    uv *= 25.;\n    \n    // Time varying pixel color\n    vec3 col = vec3(1.6);\n    col += planet(uv, .7, 1.2, 6., vec3(.7, 1.5, .7));\n    col += planet(uv, 3.1, 1., 8.5, vec3(1.7, 2.5, 2.7));\n    col += planet(uv, .4, .5, 11., vec3(4.7, 2.5, 1.7));\n    col += planet(uv, 1.5, .7, 14., vec3(2.7, 1.5, 5.7));\n    col += planet(uv / 2., 5.4, 1.387, 8.5, vec3(4., 2.8, 2.));\n    col += planet(uv / 1.4, 2.4, .92, 14.57, vec3(1., 10., 1.));\n    col += planet(uv * 1.5, 1.87, 2., 37.45, vec3(1., 1., 4.8));\n    col /= vec3(1.15, 1.15, 1.2);\n    col /= vec3(length(uv.xy));\n    col = pow(col, vec3(2.));\n    col = pow(col, vec3(0.554545));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lccGWX.jpg", "time_retrieved": "2024-04-28T18:59:50.356358", "access": "api", "wgpu-test": "ok"}
{"id": "XccGWX", "name": "Checkerboard Float Error", "author": "SnoopethDuckDuck", "description": "A small fractal thing I found interesting, maybe it's a bug? \n\nScreenshots:\nhttps://postimg.cc/gallery/5Hkbkxc", "tags": ["fractal", "bug", "error", "float"], "image_code": "void mainImage( out vec4 o, vec2 u )\n{\n    vec2 R = iResolution.xy;\n   \n    // Replace exp2() to change zoom\n    u = ceil(exp2(iTime) * (u+u-R) / R.y);\n\n    float a = .99999995; // Checkboard with fractal error\n    // a = 1.;           // Checkerboard with no error\n\n    o = vec4(0. == mod(u.x + a * u.y, 2.));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/XccGWX.jpg", "time_retrieved": "2024-04-28T18:59:50.416198", "access": "api", "wgpu-test": "error"}
{"id": "lftGWj", "name": "15 grids font v3", "author": "yasuo", "description": "15 grids font v3", "tags": ["fonts", "graphicdesign", "cineshader"], "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.5),-antialiasing(1.5),d - b)\n#define B(p,s) max(abs(p).x-s.x,abs(p).y-s.y)\n#define BASE_FONT_SIZE 0.08\n\nint cA[15] = int[](1,1,1,0,0,1,1,1,1,1,0,1,1,1,1);\nint cB[15] = int[](1,1,1,1,0,1,1,1,0,1,0,1,1,1,1);\nint cC[15] = int[](1,1,1,1,0,0,1,0,0,1,0,0,1,1,1);\nint cD[15] = int[](1,1,0,1,0,1,1,0,1,1,0,1,1,1,0);\nint cE[15] = int[](1,1,1,1,0,0,1,1,0,1,0,0,1,1,1);\nint cF[15] = int[](1,1,1,1,0,0,1,1,0,1,0,0,1,0,0);\nint cG[15] = int[](1,1,1,1,0,0,1,0,1,1,0,1,1,1,1);\nint cH[15] = int[](1,0,1,1,0,1,1,1,1,1,0,1,1,0,1);\nint cI[15] = int[](0,1,0,0,0,0,0,1,0,0,1,0,0,1,0);\nint cJ[15] = int[](0,1,1,0,0,1,0,0,1,0,0,1,1,1,1);\nint cK[15] = int[](1,0,1,1,0,1,1,1,0,1,0,1,1,0,1);\nint cL[15] = int[](1,0,0,1,0,0,1,0,0,1,0,0,1,1,1);\nint cM[15] = int[](1,0,1,1,1,1,1,0,1,1,0,1,1,0,1);\nint cN[15] = int[](1,1,1,1,0,1,1,0,1,1,0,1,1,0,1);\nint cO[15] = int[](1,1,1,1,0,1,1,0,1,1,0,1,1,1,1);\nint cP[15] = int[](1,1,1,1,0,1,1,1,1,1,0,0,1,0,0);\nint cQ[15] = int[](1,1,1,1,0,1,1,0,1,1,1,1,0,0,1);\nint cR[15] = int[](1,1,1,1,0,1,1,1,0,1,0,1,1,0,1);\nint cS[15] = int[](1,1,1,1,0,0,1,1,1,0,0,1,1,1,1);\nint cT[15] = int[](1,1,1,0,1,0,0,1,0,0,1,0,0,1,0);\nint cU[15] = int[](1,0,1,1,0,1,1,0,1,1,0,1,1,1,1);\nint cV[15] = int[](1,0,1,1,0,1,1,0,1,1,1,0,1,0,0);\nint cW[15] = int[](1,0,1,1,0,1,1,0,1,1,1,1,1,0,1);\nint cX[15] = int[](1,0,1,1,0,1,0,1,0,1,0,1,1,0,1);\nint cY[15] = int[](1,0,1,1,0,1,1,1,1,0,1,0,0,1,0);\nint cZ[15] = int[](1,1,1,0,0,1,0,1,0,1,0,0,1,1,1);\nint c0[15] = int[](1,1,1,1,0,1,1,0,1,1,0,1,1,1,1);\nint c1[15] = int[](0,1,0,0,1,0,0,1,0,0,1,0,0,1,0);\nint c2[15] = int[](1,1,1,0,0,1,1,1,1,1,0,0,1,1,1);\nint c3[15] = int[](1,1,1,0,0,1,1,1,1,0,0,1,1,1,1);\nint c4[15] = int[](1,0,0,1,0,0,1,1,0,1,1,1,0,1,0);\nint c5[15] = int[](1,1,1,1,0,0,1,1,1,0,0,1,1,1,1);\nint c6[15] = int[](1,1,1,1,0,0,1,1,1,1,0,1,1,1,1);\nint c7[15] = int[](1,1,1,0,0,1,0,0,1,0,0,1,0,0,1);\nint c8[15] = int[](1,1,1,1,0,1,1,1,1,1,0,1,1,1,1);\nint c9[15] = int[](1,1,1,1,0,1,1,1,1,0,0,1,1,1,1);\n\n// thx iq! https://iquilezles.org/articles/distfunctions/\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat baseFontShape(vec2 p, float i){\n    float size = BASE_FONT_SIZE;\n    float d = length(p)-(size-(cos(10.*(100.+iTime)*(i+1.0)*.2)*(size*0.5)));\n    float d2 = length(p)-size;\n    d = min(d,d2);\n    return d;\n}\n\nfloat chars(vec2 p, int[15] data, float n){\n    vec2 prevP  = p;\n    float size = BASE_FONT_SIZE;\n    float d = 10.;\n    float k = size+0.05;\n    for(int i = 0; i<data.length(); i++){\n        p = prevP;\n        p.x-=(float(i%3)*(size*2.))-(size*2.);\n        p.y+=(float(i/3)*(size*2.))-(size*4.);\n        \n        if(data[i] == 1){\n            float d2 = baseFontShape(p,sin(float(i))*n);\n            d = smin(d,d2,k);\n        }\n    }\n    return d;\n}\n\nfloat drawFont(vec2 p, int char, float n){\n    float d = 10.;\n    if(char == 0) {\n        d = chars(p,c0,n);\n    } else if(char == 1) {\n        d = chars(p,c1,n);\n    } else if(char == 2) {\n        d = chars(p,c2,n);\n    } else if(char == 3) {\n        d = chars(p,c3,n);\n    } else if(char == 4) {\n        d = chars(p,c4,n);\n    } else if(char == 5) {\n        d = chars(p,c5,n);\n    } else if(char == 6) {\n        d = chars(p,c6,n);\n    } else if(char == 7) {\n        d = chars(p,c7,n);\n    } else if(char == 8) {\n        d = chars(p,c8,n);\n    } else if(char == 9) {\n        d = chars(p,c9,n);\n    } else if(char == 10) {\n        d = chars(p,cA,n);\n    } else if(char == 11) {\n        d = chars(p,cB,n);\n    } else if(char == 12) {\n        d = chars(p,cC,n);\n    } else if(char == 13) {\n        d = chars(p,cD,n);\n    } else if(char == 14) {\n        d = chars(p,cE,n);\n    } else if(char == 15) {\n        d = chars(p,cF,n);\n    } else if(char == 16) {\n        d = chars(p,cG,n);\n    } else if(char == 17) {\n        d = chars(p,cH,n);\n    } else if(char == 18) {\n        d = chars(p,cI,n);\n    } else if(char == 19) {\n        d = chars(p,cJ,n);\n    } else if(char == 20) {\n        d = chars(p,cK,n);\n    } else if(char == 21) {\n        d = chars(p,cL,n);\n    } else if(char == 22) {\n        d = chars(p,cM,n);\n    } else if(char == 23) {\n        d = chars(p,cN,n);\n    } else if(char == 24) {\n        d = chars(p,cO,n);\n    } else if(char == 25) {\n        d = chars(p,cP,n);\n    } else if(char == 26) {\n        d = chars(p,cQ,n);\n    } else if(char == 27) {\n        d = chars(p,cR,n);\n    } else if(char == 28) {\n        d = chars(p,cS,n);\n    } else if(char == 29) {\n        d = chars(p,cT,n);\n    } else if(char == 30) {\n        d = chars(p,cU,n);\n    } else if(char == 31) {\n        d = chars(p,cV,n);\n    } else if(char == 32) {\n       d = chars(p,cW,n);\n    } else if(char == 33) {\n       d = chars(p,cX,n);\n    } else if(char == 34) {\n       d = chars(p,cY,n);\n    } else if(char == 35) {\n       d = chars(p,cZ,n);\n    }\n    \n    return d;\n}\n\nfloat backOut(float t) {\n  float f = 1.0 - t;\n  return 1.0 - (pow(f, 3.0) - f * sin(f * 3.1415));\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nfloat getTime(float t, float duration){\n    return clamp(t,0.0,duration)/duration;\n}\n\nfloat numberAnim(vec2 p, float speed, float n){\n    float morphVal = 0.;\n    float frame = mod(iTime*speed,10.0);\n    float time = frame;\n    \n    float duration = 0.7;\n    float d = drawFont(p,0,n);\n    if(frame>=0. && frame<1.){\n        time = getTime(time,duration);\n        morphVal = backOut(time);\n        d = mix(drawFont(p,0,n),drawFont(p,1,n),morphVal);\n    } else if(frame>=1. && frame<2.){\n        time = getTime(time-1.,duration);\n        morphVal = backOut(time);\n        d = mix(drawFont(p,1,n),drawFont(p,2,n),morphVal);\n    } else if(frame>=2. && frame<3.){\n        time = getTime(time-2.,duration);\n        morphVal = backOut(time);\n        d = mix(drawFont(p,2,n),drawFont(p,3,n),morphVal);\n    } else if(frame>=3. && frame<4.){\n        time = getTime(time-3.,duration);\n        morphVal = backOut(time);\n        d = mix(drawFont(p,3,n),drawFont(p,4,n),morphVal);\n    } else if(frame>=4. && frame<5.){\n        time = getTime(time-4.,duration);\n        morphVal = backOut(time);\n        d = mix(drawFont(p,4,n),drawFont(p,5,n),morphVal);\n    } else if(frame>=5. && frame<6.){\n        time = getTime(time-5.,duration);\n        morphVal = backOut(time);\n        d = mix(drawFont(p,5,n),drawFont(p,6,n),morphVal);\n    } else if(frame>=6. && frame<7.){\n        time = getTime(time-6.,duration);\n        morphVal = backOut(time);\n        d = mix(drawFont(p,6,n),drawFont(p,7,n),morphVal);\n    } else if(frame>=7. && frame<8.){\n        time = getTime(time-7.,duration);\n        morphVal = backOut(time);\n        d = mix(drawFont(p,7,n),drawFont(p,8,n),morphVal);\n    } else if(frame>=8. && frame<9.){\n        time = getTime(time-8.,duration);\n        morphVal = backOut(time);\n        d = mix(drawFont(p,8,n),drawFont(p,9,n),morphVal);\n    } else if(frame>=9. && frame<10.){\n        time = getTime(time-9.,duration);\n        morphVal = backOut(time);\n        d = mix(drawFont(p,9,n),drawFont(p,0,n),morphVal);\n    }\n\n    return d;\n}\n\nfloat random (vec2 p) {\n    return fract(sin(dot(p.xy, vec2(12.9898,78.233)))* 43758.5453123);\n}\n\nfloat dots(vec2 p){\n    float size = BASE_FONT_SIZE;\n    p = mod(p,size)-(size*0.5);\n    float d = length(p)-0.002;\n    return d;\n}\n\nfloat plus(vec2 p){\n    float d = min(B(p,vec2(0.001,0.015)),B(p,vec2(0.015,0.001)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    vec2 prevP = p;\n    vec3 col = vec3(0.);\n    \n    p.y-=100.+iTime*0.2;\n    float d = dots(p);\n    col = mix(col,vec3(0.8),S(d,0.));\n    \n    p = prevP;\n    \n    p.x+=1.;\n    p.y+=1.;\n    p*=2.5;\n    p.y-=100.+iTime*0.5;\n    vec2 gv = fract(p)-0.5;\n    vec2 id = floor(p);\n\n    float n = random(id)*35.0;\n    int char = int(n);\n    \n    d = 10.;\n    vec3 fontColor = vec3(random(prevP*(iTime+100.)))+0.5;\n    if(char < 15){\n        d = numberAnim(gv,float(n*0.3),sin(n));\n        col = mix(col,vec3(fontColor),S(d,0.));\n    } else {\n        d = drawFont(gv,char,sin(n));\n        col = mix(col,vec3(fontColor),S(d,0.));\n    }\n    col = mix(col,vec3(0.6),S(abs(d)-0.003,0.));\n    \n    p = prevP;\n    \n    p.y-=iTime*0.2;\n    p = mod(p,0.4)-0.2;\n    d = plus(p);\n    col = mix(col,vec3(1.),S(d,0.));    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lftGWj.jpg", "time_retrieved": "2024-04-28T18:59:50.421184", "access": "api", "wgpu-test": "ok"}
{"id": "4XBSRK", "name": "SAMSA - Fragment IV", "author": "Kris_Katur", "description": "Samsa unveils a dance of geometry, where distinct bodies seamlessly merge, creating a fluid-like sculpture in permanent flux. This metamorphosis perpetually evolves, as if on a quest to discover its ultimate and absolute form.", "tags": ["raymarching", "reflection", "refraction", "glass", "normal", "morph", "fresnel", "bool", "cineshader", "samsa"], "image_code": "/* \"Samsa - Fragment IV\"\n    2024\n    by KÎ›TUR\n    License - Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Unported License.\n\n    \n    Fragment I   - https://www.shadertoy.com/view/MflGDM\n    Fragment II  - https://www.shadertoy.com/view/XX2SRR\n    Fragment III - https://www.shadertoy.com/view/XX2SWR\n    Fragment IV  - https://www.shadertoy.com/view/4XBSRK\n    \n    https://lichterloh.tv/portfolio/samsa/\n    \n//========================================================//\n\n               âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§â—‹âˆ¨âˆ§âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§\n               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆÂ¬Â¬Â¬â–ˆâ–ˆÂ¬â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n               â–ˆÂ¬Â¬Â¬Â¬Â¬â–ˆâ–ˆÂ¬Â¬â–ˆÂ¬â–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆâ–ˆÂ¬â–ˆÂ¬Â¬Â¬Â¬Â¬â–ˆâ–ˆÂ¬Â¬â–ˆ\n               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆâ– â– â–ˆÂ¬â–ˆÂ¬Â¬â–ˆÂ¬Â¬â–ˆÂ¬â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆâ– â– â–ˆ\n               Â¬Â¬Â¬Â¬â–ˆÂ¬â–ˆâ–ˆÂ¬Â¬â–ˆÂ¬â–ˆÂ¬Â¬Â¬Â¬Â¬â–ˆÂ¬Â¬Â¬Â¬Â¬â–ˆÂ¬â–ˆâ–ˆÂ¬Â¬â–ˆ\n               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆÂ¬Â¬â–ˆÂ¬â–ˆÂ¬Â¬Â¬Â¬Â¬â–ˆÂ¬â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆÂ¬Â¬â–ˆ\n               âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨â—âˆ§âˆ¨âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨\n\n        An exploration of light and form, continuously\n          adapting on a quest to find equilibrium.\n\n             Motivated by the uncluttered yet\n                 intricate beauty of math.\n\n//========================================================//\n\nAnti Aliasing from https://www.shadertoy.com/view/wtjfRV\nAA 0 = no AA\nAA 1 = with AA\n(GPU intense - Any better solution welcome :)  <3  )      */\n\n#define AA 0\n\nvec3 CamTransform(float t){\n    t *= .1;\n    return vec3(sin(t)*sin(t*.9)*7.,\n                sin(t+sin(t*.6)*5.),\n                cos(t)*-7.);\n}\n\nfloat SDF(vec3 p){\n    \nfloat t = iTime*.2;\n      t += sin(iTime*.5)*.3;\n        \n    // TORUS\n    float tor = 1e9;\n    for(float i=min(t,0.);i<3.;i++){\n        vec3 pt = p;\n        float s = sin(t+i)*.5+1.;\n        pt.x += sin(t*.15+i*1.3)*3.;\n        pt.y += sin(t*.32+i*1.2);\n        pt.z += sin(t*.52+i*1.1)*3.;\n        pt.xz *= Rot(t*.59-i);\n        pt.xy *= Rot(t*.62+i);\n        pt.yz *= Rot(t*.47-i);\n    tor = Smin(tor,Torus(pt,vec2(s,s*.1)),1.5);}   \n    tor += (sin(t+p.x*2.)*cos(t+p.y))*.2-.2; // deformation\n    \n    // SPHERE\n    float sph = 1e9;\n    for(float i=min(t,0.);i<2.;i++){\n        vec3 ps = p;\n        ps.x += sin(t*.33-i*1.5)*2.5;\n        ps.y += sin(t*.41+i)*2.+.5;\n        ps.z += sin(t*.27+i*i)*2.5;\n    sph = Smin(sph,Sphere(ps,sin(t+i)*.4+.6),1.);}\n        \n    // GYROID I\n    float sg = 2.;\n    float gyr = abs(dot(sin(p*sg),cos(p.zxy*sg)))/sg-.2;\n    \n    // GYROID II\n    float gyr2 = abs(dot(sin(p),cos(p.zxy)))-1.;\n    \n    // PLANE\n    vec3  pp = p;\n    pp.y += 2.;\n    float pla = pp.y;\n    \n    // COMPOSITION                  // == Boolsche Operation ==\n        float d = 1e9;\n        gyr = Smax(gyr,tor-.3,.03); // Intersection::Gyroid I AND bigger Tori  \n        d = min(d,gyr);             // Union:::::::::Sdf  OR  Gyroid\n        d = Smin(d,pla,1.);         // Union:::::::::Sdf  OR  Plane\n        d = Smin(d,sph,1.);         // Union:::::::::Sdf  OR  Spheres\n        d = Smax(d,-tor,.1);        // Subtraction:::Sdf  NOT Tori\n  float e = Smax(tor-.2,gyr2,.5);   // Intersection2:Tori AND Gyroid II\n        d = max(d,-e);              // Subtraction:::Sdf  NOT Intersection2\n\n    // DEFORMATION\n    float b = 73.;\n    d += clamp(0.,2.,p.y+1.7) * pow( (sin(t+p.x*p.z*p.y*.5)*.5+.5),8.) *( (asin(sin(p.x*b)) + asin(sin(p.y*b)) +asin(sin(p.z*b)))*0.01);\n    \n    // CAMERA BOUNDING SPHERE\n    d = Smax(d,-Sphere(p-CamTransform(iTime),.3),.5)*.9; // Sphere Subtraction\n    \n    return d;\n}\n\nfloat March(vec3 ro, vec3 rd, float side){\n    float o=0.;\n    for(int i=0;i<MAX_STEPS; i++){\n        vec3 p = ro + rd*o;\n        float dS = SDF(p)*side;\n        o += dS;\n        if(o>MAX_DIST||abs(dS)<SURF_DIST) break;\n    }\n    return o;\n}\n\nvec3 CalcNormal (vec3 p){\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=min(iFrame,0); i<4; i++ ){\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*SDF(p+.001*e);\n    }\n    return normalize(n);\n}\n\nvec4 Color ( in vec2 fragCoord )\n{\n    float t = iTime*.1;\n    \n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 ro = CamTransform(iTime),\n         rd = CastRay(uv, ro, vec3(0), 2.),\n         col = vec3(1);       \n    \n    float d = March(ro, rd, 1.);\n    \n    float IOR = 1.45; // index of refraction\n\n    if(d<MAX_DIST){\n    \n        vec3 p = ro + rd * d; \n        vec3 n = CalcNormal(p); \n        vec3 r = reflect(rd, n);\n        \n// :::: Refraction from https://www.shadertoy.com/view/sllGDN :::: //\n\n        vec3 refOutside = texture(iChannel0, r).rgb;\n        vec3 rdIn = refract(rd, n, 1./IOR);\n        \n        vec3 pEnter = p - n*SURF_DIST*4.;\n        float dIn = March(pEnter, rdIn, -1.);\n        \n        vec3 pExit = pEnter + rdIn * dIn;\n        vec3 nExit = -CalcNormal(pExit); \n        \n        vec3 reflTex = vec3(0);\n        vec3 rdOut = vec3(0);\n        float ab = clamp(0.,.02,p.y+1.);\n        \n        // red\n        rdOut = refract(rdIn, nExit, IOR-ab);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex.r = texture(iChannel0, rdOut).r;\n        \n        // green\n        rdOut = refract(rdIn, nExit, IOR);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex.g = texture(iChannel0, rdOut).g;\n        \n        // blue\n        rdOut = refract(rdIn, nExit, IOR+ab);\n        if(dot(rdOut, rdOut)==0.) rdOut = reflect(rdIn, nExit);\n        reflTex.b = texture(iChannel0, rdOut).b;\n        \n        /*\n        // density of the medium\n        \n        float dens = .1;\n        float optDist = exp(-dIn*dens);\n        \n        reflTex = reflTex*optDist;\n        */\n        \n        float fresnel = pow(1.+dot(rd, n), 5.);\n        \n        col = mix(reflTex, refOutside, fresnel);\n    }\n    \n    col = mix( col, vec3(texture(iChannel0,rd).rgb)*.9, 1.-exp(-pow(.08*d,6.)));//fog\n    col = pow(col, vec3(.4545)); //gamma correction\n\treturn vec4(col, 1);\n}\n\n\n// AA from https://www.shadertoy.com/view/wtjfRV\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = Color(fragCoord);\n#if AA == 1\n    fragColor = vec4(0);\n    float A = 2.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s)\n    fragColor += min ( Color(vec2(x,y)+fragCoord), 1.0);     \n\tfragColor /= A*A;\n#endif\n    \n}", "image_inputs": [{"id": 22, "src": "/media/a/585f9546c092f53ded45332b343144396c0b2d70d9965f585ebc172080d8aa58.jpg", "ctype": "cubemap", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 37073, "src": "https://soundcloud.com/user-66247455/phillip-glass-glassworks?utm_source=clipboard&utm_medium=text&utm_campaign=social_sharing", "ctype": "musicstream", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0}], "common_code": "/* \"Samsa - Fragment IV\"\n    2024\n    by KÎ›TUR\n    License - Creative Commons Attribution-NonCommercial-ShareAlike 4.0 International Unported License.\n\n    \n    Fragment I   - https://www.shadertoy.com/view/MflGDM\n    Fragment II  - https://www.shadertoy.com/view/XX2SRR\n    Fragment III - https://www.shadertoy.com/view/XX2SWR\n    Fragment IV  - https://www.shadertoy.com/view/4XBSRK\n    \n    https://lichterloh.tv/portfolio/samsa/\n    \n//========================================================//\n\n               âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§â—‹âˆ¨âˆ§âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§\n               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆÂ¬Â¬Â¬â–ˆâ–ˆÂ¬â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\n               â–ˆÂ¬Â¬Â¬Â¬Â¬â–ˆâ–ˆÂ¬Â¬â–ˆÂ¬â–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆâ–ˆÂ¬â–ˆÂ¬Â¬Â¬Â¬Â¬â–ˆâ–ˆÂ¬Â¬â–ˆ\n               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆâ– â– â–ˆÂ¬â–ˆÂ¬Â¬â–ˆÂ¬Â¬â–ˆÂ¬â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆâ– â– â–ˆ\n               Â¬Â¬Â¬Â¬â–ˆÂ¬â–ˆâ–ˆÂ¬Â¬â–ˆÂ¬â–ˆÂ¬Â¬Â¬Â¬Â¬â–ˆÂ¬Â¬Â¬Â¬Â¬â–ˆÂ¬â–ˆâ–ˆÂ¬Â¬â–ˆ\n               â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆÂ¬Â¬â–ˆÂ¬â–ˆÂ¬Â¬Â¬Â¬Â¬â–ˆÂ¬â–ˆâ–ˆâ–ˆâ–ˆâ–ˆÂ¬â–ˆâ–ˆÂ¬Â¬â–ˆ\n               âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨â—âˆ§âˆ¨âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨âˆ§âˆ¨\n\n        An exploration of light and form, continuously\n          adapting on a quest to find equilibrium.\n\n             Motivated by the uncluttered yet\n                 intricate beauty of math.\n\n//========================================================*/\n\n#define MAX_STEPS 100\n#define MAX_DIST 20.\n#define SURF_DIST .001\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);}\n\n//===================================================================//\n// below by https://iquilezles.org/\n\nfloat Smin( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n    \nfloat Smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat Sphere(vec3 p,float s){\n    return length(p)-s;\n    }\n\nfloat Torus( vec3 p, vec2 t){\n  vec2 q = vec2(length(p.zx)-t.x,p.y);\n  return length(q)-t.y;\n    }\n\n// above by https://iquilezles.org/\n//===================================================================//\n\nvec3 CastRay(vec2 uv, vec3 p, vec3 a, float z) {\n    vec3 \n        f = normalize(a-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u;\n    return normalize(i);\n}", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4XBSRK.jpg", "time_retrieved": "2024-04-28T18:59:57.903165", "access": "api", "wgpu-test": "error"}
{"id": "4c3GD2", "name": "VoronoiNoiseTest_yl", "author": "yangle", "description": "Noise", "tags": ["noise"], "image_code": "#define T iTime\n\nfloat N21(vec2 p) {\n  return fract(sin(p.x*131.13+p.y*6574.31231)*5641.3212);\n}\n\n\nvec2 randVec(vec2 value)\n{\n  vec2 vec = vec2(dot(value, vec2(127.1, 337.1)), dot(value, vec2(269.5, 183.3)));\n  vec = -1. + 2. * fract(sin(vec) * 43758.5453123);\n  return vec;\n}\n\nvec2 N22(vec2 p){\n    float a = N21(randVec(p));\n    float b = N21(randVec(p));\n    return vec2(a, b);\n}\n\n// cells\nvec2 voronoi(vec2 uv, float angleOffset, float cellDensity)\n{\n  float Out=0.0;\n  float Cells=0.0;\n  // cellDensity å…¶å®žå°±æ˜¯ scale\n  vec2 g = floor(uv * cellDensity);  // æ ¼å­ç¼–å·\n  vec2 f = fract(uv * cellDensity);  // æ ¼å­å‘¨æœŸ\n  float t = 8.0;\n  vec3 res = vec3(8.0, 0.0, 0.0);\n  for (int y = -1; y <= 1; y++)\n  {\n    for (int x = -1; x <= 1; x++)\n    {\n      vec2 lattice = vec2(x, y);\n      vec2 dv = lattice + g;  // å‘¨å›´ 9 ä¸ªæ ¼ç‚¹ç¼–å·\n      \n      vec2 offset = sin(N22(dv)*T) * .5 + .5;  // éšæœºåç§»\n      // vec2 offset = vec2(sin(dv.y * angleOffset), cos(dv.x * angleOffset)) * 0.5 + 0.5; // éšæœºåç§»\n      float d = distance(lattice + offset, f);\n      if (d < res.x)\n      {\n        res = vec3(d, offset.x, offset.y);\n        Out = res.x;\n        Cells = res.y;\n      }\n    }\n  }\n  return vec2(Out, Cells);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    //vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.);\n    \n    vec2 d = voronoi(uv,1.,10.);\n    \n   \n    col = vec3(d.x);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4c3GD2.jpg", "time_retrieved": "2024-04-28T18:59:57.905160", "access": "api", "wgpu-test": "ok"}
{"id": "lct3DS", "name": "Cheap Error Diffusion Dither", "author": "ladberg", "description": "Just playing around with a super cheap error diffusion dither.", "tags": ["dither"], "image_code": "const int SEGMENT_LENGTH = 13;\nconst ivec2 idims = ivec2(320, 180);\nconst vec2 dims = vec2(idims);\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord/iResolution.xy;\n    int globalind = int(uv.x * dims.x) + int(uv.y * dims.y) * idims[0];\n    \n    float error = 0.0;\n    for (int i = globalind / SEGMENT_LENGTH * SEGMENT_LENGTH; i <= globalind; i++) {\n        error -= float(error > 0.5);\n        \n        vec2 pos = vec2(i % idims[0], i / idims[0]);\n        float lightness = length(texture(iChannel0, pos / dims).rgb) / sqrt(3.0);\n        error += pow(lightness, 1.0);\n    }\n    \n    fragColor = vec4(error > 0.5);\n}\n\n", "image_inputs": [{"id": 12, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lct3DS.jpg", "time_retrieved": "2024-04-28T18:59:58.102632", "access": "api", "wgpu-test": "error"}
{"id": "lf33WS", "name": "Fork Ascii Art d_lan 531", "author": "d_lan", "description": "basic bitmap to (mouse clicked ? grayscale : color) ascii (8 characters) art shader;\nI've answered some questions about this shader on my blog in the comments section: https://blog.thrill-project.com/ascii-art-shader/", "tags": ["mouse", "ascii"], "image_code": "// Bitmap to ASCII (not really) fragment shader by movAX13h, September 2013\n// This is the original shader that is now used in PixiJs, FL Studio and various other products.\n\n// Here's a little tool for new characters: thrill-project.com/archiv/coding/bitmap/\n\n// update 2018-12-14: values for characters are integer now (were float)\n//                    since bit operations are available now, making use of them\n//                    instead of int(mod(n/exp2(p.x + 5.0*p.y), 2.0))\n// update 2023-04-21: added characters A-Z and 0-9 and some others\n//                    black/white mode does not use gray value anymore\n\nfloat character(int n, vec2 p)\n{\n\tp = floor(p*vec2(-4.0, 4.0) + 2.5);\n    if (clamp(p.x, 0.0, 4.0) == p.x)\n\t{\n        if (clamp(p.y, 0.0, 4.0) == p.y)\t\n\t\t{\n        \tint a = int(round(p.x) + 5.0 * round(p.y));\n\t\t\tif (((n >> a) & 1) == 1) return 1.0;\n\t\t}\t\n    }\n\treturn 0.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 pix = fragCoord.xy;\n\tvec3 col = texture(iChannel0, floor(pix/8.0)*8.0/iResolution.xy).rgb;\t\n\t\n\tfloat gray = 0.3 * col.r + 0.59 * col.g + 0.11 * col.b;\n\t    \n\tint n =  4096;\n    \n    // limited character set\n    if (gray > 0.2) n = 65600;    // :\n\tif (gray > 0.3) n = 163153;   // *\n\tif (gray > 0.4) n = 15255086; // o \n\tif (gray > 0.5) n = 13121101; // &\n\tif (gray > 0.6) n = 15252014; // 8\n\tif (gray > 0.7) n = 13195790; // @\n\tif (gray > 0.8) n = 11512810; // #\n    \n    // full character set including A-Z and 0-9\n    /*\n    if (gray > 0.0233) n = 4096;\n    if (gray > 0.0465) n = 131200;\n    if (gray > 0.0698) n = 4329476;\n    if (gray > 0.0930) n = 459200;\n    if (gray > 0.1163) n = 4591748;\n    if (gray > 0.1395) n = 12652620;\n    if (gray > 0.1628) n = 14749828;\n    if (gray > 0.1860) n = 18393220;\n    if (gray > 0.2093) n = 15239300;\n    if (gray > 0.2326) n = 17318431;\n    if (gray > 0.2558) n = 32641156;\n    if (gray > 0.2791) n = 18393412;\n    if (gray > 0.3023) n = 18157905;\n    if (gray > 0.3256) n = 17463428;\n    if (gray > 0.3488) n = 14954572;\n    if (gray > 0.3721) n = 13177118;\n    if (gray > 0.3953) n = 6566222;\n    if (gray > 0.4186) n = 16269839;\n    if (gray > 0.4419) n = 18444881;\n    if (gray > 0.4651) n = 18400814;\n    if (gray > 0.4884) n = 33061392;\n    if (gray > 0.5116) n = 15255086;\n    if (gray > 0.5349) n = 32045584;\n    if (gray > 0.5581) n = 18405034;\n    if (gray > 0.5814) n = 15022158;\n    if (gray > 0.6047) n = 15018318;\n    if (gray > 0.6279) n = 16272942;\n    if (gray > 0.6512) n = 18415153;\n    if (gray > 0.6744) n = 32641183;\n    if (gray > 0.6977) n = 32540207;\n    if (gray > 0.7209) n = 18732593;\n    if (gray > 0.7442) n = 18667121;\n    if (gray > 0.7674) n = 16267326;\n    if (gray > 0.7907) n = 32575775;\n    if (gray > 0.8140) n = 15022414;\n    if (gray > 0.8372) n = 15255537;\n    if (gray > 0.8605) n = 32032318;\n    if (gray > 0.8837) n = 32045617;\n    if (gray > 0.9070) n = 33081316;\n    if (gray > 0.9302) n = 32045630;\n    if (gray > 0.9535) n = 33061407;\n    if (gray > 0.9767) n = 11512810;\n\t*/\n    \n\tvec2 p = mod(pix/4.0, 2.0) - vec2(1.0);\n    \n\tif (iMouse.z > 0.5)\tcol = vec3(character(n, p));\n\telse col = col*character(n, p);\n\t\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": 31, "src": "/presets/webcam.png", "ctype": "webcam", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lf33WS.jpg", "time_retrieved": "2024-04-28T18:59:58.105624", "access": "api", "wgpu-test": "incomplete"}
{"id": "4cc3WS", "name": "Shader228", "author": "kashircevpetr", "description": "shader shader", "tags": ["shader"], "image_code": "void c1(in vec2 uv, in vec3 col1, out vec3 col){\n\n    float q;\n\n    float x1 = -0.4 * abs(sin(iTime / 2.3)) + 0.945;\n\n    float y1 = -0.8 * abs(cos(iTime / 2.3)) + 0.9;\n\n    float r = 0.1;\n\n    \n\n    if ((uv.x - x1) * (uv.x - x1) * 3.0 + (uv.y - y1) * (uv.y - y1) <= r * r){\n\n        col = vec3(55.0 * abs(sin(0.02*iTime + (sqrt((uv.x - x1) * (uv.x - x1) * 3.0 + (uv.y - y1) * (uv.y - y1))))), 55.0*abs(sin(0.07*iTime + 53.7 + sqrt((uv.x - x1) * (uv.x - x1) * 3.0 + (uv.y - y1) * (uv.y - y1)))), 255.0*abs(sin(0.03*iTime + 216.52 + sqrt((uv.x - x1) * (uv.x - x1) * 3.0 + (uv.y - y1) * (uv.y - y1)) )));\n\n    } else {col = col1;}\n\n}\n\n\nvoid c2(in vec2 uv, in vec3 col1, out vec3 col){\n    float q;\n    float x1 = 0.1 + 0.78 * abs(sin(iTime));\n    float y1 = 0.2 + 0.6 * abs(sin(iTime));\n    float r = 0.2;\n    \n    if ((uv.x - x1) * (uv.x - x1) * 3.0 + (uv.y - y1) * (uv.y - y1) <= r * r && sin(iTime) >= 0.0 && cos(iTime) >= 0.0){\n        col = vec3(0, 255, 255);\n    } else {col = col1;}\n}\n\n\nvoid c3(in vec2 uv, in vec3 col1, out vec3 col){\n    float q;\n    float x1 = 0.3 - 0.1 * abs(sin(1.7 * iTime));\n    float x2 = 0.5 + 0.1 * abs(sin(1.7 * iTime));\n    float y1 = 0.2 - 0.1 * abs(sin(1.7 * iTime + 0.9));\n    float y2 = 0.7 + 0.1 * abs(sin(1.7 * iTime + 0.9));\n    \n    if (x1 <= uv.x && uv.x <= x2 && y1 <= uv.y && uv.y <= y2){\n        col = vec3(255, 255, 0);\n    } else {col = col1;}\n}\n\n\n\nvoid c4(in vec2 uv, in vec3 col1, out vec3 col){\n\n    float q;\n\n    float x1 = 0.1 + 0.78 * abs(sin(iTime));\n\n    float y1 = 0.2 + 0.6 * abs(sin(iTime));\n\n    float r = 0.2;\n\n    \n\n    if ((uv.x - x1) * (uv.x - x1) * 3.0 + (uv.y - y1) * (uv.y - y1) <= r * r && sin(iTime) <= 0.0 && cos(iTime) <= 0.0){\n\n        col = vec3(0, 255, 255);\n\n    } else {col = col1;}\n\n}\n\n\nvoid c5(in vec2 uv, in vec3 col1, out vec3 col){\n\n    float q;\n\n    float x1 = 0.1 + 0.78 * abs(sin(iTime));\n\n    float y1 = 0.2 + 0.6 * abs(sin(iTime));\n\n    float r = 0.2;\n\n    \n\n    if ((uv.x - x1) * (uv.x - x1) * 3.0 + (uv.y - y1) * (uv.y - y1) <= r * r && sin(iTime) <= 0.0 && cos(iTime) >= 0.0){\n\n        col = vec3(0, 255, 255);\n\n    } else {col = col1;}\n\n}\n\n\nvoid c6(in vec2 uv, in vec3 col1, out vec3 col){\n\n    float q;\n\n    float x1 = 0.1 + 0.78 * abs(sin(iTime));\n\n    float y1 = 0.2 + 0.6 * abs(sin(iTime));\n\n    float r = 0.2;\n\n    \n\n    if ((uv.x - x1) * (uv.x - x1) * 3.0 + (uv.y - y1) * (uv.y - y1) <= r * r && sin(iTime) >= 0.0 && cos(iTime) <= 0.0){\n\n        col = vec3(0, 255, 255);\n\n    } else {col = col1;}\n\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col;\n    col = cos(4.7 * iTime+uv.yyy * uv.yyy + uv.xxx * uv.xxx + vec3(0, 30, 60)) * cos(4.7*iTime+uv.yyy * uv.yyy + uv.xxx * uv.xxx + vec3(0, 30, 60));\n\n    c5(uv, col, col);\n    c6(uv, col, col);\n    c3(uv, col, col);\n    c2(uv, col, col);\n    c4(uv, col, col);\n    c1(uv, col, col);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4cc3WS.jpg", "time_retrieved": "2024-04-28T18:59:58.127566", "access": "api", "wgpu-test": "ok"}
{"id": "4ctGzs", "name": "Psychedelic rainbow rug (music)", "author": "jarble", "description": "An electronic synthesizer with a rug pattern.", "tags": ["fractal", "music", "mosaic", "rug"], "image_code": "vec2 triangle_wave(vec2 a){\n    vec2 a2 =\n        vec2(1.,0.5)\n    ,\n    a1 = a+a2;\n    return abs(fract((a1)*(a2.x+a2.y))-.5);\n}\n\n    float scale = 1.5;\n\n\nvoid transform(inout vec2 uv, inout vec2 t2, inout vec3 col,inout float c1){\n        uv = (uv+t2)/scale;\n        uv = ((vec2(uv+vec2(.5,1.5))*scale)-.5)/scale;\n        \n        t2 = triangle_wave(uv+.5);\n        uv =\n            t2/2.-triangle_wave(uv.yx)\n            //1./2.-triangle_wave(uv.yx)\n        ;\n        \n        {t2.x = (t2.x-1.); }\n        if(uv.x>uv.y)\n        uv.y += 1./4.;\n        //col = col.yzx; //rainbow colors\n}\n\nvec3 fractal(vec2 uv){\n    vec3 col = vec3(0.);\n    vec2 t2 = vec2(0.);\n    float c1=0.;\n    for(int k = 0; k < 12; k++){\n        transform(uv,t2,col,c1);\n        c1 =\n            max(abs(t2.y-t2.x),c1)\n            //max(sign(t2.x-t2.y)/2.,c1)\n        ;\n        c1 =\n            max(1.-abs(c1-1.),0.)\n        ;\n        col.x =\n            //c1\n            abs(c1-col.x)\n        ;\n        col = col.yzx;\n        if(k>6) uv.x += iTime/2.;\n    }\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.0);\n    float t1 = 1.;\n    \n    vec2 uv = (fragCoord)/iResolution.y/t1/2.0;\n    uv.xy += iTime/t1/12.;\n    if(iMouse.z>.5)\n    uv = uv.xy + iMouse.xy / iResolution.xy/t1;\n    vec3 col1 = fractal(uv);\n    fragColor = vec4(col1,1.0);\n    //fragColor = pow(fragColor ,vec4(1./1.8)); //gamma correction\n\n}\n", "image_inputs": [], "sound_code": "//remix of https://www.shadertoy.com/view/MffGzM\nfloat mod1(float a, float b){\n    return\n        mod(a,b)\n        //mod(a+mod(a,b+3.),b)\n    ;\n}\n\nfloat fmod(float a, float b){\n    //the modulus should be a prime number\n    //this makes some interesting rhythms\n    float modulus =\n        //3.\n        5.\n        //7.\n    ;\n    for(float i = 1.; i < mod(floor(a/b),modulus); i++){\n    //for(float i = 1.+mod(floor(a/b),3.); i < mod(floor(a/b),modulus); i++){\n        a += mod1(floor(a/2.),b)*i;\n    }\n    return\n        mod(floor(a),b)\n    ;\n}\n\n#define fract1(a) abs(1.-fract(-a)*fract(-a))\n//#define fract1(a) pow(fract(a),1.+log(2.)-log(1.+fract(a)))\n\nvec2 synth_(vec2 a1,vec2 a,vec2 a2,vec2 a3,vec2 nb,vec2 a4){\n    return log(a1+a*abs(a2-abs(.5-a3*vec2(fract1(nb.x*.998),fract1(nb.y)))*a4));\n}\n#define synth(a1,a,a2,a3,nb,a4) synth_(vec2(a1),vec2(a),vec2(a2),vec2(a3),vec2(nb),vec2(a4))\n\nvec2 sitar5(vec2 a, vec2 nb){\n    return a/16./2.*abs(log(1./2.+.5*a*abs(1./8.-abs(.5-vec2(fract1(nb.x*4.*.998),fract1(nb.y*4.)))/2.))\n      -log(1./2.+a*a/2.*abs(1./4.-abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))) \n    ;\n}\n\nvec2 mainSound1(int samp, float time,float scale,float duration){\n  float tempo = .25;\n  time /= tempo;\n  float s1 =\n      8.;\n  vec3\n  rhythm =\n      vec3(1.)\n      \n      //more rhythms here!\n      //vec3(2.,1./2.,2.)\n      //vec3(2.,2.,1./2.)\n      //vec3(1.,fmod(time/8.,2.)+1.,1.)\n      //vec3(2.)\n      //vec3(1.+mod(floor(time/4.),2.))\n      //vec3(mod(floor(time/32./4.),2.),mod(floor(time/16./4.),2.),mod(floor(time/8./4.),2.))+1.\n      //vec3(2.,2.,1.)\n      //vec3(mod(floor(time/4.),2.)+1.,1.,1.)\n  ;\n  for(float i = 1.; i < mod(floor(time),5.); i++){\n      time += mod(floor(time*2./rhythm.x),s1)*i;\n      time /= 1.+fmod(floor(time/2./rhythm.y)*2.,2.);\n      tempo *= 1.+fmod(floor(time/rhythm.z)*2.,2.);\n  }\n  float s2 = 8.,\n  t=\n      time,\n  m4 = (1.+fmod(t/16.,2.)),\n  m1 =\n      fmod(t/m4,s2)\n  ,\n  m3 =\n      fmod(t,1.+m1)+fmod(t/8.,2.);\n  t /=\n      (1.+fmod(t/s1,2.))*4./s1/s1\n  ;\n  float m2 =\n      1. + fmod(t/s1,s1)\n  ;\n  \n  //duration /= m4;\n  \n  vec2 a=\n      //vec2((1.-sqrt(fract(t/s1)/1.25))*.2)\n      -vec2((log(1./64./4.+fract1(t/s1)/8./duration)))\n      \n      //-vec2((log(1./64./4.+fract1(mod(t/s1,duration*s1))/2.)))\n\n      //pow(1.-log(1./16./2.+fract(t/s1)/4.),2.)\n  ,\n  nb = vec2(time*tempo*pow(2.,floor((m3+m2)/2.)/5.+scale));\n  vec2 \n  sitar = synth(1./8.,a,1./8.,1.,nb*2.,1./2.)\n  ,gamelan = a/16./4.*abs(synth(1./4.,a,1./8.,1.,nb*2.,1./2.)\n  +.5*synth(1./4.,a,1./4.,1.,nb*2.,1./2.)) \n  ,steel_drum = a/16./4.*abs(synth(1./2.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))      \n  ,oud = a/16./2.*abs(log(.5+a*abs(abs(.5-vec2(fract1(nb.x*2.*.998),fract1(nb.y*2.)))/2.))\n      +.5*log(1./8.+a*abs(1./8.-abs(.5-vec2(fract1(nb.x*.998),fract1(nb.y)))/2.)))/2.\n  \n  ,synth_drum = a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,4./m2)\n  + synth(1./8.,a,1./4.,1.,nb*2.,m2/4.))\n  \n  ,harp = a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,2.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1./2.))\n    ,guitar = a/16./4.*abs(\n  synth(1./4.,a,1./8.,1.,nb*4.,1.)\n  + synth(1./8.,a,1./4.,1.,nb*2.,1.))\n  \n  \n  \n  ;\n  return\n      //sitar\n      //oud\n      //synth_drum\n      //harp\n      \n      //steel_drum\n      synth_drum\n      ///abs(gamelan/2.-synth_drum)\n      \n      //abs(gamelan-steel_drum/2.)\n      //abs(gamelan/2.-oud*2.)*2.\n\n      //abs(gamelan-oud*3.)/3.\n      \n      //abs(gamelan-steel_drum/4.)\n      \n      \n      //oud\n      //abs(.5-vec2(fract(nb.x*.998*2.),fract(nb.y)))*a\n      \n      \n      //log(abs(a/4.-2.*abs(.5-vec2(fract(nb*.998*2.),fract(nb*2.)))*a))\n\n      //log(abs(a/8.-abs(.5-vec2(fract(nb*.998*2.),fract(nb)))*a))\n  ;\n}\n\nvec2 mainSound(int samp, float time){\n    return\n        \n        //mainSound1(samp,time,5.5,1./2.)\n        //abs(mainSound1(samp,time,5.5,1./2.)-mainSound1(samp,time,6.5,1./2.)/4.)\n\n        //black metal\n        //abs(mainSound1(samp,time,7.,1./4.)-mainSound1(samp,time,6.5,1./4.))\n        \n        //amazing breakcore remix!\n        abs(mainSound1(samp,time/8.,8.,1.)-mainSound1(samp,time,6.,1./8.))\n        \n        //snare drum\n        //abs(mainSound1(samp,time,6.,1./8.)-mainSound1(samp,time,6.5,1./8.))\n        //weird harp remix\n        //mainSound1(samp,time/2.,7.,1./4.)\n        \n        //another harp remix\n        //abs(mainSound1(samp,time,6.,1./4.)+mainSound1(samp,time,7.,1./2.)/2.+mainSound1(samp,time,8.,1.)/4.)\n\n        \n        //drum remix\n        //abs(mainSound1(samp,time,4.5,1./2.)-mainSound1(samp,time,5.5,1./2.)/2.)\n        \n\n    ;\n}", "sound_inputs": [], "common_code": "", "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/4ctGzs.jpg", "time_retrieved": "2024-04-28T18:59:58.251234", "access": "api", "wgpu-test": "incomplete"}
{"id": "lf33zs", "name": " Jewel", "author": "wyatt", "description": "Ornament", "tags": ["jewel"], "image_code": "void mainImage( out vec4 Q, in vec2 U ) {\n    Q = A(U)/float(iFrame);\n\n}", "image_inputs": [{"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "common_code": "#define R iResolution.xy\n#define A(U) texture(iChannel0,(U)/R)\n#define B(U) texture(iChannel1,(U)/R)\n#define Main void mainImage(out vec4 Q, in vec2 U)\n #define UIF (1.0 / float(0xffffffffU))\nvec4 hash44(uvec4 q)\n{\n\tq *= uvec4(1597334673U, 3812015801U, 2798796415U, 1979697957U);\n\tq = (q.x ^ q.y ^ q.z ^ q.w)*uvec4(1597334673U, 3812015801U, 2798796415U, 1979697957U);\n\treturn vec4(q) * UIF;\n}\n#define pi 3.141592659", "buffer_a_code": "Main\n{\n    U = 2.3*(U-.5*R)/R.y;\n    vec2 U0 = 2.*U;\n    for (float i = 0.; i < 100.; i++) {\n    \n        U = U/dot(U,U);\n        U = abs(U)-.5;\n        \n        U0 = U0/dot(U0,U0);\n        U0 = abs(U0)-.25;\n    }\n    float a = .5+.5*sign(max(U.x,U.y)-.5);\n    float b = .5-.5*sign(max(U0.x,U0.y)-.5);\n    Q = vec4(a+b);\n}", "buffer_a_inputs": [], "buffer_b_code": "Main {\n    \n    vec4 n = A(U+vec2(0,1));\n    vec4 e = A(U+vec2(1,0));\n    vec4 s = A(U-vec2(0,0));\n    vec4 w = A(U-vec2(0,0));\n    Q.xy = A(U).xy;\n    Q.z = e.x-w.x;\n    Q.w = n.x-s.x;\n    \n}", "buffer_b_inputs": [{"id": 257, "src": "/media/previz/buffer00.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "buffer_c_code": "Main {\n    Q = A(U);\n    vec4 h = hash44(uvec4(U,iFrame,iTime));\n    \n    vec2 d = vec2(cos(h.x*2.*pi),sin(h.x*2.*pi));\n    \n    U -= d*h.y;\n    for (float i = 0.; i < 100.; i++) {\n        \n        U += 1.5*d;\n        vec4 b = B(U);\n        d = normalize(d-.6*(h.w)*b.zw);\n        vec4 q = pow(max(dot(vec2(0,1),d),0.),3.)*1.5*b.x*max(sin(6.*h.w-3.+vec4(1,2,3,4)),0.);\n        Q += q/10.;\n    \n    }\n    if (iFrame < 1) Q = vec4(0);\n}", "buffer_c_inputs": [{"id": 258, "src": "/media/previz/buffer01.png", "ctype": "buffer", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}, {"id": 259, "src": "/media/previz/buffer02.png", "ctype": "buffer", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1}], "sound_code": "", "sound_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "license": "cc-by-nc-sa-3.0", "thumbnail": "https://www.shadertoy.com/media/shaders/lf33zs.jpg", "time_retrieved": "2024-04-28T18:59:58.281155", "access": "api", "wgpu-test": "incomplete"}
