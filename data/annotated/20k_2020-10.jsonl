{"id": "3d3BRn", "name": "Distorted Checkerboard", "author": "tombla", "description": "A simple checkerboard distorted by sine.", "tags": ["2d", "checkerboard"], "likes": 12, "viewed": 255, "published": "Public API", "date": "1604098277", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R                       (iResolution.xy)\n#define MR                      min(R.x, R.y)\n#define VERTICAL_CHECKERS       22.\n#define CHECKERS_DIFF           6.5\n// Suggestion from FabriceNeyret2:\n#define CHECKER_BORDER\t        (1.7 * VERTICAL_CHECKERS / MR)\n#define S(B, v)                 smoothstep(B, 0., min(v.x, v.y))\n#define BORDER_COLOR            vec3(0.1, 0.1, 0.1)\n\n#define ANGULAR_SPEED 0.2\n#define ANGULAR_ADD   0.5\n\n//  Function from Iñigo Quiles\n//  https://www.shadertoy.com/view/MsS3Wc\nvec3 hsb2rgb(in vec3 c) {\n    vec3 rgb = clamp(abs(mod(c.x * 6.0 + vec3(0.0,4.0,2.0),\n                             6.0) -3.0 ) -1.0,\n                     0.0,\n                     1.0 );\n    rgb = rgb * rgb * (3.0 - 2.0 * rgb);\n    return c.z * mix(vec3(1.0), rgb, c.y);\n}\n\nmat2 rot(in float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec4 toCheckers(in vec2 p) {\n    // Distort\n    p += 0.05 * sin(p *12.);\n    // Tiles\n    p *= VERTICAL_CHECKERS + CHECKERS_DIFF * sin(iTime);\n    p *= rot(iTime * ANGULAR_SPEED + sin(iTime * ANGULAR_ADD));\n    \n    return vec4(\n        fract(p.x),\n        fract(p.y),\n        floor(p.x),\n        floor(p.y));\n}\n\nvoid mainImage(out vec4 O, in vec2 u) {\n    // Normalize to -0.5 ... 0.5 on the shorter axis.\n    u = (u - 0.5 * R) / MR;\n    vec4 c = toCheckers(u);\n    \n    // Simplification of:\n    //   float lb = smoothstep(CHECKER_BORDER, 0.0, min(c.x, c.y));\n    //   float ur = smoothstep(1.0 - CHECKER_BORDER, 1.0, max(c.x, c.y));\n    //   float borderFactor = max(lb, ur);\n    // Suggestion from FabriceNeyret2:\n    float borderFactor = S(CHECKER_BORDER, min(c.xy, 1. - c.xy));\n    // light or dark?\n    float isLight = mod(c.z + c.w, 2.);\n    // Inner color\n    vec3 innerColor = hsb2rgb(vec3(\n        mod((c.z + c.w + iTime * 4.)/22., 3.),\n        smoothstep(-1.6, 1., sin((c.z + c.w) / 12.1 + iTime * 1.3)),\n        .7 + 0.3 * sin(c.z - c.w + iTime * 3.7)));\n    \n    O = vec4(\n        mix(innerColor, BORDER_COLOR, borderFactor),\n        1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3BRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[435, 509, 534, 534, 781], [783, 783, 805, 805, 881], [883, 883, 911, 926, 1194], [1196, 1196, 1235, 1289, 2038]]}
{"id": "3d3cDs", "name": "dust01", "author": "Del", "description": "just some more noise", "tags": ["noise", "volumetric", "dust"], "likes": 7, "viewed": 210, "published": "Public API", "date": "1601949232", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// volume noise test\n\nvec3 erot(vec3 p, vec3 ax, float ro)\n{\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat WaveletNoise(vec3 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<3.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5);\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\n#define brightness -7.7\n#define saturation 0.9\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*0.8,2.);\n\tfloat time=iTime*0.04;\n\n\t//rotation\n    vec2  mm = iMouse.xy/iResolution.xy;\n\tfloat a1=0.5+(mm.x*0.5);\n\tfloat a2=0.8+(mm.y*0.5);\n    \n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,.75);\n\tfrom+=vec3(time*1.8,time,-5.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t// volumetric\n\tfloat s=0.1;\n    float fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<50; r++)\n    {\n\t\tvec3 p=from+s*dir*.5;\n\t\tvec3 p2 = p*4.0;\n\t\tfloat a = WaveletNoise(p2, 0.0, 1.9)*2.0 - 1.0;\n\t\ta *= a * a;\n\t\tv += vec3(s, s*s, s*s*s*s)* a * brightness * fade;\n\t\tfade *= 0.925;\n\t\ts += 0.032;\n\t}\n\tv=mix(vec3(length(v)),v,saturation);\n\tfragColor = vec4(v.gbr*.01,1.);\t\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3cDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 22, 60, 60, 122], [124, 124, 170, 215, 728], [778, 778, 835, 835, 1668]]}
{"id": "3dccDl", "name": "Fab8 #inktober2020 \"teeth\"", "author": "FabriceNeyret2", "description": "WIP\n[url]https://inktober.com/[/url]\n#inktober2020 themes: \n[img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 5, "viewed": 209, "published": "Public API", "date": "1601939880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define A(v)      clamp( r - R.y/32. * abs(v) , 0., 1. )                  //\n#define L(x,y)    ( a=b, b = vec2(x,y),                                    \\\n                    A( length( U-a - (b-a) * clamp(dot(U-a, b-a) / dot(b-a, b-a), 0., 1.) )) ) //\nvoid mainImage(out vec4 O,vec2 u) {                                 \n    vec2  R = iResolution.xy, a, B = vec2(.1,2), b,                       \n          V = ( u+u - R )  / R.y, U;\n    float T = mod(.3*iTime+2.,3.),\n          z = exp2(-T), r, l, i = 0., c = 0.,\n          t =  atan( 8. * sin(18.85*T) ) / 1.3 - .5;  // sin with faster change\n    V.x = abs(V.x);\n    for (; ++i<4.;  ) {                               // shape zoomed copies\n        U = V *= z*8.; z=1.;                          // scaling\n        c = 0.; U.y += t;                             // t: mouth animation\n        r = 1.5; b=B; c += L(1,-1)+L(2,2) + L(3,-.2)+L(3.9,1.6) + L(4.7,-.4)+L(5.5,.8) + L(6.2,-2)+L(6.8,.3);\n        r = .75; b=B; c += L(1, 4)+L(2,2) + L(3,3.5)+L(3.9,1.6) + L(4.7,2.5)+L(5.5,.8) + L(6.2, 2)+L(6.8,.3);\n        U.y = -U.y; U.y += t+t;          // above: top teeth below: bottom teeth\n        r = 1.5; b=B; c += L(.3,0)+L(1,2.2)+ L(2,-.4)+L(2.9,1.6) + L(3.9,-.2)+L(4.7,1.4) + L(5.5,.1)+L(5.8,1.2);\n        r = .75; b=B; c += L(.5,3)+L(1,2.2)+ L(2,  3)+L(2.9,1.6) + L(3.9,2.5)+L(4.7,1.4) + L(5.4, 2)+L(5.8,1.2);\n        l = i - T/3. -1.3; O += exp(-3.*l*l) * min(1.,c); // intensity fading small and large scale\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dccDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 252, 287, 287, 1466]]}
{"id": "3dcyDj", "name": "LeafyWibble", "author": "Del", "description": "A Green Leafy thing :)", "tags": ["sin", "rot"], "likes": 10, "viewed": 220, "published": "Public API", "date": "1601684465", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A Green Leafy thing :)\n\nfloat wave(vec2 p)\n{\n  float v = sin(p.x + sin(p.y) + sin(p.y * .43));\n  return v*v;\n}\n \nfloat get(vec2 p,float t)\n{\n  mat2 rot = mat2(0.5, 0.86, -0.86, 0.5);\n  float v = wave(p);\n  p.y += t;\n  p *= rot;\n  v += wave(p.yx);\n  p.y += t * .17;\n  p *= rot;\n  v += wave(p.xy);\n  v = abs(1.5 - v);\n  v+=pow(abs(sin(p.x+v)),18.0);\n  return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (iResolution.xy - 2.0*fragCoord.xy)/iResolution.y;\n    float t = iTime;\n\tfloat scale =14.0;\n\tfloat speed = .3;\n\tuv.y += sin(fract(t*0.1+uv.x)*6.28)*0.05;\t// wibble\n\tuv.xy += t*0.08;\t\t\t\t\t// scroll\n\tvec2 p = uv*scale;\n\t//p.y+= 1.0/p.y*p.y;\n  \tfloat v = get(p,t*speed);\n  \tv = smoothstep(-3.5,3.5,v);\n\tvec3 col = vec3(.29, 0.86, 0.4);\n    fragColor = vec4(col*v*v, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcyDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 27, 47, 47, 113], [116, 116, 143, 143, 364], [366, 366, 423, 423, 808]]}
{"id": "3ddcD2", "name": "🌟 🌬️ Cosmic Heaven 🌫️ 🌌", "author": "rmmcal", "description": "Whispering sighs from the cosmic heaven...  ", "tags": ["heaven"], "likes": 5, "viewed": 93, "published": "Public", "date": "1601805363", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/////////////////////////////////////////////////////////////\n////       ...  🌟 🌬️ Cosmic Heaven 🌫️ 🌌 ...             ////\n/////////////////////////////////////////////////////////////\n// Brasil/Amazonas/Manaus\n// Created by Rodrigo Cal (twitter: @rmmcal)🧙🧞\n// - Started: 2020/10 - Published: 2020/10\n// - https://www.shadertoy.com/view/Ws3yzS\n/////////////////////////////////////////////////////////////\n// -----------------------------------------------------------\n//\n//  🌟 🌬️ Cosmic Heaven 🌫️ 🌌\n//  \n//\tPass: Cosmo \n//  \n//      ... @rmmcal 2020/10 \n//  \n// -----------------------------------------------------------\n/////////////////////////////////////////////////////////////\n//\n\nfloat dist(vec3 p){\n    p *= 1.;\n    float g =  abs(sin(p.x)*cos(p.y)+sin(p.y)*cos(p.z)+sin(p.z)*cos(p.x))-cos(p.z*2.-fract(iTime)*3.1415926*2.)/120.;\n\tfloat d =  1.4-g+(p.y)+(-p.z*.1);\n\t\n    vec3 ctv = cos(p*21.+iTime*3.);\n    d += .1*( smoothstep(-1.0,1.5, .5 - abs(ctv.x + ctv.y + ctv.z)) ) ;\n    d = 10.-abs(d);\n    p.y +=7.0;\n\n    float t = abs(fract(iTime*.1)*2.-1.)*2.;\n    t*=t; t*=t; t*=t;\n    p *= .1;\n\tfloat d2 = 1.6-abs(sin(p.x)*cos(p.y)+sin(p.y)*cos(p.z)+sin(p.z)*cos(p.x))-cos(p.z*2.-fract(iTime)*3.1415926*2.)/120.;\n    \n    d = max(d,mix(d,d2,sin(iTime*.1)));\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = (iTime);\n    vec2 aspectRatio = vec2(1., iResolution.y/iResolution.x);\n\tvec2 uv = fragCoord/iResolution.xy; \n    vec2 p = (uv-.5)*aspectRatio;\n\n    vec3 cpos = vec3(0.0,0.0,-20.0);\n    vec3 cdir = vec3(0.0,0.0,  0.0);\n    \n    cpos += vec3(t/3.,0.0,(cos(t*.04)*81.)) * clamp(pow(t*.2,8.),0.,1.);\n    vec3 bpos = cpos;\n    vec3 ray = vec3(sin(p.xy)*(1.+sin(t*.1)*clamp((t-30.)*0.1, 0., 1.)),.5);\n   \n    vec3 g,b;\n    for (int i = 0; i < 250; i++) {\n        float d = dist(cpos);\n        if (d > .01)   b += vec3(0.,1.,0.)/(d*1000.);\n\t\td = max(d,.01);\n        cpos += ray*d;\n        if (d < 0.01) break;\n        if (d > 128.) break;\n        g += vec3(.5,0.4,1.)*(min(1./1., d)/25.)/ max(0.4, (cpos.z-bpos.z-20.)*.2);\n    }\n\n    vec3 col = g;\n    col += b*smoothstep(-80.,40., -cpos.z)*.2;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "lljGWK", "previewfilepath": "https://soundcloud.com/kontejyan/loreena-mckennitt-mistic-dream", "channel": 3, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/kontejyan/loreena-mckennitt-mistic-dream", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddcD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 727, 746, 746, 1318], [1320, 1320, 1377, 1377, 2212]]}
{"id": "3ddcDl", "name": "anisotropic multiplicative noise", "author": "FabriceNeyret2", "description": "mouse control or auto-rotate.\nRed: multiplicative cascaded noise.   Blue: additive cascaded noise.\nfront/back: filaments vs plates\n\nAbout multiplicative noise: [url]/view/Xs23D3[/url]  , [url]/view/XssBWj[/url] , [url]/view/Ms2GDc[/url]", "tags": ["procedural", "3d", "raymarching", "displacement", "antialiasing", "volumetric", "vr", "hairs", "preintegration"], "likes": 21, "viewed": 631, "published": "Public API", "date": "1602002085", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Preintegrated transfer function from https://shadertoy.com/view/tsdcRj\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define hash(p)  fract(sin(dot(p, vec3(12.9898, 78.233, 311.7))) * 43758.5453) // https://www.shadertoy.com/view/llySRh\n#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n\n//#define T(d)   texture(iChannel0, (i+d+.5)/32. ).x     // noise texture\n  #define T(d)   hash(i+d)                               // value noise\n//#define T(d) ( .5+ .7*dot( d-F ,  2.*hash3(i+d)-1. ) ) // gradient noise (Perlin noise)\n\nfloat noise(vec3 x) {  // By default, simple 3D value noise with cubic interpolation\n    vec3 i = floor(x), // Switch to gradient noise above if you wish, but little differences\n         F = fract(x), e = vec3(1,0,0),\n         f = smoothstep(0.,1.,F );\n    vec4 T = mix ( vec4(T(e.zzz),T(e.zxz), T(e.zzx), T(e.zxx) ),\n                   vec4(T(e.xzz),T(e.xxz), T(e.xzx), T(e.xxx) ),\n                   f.x );\n    vec2 v = mix( T.xz, T.yw, f.y);\n    return mix(v.x,v.y,f.z);\n        }\n\nfloat add_noise(vec3 x) {\n    float n = noise(x)/2.;  x *= 2.1; // return n*2.;\n         n += noise(x)/4.;  x *= 1.9;\n         n += noise(x)/8.;  x *= 2.3;\n         n += noise(x)/16.; x *= 1.9;\n         n += noise(x)/32.;\n    return n; \n}\n\nfloat mul_noise(vec3 x) {\n    float n = 2.*noise(x);  x *= 2.1; // return n/2.;\n         n *= 2.*noise(x);  x *= 1.9;\n         n *= 2.*noise(x);  x *= 2.3;\n         n *= 2.*noise(x);  x *= 1.9;\n         n *= 2.*noise(x);\n    return n/2.; \n}\n\nfloat z;\nfloat map(vec3 p )  // bounding sphere (0,0,0), 2.\n{\n    vec3 q = p*2.+ .6*iTime;\n    q /= p.z < 0. ? vec3(1,1,4) :  vec3(4,4,1);\n//  float f =  1.2*add_noise(q) -.2 ;// source noise\n//  float f =  add_noise(q);\n//  float f =  mul_noise(q);\n    float f =  p.x < 0. ? add_noise(q) : mul_noise(q);\n    f *= smoothstep(1.,.8,length(p)/2.);   // source sphere\n\n    f*= smoothstep(.1,.2,abs(p.x));               // empty slice (derivable ) \n    z = length(p)/2.;                             // depth in sphere\n    return f;                        \n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n\n  #define sl  200.                               // transition slope transp/opaque\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n  #define C(d)    clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return intLUT(_d,d);\n/*  return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n*/\n}\n\nfloat intersect_sphere( vec3 O, vec3 D, vec3 C, float r )\n{\n\tfloat b = dot( O-=C, D ),\n\t      h = b*b - dot( O, O ) + r*r;\n\treturn h < 0. ? -1.             // no intersection\n\t              : -b - sqrt(h);\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat dt = .01,\n         den = 0., _den, lut,\n           t = intersect_sphere( ro, rd, vec3(0), 2.);\n    if ( t == -1. ) return vec4(0); // the ray misses the object \n    t += 1e-5;                      // start on bounding sphere\n    \n    for(int i=0; i<500; i++) {\n        vec3 pos = ro + t*rd;\n        if(   sum.a > .99               // end if opaque or...\n           || length(pos) > 2. ) break; // ... exit bounding sphere\n                                    // --- compute deltaInt-density\n        _den = den; den = map(pos); // raw density\n        float _z = z;               // depth in object\n        lut = LUTs( _den, den );    // shaped through transfer function\n        if( lut > .0                // optim\n          ) {                       // --- compute shading                  \n#if 0                               // finite differences\n            vec2 e = vec2(.3,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) );\n         // see also: centered tetrahedron difference: https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n            float dif = clamp( -dot(n, sundir), 0., 1.);\n#else                               // directional difference https://www.iquilezles.org/www/articles/derivative/derivative.htm\n         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n#endif\n/*\n            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n                  col = vec3(.2 + dif);\n            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n*/            \n            vec3 S = pos.x < 0. ? vec3(3,3,2) : vec3(2,3,3);\n            vec3 col = exp(-S *(1.-z));                   // dark with shadow\n         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));     // dark with depth\n                   //      *  exp(- 1.5 *(1.-z));\n            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;\n        }\n        t += dt;  // stepping\n    }\n\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = max( dot(sundir,rd), 0. );\n\tvec3 col = // vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t           //  + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            +  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * pow( sun,3.);\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = iMouse.z>0. ? 2.* ( 1.- iMouse.xy / R )\n                         : 1.+cos(.3*iTime+vec2(0,11));\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), m.y, cos(3.*m.x))),\n\t     ta = vec3(0, 0, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n // if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1); // red separator\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": "XdX3Rr", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddcDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[832, 923, 944, 1007, 1406], [1408, 1408, 1433, 1433, 1646], [1648, 1648, 1673, 1673, 1888], [1899, 1899, 1951, 1951, 2443], [2761, 3019, 3052, 3111, 3308], [3310, 3310, 3369, 3369, 3517], [3519, 3519, 3576, 3576, 5929], [5931, 5931, 5977, 5977, 6139], [6141, 6141, 6184, 6208, 6660], [6662, 6662, 6700, 6700, 7251]]}
{"id": "3ddcDs", "name": "catmull rom test", "author": "NateS", "description": "Make sure the catmullRom function is right.\n\nBased on https://www.shadertoy.com/view/Mt2GWd just with a different catmullRom function.", "tags": ["catmullrom"], "likes": 4, "viewed": 117, "published": "Public", "date": "1602013327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by Nikos Papadopoulos, 4rknova / 2015\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define ANIMATED\n#define SHOW_CONTROL_POINTS\n#define SHOW_SEGMENT_POINTS\n#define MOUSE_ENABLED \n//#define AA 1.\n\n#define STEPS  15.\n#define STROKE .8\n\n#define EPS    .01\n\n#define BG   vec3(0.0745, 0.0862, 0.1058)\n#define COL0 vec3(.2, .35, .55)\n#define COL1 vec3(.9, .43, .34)\n#define COL3 vec3(1.)\n\nvec2 catmullRom (vec2 A, vec2 B, vec2 C, vec2 D, float t) {\n\tvec2 a = (A - (B - C) * 3.0 - D) * -0.5;\n\tvec2 b = A - B * 2.5 + C * 2.0 - D * 0.5;\n\tvec2 c = (C - A) * 0.5;\n\treturn t * (t * (a * t + b) + c) + B;\n}\n\nfloat df_circ(in vec2 p, in vec2 c, in float r) {\n    return abs(r - length(p - c));\n}\n\nfloat df_line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa,ba) / dot(ba,ba), 0., 1.);\t\n\treturn length(pa - ba * h);\n}\n\nfloat sharpen(in float d, in float w) {\n    float e = 1. / min(iResolution.y , iResolution.x);\n    return 1. - smoothstep(-e, e, d - w);\n}\n\nfloat ip_control(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d) {    \n    float cp = 0.;\n    \n#ifdef SHOW_CONTROL_POINTS    \n    float c0 = sharpen(df_circ(uv, a, .02), EPS * .75);\n    float c1 = sharpen(df_circ(uv, b, .02), EPS * .75);\n    float c2 = sharpen(df_circ(uv, c, .02), EPS * .75);\n    float c3 = sharpen(df_circ(uv, d, .02), EPS * .75);\n\n    float l0 = sharpen(df_line(uv, a, b), EPS * .6);\n    float l1 = sharpen(df_line(uv, b, c), EPS * .6);\n    float l2 = sharpen(df_line(uv, c, d), EPS * .6);\n\n    cp = max(max(max(c0, c1),max(c2, c3)),\n\t         max(max(l0, l1),l2));\n#endif\n\n    return cp;\n}\n\nfloat ip_point(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d) {\n    vec2 p = catmullRom(a, b, c, d, mod(iTime * 2., 10.) / 10.);\n    return sharpen(df_circ(uv, p, .025), EPS * 1.);\n}\n\nfloat ip_curve(vec2 uv, vec2 a, vec2 b, vec2 c, vec2 d) { \n    float e = 0.;\n    for (float i = 0.; i < STEPS; ++i) {\n        vec2  p0 = catmullRom(a, b, c, d, (i   ) / STEPS);\n        vec2  p1 = catmullRom(a, b, c, d, (i+1.) / STEPS);\n#ifdef SHOW_SEGMENT_POINTS        \n        float m = sharpen(df_circ(uv, p0, .01), EPS * .5);\n        float n = sharpen(df_circ(uv, p1, .01), EPS * .5);\n        e = max(e, max(m, n));\n#endif\n        float l = sharpen(df_line(uv, p0, p1), EPS * STROKE);\n        e = max(e, l);\n    }\n    return e;\n}\n\nvec3 scene(in vec2 uv, in vec2 a, in vec2 b, in vec2 c, in vec2 d) {\n    float d0 = ip_control(uv, a, b, c, d);\n    float point = 0.;\n    \n#ifdef ANIMATED\n    point = ip_point(uv, a, b, c, d);\n#endif\n    \n    float d1 = ip_curve(uv, a, b, c, d);    \n    float rs = max(d0, d1);\n    \n    return (point < .5)\n        ? rs * (d0 > d1 ? COL0 : COL1)\n        : point * COL3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 col = BG;\n    \n    vec2 a = vec2(-.75,-.8);\n    vec2 b = vec2(-.50, .0);\n    vec2 c = vec2( .50, .0);\n    vec2 d = vec2( .75, .8);\n        \n#ifdef MOUSE_ENABLED        \n    a = (iMouse.xy / iResolution.xy * 2. - 1.)\n           * vec2(iResolution.x / iResolution.y, 1.);\n#endif\n    \n#ifdef AA\n    // Antialiasing via supersampling\n    float e = 1. / min(iResolution.y , iResolution.x);    \n    for (float i = -AA; i < AA; ++i) {\n        for (float j = -AA; j < AA; ++j) {\n    \t\tcol += scene(uv + vec2(i, j) * (e/AA), a, b, c, d) / (4.*AA*AA);\n        }\n    }\n#else\n    col += scene(uv, a, b, c, d);\n#endif /* AA */\n    \n\tfragColor = vec4(col, 1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddcDs.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 421, 480, 480, 631], [633, 633, 682, 682, 719], [721, 721, 769, 769, 885], [887, 887, 926, 926, 1025], [1027, 1027, 1086, 1086, 1630], [1632, 1632, 1689, 1689, 1808], [1810, 1810, 1867, 1867, 2343], [2345, 2345, 2413, 2413, 2716], [2718, 2718, 2775, 2775, 3529]]}
{"id": "3ddyDS", "name": "3D inversion", "author": "FabriceNeyret2", "description": "3D inversion of a regular grid of cubes.\nmouse control or auto-rotate.", "tags": ["procedural", "3d", "raymarching", "displacement", "antialiasing", "volumetric", "vr", "hairs", "preintegration"], "likes": 21, "viewed": 288, "published": "Public API", "date": "1601639953", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/tsdcRj\n\n// - Introduce transfer function ( i.e. LUT(dens) ) to shape the look (much like doctors do for scan data)\n// - Rely on preintegrated density on segment.\n//     inspired by preintegrated segment rendering ( see http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.10.3079&rep=rep1&type=pdf )\n//     NB: they store a small texture(_dens,dens), but here I do it analytically.\n\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n             \nfloat z, BR = 2.5;   // bounding sphere (0,0,0), 2.\nfloat map(vec3 p )\n{\n    vec3 q = 2. * p / dot(p,p);\n    z = length(q)/2.;                             // depth in sphere\n    q = abs( fract(q+.5)-.5 );\n    float f = max( q.x, max(q.y,q.z));\n    f = smoothstep(.3,.29,f);\n    return f;                        \n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n  #define sl  5.                               // transition slope transp/opaque\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n  #define C(d)    clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return intLUT(_d,d);\n/*  return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n*/\n}\n\nfloat intersect_sphere( vec3 O, vec3 D, vec3 C, float r )\n{\n\tfloat b = dot( O-=C, D ),\n\t      h = b*b - dot( O, O ) + r*r;\n\treturn h < 0. ? -1.             // no intersection\n\t              : -b - sqrt(h);\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat dt = .01,\n         den = 0., _den, lut,\n           t = intersect_sphere( ro, rd, vec3(0), BR );\n    if ( t == -1. ) return vec4(0); // the ray misses the object \n    t += 1e-5;                      // start on bounding sphere\n    \n    for(int i=0; i<500; i++) {\n        vec3 pos = ro + t*rd;\n        if(   sum.a > .99               // end if opaque or...\n           || length(pos) > BR ) break; // ... exit bounding sphere\n                                    // --- compute deltaInt-density\n        _den = den; den = map(pos); // raw density\n        float _z = z;               // depth in object\n        lut = LUTs( _den, den );    // shaped through transfer function\n        if( lut > .0                // optim\n          ) {                       // --- compute shading                  \n#if 0                               // finite differences\n            vec2 e = vec2(.3,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) );\n         // see also: centered tetrahedron difference: https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n            float dif = clamp( -dot(n, sundir), 0., 1.);\n#else                               // directional difference https://www.iquilezles.org/www/articles/derivative/derivative.htm\n         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n#endif\n/*\n            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n                  col = vec3(.2 + dif);\n            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n*/            \n            vec3 col = exp(- .4*vec3(3,3,2) *(1.-z));      // dark with shadow\n         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));      // dark with depth\n                   //      *  exp(- 1.5 *(1.-z));\n         // vec3 col = vec3(1);\n            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*5.); // --- blend. Original was improperly just den*.4;\n        }\n        t += dt;  // stepping\n    }\n\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = abs( dot(sundir,rd) );\n\tvec3 col = // vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t           //  + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            +  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * ( .2 + pow( sun,3.) );\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = iMouse.z>0. ? 2.* iMouse.xy / R.xy\n                         : 1.+cos(.3*iTime+vec2(0,11));\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, 0, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n // if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1); // red separator\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": "XdX3Rr", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddyDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[525, 556, 576, 576, 817], [1070, 1328, 1361, 1420, 1617], [1619, 1619, 1678, 1678, 1826], [1828, 1828, 1885, 1885, 4212], [4214, 4214, 4260, 4260, 4422], [4424, 4424, 4467, 4491, 4948], [4950, 4950, 4988, 4988, 5537]]}
{"id": "3ddyRl", "name": "Simple bytecode interpreter", "author": "castano", "description": "One shader to rule them all.", "tags": ["interpreter", "bytecode"], "likes": 10, "viewed": 317, "published": "Public", "date": "1601511728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A simple bytecode interpreter.\n\n// Registers:\n// 0-15 = user registers?\n// 16   = time\n// 17  = fragCoord\n// 18  = iResolution\n// ...\n// 32+ = constants\n#define R(reg) (reg)\n#define C(idx) (32+idx)\n\n// Instructions:\nconst int MOV = 0;\nconst int ADD = 1;\nconst int SUB = 2;\nconst int MUL = 3;\nconst int DIV = 4;\nconst int SIN = 5;\nconst int COS = 6;\nconst int SQR = 7;\nconst int RSQ = 8;\nconst int PCK = 9; // 0.5 * x + 0.5\n\n\n#if 0\n\n// Default shader.\nconst int instructions[] = int[](\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    R(0), DIV, R(17), R(19),\n    R(1), DIV, R(18), R(20),\n    \n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    R(0), ADD, R(0), R(16),\n    R(1), ADD, R(1), R(16),\n    R(1), ADD, R(1), C(2),\n    R(2), ADD, R(0), C(4),\n\n    R(0), COS, R(0), 0,\n    R(1), COS, R(1), 0,\n    R(2), COS, R(2), 0,\n\n    R(0), PCK, R(0), C(3),\n    R(1), PCK, R(1), C(3),\n    R(2), PCK, R(2), C(3),\n\n    R(3), MOV, C(1), 0\t   \t// A = 1\n);\n\nconst float constants[] = float[](0.0f, 1.0f, 2.0f, 0.5f, 4.0f);\n\n#else\n\n// Old school plasma.\nconst int instructions[] = int[](\n    \n    R(16), MUL, R(16), C(4),\t// float time = iTime * 0.5;\n    \n    R(3), SIN, R(16), 0,\t\t// float s = sin(time);\n    R(4), COS, R(16), 0,\t\t// float c = cos(time);\n    \n    R(5), MUL, R(17), R(3),\t\t// float x1 = 0.5 + 0.5 * sin(dot(fragCoord.xy, vec2(s,c)) * 0.02 + time);\n    R(6), MUL, R(18), R(4),\n    R(5), ADD, R(5), R(6),\n    R(5), MUL, R(5), C(5),\n    R(5), ADD, R(5), R(16),\n    R(5), COS, R(5), 0,\n    R(5), PCK, R(5), 0,\n    \n    // vec2 center = 0.5 * iResolution.xy * vec2(1.0-s,1.0+c);\n    R(6), SUB, C(1), R(3),\n    R(7), ADD, C(1), R(4),\n    R(6), MUL, R(19), R(6),\n    R(7), MUL, R(20), R(7),\n    R(6), MUL, R(6), C(4),\n    R(7), MUL, R(7), C(4),\n    \n    // float x2 = 0.5 + 0.5 * cos(length(fragCoord.xy - center) * 0.03);\n\tR(6), SUB, R(17), R(6),\n    R(7), SUB, R(18), R(7),\n    R(6), MUL, R(6), R(6),\n    R(7), MUL, R(7), R(7),\n    R(6), ADD, R(6), R(7),\n    R(6), SQR, R(6), 0,\n    R(6), MUL, R(6), C(6),\n    R(6), COS, R(6), 0,\n    R(6), PCK, R(6), 0,\n    \n    // float x = PI * (x1 + x2) + time;\n    R(5), ADD, R(5), R(6),\n    R(5), MUL, R(5), C(3),\n    R(5), ADD, R(5), R(16),\n\n    R(0), COS, R(5), 0,\t// float r = 0.5 + 0.5 * cos(x);\n    R(0), PCK, R(0), 0,\t\n    R(1), SIN, R(5), 0, // float g = 0.5 + 0.5 * sin(x);\n    R(1), PCK, R(1), 0,\n    R(2), PCK, R(3), 0, // float b = 0.5 + 0.5 * s;\n    \n    R(3), MOV, C(1), 0\t   \t// A = 1\n);\n\nconst float constants[] = float[](0.0f, 1.0f, 2.0f, 3.14159265, 0.5f, 0.02f, 0.03f);\n\n#endif\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Init registers.\n    float reg[32];\n    \n    // Load these into registers. Ideally iTime, iResolution would be constants.\n    reg[16] = iTime;\n    reg[17] = fragCoord.x;\n    reg[18] = fragCoord.y;\n    reg[19] = iResolution.x;\n    reg[20] = iResolution.y;\n\n    // Execute instructions.\n    for (int i = 0; i < instructions.length(); i += 4) {\n        int dst = instructions[i+0];\n        int inst = instructions[i+1];\n        int src0 = instructions[i+2];\n        int src1 = instructions[i+3];\n        \n        float a = (src0 < 32) ? reg[src0] : constants[src0-32];\n        float b = (src1 < 32) ? reg[src1] : constants[src1-32];\n        \n        if (inst == MOV) \t\treg[dst] = a;\n        else if (inst == ADD)   reg[dst] = a + b;\n        else if (inst == SUB)   reg[dst] = a - b;\n        else if (inst == MUL)   reg[dst] = a * b;\n        else if (inst == DIV)   reg[dst] = a / b;\n        else if (inst == SIN)   reg[dst] = sin(a);\n        else if (inst == COS)   reg[dst] = cos(a);\n        else if (inst == SQR)   reg[dst] = sqrt(a);\n        else if (inst == RSQ)   reg[dst] = 1.0/sqrt(a);\n        else if (inst == PCK)   reg[dst] = a * 0.5 + 0.5;\n    }\n\n    // Output to screen.\n    fragColor = vec4(reg[0], reg[1], reg[2], reg[3]);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddyRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[409, 2630, 2687, 2710, 3929]]}
{"id": "3ddyWj", "name": "OrangeAction", "author": "Del", "description": "Orange Action! - Hold Mouse Button for something else...", "tags": ["orange", "mirror", "pattern"], "likes": 2, "viewed": 162, "published": "Public API", "date": "1601753753", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Orange Action - Del 03/10/2020\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (iResolution.xy - 2.0*fragCoord.xy)/iResolution.y;\n\tfloat t = iTime+2.0;\n    vec3 color1 = vec3( 1.0, 0.7, 0.3 );\n\tvec3 color2 = vec3( 0.5, 0.35, 0.1 );\n\tuv.x *= 2.0+sin(t*0.4);\n    if (iMouse.z<0.5)\n    \tuv.x = dot(uv,uv)*0.05;\n\tfloat c = floor((uv.x + 0.25)/0.5);\n\tuv.x = mod(uv.x + 0.25,0.5) - 0.25;\n\tuv.x *= -(mod(c, 2.0)*2. - 1.);\n\tfloat v1 = sin(fract(t*.05)*6.28);\n    v1 *= sin(uv.y*.5)*10.0;\n\tfloat v2 =sin(fract(t*.027)*6.28) *24.4; \n\tuv.x += sin(fract(uv.x*0.125+t*.6)*6.28+(uv.x*v2+uv.y*5.0)+v1)*1.4;\n\tfloat curve = 0.3;\n   \tvec3 col = mix( color1, color2, smoothstep( 0.5-curve,0.5+curve,uv.x+0.5) );\t\n\tfragColor = vec4(col, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 34, 91, 91, 755]]}
{"id": "3ddyzl", "name": "Twitch.tv/vedepo", "author": "zovox", "description": "Twitch.tv/vedepo", "tags": ["twitchtvvedepo"], "likes": 5, "viewed": 218, "published": "Public API", "date": "1601517580", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.14159265359\n#define E 2.7182818284\n#define GR 1.61803398875\n#define EPS .001\n\n#define MAX_DIM (max(iResolution.x,iResolution.y))\n#define DURATION 777.\n#define time ((saw(float(__LINE__)/GR)+1.0)*(saw(iTime/DURATION*2.)*DURATION)/E/PI)\n#define flux(x) (vec3(cos(x),cos(4.0*PI/3.0+x),cos(2.0*PI/3.0+x))*.5+.5)\n\nfloat cross2d( in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\n\nfloat saw(float x)\n{\n    float f = mod(floor(abs(x)), 2.0);\n    float m = mod(abs(x), 1.0);\n    return f*(1.0-m)+(1.0-f)*m;\n}\nvec2 saw(vec2 x)\n{\n    return vec2(saw(x.x), saw(x.y));\n}\n\nvec3 saw(vec3 x)\n{\n    return vec3(saw(x.x), saw(x.y), saw(x.z));\n}\nvec2 invBilinear( in vec2 p, in vec2 a, in vec2 b, in vec2 c, in vec2 d )\n{\n    vec2 res = vec2(-1.0);\n\n    vec2 e = b-a;\n    vec2 f = d-a;\n    vec2 g = a-b+c-d;\n    vec2 h = p-a;\n        \n    float k2 = cross2d( g, f );\n    float k1 = cross2d( e, f ) + cross2d( h, g );\n    float k0 = cross2d( h, e );\n    \n    // if edges are parallel, this is a linear equation. Do not this test here though, do\n    // it in the user code\n    if( abs(k2)<0.001 )\n    {\n        float v = -k0/k1;\n        float u  = (h.x*k1+f.x*k0) / (e.x*k1-g.x*k0);\n        //if( v>0.0 && v<1.0 && u>0.0 && u<1.0 ) \n            res = vec2( u, v );\n    }\n\telse\n    {\n        // otherwise, it's a quadratic\n        float w = k1*k1 - 4.0*k0*k2;\n        //if( w<0.0 ) return vec2(-1.0);\n        w = sqrt( w );\n\n        float ik2 = 0.5/k2;\n        float v = (-k1 - w)*ik2;// if( v<0.0 || v>1.0 ) v = (-k1 + w)*ik2;\n        float u = (h.x - f.x*v)/(e.x + g.x*v);\n        //if( u<0.0 || u>1.0 || v<0.0 || v>1.0 ) return vec2(-1.0);\n        res = vec2( u, v );\n    }\n    return (res);\n}\n\n\nmat2 rotate(float x) { return mat2(cos(x), sin(x), sin(x), -cos(x)); }\n\n\nfloat smooth_floor(float x)\n{\n\treturn x;//floor(x)+smoothstep(.75, 1., fract(x));\n}\n\nvec2 tree(vec2 uv)\n{\n    \n    vec2 p = uv*2.-1.;\n    \n\t\n        float angle = smooth_floor((time))*PI/12.;\n\n        vec2 a = vec2(1., 1.);\n        vec2 b = vec2(0., 1.);\n        vec2 c = vec2(0., 0.);\n        vec2 d = vec2(1., 1./MAX_DIM);\n        \n        \n        vec2 s = vec2(.75);\n        vec2 o = vec2(smooth_floor(time/PI)/500., 0.);\n        mat2 m = rotate(angle);\n        \n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n        \n        a = a*m; b = b*m; c = c*m; d = d*m;\n        a *= s; b *= s; c *= s; d *= s;\n        a += o; b += o; c += o; d += o;\n\n        \n        /*\n        //= a*.5+.5; b = b*.5+.5; c = c*.5+.5; d = d*.5+.5;\n\t\ta = a*2.-1.; b = b*2.-1.; c = c*2.-1.; d = d*2.-1.;\n\t\t*/\n\n        vec2 a2 = a*vec2(-1., 1.);\n        vec2 b2 = b*vec2(-1., 1.);\n        vec2 c2 = c*vec2(-1., 1.);\n        vec2 d2 = d*vec2(-1., 1.);\n        if(p.x > 0.)\n        \tp = (invBilinear( p, a, b, c, d ));\n        else\n        \tp = (invBilinear( p, a2, b2, c2, d2 ));\n    return p;\n}\n\nvec2 flower(vec2 p)\n{\n\tp *= rotate(time);\n\tfloat rots = 6.+1./MAX_DIM;\n\tfloat angle = atan(-p.y, -p.x);\n\tfloat radius = length(p);\n\tangle = floor(((angle/PI)*.5+.5)*rots);\n\n\n\tvec2 a = vec2(1., 0.);\n\tvec2 b = vec2(1., 1./MAX_DIM);\n\tvec2 c = vec2(0., 1./MAX_DIM);\n\tvec2 d = vec2(0., -1./MAX_DIM);\n\t\n\tb *= rotate(angle/rots*2.*PI);\n\tangle += 1.;\n\ta *= rotate(angle/rots*2.*PI);\n\t\n\treturn (invBilinear( p, a, b, c, d ));\n}\n\n\nfloat square(vec2 uv, vec2 uv0)\n{\n    uv = (uv*2.-1.)*GR;\n    return abs(saw(uv.y+uv0.x-uv0.y+time)-uv.x);\n}\n\n\nvec2 spiral(vec2 uv)\n{\n    float r = log(length(uv)+1.)/2.;\n    float theta = atan(uv.y, uv.x)/PI-r*sin(time/E/PI/GR)/PI;\n    return vec2(saw(r+time/E/E),\n                saw(theta+time/GR/E))*2.-1.;\n}\n\nvec3 phase(float map)\n{\n    return vec3(sin(map),\n                sin(4.0*PI/3.0+map),\n                sin(2.0*PI/3.0+map))*.5+.5;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 uv0 = uv.xy*2.-1.;\n    uv0.x *= max(iResolution.x/iResolution.y, 1.);\n    uv0.y *= max(iResolution.y/iResolution.x, 1.);\n\tuv0 = uv0*.5+.5;\n    float map = 0.0;\n    \n    float lambda = 4.0;\n\tconst int max_iterations = 12;\n\n    float scale = 3.0*PI+(time*PI*GR*E);\n    uv *= scale;\n    uv -= scale/2.0;\n    uv.x *= max(iResolution.x/iResolution.y, 1.);\n    uv.y *= max(iResolution.y/iResolution.x, 1.);\n    uv.xy += vec2(cos(time*.234),\n                  sin(time*.345))*scale/2.;\n\tfloat m = smoothstep(0.45, .55, saw(time/E/PI));\n    uv.xy = spiral(uv.xy*scale)*m+(1.-m)*(uv0);;\n    \n\tfloat nature = smoothstep(.025, .125, saw(time/GR/E))*(1.-m);\n\tuv =  uv*(1.-nature)+flower(uv0*2.-1.)*nature;\n\t\n    for(int i = 0; i <= max_iterations; i++)\n    {\n    \tfloat iteration = (float(i)/(float(max_iterations) ));\n        uv.xy = saw(tree(uv.xy));\n\t\t\tmap += square(uv.xy, uv0);\n\t\tuv0 = uv;\n    }\n    \n    float w = smoothstep(saw(map/float(max_iterations)+time), .0, .2);\n    float b = smoothstep(saw(map/float(max_iterations)+time), .0, .2);\n    fragColor.rgb = (flux(map))*\n        \t\t\t\n        \t\t\tclamp(map, 0.0, 1.0);\n    fragColor.a = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 323, 362, 362, 390], [392, 392, 412, 412, 517], [518, 518, 536, 536, 575], [577, 577, 595, 595, 644], [645, 645, 720, 720, 1692], [1695, 1695, 1717, 1717, 1765], [1768, 1768, 1797, 1797, 1851], [1853, 1853, 1873, 1873, 2846], [2848, 2848, 2869, 2869, 3266], [3269, 3269, 3302, 3302, 3377], [3380, 3380, 3402, 3402, 3581], [3583, 3583, 3606, 3606, 3715], [3717, 3717, 3774, 3774, 4962]]}
{"id": "3dGcDd", "name": "metaBallsReflexions", "author": "Kaeylos", "description": "#8 particles/circles\nmade during the Ink-MAC-tober 2020", "tags": ["metaballs", "imac"], "likes": 4, "viewed": 76, "published": "Public", "date": "1603987361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ----- Ray marching options ----- //\n#define AA_SAMPLES 1 // antialisaing\n// #define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 50\n#else\n    #define MAX_STEPS 200\n#endif\n#define MAX_DIST 50.\n#define SURF_DIST 0.0001\n#define NORMAL_DELTA 0.0001\n\n#define FBM_MAX_ITER 10\n\n// sub interpolation used in smoothstep\n#define hermiteInter(t) t * t * (3.0 - 2.0 * t)\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\n// ----- Useful functions ----- //\n#define rot2(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(max(v.x , v.y), v.z); }\nfloat cro(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\nfloat map(float t, float a, float b) {return a + t * (b - a); } // considering that t is in [0-1]\nfloat map(float t, float a, float b, float c, float d) { return c + (t - a) * (d - c) / (b - a); }\nfloat mult(vec2 v) { return v.x*v.y; }\nfloat mult(vec3 v) { return v.x*v.y*v.z; }\nfloat sum(vec2 v) { return v.x+v.y; }\nfloat sum(vec3 v) { return v.x+v.y+v.z; }\n#define saturate(v) clamp(v, 0., 1.)\n\n// ----- Noise stuff ----- //\n// Based on Morgan McGuire and David Hoskins\n// https://www.shadertoy.com/view/4dS3Wd\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash1(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nvec3 hash3(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nfloat perlinNoise(float x) {\n    float id = floor(x);\n    float f = fract(x);\n    float u = hermiteInter(f);\n    return mix(hash1(id), hash1(id + 1.0), u);\n}\n\nvec3 perlinNoise3(float x) {\n    float id = floor(x);\n    float f = fract(x);\n    float u = hermiteInter(f);\n    return mix(hash3(id), hash3(id + 1.0), u);\n}\n\nvec3 fbm (float x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tvec3 v = vec3(0.);\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise3(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t}\n\treturn v / aSum;\n}\n\nvec3 vectorWiggle(float x) {\n    return fbm(x, 1., 2);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat polysmin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat sphereSDF(vec3 p, float radius) { return length(p) - radius; }\n\n// source: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n// All components are in the range [0, 1], including hue.\nvec3 rgb2hsv(vec3 c) {\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// All components are in the range [0, 1], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat sceneSDF(vec3 p) {\n\tfloat d = 1.e10;\n\t\n\tfloat speed = 0.5;\n\tfloat t = iTime*speed;\n\tfor(float i=0.0; i < 15.; ++i) {\n\t\tfloat h = hash1(i*4757.);\n\t\tfloat radius = map(pow(perlinNoise(i*15456. + t),3.), 0.05, 0.35);\n\t\tvec3 center = mix(1., 0.4, pow(perlinNoise(i*10.*h+ t), 3.))*(vectorWiggle(i*10.*h + t)*2.-1.);\n\t\tfloat sphere = sphereSDF(p - center, radius);\n\t\t\n\t\td = polysmin(d, sphere, mix(0.05, 0.1, h));\n\t}\n\treturn d;\n}\n\n// from iq technique\n// source: https://www.shadertoy.com/view/3lsSzf\nfloat calcOcclusion(vec3 pos, vec3 nor) {\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++) {\n        float h = 0.01 + 0.11*float(i)/4.0;\n        vec3 opos = pos + h*nor;\n        float d = sceneSDF(opos);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\n// source: https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p) {\n    const float h = NORMAL_DELTA;\n\tconst vec2 k = vec2(1., -1.);\n    return normalize( k.xyy * sceneSDF( p + k.xyy*h ) + \n                      k.yyx * sceneSDF( p + k.yyx*h ) + \n                      k.yxy * sceneSDF( p + k.yxy*h ) + \n                      k.xxx * sceneSDF( p + k.xxx*h ) );\n}\n\n// return dist, marchingCount\nvec2 rayMarching(vec3 O, vec3 D) { // ray origin and dir\n    float t = 0.0;\n    float marchingCount = 0.0;\n \t\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 pos = O + D * t;\n        float d = sceneSDF(pos);\n        \n        t += d * 0.6; // precision handling\n        ++marchingCount;\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( t > MAX_DIST || abs(d) < SURF_DIST*0.99) break;\n\n    }\n    return vec2(t, marchingCount);\n}\n\nvec3 blendColor(float t, vec3 a, vec3 b) {\n\treturn sqrt((1. - t) * pow(a, vec3(2.)) + t * pow(b, vec3(2.)));\n}\n    \nvec3 render(vec3 O, vec3 D) { // ray origin and dir\n\t\n\tint reflexionsCount = 2;\n\tfloat shadowsAttenuation = 5.;\n\tfloat specularStrength = 20.;\n\tvec3 backgroundColor = vec3(2,43,58)/255.0;\n\tvec3 ballsColor = vec3(255,166,43)/255.0;\n\t\n\t// backgroundColor = vec3(29, 186, 34)/255.0;  // green\n\t// ballsColor = vec3(255, 68, 180)/255.0; // pink\n\t\n    vec3 sunDir = normalize(vec3(0., 1., -1.));\n    vec3 sunColor = normalize(vec3(0.7, 0.7, 0.5));\n    float sunIntensity = 0.; \n    \n    vec3 finalCol = vec3(0.0);\n    bool skyReached = false;\n    \n    vec3 p, normal, ref;\n    for(int i = 0; i < reflexionsCount; ++i) {// reflexion loop\n    \t\n    \tvec3 col = ballsColor;\n    \tfloat d = rayMarching(O, D).x;\n    \t\n    \tif( d < MAX_DIST) {\n\t    \t// intersected point position\n\t        p = O + D * d;\n\t        normal = getNormal(p);\n\t        ref = normalize(reflect(D, normal));\n\t        \n\t        float occ = calcOcclusion(p, normal); // ambient occlusion\n\t        float sunDiffuse = saturate(dot(normal, sunDir));\n\t\t\t\n\t\t\tfloat sunSpecular = pow(max(0., dot(normal, normalize(sunDir - D))), specularStrength); // Blinn-Phong\n\t        // sunSpecular = pow(max(0., dot(sunDir, ref)), specularStrength); // Phong\n\t\t\t\n\t        col += sunIntensity*sunColor*sunDiffuse + sunSpecular*sunColor;\n\t\t\tcol *= mix(occ, 1., 0.5);\n\t        col *= 0.3;\n\t    }else {\n\t    \tcol = backgroundColor;\n\t    \tskyReached = true;\n\t    }\n        \n        // define new Origin and Direction for reflexion\n        O = p + normal*SURF_DIST;\n        D = ref;\n        \n        // mix reflexions colors\n        // using step and mix to branchless set finalCol = col when i == 0\n        if( i == 0) {\n        \tfinalCol = col;\n        }else {\n        \tfloat f = 0.6;\n        \tif(skyReached) f /= 6.; // diminish impact of backgroundColor\n\t        \t\n        \tfinalCol = blendColor(f, finalCol, col);\n        \t// finalCol = (finalCol + col*f) / (1+f);\n        }\n        if(skyReached) break; // no reflexions calculation for sky\n    }\n    \n    \n\treturn vec3(saturate(finalCol));\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 1.1; // zoom\n\t\n\tvec3 O = vec3(1.5, 0., 0.); // origin\n\n\tvec3 finalColor = vec3(0.);\n#if AA_SAMPLES > 1\n    for (float i = 0.; i < float(AA_SAMPLES); i++) {\n    \tfor (float j = 0.; j < float(AA_SAMPLES); j++) {\n\t        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) *2.0 - 1.0) / iResolution.y;\n\t        uv += deltaUV;\n#endif\n\t\t\tvec3 D = computeCamDir(uv, O, vec3(0.,1.,0.), vec3(0.)); // dir\n\t    \tfinalColor += render(O, D);\n#if AA_SAMPLES > 1\n    \t}\n    }\n    finalColor /= float(AA_SAMPLES * AA_SAMPLES); // Average samples\n#endif\n    \n    // gamma corection\n    finalColor = pow(finalColor, vec3(1./2.2));\n    \n    \n    vec3 hsv = rgb2hsv(finalColor);\n    hsv.y *= 1.5; // saturate\n    hsv.z *= 1.3;\n    finalColor = hsv2rgb(saturate(hsv));\n    \n    // color grading\n    finalColor *= vec3(1.07 ,0.92, 0.95);\n    \n\tfragColor = vec4(finalColor,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGcDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[492, 581, 604, 604, 629], [630, 630, 653, 653, 688], [689, 689, 715, 715, 743], [744, 744, 782, 782, 807], [808, 842, 898, 898, 940], [941, 941, 961, 961, 979], [980, 980, 1000, 1000, 1022], [1023, 1023, 1042, 1042, 1060], [1061, 1061, 1080, 1080, 1102], [1141, 1299, 1321, 1321, 1406], [1408, 1408, 1429, 1429, 1562], [1564, 1564, 1592, 1592, 1721], [1723, 1723, 1751, 1751, 1880], [1882, 1882, 1924, 1924, 2178], [2180, 2180, 2208, 2208, 2236], [2238, 2274, 2319, 2319, 2412], [2414, 2414, 2453, 2453, 2482], [2484, 2609, 2631, 2631, 2962], [2964, 3022, 3044, 3044, 3213], [3215, 3215, 3239, 3239, 3645], [3647, 3717, 3758, 3758, 4038], [4040, 4113, 4137, 4137, 4432], [4434, 4464, 4498, 4520, 4943], [4945, 4945, 4987, 4987, 5055], [5061, 5061, 5090, 5112, 7097], [7099, 7099, 7169, 7169, 7448], [7450, 7450, 7505, 7505, 8429]]}
{"id": "3dGczG", "name": "warped blast off", "author": "trancor", "description": "Warped ray marching with \"boolean\" cuts from the \"geo\".\nJust a test to learn geo sdf Ray Marching; based off of the Operators tutorial by Martijn Steinrucken; yt- \"Art Of Code\"\nTrying out some triplanar mapped marched geo too.", "tags": ["raymarching", "triplanar"], "likes": 2, "viewed": 88, "published": "Public", "date": "1603070170", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Diving into better ray marching methods after all these years\n// Started with a tutorial, but added in triplanar texturing and animated the heck out of it\n// modded by Kevin Edzenga\n// -- -- -- --\n// Based off of by Art Of Code - \"ShaderToy Tutorial - Ray Marching Operators 2\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// \n// This is the starting point for a YouTube tutorial:\n// https://youtu.be/Vmb7VGBVZJA\n\n\n#define MAX_STEPS 50\n#define MAX_DIST 12.\n#define SURF_DIST .25\n\n// Untouched from tutoial\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// Used to be math for a cube\n// Now its just a mess of distance based warping\nfloat sdBox(vec3 p, vec3 s) {\n    p = min( (p)-s, (p)+s);\n\treturn length(p)+(p.x+p.y);\n}\n\n\n// Slice'n'Dice!\n// Duel plane cutting a botched up box with warped planes and distance in space\nfloat GetDist(vec3 p, vec3 ro) {\n\tfloat time = iTime*.3;\n    vec3 pd = p;\n    pd.x = abs(p.x) + tan(p.z*.2) * cos(-p.y*.3);\n    pd.y *= pd.x<0.0 ? -2.0 : 1.1;\n    pd.z = mix( pd.z, pd.x, sin(p.z)*.15-.1 );\n    \n    float scalar = sin( dot(normalize(ro-pd),pd)*.1) * (pd.x+pd.z)*.4;\n    pd.z = mix( -pd.z, pd.y+pd.x, abs(scalar) );\n\n   \n    vec2 tUv = vec2( sin(pd.x*.01+scalar*.1), cos(pd.z*.1+scalar*.01)) *.1+.5;\n    vec3 tex = texture(iChannel0, tUv ).rgb;\n\n    vec3 slicer = normalize( vec3(sin(time+pd.z-pd.x+1.2)*.50+.5, -0.71, cos(time+pd.z+pd.y)*.10+.2) );\n\tslicer -= texture(iChannel1, slicer.rg*.01).rgb;\n    float plane = dot(pd, slicer); // Dot Plane 1\n    \n    \n    slicer = vec3( sin(-time*1.5+pd.z+tex.g+5.1)*2.0, .90, cos(time+pd.y+tex.g)*2.0 );\n \n    float pa = dot( pd*vec3(1.27,.07,.95), slicer ); // Dot Plane 2\n    plane = plane*abs(pa); // Combine both cutting planes\n    \n    float box = sdBox(pd+vec3(.0,.15,.0), vec3(.7)); // Warped Box Math 1\n    \n    slicer = vec3( sin(-time*1.5+pd.x+tex.g), .0, cos(time+pd.y+tex.g)*2.0 );\n    float boxf = sdBox( pd*vec3(-1,1,-1)-vec3(0.0,.2,1.0), vec3(-slicer*0.5+.5) ); // Warped Box Math 2\n    box = box+abs(boxf)-0.10; // Combine both boxes\n    \n    float d = max( plane, box) * min(1.0,length(pd));\n    \n    return d;\n}\n\n// Minor tweeks\nvec4 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    float dS=0.;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dS = GetDist(p, ro);\n        dO += dO>MAX_DIST || dS<SURF_DIST ? 0.00 : dS;\n    }\n    \n    return vec4( ro + rd*dO,dO); // ##\n}\n\nvec3 GetNormal(vec3 p, vec3 ro, float dO) {\n\tfloat d = GetDist(p, ro);\n    vec2 e = vec2(.005, 0); // ##\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy, ro),\n        GetDist(p-e.yxy, ro),\n        GetDist(p-e.yyx, ro));\n    \n    return normalize(n);\n}\n\n\n// Minor tweeks\nvec4 GetLight(vec3 p, vec3 n) {\n    vec3 lightPos = vec3(3.0, 5, 4);\n    vec3 l = normalize(lightPos-p);\n    \n    float dif = dot(n, l)*.5+.5;\n\n    return vec4(n,dif); // #\n}\n\n// Untouched from tutoial\nvec3 rayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 0, 3.4);\n    \n    float ds = length(uv)*.1+1.0;\n    vec3 rd = rayDir(uv, ro, vec3(0,-.37,0), ds);\n\n    vec4 d = RayMarch(ro, rd); // vec3(rayMarchEnd), float lastStepSize\n\tfloat bgMask = step(d.w,MAX_DIST);\n    \n    vec3 p = d.xyz;\n    \n    vec3 n = GetNormal(p, ro, d.w);\n\tfloat dotEdge = dot( p.xyz ,n.xyz)* bgMask ; // Edge fall off\n    vec4 dif = GetLight(p, n); // Lighting dir vector\n\n\t// Get some warping from surface bend direction to apply as an offset to the xyz texture reads\n\tvec3 texWarp=cross( normalize(ro-d.xyz), n.xyz )*dotEdge*.5+.5;\n\n\n\t// Triplanar, it ainy pretty, but it works ... sorta\n    vec3 tx = texture(iChannel0, p.yz*.1+texWarp.yz).rgb;\n    vec3 ty = texture(iChannel0, p.xz*.1+texWarp.xz).rgb;\n    vec3 tz = texture(iChannel0, p.xy*.1+texWarp.xy).rgb;\n    vec3 td = abs( vec3( dot(vec3(1,0,0),n), dot(vec3(0,1,0),n), dot(vec3(0,0,1),n) ) );\n\tvec3 tdInv = vec3( 1.0-td.x, 1.0-td.y, 1.0-td.z );\n\t// Scale by other axes prominance\n    vec3 tm = vec3(\n\t\t\ttd.x * (tdInv.y * tdInv.z),\n\t\t\ttd.y * (tdInv.x * tdInv.z),\n\t\t\ttd.z * (tdInv.x * tdInv.y));\n    vec3 tex = tx*tm.x + ty*tm.y + tz*tm.z; // Combine the triplanar colors\n\n    // Boost the color of the center mass\n\tvec3 tf = texture(iChannel2, uv*.1+d.zz*.1+texWarp.xy*.1).rgb;\n\n    float dscale = max(0.0,(d.w-3.0)*.02); // Boost green/blue bg colored bits\n\ttex += cross(vec3(.1,1,0), p.xyz)*(1.0+dotEdge*dscale);\n\tfloat bBrown=max(0.0, 1.0-max(0.0, d.w-2.5)); // Boost Brown;\n    tex += tf*(1.0+bBrown);\n\n    col = vec3(tex*dif.w* bgMask * (1.0-dotEdge*dscale) );\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGczG.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[584, 610, 629, 629, 705], [708, 787, 816, 816, 875], [878, 975, 1007, 1007, 2262], [2264, 2280, 2313, 2313, 2543], [2545, 2545, 2588, 2588, 2800], [2803, 2819, 2850, 2850, 2993], [2995, 3021, 3068, 3068, 3263], [3266, 3266, 3323, 3323, 5015]]}
{"id": "3dGyRh", "name": "Audio visualizer 2", "author": "supah", "description": "Audio visualizer", "tags": ["sound", "wave", "audio", "visualizer"], "likes": 4, "viewed": 184, "published": "Public", "date": "1602172918", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float line(float top, float bottom, float sharpen, vec2 uv) {\n    sharpen = 0.05 * smoothstep(0.6, 1., uv.x) + 0.05 * smoothstep(0.3, 0., uv.x);\n    return smoothstep(top, top + sharpen, uv.y) - smoothstep(bottom, bottom + sharpen, uv.y);\n}\n\nfloat wave(float time, vec2 uv, float phase) {\n    float wave = sin(time + uv.x * phase);\n    float blur = 0.1 * smoothstep(0., .5, uv.x) * 0.1 * smoothstep(1., 0.5, uv.x);\n    uv.y += phase * blur * wave;\n    return line(0.495, 0.505, 0.01, uv);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float audio = 1.; texture(iChannel0, vec2(uv * 0.1)).x;\n    \n    float line = wave(iTime * 3., uv, 10. + sin(iTime) * 1.5);\n    float line2 = wave(iTime * 4., uv, 13. + sin(iTime + 2.) * 3.);\n    float line3 = wave(iTime *  5., uv, 20. + sin(iTime + 3.) * 3.);\n    \n    vec3 col1 = vec3(1.0, 0.1, 0.2) * line;\n    vec3 col2 = vec3(0.8, 0.4, 0.2) * line2;\n    vec3 col3 = vec3(0.3, 0.2, 0.9) * line3;\n    vec3 col = 4. * (col1 * audio + col2 * audio + col3 * audio);\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGyRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 61, 61, 240], [242, 242, 288, 288, 490], [492, 492, 549, 549, 1101]]}
{"id": "3dGyWh", "name": "Parallax cubes", "author": "jsharifi", "description": "Cubes which have been given parallax translations.\nBased on https://www.shadertoy.com/view/XsyXWV (camargo) with some stub code from https://www.shadertoy.com/view/Xds3zN (iq).", "tags": ["raymarching", "cube", "parallax", "iq", "camargo"], "likes": 0, "viewed": 33, "published": "Public", "date": "1602648873", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// code primarily from https://www.shadertoy.com/view/XsyXWV\n// Author: Chris Camargo\n\n\n// First Raymarch - Cubes\n// Chris Camargo, June 2016\n\n// Distance function for box.\nfloat box(vec3 p, vec3 b)\n{\n    vec3 d = abs(p) - b;\n\n    return min(max(d.x,max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\n// from https://www.shadertoy.com/view/Xds3zN\n// THE Inigo Quilez\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// from https://www.shadertoy.com/view/Xds3zN\n// THE Inigo Quilez\nfloat sdEllipsoid( vec3 p, vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\n// Repeater distance function for box.\nfloat rep(vec3 p, vec3 c)\n{\n    vec3 q = mod(p, c) - 0.5 * c;\n    return box(q, vec3(0.5, 0.5, 0.5));\n}\n\n// Raymarch, computing the distance at each step and incrementing the\n// ray parameter t.\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n        vec3 p = o + r * t;\n\n        // Distance function.\n        float d = rep(p, vec3(2.0, 3.0, 2.0));\n\n        t += d;\n    }\n    return t;\n}\n\n// Image computation.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    float x = fragCoord.x;            // Current pixel x-coordinate. Range: [0.5, iResolution.x - 0.5].\n    float y = fragCoord.y;            // Current pixel y-coordinate. Range: [0.5, iResolution.y - 0.5].\n    float minX = 0.5;                 // Min x-coordinate value.\n    float minY = 0.5;                 // Min y-coordinate value.\n    float maxX = iResolution.x - 0.5; // Viewport width.\n    float maxY = iResolution.y - 0.5; // Viewport height.\n\n    // Feature Scaling. Bring coords to value between [0, 1].\n    // https://en.wikipedia.org/wiki/Feature_scaling#Rescaling\n    vec2 uv = vec2((x - minX) / (maxX - minX), (y - minY) / (maxY - minY));\n\n    // Coords between [0, 1] so 'eye' is centered at (0.5, 0.5).\n    // We want 'eye' centered at (0, 0). Thus subtract 0.5 from\n    // each coord.\n    uv -= 0.5;\n\n    // Move coords away from 'eye' by a factor of 2.0.\n    // You can play with this number.\n    uv *= 2.0;\n    \n    // Scale x based on aspect ratio.\n    uv.x *= iResolution.x / iResolution.y;\n    \n    // translate in x\n    float xtranslate = cos(iTime) * 2.0;\n    const float positionK = 0.5;\n    const float parallaxK = 0.5;\n    // origin is a-function-of-translation\n    // Ray origin.\n    vec3 o = vec3(xtranslate * positionK, 0.0, 0.0);\n\n    // view direction scales linearly with the opposite of translation\n    // Ray direction.\n    vec3 r = normalize(vec3(uv.x - xtranslate * parallaxK, uv.y, 1.0));\n\n    r = normalize(r);\n    \n    // Rotate direction r around y-axis by a fraction of time.\n    // float theta = iTime * 0.25;\n    // r.xz *= mat2(cos(theta), -sin(theta), sin(theta), cos(theta));\n    \n    // Trace ray from origin o in direction r.\n    float t = trace(o, r);\n    float t2 = trace(o + vec3(0.01, 0.0, 0.0), r - vec3(0.01, 0.0, 0.0));\n    \n    // compute marginal derivative. $t is distance\n    float dtdx = (t - t2) / 0.001;\n    \n    // dampen the force field glows\n    float g = 0.05 * dtdx;\n    \n    // Set the color via 1 / (1. + t): Light attenuation.\n    // lerp in an occasional dark tint to gb values\n    float forceFieldMode = cos(iTime * 2.0) * 0.1 + 0.9;\n    vec3 color = vec3(0.5 * (1.0 - forceFieldMode), +0.01 * g + forceFieldMode / (1. + t), -0.01 * g + forceFieldMode / (1. + t));\n    \n    // Set pixel color.\n    fragColor =  vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGyWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[143, 173, 200, 200, 295], [297, 363, 411, 411, 699], [701, 767, 820, 820, 909], [911, 950, 977, 977, 1053], [1055, 1145, 1174, 1174, 1373], [1375, 1397, 1452, 1452, 3758]]}
{"id": "3dGyWt", "name": "Sine Ring", "author": "gaz", "description": "raycast", "tags": ["raycast"], "likes": 4, "viewed": 61, "published": "Public", "date": "1603960330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.)\n#define TAU PI*2.\n\nvec3 lookat(vec3 p, vec3 eye, vec3 target, vec3 up)\n{\n\tvec3 w=normalize(target-eye), u=normalize(cross(w,up));\n\treturn vec3(dot(p,u), dot(p,cross(u,w)), dot(p,w));\n}\n\nvec2 rotate(vec2 p, float a)\n{\n    return p*cos(a)+vec2(-p.y, p.x)*sin(a);\n}\n\nvec3 func(vec3 p, vec3 nor, float r, float t)\n{\n    t*=TAU;\n    vec2 uv=vec2(cos(t),sin(t))*r*(1.+sin(t*6.)*.15);\n    vec3 u=normalize(cross(nor,vec3(0,1,0)));\n    vec3 v=normalize(cross(nor,u));\n    return uv.x*u+uv.y*v+p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord*2.-iResolution.xy)/iResolution.y;\n    vec3 ro=vec3(0,0,10);\n    ro.xz=rotate(ro.xz, iTime);\n    vec3 ta=vec3(.1,.2,.1);\n    vec3 rd=lookat(normalize(vec3(uv,2)),ro,ta,vec3(0,1,0));\n\n    float R=.5;\n    \n    vec3 nor;\n \tfloat ITR=150.,pitch=1.,t=.5,de=R+1.,z=1e10;   \n    for(int j=0;j<2;j++)\n    {\n        float t0=t-pitch*.5;\n        pitch/=ITR;\n        for(float i=0.;i<ITR;i++)\n        {\n            t0+=pitch;\n            vec3 p=func(vec3(.2,.1,.1),normalize(vec3(3,2,-2)),3.,t0);\n            float de0=length(cross(p-ro,rd));\n            if(de0<=R){\n                de=de0;\n                float z0=dot(p-ro,rd)-sqrt(R*R-de*de);\n                if(z>z0){\n                    z=z0;\n                    nor=normalize(ro+rd*z-p);\n                    t=t0;\n                }\n                \n            }\n        }\n    }\n    if(de<=R)\n    {\n\t\tfragColor+=max(dot(nor,normalize(vec3(1))),.2);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGyWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[40, 40, 93, 93, 205], [207, 207, 237, 237, 283], [285, 285, 332, 332, 510], [512, 512, 569, 569, 1493]]}
{"id": "3dGyzR", "name": "Voronoi Example Test 2", "author": "beherca", "description": "Voronoi", "tags": ["voronoi"], "likes": 1, "viewed": 43, "published": "Public", "date": "1602060342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.youtube.com/watch?v=l-07BXzNdPw&t=129s\n\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx * vec3(123.34,234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float m = 0.;\n    float minDist = 100.;\n    float cellIndex = 0.;\n\n    for(float i=0.;i<200.;i++){\n        vec2 nv = N22(vec2(i));\n        vec2 p = sin(nv * iTime);\n        float d = length(uv -p);\n        m+= smoothstep(0.12, 0.119, d);\n        if(d < minDist){\n            minDist = d;\n            cellIndex = i;\n        }\n    }\n    \n    vec3 col = vec3(cellIndex/100., cellIndex/120., cellIndex/170.);\n    // Output to screen\n    fragColor = vec4(col ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGyzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 55, 72, 72, 198], [200, 200, 257, 307, 867]]}
{"id": "3dKczD", "name": "Not mine, but good", "author": "lyurai", "description": "Amazing kaleydoscop", "tags": ["fract"], "likes": 2, "viewed": 191, "published": "Public API", "date": "1602355423", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/10.;\n        for(int i=0;i<1;i++){\n            uv=abs(uv);\n            uv-=.5;\n            uv=uv*rot(t/float(i+1));\n        }\n\t    col[c]=fract(uv.x*2.),fract(uv.x*2.),fract(uv.x*2.);\n    }\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKczD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 496]]}
{"id": "3dKyDK", "name": "Fast 3D water - 421 Chars", "author": "Ric3cir121", "description": "Fast 3D water generated with a procedural cosine noise", "tags": ["procedural", "3d", "raytracing", "raymarching", "noise", "waves", "wave", "sea", "fast", "water", "light", "ocean", "blue", "blue", "realistic", "chars"], "likes": 18, "viewed": 456, "published": "Public API", "date": "1603786758", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define r(A)     mat2( C=cos(A), S=sin(A), -S, C )           //\n//#define r(a)   mat2( cos( a + vec4(0,11,33,0) ) )          // bug: https://www.shadertoy.com/view/ttGyzh\n#define w(c,a) ( R.xy = r(a) * c.xz + iTime,  abs( cos( R.y + cos( R.x ) ) ))  //\n#define W(c)   ( w(c,9.) + w(c,7.) + w(c,h) )                //\n#define D(c)     W(h*c) + W(c)*.1 + 9. + c.y\n\nvoid mainImage( out vec4 o, vec2 u ) {\n    float h = .3, f = h, C,S; \n    vec3 m = u.xyy/iResolution.x - .5, c=m-m, R;\n    m.z -= .4; m.xz *= r(iTime*h);\n    \n    for( m /= length(m) ; \n         f++ < 30. && (C=D((c+h))) > .1 ; \n         c += m * C );\n    \n    o = min((D(c)+h)*9., 0.) * min(m.x+.6, 0.) \n      + .1* vec4( C= c.y+12. , 2.+C , 4 , 1 )\n      + f/50. - length(c)/7e2 ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKyDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 363, 401, 401, 747]]}
{"id": "3dKyR1", "name": "Rolling Cubes", "author": "nanase", "description": "Rolling Cubes.", "tags": ["3d", "cubes"], "likes": 2, "viewed": 54, "published": "Public", "date": "1602851269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(float h, float s, float v) {\n\tvec3 a = fract(h + vec3(0.0, 2.0, 1.0)/3.0) * 6.0 - 3.0;\n\ta = clamp(abs(a) - 1.0, 0.0, 1.0) - 1.0;\n\ta = a*s + 1.0;\n\treturn a*v;\n}\n\nmat2 rot(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,s,-s,c);\n}\n\nvec3 onRep(vec3 p, float interval) {\n\treturn mod(p, interval) - interval * 0.5;\n}\n\nvec3 rotate(vec3 p, float angle, vec3 axis) {\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\nfloat box(vec3 p, float s) {\n    p = abs(p) - s;\n    return max(max(p.x, p.y), p.z);\n}\n\nfloat plane(vec3 p) {\n    float d = p.y;\n    return d;\n}\n\nfloat sdFloor(vec3 p) {\n    return dot(p, vec3(0., 1., 0.)) + 0.28;\n}\n\nfloat boxZ(vec3 p, float speed, float size, float repx, float repz) {\n    p.z -= (iTime - 1.) * speed;\n    p.z = onRep(p, repz).z;\n    p.x = onRep(p, repx).x;\n\n    p.y += 0.2 - size;\n\n    p = rotate(p, iTime * speed, vec3(-0.5,0.0,0.0));\n    return box(p, size);\n}\n\nfloat boxX(vec3 p, float speed, float size, float repx, float repz) {\n    p.x -= iTime * speed;\n    p.x = onRep(p, repx).x;\n    p.z = onRep(p, repz).z;\n    p.y += 0.2 - size;\n\n    p = rotate(p, iTime * speed, vec3(0.0,0.0,0.5)); \n    return box(p, size);\n}\n\nfloat myBoxZ1(vec3 p) {\n    return boxZ(vec3(p.x + .5, p.y, p.z), 5., 0.1, 5., 2.);\n}\nfloat myBoxZ2(vec3 p) {\n    return boxZ(vec3(p.x+1.5, p.y, p.z), 4., 0.2, 5., 2.);\n}\nfloat myBoxZ3(vec3 p) {\n    return boxZ(vec3(p.x+2.5, p.y, p.z), 3., 0.25, 5., 2.);\n}\nfloat myBoxZ4(vec3 p) {\n    return boxZ(vec3(p.x+3.5, p.y, p.z), 2., 0.3, 5., 2.);\n}\nfloat myBoxZ5(vec3 p) {\n    return boxZ(vec3(p.x+4.5, p.y, p.z), 1.8, 0.4, 5., 2.);\n}\nfloat myBox4(vec3 p) {\n    return boxX(vec3(p.x, p.y, p.z), 5., 0.1, 2., 8.);\n}\nfloat myBox5(vec3 p) {\n    return boxX(vec3(p.x, p.y, p.z-2.), 4., 0.2, 2., 8.);\n}\nfloat myBox6(vec3 p) {\n    return boxX(vec3(p.x, p.y, p.z-4.), 3., 0.25, 2., 8.);\n}\nfloat myBox7(vec3 p) {\n    return boxX(vec3(p.x, p.y, p.z-6.), 2., 0.3, 2., 8.);\n}\n\nfloat sceneDist(vec3 p) {\n    float ret = sdFloor(p);\n    // z\n    ret = min(ret, myBoxZ1(p));\n    ret = min(ret, myBoxZ2(p));\n    ret = min(ret, myBoxZ3(p));\n    ret = min(ret, myBoxZ4(p));\n    ret = min(ret, myBoxZ5(p));\n\n    return ret;\n}\n\nconst float EPS = 0.0001;\nvec3 getNormal(vec3 p) {\n\treturn normalize(vec3(\n\t\tsceneDist(p + vec3(EPS,0.,0.)) - sceneDist(p + vec3(-EPS,0.,0.)),\n\t\tsceneDist(p + vec3(0.,EPS,0.)) - sceneDist(p + vec3(0.,-EPS,0.)),\n\t\tsceneDist(p + vec3(0.,0.,EPS)) - sceneDist(p + vec3(0.,0.,-EPS))\n\t));\n}\n\nconst vec3 lightDir = vec3(-0.577, 0.577, 0.577);\n\nmat3 camera(vec3 ro, vec3 ta) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(0.0, 1.0, 0.0);\n    vec3 cu = cross(cw, cp);\n    vec3 cv = cross(cu, cw);\n    return mat3(cu, cv, cw);\n}\n\nfloat genShadow(vec3 ro, vec3 rd) {\n    float h = 0.0;\n    float c = 0.001;\n    float r = 1.0;\n    float shadowCoef = 0.5;\n    for (int i = 0; i<20; i++) {\n        h = sceneDist(ro + rd * c);\n        if(h < 0.001) {\n            return shadowCoef;\n        }\n        r = min(r, h * 16.0 / c);\n        c += h;\n    }\n\n    return 1.0 - shadowCoef + r * shadowCoef;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\n    float screenZ = 1.5;\n    vec3 rd = normalize(vec3(uv, screenZ));\n\n    // Camera\n    vec3 ta = vec3(-1.5, -0.5, -1.);\n    vec3 ro = vec3(1., 2.5, 2.);\n    if (mod(iTime, 50.) < 10.) {\n        ro *= mod(iTime, 50.);\n    } else if (mod(iTime, 50.) < 20.) {\n        ro = vec3(-1., 0.5, 1.5);\n        ro.x *= mod(iTime, 50.) - 9.;\n        ro.y *= mod(iTime, 50.) - 10.;\n    } else if (mod(iTime, 50.) < 30.) {\n        ro = vec3(0.1, 5., 0.5);\n        ro.x += 2.;\n        ro.zy *= mod(iTime, 50.) - 18.;\n        ro.xy /= 2.;\n    } else if (mod(iTime, 50.) < 40.) {\n        ro = vec3(2., 0.5, 2.5);\n        ro.xy *= mod(iTime, 50.) - 30.;\n    } else {\n        ro = vec3(-5., 0.5, 2.5);\n        ro.z *= mod(iTime, 50.) - 40.;\n    }\n    rd = camera(ro, ta) * normalize(vec3(uv, screenZ));\n\n    float d = 0.0;\n    vec3 col = vec3(0.);\n\n    vec3 light = normalize(lightDir + vec3(0., 2., 1.));\n    float shadow = 1.0;\n\n    for(int i=0; i<99; i++) {\n        vec3 rp = ro + rd * d;\n        float dist = sceneDist(rp);\n\n        if (abs(dist) < 0.0001) {\n            vec3 normal = getNormal(rp);\n\n            // light\n            vec3 halfLE = normalize(light - rd);\n            float diff = clamp(dot(light, normal), 0.1, 1.0);\n            float spec = pow(clamp(dot(halfLE, normal), 0.0, 1.0), 50.0);\n\n            shadow = genShadow(rp + normal * 0.001, light);\n\n            float u = 1.0 - floor(mod(rp.x, 2.0));\n            float v = 1.0 - floor(mod(rp.z, 2.0));\n\n            if((u == 1.0 && v < 1.0) || (u < 1.0 && v == 1.0)) {\n                diff *= 0.7;\n            }\n\n            col = vec3(0.89);\n            col = col * diff + vec3(spec);\n\n            if(myBoxZ1(rp) < 0.001) {\n                col.rgb -= mod(iTime, 1.) * 0.5;\n            }\n            else if(myBoxZ2(rp) < 0.001) {\n                col.r += 0.5;\n            }\n            else if(myBoxZ3(rp) < 0.001) {\n                col.g += 0.5;\n            }\n            else if(myBoxZ4(rp) < 0.001) {\n                col.b += 0.5;\n            }\n            else if(myBoxZ5(rp) < 0.001) {\n                col.rgb += 0.5;\n            }\n\n            break;\n        }\n\n        d += dist;\n    }\n\n    fragColor = vec4(col * max(0.5, shadow), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKyR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 172], [174, 174, 193, 193, 256], [258, 258, 294, 294, 339], [341, 341, 386, 386, 740], [742, 742, 770, 770, 828], [830, 830, 851, 851, 886], [888, 888, 911, 911, 957], [959, 959, 1028, 1028, 1223], [1225, 1225, 1294, 1294, 1481], [1483, 1483, 1506, 1506, 1568], [1569, 1569, 1592, 1592, 1653], [1654, 1654, 1677, 1677, 1739], [1740, 1740, 1763, 1763, 1824], [1825, 1825, 1848, 1848, 1910], [1911, 1911, 1933, 1933, 1990], [1991, 1991, 2013, 2013, 2073], [2074, 2074, 2096, 2096, 2157], [2158, 2158, 2180, 2180, 2240], [2242, 2242, 2267, 2267, 2483], [2511, 2511, 2535, 2535, 2769], [2822, 2822, 2853, 2853, 3011], [3013, 3013, 3048, 3048, 3374], [3376, 3376, 3433, 3433, 5723]]}
{"id": "3dKyRW", "name": "circle-pattern", "author": "lasoy", "description": "pattern", "tags": ["pattern"], "likes": 4, "viewed": 186, "published": "Public API", "date": "1602325880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 brickTile(vec2 pos, float zoom){\n    pos *= zoom;\n\n    float time = fract(iTime * .5);\n    float col = step(1., mod(pos.x + (1.0 - step(.75, time)) * .5, 2.0));\n    float row = step(1., mod(pos.y - step(.5, time) * .5, 2.0));\n\n    pos.x += (clamp(time, .0, .25) + clamp(time - .5, .0, .25)) * (row - .5) * 4.;\n    pos.y += (clamp((time - .25), .0, .25) + clamp(time - .75, .0, .25)) * (col - .5) * 4.;\n\n    return fract(pos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    vec2 pos = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    pos = brickTile(pos, 6.);\n    \n    pos = pos - vec2(.5);\n    float angle = atan(pos.x, pos.y);\n    angle += iTime * 1.;\n    float r = length(pos);\n\n    vec3 color = vec3(smoothstep(cos(angle*3.),cos(angle*3.)+.1,r*3. ));\n    fragColor = vec4(color,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKyRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 37, 37, 432], [434, 434, 490, 490, 816]]}
{"id": "3dtcDB", "name": "[TWITCH] Frankenslug", "author": "evvvvil", "description": "Frankenslug - Result of improvised live code session on Twitch\nLIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time:\nhttps://www.twitch.tv/evvvvil_", "tags": ["tunnel", "demoscene", "glow", "alien", "goo", "organic", "scifi", "liquid", "tube", "monster", "drip", "lazer", "creature", "industrial", "biomechanic", "giger"], "likes": 27, "viewed": 668, "published": "Public API", "date": "1601653605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Frankenslug - Result of an improvised live coding session on Twitch\n// LIVE SHADER CODING, SHADER SHOWDOWN STYLE, EVERY TUESDAYS 20:00 Uk time: \n// https://www.twitch.tv/evvvvil_\n\nvec2 z,v,e=vec2(.0035,-.0035);float t,tt,g,ggg,tnoi=1.;vec3 blobP,op,po,no,al,ld,colorP;\nfloat lngSp( vec3 p, vec3 h,float r ) {p = p - clamp( p, -h, h );return length( p )-r;}\nconst float PI=acos(-1.);\nfloat smin(float a,float b,float k){float h=max(k-abs(a-b),0.);return min(a,b)-h*h*.25/k;}\nfloat smax(float a,float b,float k){float h=max(k-abs(-a-b),0.);return max(-a,b)+h*h*.25/k;}\nmat2 r2(float r){return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec4 texNoise(vec2 uv){ float f = 0.; f+=texture(iChannel0, uv*.125).r*.5; f+=texture(iChannel0,uv*.25).r*.25;\n                       f+=texture(iChannel0,uv*.5).r*.125; f+=texture(iChannel0,uv*1.).r*.125; f=pow(f,1.2);return vec4(f*.45+.05);}\nvec2 mp( vec3 p,float s)\n{\n    op=blobP=p;\n    vec3 hTubesP=p-vec3(0,0,0);    \n    float frill=sin(p.x*30.)*.005,\n        vfrill=cos(p.y*30.)*.006,\n        def=sin(p.x*.5+tt)*.2+sin(p.x*.1+1.)*.3-sin(p.x*1.5)*.2+cos(p.x*p.z*.3)*.2,\n        vdef=sin(p.y*.5+tt+1.),\n        tunnelD=clamp(cos(p.x*.5+1.5),-.5,.5);\n    hTubesP=vec3(atan(hTubesP.z,hTubesP.y)*4., length(hTubesP.zy)-6.9+tunnelD, hTubesP.x*.5);  \n    float tubeD=clamp((cos(hTubesP.z*.4-.5)),-.1,.1)*5.+.5;  \n    hTubesP.x=mod(hTubesP.x,6.)-3.;\n    hTubesP.x=abs(hTubesP.x)-1.5;\n    for(int i=0;i<3;i++){\n        hTubesP.x=abs(hTubesP.x)-tubeD*.2;    \n        hTubesP.x-=.15;\n    }    \n    blobP.xy-=def*1.5;\n    vec3 blobPlugsP=vec3(abs(abs(blobP.x)-2.8)-1.4,abs(abs(abs(blobP.y)-3.5)-4.)-1.5-def*1.5,abs(blobP.z)-2.2);  \n    blobPlugsP.yz*=r2(sin(p.x*.3+tt)*.1);\n    blobPlugsP.z+=-.65+cos(p.y*.4)*.75;\n    vec3 vertTubesP=blobPlugsP;\n    vec2 h,t=vec2(.7*(length(vertTubesP.xz)-.16-vdef*.08-vfrill),7);                      //SLUG VERTICAL TUBES\n    if(lngSp(blobP,vec3(7.5,0,0),5.5)<0.){\n        tnoi=texNoise(p.xz*.06-vec2(.66,1.28)).r*3.8;\n        t.x=min(t.x,.55*lngSp(blobP,vec3(3.9,0,0),2.5+frill+(def-tnoi)*.5));              //SLUG BODY\n        t.x=smax(.8*(length(blobP-vec3(6.,.1,0))-1.1+sin(tt)*.5+tnoi*.4),t.x,.4);         //SLUG MOUTH    \n        t.x=smax(.8*(length(abs(blobP.yz-vec2(3.2,0))-1.)-.12+sin(p.x*25.)*.03),t.x,1.);  //SLUG HOLE CREST\n    }\n    t.x=smin(.5*(length(blobPlugsP)-.6-sin(blobPlugsP.y*blobPlugsP.z*30.)*0.04),t.x,.4);  //SLUG PLUGS  \n    //t.x=smax(length(blobPlugsP-vec3(0,0.4,-0.1))-.3,t.x,.5);//REMOVED TO OPTIMIZE\t\t  //SLUG PLUG HOLES\n    vec3 bubblesP=p-vec3(0,2.5+def,0);bubblesP.x=abs(abs(bubblesP.x)-2.)-1.;\n    t.x=smin(t.x,max(length(bubblesP*vec3(1,sin(p.y*.5-p.x*.2-tt)*.3,1))-.3+p.y*.03,-p.y),.5); //SLUG BUBBLES  \n    h=vec2(length(p.yz)-50.,5.);                                                            //TUNNNNNNNNNELLLLL  \n    h.x=max(h.x,-.8*(length(p.yz)-7.+frill*2.+tunnelD));  \n    vertTubesP-=vec3(0,.4,0.0);\n    if(s>0.){\n        float glowPlugs=.6*(length(vertTubesP)-.48);                                      //SLUG GLOW PLUGS  \n        g+=0.1/(0.1*glowPlugs*glowPlugs*500.);  \n        vertTubesP.xz*=r2(sin(p.y*.5)+tt);    \n        vertTubesP=abs(vertTubesP)-.1-vdef*.4*clamp(p.y-2.,0.,1.)-vfrill;  \n        float lazers=0.65*length(vertTubesP.xz);                                          //LAZERS\n        lazers=min(lazers,glowPlugs);  \n        g+=0.1/(0.1*lazers*lazers*400.);  \n        h.x=min(h.x,lazers);\n        float reddish=.7*lngSp(blobP-vec3(0,.75,0),vec3(4.1,0,0.),1.1+frill);             //SLUG REDISH GLOW\n        ggg+=0.1/(0.1*reddish*reddish*400.);\n        h.x=min(h.x,reddish);\n    }\n    t=t.x<h.x?t:h;    \n    h=vec2(0.8*(length(hTubesP.xy)-.15+(clamp(sin(p.x*3.),-0.5,.5)+.5)*.1),6);            //TUUUUUUUUUBES WHITE\n    t=t.x<h.x?t:h;    \n    h=vec2(.9*length(hTubesP.xy-frill-vec2(0.3,0.))-.38-tunnelD*.2,3);                    //BLACK TUBES CASINGS\n    h.x=max(h.x,-.8*(hTubesP.y+.2-frill)+sin(p.z*p.x*.05)*.2);\n    h.x=max(h.x,-.9*(abs(abs(hTubesP.x-.2)-.2)-.1));  \n    t=t.x<h.x?t:h;\n    colorP=hTubesP;\n    return t;\n}\nvec2 tr( vec3 ro,vec3 rd)\n{\n    vec2 h,t=vec2(.2);\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x,1.);\n        if(h.x<.0001||t.x>35.) break;\n        t.x+=h.x;t.y=h.y;\n    }\n    if(t.x>35.) t.y=0.;\n    return t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime+9.3,62.83);\n    vec3 ro=mix(vec3(18.+cos(tt*.2)*9.,4,sin(tt*.4)*4.),\n                vec3(5.-sin(tt*.2)*20.,cos(tt*.2)*5.,-2.),ceil(cos(tt*0.2)));\n    vec3 cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),\n        cv=normalize(cross(cu,cw)),rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n    co=fo=vec3(.2,.12,.1)-length(uv)*.1-rd.y*.2;\n    ld=normalize(vec3(.3,.3,-.0));\n    z=tr(ro,rd);t=z.x;\n    if(z.y>0.){\n        po=ro+rd*t;\n        no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n        al=vec3(.6,.5,.4)-sin(colorP.x*200.)*.1;\n        float spa=1.,sspa=0.;\n        if(z.y<5.)al=vec3(0);\n        if(z.y>5.)al=vec3(1),spa=0.;\n        if(z.y>6.)al=vec3(.1,.2,.4)*.5,spa=sspa=1.;\n        float dif=max(0.,dot(no,ld)),\n            fr=pow(1.+dot(no,rd),4.),\n            sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n        co=mix(sp*spa+al*(a(.05)*a(.2)+.2)*(dif*vec3(.6,.7,.9)+s(.5)*sspa*2.),fo,min(fr,.5));\n        co=mix(fo,co,exp(-.00008*t*t*t));\n    }\n    fragColor = vec4(pow(co+g*.2*vec3(.1,.3,.9)+ggg*.2*vec3(.7,.3,.2),vec3(.65)),1);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtcDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 272, 311, 311, 359], [386, 386, 422, 422, 476], [477, 477, 513, 513, 569], [570, 570, 587, 587, 630], [631, 631, 654, 654, 874], [875, 875, 901, 901, 4047], [4048, 4048, 4075, 4075, 4264], [4360, 4360, 4417, 4417, 5641]]}
{"id": "3dVcRD", "name": "easing scan line", "author": "z4none", "description": "a easing scan line demo", "tags": ["line", "scan", "easing", "scaner"], "likes": 1, "viewed": 41, "published": "Public", "date": "1602349267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float remainder (float f, float div) {\n    while(f > div) {\n        f -= div;\n    }\n    return f;\n}\nfloat pointy (float f) {\n    return 0.01/(abs(f)+0.01);\n}\n\nfloat vMag (vec4 v) {\n    return v.x*v.x + v.y*v.y + v.z*v.z;\n}\n\nfloat cubicInOut(float t) {\n  return t < 0.5\n    ? 4.0 * t * t * t\n    : 0.5 * pow(2.0 * t - 2.0, 3.0) + 1.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 tex = texture(iChannel0, uv ).xyz; \n    vec3 col = vec3(0.0);    \n    float r = remainder(iTime*0.3, 1.0);    \n    float f = abs(uv.x - cubicInOut(r));\n    col = vec3(pointy(f));\n    col = tex + col;\n    fragColor = vec4(col, 0);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVcRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 99], [100, 100, 124, 124, 157], [159, 159, 180, 180, 222], [224, 224, 251, 251, 335], [337, 337, 394, 394, 675]]}
{"id": "3dVyRw", "name": "Accidental Dragons", "author": "Blake447", "description": "Accidentally ended up with a dragon curve in a weird way while trying to make a dragon curve in a different weird way. Thought it looked cool so I transferred it over to GLSL and made it spin", "tags": ["fractal", "dragon", "curve", "dragoncurve", "harter", "heighway"], "likes": 7, "viewed": 98, "published": "Public", "date": "1602707710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 T(vec2 v, int dir)\n{\n\tvec2 double_point = v;\n\n\tfloat index_0 = mod(((v.x + v.y) + 4096.0), 2.0);\n\n\n\tfloat x_proj = floor(( v.x + v.y) / 4.0 + 0.5*(float(dir) + 1.0));\n\tfloat y_proj = floor((-v.x + v.y) / 4.0 + 0.5*(float(dir) + 1.0));\n\n\n    vec2 coord_back = x_proj * vec2(1.0, 1.0)*2.0 + y_proj * vec2(-1.0, 1.0)*2.0;\n    vec2 half_point = coord_back;\n\n    float index = mod((x_proj + y_proj + 4096.0 + float(dir)), 2.0);\n    float direction = 1.0 - 2.0 * index;\n    vec2 offset = v - half_point;\n    vec2 rotated = half_point + vec2(offset.x + offset.y * direction, offset.y - offset.x * direction);\n\n    vec2 new_coord = vec2(floor(rotated.x + rotated.y)/2.0, floor(rotated.y - rotated.x) / 2.0);\n\n\n    return new_coord;\n}\n\n\nvec2 rotate45(vec2 p, vec2 c, float dir)\n{\n \tvec2 v = p-c;\n    return c + vec2(v.x + v.y*dir, v.y - v.x*dir);\n    \n}\n\nfloat DE(vec2 p)\n{\n    vec2 comparison = vec2(clamp(p.x, -1.0, 1.0), 0.0);\n    \n\treturn length(p-comparison);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_init = fragCoord/iResolution.xy;\n    \n    vec2 start = vec2(-0.5, -0.5);\n    vec2 end = vec2(0.5, 0.5);\n    \n    // Generate a p within our viewing window with corrected aspect ratio\n    vec2 uv = (start + (end-start)*uv_init) *vec2(iResolution.x/iResolution.y, 1.0);\n\n    float speed = -0.05;\n    float theta = iTime * speed;\n    uv = vec2(uv.x*cos(theta) - uv.y*sin(theta), uv.x*sin(theta) + uv.y*cos(theta));\n    \n    \n    float size = 4096.0;\n    vec2 mapping = vec2(float(floor(uv.x/2.0*size)) * 2.0, float(floor(uv.y / 2.0*size))*2.0);\n    \n    vec2 p0 = mapping + vec2(0.0, 1.0);\n    vec2 p1 = mapping + vec2(1.0, 0.0);\n    vec2 p2 = mapping + vec2(1.0, 2.0);\n    vec2 p3 = mapping + vec2(2.0, 1.0);\n\n    vec2 v0 = p0;\n    vec2 v1 = p1;\n    vec2 v2 = p2;\n    vec2 v3 = p3;\n    \n    const int ITERATIONS = 23;\n    \n    for (int j = 0; j < ITERATIONS; j++)\n    {\n        v0 = T(v0, 0);\n        v1 = T(v1, 0);\n        v2 = T(v2, 0);\n        v3 = T(v3, 0);\n\n        uv = (vec2(uv.x + uv.y, uv.y - uv.x) / 2.0);\n    }\n    \n    vec2 a = vec2(0.0, 1.0);\n\n    float d0 = length(v0 / float(size) - uv) * size;\n    float d1 = length(v1 / float(size) - uv) * size;\n    float d2 = length(v2 / float(size) - uv) * size;\n    float d3 = length(v3 / float(size) - uv) * size;\n\n\tfloat dist = min(min(d0, d1), min(d2, d3));\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\n    float SCALE = 150.0;\n    // Output to screen\n    fragColor = vec4(vec3(1.0, 1.0 ,1.0)*dist / length(p0-v0)*SCALE,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVyRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 25, 25, 730], [733, 733, 775, 775, 849], [851, 851, 869, 869, 962], [965, 965, 1022, 1072, 2617]]}
{"id": "3dVyWG", "name": "raymachtutor", "author": "geranyan", "description": "pass", "tags": ["comma"], "likes": 2, "viewed": 97, "published": "Public", "date": "1603642631", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdElipsoid(in vec3 pos, vec3 rad){\n\nfloat k0 = length(pos/rad);\nfloat k1 = length(pos/rad/rad);\n\n    return k0* (k0-1.0)/k1;\n}\n\nfloat smin(float a, float b, float k){\n\nfloat h = max(k - abs(a-b), 0.0);\nreturn min(a,b) - h*h/(k * 4.0);\n}\nfloat sdGuy(in vec3 pos){\n\nfloat t = 0.5; //fract(iTime);\n\nfloat y = 4.0*t*(1.0 - t);\n\nfloat dy = 4.0*(1.0 - 2.0*t);\n\nvec2 u = normalize(vec2(1.0, -dy));\n\nvec2 v = vec2(dy, 1.0);\n\nvec3 cen = vec3(0.0, 0.0, 0.0);\n\nfloat sy = 0.5 + 0.5*y;\n\nfloat sz = 1.0/sy;\n\nvec3 rad = vec3(0.25, 0.25*sy, 0.25*sz);\n\nvec3 q = pos - cen;\n\n//q.yz = vec2(dot(u, q.yz), dot(v, q.yz));\n\nfloat d = sdElipsoid(q,rad);\n\nvec3 h = q - vec3(0.0, 0.28, 0.0);\n\nfloat d2 = sdElipsoid(h, vec3(0.2));\n\nd = smin(d, d2, 0.15);\nreturn d;\n\n\n}\nfloat map(in vec3 pos){\n\nfloat d1 = sdGuy(pos);\n\nfloat d2 = pos.y - (-0.25);\n\n\nreturn min(d1, d2); // объединение\n}\n\nvec3 calcNormal(in vec3 pos){\n\nvec2 e = vec2(0.0001, 0.0);\nreturn normalize( vec3(map(pos + e.xyy)-map(pos - e.xyy),\nmap(pos + e.yxy)-map(pos - e.yxy),\nmap(pos + e.yyx)-map(pos - e.yyx) ) );\n}\n\nfloat rayMarch(in vec3 ro, in vec3 rd){\nfloat t = 0.0;\n//ray march loop\nfor(int i = 0; i < 100; i++) {\n\nvec3 pos = ro + t * rd;\n\n\nfloat h = map(pos);\nif(h < 0.001){\nbreak;\n}\nt += h;\nif(t >20.0){\nbreak;\n}\n\n}\nif(t > 20.0){\nt = -1.0;\n}\n\nreturn t;\n\n}\n\n\nvec4 galaxy(vec2 dir){\n\tvec2 pos = vec2(dir.x,dir.y-0.5);\n\tfloat t =  iTime*0.1;\n\tfloat si = sin(t);\n\tfloat co = cos(t);\n\tmat2 ma = mat2(co, si, -si, co);\n    \n    \n    float v1, v2, v3;\n\tv1 = v2 = v3 = 0.0;\n\t\n\tfloat s = 1.0;\n\tfor (int i = 0; i < 90; i++)\n\t{\n\t\tvec3 p = s * vec3(pos, 1.0);\n\t\tp.xy *= ma;\n\t\tp += vec3(.22, .3, s - 1.5 - sin( .13) * .1);\n\t\tfor (int i = 0; i < 8; i++)\tp = abs(p) / dot(p,p) -0.665;\n\t\tv1 += dot(p,p) * .0015 * (1.8 + sin(length(pos.xy ) + .5  ));\n\t\tv2 += dot(p,p) * .0013 * (1.5 + sin(length(pos.xy) + 1.2 ));\n\t\tv3 += length(p.xy*10.) * .0003;\n\t\ts  += 0.020;\n\t}\n    float len = length(pos);\n\tv1 *= smoothstep(.7, .0, len);\n\tv2 *= smoothstep(.5, .0, len);\n\tv3 *= smoothstep(.9, .0, len);\n\t\n\tvec3 col = vec3( v3 * (1.5 + sin(iTime * .2) * .4),\n\t\t\t\t\t(v1 + v3) * .3,\n\t\t\t\t\t v2) + smoothstep(0.2, .0, len) * .85 + smoothstep(.0, .6, v3) * .3;\n\t\n\treturn vec4(min(pow(abs(col), vec3(1.2)), 1.0), 1.0) ;\n\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\nvec2 p = (2.0 * fragCoord - iResolution.xy)/iResolution.y; //получаем пиксель\n\nfloat an = 10.0 * iMouse.x/iResolution.x;\n\n\nvec3 ro = vec3(2.0*sin(an), 0.2, 2.0* cos(an)); //положение камеры\n\n\n\nvec3 ta = vec3(0.0, 0.75, 0.0); // target for camera\n\n\nvec3 ww = normalize(ta - ro);\nvec3 uu = normalize( cross(ww, vec3(0,1,0)));\nvec3 vv = normalize( cross(uu, ww));\n\n\n\nvec3 rd = normalize(p.x*uu + p.y*vv + 1.5*ww); //-1.5 - глубина\n\n\n\n\n\n\n\nvec3 col = vec3(0.0001, 0.001, 0.01); //градиент на небе(оно не может быть однородным везде)\n\ncol = mix (col, vec3(0.0,0.0, 0.06), exp(-10.0*rd.y)); // линия горизонта\n\nfloat t = rayMarch(ro, rd);\n\nif(t > 0.0){\n\nvec3 pos = ro + t * rd;\nvec3 nor = calcNormal(pos);\n\nvec3 mate = vec3(0.18);\n\nvec3 sun_dir = normalize(vec3(0.8, 0.4, 0.2) );\nfloat sun_dif = clamp( dot (nor, sun_dir), 0.0, 0.1);\nfloat sun_shadow = step(rayMarch(pos + 0.001*nor, sun_dir),0.0);\nfloat sky_dif = clamp( 0.5 + dot (nor, vec3(0.0,1.0,0.0)), 0.0, 1.0); //0.5 + чтобы сдеелать более мягкую растушевку\nfloat bounce_dif = clamp( 0.5 + dot (nor, vec3(0.0,-1.0,0.0)), 0.0, 1.0); // тот же свет что и от неба только снизу координата -1\n\n    \n\n\n    \n    \n    \ncol = mate * vec3(7.0, 4.5, 3.0) * sun_dif * sun_shadow;\n\ncol += mate * vec3(0.5, 0.8, 0.9) * sky_dif;\n\ncol += mate * vec3(0.7, 0.3, 0.2) * bounce_dif;\n\n\n}\n\ncol = pow(col, vec3(0.4545));\n    \nvec4 galaxy_dir = galaxy(p);\n\nfragColor = vec4(col,1.0) +galaxy_dir ;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVyWG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 133], [135, 135, 173, 173, 243], [244, 244, 269, 269, 749], [750, 750, 773, 773, 876], [878, 878, 907, 907, 1070], [1072, 1072, 1111, 1111, 1318], [1321, 1321, 1343, 1343, 2248], [2250, 2250, 2307, 2307, 3902]]}
{"id": "3dVyWV", "name": "Checkerboard and Mirror Sphere", "author": "diabolix17", "description": "Infinite checkerboard and sphere rendered with very simple raytracing", "tags": ["raytracing"], "likes": 2, "viewed": 63, "published": "Public", "date": "1603798024", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 intersect_plane(vec3 origin, vec3 ray){\n    \n    if(ray.y == 0.0){\n        return vec3(0.0,0.0,1.0);\n    }\n    float a = -origin.y/ray.y;\n    if(a <= 0.0){\n        return vec3(0.0,1.0,1.0);\n    }\n    ivec2 grid_coord = ivec2(floor((origin + a*ray).xz));\n    int grid = abs(grid_coord.x % 2) ^ abs(grid_coord.y % 2);\n    return (grid != 0) ? vec3(0.0, min(10.0/a, 1.0), 0.0) : vec3(0.0, 0.0, 0.0);\n}\n\nvec3 intersect_sphere(vec3 origin, vec3 ray){\n    \n    ray = normalize(ray);\n    //vec3 center = vec3(cos(iTime), cos(0.5*iTime) + 2.0, sin(iTime) + 3.0);\n    vec3 center = vec3(4.0*(iMouse.xy / iResolution.xy - vec2(0.5)) + vec2(0.0, 1.0), 2.0*iTime + 2.5);\n    //float radius = 0.5*cos(iTime) + 0.6;\n    float radius = 1.0;\n    center.y = max(center.y, radius);\n\n    float a = 1.0;\n    float b = 2.0 * dot(ray, origin - center);\n    float c = dot(origin - center, origin - center) - radius*radius;\n    float disc = b*b - 4.0*a*c;\n    if(disc <= 0.0){\n        return intersect_plane(origin, ray);\n    }\n    float s = (-b - sqrt(disc))/(2.0*a);\n    if(s <= 0.0){\n        s = (-b + sqrt(disc))/(2.0*a);\n        if(s <= 0.0){\n            return intersect_plane(origin, ray);\n        }\n    }\n    vec3 intersection = origin + s*ray;\n    vec3 normal = normalize(intersection - center);\n    vec3 ray2 = 2.0*dot(normal, -ray)*normal + ray;\n    return 0.6*intersect_plane(intersection, ray2);\n}\n\n#define NUM_SAMPLES 4\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv = floor(300.0*uv)/300.0;\n\n    mat3 rot = mat3(vec3(cos(iTime), 0.0, -sin(iTime)), vec3(0.0, 1.0, 0.0), vec3(sin(iTime), 0.0, cos(iTime)));\n    vec3 ray = vec3(2.0*(uv - vec2(0.5)), 1.0);\n    //ray = rot*ray;\n    //vec3 origin = vec3(0.0, cos(iTime) + 2.0, 0.0);\n\tvec3 origin = vec3(0.0, 1.5, 2.0*iTime);\n    \n    vec2 pixeldim = vec2(1.0/iResolution.x, 1.0/iResolution.y);\n    vec3 ray_curr = ray;\n    vec3 col = vec3(0.0);\n    for(int i = 0; i < NUM_SAMPLES; i++){\n        for(int j = 0; j < NUM_SAMPLES; j++){\n     \n        \tcol += intersect_sphere(origin, ray_curr);\n            ray_curr += vec3(pixeldim.x/float(NUM_SAMPLES), 0.0, 0.0);\n        }\n        ray_curr.x = ray.x;\n        ray_curr += vec3(0.0, pixeldim.y/float(NUM_SAMPLES), 0.0);\n    }\n    col /= float(NUM_SAMPLES*NUM_SAMPLES);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVyWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 44, 44, 403], [405, 405, 450, 450, 1391], [1416, 1416, 1473, 1523, 2406]]}
{"id": "3dVyWz", "name": "SDF Morphing", "author": "oneshade", "description": "Wait what?!? You can interpolate SDFs? Now I am starting to see the power in using math!", "tags": ["3d", "raymarching", "sdf", "morphing"], "likes": 4, "viewed": 125, "published": "Public", "date": "1602601669", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThis shader uses an older version of my Raymarcher Template (https://www.shadertoy.com/view/3styDs)\nand I do not plan on implementing the newer features as they are not necessary.\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1000.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2000.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 500;\n\n// Signed Distance Functions (SDFs):\nfloat udPlane(in vec3 p, in vec3 n) {\n    return abs(dot(n, normalize(p))) * length(p);\n}\n\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    return max(abs(p.x) - 0.5 * w, max(abs(p.y) - 0.5 * h, abs(p.z) - 0.5 * d));\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    return max(abs(p.y) - 0.5 * h, length(p.xz) - r);\n}\n\nfloat sdTorus(in vec3 p, in float r1, in float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nfloat Union(in float sdf1, in float sdf2) {\n    return min(sdf1, sdf2);\n}\n\nfloat Subtraction(in float sdf1, in float sdf2) {\n    return max(sdf1, -sdf2);\n}\n\nfloat Intersection(in float sdf1, in float sdf2) {\n    return max(sdf1, sdf2);\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\nvec3 Scale(in vec3 p, in vec3 s) {\n    return p / s;\n}\n\n// Scene mapping function:\nfloat mapScene(in vec3 p) {\n    p = Rotate(p, vec3(vec2(iTime * 20.0), 0.0));\n    float interpVal = 1.5 + sin(iTime * 0.5) * 1.5;\n    float cube = sdCuboid(p, 200.0, 200.0, 200.0);\n    float cylinder = sdCylinder(p, 200.0, 100.0);\n    float torus = sdTorus(p, 100.0, 50.0);\n    float sphere = sdSphere(p, 100.0);\n    float shape1 = cube;\n    float shape2 = cylinder;\n    if (interpVal >= 1.0 && interpVal < 2.0) {\n        interpVal -= 1.0;\n        shape1 = cylinder;\n        shape2 = torus;\n    }\n\n    if (interpVal >= 2.0 && interpVal <= 3.0) {\n        interpVal -= 2.0;\n        shape1 = torus;\n        shape2 = sphere;\n    }\n\n    return mix(shape1, shape2, interpVal);\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy);\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy);\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx);\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Material calculation functions:\nvec3 calculateAmbient(in vec3 p, in vec3 normal) {\n    return 0.5 + 0.5 * normal;\n}\n\nvec3 calculateDiffuse(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 calculateSpecular(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nfloat calculateShininess(in vec3 p, in vec3 normal) {\n    return 0.0;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in vec3 ro, in vec3 rd) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ro + rd * distanceTraveled;\n        float distanceToClosest = mapScene(currentPosition);\n        if (distanceToClosest < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n\n            // Illumination is calculated using the Phong illumination model.\n            vec3 materialAmbient = calculateAmbient(currentPosition, normal);\n            vec3 materialDiffuse = calculateDiffuse(currentPosition, normal);\n            vec3 materialSpecular = calculateSpecular(currentPosition, normal);\n            float materialShininess = calculateShininess(currentPosition, normal);\n\n            vec3 illuminationAmbient = materialAmbient * lightColor;\n            float lambertian = max(0.0, dot(normal, lightDirection));\n            vec3 illuminationDiffuse = lambertian * materialDiffuse * lightColor;\n            vec3 reflection = reflect(lightDirection, normal);\n            float specularAngle = max(0.0, dot(reflection, rd));\n            vec3 illuminationSpecular = pow(specularAngle, materialShininess) * materialSpecular * lightColor;\n\n            return vec4(illuminationAmbient + illuminationDiffuse + illuminationSpecular, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += distanceToClosest;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = rayMarch(rayOrigin, rayDirection);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVyWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[775, 812, 849, 849, 901], [903, 903, 966, 966, 1049], [1051, 1051, 1104, 1104, 1160], [1162, 1162, 1214, 1214, 1270], [1272, 1272, 1311, 1311, 1339], [1341, 1389, 1432, 1432, 1462], [1464, 1464, 1513, 1513, 1544], [1546, 1546, 1596, 1596, 1626], [1628, 1648, 1686, 1686, 1706], [1708, 1708, 1743, 1743, 2354], [2356, 2356, 2390, 2390, 2410], [2412, 2439, 2466, 2466, 3111], [3113, 3162, 3195, 3195, 3525], [3527, 3562, 3612, 3612, 3645], [3647, 3647, 3697, 3697, 3731], [3733, 3733, 3784, 3784, 3818], [3820, 3820, 3873, 3873, 3891], [3893, 3914, 3953, 3953, 5431], [5433, 5466, 5521, 5521, 5841]]}
{"id": "3dycDh", "name": "Yab and YCH", "author": "thepheer", "description": "YCH ↔ Yab ↔ RGB color conversion.\n\nhttps://acescentral.com/knowledge-base-2/lmts-part-4-how-do-they-work-and-how-are-they-made/\n", "tags": ["color", "rgb", "yab", "ych"], "likes": 3, "viewed": 202, "published": "Public API", "date": "1602686406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const mat3 Yab_TO_RGB = mat3(3., 3., 3., 4., -2., -2., 0., sqrt(3.), -sqrt(3.))/3.;\nconst mat3 RGB_TO_Yab = mat3(4., 6., 0., 4., -3., 6.*sqrt(3.), 4., -3., -6.*sqrt(3.))/12.;\n\nvec3 Yab_to_RGB(vec3 Yab) { return Yab_TO_RGB*Yab; }\nvec3 RGB_to_Yab(vec3 rgb) { return RGB_TO_Yab*rgb; }\n\nvec3 YCH_to_Yab(vec3 YCH) { return vec3(YCH.x, YCH.y*vec2(cos(YCH.z), sin(YCH.z))); }\nvec3 Yab_to_YCH(vec3 Yab) { return vec3(Yab.x, length(Yab.yz), atan(Yab.z, Yab.y)); }\n\nvec3 YCH_to_RGB(vec3 YCH) { return Yab_to_RGB(YCH_to_Yab(YCH)); }\nvec3 RGB_to_YCH(vec3 rgb) { return Yab_to_YCH(RGB_to_Yab(rgb)); }\n\nvoid mainImage(out vec4 rgba, vec2 xy) {\n\tconst float tau = radians(360.0);\n    vec2 uv = xy/iResolution.xy;\n    vec3 hsl = vec3(uv.x, 0.5 + 0.5*cos(iTime), uv.y);\n    vec3 ych = vec3(hsl.z, hsl.y*hsl.z*(1.0-hsl.z), tau*hsl.x);\n   \tvec3 rgb = YCH_to_RGB(ych);\n    rgba = vec4(rgb, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dycDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[176, 176, 203, 203, 228], [229, 229, 256, 256, 281], [283, 283, 310, 310, 368], [369, 369, 396, 396, 454], [456, 456, 483, 483, 521], [522, 522, 549, 549, 587], [589, 589, 629, 629, 877]]}
{"id": "3dycW1", "name": "VOTE", "author": "PixelPhil", "description": "This is a simple shader to address a simple message to my American friends.\nMake yourself and the world a favor, go vote, fight authoritarianism and bigotry, claim your country back.\nhttps://www.usa.gov/how-to-vote", "tags": ["flag", "ballot", "vote", "usa"], "likes": 11, "viewed": 266, "published": "Public API", "date": "1602835809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// 🗳️ VOTE 🇺🇸 by Philippe Desgranges\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n\n// This is a simple shader to address a simple message to my American friends.\n// Make yourself and the world a favor, go vote, fight authoritarianism, claim your country back.\n// https://www.usa.gov/how-to-vote\n\n\n#define S(a, b, t) smoothstep(a, b, t)\n#define sat(a) clamp(a, 0.0, 1.0)\n\nfloat star(vec2 uv)\n{\n    float aa = iResolution.x * 0.03;\n    \n    uv.x = -abs(uv.x);\n    \n    vec2 n  = normalize(vec2(1.0, -0.35));\n    vec2 n2 = normalize(vec2(-0.7, 1.0));\n    \n    float dot1 = sat(dot(uv - vec2(0.0, 1.0), n) * aa);\n    \n    float dot2 = sat(dot(uv + vec2(0.0, 0.351), n2) * aa);\n    \n    \n    float star1 = dot1 * dot2 ;\n    \n    float dot3 = sat((0.32 - uv.y) * aa);\n    \n    uv.x = -uv.x;\n\tfloat dot4 = sat(dot(uv  + vec2(0.0, 0.351), n2) * aa);\n    \n    \n    float star2 = dot3 * dot4 ;\n    \n    return sat(star1 + star2);\n}\n\n\nvec3 flag(vec2 uv)\n{\n    float stripe;\n    \n    float aa = 10.0 / iResolution.x;\n    \n    stripe = S(0.25 -aa, 0.25 + aa, abs(fract(uv.y * 6.5 + 0.25) - 0.5));\n    \n    vec2 boxUV = vec2(uv.x * 2.2, (1.0 - uv.y) * (13.0 / 7.0));\n    \n    float aa2 = aa * 0.2;\n    float square = S(1.0 + aa2, 1.0 - aa2, boxUV.x);\n    square *= S(1.0 + aa2, 1.0 - aa2, boxUV.y);\n    \n    vec2 starsTile =  boxUV * vec2(6.0, 5.0);\n    \n    vec2 starsUv = (fract(starsTile) - vec2(0.5)) * vec2(4.0, 3.0);\n    \n    starsUv.y = -starsUv.y;\n    \n    float stars = star(starsUv);\n    \n    \n    starsTile -= vec2(0.5);\n    starsTile.x = clamp(starsTile.x, 0.0, 5.0);\n    starsTile.y = clamp(starsTile.y, 0.0, 4.0);\n    \n    vec2 starsUv2 = (fract(starsTile) - vec2(0.5)) * vec2(4.0, 3.0);\n    starsUv2.y = -starsUv2.y;\n    \n    stars += star(starsUv2);\n    \n    vec3 starsCol = mix(vec3(0.2, 0.1, 0.6), vec3(1.0), stars);\n    \n    vec3 col = mix(vec3(0.8, 0.1, 0.2), vec3(1.0), stripe);\n    col = mix(col, starsCol, square);\n    \n    return vec3(col);\n}\n\n\n\nfloat sdCapsule( vec2 p, vec2 a, vec2 b, float r )\n{\n  vec2 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\n\nfloat voteDst(vec2 uv)\n{\n\n    \n    float r = 0.5;\n    float dst = sdCapsule(uv, vec2(0.0,3.0), vec2(1.5,0.0), r);\n    dst = min(dst, sdCapsule(uv, vec2(3.0,3.0), vec2(1.5,0.0), r));\n    \n    \n    dst = min(dst, sdCapsule(uv, vec2(8.0,3.0), vec2(11.0,3.0), r));\n    dst = min(dst, sdCapsule(uv, vec2(9.5,3.0), vec2(9.5,0.0), r));\n    \n    dst = min(dst, sdCapsule(uv, vec2(12.5,0.0), vec2(12.5,3.0), r));\n    \n    dst = min(dst, sdCapsule(uv, vec2(12.5,3.0), vec2(14.5,3.0), r));\n    dst = min(dst, sdCapsule(uv, vec2(12.5,0.0), vec2(14.5,0.0), r));\n    dst = min(dst, sdCapsule(uv, vec2(12.5,1.5), vec2(13.5,1.5), r));\n    \n    dst = min(dst, abs(length(uv - vec2(5.5, 1.5)) - 1.5) - 0.5);\n              \n    return dst;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    \n    float yUv = uv.y + 0.5;\n    \n    \n    vec2 flagsUv = uv * vec2(0.3, 0.5) * 1.3 + vec2(0.5);\n    \n    float t = iTime * 0.3;\n    vec2 wave = vec2(sin(uv.y * 1.3 + t * 0.5) * 0.5, sin(uv.x * 4.0 + t * 4.0));\n    \n    wave += vec2(sin(uv.y * 4.3 + t * 3.6) * 0.25, sin(uv.x * 3.2 + t * 6.2)* 0.5);\n    \n    //wave = vec2(sin(uv.y + iTime), sin(uv.x + iTime)) * 0.1;\n    \n    \n    float fakeShading = mix(0.6, 1.3, S(1.0, -1.0, dot(wave, vec2(-0.7, 0.5))));\n    \n    \n    flagsUv += wave * 0.02;\n    \n    vec2 flagMaskXY = (vec2(0.5) - abs(flagsUv - vec2(0.5))) * 200.0;\n\n    float flagMask = sat(flagMaskXY.x) * sat(flagMaskXY.y);\n    \n    vec3 flagCol = flag(flagsUv) * fakeShading * vec3(0.9, 0.9, 1.1);\n    \n    vec3 bg = mix(vec3(0.3, 0.4, 1.0),  vec3(0.0, 0.0, 1.0),  yUv);\n    \n    bg.rgb += (uv.y * uv.y + uv.x * 0.1) * 0.6;\n    \n    bg.rgb *= S(2.5, 1.0, length(uv * vec2(1.0, 1.5))) * 0.6 + 0.4;\n    \n\n    \n    // Time varying pixel color\n    //vec3 col = vec3(star(uv.xy));\n    \n    //vec3 col = vec3(flag(uv.xy));\n    \n    vec3 col = mix(bg, flagCol, flagMask);\n    \n    float vote = voteDst(uv * 5.0 + vec2(7.25, 1.5));\n    \n\n    col = mix(vec3(0.0), col, S(-1.2, 1.0, vote));\n    \n    \n    float aa = 15.0 / iResolution.x;\n    \n    float outline = 0.2;\n    col = mix(vec3(0.0), col, S(outline -aa, outline +aa, vote));\n    col = mix(vec3(1.0), col, S(-aa, aa, vote));\n    \n\n    col.rgb = pow(col.rgb, vec3(0.7));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n    //fragColor.rgb = vec3(vote(uv));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dycW1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[142, 430, 451, 451, 980], [983, 983, 1003, 1003, 2011], [2015, 2015, 2067, 2067, 2188], [2191, 2191, 2215, 2215, 2913], [2915, 2915, 2972, 2972, 4575]]}
{"id": "3dyyWK", "name": "crazy bit operator patterns", "author": "izutionix", "description": "I have almost no idea why all of this this happens..", "tags": ["xor", "bit", "bitshift"], "likes": 3, "viewed": 54, "published": "Public", "date": "1603710890", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define T iTime\n#define F iFrame\n#define R iResolution\n\nvoid mainImage( out vec4 O, in vec2 U )\n{\n    ivec2 u = ivec2(U);\n    \n    int bd = u.x<<u.y;\n    int bu = u.x>>u.y;\n    int x = u.x^u.y;\n    int a = u.x&u.y;\n    int o = u.x|u.y;\n    int m = u.x%u.y; // not a bit operator I know\n    \n    // reversing the order\n\tint rbd = u.y<<u.x;\n    int rbu = u.y>>u.x;\n    int rm = u.y%u.x;\n\n    //O = vec4(float(bd>>o+1+F)/R.x);\n    //O = vec4(float(rm>>m+F)/R.x);\n    //O = vec4(float(F+u.y+u.x<<o>>a)/R.x); //\n    //O = 1e5/O;\n    O = vec4(float(o>>a&(F+1023))/R.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyyWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 58, 99, 99, 567]]}
{"id": "3l2BWc", "name": "rendering's edge", "author": "scanlime", "description": "just weird junk", "tags": ["glitch", "ambient"], "likes": 2, "viewed": 55, "published": "Public", "date": "1603306309", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 empty() { return vec4(0.,0.,0.,1e20); }\nvec4 inv(vec4 a) { return vec4(a.xyz, -a.w); }\nvec4 un(vec4 a, vec4 b) { return a.w < b.w ? a : b; }\nvec4 isect(vec4 a, vec4 b) { return a.w > b.w ? a : b; }\nvec4 diff(vec4 a, vec4 b) { return isect(a, inv(b)); }\n\nvec4 sphere(vec3 matl, vec3 p, float r) { return vec4(matl, length(p) - r); }\nvec4 box(vec3 matl, vec3 p, vec3 r, float o) { return vec4(matl, length(max(vec3(0.), abs(p)-r+o))-o); }\nvec4 plane(vec3 matl, vec3 p) { return vec4(matl, p.y); }\n\nmat3 rotX(float a) { float s = sin(a), c = cos(a); return mat3(1.,0.,0.,0.,c,-s,0.,s,c); }\nmat3 rotY(float a) { float s = sin(a), c = cos(a); return mat3(c,0.,s,0.,1.,0.,-s,0.,c); }\nmat3 rotZ(float a) { float s = sin(a), c = cos(a); return mat3(c,-s,0.,s,c,0.,0.,0.,1.); }\n\nvec4 scene(vec3 p)\n{\n    p -= vec3(0., -10., 3.);\n  \tp *= rotX(.8 + .2*sin(iTime*.1));\n    p *= rotY(iTime * 0.04);\n\n    float a =  length(p) * 0.4 - iTime * .2 + atan(p.x,p.z) * 50.;\n    vec4 r = plane(vec3(1., .6, .2), p + vec3(0., .9*sin(a), 0.));\n        \n    return r;\n}\n\nvec3 shade(vec3 p, vec4 r)\n{\n\tconst vec2 e = vec2(0.01, 0.);\n    const vec3 light = normalize(vec3(1.,1.,-2.));\n                    \n\tvec3 grad = (vec3(scene(p+e.xyy).w, scene(p+e.yxy).w, scene(p+e.yyx).w) - vec3(r.w)) / e.x;\n    float diff = .8 * dot(grad, light);\n    float spec = 2. * pow(dot(grad, light), 20.);\n    \n    return r.xyz * diff + r.xyz * spec;\n}\n\nvoid mainImage(out vec4 color, in vec2 coord)\n{\n    vec2 uv = (coord/iResolution.xy - vec2(.5)) * vec2(iResolution.x / iResolution.y, 1.);\n\tfloat fov = 1.1 + 0.8 * sin(iTime*.2);\n    vec3 view = normalize(vec3(uv.xy, 1./fov));\n\n\tint iter = 0;\n    vec3 p = vec3(0.);\n    while (++iter < 15) {\n   \t  \tvec4 r = scene(p);\n        if (abs(r.w) < .01) {\n           \tcolor.rgb = shade(p, r);\n   \t \t\tcolor.rgb *= sqrt(1.0 - dot(uv,uv));\n\t\t   \tcolor.rgb = pow(color.rgb, vec3(.8));\n           \treturn;\n\t    }\n        p += view * r.w;\n    }\n    color.rgb = vec3(.4) + mod(p*p*.01, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3l2BWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 14, 14, 44], [45, 45, 63, 63, 91], [92, 92, 117, 117, 145], [146, 146, 174, 174, 202], [203, 203, 230, 230, 257], [259, 259, 300, 300, 336], [337, 337, 383, 383, 441], [442, 442, 473, 473, 499], [501, 501, 521, 521, 591], [592, 592, 612, 612, 682], [683, 683, 703, 703, 773], [775, 775, 795, 795, 1050], [1052, 1052, 1080, 1080, 1414], [1416, 1416, 1463, 1463, 1993]]}
{"id": "3s2SzV", "name": "Tokyo World  Wave Warp", "author": "strata", "description": "plasma shader for Tokyo World Site", "tags": ["plasma"], "likes": 0, "viewed": 57, "published": "Public", "date": "1602676880", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float th = 1.0/3.0;\n    float speed = iTime/2.0;\n    \n    vec2 mouse = iMouse.xy/iResolution.xy;\n    \n    //uv += mouse;\n    \n    uv.x *= 0.5 - 0.6*cos(uv.y*5.0 + speed) + 0.15*sin(uv.y*7.9 - speed*0.8) - 0.9*sin(uv.x*3.0 + speed*0.1);\n    uv.x *= 0.9*cos(uv.y*3.0 + speed*0.1) + 1.0;\n    //uv.x *= 0.4*sin(uv.x*3.2 + speed*0.1);\n    \n    uv.x *= 0.5 - 0.6*sin(uv.x*1.0 + speed*0.1 + 3.0) - 0.6*cos(uv.y*1.0 + speed*0.1 + 3.0);\n    //uv.x *= 0.5 - 0.6*sin(uv.x*1.0 + speed*0.1 + 3.0*mouse.x) - 0.6*cos(uv.y*1.0 + speed*0.1 + 3.0*mouse.y);\n        \n    uv *= 7.0;\n    uv = fract(uv);\n    \n    \n    vec3 yellow = vec3(1.0, 0.8745, 0.3608);\n    vec3 orange = vec3(1.0, 0.6706, 0.4863);\n    vec3 pink   = vec3(1.0, 0.4784, 0.6824);  \n    \n    \n    float r1 = 1.0 - step(th, uv.x);\n    float r2 = 1.0 - step(th*2.0, uv.x) - r1;\n    float r3 = 1.0 - step(th*3.0, uv.x) - r1 - r2;\n    \n    yellow *= r1;\n    orange *= r2;\n    pink   *= r3;\n    \n    vec3 col = vec3(yellow + orange + pink);\n    \n    \n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s2SzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1212]]}
{"id": "3s3Bzn", "name": "Broken chains", "author": "jarble", "description": "This fractal resembles a rusted or corroded chain-like structure.", "tags": ["fractal", "chain", "bones"], "likes": 4, "viewed": 250, "published": "Public API", "date": "1604113752", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\nconst int MAX_MARCHING_STEPS = 255;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat sceneSDF1(vec3 p) {\n    return (length(sin(p.yzx)+cos(p))-.6);\n}\n\nfloat sceneSDF(vec3 p){\n\tfloat result = sceneSDF1(p);\n    for(float i = 3.0; i < 81.0; i *= -3.0){\n        result = min(result, sceneSDF1(p/i)*i);\n    }\n    return -result;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p *= 50.0;\n    return sin(vec3(sceneSDF1(p/7.0),sceneSDF1(p/11.0),sceneSDF1(p/13.0)));\n}\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);\n    \n    vec3 light2Pos = vec3(2.0 * sin(0.37),\n                          2.0 * cos(0.37),\n                          2.0);\n    vec3 light2Intensity = vec3(0.4, 0.4, 0.4);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light2Pos,\n                                  light2Intensity);    \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    vec3 eye = vec3(10.0*sin(iTime/10.0), 10.0*sin(iTime/10.0), 10.0*cos(iTime/10.0));\n    \n    mat3 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 10.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3Bzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[182, 422, 447, 447, 492], [494, 494, 517, 517, 668], [670, 670, 698, 698, 791], [793, 1214, 1305, 1305, 1611], [1626, 1880, 1945, 1945, 2077], [2079, 2168, 2197, 2197, 2507], [2509, 3001, 3141, 3141, 3731], [3733, 4103, 4188, 4188, 4946], [4948, 5275, 5324, 5359, 5490], [5492, 5492, 5549, 5549, 6409]]}
{"id": "3s3cD2", "name": "Soft shadows 2D test", "author": "athibaul", "description": "Testing soft shadow methods in 2D clearly reveals the artifacts of the method used. Left is iq's method (for which the shadows are too dark), right is mine. Both exhibit the same kind of problems inherent to raymarching.", "tags": ["raymarching", "sdf", "softshadows"], "likes": 3, "viewed": 128, "published": "Public", "date": "1603968028", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool IQ_SHADOWS;\n\n\nfloat map(vec2 p)\n{\n    float d = 100.;\n    for(float i=0.; i<20.; i++)\n    {\n        vec3 c = texelFetch(iChannel0, ivec2(mod(i,256.),1.+i/256.), 0).xyz*2.-1.;\n        float di = length(p-c.xy) - 0.1*sqrt(c.z);\n        d = min(d, di);\n    }\n    return d;\n}\n\n\nfloat softShadow(vec2 p, vec2 sun, float softness, float tmax)\n{\n    float shadow = 1.0;\n    float d, t=0.0;\n    float w0 = 0.0; // Unused\n    for(int i=0; i<50; i++)\n    {\n        d = map(p+t*sun);\n        float w = t*softness + w0;\n        if(IQ_SHADOWS)\n            shadow = min(shadow, clamp((d+w0)/w, 0., 1.));\n        else\n        \tshadow = min(shadow, smoothstep(-w,w,d+w0));\n       \tt += max(d,0.02);\n        if(shadow < 0.001 || t > tmax ) break;\n    }\n    return shadow;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    IQ_SHADOWS = fragCoord.x < iResolution.x*.5;\n    \n    float d = map(p);\n    float v = smoothstep(-0.01,0.01,d);\n    vec3 col = vec3(v);\n    \n    float th = iTime;\n    //vec2 sun = normalize(vec2(cos(th),sin(th)));\n    vec2 ligPos = sin(iTime*vec2(1.,1.6));\n    vec2 ligDir = normalize(ligPos-p);\n    float ligDist = length(ligPos-p)-0.1;\n    col *= softShadow(p, ligDir, 0.2, ligDist) * 0.5/(ligDist*ligDist);\n\n    col = 1.-exp(-col);\n    col = mix(col, vec3(1,0,0), smoothstep(2.,0.,abs(fragCoord.x - iResolution.x*.5)));\n    col = sqrt(col);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3cD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 38, 38, 276], [279, 279, 343, 343, 761], [764, 764, 821, 821, 1485]]}
{"id": "3s3yD2", "name": "Plaid-Warp", "author": "celifrog", "description": "yes\nYou can make it spaz out by clicking your mouse around. ", "tags": ["fun", "original"], "likes": 2, "viewed": 184, "published": "Public API", "date": "1601706554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = iResolution.xy/fragCoord-iResolution.xy+iMouse.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 90.5/cos(uv.xxx/uv.yyy*uv.yyy-iTime-uv.xyx-uv.xyx*vec3(10,12,4));\n\n    // Output to screen\n    fragColor = vec4(uv.yyy*col*iTime*uv.xyx,11.0/uv.xxx);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3yD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 378]]}
{"id": "3s3yDj", "name": "Simple Mandelbrot Renderer", "author": "space928", "description": "Just a quick and simple mandelbrot set renderer, nothing particularly special about it.", "tags": ["mandelbrot"], "likes": 2, "viewed": 56, "published": "Public", "date": "1601683791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Thomas M.\nconst int testIters = 512;\nconst vec2 zoomVec = vec2(0.348,0.5);\n\n//Taken from: https://www.chilliant.com/rgb2hsv.html\nvec3 hueToRgb(float H)\n{\n    float R = abs(H * 6. - 3.) - 1.;\n    float G = 2. - abs(H * 6. - 2.);\n    float B = 2. - abs(H * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    uv = uv*2.-1.;\n    uv.x -= 1.5;\n    \n    //Zoom in\n    uv /= exp(iTime);\n    uv += zoomVec;\n\n    //Z is a complex number and must be treated as such and not as a standard vector\n    vec2 z = vec2(0.);\n    float outp = 0.;\n    for(int i = 0; i < testIters; i++)\n    {\n        //z = z^2 + uv\n        float zxPrev = z.x;\n        z.x = z.x*z.x - z.y*z.y;\n        z.x += uv.x;\n        z.y = 2.*z.y*zxPrev;\n        z.y += uv.y;\n        \n        if(length(z) <= 2.0)\n            outp += 1./float(testIters);\n    }\n    \n    vec3 col = hueToRgb(fract(outp));\n    \n    /*if(length(z) > 2.0)\n        col = vec3(0.);\n    else\n        col = vec3(1.);*/\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3yDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 131, 155, 155, 307], [309, 309, 366, 416, 1162]]}
{"id": "3sccWf", "name": "mandelbumb", "author": "maxim", "description": "mandelbrot set", "tags": ["mandelbrotset"], "likes": 1, "viewed": 86, "published": "Public", "date": "1601829601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXITER 7000.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    float t = max(-2.,iTime-3.);\n    \n    float zoom = pow(1.5,-t);\n    uv *= zoom;\n    uv += vec2(-.732228,.217);\n    \n\n    vec2 c = uv;\n    \n    const vec3 yelow = vec3(240., 230., 140.)/256.;\n    const vec3 pink = vec3(255., 168., 175.)/256.;\n    const vec3 blue = vec3(0., 166., 147.)/256.;\n    \n    vec2 z = vec2(0);\n    float iter = 0.;\n    \n    vec3 col = vec3(0);\n    \n    //col = vec3(smoothstep()) \n    \n    for(float i = 0.; i < MAXITER; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.*z.x*z.y) + c;\n        \n        if (length(z) > 16.) break;\n        \n        iter++;\n    }\n    \n    if(iter < MAXITER)col = sqrt(vec3(iter/MAXITER) * blue);\n   \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sccWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[23, 23, 80, 80, 861]]}
{"id": "3scyD2", "name": "Fab5 #inktober2020 \"blade\" 485ch", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: \n[img]https://i.imgur.com/b3gMiu0.png[/img]\n", "tags": ["short", "golf", "inktober2020"], "likes": 2, "viewed": 235, "published": "Public API", "date": "1601738528", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define D         clamp( 1. - R.y*max(V.x,V.y), 0.,1.)     //\n#define v(X,Y)    R/R.y*vec2(X,Y)                          //\n#define B(X,Y)  ( V = U - v(X,Y), D )                      //\n#define b(X,Y)    O = max(O, B(X,Y) );                      \\\n                  V = abs( v(X,Y) - U ) - .05,              \\\n                  O = clamp( O+C( v(X,Y)-.05, .05 ) -  D, 0.,1.);    //\n#define C(C,r)    max(0., 1.-R.y* ( length(C-U) - r ) )    //\n#define I(X)      U = abs(v-v(X,0)); O -= B(.025,.15) + C(v(0,.15),.04); //\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = abs( u+u - R ) / R.y, v = U, V;\n    vec4 O = o;\n    b(.7,.4) b(.6,.7)               /* core  */\n    O -= B(.6,.07);                 /* slit  */\n    O -= C(v(.6,.45),.05)           /* notch */\n      +  C(,.14) + C(v(.45,0),.14); /* round holes  */\n    I(.3) I(.6)                     /* narrow holes */\n    o = O * (.6+.4*sin(4.*(u.x-u)/R - iTime)).y;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scyD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[520, 520, 556, 556, 950]]}
{"id": "3scyWf", "name": "JustHemp", "author": "Michel3324", "description": "\nJust Hemp Learn about hemp, CBD, and cannabinoids on our Blog focuses on providing accurate and up-to-date information about the hemp industry.\nhttps://www.justhemp.org/\n\n", "tags": ["httpswwwjusthemporg"], "likes": 0, "viewed": 44, "published": "Public", "date": "1601827317", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 294]]}
{"id": "3sdcRl", "name": "Spidron Hexagon", "author": "timeisbeautifulhere", "description": "So I herd you like regular geometry.\n\nCode is a bloody mess but I finally got my beautiful Spidron Hexagon going.\n\nMight add fun colors later.", "tags": ["triangle", "spiral", "hexagon", "regular", "spidron"], "likes": 11, "viewed": 248, "published": "Public API", "date": "1601516266", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//https://en.wikipedia.org/wiki/Spidron#/media/File:Spidron_Hexagon.JPG\n\n//No fun constants to play with, sorry :(\n#define PI 3.14159\n#define START_CIRCUMRADIUS 3.0\n\n#define LINE_WIDTH 0.005\n\n#define RAD(deg) (deg*PI/180.0)\n\n#define TIME_CONST 1.5\n\n//Magic numbers for identifying points on/in triangles\n#define ON_TRIANGLE 123\n#define NOT_IN_TRIANGLE -1\n\nfloat THIRTY = RAD(30.0);\nfloat SIXTY = RAD(60.0);\n\n//Find closest point on a line segment, given a point p3.\n//Then compute whether it is \"on\" the line by computing\n//distance from the segment.\n//Thank you Paul Bourke http://paulbourke.net/geometry/pointlineplane/\nbool on_segment(vec2 p1, vec2 p2, vec2 p3, float thickness){\n    float u = ((p3.x-p1.x)*(p2.x-p1.x) +\n               \t(p3.y-p1.y)*(p2.y-p1.y)) /\n        \t\tpow(length(vec2(p2.x-p1.x, p2.y-p1.y)),2.0);\n    \n    //Check within bounds of segment\n    if(u<0.0||u>1.0)\n        return false;\n    \n    vec2 point_on_line = vec2(\n        p1.x + u*(p2.x-p1.x),\n        p1.y + u*(p2.y-p1.y)\n    );\n\treturn distance(point_on_line, p3)<=thickness;\n}\n\n//Check if uv inside triangle using barycentric coords\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nbool in_triangle(vec2 p1, vec2 p2, vec2 p3, vec2 uv){\n    \n    //Delicious math\n    float l1 =\n        ((p2.y-p3.y)*(uv.x-p3.x)+(p3.x-p2.x)*(uv.y-p3.y))/\n        ((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));\n    \n    float l2 = \n        ((p3.y-p1.y)*(uv.x-p3.x)+(p1.x-p3.x)*(uv.y-p3.y))/\n        ((p2.y-p3.y)*(p1.x-p3.x)+(p3.x-p2.x)*(p1.y-p3.y));\n    \n    float l3 = 1.0 - l1 - l2;\n    \n    return l1>=0. && l1<=1. &&\n        l2>=0. && l2<=1. &&\n        l3>=0. && l3<=1.;\n}\n\n//Cross product to see if point is on left side of segment\n//https://stackoverflow.com/a/3461533\nbool isLeft(vec2 p1, vec2 p2, vec2 p3){\n     return ((p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x)) > 0.0;\n}\n\n//Return kth point of hexagon by rotating\n//it along the circumradius\nvec2 hex_point(int k, float radius, float rotation){\n    \n    float deg = float(k)*SIXTY + rotation;\n    \n    float x = -1.0*cos(deg) - 0.0*sin(deg),\n        y = -1.0*sin(deg) - 0.0*cos(deg);\n    \n    return vec2(\n        x*radius,\n        y*radius\n    );\n}\n\n//Find closest hex point uv would be near by\n//calculating its rotation.\n//ie, if uv was 60 degrees from origin, it'd be at the\n//second hexagon point.\nint hex_point_n(vec2 uv, float rotation){\n    float point_rads = atan(uv.y,uv.x) + PI - rotation;\n    point_rads = mod(point_rads, 2.0*PI);\n    \n    return int(round(point_rads/SIXTY));\n}\n\n//hex_point_n, but floor instead of round\nint prev_hex_point_n(vec2 uv, float rotation){\n    float point_rads = atan(uv.y,uv.x) + PI - rotation;\n    point_rads = mod(point_rads, 2.0*PI);\n    \n    return int(floor(point_rads/SIXTY));\n}\n\n\n//Circumradius of nth hexagon in spidron hexagon.\nfloat circumradius_n(float circumradius, int n){\n    float R = circumradius;\n    \n    //Size of subsequent hexagons is a geometric series\n    //derived from the difference of the inradius and the\n    //height of the isosceles triangle touching the outer hexagon.\n    //Math simplified into a constant.\n    \n    float series_const = (cos(THIRTY) - (tan(THIRTY)/2.0));\n    \n    return R * pow(series_const, float(n));\n}\n\n//Circumradius of next hexagon in spidron hexagon\nfloat next_circumradius(float circumradius){\n    float R = circumradius;\n    float series_const = (cos(THIRTY) - (tan(THIRTY)/2.0));\n    \n    return R * series_const;\n}\n\n//Find closest hexagon a point would be near\nint closest_hex(vec2 uv, float start_radius){\n    \n    //Treating circumradius of hexagons as a \n    //geometric series x=aq^n, find n using logs\n    //https://math.stackexchange.com/a/447670\n    float x = length(uv),\n        a = start_radius,\n        q = (cos(THIRTY) - (tan(THIRTY)/2.0));\n    \n    float n = (log(x) - log(a))/log(q);\n    \n    int hex_num = int(floor(n));\n    \n    //Found the correct circumradius we're in,\n    //now check if it's outside the hexagon bounds\n    \n    //Get points of closest hex edge\n    float rotation=0.0;\n    if(hex_num%2==1)\n        rotation = THIRTY;\n    float circumradius = circumradius_n(start_radius,hex_num);\n    int hex_k = prev_hex_point_n(uv, rotation);\n    vec2 p1 = hex_point(hex_k, circumradius, rotation),\n        p2 = hex_point(hex_k+1, circumradius, rotation);\n    \n    //If it's outside, this belongs to the\n    //previous outer hexagon\n    if(!isLeft(p1,p2,uv))\n       hex_num -= 1;\n    \n    return hex_num;\n}\n\n//Determine if uv is on a hexagon edges for a given circumradius\nbool on_hex(vec2 uv, float circumradius, float rotation){\n    \n    int p1_k = prev_hex_point_n(uv, rotation);\n    \n    vec2 p1=hex_point(p1_k%6, circumradius, rotation),\n        p2=hex_point((p1_k+1)%6, circumradius, rotation);\n    \n    return on_segment(p1,p2,uv, LINE_WIDTH);\n}\n\n//Check if uv is on or near an equilateral triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint in_equilateral(vec2 uv, float circumradius, float rotation){\n    \n    //Points of closest equilateral can be derived from current\n    //and \"next\" (smaller) hexagon.\n    //Points are are hex point n of cur hexagon,\n    //n-1 of next hexagon, and n of next hexagon\n    \n    float next_radius = next_circumradius(circumradius);\n    float next_rotation = mod(rotation + THIRTY, 2.0*PI);\n    if(next_rotation<0.0)\n        next_rotation+= 2.0*PI;\n    \n    int cur_n = hex_point_n(uv, rotation),\n        next_n = cur_n;\n    \n    vec2 p1 = hex_point(cur_n, circumradius, rotation),\n        p2 = hex_point(next_n-1, next_radius, next_rotation),\n        p3 = hex_point(next_n, next_radius, next_rotation);\n    \n    if(in_triangle(p1,p2,p3,uv))\n        return cur_n%6;\n    \n    if(on_segment(p1,p2,uv,LINE_WIDTH) ||\n        on_segment(p2,p3,uv,LINE_WIDTH) ||\n        on_segment(p3,p1,uv,LINE_WIDTH))\n        return ON_TRIANGLE;\n    \n    return NOT_IN_TRIANGLE;\n}\n\n//Check if uv is on or near an isosceles triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint in_isosceles(vec2 uv, float circumradius, float rotation){\n    \n    //Points of closest isosceles can be derived from current\n    //and \"next\" (smaller) hexagon.\n    //Points are are hex point n of cur hexagon,\n    //n+1 of cur hexagon, and n of next hexagon\n    \n    float next_radius = next_circumradius(circumradius);\n    float next_rotation = mod(rotation + THIRTY, 2.0*PI);\n    if(next_rotation<0.0)\n        next_rotation+= 2.0*PI;\n    \n    int cur_n = prev_hex_point_n(uv, rotation),\n        next_n = cur_n;\n    \n    vec2 p1 = hex_point(cur_n, circumradius, rotation),\n        p2 = hex_point(cur_n+1, circumradius, rotation),\n        p3 = hex_point(next_n, next_radius, next_rotation);\n    \n    if(in_triangle(p1,p2,p3,uv))\n        return cur_n%6;\n    \n    if(on_segment(p1,p2,uv,LINE_WIDTH) ||\n        on_segment(p2,p3,uv,LINE_WIDTH) ||\n        on_segment(p2,p1,uv,LINE_WIDTH))\n        return ON_TRIANGLE;\n    \n    return NOT_IN_TRIANGLE;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // [-1,1]\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //Treat start_radius as a geometric series (x=aq^n)\n    //and linearly \"expand\" spidron by scaling n\n    float a = START_CIRCUMRADIUS,\n        q = (cos(THIRTY) - (tan(THIRTY)/2.0)),\n        n = -(iTime*TIME_CONST);\n    \n    //Loop it to avoid large numbers.\n    if(n<12.0)\n    \tn = -12.0 + mod(n, 12.0);\n    \n    //Start radius of first hexagon of structure\n    float start_radius = a * pow(q,n);\n\n    vec3 col = vec3(1.0);\n    \n    //Find which hexagon we're in\n    int closest = closest_hex(uv, start_radius);\n    float circumradius = circumradius_n(start_radius, closest);\n    float rotation = 0.0;\n    if(closest%2==1)\n        rotation = THIRTY;\n    \n    //Check if/which \"stripe\" we're in\n    //by checking if we're in any triangles\n    int on_stripe = -1;\n    \n    int eq_check = in_equilateral(uv, circumradius, rotation);\n    if(eq_check != NOT_IN_TRIANGLE && eq_check != ON_TRIANGLE){\n        on_stripe = eq_check;\n    }\n    \n    int iso_check = in_isosceles(uv, circumradius, rotation);\n    if(iso_check != NOT_IN_TRIANGLE && iso_check != ON_TRIANGLE){\n        on_stripe = iso_check;\n    }\n    \n    //Color\n    if(on_stripe != -1){\n        if(rotation>0.0)\n            on_stripe+=1;\n        on_stripe+=closest/2;\n        on_stripe%=6;\n        \n        float val = float(on_stripe)/6.0;\n        if(on_stripe%2==0){\n        \tcol=vec3(val,0.0,val);\n        }\n        else{\n            col=vec3(0.0,val,val);\n        }\n    }\n    \n    //Lines\n    if(eq_check == ON_TRIANGLE || on_hex(uv, circumradius, rotation))\n        col=vec3(1.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdcRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[409, 623, 683, 683, 1059], [1061, 1235, 1288, 1314, 1713], [1715, 1812, 1851, 1851, 1932], [1934, 2004, 2056, 2056, 2261], [2263, 2415, 2456, 2456, 2602], [2604, 2646, 2692, 2692, 2838], [2841, 2891, 2939, 2939, 3308], [3310, 3360, 3404, 3404, 3528], [3530, 3575, 3620, 3766, 4540], [4542, 4607, 4664, 4664, 4886], [4888, 5071, 5135, 5338, 6027], [6029, 6210, 6272, 6472, 7161], [7163, 7163, 7220, 7234, 8902]]}
{"id": "3sdyDS", "name": "3D inversion 2", "author": "FabriceNeyret2", "description": "3D inversion of a regular grid.\nmouse control or auto-rotate.", "tags": ["procedural", "3d", "raymarching", "displacement", "antialiasing", "volumetric", "vr", "hairs", "preintegration"], "likes": 9, "viewed": 262, "published": "Public API", "date": "1601640110", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of \"3D inversion\"  https://shadertoy.com/view/3ddyDS\n\n#define SQR(x)   ( (x)*(x) )\n#define CUB(x)   ( (x)*(x)*(x) )\n             \nfloat z, BR = 2.5;   // bounding sphere (0,0,0), 2.\nfloat map(vec3 p )\n{\n    vec3 q = 2. * p / dot(p,p);\n    z = length(q)/2.;                          // depth in sphere\n // q += .1*iTime; \n    q = abs( fract(q+.5)-.5 );\n    float f = min( length(q.xy), min(length(q.yz),length(q.xz)));\n    f = smoothstep(.05,.0,f);\n    return f;                        \n}\n\nvec3 sundir = normalize( vec3(0,0,-1) );\nvec2 coord;\n\n  #define sl  5.                               // transition slope transp/opaque\n  #define LUT(d) clamp( .5+sl*(d-.5), 0., 1. ) // transfer function\n\n                                               // integral of transfer function\n  #define intLUT(d0,d1) ( abs(d1-d0)<1e-5 ? 0. : ( I(d1) - I(d0) ) / (d1-d0) ) \n  #define C(d)    clamp( d, .5-.5/sl, .5+.5/sl )\n  #define I0(d) ( .5*d + sl*SQR(d-.5)/2. )\n  #define I(d)  ( I0(C(d)) + max(0.,d-(.5+.5/sl)) )\n\nfloat LUTs( float _d, float d ) { // apply either the simple or integrated transfer function\n    return intLUT(_d,d);\n/*  return coord.x > 0. \n             ?  LUT(d)        // right: just apply transfert function\n             :  intLUT(_d,d); // left: preintegrated transfert function\n*/\n}\n\nfloat intersect_sphere( vec3 O, vec3 D, vec3 C, float r )\n{\n\tfloat b = dot( O-=C, D ),\n\t      h = b*b - dot( O, O ) + r*r;\n\treturn h < 0. ? -1.             // no intersection\n\t              : -b - sqrt(h);\n}\n\nvec4 raymarch( vec3 ro, vec3 rd, vec3 bgcol, ivec2 px )\n{\n\tvec4 sum = vec4(0);\n\tfloat dt = .01,\n         den = 0., _den, lut,\n           t = intersect_sphere( ro, rd, vec3(0), BR );\n    if ( t == -1. ) return vec4(0); // the ray misses the object \n    t += 1e-5;                      // start on bounding sphere\n    \n    for(int i=0; i<500; i++) {\n        vec3 pos = ro + t*rd;\n        if(   sum.a > .99               // end if opaque or...\n           || length(pos) > BR ) break; // ... exit bounding sphere\n                                    // --- compute deltaInt-density\n        _den = den; den = map(pos); // raw density\n        float _z = z;               // depth in object\n        lut = LUTs( _den, den );    // shaped through transfer function\n        if( lut > .0                // optim\n          ) {                       // --- compute shading                  \n#if 0                               // finite differences\n            vec2 e = vec2(.3,0);\n            vec3 n = normalize( vec3( map(pos+e.xyy) - den,\n                                      map(pos+e.yxy) - den,\n                                      map(pos+e.yyx) - den ) );\n         // see also: centered tetrahedron difference: https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n            float dif = clamp( -dot(n, sundir), 0., 1.);\n#else                               // directional difference https://www.iquilezles.org/www/articles/derivative/derivative.htm\n         // float dif = clamp((lut - LUTs(_den, map(pos+.3*sundir)))/.6, 0., 1. ); // pseudo-diffuse using 1D finite difference in light direction \n            float dif = clamp((den - map(pos+.3*sundir))/.6, 0., 1. );             // variant: use raw density field to evaluate diffuse\n#endif\n/*\n            vec3  lin = vec3(.65,.7,.75)*1.4 + vec3(1,.6,.3)*dif,          // ambiant + diffuse\n                  col = vec3(.2 + dif);\n            col = mix( col , bgcol, 1.-exp(-.003*t*t) );   // fog\n*/            \n            vec3 col = exp(- .4*vec3(3,3,2) *(1.-z));      // dark with shadow\n         // vec3 col =   exp(- vec3(3,3,2) *(.8-_z));      // dark with depth\n                   //      *  exp(- 1.5 *(1.-z));\n         // vec3 col = vec3(1);\n            sum += (1.-sum.a) * vec4(col,1)* (lut* dt*10.); // --- blend. Original was improperly just den*.4;\n        }\n        t += dt;  // stepping\n    }\n\n    return sum; \n}\n\nmat3 setCamera( vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro),\n\t     cp = vec3(sin(cr), cos(cr),0),\n\t     cu = normalize( cross(cw,cp) ),\n\t     cv = cross(cu,cw);\n    return mat3( cu, cv, cw );\n}\n\nvec4 render( vec3 ro, vec3 rd, ivec2 px )\n{\n    // background sky  \n\tfloat sun = abs( dot(sundir,rd) );\n\tvec3 col = // vec3(.6,.71,.75) - rd.y*.2*vec3(1,.5,1) + .15*.5\n\t           //  + .2*vec3(1,.6,.1)*pow( sun, 8. );\n            +  vec3( .8 * pow( sun, 8. ) ); // dark variant\n\n    // clouds    \n    vec4 res = raymarch( ro, rd, col, px );  // render clouds\n    col = res.rgb + col*(1.-res.a);          // blend sky\n    \n    // sun glare    \n\tcol += .2*vec3(1,.4,.2) * ( .2 + pow( sun,3.) );\n\n    return vec4( col, 1. );\n}\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy,\n         p = ( 2.*U - R ) / R.y,\n         m = iMouse.z>0. ? 2.* iMouse.xy / R.xy\n                         : 1.+cos(.3*iTime+vec2(0,11));\n    coord = p;\n // O = vec4( map(vec3(4.*p,0)) ); return;\n    \n    // camera\n    vec3 ro = 4.*normalize(vec3(sin(3.*m.x), .4*m.y, cos(3.*m.x))),\n\t     ta = vec3(0, 0, 0);\n    mat3 ca = setCamera( ro, ta, 0. );\n    // ray\n    vec3 rd = ca * normalize( vec3(p,1.5) );\n    \n    O = render( ro, rd, ivec2(U-.5) );\n // if (floor(U.x)==floor(R.x/2.)) O = vec4(1,0,0,1); // red separator\n}\n\n#define mainVR(O,U,C,D) O = render( C, D, ivec2(U-.5) )", "image_inputs": [{"id": "XdX3Rr", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdyDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 193, 213, 213, 498], [751, 1009, 1042, 1101, 1298], [1300, 1300, 1359, 1359, 1507], [1509, 1509, 1566, 1566, 3894], [3896, 3896, 3942, 3942, 4104], [4106, 4106, 4149, 4173, 4630], [4632, 4632, 4670, 4670, 5219]]}
{"id": "3sGcD3", "name": "wobblyer thingy", "author": "UrbanClubProfessional", "description": "Remix of \"wobbly thing\" by avix.", "tags": ["procedural", "3d", "demoscene", "wobble", "demo", "remix", "glitch", "green", "fork", "weird", "party"], "likes": 2, "viewed": 192, "published": "Public API", "date": "1603843967", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define FARCLIP    45.0\n\n#define MARCHSTEPS 70\n#define AOSTEPS    9\n#define SHSTEPS    20\n#define SHPOWER    4.0\n\n#define PI         4.14\n#define PI2        PI*0.6    \n\n#define AMBCOL     vec3(2.0,2.0,2.0)\n#define BACCOL     vec3(2.0,2.0,2.0)\n#define DIFCOL     vec3(2.0,2.0,2.0)\n\n#define MAT1       2.0\n\n#define FOV 2.0\n\n\n/***********************************************/\nfloat rbox(vec3 p, vec3 s, float r) {\t\n    return length(max(abs(p)-s+vec3(r),0.0))-r;\n}\nfloat torus(vec3 p, vec2 t) {\n    vec2 q = vec2(length(p.xz)-t.x,p.y);\n    return length(q)-t.y;\n}\nfloat cylinder(vec3 p, vec2 h) {\n    return max( length(p.xz)-h.x, abs(p.y)-h.y );\n}\n\n/***********************************************/\nvoid oprep2(inout vec2 p, float l, float s, float k) {\n\tfloat r=2./l;\n\tfloat ofs=s+s/(r*3.0);\n\tfloat a= mod( atan(p.x, p.y) + PI2*r*k, PI*r) -PI2*r;\n\tp.xy=vec2(sin(a),cos(a))*length(p.xy) -ofs;\n\tp.x+=ofs;\n}\n\nfloat hash(float n) { \n\treturn fract(sin(n)*53758.5453123); \n}\n\nfloat noise3(vec3 x) {\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(4.0-3.0*f);\n    float n = p.x + p.y*67.0 + p.z*213.0;\n    float res = mix(mix(mix( hash(n+  0.0), hash(n+  2.0),f.x),\n                        mix( hash(n+ 67.0), hash(n+ 68.0),f.x),f.y),\n                    mix(mix( hash(n+213.0), hash(n+214.0),f.x),\n                        mix( hash(n+270.0), hash(n+271.0),f.x),f.y),f.z);\n    return res;\n}\n\nfloat sminp(float a, float b) {\n    const float k=0.2;\n    float h = clamp( 0.6+0.6*(b-a)/k, 0.0, 2.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n/***********************************************/\n\nvec2 DE(vec3 p) {\n    \n    //distortion\n    float d3=noise3(p*3.0 + iTime)*0.28;\n    //shape\n    float h=torus(p, vec2(4.0,2.5)) -d3;\n    float h2=torus(p, vec2(4.0,2.45)) -d3;\n        vec3 q=p.yzx; p.yz=q.yx;\n        oprep2(p.xy,42.0,0.25, 0.0);\n        oprep2(p.yz,24.0,0.25, 0.0);\n        float flag=p.z;\n        float k=rbox(p,vec3(0.06,0.06,2.0),0.0) ;\n        if (flag>0.2) k-=flag*0.28; else k-=0.02 ;\n\n    //pipes\n    p=q.zyx;\n\n    oprep2(p.xy,4.0,9.5, 4.0);\n    oprep2(p.xz,22.0,0.35, 0.0);\n        \n    p.y=mod(p.y,0.4)-0.6*0.4;\n    float k2=rbox(p,vec3(0.22,0.22,2.0),0.06) - 0.02;\n\n    p=q.xzy;\n    float r=p.y*0.03+sin(iTime)*0.06;\n        oprep2(p.zy,4.0,9.5, 0.0);\n    float g=cylinder(p,vec2(2.15+r,27.0)) - sin(p.y*2.3 - iTime*5.0)*0.2 -d3;\n    float g2=cylinder(p,vec2(2.05+r,28.0)) - sin(p.y*2.3 - iTime*5.0)*0.2 -d3;\n\n      float tot=max(h,-h2);\n      float sub=max(g,-g2);\n        float o=max(tot,-g);\n        float i=max(sub,-h);\n        \n            o=max(o,-k);\n            i=max(i,-k2);\n      \n      tot=sminp(o,i);\n\n\treturn vec2( tot*1.0 , MAT1);\n}\n/***********************************************/\nvec3 normal(vec3 p) {\n\tvec3 e=vec3(0.02,-0.02,0.0);\n\treturn normalize( vec3(\te.xyy*DE(p+e.xyy).x +\te.yyx*DE(p+e.yyx).x +\te.yxy*DE(p+e.yxy).x +\te.xxx*DE(p+e.xxx).x));\n}\n/***********************************************/\nfloat calcAO(vec3 p, vec3 n ){\n\tfloat ao = 0.0;\n\tfloat sca = 2.0;\n\tfor (int i=0; i<AOSTEPS; i++) {\n        \tfloat h = 0.02 + 2.2*pow(float(i)/float(AOSTEPS),2.5);\n        \tfloat dd = DE( p+n*h ).x;\n        \tao += -(dd-h)*sca;\n        \tsca *= 0.75;\n    \t}\n   return clamp( 2.0 - 2.0*ao, 0.0, 2.0 );\n //  return clamp(ao,0.0,1.0);\n}\n/***********************************************/\nfloat calcSh( vec3 ro, vec3 rd, float s, float e, float k ) {\n\tfloat res = 2.0;\n    for( int i=0; i<SHSTEPS; i++ ) {\n    \tif( s>e ) break;\n        float h = DE( ro + rd*s ).x;\n        res = min( res, k*h/s );\n    \ts += 0.03*SHPOWER;\n    }\n    return clamp( res, 0.0, 2.0 );\n}\n/***********************************************/\nvoid rot( inout vec3 p, vec3 r) {\n\tfloat sa=sin(r.y); float sb=sin(r.x); float sc=sin(r.z);\n\tfloat ca=cos(r.y); float cb=cos(r.x); float cc=cos(r.z);\n\tp*=mat3( cb*cc, cc*sa*sb-ca*sc, ca*cc*sb+sa*sc,\tcb*sc, ca*cc+sa*sb*sc, -cc*sa+ca*sb*sc,\t-sb, cb*sa, ca*cb );\n}\n/***********************************************/\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = -2.0 + 3.0 * fragCoord.xy / iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\t\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ro =vec3(0.0, 0.0, -25.0);\n\tvec3 lig=normalize(vec3(3.3, 4.0, 0.0));\n\t\n//\tvec2 mp=iMouse.xy/iResolution.xy;\n//\trot(ro,vec3(mp.x,mp.y,0.0));\n//\trot(lig,vec3(mp.x,mp.y,0.0));\n\t\n    float a=iTime*0.6;\n    float b=sin(iTime*0.35)*0.85;\n\trot(ro,vec3(a,b,0.0));\n\trot(lig,vec3(a,b,0.0));\n\n\tvec3 cf = normalize( ta - ro );\n    vec3 cr = normalize( cross(cf,vec3(0.0,2.0,0.0) ) );\n    vec3 cu = normalize( cross(cr,cf));\n\tvec3 rd = normalize( p.x*cr + p.y*cu + 3.5*cf );\n\n\tvec3 col=vec3(0.0);\n\t/* trace */\n\tvec2 r=vec2(0.0);\t\n\tfloat d=0.0;\n\tvec3 ww;\n\tfor(int i=0; i<MARCHSTEPS; i++) {\n\t\tww=ro+rd*d;\n\t\tr=DE(ww);\t\t\n        if( abs(r.x)<0.00 || r.x>FARCLIP ) break;\n        d+=r.x;\n\t}\n    r.x=d;\n\t/* draw */\n\tif( r.x<FARCLIP ) {\n\t    vec2 rs=vec2(0.3,2.0);  //rim and spec\n\t\tif (r.y==MAT1) { col=vec3(0.39,0.73,0.101);  } \n\n\t\tvec3 nor=normal(ww);\n\n    \tfloat amb= 2.0;\t\t\n    \tfloat dif= clamp(dot(nor, lig), 0.0,2.0);\n    \tfloat bac= clamp(dot(nor,-lig), 0.0,2.0);\n    \tfloat rim= pow(1.+dot(nor,rd), 4.0);\n    \tfloat spe= pow(clamp( dot( lig, reflect(rd,nor) ), 0.6, 2.0 ) ,26.0 );\n    \tfloat ao= calcAO(ww, nor);\n    \tfloat sh= calcSh(ww, lig, 0.02, 3.0, 5.0);\n\n\t    col *= 0.6*amb*AMBCOL*ao + 0.5*dif*DIFCOL*sh + 0.06*bac*BACCOL*ao;\n\t    col += 0.4*rim*amb * rs.x;\n    \tcol += 0.6*pow(spe,2.0)*sh * rs.y;\n        \n\t}\n\t\n\tcol*=exp(.09*-r.x); col*=3.0;\n\t\n\tfragColor = vec4( col, 2.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGcD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[323, 373, 410, 410, 461], [462, 462, 491, 491, 560], [561, 561, 593, 593, 645], [647, 697, 751, 751, 903], [905, 905, 926, 926, 967], [969, 969, 991, 991, 1393], [1395, 1395, 1426, 1426, 1542], [1545, 1596, 1613, 1635, 2670], [2671, 2721, 2742, 2742, 2888], [2889, 2939, 2969, 2969, 3269], [3270, 3320, 3381, 3381, 3595], [3596, 3646, 3679, 3679, 3907], [3908, 3958, 4015, 4015, 5527]]}
{"id": "3sGcDy", "name": "Lakes and forests", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/tsVyzc]\"Meandering Canyons\"[/url] shader.", "tags": ["fractal", "forest", "lake"], "likes": 1, "viewed": 217, "published": "Public API", "date": "1603589933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 20.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat heightmap(vec2 uv)\n{\n    \tuv /= 75.0;\n            float col;\n    float t = iTime*.1;\n    vec2 v1;\n\n        float factor = 1.5;\n        for(int i=0;i<9;i++)\n        {\n            v1 = uv.yx/factor;\n            uv *= -factor*factor;\n            uv += sin(uv.yx/factor)/factor;\n            col += sin(uv.x-uv.y+col+v1.y)+cos(uv.y-uv.x+v1.x);\n        }\n    return -col/2.0;\n}\n\nfloat sceneSDF(vec3 p) {\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n\n    return (-p.y+20.0-heightmap(p.xz))*.01/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    vec3 p1 = p;\n    p /= 100.0;\n    //p1.y *= 1000.0;\n    return vec3(heightmap(p.xz*100.0)+1.0)/20.0 + vec3(.0,.6-p.y,.5+p1.y);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.yz *= rot(3.14*0.666);\n    float speed = 2.0;\n    float t1 = speed*iTime+5.0;\n\tvec3 eye = vec3(-t1,-10,-t1*2.0);\n    eye.y -= 20.0;\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(0,5,1), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGcDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 491, 517, 517, 868], [870, 870, 894, 956, 1007], [1009, 1009, 1037, 1037, 1169], [1172, 1593, 1684, 1684, 1990], [2005, 2259, 2324, 2324, 2456], [2458, 2547, 2576, 2576, 2886], [2888, 3380, 3520, 3520, 4130], [4132, 4502, 4587, 4587, 5002], [5004, 5331, 5380, 5415, 5546], [5548, 5548, 5605, 5605, 6587]]}
{"id": "3sGcRz", "name": "Singulo", "author": "Redline", "description": "A WIP edition of the SS13 singularity as a shader.", "tags": ["wip", "animated", "blackhole", "ss13", "singularity"], "likes": 2, "viewed": 178, "published": "Public API", "date": "1602069369", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.14159265359\n#define tau (pi * 2.)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 cuv = (fragCoord/iResolution.xy - vec2(0.5)) * 2.;\n\n    // Time varying pixel color\n    float spiral = atan(cuv.x, cuv.y) / tau * 6. - iTime + length(cuv) * 3.;\n    float falloff = (1. - length(cuv));\n    vec3 col = (vec3((1. - abs(0.5 - mod(spiral, 1.))) + falloff) * falloff);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGcRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 48, 105, 155, 541]]}
{"id": "3sGyDt", "name": "upsideDownClouds", "author": "Kaeylos", "description": "#5 Sky\nmade during the Ink-MAC-tober 2020", "tags": ["raymarching", "volumetric", "imac"], "likes": 5, "viewed": 181, "published": "Public API", "date": "1603968667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired by iq, shane and otherds\n// https://www.shadertoy.com/view/XslGRr\n// https://www.shadertoy.com/view/MscXRH\n\n// #define LOW_QUALITY\n#define CLOUDS_LOD\n#define FBM_MAX_ITER  10\n\n#define MOUSE\n\n// ----- easingFunct -----//\nfloat quadin(float t) { return t*t;}\nfloat quadOut(float t) { return -t*(t-2.0);}\nfloat cubicIn(float t) { return t*t*t;}\nfloat cubicOut(float t) { return -t*t*t+1.0;}\nfloat circleOut(float t) { return pow(1.0-(1.0-t)*(1.0-t), 0.5); }\nfloat circleIn(float t) { return 1.0- pow(1.0-t*t, 0.5); }\nfloat gauss(float t, float s) { return exp(-(t*t*s*s)/2.); }\n// sub interpolation used in smoothstep\n#define hermiteInter(t) t * t * (3.0 - 2.0 * t)\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\n// ----- Useful functions ----- //\n#define rot2(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat max2(vec2 v) { return max(v.x , v.y); }\nfloat max3(vec3 v) { return max(max(v.x , v.y), v.z); }\nfloat dot2(vec2 v) { return dot(v,v); }\nfloat cro(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\nfloat map(float a, float b, float t) {return a + t * (b - a); } // considering that t is in [0-1]\nfloat mult2(vec2 v) { return v.x*v.y; }\nfloat mult3(vec3 v) { return v.x*v.y*v.z; }\n\n// ----- Noise stuff ----- //\n// Based on Morgan McGuire and David Hoskins\n// https://www.shadertoy.com/view/4dS3Wd\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash1(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash1(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash1(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash3(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash3(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hash4(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 hash4(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec4 p4) {\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat perlinNoise(float x) {\n    float id = floor(x);\n    float f = fract(x);\n    float u = f;\n    return mix(hash1(id), hash1(id + 1.0), u);\n}\n\nfloat perlinNoise(vec2 x) {\n    vec2 id = floor(x);\n    vec2 f = fract(x);\n\n\tfloat a = hash1(id);\n    float b = hash1(id + vec2(1.0, 0.0));\n    float c = hash1(id + vec2(0.0, 1.0));\n    float d = hash1(id + vec2(1.0, 1.0));\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = hermiteInter(f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat perlinNoise(vec3 x) {\n    const vec3 step = vec3(110., 241., 171.);\n\n    vec3 id = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(id, step);\n\n    vec3 u = hermiteInter(f);\n    return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm (vec2 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n    vec2 shift = vec2(100.);\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t\t// Rotate and shift to reduce axial bias\n\t\tx = rot2(0.5) * x + shift;\n\t}\n\treturn v / aSum;\n}\n\nfloat fbm (vec3 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t}\n\treturn v / aSum;\n}\n\nfloat density(vec3 pos, int lod) {\n\tvec3 q = pos - vec3(0.1,0.1,0.4)*iTime;\n\tfloat f = fbm(q, 1., lod);\n\tfloat f2 = fbm(q + vec3(100.), 1., lod);\n\treturn f * (smoothstep(1.5, 2., pos.y + f) + 1. - smoothstep(-1., -0.2, pos.y - 1.5*f2));\n    // return clamp( -0.5 - pos.y + 2.*f, 0.0, 1.0 );\n}\n\nvec4 cloudsMarching(vec3 ro, vec3 rd, vec3 bgCol, vec3 sundir, int steps) {\n\n\tfloat t = 0.;\n\tvec4 sum = vec4(0.);\n#ifdef LOW_QUALITY\n\tsteps = steps/2;\n#endif\n\n\tfor(int i=0; i<steps; i++) {\n\t\tvec3 pos = ro + t*rd;\n\t\t// clamp computation space\n\t   \tif( abs(pos.y)>3. || sum.a>0.99 ) break;\n\n#ifdef LOW_QUALITY\n\t\tint lod = 1;\n#else\n#ifdef CLOUDS_LOD\n\t    int lod = int(exp(-0.005*float((i-350))));\n#else\n\t    int lod = 3;\n#endif\n#endif\n\t\tfloat den = density(pos, lod);\n\t   \tif( den>0.01 ) {\n\t\t\t\n\t\t\t// mix color using density\n\t\t\tvec4  col = vec4( mix( vec3(1.0,0.95,0.8), vec3(0.25,0.3,0.35), den ), den );\n\t\t\t\n        \t// fake lighting using diff of density throught ou sunDir\n\t\t\tfloat dif = clamp((den - density(pos+0.3*sundir, lod))/0.3, 0.0, 1.0 );\n\t\t\tvec3 lin = vec3(0.91,0.98,1.1) + vec3(1.0,0.6,0.3)*dif;\n\t\t\tvec3 lightColor = mix(vec3(0.91,0.98,1.1), vec3(0.65,0.55,0.52)*2.4,dif*1.3);\n\t\t\t\n\t\t\tcol.xyz *= lightColor;\n\t\t\t// exponential decresing of density (mixing with bgcol)\n\t\t\tcol.xyz = mix( col.xyz, bgCol, 1.0-exp(-0.002*t*t) );\n\t\t\tcol.w *= 0.5; // reduce density alpha\n\t\t\tcol.rgb *= col.a; // apply alpha\n\t\t\tsum += col*(1.0-sum.a);\n\t\t}\n\t// Enforce minimum stepsize. This is probably the most important part of the procedure.\n#ifdef LOW_QUALITY\n\tt += max(0.1,0.05*t);\n#else\n\tt += max(0.05,0.02*t);\n#endif\n\t}\n\treturn sum;\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvec4 render(vec3 O, vec3 D) {\n\n\tvec3 sundir = normalize( vec3(-1.0,0.0,-1.0) );\n\t\n\tvec3 col = vec3(0.67,0.8,0.9) - D.y*0.4*vec3(0.5,0.2,0.8); // background sky color\n\tfloat sun = clamp( dot(sundir,D), 0.0, 1.0);\n\tcol += 0.3*vec3(1.0,.6,0.1)*pow(sun, 10.0); // add sun\n\n    vec4 res = clamp(cloudsMarching(O, D, col, sundir, 150), 0., 1.);\n    col = col*(1.0-res.w) + res.xyz;// clouds\n     \n\tcol += 0.1*vec3(1.0,0.4,0.2)*pow( sun, 3.0 ); // sun glare   \n\n    return vec4( col, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 1.5; // zoom\n\n#ifdef MOUSE\n    vec2 m = (iMouse.xy - .5*iResolution.xy)/iResolution.xy;\n    \n    // camera pos\n    vec3 O = 4.0*normalize(vec3(sin(2.5*m.x+1.), 0.15+m.y*0.15, cos(2.5*m.x+1.)));\n#else\n\tvec3 O = 4.0*vec3(2.5, 0.15, 1.);\n#endif\n    vec3 D = computeCamDir(uv, O, vec3(0., 1., 0.), vec3(0.));\n    \n    fragColor = render(O, D);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 232, 255, 255, 268], [269, 269, 293, 293, 313], [314, 314, 338, 338, 353], [354, 354, 379, 379, 399], [400, 400, 426, 426, 466], [467, 467, 492, 492, 525], [526, 526, 557, 557, 586], [755, 844, 864, 864, 889], [890, 890, 910, 910, 945], [946, 946, 966, 966, 985], [986, 986, 1012, 1012, 1040], [1041, 1041, 1079, 1079, 1104], [1105, 1139, 1160, 1160, 1178], [1179, 1179, 1200, 1200, 1222], [1224, 1382, 1404, 1404, 1489], [1491, 1491, 1512, 1512, 1629], [1631, 1631, 1653, 1653, 1756], [1758, 1758, 1779, 1779, 1907], [1909, 1909, 1929, 1929, 2062], [2064, 2064, 2085, 2085, 2204], [2206, 2206, 2227, 2227, 2360], [2362, 2362, 2382, 2382, 2518], [2520, 2520, 2541, 2541, 2665], [2667, 2667, 2688, 2688, 2831], [2833, 2833, 2853, 2853, 3002], [3004, 3004, 3024, 3024, 3173], [3175, 3175, 3196, 3196, 3330], [3332, 3332, 3360, 3360, 3475], [3477, 3477, 3504, 3504, 3899], [3901, 3901, 3928, 3928, 4694], [4696, 4696, 4738, 4738, 5087], [5089, 5089, 5131, 5131, 5379], [5381, 5381, 5415, 5415, 5673], [5675, 5675, 5750, 5750, 7003], [7005, 7005, 7075, 7075, 7354], [7356, 7356, 7385, 7385, 7841], [7843, 7843, 7900, 7900, 8310]]}
{"id": "3sGyDw", "name": "Person Apex Website Lattices", "author": "UrbanClubProfessional", "description": "Remix of \"Perspex Web Lattice\" by Shane", "tags": ["voronoi", "raymarch", "color", "remix", "glitch", "rainbow", "weird", "lattice", "web"], "likes": 7, "viewed": 419, "published": "Public API", "date": "1602929583", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tPerspex Web Lattice\n\t-------------------\n\t\n\tI felt that Shadertoy didn't have enough Voronoi examples, so I made another one. :) I'm\n\tnot exactly sure what it's supposed to be... My best guess is that an Alien race with no \n\tcommon sense designed a monitor system with physics defying materials. :)\n\n\tTechnically speaking, there's not much to it. It's just some raymarched 2nd order Voronoi.\n\tThe dark perspex-looking web lattice is created by manipulating the Voronoi value slightly \n\tand giving the effected region an ID value so as to color it differently, but that's about\n\tit. The details are contained in the \"heightMap\" function.\n\n\tThere's also some subtle edge detection in order to give the example a slight comic look. \n\t3D geometric edge detection doesn't really differ a great deal in concept from 2D pixel \n\tedge detection, but it obviously involves more processing power. However, it's possible to \n\tcombine the edge detection with the normal calculation and virtually get it for free. Kali \n\tuses it to great effect in his \"Fractal Land\" example. It's also possible to do a\n\ttetrahedral version... I think Nimitz and some others may have done it already. Anyway, \n\tyou can see how it's done in the \"nr\" (normal) function.\n\n\tGeometric edge related examples:\n\n\tFractal Land - Kali\n\thttps://www.shadertoy.com/view/XsBXWt\n\n\tRotating Cubes - Shau\n\thttps://www.shadertoy.com/view/4sGSRc\n\n\tVoronoi mesh related:\n\n    // I haven't really looked into this, but it's interesting.\n\tWeaved Voronoi - FabriceNeyret2 \n    https://www.shadertoy.com/view/ltsXRM\n\n*/\n\n#define FAR 2.\n\nint id = 0; // Object ID - Red perspex: 0; Black lattice: 1.\n\n\n// Tri-Planar blending function. Based on an old Nvidia writeup:\n// GPU Gems 3 - Ryan Geiss: https://developer.nvidia.com/gpugems/GPUGems3/gpugems3_ch01.html\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n   \n    n = max((abs(n) - .3), .002);\n    n /= (n.x + n.y + n.z ); // Roughly normalized.\n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    \n    // Loose sRGB to RGB conversion to counter final value gamma correction...\n    // in case you're wondering.\n    return p*p;\n}\n\n\n// Compact, self-contained version of IQ's 3D value noise function. I have a transparent noise\n// example that explains it, if you require it.\nfloat n3D(vec3 p){\n    \n\tconst vec3 s = vec3(8, 257, 213);\n\tvec3 ip = floor(p); p -= ip; \n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    p = p*p*(4. - 3.*p); //p *= p*p*(p*(p * 6. - 15.) + 10.);\n    h = mix(fract(sin(h)*53758.5453), fract(sin(h + s.x)*53758.5453), p.x);\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n}\n\n// vec2 to vec2 hash.\nvec2 hash22(vec2 p) { \n\n    // Faster, but doesn't disperse things quite as nicely. However, when framerate\n    // is an issue, and it often is, this is a good one to use. Basically, it's a tweaked \n    // amalgamation I put together, based on a couple of other random algorithms I've \n    // seen around... so use it with caution, because I make a tonne of mistakes. :)\n    float n = sin(dot(p, vec2(31, 289)));\n    //return fract(vec2(262144, 32768)*n); \n    \n    // Animated.\n    p = fract(vec2(362144, 42768)*n); \n    // Note the \".45,\" insted of \".5\" that you'd expect to see. When edging, it can open \n    // up the cells ever so slightly for a more even spread. In fact, lower numbers work \n    // even better, but then the random movement would become too restricted. Zero would \n    // give you square cells.\n    return sin( p*7.2831853 + iTime )*.55 + .6; \n    \n}\n\n// 2D 2nd-order Voronoi: Obviously, this is just a rehash of IQ's original. I've tidied\n// up those if-statements. Since there's less writing, it should go faster. That's how \n// it works, right? :)\n//\nfloat Voronoi(in vec2 p){\n    \n\tvec2 g = floor(p), o; p -= g;\n\t\n\tvec3 d = vec3(2); // 1.4, etc. \"d.z\" holds the distance comparison value.\n    \n\tfor(int y = -2; y <= 2; y++){\n\t\tfor(int x = -2; x <= 2; x++){\n            \n\t\t\to = vec2(x, y);\n            o += hash22(g + o) - p;\n            \n\t\t\td.z = dot(o, o); \n            // More distance metrics.\n            //o = abs(o);\n            //d.z = max(o.x*.8666 + o.y*.5, o.y);// \n            //d.z = max(o.x, o.y);\n            //d.z = (o.x*.7 + o.y*.7);\n            \n            d.y = max(d.x, min(d.y, d.z));\n            d.x = min(d.x, d.z); \n                       \n\t\t}\n\t}\n\t\n    return max(d.y/0.6 - d.x*0.5, 0.)/2.2;\n    //return d.y - d.x; // return 1.-d.x; // etc.\n    \n}\n\n// The height map values. In this case, it's just a Voronoi variation. By the way, I could\n// optimize this a lot further, but it's not a particularly taxing distance function, so\n// I've left it in a more readable state.\nfloat heightMap(vec3 p){\n    \n    id =0;\n    float c = Voronoi(p.xy*5.); // The fiery bit.\n    \n    // For lower values, reverse the surface direction, smooth, then\n    // give it an ID value of one. Ie: this is the black web-like\n    // portion of the surface.\n    if (c<.08) {c = smoothstep(0.8, 2., 2.-c)*.3; id = 2; }\n\n    return c;\n}\n\n// Standard back plane height map. Put the plane at vec3(0, 0, 1), then add some height values.\n// Obviously, you don't want the values to be too large. The one's here account for about 10%\n// of the distance between the plane and the camera.\nfloat m(vec3 p){\n   \n    float h = heightMap(p); // texture(iChannel0, p.xy/2.).x; // Texture work too.\n    \n    return 1. - p.z - h*.2;\n    \n}\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 nr(in vec3 p){\n\n    // Note the slightly increased sampling distance, to alleviate artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.005, -0.005); \n    return normalize(e.xyy * m(p + e.xyy) + e.yyx * m(p + e.yyx) + e.yxy * m(p + e.yxy) + e.xxx * m(p + e.xxx));\n}\n*/\n\n/*\n// Standard normal function - for comparison with the one below.\nvec3 nr(in vec3 p) {\n\tconst vec2 e = vec2(0.005, 0);\n\treturn normalize(vec3(m(p + e.xyy) - m(p - e.xyy), m(p + e.yxy) - m(p - e.yxy),\tm(p + e.yyx) - m(p - e.yyx)));\n}\n*/\n\n// The normal function with some edge detection rolled into it.\nvec3 nr(vec3 p, inout float edge) { \n\t\n    vec2 e = vec2(.006, 0);\n\n    // Take some distance function measurements from either side of the hit point on all three axes.\n\tfloat d1 = m(p + e.xyy), d2 = m(p - e.xyy);\n\tfloat d3 = m(p + e.yxy), d4 = m(p - e.yxy);\n\tfloat d5 = m(p + e.yyx), d6 = m(p - e.yyx);\n\tfloat d = m(p)*3.;\t// The hit point itself - Doubled to cut down on calculations. See below.\n     \n    // Edges - Take a geometry measurement from either side of the hit point. Average them, then see how\n    // much the value differs from the hit point itself. Do this for X, Y and Z directions. Here, the sum\n    // is used for the overall difference, but there are other ways. Note that it's mainly sharp surface \n    // curves that register a discernible difference.\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = max(max(abs(d1 + d2 - d), abs(d3 + d4 - d)), abs(d5 + d6 - d)); // Etc.\n    \n    // Once you have an edge value, it needs to normalized, and smoothed if possible. How you \n    // do that is up to you. This is what I came up with for now, but I might tweak it later.\n    edge = smoothstep(0., 2., sqrt(edge/e.x*3.));\n\t\n    // Return the normal.\n    // Standard, normalized gradient mearsurement.\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n/*\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat cAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for(float i=0.; i<5.; i++){\n    \n        float hr = .01 + i*.5/4.;        \n        float dd = m(n * hr + p);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp(1.0 - occ, 0., 1.);    \n}\n*/\n\n/*\n// Standard hue rotation formula... compacted down a bit.\nvec3 rotHue(vec3 p, float a){\n\n    vec2 cs = sin(vec2(1.570796, 0) + a);\n\n    mat3 hr = mat3(0.299,  0.587,  0.114,  0.299,  0.587,  0.114,  0.299,  0.587,  0.114) +\n        \t  mat3(0.701, -0.587, -0.114, -0.299,  0.413, -0.114, -0.300, -0.588,  0.886) * cs.x +\n        \t  mat3(0.168,  0.330, -0.497, -0.328,  0.035,  0.292,  1.250, -1.050, -0.203) * cs.y;\n\t\t\t\t\t\t\t \n    return clamp(p*hr, 0., 1.);\n}\n*/\n\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n    \n    vec3 sRd = rd; // Save rd, just for some mixing at the end.\n    \n    // Add a time component, scale, then pass into the noise function.\n    rd.xy -= iTime*.35;\n    rd *= 4.;\n    \n    //vec3 tx = tex3D(iChannel0, rd/3., sn);\n    //float c = dot(tx*tx, vec3(.299, .587, .114));\n    \n    float c = n3D(rd)*.67 + n3D(rd*3.)*.38 + n3D(rd*5.)*.25; // Noise value.\n    c = smoothstep(0.6, 2., c); // Darken and add contast for more of a spotlight look.\n    \n    //vec3 col = vec3(c, c*c, c*c*c*c).zyx; // Simple, warm coloring.\n    vec3 col = vec3(min(c*2.5, 2.), pow(c, 3.5), pow(c, 22.)).zyx; // More color.\n    \n    // Mix in some more red to tone it down and return.\n    return mix(col, col.yzx, sRd*7.35+.35); \n    \n}\n\nvoid mainImage(out vec4 c, vec2 u){\n\n    // Unit direction ray, camera origin and light position.\n    vec3 r = normalize(vec3(u - iResolution.xy*.6, iResolution.y)), \n         o = vec3(0), l = o + vec3(0, 0, -2);\n   \n    // Rotate the canvas. Note that sine and cosine are kind of rolled into one.\n    vec2 a = sin(vec2(2.570796, 0) + iTime/9.); // Fabrice's observation.\n    r.xy = mat2(a, -a.y, a.x) * r.xy;\n\n    \n    // Standard raymarching routine. Raymarching a slightly perturbed back plane front-on\n    // doesn't usually require many iterations. Unless you rely on your GPU for warmth,\n    // this is a good thing. :)\n    float d, t = 0.;\n    \n    for(int i=0; i<42;i++){\n        \n        d = m(o + r*t);\n        // There isn't really a far plane to go beyond, but it's there anyway.\n        if(abs(d)<0.002 || t>FAR) break;\n        t += d*.8;\n\n    }\n    \n    t = min(t, FAR);\n    \n    // Set the initial scene color to black.\n    c = vec4(0);\n    \n    float edge = 0.; // Edge value - to be passed into the normal.\n    \n    if(t<FAR){\n    \n        vec3 p = o + r*t, n = nr(p, edge);\n\n        l -= p; // Light to surface vector. Ie: Light direction vector.\n        d = max(length(l), 0.002); // Light to surface distance.\n        l /= d; // Normalizing the light direction vector.\n\n        \n \n        // Obtain the height map (destorted Voronoi) value, and use it to slightly\n        // shade the surface. Gives a more shadowy appearance.\n        float hm = heightMap(p);\n        \n        // Texture value at the surface. Use the heighmap value above to distort the\n        // texture a bit.\n        vec3 tx = tex3D(iChannel0, (p*3. + hm*.3), n);\n        //tx = floor(tx*15.999)/15.; // Quantized cartoony colors, if you get bored enough.\n\n        c.xyz = vec3(2.)*(hm*.09 + .03); // Applying the shading to the final color.\n        \n        c.xyz *= vec3(2.5)*tx; // Multiplying by the texture value and lightening.\n        \n        \n        // Color the cell part with a fiery (I incorrectly spell it firey all the time) \n        // palette and the latticey web thing a very dark color.\n        //\n        c.x = dot(c.xyz, vec3(.399, .687, .214)); // Grayscale.\n        if (id==0) c.xyz *= vec3(min(c.x*2.5, 2.), pow(c.x, 6.), pow(c.x, 34.))*3.;\n        else c.xyz *= .2;\n        \n        // Hue rotation, for anyone who's interested.\n        //c.xyz = rotHue(c.xyz, mod(iTime/16., 6.283));\n       \n        \n        float df = max(dot(l, n), 0.); // Diffuse.\n        float sp = pow(max(dot(reflect(-l, n), -r), 0.), 42.); // Specular.\n        \n        if(id == 1) sp *= sp; // Increase specularity on the dark lattice.\n        \n\t\t// Applying some diffuse and specular lighting to the surface.\n        c.xyz = c.xyz*(df + .85) + vec3(2, 1.97, 1.92)*sp + vec3(.6, .8, 2)*pow(sp, 42.);\n        \n        // Add the fake environmapping. Give the dark surface less reflectivity.\n        vec3 em = eMap(reflect(r, n), n); // Fake environment mapping.\n        if(id == 2) em *= .6;\n        c.xyz += em;\n        \n        // Edges.\n        //if(id == 0)c.xyz += edge*.1; // Lighter edges.\n        c.xyz *= 2. - edge*.9; // Darker edges.\n        \n        // Attenuation, based on light to surface distance.    \n        c.xyz *= 2./(2. + d*d*.225);\n        \n        // AO - The effect is probably too subtle, in this case, so we may as well\n        // save some cycles.\n        //c.xyz *= cAO(p, n);\n        \n    }\n    \n    \n    // Vignette.\n    //vec2 uv = u/iResolution.xy;\n    //c.xyz = mix(c.xyz, vec3(0, 0, .5), .1 -pow(16.*uv.x*uv.y*(1.-uv.x)*(1.-uv.y), 0.25)*.1);\n    \n    // Apply some statistically unlikely (but close enough) 2.0 gamma correction. :)\n    c = vec4(sqrt(clamp(c.xyz, 0., 2.)), 2.);\n    \n    \n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1649, 1807, 1857, 1857, 2172], [2175, 2318, 2336, 2336, 2682], [2684, 2706, 2727, 3076, 3579], [3581, 3783, 3808, 3808, 4505], [4507, 4729, 4753, 4753, 5067], [5069, 5312, 5328, 5328, 5455], [6054, 6118, 6153, 6153, 7424], [8323, 8700, 8728, 8728, 9453], [9455, 9455, 9490, 9552, 13171]]}
{"id": "3sGyRm", "name": "Sumpinski", "author": "samuelotherion", "description": "Again some Sieprinski Adaption.\n\nCaution!!!\nIf you watch too long then your world will rotate the other direction.\n\n@Fabrice: I know. It's too much unnecessary code for you! (O;", "tags": ["tutorial", "sierpinski"], "likes": 2, "viewed": 202, "published": "Public API", "date": "1602424735", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// height of a equilateral triangle\nconst float h = .5 * sqrt(3.);\n\nvoid mainImage(out vec4 o, in vec2 p) {\n\n    // want a black background\n    o = 0. * o;\n    \n    // use later for rotation\n    vec2 cs = vec2(cos(iTime), sin(iTime)),\n\t// scale centered axes\n         uv = (2.5 + 2.5 * sin(.3 * iTime)) * (2. * p / iResolution.xy - 1.) * vec2(iResolution.x / iResolution.y, 1);\n    \n    // points of the triangele: a, b, c\n    vec2 a = vec2(-1., -h),\n         b = vec2(+1., -h),\n         c = vec2(+0., +h),\n    // x and y axes and center z\n         x = b - a,\n         y = c - a,\n         z = (a + b + c) / 3.;\n    \n    // center all points of the triangle\n    a -= z; b -=z; c -= z;\n    \n    // rotate the world, so the triangle rotates back\n    uv *= mat2(cs.x, cs.y, -cs.y, cs.x);\n    \n    // trafo into triangle world\n    mat2 sierpinski = inverse(mat2(x, y));\n    \n    // apply trafo, with point 'a' as new origin\n    vec2 r = sierpinski * (uv - a);\n    \n    // scale factor for triangle size\n    float f = 1.;\n    \n    // if in triangle colorize it a little bit\n    if(0. <= r.x && 0. <= r.y && r.x + r.y < f) o = vec4(1. - dot(uv,uv));// + .1 *  cos(.1 * iTime));\n        \n    // divide 15 times\n    for(int i = 0; i < 15; ++ i) {\n        \n    \to.rgb -=\n            // am i inside the triangle? \n            // uncomment the next line for a showing only the center triangle!\n            // 0. <= r.x && 0. <= r.y && r.x + r.y < 1. &&\n            // am i in the lower left part of square in sierpinski space? -----------------------------------\n\t\t\t(mod(r.x, f) + mod(r.y, f) < f) //                                                               |\n             ? fract(mod(f, sin(.1 * iTime))) * vec3(r.x, r.y, 1. - r.x - r.y) //yes, so add some rgb colors |\n             : vec3(0.); // no, so add nothing                                                               |\n    \t                //                                                       ----------------------------\n                       //                                                       |\n        // divide the scaling factor                                            |\n        f *= .5;     //                                                         |\n    }               //                                                          |\n}                  //                                                           |\n                  //                                                            |\n/*    --------------------------------------------------------------------------\n     |\n     V\n\nf = .5\n\n+ - - - - - -\n+ + - - - - -\n+ + + - - - -\n+ + + + - - -\n+ + + + + - -\n+ + + + + + -\n+ + + + + + +\n\nf = .25\n\n+ - - - - - -\n+ + - - - - -\n+ + + - - - -\n+ - - - - - -\n+ + - - + - -\n+ + + - + + -\n+ + + + + + +\n\nf = .125\n\n+ - - - - - -\n+ + - - - - -\n+ + + - - - -\n+ - - - - - -\n+ + - - + - -\n+ - + - + + -\n+ + + + + + +\n\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 68, 107, 139, 2311]]}
{"id": "3sGyzD", "name": "fffaster", "author": "adr", "description": "..", "tags": ["seizure"], "likes": 1, "viewed": 53, "published": "Public", "date": "1602279411", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// followed great raymarch tutorial https://www.shadertoy.com/view/XlBGDW\n#define CLIP_NEAR 0.1\n#define CLIP_FAR 40.0\n#define STEPS 100\n#define EPSILON 0.0001\n#define DISTANCE_BIAS 0.7\n#define PI 3.14159\n#define SPEED 0.25\n#define START 10.0\n\n// distance to sphere function (p is world position of the ray, s is sphere radius)\n// from http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdSphere(vec3 p, float s)\n{\n\treturn length(p) - s;\n}\n\nfloat scene(vec3 p) {\n    vec3 pos_big = vec3(fract(p.x * p.x + 0.5) - 0.5, p.y, p.z); // this + careful camera control is where the effect comes from \n    float d = sdSphere(pos_big, 0.3);\n    return d;\n}\n\nfloat raymarch(vec3 p, vec3 direction) {\n\tfloat dist = CLIP_NEAR;\n    float result;\n    for (int i = 0; i < STEPS; ++i) {\n        result = scene(p + direction * dist);\n        if (result < EPSILON) { break; }\n        dist += result * DISTANCE_BIAS;\n        if (dist > CLIP_FAR) { break; }\n    }\n    return dist;\n}\n\nvec3 normal(vec3 ray_hit_position, float smoothness)\n{\t\n    // From https://www.shadertoy.com/view/MdSGDW\n\tvec3 n;\n\tvec2 dn = vec2(smoothness, 0.0);\n\tn.x\t= scene(ray_hit_position + dn.xyy) - scene(ray_hit_position - dn.xyy);\n\tn.y\t= scene(ray_hit_position + dn.yxy) - scene(ray_hit_position - dn.yxy);\n\tn.z\t= scene(ray_hit_position + dn.yyx) - scene(ray_hit_position - dn.yyx);\n\treturn normalize(n);\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    vec3 f = normalize(eye - center);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 offset = vec3(SPEED * iTime + START, 0.0,  0.0);\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 direction = normalize(vec3(uv, 2.5));    \n    \n    vec3 eye = vec3(\n        1.5 - 0.5 * sin(PI * iMouse.x / iResolution.x) + offset.x,\n        0.12 - 0.05 * iMouse.y / iResolution.y + offset.y + 0.1 * sin(PI * iMouse.x / iResolution.x),\n        0.0 - 0.2 * cos(PI * iMouse.x / iResolution.x) + offset.z);\n    \n    mat4 viewToWorld = viewMatrix(eye, offset, vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(direction, 0.0)).xyz;\n    direction = worldDir;\n    vec3 camera_origin = eye;\n    float result = raymarch(camera_origin, direction);\n\n    // arbitrary fog to hide artifacts near the far plane\n    // 1.0 / distance results in a nice fog that starts white\n    // but if distance is 0 \n    float fog = 1.0 - result / CLIP_FAR;\n    \n    vec3 materialColor = vec3(1.0, 0.25, 0.1);\n    \n    // We can reconstruct the intersection point using the distance and original ray\n    vec3 intersection = camera_origin + direction * result;\n    \n    // The normals can be retrieved in a fast way\n    // by taking samples close to the end-result sample\n    // their resulting distances to the world are used to see how the surface curves in 3D\n    // This math I always steal from somewhere ;)\n    vec3 nrml = normal(intersection, 0.01);\n    \n    // Lambert lighting is the dot product of a directional light and the normal\n    vec3 light_dir = normalize(vec3(0.0, 1.0, 0.0));\n   \tfloat diffuse = dot(light_dir, nrml);\n    // Wrap the lighting around\n    // https://developer.valvesoftware.com/wiki/Half_Lambert\n    //diffuse = diffuse * 0.5 + 0.5;\n    // For real diffuse, use this instead (to avoid negative light)\n    //diffuse = max(0.0, diffuse);\n    \n    // Combine ambient light and diffuse lit directional light\n    vec3 light_color = vec3(1.4, 1.2, 0.7);\n    vec3 ambient_color = vec3(0.2, 0.45, 0.6);\n    vec3 diffuseLit = materialColor * (diffuse * light_color + ambient_color);\n\tfragColor = vec4(diffuseLit, 1.0) * fog; /* applying the fog last */\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[243, 402, 435, 435, 460], [462, 462, 483, 483, 667], [669, 669, 709, 709, 982], [984, 984, 1038, 1089, 1384], [1386, 1386, 1435, 1435, 1625], [1627, 1627, 1684, 1684, 3816]]}
{"id": "3sGyzG", "name": "SDF with textures", "author": "edorobek", "description": "SDF playground but with 3D textures applied\n", "tags": ["raymarching", "sdf", "3dtexture"], "likes": 5, "viewed": 78, "published": "Public", "date": "1603067289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n\n\n#define ANIMATE 0\n#define MAX_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n\nfloat dot2(in vec2 v) { return dot(v,v); }\n\n\n\nfloat noise(vec3 p)\n{\n\tvec3 ip=floor(p);\n    p-=ip; \n    vec3 s=vec3(7,157,113);\n    vec4 h=vec4(0.,s.yz,s.y+s.z)+dot(ip,s);\n    p=p*p*(3.-2.*p); \n    h=mix(fract(sin(h)*43758.5),fract(sin(h+s.x)*43758.5),p.x);\n    h.xy=mix(h.xz,h.yw,p.y);\n    return mix(h.x,h.y,p.z); \n}\n\nfloat fbm( in vec3 x, in float H )\n{    \n    float t = 0.0;\n    for( int i=0; i<3; i++ )\n    {\n        float f = pow( 2.0, float(i) );\n        float a = pow( f, -H );\n        t += a*noise(f*x);\n    }\n    return clamp(t, 0.0, 1.0);\n}\n\n/* SIGNED DISTANCE FUNCTIONS */\n// ============================================================== //\nfloat sphereSDF(vec3 p,  float r) \n{\n    return length(p) - r;\n}\n\n\nfloat boxSDF(vec3 p, vec3 b)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.0)) + min(max(q.x, max(q.y,q.z)), 0.0);\n}\n\nfloat roundBoxSDF(vec3 p, vec3 b, float r)\n{\n\tvec3 q = abs(p) - b;\n\treturn length(max(q,0.0)) + min(max(q.x,max(q.y,q.x)),0.0) - r;\n}\n\nfloat boundingBoxSDF( vec3 p, vec3 b, float e )\n{\n    p = abs(p) - b;\n    vec3 q = abs(p + e) - e;\n\treturn min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\nfloat torusSDF(vec3 p, vec2 t)\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat cappedTorusSDF(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat linkSDF( vec3 p, float le, float r1, float r2 )\n{\n  vec3 q = vec3( p.x, max(abs(p.y)-le,0.0), p.z );\n  return length(vec2(length(q.xy)-r1,q.z)) - r2;\n}\n\nfloat cylinderSDF( vec3 p, vec3 c )\n{\n  return length(p.xz - c.xy)-c.z;\n}\n\nfloat coneSDF( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp(w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y - w.y*q.x), k*(w.y - q.y));\n  return sqrt(d) * sign(s);\n}\n\nfloat infConeSDF( vec3 p, vec2 c )\n{\n    vec2 q = vec2( length(p.xz), -p.y );\n    float d = length( q - c*max(dot(q,c), 0.0) );\n    return d*( (q.x*c.y - q.y*c.x < 0.0) ? -1.0 : 1.0);\n}\n\nfloat planeSDF( vec3 p, vec3 n, float h )\n{\n  // n must be normalized!!\n  return dot(p,n) + h;\n}\n\nfloat sdfHexPrime( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat triPrismSDF( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z - h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\n\nfloat capsuleSDF( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a;\n  vec3 ba = b - a;\n  float h = clamp( dot(pa,ba) / dot(ba,ba), 0.0, 1.0 );\n  return length(pa - ba*h) - r;\n}\n\nfloat cappedCylinderSDF( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat roundCylinderSDF( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat cappedConeSDF( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat roundConeSDF( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\n// NOTE: approximation\nfloat ellipsoidSDF( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p / (r*r));\n  return k0*(k0 - 1.0)/k1;\n}\n\nfloat octahedronSDF( vec3 p, float s)\n{\n  p = abs(p);\n  float m = p.x+p.y+p.z-s;\n  vec3 q;\n       if( 3.0*p.x < m ) q = p.xyz;\n  else if( 3.0*p.y < m ) q = p.yzx;\n  else if( 3.0*p.z < m ) q = p.zxy;\n  else return m*0.57735027;\n    \n  float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n  return length(vec3(q.x,q.y-s+k,q.z-k)); \n}\n\nfloat pyramidSDF( vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z > p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y - 0.5*p.z)/(m2 + 0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\n\n\n// Combinations\nfloat unionOp(float d1, float d2) { return min(d1,d2); }\nvec2 unionOp(vec2 d1, vec2 d2) { return (d1.x<d2.x) ? d1 : d2; }\nfloat subtractOp(float d1, float d2) { return max(-d1,d2); }\nvec2 subtractOp(vec2 d1, vec2 d2) { return (-d1.x > d2.x) ? -d1 : d2; }\nfloat intersectOp(float d1, float d2) { return max(d1,d2); }\nvec2 intersectOp(vec2 d1, vec2 d2) { return (d1.x > d2.x) ? d1 : d2; }\n\nfloat smoothUnionOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nvec2 smoothUnionOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat smoothSubOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nvec2 smoothSubOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp(0.5 - 0.5*(d2.x + d1.x)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0 - h); \n}\n\nfloat smotherIntersectOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2 - d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0 - h); \n}\n\nvec2 smotherIntersectOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2.x - d1.x)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) + k*h*h*(1.0 - h); \n}\n\n\n\n\n/* Experimental smooth minimum function s*/\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminA( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// power smooth min (k = 8);\nfloat sminB( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    \n    \n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n/* Transformations */\n\n// rotation and scaling\nvec3 linearTOp(vec3 p, mat4 transform)\n{\n\treturn (inverse(transform)*vec4(p,1.0)).xyz;\n}\n\nvec3 translateOp(vec3 p, vec3 h)\n{\n\treturn p - h;\n}\n\n// NOTE: YOU MUST MULTIPLY RESULTING DISTANCE BY 's'\nvec3 scaleOp(vec3 p, float s)\n{\n\treturn p / s;\n}\n\n/* Deformations */\n\n// Displacement: SDF(p) + displace(p)\n\n// ALTERATIONS\n\nvec4 elongateOP(vec3 p, vec3 h)\n{\n\tvec3 q = abs(p)-h;\n\treturn vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0));\n}\n\nfloat roundOp(float d, float h)\n{\n    return d - h;\n}\n\nvec3 twistOp(vec3 p, float k)\n{\n\tfloat c = cos(k*p.y);\n\tfloat s = sin(k*p.y);\n\tmat2 m = mat2(c,-s,s,c);\n\treturn vec3(m*p.xz,p.y);\n\t\n}\n\nvec3 bendOp(vec3 p, float k)\n{\n\tfloat c =  cos(k*p.x);\n\tfloat s = sin(k*p.x);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m*p.xy, p.z);\n}\n\n\n// ============================================================== //\n// PLAY WITH CODE HERE\n// ============================================================== //\n\n/* SDF FOR THE ENTIRE SCENE */\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(1e10, 0.0);\n\t{\n\t\t// PLANE COLOR CODE MUST BE < 1.5\n\t\tresult = unionOp(result, vec2(boxSDF(p - vec3(0.0,-1.1 ,0.0), vec3(25,.01,25)), 1.1)); \n\t\tresult = unionOp(vec2(cappedTorusSDF(p - vec3(0.0,.8,0.0), vec2(0.866025,-0.5), 0.55, 0.15), 100.), result);\n\t\tresult = smoothUnionOp(result, vec2(boxSDF(bendOp(p - vec3(0.,-.2,0.), 0.5), vec3(1.,.4,.6)), 100.), 0.3);\n    \tresult = smoothUnionOp(result, vec2(sphereSDF(p - vec3(0.,1.9,0.), .2), 100.9), .8);\n    }\n\t\n\treturn result;\n}\n\nconst float sunIntensity = .65;\nconst vec3 sunColor = sunIntensity*vec3(1.1,1.0,1.0);\n\nvec3 background(vec3 q)\n{\n\treturn mix( vec3(0.3,0.3,0.8)*0.5, vec3(0.6, 0.8, 1.0), 0.7 + 0.5*q.y );\n}\n\n// ============================================================== //\n\n// intersect ray with the scene\nvec2 raycast(vec3 ro, vec3 rd)\n{\n\tvec2 result = vec2(-1.0);\n\tfloat t = MIN_DIST;\n\tfor (int i =0; i < MAX_STEPS && t < MAX_DIST; i++) {\n\t\tvec2 h = map(ro + t*rd);\n\t\tif (abs(h.x) < (EPSILON*t)) {\n\t\t\tresult = vec2(t, h.y);\n\t\t\tbreak;\n\t\t}\n\t\tt += h.x;\n\t}\n\t\n\treturn result;\n}\n\n// get direction of ray with just device coordinates\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n// calculate the normal via finite differences\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 light = normalize( vec3(-0.5, 0.4, 0.6) );\n\n\nvec3 render(vec3 ro, vec3 rd, vec3 rdx, vec3 rdy)\n{\n\t// background\n\tvec3 col = background(rd);\n\t\n\tvec2 tmat = raycast(ro, rd);\n\tfloat t = tmat.x;\n\tfloat m = tmat.y;\n\tif (m > -1.) {\n\t\n\t\t\n\t\tcol = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        clamp(col, 0.0, 1.0);\n        float ks = 1.0;\n\t\n\t\tvec3 pos = ro + tmat.x*rd;\n\t\tvec3  hal = normalize(light - rd );\n\t\tvec3 norm = (m < 1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n\t\tvec3 ref = reflect( rd, norm );\n\t\t\n\t\tif( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            //vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            //vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            col = vec3(0.30);\n            ks = 0.1;\n        }\n        \n        if (m > 99.)\n        {\n            col = vec3(fbm(pos*11., 1.));\n        }\n\t\t\n\t\tfloat occ = calcAO(pos, norm); \n\t\tvec3 lin = vec3(0.0);\n\t\t\n\t\t// sun\n\t\t{\n            vec3  hal = normalize( light-rd );\n            float dif = clamp( dot( norm, light ), 0.0, 1.0 );\n        \t      dif *= calcSoftshadow( pos, light, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( norm, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.16*pow(clamp(1.0-dot(hal,light),0.0,1.0),2.0);\n            lin += col*2.20*dif*sunColor;\n            lin +=     5.00*spe*sunColor*ks;\n        }\n        \n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+1.5*norm.y, 0.0, 1.0 ));\n            dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n            spe *= dif;\n            spe *= 0.04+0.96*pow(clamp(1.0+dot(norm,rd),0.0,1.0), 5.0 );\n            spe *= calcSoftshadow( pos, ref, 0.02, 4.2 );\n            lin += col*0.70*dif*background(rd);\n            lin +=     1.0*spe*background(rd)*ks;\n        }\n        col = lin;\n\n\t\t// falloff (fakes a depth blur)\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.00002*t*t*t ) );\n\t}\n\t\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    \n    vec3 eye = vec3(5. * sin(.7*iTime), 7.0, 2. + 5. * cos(.8*iTime));\n    \n    mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n  \t// ray derivatives\n    vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n    vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n    vec3 rdx = (viewToWorld * normalize( vec4(px,2.5, 1.0) )).xyz;\n    vec3 rdy = (viewToWorld * normalize( vec4(py,2.5, 1.0) )).xyz;\n    \n    vec3 col = render(eye, worldDir, rdx, rdy);\n\n\tfragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 158, 158, 177], [181, 181, 202, 202, 452], [454, 454, 490, 490, 686], [688, 789, 825, 825, 853], [856, 856, 886, 886, 974], [976, 976, 1020, 1020, 1109], [1111, 1111, 1160, 1160, 1449], [1451, 1451, 1483, 1483, 1548], [1550, 1550, 1621, 1621, 1755], [1757, 1757, 1812, 1812, 1914], [1916, 1916, 1953, 1953, 1989], [1991, 1991, 2039, 2173, 2512], [2514, 2514, 2550, 2550, 2699], [2701, 2701, 2744, 2772, 2797], [2799, 2799, 2836, 2836, 3109], [3111, 3111, 3148, 3148, 3233], [3235, 3235, 3288, 3288, 3416], [3418, 3418, 3471, 3471, 3578], [3580, 3580, 3643, 3643, 3760], [3762, 3762, 3822, 3822, 4135], [4137, 4137, 4196, 4196, 4460], [4462, 4485, 4523, 4523, 4610], [4612, 4612, 4651, 4651, 4931], [4933, 4933, 4969, 4969, 5460], [5464, 5480, 5515, 5515, 5536], [5537, 5537, 5569, 5569, 5601], [5602, 5602, 5640, 5640, 5662], [5663, 5663, 5698, 5698, 5734], [5735, 5735, 5774, 5774, 5795], [5796, 5796, 5832, 5832, 5866], [5868, 5868, 5921, 5921, 6021], [6022, 6022, 6072, 6072, 6175], [6177, 6177, 6228, 6228, 6329], [6331, 6331, 6379, 6379, 6487], [6489, 6489, 6547, 6547, 6651], [6653, 6653, 6708, 6708, 6815], [6820, 6864, 6905, 6905, 6979], [6981, 7017, 7059, 7059, 7143], [7145, 7181, 7227, 7227, 7313], [7315, 7344, 7386, 7386, 7474], [7499, 7523, 7563, 7563, 7611], [7613, 7613, 7647, 7647, 7664], [7666, 7719, 7750, 7750, 7767], [7828, 7844, 7877, 7877, 7958], [7960, 7960, 7993, 7993, 8013], [8015, 8015, 8046, 8046, 8148], [8150, 8150, 8180, 8180, 8285], [8450, 8482, 8500, 8500, 8997], [9086, 9086, 9111, 9111, 9187], [9259, 9291, 9323, 9323, 9559], [9561, 9614, 9679, 9679, 9810], [9813, 9860, 9892, 9892, 10100], [10102, 10102, 10151, 10186, 10412], [10415, 10415, 10493, 10516, 10900], [10905, 10905, 10947, 10947, 11253], [11305, 11305, 11356, 11371, 13234], [13236, 13236, 13291, 13291, 13980]]}
{"id": "3sGyzw", "name": "Fab10 #inktober2020 \"hope\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nref image: [img] https://www.wired.com/story/laurie-penny-on-hope/ [/img]", "tags": ["short", "golf", "reproduction", "inktober2020"], "likes": 11, "viewed": 248, "published": "Public API", "date": "1602434875", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)    mat2( cos(a+vec4(0,11,33,0)) )                    // rotation                  \n#define B(a,l,L)  max(  max( abs(a).x, abs(a).y ) -l, abs(a).z -L ) // bar\n\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=9., a;\n    vec3  R = iResolution, e = vec3(5,-5,0), X=e.xzz, Z=e.zzx,\n          M = iMouse.z > 0. ? iMouse.xyz/R : .01*cos(.5*iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -2.*R.y ) - R ),      // ray direction\n          p = 50./R, q,s;                                // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )\n        q = p, t=9.,\n        q.yz *= rot(-.4 -6.3*M.y),                       // rotations\n        q.xz *= rot(-.4 -6.3*M.x),\n        s = q = q.xzy,\n        t = min( t, max( -B((q-3.*Z),11.,2.), a = abs(q.z-15.)-1.5 ) ), // roof hole\n        q.y += 2., q.yz *= rot(.4),\n        t = min( t, B(abs(q)-X,.7,30.) ),                // ladder sides\n        t = t = min( t, max( abs(q.z)-28.,  B(vec3(mod(q.z+2.5,5.)-2.5,q.yx),.5,5.) ) ),\n        p += t*D;                                        // step forward = dist to obj          \n\n   if ( a==t || O.x>1. && s.z<200.) O *= 0.;             // roof & horizon = blaxk\n// if (s.z>200.) O *= vec4(.7,1,1,0);                    // coloring\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[175, 175, 211, 211, 1272]]}
{"id": "3sKcR1", "name": "Kazaguruma", "author": "nanase", "description": "guruguru", "tags": ["simple"], "likes": 1, "viewed": 41, "published": "Public", "date": "1602236684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot2D(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n\nfloat box1(vec3 p) {\n    p.y += 1.6;\n    p = abs(p);\n    p.x -= .1;\n    p.y -= 2.;\n    return max(max(p.x,p.y),p.z);\n}\n\nfloat dist(vec3 p, float speed) {\n    vec3 q=p, e = vec3(1,0,0);\n    p.xy *= rot2D(iTime * speed);\n    float a = p.x < 0. ? length(p-e.zxz) - 1. :  length(p+e.zxz) - 1.,\n          b = p.y < 0. ? length(p+e.xzz) - 1. :  length(p-e.xzz) - 1. ;\n    return min( min(a,b),  box1(q) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy;\n    vec2 uv = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    \n    vec2 uv2 = mod(uv, 0.25) - 0.1;\n\n    vec3 cp = vec3(0.,0.,-5.);\n    float screenZ = 0.2; \n\n    vec3 rd = normalize(vec3(uv2, screenZ));\n\n    float depth = 0.0;\n    vec3 col = vec3(1.);\n\n    for (int i=0; i<10; i++) {\n        vec3 rp = cp + rd * depth;\n        float dist = dist(rp, 2.3);\n        if(dist < 0.001) {\n            col = vec3(0.);\n            break;\n        }\n        depth += dist;\n    }\n\n\n    fragColor = vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKcR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 73, 73, 171], [173, 173, 206, 206, 454], [456, 456, 513, 513, 1081]]}
{"id": "3sKczm", "name": "Example 29 - lighted sphere", "author": "jt", "description": "Diffuse lighting on a sphere.", "tags": ["example", "lighting"], "likes": 0, "viewed": 36, "published": "Public", "date": "1602504001", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n\n    vec3 v = vec3(p.x, p.y, sqrt(1.0 - p.x * p.x - p.y * p.y));\n    vec3 n = normalize(v);\n    //vec3 l = vec3(0.0, 0.0, 1.0);\n    vec3 l = vec3(sin(iTime), 0.0, cos(iTime));\n    float b = dot(n, l);\n\n    fragColor = vec4(b);\n    //fragColor = vec4(n, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKczm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 383]]}
{"id": "3sKyDR", "name": "DoubleDodecaSpin", "author": "snolot", "description": "testing raymarching with double spining structure.", "tags": ["raymarching", "dodecahedron"], "likes": 15, "viewed": 122, "published": "Public", "date": "1602706017", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// code & inspirtion borowed from lsdlive https://www.shadertoy.com/view/wd3GWM\n\n\n// Enable/disable decay animation\n//#define DECAY\n\n#define PI 3.14159\n#define TAU 6.28318\n#define BEAT (time*170.0/60.0)\n#define time iTime\n#define lofi(x,d) (floor((x)/(d))*(d))\nmat3 m;\nmat3 m2;\n\nfloat kExposure = 0.6;\n\nfloat pal_scale = 1.;\nfloat pal_offset = 0.;\n\n// if you disable DECAY animation, you can control the noise\nfloat noise_freq = 2.;\nfloat noise_amt = .3;\n\nfloat g;\n\n//#define pal(t,a,b,c,d) (a+(b)*cos(2.*PI*((c)*(t)+d)))\n#define kick(t,b) (floor(t) + fract(t) + sin(fract(t)*PI)*b)\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\n\nvec3 colormapIQ(float t){\n    //vec3 col = pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n   \t// nice blue\n    vec3 col = pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.3,0.20,0.20) );\n    \n    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,0.5),vec3(0.8,0.90,0.30) );\n    \n    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,0.7,0.4),vec3(0.0,0.15,0.20) );\n    //vec3 col = pal( t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.25) );\n    //vec3 col = pal( t, vec3(0.8,0.5,0.4),vec3(0.2,0.4,0.2),vec3(2.0,1.0,1.0),vec3(0.0,0.25,0.25) );\n    \n    return col;\n}\n\n// iq's noise\nfloat noise(in vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3. - 2. * f);\n\tvec2 uv = (p.xy + vec2(37., 17.) * p.z) + f.xy;\n\tvec2 rg = textureLod(iChannel0, (uv + .5) / 256., 0.).yx;\n\treturn -1. + 2.4 * mix(rg.x, rg.y, f.z);\n}\n\n// Fbm\nfloat fbm(vec3 p) {\n\treturn noise(p * .06125) * .5 + noise(p * .125) * .25 + noise(p * .25) * .125;\n}\n\n// Dodecahedron folding\n// checkout: https://www.shadertoy.com/view/wtsGzl\nvec3 fold(vec3 p) {\n\tvec3 nc = vec3(-.5, -.809017, .309017);\n\tfor (int i = 0; i < 5; i++) {\n\t\tp.xy = abs(p.xy);\n\t\tp -= 2.*min(0., dot(p, nc))*nc;\n\t}\n\treturn p - vec3(0, 0, 1.275);\n}\n\nfloat sdf_shell(vec3 p, float scale) {\n\tvec3 fp = fold(p * scale);\n\tfloat dist = dot(fp, normalize(sign(fp))) - .0 - sin(fp.y*.2)*2. - sin(fp.y*.5)*1.;\n    //g+=(0.1/(.01+dist*dist*999.) * sin(iTime  * .5));\n    \n\tdist += min(fp.x*1., sin(fp.y*.4)) + fbm(fp )* .03;\n\t//g+=(0.1/(.01+dist*dist*995.) * sin(iTime  * .5));\n\tfp = fold(fp) - vec3(.4, 2, -2.3);\n\tfp = fold(fp) - vec3(.8, 1, .1);\n\tfp = fold(fp) - vec3(0, .3, 0);\n\tdist += sin(fp.y*.1)*.1;\n    \n\tdist *= 1.;\n\t//g+=(0.1/(.01+dist*dist*9995.));// * sin(iTime  * .5));\n    \n\treturn dist / scale;\n}\n\nfloat sdf_core(vec3 p, float scale) {\n\tvec3 fp = fold(p * scale);\n\tfloat dist = dot(fp, normalize(sign(fp))) - .4 - sin(fp.y*.8)*1.8 - sin(fp.y*.7)*1.;\n\tdist += min(fp.x*8., sin(fp.y*.1));\n\n\tfp = fold(fp) - vec3(-.45, 6.7, -.1);\n\tfp = fold(fp) - vec3(-.3, 8.7, -0.9);\n\tfp = fold(fp) - vec3(0, .02, 0);\n\tdist += sin(fp.y*.2)*8.;\n\tdist *= .4;\n\n\treturn dist / scale;\n}\n\n\n\nfloat de(vec3 p, vec3 p2) {\n\n    \t\n\tfloat s = 37.;\n\tp = mod(p - s * .5, s) - s * .5;\n\n\tfloat dist;\n\tdist = sdf_shell(p, .1 * (1. /*+ sin(u_time * .5)*/));\n\tdist = min(dist, sdf_core(p2, .6/* * ( 1.7 - sin(u_time * .5 ) ) */)) * .7;\n\n    #ifdef DECAY\n\treturn dist + fbm(p*30.) * (.6+.45*sin(4.+1.*kick(iTime*.1, .1)));\n    #else\n    return dist + fbm(p*noise_freq) * noise_amt;\n    #endif\n}\n\nvec3 camera(vec3 ro, vec3 ta, vec2 uv) {\n\tvec3 fwd = normalize(ta - ro);\n\tvec3 left = normalize(cross(vec3(0, 1, 0), fwd));\n\tvec3 up = normalize(cross(fwd, left));\n\treturn normalize(fwd + uv.x * left + up * uv.y);\n}\n\n\n// mat3 from quaternion\nmat3 SetRot( const in vec4 q )\n{\n\tvec4 qSq = q * q;\n\tfloat xy2 = q.x * q.y * 2.0;\n\tfloat xz2 = q.x * q.z * 2.0;\n\tfloat yz2 = q.y * q.z * 2.0;\n\tfloat wx2 = q.w * q.x * 2.0;\n\tfloat wy2 = q.w * q.y * 2.0;\n\tfloat wz2 = q.w * q.z * 2.0;\n \n\treturn mat3 (\t\n     qSq.w + qSq.x - qSq.y - qSq.z, xy2 - wz2, xz2 + wy2,\n     xy2 + wz2, qSq.w - qSq.x + qSq.y - qSq.z, yz2 - wx2,\n     xz2 - wy2, yz2 + wx2, qSq.w - qSq.x - qSq.y + qSq.z );\n}\n\n\n\n// mat3 from axis / angle\nmat3 SetRot( vec3 vAxis, float fAngle )\n{\t\n\treturn SetRot( vec4(normalize(vAxis) * sin(fAngle), cos(fAngle)) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\n\tvec2 vUV = fragCoord.xy / iResolution.xy;\n    //vUV = glitch(vUV);\n\tvec2 vWindow = vUV * 2.0 - 1.0;\n\tvWindow.x *= iResolution.x / iResolution.y;\n\t\n\tvec2 vMouse = iMouse.xy / iResolution.xy;\n\n\t//vec3 ray_ori = vec3(-11.*cos(u_time), sin(u_time)*7., -11. * sin(u_time)); // softer cam\n    \n    /*vec3 ray_ori = vec3(-10.*cos(kick(u_time*2., .1)), 16.*cos(kick(u_time*1., .1)), -10.*sin(kick(u_time, .1)));\n    vec3 target = vec3(0);\n\tvec3 ray_dir = camera(ray_ori, target, uv);\n\tvec3 pos = ray_ori;*/\n    \n    \n\tfloat fHeading = iTime * 0.21;\n\tfloat fElevation = cos(iTime * 0.1) * 0.5;\n\tfloat fCameraDistance = 20.0 + sin(iTime * .5) * 5.0;\n\t\n\tfloat fSinElevation = sin(fElevation);\n\tfloat fCosElevation = cos(fElevation);\n\tfloat fSinHeading = sin(fHeading);\n\tfloat fCosHeading = cos(fHeading);\n\t\n\tvec3 vCameraOffset;\n\tvCameraOffset.x = fSinHeading * fCosElevation;\n\tvCameraOffset.y = fSinElevation;\n\tvCameraOffset.z = fCosHeading * fCosElevation;\n\t\n\tvec3 vCameraPos = vCameraOffset * fCameraDistance;\n\tvec3 pos = vCameraPos;\n\tvec3 vCameraTarget = vec3(0.0, 0.0, 0.0);\n\t\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n\tfloat fFov = 2.0;\n\t\n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * fFov);\n\t\n\tvec3 vRotationAxis = vec3(1.0, 4.0, 2.0);\n\n\t// Rotate the rotation axis\n\tmat3 m2 = SetRot( vec3(0.1, 1.0, 0.01), iTime * 0.3 );\t\t\n\t\n\tvRotationAxis = vRotationAxis * m2;\n\t\n\tfloat fRotationAngle = sin(iTime * 0.5);\n\t\n\tif( iMouse.z > 0.0 )\n\t{\n\t\tvec2 vMouseOffset = vMouse * 2.0 - 1.0;\n\t\tvRotationAxis = vec3(vMouseOffset.x, 1.0, vMouseOffset.y);\n\t\t//vRotationAxis = vec3(vMouseOffset.y, vMouseOffset.x, 1.0);\n\t\tfRotationAngle = length(vRotationAxis);\n\t}\n\t\n\tm = SetRot(vRotationAxis, fRotationAngle);\n\tm2 = SetRot(-sin(vRotationAxis), -fRotationAngle*2.);\n\n\t// local density/distance\n\tfloat ldensity = 0.;\n\n\t// accumulation color & density\n\tvec3 bg = vec3(.16, .12, .22);\n\tvec4 sum = vec4(bg, 0.);\n\n\tfloat tmax = 45.;\n\tfloat tdist = 0., dist = 0.;\n\n\tfor (float i = 0.; (i < 1.); i += 1. / 64.) {\n\n\t\tif (dist < tdist * .001 || tdist > tmax || sum.a > .95)\n\t\t\tbreak;\n\n\t\t// evaluate distance function\n\t\tvec3 vPos = (pos.xyz) * m;\n\t\tvec3 vPos2 = (pos.xyz) * m2;\n\t\t//dist = de(pos) * .5;\n\t\tdist = de(vPos, vPos2) * .5;\n\n\t\t// check whether we are close enough (step)\n\t\t// compute local density and weighting factor \n\t\tconst float h = .05;\n\t\tldensity = (h - dist) * step(dist, h);\n\n\t\tvec4 col;\n\t\tcol.rgb = colormapIQ(ldensity * 3.5 );/*(ldensity * pal_scale + pal_offset,\n\t\t\tvec3(.7, .4, .2 + sin(iTime*1.5)*.1),\n\t\t\tvec3(.9, .8, .4),\n\t\t\tvec3(.4, .5, .6),\n\t\t\tvec3(.8, .5, .3));*/\n        \n        col.rgb = clamp(col.rgb, 0., 1.);\n\t\tcol.a = ldensity;\n\n\t\t// pre-multiply alpha\n\t\t// checkout: https://www.shadertoy.com/view/XdfGz8\n\t\t// http://developer.download.nvidia.com/assets/gamedev/files/gdc12/GDC2012_Mastering_DirectX11_with_Unity.pdf\n\t\tcol.rgb *= col.a;\n        \n\t\tsum += (1. - sum.a) * col;\n\t\t//sum += g * .01;\n\t\t// from duke/las\n\t\tsum.a += .015;\n\n\t\t// enforce minimum stepsize\n\t\tdist = max(dist, .05 + sin(iTime)*.01);\n\n\t\t// step forward\n\t\tpos += dist * vDir; // sphere-tracing\n\t\ttdist += dist;\n\t}\n\n\t// from duke/las\n\t// simple scattering approximation\n\tsum *= 1. / exp(ldensity * .2) * 1.25;\n\t\n\tfragColor = vec4(sum.rgb, 1.);\n    fragColor.rgb *= smoothstep( 1.5, 0.4, length(fragCoord.xy-iResolution.xy*.5)/length(iResolution.xy*.5) );\n    vec3 grunge = texture( iChannel1, fragCoord/iChannelResolution[1].xy + vec2(.7549,.5698)*float(iFrame) ).rgb;\n    fragColor.rgb = mix( fragColor.rgb*mix( vec3(1), grunge, .2 ), grunge*vec3(.3,1,.6), .02 );\n    fragColor.rgb *= 1.+.4*sin(6.283185*fragCoord.y*.5*.618+iTime);\n    fragColor.rgb *= mix( 1., 1.8, smoothstep(.0,.3,cos(iTime/7.)) );    \n    fragColor.rgb = max(vec3(0),fragColor.rgb-.02);\n}\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKyDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[466, 584, 652, 652, 695], [698, 698, 723, 841, 1483], [1485, 1499, 1523, 1523, 1743], [1745, 1752, 1771, 1771, 1853], [1855, 1930, 1949, 1949, 2111], [2113, 2113, 2151, 2151, 2665], [2667, 2667, 2704, 2704, 3032], [3036, 3036, 3063, 3063, 3425], [3427, 3427, 3467, 3467, 3642], [3645, 3669, 3701, 3701, 4096], [4100, 4126, 4167, 4167, 4239], [4242, 4242, 4298, 4298, 8187]]}
{"id": "3sKyDw", "name": "Cells Under a Microscope", "author": "jarble", "description": "I don't know what these patterns are, but they look vaguely biological.", "tags": ["fractal", "cell"], "likes": 2, "viewed": 263, "published": "Public API", "date": "1603002849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float t = iTime*.3;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y+vec2(t+2.0);\n        //uv *= 10.0;\n        int c = 0;\n        for(int i=0;i<9;i++)\n        {\n            c = i%3;\n            float factor = 1.5;\n            vec2 uv1 = uv;\n            uv /= factor;\n            uv += uv1;\n            uv += (sin(uv.yx))/factor;\n            uv *= factor;\n            col[c] += sin(uv.x+uv.y);\n        }\n    fragColor = vec4(col*100.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 524]]}
{"id": "3sKyzd", "name": "Magic Moving Ferris Wheel", "author": "Jinkweiq", "description": "Use the mouse to move the screen. The image is generated from a normal animation and broken up. If you blur your eyes it looks a lil better tbh", "tags": ["2d", "animation"], "likes": 7, "viewed": 82, "published": "Public", "date": "1603516188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi acos(-1.)\n\nfloat sdCircle(vec2 p,float r)\n{\n    return length(p)-r;\n}\nfloat sdBox(in vec2 p,in vec2 b)\n{\n    vec2 d=abs(p)-b;\n    return length(max(d,0.))+min(max(d.x,d.y),0.);\n}\nfloat sdSegment(in vec2 p,in vec2 a,in vec2 b)\n{\n    vec2 pa=p-a,ba=b-a;\n    float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*h);\n}\nfloat map(vec2 p,float t){\n    p*=1.2;\n    p.y-=.1;\n    float d=sdCircle(p,.2);\n    d*=sdCircle(p,.18);\n    \n    d=min(d,sdCircle(p,.03));\n    \n    vec2 ap=p;\n    ap.x=abs(ap.x);\n    d=min(d,sdSegment(ap,vec2(0),vec2(.1,-.35))-.01);\n    d=min(d,sdSegment(ap,vec2(0,-.35),vec2(.3,-.35))-.02);\n    \n    mat2 am=mat2(cos(t),-sin(t),sin(t),cos(t));\n    vec2 np=p;\n    np*=am;\n    \n    float seg=6.;\n    float an=pi/float(seg);\n    float bn=mod(atan(np.x,np.y),2.*an)-an;\n    np=length(np)*vec2(cos(bn),sin(bn));\n    np.x-=.1;\n    d=min(d,sdBox(np,vec2(.1,.01)));\n    float innerHex=dot(np,normalize(vec2(1,0.)));\n    innerHex*=dot(np*50.,normalize(vec2(1,0)));\n    d=min(d,smoothstep(.003,.1,innerHex));\n    vec2 sp=p;\n    sp.y+=.04;\n    sp*=am;\n    bn=mod(atan(sp.x,sp.y),2.*an)-an;\n    an=-t;\n    sp*=mat2(cos(an),-sin(an),sin(an),cos(an));\n    sp=length(sp)*vec2(cos(bn),sin(bn));\n    sp.x-=.2;\n    an=2.*pi/seg*atan(p.x,p.y)/2./pi*seg+pi/seg;\n    sp*=mat2(cos(an),-sin(an),sin(an),cos(an));\n    \n    d=min(d,(sdBox(sp,vec2(.0175))-.015)*(sdBox(sp,vec2(.0075,.0125))-.01));\n    \n    return d;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy-.5*iResolution.xy)/iResolution.x;\n    vec2 m=iMouse.xy/iResolution.xy;\n    float segs=5.;\n    float t=floor(mod(uv.x,.02)*100.*segs);\n    vec3 col=vec3(smoothstep(0.,.00001,map(uv,t*2.)));\n    float sx=1.-abs(fract(iTime*.025+.25)*2.-1.);\n    if(iMouse.z > 0.) {\n    \tsx=m.x;\n    }\n    if(uv.x<sx-.5){\n        col*=vec3(ceil(mod(uv.x-sx,.02)-(2.-1./segs)*.01));\n    }\n    fragColor=vec4(col,1.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKyzd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 54, 54, 80], [81, 81, 115, 115, 189], [190, 190, 238, 238, 340], [341, 341, 367, 367, 1434], [1435, 1435, 1492, 1492, 1916]]}
{"id": "3stcWs", "name": "Void Zoom", "author": "yozic", "description": "Spin off of https://www.shadertoy.com/view/wl2yRD", "tags": ["2d", "zoom", "trippy"], "likes": 9, "viewed": 342, "published": "Public API", "date": "1602005773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n#define BALLS 10.\n#define zoom .2\n#define contrast 1.5\n#define ballSize 0.1\n#define radius 5.\n  \nvoid mainImage( out vec4 O, vec2 u ) {\n  vec2 R = iResolution.xy,\n       U = zoom * abs( 2. * u - R) / R.y;\n\n  U /= dot(U,U);\n  float dist = length(U);\n  O = vec4(0);\n\n  U *= tan( log(U) + iTime );\n  for (float i = 0.; i < BALLS; i++) {\n      U.x -= cos( log( abs( abs(U.x*.1) -i-1. )) -iTime );\n      float t = iTime/10. + i * PI / BALLS;\n      vec2 p =   vec2(tan(t), sin(t)) * radius * tan(i);\n      O.rgb += ( cos( + PI * (iTime/2. + i/5. +vec3(0, 2./2., -2./3.)) ) * .5 + .5)\n              * dist*ballSize / length(U + p);\n  }\n  O = pow(O, vec4(contrast));\n}\n\n/*\n\n#define PI 3.141592\n#define BALLS 10\n#define zoom .2\n#define contrast 1.5\n#define ballSize 0.1\n#define radius 5.\n  \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv = 2. * fragCoord/iResolution.xy - 1.;\n  uv.x *= iResolution.x / iResolution.y;\n  uv *= zoom;\n  fragColor = vec4(0);\n  uv = normalize(uv) / length(uv);\n  float dist = length(uv);\n  uv = (abs(uv));\n  uv *= tan(log(uv) + iTime/1.);\n  for (int i = 0; i < BALLS; i++) {\n\t\tuv.x -= cos(log(abs(uv.x*.1)-float(i+1))-iTime);\n    float t = iTime/10. + float(i) * PI / float(BALLS);\n    vec2 p = vec2(tan(t), sin(t));\n    p *= radius * tan(float(i) - PI);\n    vec3 col = cos(vec3(0, 1, -1) * PI * 2. / 3. + 3.141925 * (iTime / 2. + float(i) / 5.)) * 0.5 + 0.5;\n    fragColor += vec4(dist*ballSize / length(uv + p) * col, 1.0);\n  }\n  fragColor.xyz = pow((fragColor.xyz), vec3(contrast));\n  fragColor.w = 1.0;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[117, 117, 155, 155, 680]]}
{"id": "3styDf", "name": "Fun with Perlin Noise", "author": "Ruzzyr", "description": "Playing around with Perlin noise.", "tags": ["noise", "simple", "perlin", "dynamic"], "likes": 3, "viewed": 57, "published": "Public", "date": "1601896764", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st.xy, vec2(12.9898,78.233)))*43758.5453123);\n}\n\n\nvec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(127.1,311.7)),\n              dot(st,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*8.;\n\tuv.x = uv.x*(iResolution.x/iResolution.y);\n\tvec2 mouse = iMouse.xy*8./iResolution.xy;\n    mouse.x = mouse.x*(iResolution.x/iResolution.y);\n    \n\tvec2 uvInterpolation = fract(uv);\n    uvInterpolation = smoothstep(0.,1.,uvInterpolation);\n    //uvInterpolation = uvInterpolation*uvInterpolation*(3.0-2.0*uvInterpolation);\n    vec2 uvFloor = floor(uv);\n    float rand = random(uv);\n    float a = random(uvFloor + vec2(0, 1));\n    float b = random(uvFloor + vec2(1, 1));\n    float c = random(uvFloor + vec2(1, 0));\n    float d = random(uvFloor + vec2(0, 0));\n    \n    // depending on either mouse click or function based on time a point will be moving across the screen.\n    float movement = 2. + length(mouse - uv);\n    if (iMouse.w  <= 0.)\n    {\n     \tvec2 coord = vec2(cos(iTime/2.)*iResolution.x/iResolution.y, sin(iTime/4.))*2.;\n    \tmovement = 2.0 + length((coord + vec2(0.5*8.*iResolution.x/iResolution.y, 0.5*8.)) - uv);\n    }\n    \n    /** Perlin Noise. */\n    float result = dot(vec2(1. - uvInterpolation.x, uvInterpolation.x), transpose(mat2(d, a, c, b))*vec2(1.-uvInterpolation.y, uvInterpolation.y));\n    //float result = mix(mix(a, b, uvInterpolation.x), mix(d, c, uvInterpolation.x), uvInterpolation.y); \n    fragColor = vec4(max(0.0, cos(result*300./movement + 0.7*pow(movement/2., 2.)*random(vec2(uv*16.)))));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3styDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 97], [100, 100, 122, 122, 261], [264, 264, 321, 371, 1739]]}
{"id": "3styDs", "name": "Raymarcher Template", "author": "oneshade", "description": "This is a template I created for my future raymarching projects. You can use it if you want but I would suggest getting familiarized with the raymarching algorithm if you aren't already.", "tags": ["template", "raymarcher"], "likes": 9, "viewed": 356, "published": "Public", "date": "1602031230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nBased on Michael Walczyk's blog on raymarching at https://michaelwalczyk.com/blog-ray-marching.html\n\nThe MIT License\nCopyright © 2020 Elijah Bevers\nPermission is hereby granted, free of charge, to any person obtaining a copy of this software and\nassociated documentation files (the \"Software\"), to deal in the Software without restriction, including\nwithout limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the\nfollowing conditions: The above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY\nKIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\nPARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR\nANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nUpdate information:\n* Future updates:\n\n\n* Added features (in order):\n  - Original version\n  - Added new SDFs for plane and torus\n  - Added a background variable\n  - Added individual shape coloring\n  - Added structures to allow CSG operators to work alongside coloring\n  - Put the surface shading code into a seperate function\n  - Fixed plane SDF\n  - Added clamping of colors to prevent weird issues\n  - Added shadows\n  - Simplified plane SDF\n  - Added antialiasing\n  - Added cone SDF\n  - Added soft shadows\n  - Added a sky function\n  - Added fog\n*/\n\n// Post process settings:\nvec2 antialiasing = vec2(1.0, 1.0); // Set to 2x2 if your computer is fast enough.\n\n// Light settings:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightEmissionColor = vec3(1.0, 1.0, 1.0);\nvec3 lightColor = vec3(1.0, 0.9, 0.7);\nfloat lightPower = 2.0;\n\n// Soft shadows:\nfloat shadowSoftness = 5.0;\n\n// Fog:\nvec3 fogColor = vec3(0.25, 0.25, 0.6);\nfloat fogginess = 0.0001;\n\n// Camera settings:\nvec3 cameraPosition = vec3(0.0, 300.0, 1100.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// User interaction settings:\nfloat tiltSpeed = 3.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2000.0;\nconst float MIN_HIT_DISTANCE = 0.005;\nconst float SHADOW_BIAS = MIN_HIT_DISTANCE * 2.0;\nconst int MAX_STEPS = 500;\n\n// Raymarching structures:\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n    float signedDistance;\n};\n\n// Signed Distance Functions (SDFs):\nfloat sdPlane(in vec3 p, in vec3 n) {\n    return dot(n, p);\n}\n\n// sdCuboid(), sdCone(), and sdCylinder() are taken from Inigo Quilez's 3D distance functions article (https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm):\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    vec3 q = abs(p) - 0.5 * vec3(w, h, d);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCone(in vec3 p, in float b, in float h) {\n    p.y -= h;\n    vec2 q = h * vec2(b / h * 2.0, -2.0);\n    \n    vec2 w = vec2( length(p.xz), p.y );\n    vec2 a = w - q * clamp(dot(w, q) / dot(q, q), 0.0, 1.0);\n    vec2 c = w - q * vec2(clamp(w.x / q.x, 0.0, 1.0), 1.0);\n    float k = sign(q.y);\n    float d = min(dot(a, a), dot(c, c));\n    float s = max(k * (w.x * q.y - w.y * q.x), k * (w.y - q.y));\n    return sqrt(d) * sign(s);\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, 0.5 * h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdTorus(in vec3 p, in float r1, in float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nSurface Union(in Surface surface1, in Surface surface2) {\n    Surface surfaceUnion = surface1;\n    if (surface2.signedDistance < surfaceUnion.signedDistance) {\n        surfaceUnion = surface2;\n    }\n\n    return surfaceUnion;\n}\n\nSurface Intersection(in Surface surface1, in Surface surface2) {\n    Surface surfaceIntersection = surface1;\n    if (surface2.signedDistance > surfaceIntersection.signedDistance) {\n        surfaceIntersection = surface2;\n    }\n\n    return surfaceIntersection;\n}\n\nSurface Difference(in Surface surface1, in Surface surface2) {\n    return Intersection(surface1, Surface(surface2.ambientColor,\n                                          surface2.diffuseColor,\n                                          surface2.specularColor,\n                                          surface2.shininess,\n                                          -surface2.signedDistance));\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\nvec3 Scale(in vec3 p, in vec3 s) {\n    return p / s;\n}\n\n// Scene mapping function:\nSurface mapScene(in vec3 p) {\n    Surface plane = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(mod(dot(floor(p.xz / 100.0), vec2(1.0)), 2.0) * 1.25),\n                            vec3(0.0, 0.0, 0.0), 0.0,\n                            sdPlane(Translate(p, vec3(0.0, -75.0, 0.0)), vec3(0.0, 1.0, 0.0)));\n\n    Surface cuboid = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(1.0, 0.6, 0.0),\n                            vec3(1.0, 0.4, 0.0), 1.0,\n                            sdCuboid(Translate(p, vec3(-300.0, -12.5, -300.0)), 125.0, 250.0, 200.0));\n\n    Surface cone = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(1.0, 1.0, 0.0),\n                            vec3(1.0, 1.0, 1.0), 8.0,\n                            sdCone(Translate(p, vec3(0.0, 25.0, -300.0)), 50.0, 100.0));\n\n    Surface cylinder = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(0.0, 1.0, 0.0),\n                            vec3(0.0, 0.0, 0.0), 0.0,\n                            sdCylinder(Translate(p, vec3(300.0, 0.0, -300.0)), 150.0, 50.0));\n\n    Surface torus = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(0.0, 0.0, 1.0),\n                            vec3(1.0, 1.0, 1.0), 8.0,\n                            sdTorus(Translate(p, vec3(-150.0, -35.0, 100.0)), 100.0, 40.0));\n\n    Surface sphere = Surface(vec3(0.0, 0.0, 0.0),\n                            vec3(1.0, 0.0, 0.0),\n                            vec3(1.0, 1.0, 1.0), 8.0,\n                            sdSphere(Translate(p, vec3(150.0, 0.0, 100.0)), 75.0));\n\n    return Union(plane, Union(cuboid, Union(cone, Union(cylinder, Union(torus, sphere)))));\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy).signedDistance - mapScene(p - GRADIENT_STEP.xyy).signedDistance;\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy).signedDistance - mapScene(p - GRADIENT_STEP.yxy).signedDistance;\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx).signedDistance - mapScene(p - GRADIENT_STEP.yyx).signedDistance;\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Sky mapping function:\nvec3 mapSky(in Ray ray) {\n    return mix(vec3(1.0), vec3(0.25, 0.25, 1.0), 0.5 + 0.5 * ray.direction.y);\n}\n\n// Fog function:\nvec3 applyFog(in vec3 shade, in Ray ray, in float rayDistance) {\n    float lightAmount = max(0.0, dot(ray.direction, lightDirection));\n    vec3 fog = mix(fogColor, lightColor, pow(lightAmount, lightPower));\n    float fogAmount = 1.0 - exp(-rayDistance * fogginess);\n    return mix(shade, fog, fogAmount);\n}\n\n// Shadow mapping function:\nfloat mapShadow(in vec3 p, in vec3 normal, in float softness) {\n    float softShadow = 1.0;\n    p += normal * SHADOW_BIAS;\n    float shadowDistance = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        vec3 shadowTestPosition = p + lightDirection * shadowDistance;\n        Surface occluderSurface = mapScene(shadowTestPosition);\n        if (abs(occluderSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            return 0.0;\n        }\n\n        if (shadowDistance > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        shadowDistance += occluderSurface.signedDistance;\n        softShadow = min(softShadow, softness * occluderSurface.signedDistance / shadowDistance);\n    }\n\n    return softShadow;\n}\n\n// Surface shader (uses the Phong illumination model):\nvec3 shadeSurface(in Surface surface, in vec3 hitPosition, in Ray ray, in vec3 normal) {\n    vec3 illuminationAmbient = surface.ambientColor * lightEmissionColor;\n\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * surface.diffuseColor * lightEmissionColor;\n\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.direction));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, surface.shininess), 0.0, 1.0) * surface.specularColor * lightEmissionColor;\n\n    return illuminationAmbient + (illuminationDiffuse + illuminationSpecular) * mapShadow(hitPosition, normal, shadowSoftness);\n}\n\n// Raymarching loop:\nvec4 rayMarch(in Ray ray) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; iterations++) {\n        vec3 currentPosition = ray.origin + ray.direction * distanceTraveled;\n        Surface sceneSurface = mapScene(currentPosition);\n        if (abs(sceneSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n            vec3 color = shadeSurface(sceneSurface, currentPosition, ray, normal);\n            color = applyFog(color, ray, distanceTraveled);\n            return vec4(color, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += sceneSurface.signedDistance;\n    }\n\n    return vec4(mapSky(ray), 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 screenCenter = 0.5 * iResolution.xy;\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    cameraPosition = Rotate(cameraPosition, vec3(0.0, -iTime * 20.0, 0.0));\n    float tilt = iMouse.y - screenCenter.y;\n    if (iMouse.z > 0.0) cameraPosition.y += tilt * tiltSpeed;\n\n    cameraForward = -normalize(cameraPosition);\n    cameraRight = normalize(vec3(-cameraForward.z, 0.0, cameraForward.x));\n    cameraUp = cross(cameraRight, cameraForward);\n\n    for (float yOffset=0.0; yOffset < antialiasing.y; yOffset++) {\n        for (float xOffset=0.0; xOffset < antialiasing.x; xOffset++) {\n            vec2 pixel = fragCoord + vec2(xOffset, yOffset) / antialiasing - screenCenter;\n            vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n            vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * pixel.x - cameraUp * pixel.y));\n            fragColor += rayMarch(Ray(rayOrigin, rayDirection));\n        }\n    }\n\n    fragColor /= antialiasing.y * antialiasing.x;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3styDs.jpg", "access": "shaders20k", "license": "mit", "functions": [[2860, 2897, 2934, 2934, 2958], [2960, 3137, 3200, 3200, 3313], [3315, 3315, 3364, 3364, 3749], [3751, 3751, 3804, 3804, 3926], [3928, 3928, 3980, 3980, 4036], [4038, 4038, 4077, 4077, 4105], [4107, 4155, 4212, 4212, 4381], [4383, 4383, 4447, 4447, 4644], [4646, 4646, 4708, 4708, 5038], [5040, 5060, 5098, 5098, 5118], [5120, 5120, 5155, 5155, 5766], [5768, 5768, 5802, 5802, 5822], [5824, 5851, 5880, 5880, 7494], [7496, 7545, 7578, 7578, 7998], [8000, 8025, 8050, 8050, 8131], [8133, 8150, 8214, 8214, 8456], [8458, 8486, 8549, 8549, 9216], [9218, 9273, 9361, 9361, 9973], [9975, 9996, 10023, 10023, 10762], [10764, 10797, 10852, 10852, 11860]]}
{"id": "3sVcWm", "name": "Grid road", "author": "vanx", "description": "Infinite 3D road with a grid texture and a moving sphere beneath it.", "tags": ["3d"], "likes": 5, "viewed": 153, "published": "Public", "date": "1603022472", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define EPSILON 0.0001\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5*(b-a)/k, 0.0, 1.0);\n    return mix(b, a, h) - k*h*(1.0-h);\n}\n\nfloat map(vec3 p) { \n    float sphere = distance(p, vec3(sin(iTime)*.2, sin(iTime)*.15, 0.0))-.1;    \n    float plane = p.y + (abs(p.x) > 2.?2.:0.);\n    return smin(plane,sphere,0.1);\n}\n\nfloat trace(vec3 origin, vec3 direction) {\n    float dist = 0.0;\n    for (float i = 0.0; i < 100.0 ; i++) {\n        vec3 p = origin + direction*dist;\n        float d = map(p);\n        if (d <= 0.001) {\n            break;\n        }\n        dist += d*.05;\n    }\n    return dist;\n}\n\nvec3 normal(vec3 p) {\n    return normalize(vec3(\n        map(vec3(p.x + EPSILON, p.y, p.z)) - map(vec3(p.x - EPSILON, p.y, p.z)),\n        map(vec3(p.x, p.y + EPSILON, p.z)) - map(vec3(p.x, p.y - EPSILON, p.z)),\n        map(vec3(p.x, p.y, p.z  + EPSILON)) - map(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 albedo(vec3 p) {\n  p *=2.5;\n  float a = 0.1;\n  float b = a + 0.01;\n  return 1.-vec3(2.) * smoothstep(a,b,fract(p.x))* smoothstep(a,b,fract(p.z + iTime*1.5));  \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n    coord -= 0.5;\n    coord.x *= iResolution.x/iResolution.y;\n    \n    vec3 light = vec3(0.0, 15.5,2.0);\n\n    vec3 direction = normalize(vec3(coord, 1.0));\n    vec3 origin = vec3(0.0, 2.,-4.);\n    float dist = trace(origin, direction);  \n\n    vec3 p = origin + dist*direction;\n    vec3 norm = normal(p);    \n\n    vec3 diffuse = vec3(0.6,0.6,1.0)*clamp(dot(normalize(light-p), norm), 0.0, 1.0);    \n  \n    float brightness = 1.0-smoothstep(5.0, 300.0, distance(p, light));\n\n    vec3 color = vec3(0.0);  \n    color += diffuse*brightness*smoothstep(-20.0, -10.0, -distance(p, vec3(0.0))) * albedo(p);\n      \n    fragColor = vec4(color, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVcWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 63, 63, 154], [156, 156, 175, 175, 341], [343, 343, 385, 385, 621], [623, 623, 644, 644, 924], [926, 926, 947, 947, 1092], [1094, 1094, 1151, 1151, 1877]]}
{"id": "3sVczK", "name": "Rect to Polar Mask Example", "author": "movecraft", "description": "Rect to Polar Mask Example", "tags": ["polar"], "likes": 0, "viewed": 44, "published": "Public", "date": "1603247502", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592653589793\n\nvec2 convert(vec2 uv) {\n    float s = 2.0/PI;\n    float r = length(uv);\n    float theta = mod(atan(uv.y , uv.x ) + PI/2.0 + PI, 2.0*PI) - PI;\n    return vec2(s * theta, -r*3.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = (2.0*fragCoord.xy-iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec2 color = convert(uv);\n    float m = step(color.x+ ( fract(iTime*.5)*4.-PI*.5 ),.5);\n    \n    fragColor = vec4(vec3(m), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVczK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 53, 53, 209], [212, 212, 269, 269, 486]]}
{"id": "3sVyW1", "name": "Psychedelic Bubbling Lava", "author": "jarble", "description": "An edit of my [url=https://www.shadertoy.com/view/wsycD1]\"Neon Cells\"[/url] shader.", "tags": ["fractal", "bubbles", "lava"], "likes": 3, "viewed": 224, "published": "Public API", "date": "1602739865", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*5.0-iResolution.xy)/iResolution.y;\n        t = iTime;\n        for(int i=0;i<3;i++)\n        {\n        \tuv += (sin(iTime+uv.x)+cos(iTime+uv.y));\n            uv += uv*rot(length(sin(col)));\n        }\n     col[c] = (sin(uv.x)+cos(uv.y));\n\t}\n    \n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVyW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 485]]}
{"id": "3sVyWK", "name": "RNG using sine", "author": "kmccord1", "description": "testing randomness", "tags": ["fun"], "likes": 1, "viewed": 184, "published": "Public API", "date": "1603847203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 normal = fragCoord/iResolution.xy;\n   vec3 col = vec3(rand(fragCoord.xy + (iTime * 0.1)), rand(fragCoord.xy + (iTime * 0.1) - 500.0), rand(fragCoord.xy + (iTime * 0.1) - 1000.0));\n   fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVyWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 90], [91, 91, 148, 148, 368]]}
{"id": "3sXBDM", "name": "emerald noise", "author": "aberkson1", "description": "Fun with noise", "tags": ["noisegreen"], "likes": 3, "viewed": 43, "published": "Public", "date": "1601864825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define PI 3.141593262\n#define scale 25.0\n\nfloat random (vec2 st) \n{\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nfloat plot(vec2 uv, float pct)\n{\n\treturn smoothstep(pct-10.0, pct, uv.y) - smoothstep(pct, pct+10.0, uv.y);   \n}\n\nfloat func(vec2 ipos)\n{\n    vec3 center = vec3(floor(0.5 * scale), floor(0.5 * scale), -1.0);\n    float dist = distance(vec3(ipos,-1.0), center);\n\treturn sin(dist * 400.0*sin(iTime / 200.0) / 2.0) - 0.2;    \n}\n\nfloat _smooth(in vec2 ipos, in vec2 uv)\n{\n    \n    float a = func(ipos);\n    float b = func(ipos + vec2(1.0, 0.0));\n    float c = func(ipos + vec2(0.0, 1.0));\n    float d = func(ipos + vec2(1.0, 1.0));\n   \n    \n    vec2 u = smoothstep(0.0, 1.0, uv );\n    \n    return mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) +\n        \t  (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 ipos = floor(uv * scale);\n    float y = _smooth(ipos, fract(uv * scale));\n    float pct = plot(ipos, y);\n    \n\n    fragColor = vec4(vec3(0., y, 0.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXBDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 69, 69, 176], [178, 178, 210, 210, 290], [292, 292, 315, 315, 501], [503, 503, 544, 544, 850], [852, 852, 909, 909, 1121]]}
{"id": "3sycDD", "name": "DronesyInSpace", "author": "vageev01", "description": "intro for web game", "tags": ["game", "intro"], "likes": 2, "viewed": 84, "published": "Public", "date": "1602820153", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// --- access to the image of ascii code c // from Fabrice ;\n#define C(c) U.x-=.5; T+= U.x<.0||U.x>1.||U.y<0.||U.y>1. ?vec4(0): texture( iChannel0, U/16. + fract( floor(vec2(c, 15.999-float(c/16))) / 16.))/1.5\n\n\n\nfloat shtoy(vec2 U) { // to alter in the icon with the alter message\n    vec4 T = vec4(0); \n    C(32);C(32);C(32);C(32);C(32);C(32);C(32);C(68);C(82);C(79);C(78);C(69);C(83);C(89);C(32);C(32);C(32);C(32);C(32);C(32);C(32);C(32);\n  \n    return length(T.yz)==0. ? 0. : T.x;\n}\n\n\n \n\n\n#define dir 2    // define direction 0,1,2,3  up/down/left/right\n#define time iTime\n#define speed 0.4\n\nvec2 mod289(vec2 x) {\n\t\t  return x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\n\t\tvec3 mod289(vec3 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec4 mod289(vec4 x) {\n\t\t  \treturn x - floor(x * (1.0 / 289.0)) * 289.0;\n\t\t}\n\t\t\n\t\tvec3 permute(vec3 x) {\n\t\t  return mod289(((x*34.0)+1.0)*x);\n\t\t}\n\n\t\tvec4 permute(vec4 x) {\n\t\t  return mod((34.0 * x + 1.0) * x, 289.0);\n\t\t}\n\n\t\tvec4 taylorInvSqrt(vec4 r)\n\t\t{\n\t\t  \treturn 1.79284291400159 - 0.85373472095314 * r;\n\t\t}\n\t\t\n\t\tfloat snoise(vec2 v)\n\t\t{\n\t\t\t\tconst vec4 C = vec4(0.211324865405187,0.366025403784439,-0.577350269189626,0.024390243902439);\n\t\t\t\tvec2 i  = floor(v + dot(v, C.yy) );\n\t\t\t\tvec2 x0 = v -   i + dot(i, C.xx);\n\t\t\t\t\n\t\t\t\tvec2 i1;\n\t\t\t\ti1 = (x0.x > x0.y) ? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n\t\t\t\tvec4 x12 = x0.xyxy + C.xxzz;\n\t\t\t\tx12.xy -= i1;\n\t\t\t\t\n\t\t\t\ti = mod289(i); // Avoid truncation effects in permutation\n\t\t\t\tvec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n\t\t\t\t\t+ i.x + vec3(0.0, i1.x, 1.0 ));\n\t\t\t\t\n\t\t\t\tvec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n\t\t\t\tm = m*m ;\n\t\t\t\tm = m*m ;\n\t\t\t\t\n\t\t\t\tvec3 x = 2.0 * fract(p * C.www) - 1.0;\n\t\t\t\tvec3 h = abs(x) - 0.5;\n\t\t\t\tvec3 ox = floor(x + 0.5);\n\t\t\t\tvec3 a0 = x - ox;\n\t\t\t\t\n\t\t\t\tm *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n\t\t\t\t\n\t\t\t\tvec3 g;\n\t\t\t\tg.x  = a0.x  * x0.x  + h.x  * x0.y;\n\t\t\t\tg.yz = a0.yz * x12.xz + h.yz * x12.yw;\n\n\t\t\t\treturn 130.0 * dot(m, g);\t\t\n\t\t}\n\t\t\n\t\tfloat cellular2x2(vec2 P)\n\t\t{\n\t\t\t\t#define K 0.142857142857 // 1/7\n\t\t\t\t#define K2 0.0714285714285 // K/2\n\t\t\t\t#define jitter 0.8 // jitter 1.0 makes F1 wrong more often\n\t\t\t\t\n\t\t\t\tvec2 Pi = mod(floor(P), 289.0);\n\t\t\t\tvec2 Pf = fract(P);\n\t\t\t\tvec4 Pfx = Pf.x + vec4(-0.5, -1.5, -0.5, -1.5);\n\t\t\t\tvec4 Pfy = Pf.y + vec4(-0.5, -0.5, -1.5, -1.5);\n\t\t\t\tvec4 p = permute(Pi.x + vec4(0.0, 1.0, 0.0, 1.0));\n\t\t\t\tp = permute(p + Pi.y + vec4(0.0, 0.0, 1.0, 1.0));\n\t\t\t\tvec4 ox = mod(p, 7.0)*K+K2;\n\t\t\t\tvec4 oy = mod(floor(p*K),7.0)*K+K2;\n\t\t\t\tvec4 dx = Pfx + jitter*ox;\n\t\t\t\tvec4 dy = Pfy + jitter*oy;\n\t\t\t\tvec4 d = dx * dx + dy * dy; // d11, d12, d21 and d22, squared\n\t\t\t\t// Sort out the two smallest distances\n\t\t\t\t\n\t\t\t\t// Cheat and pick only F1\n\t\t\t\td.xy = min(d.xy, d.zw);\n\t\t\t\td.x = min(d.x, d.y);\n\t\t\t\treturn d.x; // F1 duplicated, F2 not computed\n\t\t}\n\n\n#define PI 3.14159265358979\n\nconst float pi = 3.14159;\nmat3 xrot(float t)\n{    return mat3(1.0, 0.0, 0.0,\n    0.0, cos(t), -sin(t),\n    0.0, sin(t), cos(t));\n}\nmat3 yrot(float t)\n{    return mat3(cos(t), 0.0, -sin(t),\n    0.0, 1.0, 0.0,\n    sin(t), 0.0, cos(t));\n}\n\nmat3 zrot(float t)\n{    return mat3(cos(t), -sin(t), 0.0,\n    sin(t), cos(t), 0.0,\n    0.0, 0.0, 1.0);\n}\n\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nvec2 uv (vec3 p) {\n\tfloat x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float u = atan(x, z) / (2. * PI) + .5;\n    float v = asin(y) / (PI) + .5;\n    return vec2(u,v);\n}\n\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) +\n    length(max(d,0.0));\n}\n\nfloat udBox( vec3 p, vec3 b, float r )\n{\n\treturn length(max(abs(p)-b,0.0))-r;\n}\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nvec2 map(vec3 p)\n{\n    vec2 f=(fract(p.xy) * 2.0 - 1.0) ;\n    vec3 q = vec3(f.x-0.5, f.y, p.z);\n    float br = 0.4;\n    float c = sdCylinder(  p+vec3( 0.0,0.60,-1.0), vec2(3.0,3.0)  );\n   // float b = sdCylinder(p, vec2(1.1,1.3))*br;\n    \n  //  float b= sdBox(p-vec3( 0.0,0.25, 0.0), vec3(0.65) );\n \n    float  ss = sdSphere(    p-vec3( 0.0,0.00, 0.0),1.00 )  ;\n  \n    return vec2(ss, ss);\n    \n}\nvec3 normal(vec3 p)\n{\n    vec3 o = vec3(0.02, 0.0, 0.0);\n    return normalize(vec3(map(p+o.xyy).x - map(p-o.xyy).x,\n    map(p+o.yxy).x - map(p-o.yxy).x,\n    map(p+o.yyx).x - map(p-o.yyx).x));\n}\nfloat trace(vec3 o, vec3 r)\n{\n    float t = 0.0;\n    for (int i = 0; i < 32; ++i) {\n    vec3 p = o + r * t;\n    float d = map(p).x;\n    t += d;\n\t}\nreturn t;\n}\n\nvec4 tex(vec3 p)\n{\n    \n    \n    vec4 tx= texture(iChannel1,uv(normalize(p)));\n    \n    return (tx ) ;\n}\n\n\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n   \n    \n    float t=iTime*3.0;\n    \n     \n    vec2 uv3 = fragCoord.xy / iResolution.xy;\n   \t\t uv3 = uv3 * 2.0 - 1.0;\n   \t\t uv3.x *=iResolution.x/iResolution.y;    \n \n    \n    \n    vec2 uv = fragCoord.xy / iResolution.xy ;\n\t\t\t\n\t\tuv.x*=(iResolution.x/iResolution.y);\n    \n    vec2 uvs = uv*2.-1.0;\n    \n    float rot = radians(iTime * 360.0)/30.0;\n    \n     \n    \n    mat2 m = mat2(cos(rot), -sin(rot), sin(rot), cos(rot));\n   \t\n    float gtimer = iTime;\n    \n    uv = uv -0.5;\n    if (gtimer>30.0) {  uv  = m * uv;\n    \t\t\t\t\tuv +=vec2(0.5,0.0);\n    }\n    if (gtimer>60.0) {  uv  = m * -uv;\n    \t\t\t\t\tuv +=vec2(0.5,0.0);\n    }\n\t\t\t\t\t\n\t\tvec2 GA=vec2(0);\n\t\t\t\t\n        #if dir==0 \n        GA.y +=time*speed;\n        #elif dir==1\n        GA.y -=time*speed;\n        #elif dir==2\n        GA.x +=time*speed;\n        #elif dir==3\n        GA.x -=time*speed;\n        #endif\n\t\t\n    \t// multi declaration \n        float   F1,F2,F3,F4,F5,F6,F7,F8=0.0;\n\t\tfloat   N1,N2,N3,N4,N5,N6,N7,N8=0.0;\n\t\tfloat A,A1,A2,A3,A4,A5,A6,A7,A8=0.0;\n\t\n\n\n\t// Snow layers, somewhat like an fbm with worley layers.\n\tF1 = 1.0-cellular2x2((uv+(GA*0.1))*8.0);\t\n\tA1 = 1.0-(A*0.8);\n\tN1 = smoothstep(0.9998,1.0,F1)*0.2*A1;\t\n\n\tF2 = 1.0-cellular2x2((uv+(GA*0.2))*7.0);\t\n\tA2 = 1.0-(A*0.8);\n\tN2 = smoothstep(0.9998,1.0,F2)*0.3*A2;\t\t\t\t\n\n\tF3 = 1.0-cellular2x2((uv+(GA*0.3))*6.0);\t\n\tA3 = 1.0-(A*0.8);\n\tN3 = smoothstep(0.9998,1.0,F3)*0.4*A3;\t\t\t\n            \n    F4 = 1.0-cellular2x2((uv+(GA*0.4))*5.0);\t\n\tA4 = 1.0-(A*0.8);\n\tN4 = smoothstep(0.9998,1.0,F4)*0.5*A4;\t\n            \n    F5 = 1.0-cellular2x2((uv+(GA*0.5))*4.0);\t\n\tA5 = 1.0-(A*0.8);\n\tN5 = smoothstep(0.9998,1.0,F5)*0.6*A5;\t\n\t\t\t\t\t\t\t\t\n    F6 = 1.0-cellular2x2((uv+(GA*0.8))*3.0);\t\n\tA6 = 1.0-(A*0.8);\n\tN6 = smoothstep(0.9999,1.0,F6)*0.59*A6;\n    \n    F7 = 1.0-cellular2x2((uv+(GA*1.2))*2.9);\t\n\tA7 = 1.0-(A*0.8);\n\tN7 = smoothstep(0.9999,1.0,F7)*0.58*A7;\n    \n    F8 = 1.0-cellular2x2((uv+(GA*1.8))*2.8);\t\n\tA8 = 1.0-(A*0.8);\n\tN8 = smoothstep(0.9999,1.0,F8)*0.57*A8;\n   \n    \n    \n\t float cl= (N8+N7+N6+N5+N4+N3+N2+N1)*2.0;\n \n   \n    float tm=iTime/5.0;\n    \n   \n    \n    vec3 r = normalize(vec3(uv3, 1.3));//1.5\n    vec3 o = vec3(0.0, 0.0, -2.5);\n \n    mat3 xfm = yrot(-iMouse.x*0.01)*xrot(iMouse.y*0.01)*zrot(0.);\n    xfm *= xrot(0.4*tm*3.5);// unused !\n    o *= xfm;\n    r *= xfm;\n    float tt = trace(o, r);\n    vec3 w = o + r * tt;\n    vec3 sn = normal(w);\n    vec2 fd = map(w);\n    vec3 lpos = o-1.8*sin(tm)  ;// remove  \n    vec3 ldel = lpos - w;\n    float llen = length(ldel);\n    ldel /= llen;\n    vec3 refl = reflect(ldel, sn);\n    float prod = max(dot(ldel,sn), 1.5)*1.5;\n    float spow = max(dot(refl,r), 0.1);\n    vec4 diff = tex(w*0.4);//0.4\n    vec4 spec = vec4(0.0);\n    float fog = 1.0 / (1.0 + t * t * 0.1 + fd.x * 500.0);\n    vec4 fc = (diff * prod + spec * spow) * fog;\n    \n    //uv3.x = uv3.x+0.2*iTime;\n   \n      \n     \n    \n    \n     vec3 tx   = 2.*texture(iChannel2,uv).xyz;\n        \n     float txty = 2.0;\n     float txtx = -4.0;           \n       \n     float intensity =1.0;\n    \n    \n     uvs = uvs -0.5;\n    if (gtimer>=32.0) {intensity =0.1+abs(2.*sin(gtimer)*2.0);}\n   \n    if (gtimer>=34.0) {uvs.y += 0.5+2.2*sin(gtimer)*0.5;}\n    if (gtimer>=44.0) {uvs.x += 0.5+2.2*sin(gtimer)*0.8;}\n    if (gtimer>=64.0) {uvs.x -= 0.5+2.2*sin(-gtimer)*0.8;}\n    \n      \n      \n  float a  = shtoy((uvs*0.9*5.*abs(sin(iTime*0.8)))-vec2(txtx,txty-4.8));\n        a += shtoy((uvs*1.1*5.*abs(sin(iTime*0.7)))-vec2(txtx,txty-4.2));\n        a += shtoy((uvs*1.2*5.*abs(sin(iTime*0.6)))-vec2(txtx,txty-3.6));\n        a += shtoy((uvs*1.3*5.*abs(sin(iTime*0.5)))-vec2(txtx,txty-3.0));\n        a += shtoy((uvs*1.4*5.*abs(sin(iTime*0.4)))-vec2(txtx,txty-2.4));\n        a += shtoy((uvs*1.5*5.*abs(sin(iTime*0.3)))-vec2(txtx,txty-1.8));\n        a += shtoy((uvs*1.6*5.*abs(sin(iTime*0.2)))-vec2(txtx,txty-1.2));\n\n     \n    \n     \n     \n                      \n     float final = a ;\n        \n     fragColor    = vec4(mix(vec3(final*tx.r,final*tx.g,final*tx.b)*intensity,\n                             \n                             \n                             vec3(cl,cl,cl),cl),1.0); \n      \n     \n   // *** bar layer\n    \n    vec2 bl = fragCoord.xy / iResolution.xy;\n    \n    if(bl.y>.50-min(t/8.,0.4) ^^ bl.y<0.50+min(t/8.0,.4))  fragColor  = vec4(0.2,0.2,0.2,1.0);\n    \n     \n    \n    \n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sycDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 213, 234, 281, 486], [596, 596, 617, 617, 670], [674, 674, 695, 695, 749], [755, 755, 776, 776, 830], [836, 836, 858, 858, 899], [903, 903, 925, 925, 974], [978, 978, 1008, 1008, 1065], [1071, 1071, 1095, 1095, 2016], [2022, 2022, 2051, 2051, 2851], [2909, 2909, 2929, 2929, 3013], [3014, 3014, 3034, 3034, 3118], [3120, 3120, 3140, 3140, 3224], [3227, 3227, 3262, 3262, 3288], [3290, 3290, 3308, 3308, 3464], [3468, 3468, 3499, 3499, 3594], [3596, 3596, 3636, 3636, 3675], [3676, 3676, 3712, 3712, 3815], [3816, 3816, 3834, 3834, 4212], [4213, 4213, 4234, 4234, 4406], [4407, 4407, 4436, 4436, 4565], [4567, 4567, 4585, 4585, 4671], [4680, 4680, 4737, 4737, 9028]]}
{"id": "3sycDy", "name": "ProgTober_Rotation", "author": "JulesFouchy", "description": "Rotation", "tags": ["rotation"], "likes": 1, "viewed": 61, "published": "Public", "date": "1603592086", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst vec3 uCamX = vec3(0.02645375, -0.0, -0.9996501);\nconst vec3 uCamY = vec3(0.0075564627, 0.9999715, 0.00019996673);\nconst vec3 uCamZ = vec3(0.9996215, -0.0075591076, 0.02645299);\nconst vec3 uCamPos = vec3(5.99773, -0.04535465, 0.15871796);\nconst float uFocalLength = 1.0;\n\nconst vec3 lightDir = normalize(vec3(1,2,3));\n\n#define TAU 6.28\n\n#define MAX_STEPS 1000\n#define MAX_DIST 100.\n#define SURF_DIST .0001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nfloat sdf(vec3 p) {\n    return length(p) - 1.0 + 0.1 * sin(p.y*10.+3.141592653);\n}\n\nfloat opTwist(vec3 p)\n{\n    const float k = 3.0; // or some other amount\n    float c = cos(k*p.y+iTime*0.2);\n    float s = sin(k*p.y+3.141592653*iTime*0.2);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return sdf(q);\n}\n\n\nfloat GetDist(vec3 p) {\n    float res = 0.1 * opTwist(p);\n    return res;\n}\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO = 0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n\n    vec3 col = vec3(0);\n    vec3 ro = uCamPos; //- vec3(proj.x, 0., proj.y);\n    vec3 rd = normalize(\n          uCamX * (uv.x - 0.5) * iResolution.x / iResolution.y\n        + uCamY * (uv.y - 0.5)\n        - uCamZ * uFocalLength\n    );\n\n    float res = RayMarch(ro, rd);\n    \n    if (res<MAX_DIST) {\n        const vec3 difCol = vec3(0.3, 0.1, 1.);\n        vec3 p = ro + rd * res;\n    \tvec3 n = GetNormal(p);\n        \n    \tfloat dif = dot(n, lightDir)*.5+.5;\n    \tcol += dif * difCol;\n        vec3 nor = GetNormal(p);\n        float shadow = RayMarch(p+0.001, lightDir) < MAX_DIST ? 0.4 : 1.;\n        col *= shadow;\n    }\n    else {\n        float t = 1. - abs(rd.y);\n        col = mix(vec3(8.), vec3(0.2), t);\n    }\n    \n    col = pow(col, vec3(.4545)); // gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sycDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[451, 451, 470, 470, 532], [534, 534, 556, 556, 650], [652, 652, 693, 693, 767], [769, 769, 788, 788, 851], [853, 853, 876, 876, 1092], [1095, 1095, 1118, 1118, 1170], [1171, 1171, 1205, 1205, 1418], [1420, 1420, 1444, 1444, 1634], [1635, 1635, 1692, 1742, 2591]]}
{"id": "3sycRR", "name": "Bounding Balls Test", "author": "beherca", "description": "Bounding balls Test", "tags": ["balls"], "likes": 1, "viewed": 60, "published": "Public", "date": "1602059692", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.youtube.com/watch?v=l-07BXzNdPw&t=129s\n\nvec2 N22(vec2 p){\n    vec3 a = fract(p.xyx * vec3(123.34,234.34,345.65));\n    a += dot(a, a+34.45);\n    return fract(vec2(a.x*a.y, a.y*a.z));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float m = 0.;\n\n    for(float i=0.;i<150.;i++){\n        vec2 nv = N22(vec2(i));\n        vec2 p = sin(nv * 10. * iTime);\n        float d = length(uv -p);\n        m+= smoothstep(0.02, 0.019, d);\n    }\n    \n    vec3 col = vec3(m);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sycRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 55, 72, 72, 198], [200, 200, 257, 307, 682]]}
{"id": "3sycRV", "name": "Liam's Mobius loop", "author": "liamail", "description": "mobius loop", "tags": ["mobiusloop"], "likes": 3, "viewed": 120, "published": "Public", "date": "1603202623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Credit:\n// \"RayMarching starting point\" \n// by Martijn Steinrucken aka The Art of Code/BigWings - 2020\n// The MIT License\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n// Email: countfrolic@gmail.com\n// Twitter: @The_ArtOfCode\n// YouTube: youtube.com/TheArtOfCodeIsCool\n// Facebook: https://www.facebook.com/groups/theartofcode/\n//\n// You can use this shader as a template for ray marching shaders\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdBox2d(vec2 p, vec2 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, p.y), 0.);\n}\n\nfloat GetDist(vec3 p) {\n    float r1 = 1.7, r2 = .3;\n    vec2 cp = vec2(length(p.xz) - r1, p.y);\n    float a = atan(p.x,p.z); // polar angle between -pi and pi\n    cp *= Rot(a * .5 + iTime*0.5);\n    cp.y = abs(cp.y) - .4;\n    float d1 = length(cp) - r2;\n   \td1 = sdBox2d(cp, vec2(.01,.4))-0.01; // nice trefoil shape\n    float d3 = sdBox2d(cp, vec2( 4.*sin(a*iTime*0.07-.4)*0.0141 - .1,.1+.281*sin(iTime*.3)))-0.2;\n    \n\n    float d4 = sdBox2d(cp,vec2(.2,.3*sin(4.*a)*.8+.5))-.1;\n    float d5 = sdBox2d(cp,vec2(.1,-0.4+.3*sin(12.*a)*.5+.5))-.1;\n    //d3 *= Rot(iTime);\n    float d6 = sdBox2d(cp, vec2(4.*sin(a*3. + iTime*3.1415*3.3-.4)*0.0141 - .1,.1+.281*sin(iTime*.3)))-0.2;\n    \n    //float d2 = length(vec2(length(p.xz)-r1,p.y))-.4; // torus\n//    float d = smoothstep(d1,d2,sin(iTime*0.7)*.5+0.5); // Doesnt work\n    return d1*0.37;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;\n    \n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        float dS = GetDist(p);\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return dO;\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p);\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy),\n        GetDist(p-e.yxy),\n        GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvec3 Bg(vec3 rd) {\n    float k = rd.y*.5 + .5;\n    \n    vec3 col = mix(vec3(.2,.1,.1),vec3(.2,.5,.1),k);\n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    \n    vec3 col = vec3(0);\n    // vec3 \n    vec3 ro = vec3(0, 3, -3);\n    ro.yz *= Rot(-m.y*3.14+1.);\n    ro.xz *= Rot(-m.x*6.2831);\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n\t\n    col += Bg(rd);\n    \n    float d = RayMarch(ro, rd);\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        vec3 r = reflect(rd, n);\n        \n        float spec =pow( max(0., r.y), 20.);\n    \tfloat dif = dot(n, normalize(vec3(1,2,3)))*.5+.5;\n    \tcol = mix(Bg(r), vec3(dif),.5) + spec; \n        //col = vec3(spec);\n    }\n    \n    col = pow(col, vec3(.4545));\t// gamma correction\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sycRV.jpg", "access": "shaders20k", "license": "mit", "functions": [[0, 1486, 1505, 1505, 1567], [1569, 1569, 1591, 1591, 1685], [1687, 1687, 1716, 1716, 1797], [1799, 1799, 1830, 1830, 1901], [1903, 1903, 1926, 1926, 2742], [2744, 2744, 2778, 2778, 2989], [2991, 2991, 3015, 3015, 3205], [3207, 3207, 3257, 3257, 3448], [3451, 3451, 3469, 3469, 3578], [3580, 3580, 3637, 3637, 4374]]}
{"id": "3sycWw", "name": "Fab19 #inktober2020 \"dizzy\"", "author": "FabriceNeyret2", "description": "Sorry for the inconvenience. I didn't choose the #19 word :-p\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "3tweets", "inktober2020"], "likes": 2, "viewed": 189, "published": "Public API", "date": "1602925361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(U,n,s) smoothstep(.9,1., cos( n* 6.3*length(U) -atan((U).y,(U).x) +s*t )) //\nvoid mainImage(out vec4 O, vec2 U) {\n    float t = iTime;\n    vec2 R = iResolution.xy,\n         V = (U/R-.5) * mat2(cos(.3*cos(t)+vec4(0,11,33,0)))\n                      * (1.+.2*sin(2.1*t)) + .5\n             +.05* cos(t/.1)+.03* cos(30.*vec2(-t,t));\n    O = texture(iChannel0, V ) -.5;\n    O.rg *=   mat2( cos( 6.3*t  + vec4(0,23,21,0)) );\n    O += .5  + S((U+U-R)/R.y, 2.,3.);\n    O.b += S(V-.5, 3.,-3.);}", "image_inputs": [{"id": "Xdf3Rn", "previewfilepath": "/media/ap/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e81e818ac76a8983d746784b423178ee9f6cdcdf7f8e8d719341a6fe2d2ab303.webm", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sycWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[87, 87, 123, 123, 494]]}
{"id": "3syyWw", "name": "Fab18 #inktober2020 \"trap\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]\nReference image: [img] https://miro.medium.com/max/770/1*y8l3aj1E5z_QyjcI5NUxcQ.png [/img]", "tags": ["short", "golf", "reproduction", "inktober2020"], "likes": 10, "viewed": 188, "published": "Public API", "date": "1602920206", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)      mat2( cos(a+vec4(0,11,33,0)) )            // rotation                  \n\n#define jaw(o)   \\\n        s = mod(o+16.*atan(q.x,q.z)/3.14,2.), s = min(s,2.-s),/* dents */           \\\n        t = min(t, max( abs(length(q.xz)-8.)-.1, max( abs(q.y-s)-1.5-s, -q.z ) ) ), /* round part */ \\\n        a = abs(q+4.*Z), t = min(t, max( max( abs(a.x-8.)-.1,a.y-1.5 ), a.z - 4. )) // straight part\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,s;\n    vec3  R = iResolution, e = vec3(1,-1,0), X=e.xzz, Y=e.zxz, Z=e.zzx,\n          M = iMouse.z > 0. ? iMouse.xyz/R : vec3(4,2,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),          // ray direction\n          p = 50./R, q,a;                                     // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )\n        q = p, t=9.,\n        q.yz *= rot( .4 +6.*M.y),                             // rotations\n        q.xz *= rot(-.7 -6.*M.x), \n        q.y += 5., q.z += 7., a = abs(q),\n        t = min(t, max( length(q.xz)-3.5, abs(q.y-1.)-.1) ),  // plate\n        t = min(t, max( length(q.zy) -.5,    a.x - 9.   ) ),  // axe\n        a = abs(q+1.5*Y)-10.*X,  t = min(t, max( max( a.x-1.,a.y-.15 ), // bar\n                                                 max( a.z-1.,.4-length(a.xz)) )),\n        q.z-=7., jaw(),                                       // bottom jaw\n        q.z+=7., q.yz*=rot(-1.5+1.1*atan(30.*sin(iTime))/1.5 ),q.z-=7., // animated opening angle\n        q.x-=.4, q.y= -q.y, jaw(1.2),                         // top jaw\n        p += .5*t*D;                                          // step forward = dist to obj          \n\n    O = exp(-2.5*O) * vec4(1,1,1.2,1);                        // coloring\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syyWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[403, 403, 439, 439, 1742]]}
{"id": "3syyzm", "name": "inercia Shader Royale 2020 NuSan", "author": "NuSan", "description": "Shader coded live during Inercia Shader Royale 2020 Competion: 1st place\nShader was made in about 50m, with 7 other coders competing at the same time", "tags": ["raymarching", "livecoding", "inercia"], "likes": 23, "viewed": 331, "published": "Public", "date": "1602430426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Shader coded live during Inercia Shader Royale 2020 Competion: 1st place\n// Shader was made in about 50m, with 7 other coders competing at the same time\n//\n// Shader evolved a lot during the show\n// You can activate various parts here:\n\nfloat globalSpeed = 0.5; // was at 1 with lug00ber set!\n#define USE_RAINBOW 1\n#define USE_SYMMETRY 1\n#define USE_POSTFX 1\n#define USE_LINES 0\n\n\nfloat time;\n\nvec3 repeat(vec3 p, vec3 s) {\n  return (fract(p/s+.5)-.5)*s;  \n}\nvec3 repid(vec3 p, vec3 s) {\n  return floor(p/s+.5); \n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nvec3 rnd(vec3 p) {\n  \n  return fract(sin(p*452.512+p.yzx*847.512+p.zxy*245.577)*512.844);\n}\n\nfloat tick(float t, float d) {\n  t/=d;\n  return (floor(t) + pow(smoothstep(0.,1.,fract(t)), 10.))*d;\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*457.588)*942.512);\n}\n\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(rnd(floor(t)), rnd(floor(t)+1.), pow(smoothstep(0.,1.,fract(t)), 10.));\n}\n\nvec3 aco=vec3(0);\nfloat map(vec3 p) {\n  \n  vec3 bp=p;\n  \n  float t3 = time*0.4;\n  p.xz *= rot(t3 + sin(p.y*0.3+t3*.7)*.5);\n  p.xy *= rot(t3 + sin(p.z*.4+t3*.6)*.5);\n  p.yz *= rot(t3 + sin(p.x*.2+t3*.8)*.5);\n  \n  float d=length(p)-3.;\n  \n  float sd=3./length(p);\n  d = min(d, length(p.xz)-sd);\n  d = min(d, length(p.xy)-sd);\n  d = min(d, length(p.yz)-sd);\n  \n  \n  float an = pow(fract(time*0.5),2.);\n  float ep = 0.2;\n  ep -= an*0.1 + d*0.05;\n  float d3 = abs(length(p)-an*20.-3.)-ep;\n  d3=max(d3, 0.1);\n  aco += vec3(0.8,0.5,1) * 0.004 / (0.05 + abs(d3));\n  \n  d = min(d, d3);\n  \n  vec3 p6 = bp;\n  p6.xz=abs(p6.xz);\n  if(p6.z>p6.x) p6.xz = p6.zx;\n  p6.x -= 22.;\n  p6.z = abs(p6.z)-6.-sin(bp.y*.03 + time)*5.-sin(bp.y*.1 + time)*10.;\n  p6.z = abs(p6.z)-3.-sin(bp.y*.07 + time)*5.-sin(bp.y*.2 + time*1.3)*4.;\n  \n  float d7 = length(p6.xz) - 1.;\n  d7=max(d7,0.2);\n  d = min(d, d7);\n  aco += vec3(0.8,0.5,1) * 0.008*exp(fract(-time*2.)) / (0.05 + abs(d7));\n  \n  d *= 0.7;\n  \n  p.x += tick(time, 1.)*4.;\n  \n  if(d<0.1) {\n  for(float i=1.; i<11.; ++i) {\n    \n    p-= 0.8;\n    float ss = 9./i;\n    vec3 id = repid(p, vec3(ss));\n    vec3 p2 = repeat(p, vec3(ss));\n    p2 += rnd(id)*0.2;\n    \n    float d2 = length(p2)-ss*0.3;\n    \n    \n    \n    d=max(d, -d2);\n    \n    p.xz *= rot(0.7);\n    p.yz *= rot(0.6);\n  }\n  \n  vec3 p4 = repeat(p + time*4., vec3(8));\n  float d4 = max(abs(p4.x)-0.1, d);\n  aco += vec3(0.4,0.5,1.9) * 0.026 / (0.15 + abs(d4));\n  float d5 = max(abs(p4.y)-0.1, d);\n  aco += vec3(0.8,0.5,0.4) * 0.016 / (0.15 + abs(d5));\n  d = min(d, d4);\n  d = min(d, d5);\n}\n  \n  return d;\n}\n\nfloat gao(vec3 p, vec3 n, float s) {\n  \n  return clamp(map(p+n*s)/s, 0.,1.);\n}\n\nfloat pulse;\n\nvoid cam(inout vec3 p) {\n  \n  float t=time * 0.3 + curve(pulse, 0.6)*27.3;\n  p.yz *= rot(t*0.7);\n  p.xz *= rot(t);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  time = mod(iTime*globalSpeed, 300.);\n  pulse = floor(time*0.5);\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  float alpha = 1.0;\n  \n  #if USE_POSTFX\n      float gd = 10.+curve(time, 0.1)*50.;\n      float se = curve(time - length(uv)*0.5, 0.15);\n      if(se>0.6) {\n        //uv.x += floor(uv.y*gd)*time*0.1;\n        vec2 tmp = smoothstep(0.8,0.9,fract(uv*gd));\n        uv=floor(uv*gd)/gd;\n\n        alpha = mix(1.,max(tmp.x,tmp.y)*.5+.5,se);\n      }\n  #endif\n\n  #if USE_SYMMETRY\n      uv.y += pow(curve(time, 0.3),2.0)*0.2;\n\n      uv *= 1.0+curve(time - length(uv), 0.3)*.3;\n\n      if(curve(time, 2.0)>0.6) uv=abs(uv);\n  #endif\n\n\n  vec3 s=vec3(0,0,-6. - curve(pulse, 0.5)*10.);\n  s.x += (curve(pulse, 0.4)-.5)*8.;\n  s.y += (curve(pulse, 0.7)-.5)*8.;\n  vec3 r=normalize(vec3(-uv, 1. + sin(time*curve(pulse, 0.3)*2.0)*.5));\n  \n  cam(s);\n  cam(r);\n  \n  vec3 p=s;\n  for(int i=0; i<100; ++i) {\n    float d=map(p);\n    if(d<0.001) break;\n    if(d>100.0) break;\n    p+=r*d;    \n  }\n  \n  float fog=1.-clamp(length(p-s)/100., 0.,1.);\n  \n  vec3 col=vec3(0);\n  \n  col += aco*.9;\n  \n  vec2 off=vec2(0.01,0);\n  vec3 n=normalize(map(p)-vec3(map(p-off.xyy), map(p-off.yxy), map(p-off.yyx)));\n  \n  float ao = gao(p,n,0.3);\n  ao *= gao(p,n,0.6)*.5+.5;\n  ao *= gao(p,n,1.2)*.5+.5;\n  \n  for(float i=1.; i<30.; ++i) {\n    float dd=0.1*i;\n    col += map(p+r*dd) * fog * 0.06 * vec3(dd+0.3,0.6,0.9+dd*.3) * ao;\n  }\n  \n  float fre=pow(1.-abs(dot(n,r)), 3.);\n  col += fre * vec3(1,.5,.7) * 1.4 * (0.5-0.5*n.y) * ao * fog;\n  \n  col += (1.-fog) * mix(vec3(0), vec3(0.5,0.6,0.7), pow(abs(r.x), 4.)) * 2.;\n  col += (1.-fog) * mix(vec3(0), vec3(0.7,0.6,0.3), pow(abs(r.z), 4.)) * 2.;\n  \n  #if USE_RAINBOW\n    float t5 = time*.3;\n    col.xz *= rot(t5);\n    col.xy *= rot(t5*.7);\n    col=abs(col);\n  #endif\n  \n  col *= alpha;\n  \n  vec3 bcol = col;\n  \n  #if USE_LINES\n      if(abs(length(uv)-0.3-curve(floor(time*5.)*.4, 0.4))<0.05) col = 1.-col;\n      if(abs(length(uv)-0.4-curve(floor(time*5.)*.4, 0.5))<0.05) col = 1.-col;\n\n      uv *= 0.4;\n      for(int i=0; i<3; ++i) {\n\n        uv *= rot(0.7+time*0.2);\n        uv = abs(uv)-curve(time, 0.3)*0.3;\n        uv *= 1.2;\n\n        if(abs(uv.y)<0.003) col = 1.-col;\n      }\n  #endif\n  \n  //col = mix(col, bcol, clamp(curve(time, 0.3)*2,0,1));\n  \n  col *= 1.2-length(uv);\n  \n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syyzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[266, 398, 427, 427, 462], [463, 463, 491, 491, 518], [520, 520, 539, 539, 610], [612, 612, 630, 630, 703], [705, 705, 735, 735, 807], [809, 809, 829, 829, 871], [873, 873, 904, 904, 999], [1019, 1019, 1038, 1038, 2587], [2589, 2589, 2625, 2625, 2667], [2683, 2683, 2707, 2707, 2799], [2802, 2802, 2859, 2859, 5283]]}
{"id": "3syyzW", "name": "AmongUs ", "author": "ptemoche", "description": "AmongUs practice with Raymarching.", "tags": ["raymarching", "amongus", "sofshadows"], "likes": 6, "viewed": 137, "published": "Public", "date": "1602360468", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//shapes primitives from art of code https://www.youtube.com/watch?v=Ff0jJyyiVyw \n//sofShadows from iquilez https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\n\n#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define MIN_DIST 0.005\n#define AA 2\n#define eAA 0.001\n#define wAA 1.0\n#define PI 3.14159265359\n\n\nstruct Material{\n \n    vec3 color;\n    float shininess;\n    float kd;\n    float ks;\n    float ka;\n    float kf;\n    float nd;\n};\n    \nMaterial mats[2];\nvec3 colors[10];\n    \nMaterial i_material(vec3 color,float ka, float kd, float ks, float shininess, float kf, float nd){\n\t\n    Material m;\n    m.color = color;\n    m.shininess = shininess;\n    m.kd = kd;\n    m.ks = ks;\n    m.ka = ka;\n    m.kf = kf;\n    m.nd = nd;\n    return m;\n}\n\nmat2 Rot2(float angle){\n \n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n    \n}\n\nmat3 RotX(float angle){\n \n    return mat3(1.0, \t\t0.0,\t\t0.0,\n                0.0, cos(angle),-sin(angle),\n                0.0, sin(angle), cos(angle));\n    \n}\n\nmat3 RotY(float angle){\n \n    return mat3(cos(angle), 0.0,sin(angle),\n                0.0,       1.0,0.0       ,\n                -sin(angle),0.0,cos(angle));\n    \n}\n\nmat3 RotZ(float angle){\n \n    return mat3(cos(angle),-sin(angle),0.0,\n                sin(angle), cos(angle),0.0,\n                \t   0.0,        0.0,1.0);\n    \n}\n\nfloat smin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0., 1. );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 min_v3(vec3 a, vec3 b){\n \treturn(a.x<b.x)?a:b;   \n}\nvec3 max_v3(vec3 a, vec3 b){\n \treturn(a.x>b.x)?a:b;   \n}\n\nfloat hash21(vec2 st){\n \n    return fract(sin(dot(st.xy,vec2(12.9898,78.233)))*43758.5453123);\n    \n}\n\nfloat hash31(vec3 st){\n \treturn hash21(vec2(hash21(st.xz),hash21(vec2(hash21(st.xy),hash21(st.yz)))));   \n}\n\nvec3 hash33(vec3 p){\n \n    return vec3(hash21(p.xy),hash21(p.yz),hash21(p.xz));\n}\n\n\n\nfloat sdSphere(vec3 p, vec4 s){\n    return length(p-s.xyz)-s.w;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    return length(p-c)-r;\n}\n\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab, ap) / dot(ab, ab);\n    //t = clamp(t, 0., 1.);\n    \n    vec3 c = a + t*ab;\n    \n    float x = length(p-c)-r;\n    float y = (abs(t-.5)-.5)*length(ab);\n    float e = length(max(vec2(x, y), 0.));\n    float i = min(max(x, y), 0.);\n    \n    return e+i;\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n\treturn length(max(abs(p)-s, 0.));\n}\n\nfloat sdTorus(vec3 p, vec2 r) {\n\tfloat x = length(p.xz)-r.x;\n    return length(vec2(x, p.y))-r.y;\n}\n\nvec3 tripulant(vec3 pos, vec3 translate,int index){\n    //pos = RotY(-PI*0.5)*pos;\n    pos-=translate;\n    vec3 p = pos;\n    //p.z*=1.25;\n    p.x+=((p.y-1.)*sign(p.x))*0.05;\n    vec3 d = vec3(sdCapsule(p,vec3(0,1.5,2),vec3(0,-0.5,2),1.6),0,index);\n    d.x = smin(d.x,sdBox(pos-vec3(0,0.4,3.55),vec3(1.9,1.7,0.4))-0.1,0.4);\n    vec3 p2 = p;\n    p2.x = abs(p2.x);\n    d.x = smin(d.x,sdCylinder(p2,vec3(0.8,-1.05,2),vec3(0.85,-2.75,2),0.3)-0.3,0.25);\n    d = min_v3(d,vec3(sdBox(p+vec3(0,-1,-0.5-p.x*p.x*0.3),vec3(0.875,0.375,0.125))-0.125,1,0));\n    return d;\n}\n\nvec3 space_tripulant(vec3 pos, vec3 translate,int index){\n    \n    pos-=translate;\n    pos.y+=sin(iTime)*0.5;\n    pos=RotY(-PI*0.25)*pos;\n    pos=RotX(-0.4)*pos;\n    vec3 p = pos;\n    p.x+=((p.y-1.)*sign(p.x))*0.05;\n    vec3 d = vec3(sdCapsule(p,vec3(0,1.5,2),vec3(0,-0.5,2),1.6),0,index);\n    d.x = smin(d.x,sdBox(pos-vec3(0,0.4,3.55),vec3(1.9,1.7,0.4))-0.1,0.4);\n    vec3 p2 = p;\n    p2.x = abs(p2.x);\n    d.x = smin(d.x,sdCylinder(p2,vec3(0.8,-1.25,2),vec3(0.85,-1.75,0.0),0.3)-0.3,0.25);\n    d = min_v3(d,vec3(sdBox(p+vec3(0,-1,-0.5-p.x*p.x*0.3),vec3(0.875,0.375,0.125))-0.125,1,0));\n    return d;\n}\n\nvec3 corpse(vec3 pos, vec3 translate){\n    \n    pos-=translate;\n    pos = RotY(0.7)*pos;\n    pos = RotX(-PI*0.1)*pos;\n    vec3 p = pos;\n    p.x+=((p.y-1.)*sign(p.x))*0.05;\n    vec3 d = vec3(sdCapsule(p,vec3(0,1.5,2),vec3(0,-0.5,2),1.6),0,1);\n    d = max_v3(d,vec3(p.y,0.,3));\n    d = min_v3(d,vec3(sdTorus(p-vec3(0,0,2),vec2(1.4,0.2)),0,1));\n    \n    vec3 p2 = p;\n    p2.x = abs(p2.x);\n    d.x = smin(d.x,sdCylinder(p2,vec3(0.8,-1.25,2),vec3(0.85,-1.75,0.0),0.3)-0.3,0.25);\n    \n    vec3 d2 = vec3(sdCapsule(p,vec3(0,0.5,2),vec3(0,0.1,2),0.25),0,0);\n    d2.x = smin(d2.x,sdSphere(vec3(abs(p.x),p.yz),vec4(0.3,0.75,2,0.2)),0.5);\n    d = min_v3(d,d2); \n    return d;\n    \n}\n\nvec3 map(vec3 pos){\n \tvec3 d = tripulant(pos,vec3(-2,0,-3),2);\n    d = min_v3(d,tripulant(pos,vec3(3,0,0),3));\n    d = min_v3(d,tripulant(pos,vec3(8,-0.25,-2),5));\n    d = min_v3(d,space_tripulant(pos,vec3(1,5,7),4));\n    d = min_v3(d,corpse(pos,vec3(-8.,-1.5,1)));\n    d = min_v3(d,vec3(sdSphere(pos,vec4(0.,-103.,0.,100.)),0,25));\n    \n    return d;\n}\n\n\n\nvec3 raymarching(vec3 o, vec3 dir){\n    \n    float d = 0.0;\n    vec3 t = vec3(0);\n    \n    for(int i = 0; i<MAX_STEPS;++i){\n     \tvec3 pos = o+dir*d;\n        t = map(pos);\n        d+=t.x;\n        \n        if(abs(t.x)<MIN_DIST || d>MAX_DIST)\n            break;\n    }\n    \n    t.x = d;\n    return t;\n    \n}\n\nvec3 getNormal(vec3 pos,float normal_desv){\n \n    vec2 e = vec2(0.01,0.0);\n    \n    return normalize(map(pos).x-vec3(\n    \t\t\t\t\t\tmap(pos-e.xyy).x,\n        \t\t\t\t\tmap(pos-e.yxy).x,\n        \t\t\t\t\tmap(pos-e.yyx).x\n    \t\t\t\t\t\t)+sin(hash33(pos)*PI)*normal_desv);\n    \n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t).x;\n        if( h<0.001 )\n            return 0.0;\n        res = min( res, k*h/t );\n        t += h;\n    }\n    return res;\n}\n\nfloat getLigth(vec3 pos,int index){\n \n    Material m = mats[index];\n    \n    vec3 ligth  = vec3(0,2,-7);\n    vec3 l = normalize(pos-ligth);\n    vec3 N = getNormal(pos,m.nd);\n    float dif = m.kd*clamp(dot(N,-l),0.0,1.0);\n    float spec = m.ks*pow(clamp(dot(-l,reflect(normalize(pos),N)),0.0,1.0),m.shininess);\n    float amb = m.ka*clamp(dot(N,normalize(vec3(0.0,0.0,-1.0))),0.0,1.0);\n    float fresnel = m.kf*(1.0-clamp(dot(N,normalize(-pos)),0.0,1.0));\n    float l_d = dif+spec+amb+fresnel;\n    \n    float fog = exp(-0.0125*pos.z*pos.z);\n    float shadow = clamp(softshadow(pos+N*0.01,-l,0.,20.,4.)+0.25,0.0,1.0);\n\treturn l_d*fog*shadow;    \n}\n\nvec3 getColor(vec3 origin, vec3 dir){\n \n    vec3 col = vec3(0.0);\n    \n    \n    vec3 r_pos = raymarching(origin,dir);\n\n    vec3 p = origin+dir*r_pos.x;\n\tint mat_index = int(r_pos.y);\n    int color_index = int(r_pos.z);\n    vec3 _color;\n    if(color_index<20){\n        _color = colors[color_index];\n    }else{\n        _color = texture(iChannel0,p.xz*0.15).xyz;\n    }\n    \n    if(r_pos.x>90.){\n        float c = hash31(dir);\n     \tcol=vec3(pow(c,200.0));   \n    }else{\n    \tcol = _color*getLigth(p,mat_index);\n    }\n        \n    \n    return col;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    \n    float t = 0.0;//iTime;\n    \n    vec2 uv = fragCoord.xy / iResolution.xy; // 0 <> 1\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float distan = 15.0;\n    float angle = PI*0.92;//iTime;\n    float _x = sin(angle)*distan;\n    float _z = cos(angle)*distan;\n    vec3 origin = vec3(_x,1.5,_z);\n    vec3 lookat = vec3(0);\n    \n    float zoom = 1.;\n    \n    vec3 f = normalize(lookat-origin);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = origin + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 dir = normalize(i-origin);\n    \n    vec3 col = vec3(0.0);\n    \n    /*********************\n\t*       MATERIALS    *\n\t*********************/\n    \n    mats[0] = i_material(vec3(1,1,1),0.2,0.5,0.15,3.0,0.015,0.0015);\n    mats[1] = i_material(vec3(1,1,1),0.2,0.45,0.95,4.0,0.25,0.0); \n    \n    /********************\n\t*      COLORS       *\n\t********************/\n    colors[0] = vec3(1,1,1);\n    colors[1] = vec3(0,1,0);\n    colors[2] = vec3(0,0,1);\n    colors[3] = vec3(1,0,0);\n    colors[4] = vec3(0,1,1);\n    colors[5] = vec3(1,1,0);\n    \n    \n\tcol = (getColor(origin, dir)*wAA)/(float(AA)+wAA);\n    \n    vec3 e = vec3(eAA,-eAA,0.0);\n    vec3 e2 = vec3(eAA,-eAA,0.0)*0.7071;\n    vec3 sampling[8];\n    sampling[0]=e.xzz;\n    sampling[1]=e.zyz;\n    sampling[2]=e.yzz;\n    sampling[3]=e.zxz;\n    sampling[4]=e2.xxz;\n    sampling[5]=e2.yxz;\n    sampling[6]=e2.xyz;\n    sampling[7]=e2.yyz;\n    \n    for(int i = 0; i<AA;++i){\n     \n        \n        vec3 dir = normalize(dir+sampling[i]);\n\n        col += getColor(origin,dir)/(float(AA)+wAA);\n        \n    }\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3Rr", "previewfilepath": "/media/ap/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/79520a3d3a0f4d3caa440802ef4362e99d54e12b1392973e4ea321840970a88a.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3syyzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 485, 583, 583, 742], [744, 744, 767, 767, 839], [841, 841, 864, 864, 998], [1000, 1000, 1023, 1023, 1164], [1166, 1166, 1189, 1189, 1328], [1330, 1330, 1371, 1371, 1462], [1464, 1464, 1492, 1492, 1520], [1521, 1521, 1549, 1549, 1577], [1579, 1579, 1601, 1601, 1680], [1682, 1682, 1704, 1704, 1789], [1791, 1791, 1811, 1811, 1872], [1876, 1876, 1907, 1907, 1941], [1943, 1943, 1993, 1993, 2161], [2163, 2163, 2214, 2214, 2526], [2528, 2528, 2557, 2557, 2594], [2596, 2596, 2627, 2627, 2695], [2697, 2697, 2748, 2779, 3256], [3258, 3258, 3315, 3315, 3861], [3863, 3863, 3901, 3901, 4534], [4536, 4536, 4555, 4555, 4889], [4893, 4893, 4928, 4928, 5197], [5199, 5199, 5242, 5242, 5458], [5460, 5460, 5537, 5537, 5752], [5754, 5754, 5789, 5789, 6398], [6400, 6400, 6437, 6437, 6950], [6952, 6952, 7009, 7009, 8651]]}
{"id": "3t2fR3", "name": "Halloween - 'It' Tribute", "author": "dean_the_coder", "description": "Inspired by the 'drain' scene from the Stephen King 'It' movie.\nHappy Halloween everyone!\n(https://youtu.be/HsGZhpXIMBs)", "tags": ["3d", "raymarching", "halloween", "scary", "movie", "it", "clown"], "likes": 15, "viewed": 385, "published": "Public API", "date": "1603738927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 'It' Tribute\n//\n// Inspired by the 'drain' scene from the Stephen King 'It' movie.\n// I'd love to come back to this in the future when a) my modelling\n// skills are improved, and b) my GPU is faster. :o)\n//\n// Concrete texture reused from my earlier shader:\n// https://www.shadertoy.com/view/WllfzB\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST 0.0015\n#define MAX_DIST 64.0\n\n//#define AA  // Enable this line if your GPU can take it!\n\nvec3 rayDir;\nfloat faceVisibility, eyeWonk, headLunge;\n\nstruct MarchData {\n    float d;\n    vec3 mat;        // RGB\n    float specPower; // 0: None, 30.0: Shiny\n    float opacity;   // 1.0: Solid\n};\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7.0, 157.0, 113.0);\n\tvec3 ip = floor(p);\n    vec4 h = vec4(0.0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\t\n    h = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\t\n    h.xy = mix(h.xz, h.yw, p.y);\n    return mix(h.x, h.y, p.z);\n}\n\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nfloat smin(float a, float b, float k) {\n    float h = clamp(0.5 + 0.5 * (b - a) / k, 0.0, 1.0);\n    return mix(b, a, h) - k * h * (1.0 - h);\n}\n\nfloat fbm(vec3 p) {\n    return noise(p) * noise(p + 0.2) * noise(p + 0.66);\n}\n\nmat2 rot(float a) {\n    float c = cos(a);\n    float s = sin(a);\n    return mat2(c, s, -s, c);\n}\n\nfloat opRep(float p, float c) {\n    float c2 = c * 0.5;\n    return mod(p + c2, c) - c2;\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 q = abs(p) - b;\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n    vec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdCapsule(vec3 p, float h, float r) {\n\tp.x -= clamp(p.x, 0.0, h);\n\treturn length(p) - r;\n}\n\nfloat sdPuddle(vec3 p, float r) {\n    r *= 0.9 + 0.1 * cos(7.0 * atan(p.x, p.y));\n    return sdCappedCylinder(p, r, 0.05);\n}\n\nfloat sdEye(vec3 p, inout vec3 mat, float openness, float maxEyeWonk) {\n    const float r = 0.5;\n    float d = length(p) - r;\n    vec3 pp = p;\n    pp.yz *= rot(0.181);\n    float frontAngle = abs(atan(pp.y, pp.z)) / 3.1415;\n\n    const float pupilSize = 0.1;\n    const float irisSize = 0.3;\n    \n    vec3 eyeRay = rayDir;\n    eyeRay.xz *= rot(0.75 * eyeWonk * maxEyeWonk);\n    vec3 pupilCenter = eyeRay * -r;\n    vec3 pupilToP = p - pupilCenter;\n    float distFromFocus = length(pupilToP);\n    \n    // Corners.\n    mat = mix(mat, vec3(0.3, 0.01, 0.05), smoothstep(0.8, 1.0, abs(p.x / r)));\n    \n    // Iris color.\n    const vec3 irisCol = vec3(0.068, 0.211, 0.18);\n    float radialTint = sin(atan(pupilToP.y, pupilToP.x) * 23.0) * 0.3 + 1.7 - irisSize * distFromFocus;\n    mat *= smoothstep(0.0, 0.05, distFromFocus - irisSize); // Gradient\n    mat = mix(mat,\n              irisCol * radialTint, // Radial lines\n              1.0 - min(distFromFocus / irisSize, 1.0)); // Solid\n    \n    // Iris outer.\n    mat *= mix(0.17, 1.0, smoothstep(0.0, 0.04, abs(distFromFocus - irisSize)));\n    \n    // Pupil.\n    mat = mix(vec3(0.01), mat, smoothstep(0.0, 0.06, distFromFocus - pupilSize));\n    \n    // Open/close eyelids.\n    mat *= smoothstep(0.1, 0.0, mix(1.1, 0.91, openness) - frontAngle);\n    return d;\n}\n\nMarchData sdHead(vec3 p, vec3 eyeMat) {\n    p -= vec3(0.0, 1.2, -2.0);\n    \n    // Eyes.\n    float openness = faceVisibility;\n    float blink = clamp(iTime - 32.0, 0.0, 0.4) / 0.4;\n    openness *= pow(abs(cos(blink * 3.1415)), 2.0);\n    \n    vec3 eyeMat1 = eyeMat;\n    MarchData result = MarchData(sdEye(p - vec3(-0.9, 0.0, 0.0), eyeMat1, openness, 1.0), eyeMat1, 30.0, 1.0);\n    \n    float eye2 = sdEye(p - vec3(0.9, 0.0, 0.0), eyeMat, openness, 0.0);\n    if (eye2 < result.d) {\n        result.d = eye2;\n        result.mat = eyeMat;\n    }\n    \n    // Forehead.\n    float ox = p.x;\n    p.x = abs(p.x);\n    float brow = (1.0 - cos(p.x * 2.9)) * 0.1;\n    float head = sdCapsule(p - vec3(0.0, 0.37 + brow, 0.0), 1.2, 0.2);\n    \n    vec3 pp = p.yxz;\n    pp.xz *= rot(0.6);\n    head = smin(head, sdCapsule(pp - vec3(-0.36, 0.0, 0.2), 0.5, 0.2), 0.5);\n    if (head < result.d) {\n        result.d = head;\n        float noseDim = mix(1.0, smoothstep(-0.4, 0.5, ox), clamp(0.3 - p.y, 0.0, 1.0));\n        result.mat = vec3(0.004 * faceVisibility * noseDim);\n        result.specPower = 1e7;\n    }\n    \n    return result;\n}\n\nfloat getConcreteMaterial(vec3 p, out vec3 mat) {\n    // Mix a couple of shades of grey.\n    float baseColor = smoothstep(0.0, 0.5, noise(p));\n    mat = mix(vec3(0.18, 0.17, 0.17), vec3(0.20, 0.19, 0.19), baseColor);\n\n    // Surface roughness.\n    float rough = noise(p * 60.0) * 0.005 // Base\n         \t\t  + step(0.2, noise(p * 26.666)) * 0.0033; // Pits/dents.\n    mat += rough * 24.0;\n    \n    return rough;\n}\n\nfloat getAsphaltMaterial(vec3 p, out vec3 mat) {\n    // Surface roughness.\n    float rough = abs(fbm(p * 10.0) - 0.5) * 0.1;\n    mat = vec3(rough * 0.3);\n    return rough;\n}\n\nvec3 getRayDir(vec3 ro, vec3 lookAt, vec2 uv) {\n    vec3 forward = normalize(lookAt - ro);\n    vec3 right = normalize(cross(vec3(0.0, 1.0, 0.0), forward));\n    vec3 up = cross(forward, right);\n    return normalize(forward + right * uv.x + up * uv.y);\n}\n\n// Once it has been hit, we exclude the water from the scene.\nbool refracted = false;\n\n// Map the scene using SDF functions.\nMarchData map(vec3 p) {\n    MarchData result;\n    result.specPower = 1000.0;\n    result.opacity = 1.0;\n    \n    // Concrete texture.\n    vec3 concreteMat;\n    float concreteDisplacement = getConcreteMaterial(p, concreteMat);\n    result.mat = concreteMat;\n\n    // Curb.\n    vec3 rp = p;\n    rp.x = opRep(rp.x, 12.2);\n    const vec3 curbSize = vec3(6.0, 2.0, 1.0);\n    float curb = max(sdBox(rp, curbSize), 0.25 - (sdBox(p, curbSize) - 0.1));\n\n    // Paving.\n    rp.x = opRep(p.x + 2.3, 9.2);\n    float slab = sdBox(rp - vec3(0.0, 1.8, 6.0), vec3(4.5, 0.2, 4.5));\n    rp.x = opRep(p.x - 2.3, 9.2);\n    slab = min(slab, sdBox(rp - vec3(0.0, 1.8, 15.3), vec3(4.5, 0.2, 4.5)));\n    \n    if (slab < curb) {\n        // Black out underside of paving slabs.\n        result.mat *= rayDir.y < 0.0 ? 1.0 : 0.0;\n    }\n    \n\tresult.d = min(slab, curb) - 0.1 - concreteDisplacement;\n    \n    // Drain.\n    p.y += curbSize.y;\n    float drainBox = max(\n        sdBox(p, curbSize * vec3(1.025, 2.0, 1.0)) - 0.1,\n        -sdBox(p, curbSize * vec3(0.9, 1.8, 2.0)));\n    if (drainBox < result.d) {\n    \tresult.d = drainBox;\n        result.mat *= vec3(.439, .157, .035);\n    }\n    \n    // Road.\n    p.yz += vec2(0.5, 10.7);\n    vec3 mm;\n    float road = sdBox(p, vec3(100.0, 0.5 + getAsphaltMaterial(p, mm), 10.0));\n    if (road < result.d) {\n        result.mat = mm;\n        result.d = road;\n        result.specPower = 1.0;\n    }\n\n    // Head.\n    vec3 headMat;\n    vec3 pp = p - vec3(0.0, 0.6 + sin(headLunge * 6.282) * 0.1, -1.0) * headLunge * 2.0;\n    MarchData head = sdHead(pp - vec3(0.0, 0.0, 15.0), concreteMat * 1.3);\n    if (head.d < result.d)\n        result = head;\n    \n    if (!refracted) {\n        // Puddles.\n        vec3 puddleP = p.xzy - vec3(6.0, 6.0, 0.5);\n        float puddles = sdPuddle(puddleP, 1.2);\n        puddles = min(puddles, sdPuddle(puddleP - vec3(2.0, 0.0, 0.0), 2.0));\n        puddles = min(puddles, sdPuddle(puddleP - vec3(5.0, 0.0, 0.0), 1.5));\n        \n        // Stream.\n        float waterClip = sdBox(p - vec3(0.0, 0.0, 61.0), vec3(100.0, 100.0, 50.0));\n        p.xz += vec2(46.25, -151.08);\n        float edgeWave = sin(p.x - iTime * 5.0) * 0.2;\n        float radius = 150.0 + edgeWave;\n        float prad = length(p.xz);\n        float water = max(prad - radius, abs(p.y - 0.6));\n        vec3 wp = p;\n        wp.xz *= rot(iTime * 0.1) * 0.05;\n\n        float wt = iTime * 8.0;\n        float dis = (sin(p.x - wt) + 0.5 * sin((p.x - wt * 0.5) * 1.8)) * 0.25 + 0.5;\n        dis += texture(iChannel0, wp.xz).r * 0.8;\n        dis *= (radius - prad) * 0.2;\n        water -= dis;\n        water = max(water, -waterClip);\n        water = min(water, puddles);\n        \n        if (water < result.d) {\n            result.d = water;\n            result.mat = vec3(0.25, 0.3, 0.4);\n            result.specPower = 3.0;\n            result.opacity = 0.2;\n        }\n    }\n\n    return result;\n}\n\nvec3 calcNormal(vec3 p) {\n    vec2 e = vec2(1.0, -1.0) * 0.005773;\n    return normalize(e.xyy * map(p + e.xyy).d + \n\t\t\t\t\t e.yyx * map(p + e.yyx).d + \n\t\t\t\t\t e.yxy * map(p + e.yxy).d + \n\t\t\t\t\t e.xxx * map(p + e.xxx).d);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n    return map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    col *= 0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.4);\n    return col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, MarchData data) {\n    vec3 sunCol = vec3(2.0, 1.6, 1.4);\n    vec3 sunPos = vec3(6.0, 3.0, -10.0);\n    vec3 sunDir = normalize(sunPos - p);\n    vec3 n = calcNormal(p);\n    \n    // Ambient occlusion (exluding water).\n    bool b = refracted;\n    refracted = true;\n    float amb = dot(vec3(ao(p, n, 0.2), ao(p, n, 0.5), ao(p, n, 2.0)), vec3(0.2, 0.3, 0.5));\n    refracted = b;\n    \n    // Diffuse color.\n    float diff = max(0.0, dot(sunDir, n));\n    \n    // Primary light.\n    vec3 lig = diff * sunCol * mix(amb, 1.0, iMouse.x/640.0);\n\n    // Specular.\n    float spe = pow(max(0.0, dot(rd, reflect(normalize(sunPos - p), n))), data.specPower);\n    lig += smoothstep(0.5, 1.0, spe) * 10.0;\n\n    float fre = 1.0 + dot(rd, n);\n    float fog = exp(-length(p) * 0.14);\n    return mix(data.mat * lig, vec3(0.0), fre) * fog;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n    // Raymarch.\n    vec3 p;\n    \n    float d = 0.01;\n    float opacity = 1.0;\n    MarchData h;\n    vec3 col = vec3(0.0);\n    for (float steps = 0.0; steps < 90.0; steps++) {\n        p = ro + rd * d;\n        h = map(p);\n        \n        if (abs(h.d) < MIN_DIST) {\n            if (h.opacity > 0.9999 || refracted)\n            \tbreak; // We've hit a solid surface - Stop.\n            opacity = max(0.0, opacity - h.opacity);\n            col = applyLighting(p, rd, h) * h.opacity;\n            refracted = true;\n            rd = refract(rd, calcNormal(p), 0.95);\n        }\n        \n        if (d > MAX_DIST)\n            return vec3(0.0); // Distance limit reached - Stop.\n        \n        d += h.d; // No hit, so keep marching.\n    }\n    \n    // Lighting.\n    return applyLighting(p, rd, h) * opacity + col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    // Camera.\n    const float stageCount = 3.0;\n    float ft = smoothstep(0.0, 1.0, fract(iTime / 12.0));\n    float phase = mod(floor(iTime / 12.0), stageCount);\n    float dim = 1.0 - pow(abs(cos(iTime * 3.141 / 12.0)), 100.0);\n    \n    vec3 ro, lookAt = vec3(0.0, 0.0, 0.0);\n    faceVisibility = 0.0;\n    headLunge = 0.0;\n    \n    if (phase == 0.0) {\n        ro = vec3(mix(-30.0, -9.0, ft), 7.0, -15.0);\n        lookAt = ro * vec3(1.1, 0.0, 0.0);\n    } else if (phase == 1.0) {\n        ro = mix(vec3(20.0, 8.0, -20), vec3(0.0, 5.0, -10.0), ft);\n        faceVisibility = min(1.0, (ft - 0.3) * 2.0);\n        eyeWonk = 1.0;\n    } else if (phase == 2.0) {\n        float progress = min(1.0, pow(ft * 4.0, 4.0));\n        eyeWonk = 1.0 - smoothstep(0.4, 1.0, (ft - 0.2) * 2.0);\n        faceVisibility = 1.0 + min(sin(eyeWonk * 3.141), 0.5);\n        headLunge = ft;\n        ro = mix(vec3(1.0, 10.0, -20), vec3(-1.0, 0.85, -5.0), progress);\n    }\n    \n    vec3 col = vec3(0.0);\n#ifdef AA\n    for (float dx = 0.0; dx <= 1.0; dx++) {\n        for (float dy = 0.0; dy <= 1.0; dy++) {\n            vec2 coord = fragCoord + vec2(dx, dy) * 0.5;\n#else\n            vec2 coord = fragCoord;\n#endif\n            vec2 uv = (coord - 0.5 * iResolution.xy) / iResolution.y;\n\n            rayDir = getRayDir(ro, lookAt, uv);\n            col += getSceneColor(ro, rayDir);\n#ifdef AA\n            refracted = false;\n        }\n    }\n    col /= 4.0;\n#endif\n    \n    // Output to screen.\n    col = vignette(pow(col * dim, vec3(0.4545)), fragCoord);\n    fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4tSGDc", "previewfilepath": "https://soundcloud.com/naturesoundsofficial/ambient-stream-1", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/naturesoundsofficial/ambient-stream-1", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3t2fR3.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[813, 869, 890, 890, 1166], [1168, 1168, 1188, 1188, 1255], [1257, 1257, 1296, 1296, 1399], [1401, 1401, 1420, 1420, 1478], [1480, 1480, 1499, 1499, 1575], [1577, 1577, 1608, 1608, 1666], [1668, 1668, 1697, 1697, 1792], [1794, 1794, 1844, 1844, 1960], [1962, 1962, 2005, 2005, 2058], [2060, 2060, 2093, 2093, 2184], [2186, 2186, 2257, 2257, 3487], [3489, 3489, 3528, 3528, 4600], [4602, 4602, 4651, 4690, 5014], [5016, 5016, 5064, 5090, 5189], [5191, 5191, 5238, 5238, 5443], [5532, 5570, 5593, 5593, 8462], [8464, 8464, 8489, 8489, 8682], [8684, 8712, 8747, 8747, 8782], [8784, 8870, 8911, 8911, 9052], [9054, 9054, 9107, 9107, 9906], [9908, 9908, 9946, 9963, 10752], [10754, 10754, 10809, 10824, 12358]]}
{"id": "llBXRm", "name": "Colored Cube on a Checkerboard", "author": "Nauja", "description": "Simulation of a colored cube moving on a checkerboard.\n\nThe cube move one step forward, then one step rightward, then one step forward, ...", "tags": ["cube", "checkerboard", "colored"], "likes": 4, "viewed": 198, "published": "Public API", "date": "1603823295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/**\n * Simulation of a colored cube moving on a checkerboard.\n *\n * The cube move one step forward, then one step rightward, then one step forward, ...\n *\n * Although the cube seems to rotate infinitely, it only rotates by 90° (either forward or\n * rightward) during [0, PI] seconds then go back to its initial rotation. The cube always stays\n * at position (0, 0, 0) but move a little upward during its rotation.\n *\n * The floor moves one tile backward or leftward during [0, PI] seconds then go back to its\n * initial position.\n *\n * So we have an infinite loop where everything move during [0, PI] seconds then go back to\n * the initial state.\n *\n *\n * The forward movement follows a periodic function looking like:\n *\n *     /         /         /\n *    /         /         /\n *   /         /         /\n *  /         /         /\n * /    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n *\n *\n * The rightward movement follows a periodic function looking like:\n *\n *          /         /         /\n *         /         /         /\n *        /         /         /\n *       /         /         /\n * _____/    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n *\n * So every PI seconds, the cube is moving either forward or rightward.\n *\n * To create the illusion that the cube is moving one tile forward and one tile rightward each\n * step, many equations include an offset of 1.0 if sin(time) > 0.0. You can set ENABLE_FLOOR_OFFSET\n * to 0.0 to disable this offset for the floor and you will see that its position is reset each time.\n */\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n#define SPEED 1.0 // how fast is the simulation\n#define ENABLE_FLOOR_OFFSET 1.0\n#define PI 3.1415926535897932384626433832795\n#define PI2 6.28318530718\n\n//------------------------------------------------------------------\n\n// possible shapes\n#define SHAPE_VOID 0.0\n#define SHAPE_FLOOR 1.0\n#define SHAPE_CUBEFRAME 2.0\n// cube faces are arranged in the order they will touch the floor\n#define SHAPE_CUBEFACEDOWN 3.0\n#define SHAPE_CUBEFACEFRONT 4.0\n#define SHAPE_CUBEFACERIGHT 5.0\n#define SHAPE_CUBEFACEUP 6.0\n#define SHAPE_CUBEFACEBACK 7.0\n#define SHAPE_CUBEFACELEFT 8.0\n\n// intersected shape\nstruct Shape\n{        \n    float d; // distance\n    float t; // type of shape\n    vec3 c; // color\n};\n\n// colors of each face of the cube\nconst vec3 CubeFaces[6] = vec3[6](\n    vec3(1.0, 0.65, 0.0), // yellow, down\n    vec3(0.14, 1.0, 0.0), // green, front\n    vec3(1.0, 0.0, 0.0), // red, right\n    vec3(1.0, 1.0, 1.0), // white, up\n    vec3(0.0, 0.55, 1.0), // blue, back\n    vec3(1.0, 0.31, 0.0) // orange, left\n);\n\n//------------------------------------------------------------------\n\n// create a quaternion\nvec4 quat(in vec3 v, in float a)\n{\n    return vec4(v * sin(a / 2.0), cos(a / 2.0));\n}\n\nvec4 quat_inv(in vec4 q)\n{\n    return vec4(-q.xyz, q.w);\n}\n\nvec4 p2q(in vec3 p)\n{\n    return vec4(p, 0);\n}\n\nvec4 q_mul(in vec4 q1, in vec4 q2)\n{\n    return vec4(q1.w*q2.x + q1.x*q2.w + q1.y*q2.z - q1.z*q2.y, \n                q1.w*q2.y - q1.x*q2.z + q1.y*q2.w + q1.z*q2.x, \n                q1.w*q2.z + q1.x*q2.y - q1.y*q2.x + q1.z*q2.w, \n                q1.w*q2.w - q1.x*q2.x - q1.y*q2.y - q1.z*q2.z);\n}\n\nvec3 rotate(in vec3 p, in vec4 q)\n{\n    return q_mul(q_mul(q, p2q(p)), quat_inv(q)).xyz;\n}\n\nShape opU( Shape d1, Shape d2 )\n{\n    if (d1.d<d2.d) {\n        return d1;\n    }\n    return d2;\n}\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\n\n// test intersection with a box https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n// test intersection with the black frame of the cube\nfloat sdCubeFrame(vec3 p, vec3 b)\n{    \n    return opSubtraction(\n        sdBox(p, b * vec3(0.9, 0.9, 1.1)),\n        opSubtraction(\n            sdBox(p, b * vec3(0.9, 1.1, 0.9)),\n            opSubtraction(\n                sdBox(p, b * vec3(1.1, 0.9, 0.9)),\n                sdBox(p, b)\n            )\n        )\n    );\n}\n\n// test intersection with the colored cube\nShape sdColoredCube( in vec3 pos )\n{\n    Shape res = Shape( 1e10, SHAPE_VOID, vec3(0.0, 0.0, 0.0) );\n\n    {\n      res = opU( res, Shape( sdCubeFrame( pos, vec3(0.25, 0.25, 0.25) ), SHAPE_CUBEFRAME, vec3(0.0, 0.0, 0.0 )) );\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, 0.24, 0.0), vec3(0.225, 0.01, 0.225)), SHAPE_CUBEFACEDOWN, vec3(0.0, 0.0, 0.0 ) )); // yellow, down\n      res = opU( res, Shape( sdBox( pos+vec3(-0.24, 0.0, 0.0), vec3(0.01, 0.225, 0.225)), SHAPE_CUBEFACEFRONT, vec3(0.0, 0.0, 0.0)) ); // green, front\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, 0.0, 0.24), vec3(0.225, 0.225, 0.01)), SHAPE_CUBEFACERIGHT, vec3(0.0, 0.0, 0.0 ) )); // red, right\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, 0.0, -0.24), vec3(0.225, 0.225, 0.01)), SHAPE_CUBEFACELEFT, vec3(0.0, 0.0, 0.0 ) )); // orange, left\n      res = opU( res, Shape( sdBox( pos+vec3(0.24, 0.0, 0.0), vec3(0.01, 0.225, 0.225)), SHAPE_CUBEFACEBACK, vec3(0.0, 0.0, 0.0 ) )); // blue, back\n      res = opU( res, Shape( sdBox( pos+vec3(0.0, -0.24, 0.0), vec3(0.225, 0.01, 0.225)), SHAPE_CUBEFACEUP, vec3(0.0, 0.0, 0.0 ) )); // white, up\n    }\n    \n    return res;\n}\n\n//------------------------------------------------------------------\n\n/**\n * calculate the forward movement\n * \n *     /         /         /\n *    /         /         /\n *   /         /         /\n *  /         /         /\n * /    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n */\nfloat advanceX(in float time)\n{\n    return mod(min(time - floor(time / PI2) * PI, PI * ceil(time / PI2)) * ceil(sin(time)), PI) / 2.0;\n}\n\n/**\n * same as advanceX but without the reset every [PI, 2PI]\n *\n * This is used to compute the forward movement when time == PI without having the\n * reset to 0.\n */\nfloat advanceX2(in float time)\n{\n    return (time - floor(time / PI2) * PI) / 2.0;\n}\n\n/**\n * calculate the rightward movement\n * \n *          /         /         /\n *         /         /         /\n *        /         /         /\n *       /         /         /\n * _____/    _____/    _____/\n * 0    PI   2PI  3PI  4PI\n */\nfloat advanceZ(in float time)\n{\n    return mod(min(time - PI - floor((time - PI) / PI2) * PI, PI * ceil((time- PI) / PI2)) * (1.0 - ceil(sin(time))), PI) / 2.0;\n}\n\n// test intersection with the scene\nShape map( in float time, in vec3 pos )\n{\n    Shape res = Shape( 1e10, SHAPE_VOID, vec3(0.0, 0.0, 0.0) );\n\n    {\n        pos += vec3(0.0, -0.25, 0.0);\n        pos += vec3(0.0, -0.10, 0.0) * abs(sin(time));\n    \tpos = rotate(pos, q_mul(\n            quat(vec3(0.0, 0.0, 1.0), advanceX(time)),\n        \tquat(vec3(1.0, 0.0, 0.0), advanceZ(time))\n       \t));\n    \tres = opU( res, sdColoredCube(pos) );\n    }\n    \n    return res;\n}\n\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nShape raycast( in float time, in vec3 ro, in vec3 rd )\n{\n    Shape res = Shape(-1.0,SHAPE_VOID,vec3(0.0,0.0, 0.0));\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 )\n    {\n        tmax = min( tmax, tp1 );\n        res = Shape( tp1, SHAPE_FLOOR, vec3(1.0, 1.0, 1.0) );\n    }\n    //else return res;\n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    if( tb.x<tb.y && tb.y>0.0 && tb.x<tmax)\n    {\n        //return vec2(tb.x,2.0);\n        tmin = max(tb.x,tmin);\n        tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<70 && t<tmax; i++ )\n        {\n            Shape h = map( time, ro+rd*t );\n            if( abs(h.d)<(0.0001*t) )\n            { \n                res = Shape(t,h.t, h.c); \n                break;\n            }\n            t += h.d;\n        }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in float time, in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( time, ro + rd*t ).d;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in float time, in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(time, pos+0.0005*e).d;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in float time, in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map(time, pos + h*nor ).d;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in float time, in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in float time, in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    Shape res = raycast(time, ro,rd);\n    float t = res.d;\n    if( res.t != SHAPE_VOID )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (res.t == SHAPE_FLOOR) ? vec3(0.0,1.0,0.0) : calcNormal(time, pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = res.c;\n        float ks = 1.0;\n        \n        /**\n         * Every PI time, our cube is moving forward or rightward.\n         * \n         * shift is used to shift the first row to the left if == 1\n         */\n        float shift = ceil(sin(time)) * ENABLE_FLOOR_OFFSET;\n        float face = floor(time / PI);\n        if (res.t > SHAPE_CUBEFRAME)\n        {\n            if (res.t == SHAPE_CUBEFACEUP)\n            {\n            \tcol = CubeFaces[int(mod(face + 3.0, 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACEDOWN)\n            {\n            \tcol = CubeFaces[int(mod(face, 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACEFRONT)\n            {\n            \tcol = CubeFaces[int(mod(face + 1.0 + mod(face, 2.0), 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACEBACK)\n            {// 1 - 3, 2-3; 3-5, 4-5, 5-1, 6-1\n            \tcol = CubeFaces[int(mod(face + 4.0 + mod(face, 2.0), 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACELEFT)\n            {\n            \tcol = CubeFaces[int(mod(face + 4.0 + mod(face + 1.0, 2.0), 6.0))];   \n            }\n            else if (res.t == SHAPE_CUBEFACERIGHT)\n            {\n            \tcol = CubeFaces[int(mod(face + 1.0 + mod(face + 1.0, 2.0), 6.0))];   \n            }\n        }\n        else if(res.t == SHAPE_FLOOR)\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n            \n            vec3 pos2 = pos;\n       \t\tpos2 += vec3(-0.25, 0.0, -0.25);\n            pos2 += vec3(0.5, 0.0, 0.0) * advanceX(time) / advanceX2(PI);\n       \t\tpos2 += vec3(0.0, 0.0, -0.5) * advanceZ(time) / advanceX2(PI);\n            float tileX = floor((pos2.x + 0.5) / 0.5f);\n            float tileZ = floor(-pos2.z / 0.5f) + shift;\n       \t\t//pos += vec3(0.0, 0.0, -1.0) * time * max(ceil(-1.0*sin(time)), 0.0) / 5.0;\n            float f = checkersGradBox( time, 1.7*pos.xz, 1.7*dpdx.xz, 2.5*dpdy.xz /* blur */);\n            col = 0.15 + f*vec3(0.05); // luminance + f * contrast\n            ks = 0.4; // godray ?\n            float f1 = floor(mod((pos2.x + 0.5 * shift) / 0.5, 2.0));\n            float f2 = clamp(floor(mod((pos2.z + 0.5 * f1) / 0.5, 2.0)), 0.15, 0.25);\n            col = vec3(f2, f2, f2);\n            /**\n             * tileX <= 0.0 && tileZ <= 0.0 : only tiles behind the cube\n             * abs(tileX - tileZ) <= 1.0 : only the diagonal\n             * tileZ >= tileX : one tile up, then one left, then one up, ...\n             */\n            if (tileX <= 0.0 && tileZ <= 0.0 && abs(tileX - tileZ) <= 1.0 && tileZ >= tileX)\n            {\n                /**\n                 * tileX + tileZ : initial color of the tile\n                 * + face : shift by the current cube face that is down\n                 * - shift : shift by one for odd rows\n                 */\n             \tcol = CubeFaces[int(mod(tileX + tileZ + face - shift, 6.0))];   \n            }\n        }\n\n        // lighting\n        float occ = calcAO( time, pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow(time, pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow(time, pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime*4.0*SPEED;\n\n    // camera\t\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ro = ta + vec3( 2.5*cos(0.1/**time*/), 1.3, 2.5*sin(0.1/**time */) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( time, ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/llBXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2708, 2731, 2765, 2765, 2816], [2818, 2818, 2844, 2844, 2876], [2878, 2878, 2899, 2899, 2924], [2926, 2926, 2962, 2962, 3220], [3222, 3222, 3257, 3257, 3312], [3314, 3314, 3347, 3347, 3410], [3412, 3412, 3455, 3455, 3477], [3480, 3584, 3615, 3615, 3706], [3708, 3762, 3797, 3797, 4079], [4081, 4124, 4160, 4160, 5270], [5342, 5550, 5581, 5581, 5686], [5688, 5855, 5887, 5887, 5939], [5941, 6176, 6207, 6207, 6338], [6340, 6376, 6417, 6417, 6801], [6903, 6971, 7022, 7022, 7227], [7229, 7229, 7285, 7285, 8165], [8167, 8229, 8322, 8345, 8738], [8740, 8804, 8851, 8851, 9427], [9429, 9429, 9486, 9486, 9800], [9802, 9878, 9957, 9978, 10211], [10213, 10213, 10293, 10312, 15416], [15418, 15418, 15470, 15470, 15647], [15649, 15649, 15706, 15706, 16962]]}
{"id": "td3czs", "name": "Ray Marching for Dummies - Yonng", "author": "yonng", "description": "\nRefer to the great tutorial: https://www.youtube.com/watch?reload=9&v=PGtv-dBi2wE", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 36, "published": "Public", "date": "1601505596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float GetDist(vec3 p)  // simple way calculate the distance using ray marching\n{\n     vec4 s = vec4(0,1,6,1);   //the last 1 is for radius, the first three are the coordinates of the circle\n     float sphereDist = length(p - s.xyz) - s.w;\n     float planeDist = p.y;\n     \n     float d = min(sphereDist, planeDist);\n     return d;\n    \n}\n\n#define MAX_STEPS 100    \n#define MAX_DIST 100.   \n#define SURF_DIST .01\n\n//float and int\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n \tfloat d0=0.;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n       vec3 p = ro + rd*d0;\n       float ds = GetDist(p);   \n       d0+=ds;\n       // to long or to small -> break\n       if(d0>MAX_DIST||ds<SURF_DIST) break;\n        \n    }\n    \n    return d0;\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDist(p);\n    vec2 e = vec2(.01,0);  //delta e\n    vec3 n= d - vec3(GetDist(p-e.xyy),\n                   GetDist(p-e.yxy),\n                   GetDist(p-e.yyx));\n    \n    return normalize(n);\n}\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));  //light moves around\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    \n    //utilize the idea of shadowmap to generate the light\n    //if the distance can't reach the light then in shadow\n    float d = RayMarch(p+n*SURF_DIST*2.,l); //from the plane a little bit\n    if(d<length(lightPos - p)) dif*=.1;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,1,0);\n    vec3 rd= normalize(vec3(uv.x,uv.y,1));  //rd equals every point on the screen\n    \n    float d = RayMarch(ro, rd);\n    //d /=6.;\n    vec3 p = ro+rd*d;\n    float dif = GetLight(p);\n    col = vec3(dif);\n\n    //col = GetNormal(p);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3czs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 80, 80, 337], [413, 430, 464, 464, 714], [715, 715, 739, 739, 948], [949, 949, 973, 973, 1440], [1442, 1442, 1499, 1549, 1984]]}
{"id": "tdccDX", "name": "Circle Aberrations", "author": "Ezra_Szanton", "description": "Chromatic aberration on circles to obtain an optical illusion", "tags": ["chromaticaberration", "sin", "circle"], "likes": 4, "viewed": 100, "published": "Public", "date": "1601856985", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    uv *= 5.;\n    \n    \n    vec2 gv = fract(uv * 1.);\n    \n    vec3 col = vec3(0.);\n    \n    for(float x = -1.; x <= 1.; x+=1.){\n         for(float y = -1.; y <= 1.; y++){\n             \n            vec2 offs = vec2(x,y);\n            vec2 center = floor(uv)+0.5 + offs;\n             \n    \t\tfloat r = smoothstep(.3, 0.25, length(uv + 0.5 * sin(iTime*2.) - center));    \n    \t\tfloat g = smoothstep(.3, 0.25, length(uv + 1.0 * cos(iTime)    - center));    \n    \t\tfloat b = smoothstep(.3, 0.25, length(uv - center));\n    \n    \t\tcol += vec3(r, g, b);\n         }\n    }\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdccDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 748]]}
{"id": "tdccRl", "name": "Imaginary Grey Spot", "author": "KaDokta", "description": "Move with mouse. Stare at the black circle long enough and you will see a grey spot that's not really there. ", "tags": ["illusion"], "likes": 1, "viewed": 44, "published": "Public", "date": "1601509932", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 MarkField(in vec2 position, in vec2 fragCoord)\n{    \n    float size = 50.0;\n    \n    float startX = position.x;\n    float startY = position.y;\n            \n    float endX = startX;\n    float endY = startY;\n    \n    vec2 center = vec2((startX+endX)/2.0, (startY+endY)/2.0);\n    float maxDistance = distance(vec2(0.0,0.0), iResolution.xy);\n    float currentDistance = distance(center, fragCoord)/2.0;\n    \n    float colorValue = currentDistance/maxDistance * cos(iTime) + 0.2;\n    \n    if (distance(fragCoord, center) > size){\n    \treturn mix(vec4(colorValue, colorValue, colorValue, 1.0), vec4(sin(iTime), 2.0* sin(iTime), 3.0*sin(iTime), 1.0), 0.2);\n    }\n    else\n    {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if(iMouse.xy == vec2(0,0)){\n\t\tfragColor = MarkField(iResolution.xy/2.0, fragCoord);\n    }\n    else{\n        fragColor = MarkField(iMouse.xy, fragCoord);\n    }\n\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdccRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 724], [727, 727, 782, 782, 948]]}
{"id": "tdcyDj", "name": "A munching square with XOR", "author": "AI", "description": "This uses XOR for creating a munching square.", "tags": ["generativeart"], "likes": 3, "viewed": 43, "published": "Public", "date": "1601735635", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float col;\n    float dim=512.;\n    vec2 uv = fragCoord/iResolution.xy;\n    uv*=dim;\n    if ((int(uv.x) ^ int(uv.y))<(int(59.*iTime)%int(dim))){\n      col=1.;   \n    }\n    fragColor = vec4(col,.5+.2*sin(col*iTime+uv.y/20.),.5+.2*cos(col*iTime+uv.x/20.),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcyDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 320]]}
{"id": "tddcWj", "name": "Sierpinski Torus Interior", "author": "rodolphito", "description": "Remix of https://www.shadertoy.com/view/MsX3Wj and https://www.shadertoy.com/view/3sfcRj\n\nI threw this together real quick to reproduce hallucination visuals I had", "tags": ["torus", "sierpinski", "interior"], "likes": 0, "viewed": 25, "published": "Public", "date": "1601790280", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Thank you iquilez for some of the primitive distance functions!\n\n\nconst float AA = 2.0;\nbool docolor = true;\nint depth =8; // Levels of triangle\nfloat pcolorchange = 0.25; // Probability of color change at a given level\n\nconst float PI = 3.14159265358979323846264;\n\n// Smooth HSV to RGB conversion \n// Function by iq, from https://www.shadertoy.com/view/MsS3Wc\nvec3 hsv2rgb( in vec3 c ) {\n  vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n  rgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n  return c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n// From Chris Wellons: https://nullprogram.com/blog/2018/07/31/\nuint ihash(uint x) {\n    x ^= x >> 16;\n    x *= 0x7feb352dU;\n    x ^= x >> 15;\n    x *= 0x846ca68bU;\n    x ^= x >> 16;\n    return x;\n}\n\nuint randseed = 1U;\nuint xorshift() {\n  // Xorshift*32\n  // From George Marsaglia: http://www.jstatsoft.org/v08/i14/paper\n  randseed ^= randseed << 13;\n  randseed ^= randseed >> 17;\n  randseed ^= randseed << 5;\n  return randseed;\n}\n\nfloat rand() {\n  return float(xorshift())/pow(2.0,32.0);\n}\n\nvec3 getspherecolor(vec2 z) {\n    \n    z += (z.x + z.y) * -(3.0-sqrt(3.0))/6.0;\n    \n    uint index = uint(floor(dot(floor(z), vec2(5.,7.))));\n    \n    z = fract(z);\n    if (z.x + z.y > 1.) z = 1. - z;\n  float E = 10.0;\n  float t = 0.5;\n  uint epoch = uint((t+0.5*E+1.0)/(E+2.0));\n  t = mod(t,E+2.0)-1.0;\n  t = max(t,0.0);\n  if (t > 0.5*E) t = max(0.5*E,t-1.0);\n  t = min(t,E-t); // t < 0.5*E\n  randseed = ihash(epoch^index+1U); // 0 hashes to 0!\n  vec3 col = hsv2rgb(vec3(rand() + iTime * 0.1,0.8, 0.5 + 50.0 * z.x * z.y * (1. - z.x - z.y)));\n  for (int i = 0; i < depth; i++) {\n    int j;\n    if  (z.x > 0.5) { j = 0; z = 2.0*vec2(z.x-0.5,z.y); }\n    else if (z.y > 0.5) { j = 1; z = 2.0*vec2(z.x,z.y-0.5); }\n    else if (z.x + z.y < 0.5) { j = 2; z = 2.0*z; }\n    else { j = 3; z = 0.5-z; }\n    index = (index << 2) + uint(j);\n    randseed = ihash(epoch^index+1U); // 0 hashes to 0!\n    if (rand() < pcolorchange) col = hsv2rgb(vec3(rand() + iTime * 0.1,0.8,0.5 + 50.0 * z.x * z.y * (1. - z.x - z.y)));\n  }\n  return docolor ? col : vec3(0.8);\n}\n\n\n\nconst int MAX_PRIMARY_RAY_STEPS = 64; //decrease this number if it runs slow on your computer\n\nvec2 rotate2d(vec2 v, float a) { \n\treturn vec2(v.x * cos(a) - v.y * sin(a), v.y * cos(a) + v.x * sin(a)); \n}\n\nfloat sdTorus( vec3 p, vec2 t ) {\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat distanceField(vec3 p) {\n\treturn -sdTorus(p, vec2(4.0, 3.0));\n}\n\nvec3 castRay(vec3 pos, vec3 dir, float treshold) {\n\tfor (int i = 0; i < MAX_PRIMARY_RAY_STEPS; i++) {\n\t\t\tfloat dist = distanceField(pos);\n\t\t\t//if (abs(dist) < treshold) break;\n\t\t\tpos += dist * dir;\n\t}\n\treturn pos;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec4 mousePos = (iMouse / iResolution.xyxy) * 2.0 - 1.0;\n\tvec2 screenPos = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tvec3 cameraPos = vec3(0.0, 0.0, -3.8);\n\t\n\tvec3 cameraDir = vec3(0.0, 0.0, 0.5);\n\tvec3 planeU = vec3(1.0, 0.0, 0.0) * 0.8;\n\tvec3 planeV = vec3(0.0, iResolution.y / iResolution.x * 1.0, 0.0);\n\tvec3 rayDir = normalize(cameraDir + screenPos.x * planeU + screenPos.y * planeV);\n\t\n\tvec3 rayPos = castRay(cameraPos, rayDir, 0.01);\n\t\n\tfloat majorAngle = atan(rayPos.x, -rayPos.z) * 0.5 + iTime * 0.2;\n\tfloat minorAngle = atan(length(rayPos.xz) - 4.0, rayPos.y) + iTime * 0.1;\n\tvec2 coord = vec2(majorAngle, minorAngle) / PI * 0.5;\n\tvec3 color = getspherecolor(rotate2d(coord + 37., 37.));\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddcWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[268, 363, 390, 390, 566], [568, 632, 652, 652, 766], [788, 788, 805, 889, 999], [1001, 1001, 1015, 1015, 1059], [1061, 1061, 1090, 1090, 2108], [2150, 2207, 2239, 2239, 2315], [2317, 2317, 2350, 2350, 2415], [2417, 2417, 2446, 2446, 2485], [2487, 2487, 2537, 2537, 2702], [2704, 2704, 2761, 2761, 3497]]}
{"id": "tddyWl", "name": "Irreptile Triangle", "author": "tdhooper", "description": "Recursively tiling this hexadrafter irreptile from George Sicherman [url]https://userpages.monmouth.com/~colonel/drirrep/index.html[/url]", "tags": ["irreptile"], "likes": 39, "viewed": 700, "published": "Public API", "date": "1602028741", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Irreptile Triangle\n    ------------------\n\n    Recursively tiling this hexadrafter irreptile from George Sicherman\n    https://userpages.monmouth.com/~colonel/drirrep/index.html\n\n*/\n\n// Polygon distance, iq https://www.shadertoy.com/view/wdBXRW\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N = 6;\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return 1. - pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n#define PI 3.14159265359\n\n\n// MATRIX\n\nmat3 trs(vec2 t) {\n\treturn mat3(1, 0, t.x, 0, 1, t.y, 0, 0, 1);\n}\n\nmat3 rot(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\nmat3 scl(vec2 s) {\n\treturn mat3(s.x, 0, 0, 0, s.y, 0, 0, 0, 1);\n}\n\nfloat decomposeScale(mat3 m) {\n\tvec3 a = vec3(0) * m;\n\tvec3 b = vec3(1,0,0) * m;\n    return distance(a, b);\n}\n\n\n// MAIN\n\nconst int count = 11;\nmat3 tiles[count];\n\nfloat h = sqrt(3.) / 2.;\n\nfloat sdTile(vec2 p) {\n    vec2[] poly = vec2[](\n    \tvec2(0, 0),\n        vec2(2.5, 0),\n        vec2(2.5 - .25, -h / 2.),\n        vec2(1.5 - .25, -h / 2.),\n        vec2(1., -h),\n        vec2(.5, -h)\n    );\n\treturn sdPoly(poly, p);\n}\n\n//#define LOOP\n\nvec3 shadeTile(float d, float s, int i, int iteration) {\n    d = -d;\n    d *= iResolution.y * 2. / s;\n    d += .001 * iResolution.y;\n    //d += (.002 / s + .0008)  * iResolution.y;\n    d = clamp(d, 0., 1.) / 4.;\n    float t = float(i);\n    #ifdef LOOP\n        float time = mod(iTime / 3., 1.);\n        if (iteration > 0) {\n            t /= float(count);\n        } else {\n            t /= 3.;\n        }\n    \t//t *= 1.666;\n        t += time;\n    #else\n        if (iteration > 0) {\n            t /= float(count);\n            t = t * mix(1., 10., cos(iTime / 10.) * .5 + .5);\n        } else {\n            t /= 3.;\n        }\n        t += iTime / 3.;\n    #endif\n    vec3 col = d * spectrum(t);\n    return col;\n}\n\nbool drawTiles(inout vec2 p, inout vec3 col, inout float scale, int iteration) {\n    \n\tfloat scaleOut;\n    vec2 pOut;\n    bool hit = false;\n    \n    vec2 p2 = p;\n    float scale2 = scale;\n\n    for(int i = 0; i < count; i++ )\n    {\n        mat3 txm = tiles[i];\n        p = (vec3(p2, 1) * txm).xy;\n        scale = scale2 * decomposeScale(txm);\n\n        float d = sdTile(p);\n        col -= shadeTile(d, scale, i, iteration);\n\n        if (d < 0.) {\n            pOut = p;\n\t\t\tscaleOut = scale;\n            hit = true;\n        }\n        \n        if (iteration == 0 && i == 2) {\n        \tbreak;\n        }\n    }\n    \n    p = pOut;\n    scale = scaleOut;\n\n    return hit;\n}\n\nvec3 render(vec2 p) {\n\n    float scale = 1.;\n    vec3 col = vec3(1);\n\n    // recurse\n    for(int i = 0; i < 4; i++) {\n        if ( ! drawTiles(p, col, scale, i)) {\n            if (i == 0) {\n            \tcol = vec3(.8);\n            }\n            break;\n        }\n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y;\n\tp *= .55;\n    p *= vec2(1,-1);\n    p -= vec2(-.5,h/2.);\n    \n    \n    // prepare matrices\n    \n    // tri\n    mat3 triOrigin = trs(vec2(-.5, sqrt(3.) / 6.)) * scl(vec2(3));\n    tiles[0] = triOrigin * trs(vec2(1., -h));\n    tiles[1] = triOrigin * rot(PI / 1.5) * trs(vec2(1., -h));\n    tiles[2] = triOrigin * rot(PI / -1.5) * trs(vec2(1., -h));\n    \n    // long\n    mat3 rect = trs(vec2(-3.5, h)) * scl(vec2(-1));\n    mat3 longOrigin = scl(vec2(3. / 1.5)) * trs(vec2(-5, 0)) * scl(vec2(-1, 1));\n    tiles[3] = longOrigin;\n    tiles[4] = tiles[3] * rect;\n    \n    // box\n    mat3 boxOrigin = trs(vec2(-.5, h)) * scl(vec2(1.5 / .25));\n    tiles[5] = boxOrigin * rot(PI / -3.);\n    tiles[6] = tiles[5] * rect;\n    tiles[7] = boxOrigin * trs(vec2(-1, 0)) * rot(PI / -3.);\n    tiles[8] = tiles[7] * rect;\n    tiles[9] = boxOrigin * trs(vec2(-2, 0)) * rot(PI / -3.);\n    tiles[10] = tiles[9] * rect;\n\n    \n    // draw\n    \n   \tvec3 col = render(p);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 254, 279, 279, 298], [299, 299, 339, 339, 371], [391, 391, 432, 432, 979], [982, 1045, 1113, 1113, 1156], [1158, 1158, 1182, 1182, 1285], [1315, 1326, 1344, 1344, 1391], [1393, 1393, 1412, 1412, 1476], [1478, 1478, 1496, 1496, 1543], [1545, 1545, 1575, 1575, 1654], [1657, 1734, 1756, 1756, 1966], [1968, 1984, 2040, 2040, 2689], [2691, 2691, 2771, 2771, 3353], [3355, 3355, 3376, 3376, 3645], [3647, 3647, 3704, 3704, 4777]]}
{"id": "tddyWX", "name": "hexagonal world", "author": "nexor", "description": ".", "tags": ["2d", "hex"], "likes": 2, "viewed": 27, "published": "Public", "date": "1601904316", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define R iResolution\n#define T iTime\n#define pi acos(-1.)\n#define rot(a) mat2(cos(a+699.*vec4(0,-1,1,0)))\n\nfloat box(vec2 p, vec2 b)\n{\n \tp=abs(p)-b;\n    return min(0.,max(p.x,p.y))+length(max(p,.0));\n}\n\nfloat hex(vec2 p, out float id) {\n    p.x *= 2./sqrt(3.);\n\tp.y += mod(floor(p.x), 2.0)*0.5;\n    vec2 ip=floor(p)+.5;\n    p=fract(p)-.5;\n\tp = abs(p);\n    id=abs(max(ip.x*1.5 + ip.y, ip.y*2.0) - 1.0);\n\treturn abs(max(p.x*1.5 + p.y, p.y*2.0) - 1.0);\n}\n\nvoid mainImage( out vec4 O, in vec2 I )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (I-.5*R.xy)/R.y;\n\n    float k = length(uv);\n    //uv*=rot(.2*cos(k*15.+T));\n    uv=uv\n    *2./dot(uv,uv)\n    ;\n    float tt=T*.5;\n    float t=floor(tt);\n    float x=t+smoothstep(.0,.5,fract(tt));\n    float y=t+smoothstep(.5,1.,fract(tt));\n    \n    uv-=vec2(x,y);\n\n    float w =fwidth(length(uv));\n    //uv *= R.x/R.y*8.;\n    //uv *= 15.;\n    //uv = fract(uv-.5)-.5;\n    \n    //uv *= vec2(1.3,1.);\n    float id;\n    float d =hex(uv,id)-.25;\n    d=smoothstep(w*5.,.0,d);\n    //d-=sin(atan(id.y,id.x)*10.+length(id)*5.+T)*.5;\n    //id = floor(id);\n    vec3 col = (vec3(cos(id*7.)+sin(id*141.),sin(id*8.)*cos(id*31.),cos(id*13.+sin(id*17.)*12.))*.5+.5);\n    col = .3+.7*col;\n    col *= 1.-d;\n    O.rgb=col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddyWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 108, 135, 135, 202], [204, 204, 237, 237, 452], [454, 454, 495, 545, 1264]]}
{"id": "tdGcRh", "name": "Catmull-Rom Splines", "author": "Danguafer", "description": "Catmull-Rom Spline.\n\nThe first and last point are considered control points thus they aren't rendered.", "tags": ["spline"], "likes": 12, "viewed": 368, "published": "Public API", "date": "1602236037", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Reference: https://qroph.github.io/2018/07/30/smooth-paths-using-catmull-rom-splines.html\n\n// Constants\n\n#define time (iTime/1.0)\n#define LINES 32\n#define STEP 1.0/float(LINES)\n\n#define POINTS 10\n#define MAX_POINTS POINTS\n\nconst float PI = acos(-1.0);\nconst float TAU = PI * 2.0;\n\n// Draw helpers\n\nvec2 p;\n\nfloat line(vec2 a, vec2 b) {\n\tvec2 v  = b-a;\n    vec2 p0 = p-a;\n    float k = min(length(p0)/length(v),1.0);\n    return smoothstep(4.0/iResolution.y,0.0,length(p0-k*v));\n}\n\nfloat point(vec2 o) { return smoothstep(10.0/iResolution.y,7.5/iResolution.y,length(p-o)); }\n\nvoid drawPoint(inout vec3 color, vec3 drawColor, vec2 p) {\n    color = mix(color, drawColor, point(p));\n}\n\nvoid drawPoints(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {\n    for (int i = 0; i < count; i++)\n        drawPoint(color, drawColor, p[i]);\n}\n\nvoid drawLine(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {\n    for (int i = 0; i < count - 1; i++) {\n        color = mix(color, drawColor, line(p[i], p[i+1]));\n    }\n}\n\nvec2 splineInterpolation(vec2 p0, vec2 p1, vec2 p2, vec2 p3, float t) {\n    float alpha = 1.0;\n    float tension = 0.0;\n    \n    float t01 = pow(distance(p0, p1), alpha);\n\tfloat t12 = pow(distance(p1, p2), alpha);\n\tfloat t23 = pow(distance(p2, p3), alpha);\n\n\tvec2 m1 = (1.0f - tension) *\n    \t(p2 - p1 + t12 * ((p1 - p0) / t01 - (p2 - p0) / (t01 + t12)));\n\tvec2 m2 = (1.0f - tension) *\n    \t(p2 - p1 + t12 * ((p3 - p2) / t23 - (p3 - p1) / (t12 + t23)));\n    \n\tvec2 a = 2.0f * (p1 - p2) + m1 + m2;\n\tvec2 b = -3.0f * (p1 - p2) - m1 - m1 - m2;\n\tvec2 c = m1;\n\tvec2 d = p1;\n\n\treturn a * t * t * t +\n           b * t * t +\n           c * t +\n           d;\n\n}\n\nfloat spline(vec2 p0, vec2 p1, vec2 p2, vec2 p3) {\n    float curve = 0.0;\n    vec2 a = p1;\n\n    for (int i = 1; i <= LINES; i++) {\n        vec2 b = splineInterpolation(p0, p1, p2, p3, STEP*float(i));\n        curve = mix(curve,1.0, line(a, b));\n        a = b;\n    }\n    \n    return curve;\n}\n\nvoid drawSpline(inout vec3 color, vec3 drawColor, vec2 p[MAX_POINTS], int count) {\n    for (int i = 0; i < count - 3; i++) {\n        color = mix(color, drawColor, spline(p[i], p[i+1], p[i+2], p[i+3]));\n    }\n}\n\nvec2[MAX_POINTS] deformedCircle(int count) {\n    vec2 p[MAX_POINTS];\n    for (int i = 0; i < count; i++) {\n        float a = float(i) / float(count) * TAU;\n        p[i] = vec2(3.0, 1.5) * vec2(cos(a), sin(a)) * (0.3 + 0.1 * sin(iTime) + 0.15 * sin(a * 3.456 + iTime));\n    }\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0.94);\n    \n    vec2 p[MAX_POINTS] = deformedCircle(POINTS);\n    \n    drawLine(color, vec3(0.0), p, POINTS);\n    drawPoints(color, vec3(0.0), p, POINTS);\n    drawSpline(color, vec3(1.0, 0.0, 0.0), p, POINTS);\n    \n\tfragColor = vec4(color ,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGcRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[284, 310, 338, 338, 481], [483, 483, 504, 504, 575], [577, 577, 635, 635, 682], [684, 684, 766, 766, 847], [849, 849, 929, 929, 1038], [1040, 1040, 1111, 1111, 1692], [1694, 1694, 1744, 1744, 1983], [1985, 1985, 2067, 2067, 2194], [2488, 2488, 2545, 2545, 2872]]}
{"id": "tdGcRW", "name": "mprin", "author": "adr", "description": "move mouse move camera", "tags": ["weeee"], "likes": 4, "viewed": 48, "published": "Public", "date": "1602361083", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// followed great raymarch tutorial https://www.shadertoy.com/view/XlBGDW\n#define CLIP_NEAR 0.1\n#define CLIP_FAR 8.0\n#define STEPS 100\n#define EPSILON 0.0001\n#define DISTANCE_BIAS 0.7\n#define PI 3.14159\n\nfloat scene(vec3 p) {\n    vec3 pos = vec3(\n        sin(p.x * PI + 12.0 * sin(PI * p.x / 5.0)), // phase modulation\n        sin(p.y * PI + 12.0 * sin(PI * p.y / 5.0)),\n        p.z);\n    float d = length(pos);\n    return d;\n}\n\nfloat raymarch(vec3 p, vec3 direction) {\n\tfloat dist = CLIP_NEAR;\n    float result;\n    for (int i = 0; i < STEPS; ++i) {\n        result = scene(p + direction * dist);\n        if (result < EPSILON) { break; }\n        dist += result * DISTANCE_BIAS;\n        if (dist > CLIP_FAR) { break; }\n    }\n    return dist;\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n\t//vec3 f = normalize(center - eye);\n    vec3 f = normalize(eye - center);\n\tvec3 s = normalize(cross(f, up));\n\tvec3 u = cross(s, f);\n\treturn mat4(\n\t\tvec4(s, 0.0),\n\t\tvec4(u, 0.0),\n\t\tvec4(-f, 0.0),\n\t\tvec4(0.0, 0.0, 0.0, 1)\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 offset = vec3(-0.25 * iTime, 0.1 * iTime,  0.0);\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 direction = normalize(vec3(uv, 2.5));\n    vec3 eye = vec3(\n        1.0 - 2.0 * sin(PI * iMouse.x / iResolution.x) + offset.x,\n        1.0 - 2.0 * iMouse.y / iResolution.y + offset.y,\n        1.0 - 2.0 * cos(PI * iMouse.x / iResolution.x) + offset.z);\n    mat4 viewToWorld = viewMatrix(eye, offset, vec3(0.0, 1.0, 0.0));\n    vec3 worldDir = (viewToWorld * vec4(direction, 0.0)).xyz;\n    float result = raymarch(eye, worldDir);\n    float fog = 0.5 - result / CLIP_FAR;\n    \n    vec3 base = vec3(fog, fog, fog) * fog;\n    vec3 tint = vec3(1.0, 0.2, 0.2);\n    vec3 modulation_tint = vec3(0.1, 0.0, -0.1);\n    vec3 modulation_back = vec3(0.1, 0.0, 0.0);\n    vec3 back = vec3(0.2, 0.0, 0.2);\n    \n    vec3 color = base * (cos(iTime / (3.0 * PI)) * modulation_tint + tint) + back + sin(iTime / PI) * modulation_back;\n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGcRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 204, 225, 225, 427], [429, 429, 469, 469, 742], [744, 744, 793, 830, 1020], [1022, 1022, 1079, 1079, 2084]]}
{"id": "tdGyRw", "name": "waveDivision", "author": "Kaeylos", "description": "#4 sinWave\nmade during the Ink-MAC-tober 2020\ntribute to joy division\n\ninspired by : https://www.shadertoy.com/view/4dfSDj", "tags": ["noise", "monochromatic", "imac"], "likes": 2, "viewed": 90, "published": "Public", "date": "1602435114", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired by : https://www.shadertoy.com/view/4dfSDj\n// source: https://www.shadertoy.com/view/ttc3zr\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) { return uintBitsToFloat(murmurHash12(floatBitsToUint(src)) & 0x007fffffu | 0x3f800000u) - 1.0; }\n\n// optimized smoothstep\nfloat hermiteInter(float t) { return t * t * (3.0 - 2.0 * t); }\nvec2 hermiteInter(vec2 t) { return t * t * (3.0 - 2.0 * t); }\n\nfloat perlinNoise(vec2 xy) {\n\tvec2 lv = hermiteInter(fract(xy));\n\tvec2 id = floor(xy);\n\t\n\tfloat a = hash12(id+vec2(0.,0.));\n\tfloat b = hash12(id+vec2(1.,0.));\n\tfloat c = hash12(id+vec2(0.,1.));\n\tfloat d = hash12(id+vec2(1.,1.));\n\tfloat x1 = mix(a, b, lv.x);\n\tfloat x2 = mix(c, d, lv.x);\n\treturn mix(x1, x2, lv.y);\n}\n\nfloat fbm (vec2 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat a = 1.;\n\tfloat aSum = 1.;\n\t\n\t// Rotate and shift to reduce axial bias\n    //mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    //vec2 shift = vec2(100);\n\tfor ( float i=0.; i < float(octaves); ++i) {\n\t\tv += a * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\ta *= G;\n\t\taSum += a;\n\t\t// p = rot * p + shift;\n\t}\n\treturn v / aSum;\n}\n\nfloat rayPlaneIntersion(vec3 O, vec3 D, vec3 p, vec3 n) {\n\tfloat denom = dot(n, D);\n\tif( denom > 0.001) {\n\t\treturn  (dot(n, p-O)) / denom;\n\t}\n\treturn -1.;\n}\n\nvec3 rayTrace(vec3 O, vec3 D) {\n\tvec3 bgCol = vec3(0.16);// background color\n\tvec3 col = bgCol; \n\tvec3 n = vec3(0.,0.,1.); // planes normal\n\t\n\tvec2 pc = vec2(0.9, 0.005); // planeClamp\n\tfloat mistDist = 2.5;\n\tfloat t = -1.; // t factor to plane ip = O+t*D\n    for (float k=0.; k<30.; ++k) {\n    \tpc.x *= 1.05; // horizontalClamping enlargment\n    \tfloat planeDepth = k*0.08125;\n\t\tt = rayPlaneIntersion(O, D, vec3(0., 0., planeDepth), n);\n        if (t>0.) { // if we hit something\n        \tvec3 ip = O+t*D; // intersection pt\n        \tfloat vx = abs(ip.x);\n        \tif (vx<pc.x) { // clamp horizontal axis\n\t\t        float noise = 0.18*(fbm(3.*ip.xz+0.08*iTime, 1., 3)*2.0-1.0);\n\t\t        noise *= exp(-10.*vx*vx); // reduce impact horizontaly\n\t\t        ip.y += noise;\n\t        \tif(abs(ip.y) < pc.y) { // clamp verticaly axis  \n\t\t        \tfloat d = abs(ip.y/pc.y); // distance to edge\n\t\t        \t// d = -(d-1.); // distance inversion\n\t\t        \tcol = mix(vec3(1.), bgCol, hermiteInter(d));\n\t\t        \t\n\t\t        \tfloat mistCoeff = clamp(pow(planeDepth / mistDist, 1.5), 0., 1.) ;\n\t\t        \tcol = mix(col, bgCol, mistCoeff);\n\t\t        \tbreak;\n\t\t        }\n        \t}\n        }\n    }\n    return clamp(col,0.,1.);\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv /= 1.; // zoom\n    \n    float T1 = -3.14159*(0.5 + 0.15*cos(0.33*iTime));\n\t// camera\n\tvec3 O = vec3(0., 0.28 + 0.03 * (sin(iTime)+1.)/2., -0.2);\n\tvec3 lookAtPos = vec3(0., 0., 2.8);\n\tvec3 D = computeCamDir(uv, O, vec3(0., 1., 0.), lookAtPos);\n\t\n\n\tvec3 col = vec3(0.16); // background color\n\t\n    // Render planes\n    col = rayTrace(O, D);\n\t\n\t// Vignetting\n\tvec2 q = uv*iResolution.y/iResolution.xy/2.;\n    // col *= vec3(pow(1.-length(q), 0.8));\n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGyRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 104, 134, 134, 331], [332, 332, 356, 356, 452], [454, 478, 507, 507, 541], [542, 542, 569, 569, 603], [605, 605, 633, 633, 920], [922, 922, 964, 964, 1345], [1347, 1347, 1404, 1404, 1503], [1505, 1505, 1536, 1536, 2716], [2718, 2718, 2788, 2788, 3067], [3069, 3069, 3126, 3126, 3678]]}
{"id": "tdGyWm", "name": "Wired checkerboard", "author": "Good", "description": "doodling with sine waves", "tags": ["checkerboard"], "likes": 8, "viewed": 107, "published": "Public", "date": "1602965732", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 p, float a){return p * mat2(cos(a), -sin(a), sin(a), cos(a));}\n \nconst vec3 c1 = vec3(.1,.05,.2);\nconst vec3 c2 = vec3(1,.5,.1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.yy /3. ;    \n    vec2 uv1 = rotate(uv, 1.6+sin(iTime)*.4);    \n    float w = sin(uv1.x*160.+iTime*20. + sin(uv1.y*30.)*3.)*20.; \n    w += sin(uv.x*150. + sin(uv.y*20.)*5.)*20.;    \n    w = clamp(w, .0, 1.);\n    vec3 col = mix(c1, c2, w);\n    fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGyWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 29, 29, 79], [147, 147, 203, 203, 529]]}
{"id": "tdGyz3", "name": "huya", "author": "jokey", "description": "初次尝试，虎牙公仔一只。欢迎大佬指正", "tags": ["sdf"], "likes": 2, "viewed": 73, "published": "Public", "date": "1603343802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat hash( float n )\n{\n    return fract(sin(n)*158.5453123);\n}\n\n\n\nconst mat2 m2 = mat2( 0.80, -0.60, 0.60, 0.80 );\n\n\n//----------------------------------------------------------------\n\nfloat sdEllipsoid( in vec3 p, in vec3 r )\n{\n    return (length( p/r ) - 1.0) * min(min(r.x,r.y),r.z);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\n// trick by klems\n#define ZERO (min(iFrame,0))\n\n//----------------------------------------------------------------\n\nvec2 map( vec3 p )\n{\n\tp.y -= 1.8;\n    \n\tp.x = abs(p.x);\n\n\tvec3 q = p;\n\tq.y -= 0.2*pow(1.0-length(p.xz),1.0)*sin(p.y*3.0)*smoothstep(0.0,0.2,p.y);\n    q.x*=0.71;\n\tq.z *= 1.0 + 0.1*smoothstep( 0.0, 0.5, q.z )*smoothstep( -0.5, 0.5, p.y );\n\tfloat d1 = length( q ) - 0.9;\n    vec2 res = vec2( d1, 2.3 );\n\n\n\tvec3 hp = p - vec3(0.65,0.4,0.0);\n    hp.xy = mat2(0.6,0.8,-0.8,0.6)*hp.xy;\n    hp.x += 1.8*hp.y*hp.y;\n    float d4 = sdEllipsoid(hp, vec3(0.53,0.5,0.26) );\n\t//d4 *= 0.2;\n\tif( d4<res.x )  res = vec2( d4, 2.0 );\n\n \n\n\t// mouth\n\tfloat mo = length( (q-vec3(0.0,-0.35,1.0))*vec3(1.0,1.2,0.25)/1.2 ) -0.3/1.2;\n\tfloat of = 0.1*pow(smoothstep( 0.0, 0.2, abs(p.x-0.3) ),0.5);\n\tmo = max( mo, -q.y-0.35-of );\n\n\tfloat li = smoothstep( 0.0, 0.05, mo+0.02 ) - smoothstep( 0.05, 0.10, mo+0.02 );\n\t//res.x -= 0.03*li*clamp( (-q.y-0.4)*10.0, 0.0, 1.0 );\n\t\n\treturn vec2(res.x*0.8,res.y);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n#if 0    \n    vec3 eps = vec3(0.002,0.0,0.0);\n\treturn normalize( vec3(\n           map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n           map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n           map(pos+eps.yyx).x - map(pos-eps.yyx).x ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.002*e).x;\n    }\n    return normalize(n);\n#endif    \n}\n\nvec3 intersect( in vec3 ro, in vec3 rd )\n{\n    float m = -1.0;\n\tfloat mint = 10.0;\n\n    // plane\t\n\tfloat tf = (0.0-ro.y)/rd.y;\n\tif( tf>0.0 ) { mint = tf; m = 0.0; }\n\t\n\t// mike\n\tfloat maxd = min(5.0,mint);\n\tfloat precis = 0.001;\n    float t = 0.0;\n\tfloat d = 0.0;\n    for( int i=ZERO; i<128; i++ )\n    {\n\t    vec2 res = map( ro+rd*t );\n        float h = res.x;\n\t\td = res.y;\n        if( h<precis||t>maxd ) break;\n        t += h;\n    }\n\n   if( t<maxd && t<mint )\n\t{\n\t\tmint = t;\n\t\tm = d;\n\t}\n\n    return vec3( mint, m, m );\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<50; i++ )\n    {\n        float h = map(ro + rd*t).x;\n        res = min( res, smoothstep(0.0,1.0,k*h/t) );\n\t\tt += clamp( h, 0.01, 0.25 );\n\t\tif( res<0.005 || t>10.0 ) break;\n    }\n    return clamp(res,0.0,1.0);\n}\n\nvec2 rotate( vec2 p, float a )\n{\n    return vec2(cos(a)*p.x+p.y*sin(a), p.y*cos(a)-p.x*sin(a));\n}\nfloat sdEquilateralTriangle( in vec2 p,float ro )\n{\n    vec2 q=rotate(p,ro);\n    const float k = sqrt(3.0);\n    q.x = abs(q.x) - 1.0;\n    q.y = q.y + 1.0/k;\n    if( q.x+k*q.y>0.0 ) q = vec2(q.x-k*q.y,-k*q.x-q.y)/2.0;\n    q.x -= clamp( q.x, -2.0, 0.0 );\n    return -length(q)*sign(q.y);\n}\n\nvec3 lig = normalize(vec3(1.0,0.7,0.9));\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.5);\n\t\n\t#ifdef STEREO\n\tfloat eyeID = mod(fragCoord.x + mod(fragCoord.y,2.0),2.0);\n    #endif\n\n\n\t\n    //-----------------------------------------------------\n    // camera\n    //-----------------------------------------------------\n\t\n\tfloat an = sin(-0.25 + 0.31416*iTime) - 6.2831*(m.x-0.5);\n\n\tvec3 ro = vec3(3.5*sin(iTime),1.8,3.5*cos(iTime));\n    vec3 ta = vec3(0.0,1.5,0.0);\n\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n\t// create view ray\n\tvec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\n\t#ifdef STEREO\n\tvec3 fo = ro + rd*7.0; // put focus plane behind Mike\n\tro -= 0.1*uu*eyeID;    // eye separation\n\trd = normalize(fo-ro);\n    #endif\n\n    //-----------------------------------------------------\n\t// render\n    //-----------------------------------------------------\n\n\tvec3 col = vec3(1.0);\n\n\t// raymarch\n    vec3 tmat = intersect(ro,rd);\n    if( tmat.z>-0.5 )\n    {\n        // geometry\n        vec3 pos = ro + tmat.x*rd;\n        vec3 nor = calcNormal(pos);\n\t\tvec3 ref = reflect( rd, nor );\n\n        // materials\n\t\tvec4 mate = vec4(0.0);\n\t\tvec2 mate2 = vec2(1.0,1.0);\n\t\tif( tmat.z<0.5 )\n\t\t{\n\t\t\tnor = vec3(0.0,1.0,0.0);\n\t\t    ref = reflect( rd, nor );\n\t\t\tmate.xyz = vec3(1.0);\n            mate2.y = 1.0 - 0.9*(2.0/(2.0+dot(pos.xz,pos.xz)));\n\t\t}\n\t\telse if( tmat.z<2.5 )\n\t\t{\n\t\t\tvec3 q = pos-vec3(0.0,2.1,0.0);\n\n\t\t\tfloat an2 = an + 0.015*(-1.0+2.0);\n            vec3 oq = q;\t\t\t\n\t\t\tq.x += -2.0*0.15*clamp(sin(an2),-0.42,0.42);\n            q.x*=0.6;\n\t\t\tfloat f = length( q.xy );  \n            vec3 eyec=vec3(0.398,0.23,0.133);\n            mate = vec4(1.0,0.967,0.02,1.0);\n           \t//mate2.y = 1.0-smoothstep(0.24,0.35,length( oq.xy-vec2(0.0,0.035) ));\t\t\t\n\t        mate2.y*=0.1;\n            if(q.z>0.0){\n\t\t\tmate.xyz = mix(mate.xyz, vec3(0.9),1.0-smoothstep(0.5,0.55,f) );\t\n             \n            vec3 mq= pos-vec3(0.0,2.1,0.0);\n            mq.y += 0.7;\n            mq.xy*=vec2(1.6,4.3);\n\t\t\tf = length( mq.xy );    \n            mate.xyz = mix(mate.xyz, vec3(0.531,0.281,0.152),1.0-smoothstep(0.5,0.55,f) );\t\n                \n                \n            float ya=sdEquilateralTriangle(mq.xy*vec2(18.0,9.0)+vec2(-4.0,-3.5),3.14*0.35);\n\t\t\tmate.xyz = mix( mate.xyz, vec3(3.9), 1.0-smoothstep( 0.18, 0.19, ya ) );   \n                   \n                \n                \n            float eye=sdEquilateralTriangle(q.xy*4.0,3.14*0.15);                 \n\t\t\tmate.xyz = mix( mate.xyz, eyec, 1.0-smoothstep( 0.18, 0.19, eye ) );\n           \n            oq.x += -0.4*clamp(sin(an2),-0.22,0.22);\n            oq.x+=0.1;\n            oq.y-=0.1;\n\t\t\tf = length( oq.xy );\n\t\t\tmate.xyz = mix( mate.xyz, vec3(0.9), 1.0- smoothstep( 0.07, 0.10, f ));\n                \n                \n         \n            }\n            \n     \n            float wen1=sdEquilateralTriangle(q.xy*vec2(4.0,10.0)+vec2(-3.0,6.0),3.14*1.15);\n\t\t\tmate.xyz = mix( mate.xyz, eyec, 1.0-smoothstep( 0.18, 0.19, wen1 ) );\n\n            float wen2=sdEquilateralTriangle(q.xy*vec2(4.0,10.0)+vec2(3.0,6.0),3.14*0.15);\n\t\t\tmate.xyz = mix( mate.xyz, eyec, 1.0-smoothstep( 0.18, 0.19, wen2 ) );\n\n            float wen3=sdEquilateralTriangle(q.xy*vec2(4.0,10.0)+vec2(-3.0,4.0),3.14*1.15);\n\t\t\tmate.xyz = mix( mate.xyz, eyec, 1.0-smoothstep( 0.18, 0.19, wen3 ) );\n\n            float wen4=sdEquilateralTriangle(q.xy*vec2(4.0,10.0)+vec2(3.0,4.0),3.14*0.15);\n\t\t\tmate.xyz = mix( mate.xyz, eyec, 1.0-smoothstep( 0.18, 0.19, wen4 ) );\n            \n            \n           \n            \n\t\t\n            //mate.xyz *= 1.0-0.2*vec3(0.5,0.9,1.0)*smoothstep( 0.2, 0.4, f );\n           \n            mate2.x = 64.0;\n\t\t}\t\n        \n\t\n\t\t\n\t\t// lighting\n\t\tfloat occ = (0.5 + 0.5*nor.y)*mate2.y;\n        float amb = 0.5;\n\t\tfloat bou = clamp(-nor.y,0.0,1.0);\n\t\tfloat dif = max(dot(nor,lig),0.0);\n        float bac = max(0.3 + 0.7*dot(nor,-lig),0.0);\n\t\tfloat sha = 0.0; if( dif>0.01 ) sha=softshadow( pos+0.01*nor, lig, 0.001, 32.0 );\n        float fre = pow( clamp( 1.0 + dot(nor,rd), 0.0, 1.0 ), 2.0 );\n        vec3  hal = normalize(lig-rd);\n        float spe = max(pow( clamp( dot(nor,hal), 0.0, 1.0), mate2.x*4.0 ),0.0 );\n\t\t\n\t\t// lights\n\t\tvec3 lin = vec3(0.2);\n        lin += 2.0*dif*vec3(1.00,1.00,1.00)*pow(vec3(sha),vec3(1.0,1.2,1.5));\n\t\tlin += 1.0*amb*vec3(0.30,0.30,0.30)*occ;\n\t\tlin += 2.0*bou*vec3(0.40,0.40,0.40)*mate2.y;\n\t\tlin += 4.0*bac*vec3(0.40,0.30,0.25)*occ;\n        lin += 1.0*fre*vec3(1.00,1.00,1.00)*2.0*mate.w*(0.5+0.5*dif*sha)*occ;\n\n        \n\t\tcol = mate.xyz*lin;\n\t}\n\n\tcol = pow( clamp(col,0.0,1.0), vec3(0.45) );\n\n\t// vigneting\n    col *= 0.5 + 0.5*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.25 );\n\n    #ifdef STEREO\t\n    col *= vec3( eyeID, 1.0-eyeID, 1.0-eyeID );\t\n\t#endif\n\t   \n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGyz3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 24, 24, 64], [119, 187, 230, 230, 290], [292, 292, 333, 333, 422], [424, 424, 457, 457, 483], [533, 601, 621, 621, 1475], [1477, 1477, 1509, 1509, 2058], [2060, 2060, 2102, 2102, 2580], [2582, 2582, 2647, 2647, 2921], [2923, 2923, 2955, 2955, 3020], [3021, 3021, 3072, 3072, 3308], [3352, 3352, 3409, 3409, 8308]]}
{"id": "tdKcDt", "name": "DistoLines", "author": "Kaeylos", "description": "#9 distortion\nmade during the Ink-MAC-tober 2020", "tags": ["raymarching", "distortion", "imac"], "likes": 18, "viewed": 298, "published": "Public", "date": "1604081525", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ----- Ray marching options ----- //\n#define AA_SAMPLES 2 // antialisaing\n// #define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 25\n#else\n    #define MAX_STEPS 200\n#endif\n#define MAX_DIST 50.\n#define SURF_DIST 0.0001\n#define NORMAL_DELTA 0.0001\n\n#define FBM_MAX_ITER 10\n\n// ----- easingFunct -----//\nfloat quadin(float t) { return t*t;}\nfloat quadOut(float t) { return -t*(t-2.0);}\nfloat cubicIn(float t) { return t*t*t;}\nfloat cubicOut(float t) { return -t*t*t+1.0;}\nfloat circleOut(float t) { return pow(1.0-(1.0-t)*(1.0-t), 0.5); }\nfloat circleIn(float t) { return 1.0- pow(1.0-t*t, 0.5); }\nfloat gauss(float t, float s) { return exp(-(t*t)/(2.*s*s)); }\n// sub interpolation used in smoothstep\n#define hermiteInter(t) t * t * (3.0 - 2.0 * t)\n\n// ----- UsefulConstants ----- //\n#define PI  3.14159265358979323846264338327\n\n// ----- Useful functions ----- //\n#define rot2(a) mat2(cos(a), -sin(a), sin(a), cos(a))\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(max(v.x , v.y), v.z); }\nfloat cro(vec2 a,vec2 b) { return a.x*b.y - a.y*b.x; }\nfloat map(float a, float b, float t) {return a + t * (b - a); } // considering that t is in [0-1]\nfloat mult(vec2 v) { return v.x*v.y; }\nfloat mult(vec3 v) { return v.x*v.y*v.z; }\nfloat sum(vec2 v) { return v.x+v.y; }\nfloat sum(vec3 v) { return v.x+v.y+v.z; }\n#define saturate(v) clamp(v, 0., 1.)\n\n// ----- Noise stuff ----- //\n// Based on Morgan McGuire and David Hoskins\n// https://www.shadertoy.com/view/4dS3Wd\n// https://www.shadertoy.com/view/4djSRW\n\nfloat hash1(float p) {\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\nfloat hash1(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat hash1(vec3 p3) {\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec2 hash2(float p) {\n\tvec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n\tp3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec2 hash2(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\nvec3 hash3(float p) {\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nvec3 hash3(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yzz)*p3.zyx);\n}\n\nvec3 hash3(vec3 p3) {\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n}\n\nvec4 hash4(float p) {\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n\n}\n\nvec4 hash4(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx)  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nvec4 hash4(vec4 p4) {\n\tp4 = fract(p4  * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\n\nfloat perlinNoise(float x) {\n    float id = floor(x);\n    float f = fract(x);\n    float u = f;\n    return mix(hash1(id), hash1(id + 1.0), u);\n}\n\nfloat perlinNoise(vec2 x) {\n    vec2 id = floor(x);\n    vec2 f = fract(x);\n\n\tfloat a = hash1(id);\n    float b = hash1(id + vec2(1.0, 0.0));\n    float c = hash1(id + vec2(0.0, 1.0));\n    float d = hash1(id + vec2(1.0, 1.0));\n\t// Same code, with the clamps in smoothstep and common subexpressions\n\t// optimized away.\n    vec2 u = hermiteInter(f);\n\treturn mix(a, b, u.x) + (c - a) * u.y * (1.0 - u.x) + (d - b) * u.x * u.y;\n}\n\nfloat perlinNoise(vec3 x) {\n    const vec3 step = vec3(110., 241., 171.);\n\n    vec3 id = floor(x);\n    vec3 f = fract(x);\n \n    // For performance, compute the base input to a 1D hash from the integer part of the argument and the \n    // incremental change to the 1D based on the 3D -> 1D wrapping\n    float n = dot(id, step);\n\n    vec3 u = hermiteInter(f);\n    return mix(mix(mix( hash1(n + dot(step, vec3(0, 0, 0))), hash1(n + dot(step, vec3(1, 0, 0))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 0))), hash1(n + dot(step, vec3(1, 1, 0))), u.x), u.y),\n               mix(mix( hash1(n + dot(step, vec3(0, 0, 1))), hash1(n + dot(step, vec3(1, 0, 1))), u.x),\n                   mix( hash1(n + dot(step, vec3(0, 1, 1))), hash1(n + dot(step, vec3(1, 1, 1))), u.x), u.y), u.z);\n}\n\nfloat fbm (vec2 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n    vec2 shift = vec2(100.);\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t\t// Rotate and shift to reduce axial bias\n\t\tx = rot2(0.5) * x + shift;\n\t}\n\treturn v / aSum;\n}\n\nfloat fbm (vec3 x, float H, int octaves) {\n\tfloat G = exp2(-H);\n\tfloat v = 0.;\n\tfloat f = 1.;\n\tfloat amp = 1.;\n\tfloat aSum = 1.;\n\t\n\tfor ( int i=0; i < FBM_MAX_ITER; ++i) {\n\t\tif( i >= octaves) break;\n\t\tv += amp * perlinNoise(f*x);\n\t\tf *= 2.;\n\t\tamp *= G;\n\t\taSum += amp;\n\t}\n\treturn v / aSum;\n}\n\nfloat distanceField(vec3 p) {\n    float final = perlinNoise(p*0.06125) -0.5;\n    float other = perlinNoise(p*0.06125 + 1234.567) - 0.5;\n    final = 1./(abs(final*final*other));\n    return final*0.0001;\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\n// return dist, marchingCount, maxDist\nvec3 rayMarching(vec3 O, vec3 D, int steps, inout float density) { // ray origin and dir\n    float t = 0.0;\n    float marchingCount = 0.0;\n \tfloat maxD = 1.e-10;\n    for(int i = 0; i < steps; i++) {\n    \tif( i > MAX_STEPS) break;\n    \tvec3 newPos = O + D * t;\n        float d = distanceField(newPos);\n        \n        // custom incrementation here for this sketch\n        t += 3.; // precision handling\n        density += d*0.01;\n        ++marchingCount;\n        maxD = max(maxD, d);\n        \n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( t > MAX_DIST || abs(d) < SURF_DIST*0.99) break;\n    }\n    return vec3(t, marchingCount, maxD);\n}\n\nfloat densityMarching(vec3 O, vec3 D) {\n\tfloat density = 0.;\n    // ray marching\n\tint steps = 12;\n    float t = 0.0;\n    for(int i = 0; i < steps; i++) {\n    \tif( i > MAX_STEPS) break;\n    \tvec3 newPos = O + D * t;\n        float d = distanceField(newPos + 12.);\n        \n        // custom incrementation here for this sketch\n        t += 3.; // precision handling\n        density += d*0.01;\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( t > MAX_DIST || abs(d) < SURF_DIST*0.99) break;\n    }\n    return density;\n}\n\nvec3 render(vec3 O, vec3 D) {\n\tvec3 cyan = vec3(25., 80., 122.)/255.;\n    vec3 blue = vec3(21., 71., 199.)/255.;\n    vec3 orange = vec3(255., 184., 113.)/255.;\n    \n    float density =  densityMarching(O, D);\n    \n\tvec3 col = blue*0.1;\n\tcol += pow(density, 0.45)*orange*0.5;\n\tcol += gauss(density*2., 0.1) * cyan * 0.2;\n\treturn saturate(col);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n\tvec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n    uv *= 2.; // zoom\n    float delay = 12.; // loop delay in s\n\tfloat a = 2.*PI*iTime/delay; // angle\n\tfloat r = 3.; // radius\n\tfloat y = sin(a + 12.)*0.5;\n\tvec3 O = vec3(r*cos(a), y, r*sin(a)); // origin\n\t\n\tvec3 finalColor = vec3(0.);\n#if AA_SAMPLES > 1\n    for (float i = 0.0; i < float(AA_SAMPLES); i++) {\n    \tfor (float j = 0.0; j < float(AA_SAMPLES); j++) {\n\t        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) *2.0 - 1.0) / iResolution.y;\n\t        uv += deltaUV;\n#endif\n\t\t\tvec3 D = computeCamDir(uv, O, vec3(0.,1.,0.), vec3(0.)); // dir\n\t    \tfinalColor += render(O, D);\n#if AA_SAMPLES > 1\n    \t}\n    }\n    finalColor /= float(AA_SAMPLES * AA_SAMPLES); // Average samples\n#endif\n    \n    // color grading\n    finalColor *= vec3(1.0 ,0.9, 0.98) *1.2;\n    \n\tfragColor = vec4(finalColor,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKcDt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[324, 353, 376, 376, 389], [390, 390, 414, 414, 434], [435, 435, 459, 459, 474], [475, 475, 500, 500, 520], [521, 521, 547, 547, 587], [588, 588, 613, 613, 646], [647, 647, 678, 678, 709], [878, 967, 990, 990, 1015], [1016, 1016, 1039, 1039, 1074], [1075, 1075, 1101, 1101, 1129], [1130, 1130, 1168, 1168, 1193], [1194, 1228, 1248, 1248, 1266], [1267, 1267, 1287, 1287, 1309], [1310, 1310, 1329, 1329, 1347], [1348, 1348, 1367, 1367, 1389], [1428, 1586, 1608, 1608, 1693], [1695, 1695, 1716, 1716, 1833], [1835, 1835, 1857, 1857, 1960], [1962, 1962, 1983, 1983, 2111], [2113, 2113, 2133, 2133, 2266], [2268, 2268, 2289, 2289, 2408], [2410, 2410, 2431, 2431, 2564], [2566, 2566, 2586, 2586, 2722], [2724, 2724, 2745, 2745, 2869], [2871, 2871, 2892, 2892, 3035], [3037, 3037, 3057, 3057, 3206], [3208, 3208, 3228, 3228, 3377], [3379, 3379, 3400, 3400, 3534], [3536, 3536, 3564, 3564, 3679], [3681, 3681, 3708, 3708, 4103], [4105, 4105, 4132, 4132, 4898], [4900, 4900, 4942, 4942, 5291], [5293, 5293, 5335, 5335, 5583], [5585, 5585, 5614, 5614, 5788], [5790, 5790, 5860, 5860, 6139], [6141, 6180, 6246, 6268, 6868], [6870, 6870, 6909, 6909, 7435], [7437, 7437, 7466, 7466, 7781], [7783, 7783, 7838, 7838, 8699]]}
{"id": "tdKcRK", "name": "barycentric compact", "author": "Artleet", "description": "my version of the triangle-based backgrounds inspired by\nhttps://www.shadertoy.com/view/MdfBzl", "tags": ["2d", "barycentric", "triangulation"], "likes": 27, "viewed": 379, "published": "Public", "date": "1603272585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//my version of the triangle-based backgrounds inspired by\n//https://www.shadertoy.com/view/MdfBzl\n\n#define K 5.\n#define T (K + iTime * .2)\n#define S(a, b) vec2(cos(a),-sin(b))\n\n//barycentric coordinates\n//using some methods discovered by FabriceNeyret2\nvec3 b(vec2 a, vec2 b, vec2 c, vec2 p) {\n    a = inverse(mat2(b - a, c - a)) * (p - a);\n    return abs(vec3(1. - a.x - a.y, a));\n}\n\n//simple hash\nvec2 h(vec2 p){\n    return fract(sin(p * 34. + p.yx * 91.) * 4e5) * 2. - 1.;\n}\n\n//animation\nvec2 a(vec2 p){\n    vec2 b = h(p) * T;\n    return (p + S(b.x, b.y) * .2 + .5) / K;\n}\n\n//colour\nvec3 c(vec2 p) {\n    return .5 + .5 * cos(6.283 * (vec3(.8, .8, .5) * dot((p + h(p)) / K, S(T, T)) + vec3(0, .2, .5)));    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 u = fragCoord.xy / iResolution.y, id = floor((u *= mat2(1, 0, -.5, .8)) * K);\n    vec3 x, y, z, w;\n    float m = 1., d, q, r;\n   \n    for(int i=0; i<4; i++){       \n        //setup vertices coordinates\n        //using some methods discovered by FabriceNeyret2\n        //using i-i/2*2 instead i%2 for WebGL 1 compatibility \n        vec2 v0 = id - vec2(i-i/2*2,i/2), v1=v0, v2=v0, v3=v0+1.; v2.x++; v1.y++;\n\n       \t\n        //barycentric coordinates for two tiangles\n \t\tz = b(a(v0), a(v1), a(v2), u), \n        w = b(a(v1), a(v2), a(v3), u);\n        \n        //the sum of the coordinates - 1. to understand is the point inside the triangle or not\n        q = z.x + z.y + z.z - 1.,\n        r = w.x + w.y + w.z - 1.;\n        \n        //setup colours for the vertices of the triangles\n        //interpolation between colours of the vertices\n        z = mat3(c(v2), c(v0), c(v1)) * z, \n        w = mat3(c(v2), c(v1), c(v3)) * w;\n        \n        //if the point is out of the triangle - make a mask for the antialiasing, sum triangle colour otherwise\n        if(q > 1e-6) m = min(m, q * 1e2); else x += z;\n        if(r > 1e-6) m = min(m, r * 1e2); else x += w;\n\t\t\n        //mixing colours for antialiasing on edges\n        if(q < .01) y += z, d++;\n        if(r < .01) y += w, d++;\n    }\n    \n\tfragColor = vec4(mix(y / d, x, m), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKcRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 254, 294, 294, 384], [386, 400, 415, 415, 478], [480, 492, 507, 507, 576], [578, 587, 603, 603, 712], [715, 715, 772, 772, 2109]]}
{"id": "tdKcWc", "name": "RayMarchingTest-sphere", "author": "Hopepdm", "description": "sdf 基本光照模型， copy from iq", "tags": ["3d"], "likes": 2, "viewed": 60, "published": "Public", "date": "1603940318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// 抗锯齿开关\n\n#define AA 2\n\n// sdf\nfloat sdPlane(vec3 p) {\n\treturn p.y;\n}\n\nfloat sdSphere(vec3 p, float s){\n\treturn length(p) - s;\n}\n\n// sdf的交并补\n// subtraction减法\nfloat opS(float d1, float d2){\n\treturn max(-d2, d1);\n}\n\n// Union\nvec2 opU(vec2 d1, vec2 d2) {\n    return ( d1.x < d2.x ) ? d1 : d2;\n}\n\n// repetition 周期重复\nvec3 opRep(vec3 p, vec3 c){\n\treturn mod(p,c) - 0.5 * c;\n}\n\n//twist 扭曲\nvec3 opTwist(vec3 p){\n\tfloat c = cos(10.0 * p.y + 10.0);\n    float s = sin(10.0 * p.y + 10.0);\n    mat2 m = mat2(c, -s, s, c);\n    return vec3(m * p.xz, p.y);\n}\n\nvec2 map(in vec3 pos){\n\t// res.x 是光线到表面的距离，res.y 影响的是物体材质\n\t//vec2 res = vec2( sdSphere( pos-vec3( 0.0,0.25, 0.0), 0.25 ), 46.9 );\n\tvec2 res = opU( vec2( sdPlane( pos), 1.0 ),\n\t\t\tvec2( sdSphere( pos-vec3( 0.0,0.25, 0.0), 0.25 ), 48.0 ) );\n    \n    return res;\n\n}\n\n// 实际是 Ray-marching\nvec2 castRay( in vec3 ro, in vec3 rd )\n{\n\tfloat tmin = 1.0;\n\tfloat tmax = 20.0;\n \n#if 1   // 加速 Raymarching\n\t// bounding volume\n\tfloat tp1 = (0.0-ro.y)/rd.y;\n\tif( tp1>0.0 )\n\t\ttmax = min( tmax, tp1 );\n \n\tfloat tp2 = (1.6-ro.y)/rd.y;\n\tif( tp2>0.0 )\n\t{\n\t\tif( ro.y>1.6 )\n\t\t\ttmin = max( tmin, tp2 );\n\t\telse\n\t\t\ttmax = min( tmax, tp2 );\n\t}\n#endif\n \n\tfloat t = tmin;\n\tfloat m = -1.0;\n\tfor( int i=0; i<64; i++ )\n\t{\n\t\tfloat precis = 0.0005*t;\n\t\tvec2 res = map( ro+rd*t );\n\t\tif( res.x<precis || t>tmax )\n\t\t\tbreak;\n\t\tt += res.x;\n\t\tm = res.y;\t// 唯一用到 res.y 的地方，影响材质的计算\n\t}\n \n\tif( t>tmax )\n\t\tm=-1.0;\n\treturn vec2( t, m );\n}\n \n// 柔化阴影\n// http://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n\tfloat t = mint;\n\tfor( int i=0; i<16; i++ )\n\t{\n\t\tfloat h = map( ro + rd*t ).x;\n\t\tres = min( res, 8.0*h/t );\n\t\tt += clamp( h, 0.02, 0.10 );\n\t\tif( h<0.001 || t>tmax )\t// 在[ mint, maxt)范围内进行插值\n\t\t\tbreak;\n\t}\n\treturn clamp( res, 0.0, 1.0 );\n}\n \n// 法线\nvec3 calcNormal( in vec3 pos )\n{\n\tvec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n\treturn normalize( e.xyy*map( pos + e.xyy ).x +\n\t\t\te.yyx*map( pos + e.yyx ).x +\n\t\t\te.yxy*map( pos + e.yxy ).x +\n\t\t\te.xxx*map( pos + e.xxx ).x );\n\t/*\n\t vec3 eps = vec3( 0.0005, 0.0, 0.0 );\n\t vec3 nor = vec3(\n\t map(pos+eps.xyy).x - map(pos-eps.xyy).x,\n\t map(pos+eps.yxy).x - map(pos-eps.yxy).x,\n\t map(pos+eps.yyx).x - map(pos-eps.yyx).x );\n\t return normalize(nor);\n\t */\n}\n \n// Ambient Occlusion: 环境光吸收/遮蔽\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n\tfloat sca = 1.0;\n\tfor( int i=0; i<5; i++ )\n\t{\n\t\tfloat hr = 0.01 + 0.12*float(i)/4.0;\n\t\tvec3 aopos = nor * hr + pos;\n\t\tfloat dd = map( aopos ).x;\n\t\tocc += -(dd-hr)*sca;\n\t\tsca *= 0.95;\n\t}\n\treturn clamp( 1.0 - 3.0*occ, 0.0, 1.0 );\n}\n \nvec3 render( in vec3 ro, in vec3 rd )\n{\n\tvec3 col = vec3(0.7, 0.9, 1.0) +rd.y*0.8;\n\tvec2 res = castRay(ro,rd);\n\tfloat t = res.x;\n\tfloat m = res.y;\n\tif( m>-0.5 )\n\t{\n\t\tvec3 pos = ro + t*rd;\t\t// 步进的光线位置\n\t\tvec3 nor = calcNormal( pos );\t// 法线\n\t\tvec3 ref = reflect( rd, nor );\t// 反光\n \n\t\t// material\n\t\tcol = 0.45 + 0.35*sin( vec3(0.05,0.08,0.10)*(m-1.0) );\n\t\t// 如果是地板的话\n\t\tif( m<1.5 )\n\t\t{\n\t\t\t// 格子地砖\n\t\t\tfloat f = mod( floor(5.0*pos.z) + floor(5.0*pos.x), 2.0);\n\t\t\tcol = 0.3 + 0.1*f*vec3(1.0);\n\t\t}\n \n\t\t// 光照模型的计算\n\t\tfloat occ = calcAO( pos, nor );\n\t\tvec3 lig = normalize( vec3(-0.4, 0.7, -0.6) );\n\t\tfloat amb = clamp( 0.5+0.5*nor.y, 0.0, 1.0 );\n\t\tfloat dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n\t\tfloat bac = clamp( dot( nor, normalize(vec3(-lig.x,0.0,-lig.z))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n\t\tfloat dom = smoothstep( -0.1, 0.1, ref.y );\n\t\tfloat fre = pow( clamp(1.0+dot(nor,rd),0.0,1.0), 2.0 );\n\t\tfloat spe = pow(clamp( dot( ref, lig ), 0.0, 1.0 ),16.0);\n \n\t\t// 散射阴影\n\t\tdif *= softshadow( pos, lig, 0.02, 2.5 );\n\t\t// 反光阴影\n\t\tdom *= softshadow( pos, ref, 0.02, 2.5 );\n \n\t\t// 注意物体底座的阴影变化\n\t\t// occ = 1.;\n\t\tvec3 lin = vec3(0.0);\n\t\tlin += 1.30*dif*vec3(1.00,0.80,0.55);\n\t\tlin += 2.00*spe*vec3(1.00,0.90,0.70)*dif;\n\t\tlin += 0.40*amb*vec3(0.40,0.60,1.00)*occ;\n\t\tlin += 0.50*dom*vec3(0.40,0.60,1.00)*occ;\n\t\tlin += 0.50*bac*vec3(0.25,0.25,0.25)*occ;\n\t\tlin += 0.25*fre*vec3(1.00,1.00,1.00)*occ;\n\t\tcol = col*lin;\n \n\t\tcol = mix( col, vec3(0.8,0.9,1.0), 1.0-exp( -0.0002*t*t*t ) );\n\t}\n \n\treturn vec3( clamp(col,0.0,1.0) );\n}\n \nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\t\t// look\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\t// XY Space\n\tvec3 cu = normalize( cross(cw,cp) );\t// right\n\tvec3 cv = normalize( cross(cu,cw) );\t// up\n \n\t// right,\n\t// up,\t* world = camera\n\t// look\n\t// 注意： glsl 是按列存储，所以可以直接右乘相机坐标系的点，结果就是世界坐标系下的点\n\treturn mat3( cu, cv, cw );\t// right, up, look\n}\n \n\nuniform float iGlobalTime;\n \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy / iResolution.xy;\n        float time = 15.0 + iTime;\n\n        vec3 tot = vec3(0.0);\n    #if AA>1\t// 开启 AA\n        for (int m = 0; m < AA; m++)\n        {\n            for (int n = 0; n < AA; n++)\n            {\n                // pixel coordinates\n                vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n                vec2 p = (-iResolution.xy + 2.0 * (fragCoord + o)) / iResolution.y;\n    #else\n                vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    #endif\n\n                // camera\n                vec3 ro = vec3(-0.5 + 3.5 * cos(0.1 * time + 6.0 * mo.x),\n                        1.0 + 2.0 * mo.y, 0.5 + 4.0 * sin(0.1 * time + 6.0 * mo.x));\n                vec3 ta = vec3(-0.5, -0.4, 0.5);\n                // camera-to-world transformation\n                mat3 ca = setCamera(ro, ta, 0.0);\n                // ray direction\n                vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n                // render\n                vec3 col = render(ro, rd);\n\n                // 针对电子屏幕的 gamma 矫正（否则颜色偏暗）\n                col = pow(col, vec3(0.4545));\n\n                tot += col;\n    #if AA>1\n            }\n        }\n        tot /= float(AA * AA);\n    #endif\n\n        fragColor = vec4(tot, 1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKcWc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 41, 64, 64, 79], [81, 81, 113, 113, 138], [140, 180, 210, 210, 234], [236, 245, 273, 273, 313], [315, 342, 369, 369, 399], [401, 416, 437, 437, 576], [578, 578, 600, 743, 875], [877, 903, 943, 943, 1545], [1548, 1630, 1704, 1704, 1975], [1978, 1988, 2020, 2020, 2430], [2433, 2478, 2520, 2520, 2769], [2772, 2772, 2811, 2811, 4377], [4380, 4380, 4432, 4432, 4830], [4865, 4865, 4922, 4922, 6213]]}
{"id": "tdKcWD", "name": "Fishermen at sea", "author": "athibaul", "description": "Reproduction of the painting [url=https://en.wikipedia.org/wiki/Fishermen_at_Sea]Fishermen at Sea[/url] by William Turner.", "tags": ["procedural", "waves", "sea", "ocean", "painting", "reproduction", "williamturner"], "likes": 26, "viewed": 232, "published": "Public", "date": "1602899337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Trying to recreate the painting \"Fishermen at sea\" by William Turner\n// https://www.tate.org.uk/art/artworks/turner-fishermen-at-sea-t01585\n\n// I have rediscovered William Turner's paintings recently; \n// here is my take on this moonlight scene.\n// Many elements are missing (including the fishermen themselves!),\n// and the lighting is not quite on point, but I think it's already\n// rather pretty.\n\n\n\n// Inspired by \"Seascape\" by TDM\n// https://www.shadertoy.com/view/Ms2SD1\n\n// My clouds are 2D, but their lighting was inspired by\n// \"Clouds\" by iq\n// https://www.shadertoy.com/view/XslGRr\n\n// The non-physically-based lighting was inspired by\n// \"Live Coding \"Greek Temple\"\" by iq\n// https://youtu.be/-pdSjBPH3zM?t=5092\n\n\n\n\n\n#define ITER_GEOM 2\n#define ITER_SHADING 8\n#define WAVE_HEIGHT 1.2\n#define dot2(a) dot(a,a)\n\n#define T0(ip) texelFetch(iChannel0, ivec2(mod(ip,256.)), 0).r\n#define rgb(r,g,b) pow(vec3(r,g,b)/255., vec3(2.2))\n\nconst vec2 subject = vec2(-1.3,5.);\n\nfloat noise(vec2 p)\n{\n    vec2 ip = floor(p), fp = fract(p);\n    fp = smoothstep(0.,1.,fp);\n    vec2 e = vec2(1,0);\n    return mix(\n        mix(T0(ip     ), T0(ip+e.xy), fp.x),\n        mix(T0(ip+e.yx), T0(ip+e.xx), fp.x),\n        fp.y);\n}\n\n\nfloat seaOctave(vec2 uv, bool choppy)\n{\n    // Adapted from TDM \"Seascape\"\n    uv += 2.*noise(uv);\n    uv.x *= 0.62;\n    vec2 wv = 0.5+0.5*cos(2.*uv);\n    float w = pow(wv.x * wv.y, 0.6);\n   \tif(choppy)\n        return (1.-w)*(1.-w);\n    return 1.-w;\n}\n\nfloat clouds(vec2 uv, float time, float displace)\n{\n    uv += 0.7*noise(displace*uv + time) + time*vec2(1.,0.3);\n    float f = 0.5*noise(uv);\n    f += 0.25*noise(2.*uv) + 0.125*noise(4.*uv) + 0.0625*noise(8.*uv);\n    return f;\n}\n\n\nfloat seaHeight(vec2 uv, float time, int iter)\n{\n    vec2 p = uv;\n    uv *= 0.4;\n    float phase = time*0.18;\n    float h = 0.;\n    float amp = 0.25 * mix(0.2, 1.0, smoothstep(15.,5.,length(p-subject)));\n    for(int i=0; i<iter; i++)\n    {\n        bool choppy = (i<3);\n        h += amp * (seaOctave(uv+phase, choppy) + seaOctave(-uv+phase, choppy));\n        //uv *= mat2(.6,.8,-.8,.6)*2.;\n        uv *= mat2(0,2,-2,0);\n        // Wave propagation speed is approximately proportional to sqrt(wavenumber)\n        // https://en.wikipedia.org/wiki/Dispersion_(water_waves)\n        // so we scale phase by the appropriate factor\n        phase *= sqrt(2.);\n        amp *= 0.4;\n    }\n    return h;\n}\n\n\nfloat map(vec3 p, int iter)\n{\n    float d = p.z + WAVE_HEIGHT*(1. - seaHeight(p.xy, iTime, iter));\n     // Forced perspective : the sea in the foreground is lowering toward the viewer\n    d += 2./(1.+p.y) - 0.4;\n    return d;\n}\n\nfloat raymarch(vec3 ro, vec3 rd)\n{\n    if(rd.z > 0.) return 100.;\n    float d, t=-ro.z/rd.z; // Water surface is below z=0\n    for(int i=0; i<100; i++)\n    {\n        d = map(ro+t*rd, ITER_GEOM);\n        if(d < 0.005 || t > 100.) break;\n        t += d;\n    }\n    return t;\n}\n\nvec3 normal(vec3 p, int iter)\n{\n    float eps = 0.005;\n    #if 0\n    vec2 e = eps * vec2(1,-1);\n    return normalize(\n          e.xxx*map(p+e.xxx, iter)\n        + e.xyy*map(p+e.xyy, iter)\n        + e.yxy*map(p+e.yxy, iter)\n        + e.yyx*map(p+e.yyx, iter)\n        );\n    #else\n    vec2 e = eps*vec2(1,0);\n    return normalize(\n        vec3(\n            map(p+e.xyy, iter) - map(p-e.xyy, iter),\n            map(p+e.yxy, iter) - map(p-e.yxy, iter),\n            2.*e.x\n            ));\n    #endif\n}\n\nconst vec3 moonColor = rgb(182,168,107);\nconst vec3 seaColor = rgb(35,59,59)*3.;\nconst vec3 horizonTint = rgb(140,120,61)/moonColor;\n\nvec3 moon = normalize(vec3(-0.2,1.0,0.35));\n\nvec3 getSkyColor(vec3 rd)\n{\n    float LdotV = dot(rd, moon);\n    float surface = 0.01*0.01;\n    float moonDisk = smoothstep(2.*surface, surface, 1.-LdotV);\n    \n    float cltime = iTime*0.1; // Clouds\n    vec2 cluv = rd.xz / (1.+rd.y);\n    vec2 moonuv = moon.xz / (1.+moon.y);\n    \n    vec3 moonHalo = vec3(clamp((1.+LdotV)/2., 0., 1.));\n    \n    moonHalo = pow(moonHalo, vec3(20,18,18)*1.5) * moonColor;\n    \n    moonHalo *= smoothstep(0.5,0.0,abs(cluv.x-moonuv.x));\n    \n    vec3 col = moonDisk * moonColor * 3. + moonHalo;\n    \n    \n    {\n        // Back clouds\n        float cl = clouds(vec2(50,100) * cluv, cltime, 3.);\n        float cl2 = clouds(vec2(50,100) * mix(cluv, moonuv, 0.05), cltime, 3.);\n        float lig = max((cl-cl2), 0.) / max(dot2(moonuv-cluv),1e-3)*0.03;\n        //cl += smoothstep(0.2, 0.6, length(vec2(rd.z, rd.x+0.15*rd.y)));\n        //cl = smoothstep(0.5, 1.0, cl);\n        cl *= smoothstep(0.,0.2,length(cluv-moonuv));\n        vec3 clcol = lig * mix(moonColor, vec3(0.5), 0.5);\n        col = mix(col, clcol, cl);\n    }\n    \n    // Front clouds\n    float cl = clouds(vec2(30,50) * cluv, cltime, 1.);\n    cl += smoothstep(0.2, 0.6, length(vec2(rd.z, rd.x+0.15*rd.y)));\n    cl = smoothstep(0.5, 1.0, cl);\n    float cl2 = clouds(vec2(30,50) * mix(cluv, moonuv, 0.01), cltime, 1.);\n    cl2 += smoothstep(0.2, 0.6, length(vec2(rd.z, rd.x+0.15*rd.y)));\n    cl2 = smoothstep(0.5, 1., cl2);\n    float lig = max((cl-cl2), 0.);\n    \n    lig *= 1. / max(dot2(moonuv-cluv),1e-3)*0.05;\n    \n    vec3 clcol = lig*moonColor*vec3(1.,0.8,0.6);\n    col = mix(col, clcol, cl);\n   \n    \n    \n    \n    float fogDepth = 1./max(rd.z,0.001);\n    fogDepth = mix(fogDepth, 0., cl*smoothstep(0.,0.3,rd.z));\n    col = mix(col, moonHalo*horizonTint, 1.-exp(-0.08*fogDepth));\n    \n    return col;\n}\n\nvec3 getBigMoonColor(vec3 rd)\n{\n    // Fake reflections using a big moon\n    //vec3 dist = vec3(0.05,1.,1.);\n    //vec3 rd2 = normalize(dist*rd), moon2=normalize(-dist*moon);\n    vec3 rd2 = rd, moon2 = normalize(vec3(0.,10.,5.));\n    float LdotV = dot(rd, moon);\n    float surface = 3e-4;\n    float moonDisk = smoothstep(surface, 0., 1.-LdotV);\n    return moonColor*moonDisk*0.002/surface;\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    float d, t=0.;\n    for(int i=0; i<20; i++)\n    {\n        d = map(ro+t*rd, ITER_GEOM);\n        if(d < 0.02 || t > 100.) break;\n        t += d;\n    }\n    return t>10. ? 1. : 0.;\n}\n\nvec3 calculateColor(vec3 ro, vec3 rd)\n{\n    \n    float t = raymarch(ro, rd);\n    if(t < 100.)\n    {\n    \tvec3 p = ro+t*rd;\n        vec3 n = normal(p, ITER_SHADING);\n        vec3 rrd = reflect(rd, n);\n        //vec3 col = vec3(seaHeight(p.xy, iTime, ITER_SHADING));\n        vec3 col = 0.5+0.5*n;\n        \n        float fre = 1.0 - clamp(dot(-rd, n), 0.0, 1.0);\n        fre = pow(fre, 5.);\n        \n        // Here come the non-physical lighting tricks!\n        \n        // Fake subsurface scattering inspired by Tekf\n        // \"Wax (fake subsurface)\"\n        // https://www.shadertoy.com/view/lslXRj\n        float subsurfDist = 0.15;\n        float subsurfCoef = (map(p + moon*subsurfDist, 1) - map(p, 1))/subsurfDist;\n        subsurfCoef = smoothstep(0.25, 0.5, subsurfCoef);\n        // Modulate this component to highlight only the backfaces of waves\n        float backSubsurfCoef = clamp(dot(n, vec3(-1,-1,0)*moon), 0., 1.0);\n        float subsurfDist2 = 0.5;\n        float subsurfCoef2 = (map(p + moon*subsurfDist2, ITER_GEOM) - map(p, ITER_GEOM))/subsurfDist2;\n        subsurfCoef2 = clamp(subsurfCoef2, 0., 1.);\n        vec3 diffuse = 2.*seaColor * subsurfCoef2;\n        \n        float subjectDist = length(p.xy - subject);\n        // Add the strange lighting in the background\n        float backDist = length(p.xy - vec2(-10.,50.)*0.8);\n        vec3 backLight = pow(smoothstep(30.,0.,backDist),3.)*vec3(3.8,4.,5.)*2.;\n        diffuse *= smoothstep(5., 0.0, subjectDist) + backLight;\n        diffuse += 5.*moonColor*backSubsurfCoef*subsurfCoef * smoothstep(3.,0.,subjectDist);\n        \n        float LdotN = dot(n, moon);\n        //diffuse *= 1.+LdotN;\n        \n        vec3 specular = getSkyColor(rrd) * backLight;\n        \n        specular += getBigMoonColor(rrd)\n     \t\t\t\t* smoothstep(5.0, 0.0, subjectDist);\n\t\t\t\t\t//* shadow(p+0.01*n, rrd);\n\t\t\n        {\n            // Add a light at the position of the \"subject\"\n            vec3 lpos = vec3(subject, 0.15-map(vec3(subject,0),ITER_GEOM));\n            vec3 ldir = lpos - p;\n            vec3 lcol = vec3(1.,0.3, 0.03);\n            float ldist = length(ldir);\n            ldir /= ldist;\n            float intensity = 1./(ldist*ldist);\n           \tfloat LdotV = clamp(dot(ldir, rrd), 0., 1.);\n            specular += lcol * pow(LdotV, 1000.) * 10.*intensity;\n            diffuse += lcol * LdotV * intensity*0.01;\n        }\n        \n            \n        col = mix(diffuse, specular, fre);\n        \n        //col += moonColor *3. * pow(smoothstep(30.,0.,backDist), 3.)*fre;\n        \n        // Mix with fog\n        float fog = 1.-exp(-t*0.02);\n        col = mix(col, getSkyColor(vec3(rd.xy, 0.)), fog);\n        \n        return col;\n    } else\n    {\n        return getSkyColor(rd);\n    }\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\t\n    vec3 ro = vec3(0,0,0.1);\n    vec3 rd = normalize(vec3(uv.x,2.,uv.y+0.2));\n    \n    vec3 col = calculateColor(ro, rd);\n    \n    col = mix(col, 1.-(4./27.)/(col*col), step(2./3.,col));\n    col = pow(col, vec3(1./2.2));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKcWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[598, 979, 1000, 1000, 1217], [1220, 1220, 1259, 1294, 1471], [1473, 1473, 1524, 1524, 1701], [1704, 1704, 1752, 1752, 2396], [2399, 2399, 2428, 2428, 2626], [2628, 2628, 2662, 2662, 2901], [2903, 2903, 2934, 2934, 3399], [3580, 3580, 3607, 3607, 5376], [5378, 5378, 5409, 5552, 5769], [5771, 5771, 5803, 5803, 5985], [5987, 5987, 6026, 6026, 8728], [8731, 8731, 8788, 8788, 9128]]}
{"id": "tdKcWm", "name": "BlinnPhongs", "author": "emedan", "description": "Test for BlinnPhong. Using Struct to easier manage different materials and lights. Slow with > 1 light source on laptop.", "tags": ["test"], "likes": 3, "viewed": 61, "published": "Public", "date": "1603132333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// BlinnPhong shading.\n// With a twist of shadow.\n//\n// Jon Bolmstedt 2020-10-19\n\nint NBR_LIGHT = 3;\t// 1-3.\n\n// Ray march to find object empirically.\n// Spherical algorithm, so it's only the qualifying short distance \n//   to find an object that affects performance.\n\n\n//  Ray marching parameters\n//  MAX_STEPS - Exit march regardless of finding an object.\t\n//                Does not affect performance much.\n//                Can be used for nice halo, because this code returns \"no object and no background\".\n//  SURF_DIST - Small distance to reach when object is found.\t\t\n//                Affects performance much.. need depends on geometry.\n//  MAX_DIST  - Far \"clipping plane\".\n//                Does not affect performance much.\n//                In this code \"background\" is returned when this distance is reached.\n//                Can make trippy 4D effects.\n#define MAX_STEPS 300\n#define SURF_DIST 0.01\n#define MAX_DIST 100.0\n\n#define pi 3.141593\n#define pi2 6.28318530718\n#define pi4 12.5663706144\n\nbool BLINN = true;\n\n\nstruct Material {\n    // Each type of reflected light can be given a separate tint.\n    vec3 ambCol;\t// Material color of reflected ambient light.\n    vec3 diffCol;\t// Material color of reflected diffuse light.\n    vec3 specCol;\t// Material color of reflected specular light.\n    \n    // Use the intensities to darken/brighten the defined light color.\n    float ambFac;\t// Material intensity modifier for ambient light.\t\n    float diffFac;\t// Material intensity modifier for diffuse light.\n    float specFac;\t// Material intensity modifier for specular light.\n\n    // How tight the glare is.\n    float shininess;// Material specular shininess.\n}; \n    \nstruct Light {\n    // A magical light source may not have the same color if it's diffused or reflected.\n    // But for normal light sources the colors are the same.\n    vec3 ambCol;\t// Light ambient color\n    vec3 diffCol;\t// Light diffuse color\n    vec3 specCol;\t// Light ambient color\n    \n    // Use the intensities to darken/brighten the defined light color.\n    float ambFac;\t// Light intensity modifier\n    float diffFac;\t// Light intensity modifier\n    float specFac;  // Light intensity modifier\n    \n    // Not here? Separate for PointLight, AreaLight and so on?\n    float power;\n    float falloffLinFac;\n    float falloffQuadFac;\n    vec3 pos;\n    float powerAtt;\t// Placeholder for calculation.\n    float dist;\t\t\t// Placeholder for calculation.\n}; \n\n\n// Possible light sources \nLight lights[4];\n    \n\n// Global list to simplify function returns.\nfloat objectDistances[10];\n\n\n// map from to, clamped\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1), min2, max2);\n}\n\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n\n// Return rotation matrix\nmat3 rotate3dx(float _angle){\n    float c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        1, 0,  0, \n        0, c, -s,\n        0, s,  c\n    );\n}\nmat3 rotate3dy(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n         c, 0, s,\n         0, 1, 0,  \n        -s, 0, c\n    );\n}\nmat3 rotate3dz(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        c, -s, 0,\n        s,  c, 0,\n        0,  0, 1\n    );\n}\n\n\n// Signed, negative inside object\nfloat SDF_box(vec3 p, vec3 size, float rounding) {\n\tp = abs(p)-size;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0) - rounding;\n}\n\n\n// Signed, negative inside object\nfloat SDF_capsule(vec3 p, vec3 A, vec3 B, float r) {\n    vec3 AB = B-A;\n    vec3 AP = p-A;\n    \n    float t = dot(AB, AP) / dot(AB, AB);\n    t = clamp(t, 0.0, 1.0);\n    \n    //return length(p - (A + t*AB)) - r;\n    float tt = 2.0*abs(0.5 - t);\t// 1 .. 0 .. 1\n    tt = t;\n    return length(p - (A + t*AB)) -r + r*smoothstep(1.0, 0.0, pow(tt, 0.9));\n    \n    float s1 = length(p - (A + t*AB)) - r*smoothstep(1.0, 0.0, tt);\n    float s2 =  length(p - (A + t*AB)) - r*(1.0+1.0*pow((t-0.5), 2.0));\n    float s = 0.5*(1.0+sin(iTime));\n    s = 0.0;\n    return s*s1+(1.0-s)*s2;\n}\n\n\n//Signed, negative inside object.\nfloat SDF_sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\n\n// Get the distance from point p to the closest object of all objects in the scene.\n// Returns: distance, object index\n// Distance can be constrained to selected object.\nfloat GetDist(vec3 p, out int objIndex, in int objConstraint) {\n    // Reusable translation variable.\n    vec3 trans;\n    \n    // Sphere /////////////////////////////////////////\n    //vec4 sphere = vec4(2.*sin(iTime), 0, 10.+6.*cos(iTime), 2);\n    vec4 sphere;\n    sphere = vec4(0, 3, 4, 2.1);\n    float sdf_sphere = SDF_sphere(p, sphere.xyz, sphere.w);\n    //sdf_sphere = abs(sdf_sphere) - 0.05;\t// Shell\n\t///////////////////////////////////////////////////\n    \n    // A sphere above the light to make a lamp\n    float sdf_sphereLight = SDF_sphere(p, vec3(12.*sin(iTime/4.), 13, 12.*cos(iTime/4.) + 6.), 0.8);\n\tsdf_sphereLight = SDF_sphere(p, vec3(0, 15, 0), 0.8);\n    \n    // Capsule ///////////////////////////////////////\n\tvec3 cpA, cpB;\n    float cr;\n    cr = 0.85;\n\n    // Position object before rotating around world origo\n\t// Rotate around origo\n    float xang = iTime*0.6+pi/4.0;\n    float yang = iTime*0.3;\n    float zang = iTime*0.3+pi/3.0;\n    mat3 rot = rotate3dy(yang) * rotate3dx(xang) * rotate3dz(zang);\n    \n    float a = 1.0;\n    float b = 4.0;\n    vec3 cpA1 = vec3(a, 0, 0);\n    vec3 cpB1 = vec3(b, 0, 0);\n    vec3 cpA2 = vec3(-a, 0, 0);\n    vec3 cpB2 = vec3(-b, 0, 0);\n    vec3 cpA3 = vec3(0, a, 0);\n    vec3 cpB3 = vec3(0, b, 0);\n    vec3 cpA4 = vec3(0, -a, 0);\n    vec3 cpB4 = vec3(0, -b, 0);\n    vec3 cpA5 = vec3(0, 0, a);\n    vec3 cpB5 = vec3(0, 0, b);\n    vec3 cpA6 = vec3(0, 0, -a);\t\t\n    vec3 cpB6 = vec3(0, 0, -b);\n    vec3 baseT = vec3(0, 3, 4);\n    cpA1 *= rot;\n    cpB1 *= rot;\n    cpA2 *= rot;\n    cpB2 *= rot;\n    cpA3 *= rot;\n    cpB3 *= rot;\n    cpA4 *= rot;\n    cpB4 *= rot;\n    cpA5 *= rot;\n    cpB5 *= rot;\n    cpA6 *= rot;\n    cpB6 *= rot;\n    cpA1 += baseT;\n    cpB1 += baseT;\n    cpA2 += baseT;\n    cpB2 += baseT;\n    cpA3 += baseT;\n    cpB3 += baseT;\n    cpA4 += baseT;\n    cpB4 += baseT;\n    cpA5 += baseT;\n    cpB5 += baseT;\n    cpA6 += baseT;\n    cpB6 += baseT;\n    \n    \n    ///////////////////////////////////////////////////\n    float sdf_capsule1 = SDF_capsule(p, cpA1, cpB1, cr);\n    float sdf_capsule2 = SDF_capsule(p, cpA2, cpB2, cr);\n    float sdf_capsule3 = SDF_capsule(p, cpA3, cpB3, cr);\n    float sdf_capsule4 = SDF_capsule(p, cpA4, cpB4, cr);\n    float sdf_capsule5 = SDF_capsule(p, cpA5, cpB5, cr);\n    float sdf_capsule6 = SDF_capsule(p, cpA6, cpB6, cr);\n    \n    // Box ////////////////////////////////////////////\n    vec3 boxSize = vec3(0.7);\n    vec3 boxCenter = vec3(-6, 3., 6);\n    float boxRounding = 1.5;\n    float boxThickness = 0.05;\n    vec3 boxPos = p-boxCenter;\n    \n    // Mirror in x. Works because position contains marching point and box sdf function\n    //  is made for box at origo.\n    //boxPos.x = abs(boxPos.x); \n    //boxPos.x -= 4.;\t\t\t\t// Space mirrored out from original pos.\n    \n    float sdf_box = SDF_box(boxPos, boxSize, boxRounding);\n    //sdf_box = abs(sdf_box) - boxThickness;\t// Makes shell with thickness.\n    ///////////////////////////////////////////////////\n    \n    // Floor plane ////////////////////////////////////\n    float sdf_plane = p.y;\t//  flat and at y = 0.\n    sdf_plane = dot(p, normalize(vec3(0, 1, 0 )));\t// Tilt plane\n    sdf_plane += sin(p.x/4. +iTime/4.) /5.;\n    sdf_plane += sin(p.x/2. +iTime/2.) /7.;\n    sdf_plane += sin(p.x    +iTime/1.) /9.;\n\n    sdf_plane += sin(p.z/2. +iTime)    /3.;\n    sdf_plane += sin(p.z    +iTime*3.) /7.;\n    ///////////////////////////////////////////////////\n    \n    // Info about hit object.\n    int objIndexDist = 0;\n    float objLimit = SURF_DIST;\n\n    // Capsules + sphere\n    if      (sdf_capsule1   < objLimit) objIndexDist = 1;\n    else if (sdf_capsule2   < objLimit) objIndexDist = 2;\n    else if (sdf_capsule3   < objLimit) objIndexDist = 3;\n    else if (sdf_capsule4   < objLimit) objIndexDist = 4;\n    else if (sdf_sphere     < objLimit) objIndexDist = 5;\n    else if (sdf_capsule5   < objLimit) objIndexDist = 6;\n    else if (sdf_capsule6   < objLimit) objIndexDist = 7;\n\n    ///////////////////////////////////////////////////    \n    // Copy all distances to a global array\n    objectDistances[0] = sdf_capsule1;\n    objectDistances[1] = sdf_capsule2;\n    objectDistances[2] = sdf_capsule3;\n    objectDistances[3] = sdf_capsule4;\n    objectDistances[4] = sdf_sphere;\n    objectDistances[5] = sdf_capsule5;\n    objectDistances[6] = sdf_capsule6;\n\t    \n    // Return the distance to any object for this position p.\n    // The ray marcher will march until the distance is really small.\n    // Distance functions must be signed, and return negative value inside object.\n    //\n    // abs(object distance) - Creates shell. Distance will increase from edges.\n    //\n    // Using: \n    //  min(d1, d2)  - Ray will stop at closest to either one. Typical usage.\n    //  max(d1, d2)  - Ray point requires both d1 and d2 small. Will get the intersection.\n    //  max(-d1, d2) - Object 1 will cut out object 2.\n    float d = MAX_DIST;\n    \n    \n        \n    // Capsules + sphere\n    d = MAX_DIST;\n    d = min(d, sdf_capsule1);\n    d = min(d, sdf_capsule2);\n    d = min(d, sdf_capsule3);\n    d = min(d, sdf_capsule4);\n    d = min(d, sdf_capsule5);\n    d = min(d, sdf_capsule6);\n    d = min(d, sdf_sphere);\n\n    \n    // With object constraint, only give the distance to the selected object.\n    if (objConstraint > -1) {\n        d = MAX_DIST;\n        if      (objConstraint == 1) d = min(d, sdf_capsule1);\n        else if (objConstraint == 2) d = min(d, sdf_capsule2);\n        else if (objConstraint == 3) d = min(d, sdf_capsule3);\n        else if (objConstraint == 4) d = min(d, sdf_capsule4);\n        else if (objConstraint == 5) d = min(d, sdf_sphere);\n        else if (objConstraint == 6) d = min(d, sdf_capsule5);\n        else if (objConstraint == 7) d = min(d, sdf_capsule6);\n    }\n    \n    objIndex = objIndexDist;\n    return d;\n    //return vec2(d, float(objIndexDist));\n}\n\n\n// Ray march / sphere trace. Walk in ray direction, but the distance of the closest object.\n//  Guarantees to not oveshoot the second closest object.\n// Returns: distance to first hit object, hit object index, iterations\nvoid RayMarch(vec3 ro, vec3 rd, \n              out float dO, out int objIndex, out int iterations) {\n\t\n    // Distance from origin start 0 each loop\n    dO = 0.0;\n    float dS;\n    vec2 distResult;\n    int i;\n    for ( i=0; i<MAX_STEPS; i++ ) {\n        // Point marches along ray direction.\n        vec3 p = ro + dO*rd;\n        \n        // Check if the point is so close to a surface that it's a hit.\n        // GetDist returns (distance, object index)\n        dS = GetDist(p, objIndex, -1);\n        //dS = distResult.x;\n        \n        // March the length of closest distance, but in ray direction.\n        dO += dS; \n        \n        // Exit loop if hit object or too long distance.\n        if (abs(dS) < SURF_DIST || dO > MAX_DIST) {\n        \tbreak;\n        } \n    }\n    \n    //Outputs\n    //dO\n    //objIndex\n    iterations = i;\n    return;\n    //return; vec3(dO, float(objIndex), float(i));\n    //return vec3(dO, float(distResult.y), float(i));\t// Always return distance for when loop was exited.\n    // Return nbr of iterations for glow effect. Iteratons increase for rays passing close to objects. \n}\n\n\n// Approximate normal calculation. Uses GetDist to \"find\" the actual object.\n//  Needs p on object for relevant result.\n// The approximate surface of different objects is used if they are close.\n// Approxmation of normal can be constrained to surface of the object found at point p.\nvec3 GetNormal(vec3 p, bool useObjConstraint) {\n    int objConstraint;\n    int dummy;\n    float d =  GetDist(p, objConstraint, -1);\t// Since p is passed here, the distance to p is likely known.\n\tvec2 eps = vec2(0.01 ,0);\n    \n    if (!useObjConstraint) objConstraint = -1;\n    \n    // Get tangent plane\n    float xd =  GetDist(p + eps.xyy, dummy, objConstraint);\n    \n    float yd = GetDist(p + eps.yxy, dummy, objConstraint);\n    \n    float zd = GetDist(p + eps.yyx, dummy, objConstraint);\n    \n    // Normal?? Detta är väl planet?\n    // Det är normalen. Färglägger man blir planet grönt, dvs y = 1.\n    return normalize( vec3(xd, yd, zd) - d );\n}\n\n\n// Get the material properties for the selected object.\nMaterial GetMaterial(int objIndex) {\n    Material material;\n    \n    // Material constants\n    material.ambFac = 0.2;\n    material.diffFac = 1.0;\n    material.specFac = 1.0;\n    material.shininess = 4.0;\n    \n    // Material colors\n    material.ambCol = vec3(0);\t\t\t\t// Init to 0 if no object found for debug.\n    material.specCol = vec3(1, 1, 0.6);\n\n    if (objIndex == 1) { \n        material.diffCol = vec3(1, 0, 0);\n        material.specFac = 3.;\n\t    material.shininess = 4.;\n    }\n    else if (objIndex == 2) { \n        material.diffCol = vec3(0, 1, 0);\n        material.specFac = 3.;\n\t    material.shininess = 8.;\n    }\n    else if (objIndex == 3) {\n\t\tmaterial.diffCol = vec3(0, 0, 1);\n        material.specFac = 3.;\n\t    material.shininess = 16.;\n    }\n    else if (objIndex == 4) {\n        material.diffCol = vec3(1, 0, 1);\n        material.specFac = 3.;\n\t    material.shininess = 32.;\n    }\n    else if (objIndex == 5) {\t// Sphere\n        material.diffCol = vec3(1, 1, 1);\n        material.specFac = 3.;\n\t    material.shininess = 8.;\n    }\n    else if (objIndex == 6) {\n        material.diffCol = vec3(1, 1, 0);\n        material.specFac = 3.;\n\t    material.shininess = 32.;\n    }\n    else if (objIndex == 7) {\n        material.diffCol = vec3(0, 1, 1);\n        material.specFac = 3.;\n\t    material.shininess = 32.;\n    }\n    \n    material.ambCol = material.diffCol;\t\t// Make the same. \n    \n    if (BLINN) {\n    \tmaterial.shininess *= 3.5;\t// For BlinnPhong compared to Phong.\n    }\n    return material;\n}\n\n\nvec3 BlinnPhong(vec3 p, int objIndex, vec3 ro) {\n    vec3 v_N = GetNormal(p, true);\t\t// Normal\n\n    // Define light sources ///////////////////////////////\n    // Point light\n    lights[0].ambCol = vec3(1);\n    lights[0].diffCol = vec3(1);\n    lights[0].specCol = vec3(1);\n    lights[0].ambFac = 0.4;\n    lights[0].diffFac = 1.0;\n    lights[0].specFac = 1.0;\n    lights[0].power = 2500.0 / float(NBR_LIGHT);\n    lights[0].falloffQuadFac = 12.56637;\n\n    lights[0].pos = vec3(10.0, 25, -5);\n    lights[0].dist = length(lights[0].pos - p);\n\tlights[0].powerAtt = lights[0].power/(lights[0].falloffQuadFac*pow(lights[0].dist, 2.0));\n    \n    \n    lights[1] = lights[0];\n\tlights[1].pos = vec3(-8, 15, 4);\n    lights[1].dist = length(lights[1].pos - p);\n\n    lights[2] = lights[0];\n\tlights[2].pos = vec3(0, 15, 20);\n    lights[2].dist = length(lights[2].pos - p);\n    \n    // Ambient should probably be treated outside lights. An approximated value anyway.\n    for (int i = 0; i < NBR_LIGHT; i++) {\n    \tlights[i].ambFac /= float(NBR_LIGHT);\n    }\n\n    \n    // Get material properties ////////////////////////////\n    Material material = GetMaterial(objIndex);\n    ///////////////////////////////////////////////////////\n    \n    \n    // Calculate contribution of all light sources ////////\n    // But not material colors.\n    vec3 ambientSum = vec3(0);\t\t// Combined contribution from all lights.\n    vec3 diffuseSum = vec3(0);\t\t// Combined contribution from all lights.\n    vec3 specularSum = vec3(0);\t// Combined contribution from all lights.\n    for (int i = 0; i < NBR_LIGHT; i++) {\n        Light light = lights[i];\n\n        // Vectors ////////////////////////////////////////////\n        vec3 v_L = normalize(light.pos - p);     // From point to light (depends on type of light).\n        vec3 v_R = reflect(-v_L, v_N);  \t// Reflected light in normal\n        vec3 v_V = normalize( ro - p );\t\t// View direction\n        vec3 v_H = normalize(v_L + v_V); \t// Halfway direction - Blinn.\n\n        float dotLN = dot(v_N, v_L);\n        ///////////////////////////////////////////////////////\n\n        // Ambient\n        vec3 ambient = light.ambCol * light.ambFac * material.ambFac;\n\n        // Diffuse \n        float diff = max(dotLN, 0.0);\n        vec3 diffuse = diff * light.powerAtt * light.diffCol * light.diffFac * material.diffFac;\n\n        // Specular\n        float spec;\n        spec = pow(max(dot(v_V, v_R), 0.0), material.shininess);\t// Phong\n        if (BLINN) {\n            spec = pow(max(dot(v_N, v_H), 0.0), material.shininess);\t// Blinn\n        }\n        vec3 specular = spec * light.powerAtt * light.specCol * light.specFac * material.specFac;\n        \n        \n        // Additional shading. Not Blinn or Phong.\n        // Add ambient occlusion where dot L N is -1, and the diffuse part is already 0.\n        // This will make the core shadow darker. Sort of the same as adding diffuse light\n        //  all the way round.\n        // Material parameter?\n        // An opposite would also be interesting - to lead the diffuse light further around,\n        //  as if the material conducts light on the surface.\n        float M_da = 0.7;\t// Reduction of ambient light in the shadow. 1 = no reduction.\n        ambient *= M_da * (1.0 + clamp(dotLN, -1.0, 0.0));\n        \n        \n        // Add more shadows if no path to light source from point p.  //////////\n        // This causes extra ray march. Approximation.\n        // Go from point towards light. If hit an object first - no light path.\n        //  But start a little bit above the surface of p.\n        // Must shadow a point by its own object or else a strange gradient comes.\n        float dShadowObject;\n        int dummy_iterations;\n        int shadowindex;\n        const float SHADOW_FO = 2.5;\t// Falloff\n        RayMarch(p + 3.0*SURF_DIST*v_N, v_L, \n                 dShadowObject, shadowindex, dummy_iterations);\n        bool inShade = dShadowObject < light.dist + SURF_DIST;\n        bool selfShade = inShade && shadowindex == objIndex;\n        if (inShade) {\n            // Point is affected by shadow.\n            float sf = clamp(M_da*dShadowObject/SHADOW_FO, 0.0, 1.0);\n            sf = pow(sf, 2.0);\n            diffuse *= sf;\n            specular *= pow(sf, 1.1);\n        }\n        //if (selfShade) { I_ambient = vec3(1); I_diffuse = vec3(1); } // Debug\n        //if (inShade && !selfShade) { I_ambient = vec3(0); I_diffuse = vec3(0); } // Debug\n        ////////////////////////////////////////////////\n        \n        // Totalize contribution of this light\n        ambientSum += ambient;\n        diffuseSum += diffuse;\n        specularSum += specular;\n    }\n    ///////////////////////////////////////////////////////\n    \n \n    return ambientSum * material.ambCol + \n           diffuseSum * material.diffCol + \n           specularSum * material.specCol;\n    \n}\n\n\n// Ambient occlusion affect objects close to each other.\n// It's an simplification. \n//  Don't detect the object intersect edge, but should shadow narrow angles more.\n//  Improve by using normal of the other object. How to get that?\nfloat AO(vec3 p, int objIndex) {\n    // Point p is on the surface of object[objIndex], so the distance to other objects\n    //  will be from this.\n    // But when objects intersect the distance will be wrong - it should be only distances\n    //  to visible parts. Can the GetDist / RayMarch also return p of all other distances, and\n    //  not only the p of the \"found\" object?\n    float ao, ao_sum = 0.0;\t\t\t// 0: No ao at all\n    const int NBR_RODS = 6;\n    const int sphereIndex = 5;\n    const float d_fo = 0.3;\t\t// 0..r Fall off distance\n    const float ao_max = 0.8;\t// 0..1 Maximum amount of ao \n    \n    // Make sure global distance variables are updated. XXX now it starts becoming unnecessary (costly).\n    int dummy_index;\n    GetDist(p, dummy_index, -1);\n    \n    // Point is on the sphere.\n    if (objIndex == sphereIndex) {\n        // Move the rod distances to array for iteration possibility.\n        float rd[NBR_RODS];\n        rd[0] = objectDistances[0];\n        rd[1] = objectDistances[1];\n        rd[2] = objectDistances[2];\n        rd[3] = objectDistances[3];\n        rd[4] = objectDistances[5];\n        rd[5] = objectDistances[6];\n\n        // Shadow depending on the distance to each rod.\n        for (int i = 0; i < NBR_RODS; i++) {\n            // Normalize distance between 0..1\n            float d = clamp(rd[i] / d_fo, 0.0, 1.0);\n            \n            // Calculate ao based on distance function.\n            ao = clamp(pow((1.0-d), 3.0), 0.0, 1.0);\n            //ao = 0.3*d;\n            \n            // Add to existing ao with a reduction factor.\n            ao_sum += clamp(0.75*min(ao, ao_max), 0.0, 1.0);\n        }\n    }\n    else {\n    \t// Point is on a rod.\n        // Normalize distance between 0..1\n        float d = clamp(objectDistances[4] / d_fo, 0.0, 1.0);\n\n        // Calculate ao based on distance function.\n        ao = clamp(pow((1.0-d), 3.0), 0.0, 1.0);\n        //ao = 0.3*d;\n\n        // Add to existing ao with a reduction factor. Will matter when several nearby objects\n        //  contribute to the same occlusion.\n        ao_sum += clamp(0.75*min(ao, ao_max), 0.0, 1.0); \n    }\n    \n    return 1.0 - min(ao_sum, ao_max);\n}\n\n\n// Sky color\nvec3 skyColor(vec2 uv) {\n    // 077b88 = \n    // 9dc6ca = \n\tvec3 col; \n    col = mix(vec3(0.615, 0.776, 0.792), vec3(0.027, 0.482, 0.533), 2.0*sqrt(abs(uv.y)));\n    \n    // Lighten middle, darken out. Multiply with > 1.\n    col *= mix(vec3(2), vec3(1), 2.0*pow(abs(uv.y), 0.25));\n        \n    col = pow( clamp(col,0.0,1.0), vec3(2.2) );\t// Inverse gamma bc sky color was chosen from palette.\n\treturn col;\n}\n\n// Render the point of the ray\n// returns: vec3 color, object index, object distance\nvec3 Render(vec3 ro, vec3 rd, vec2 uv,\n            out int objIndex, out float d) {\n    \n    // Ray march in direction for this uv-coordinate / screen pixel.\n    int raySteps;\n    RayMarch(ro, rd, \n             d, objIndex, raySteps);\t// Returns (distance, object index, ray iterations)\n    \n    // Light and color for the intersected point.\n    // Don't do color calculations if there was no hit.\n    vec3 col = vec3(1);\n    if (d < MAX_DIST) {\n        vec3 p = ro + d*rd;\n        col = BlinnPhong(p, objIndex, ro);\n\n        // Ambient occlusion \n        col *= AO(p, objIndex);\n\n        // Use the nbr of marched steps for glow.\n        //if (objIndex > 1) {\n        //    float stepF = float(raySteps)/float(MAX_STEPS); \n        //    difCol += (pow(stepF*10., 2.0)*1.);   \n        //}\n\n        // Do not shade the light ball\n        //if (objIndex == 5) col = vec3(1, 1, 0);\n    }\n    else {\n        // Background. Remove anything when marcher did not reach because of distance.\n        col = skyColor(uv);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Rescale x so a circle looks like a circle, and move to new center.\n    // uv.y: -0.5 .. 0.5\n    // uv.x: ( -0.5 .. 0.5 ) * aspect ratio.\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Camera ////////////////////////////////////////////////////////////\n    // Camera ray origin, ray direction, ro, rd\n    // x, y view plane and z is depth.\n    vec3 ro;\n\n    // Camera ray direction - look from origin in the direction of each screen pixel.\n    // XXX - Är det ortogonal view genom att sätta x, y, 1 alltid. Nej...\n\tvec3 rd;\n    \n    // Pixel color for what the ray hit.\n    vec3 col;\n    \n    // Camera ray origin\n    ro = vec3(0, 4, -8);\t\n\n    // Camera ray direction\n    rd = normalize( vec3(uv.x, uv.y-0.1, 1) );\n    //////////////////////////////////////////////////////////////////////\n\n    // Cast original ray\n\tvec2 uvorg = uv;\n            \n    // Render what the ray hits.\n    int objIndex;\n    float dist;\n    col = Render(ro, rd, uvorg,\n          objIndex, dist);  // Color of hit point\n    \n    \n    // Focus blur /////////////////////////////////////\n    float fact;\n    fact = 700.0;\t// Use 700 for good AA.\n\n    float range = 0.5;\n    float fp = 4.5;\n    fact =  clamp(pow(abs(dist-fp), 3.2), 20.0, 700.0);\n    ///////////////////////////////////////////////////\n    \n    \n    // Calculate distance\n    //XXXvec3 p = GetDist();\n    //float centerDist = p.z-ro.z;\t// Orthogonal distance to object from camera.\n    //if (objIndex1 == 0) centerDist = MAX_DIST;\n    \n    // Cast ray\n    // How to calculate backwards from uv into a ray direction?\n    // Seems better than to ray with small angular difference.\n\n    // Anti-aliasing - sample 4 points (or perhaps only affect when point is on object edge).\n    // 4 sample is just blur everywhere.\n    // \n    \n    // Procesing saving algorithm for at least few objects:\n    //  Cast the ray.\n    //  If ray hits an object\n    //    Cast the AA rays.\n    //    Optional:\n    //    Blur only if one or more AA ray does not hit object. Prevents pure object internal blur.\n    //\n    // Rays cast: 1 per \"normal cast\". 5 per normal cast that hits an object.\n    \n    // And AA only on \"edge between objects\" but not \"edges within the same object\"\n    //  Cast the ray\n    //  If ray hits Object obj at Point p:\n    //    Calculate a new point pp that is a small view angle in the normal direction of p\n    //     Point pp distance from p depends on camera and perspective transform.\n    //    Cast a ray towards pp\n    //      If ray does not hit obj:\n    //        Blur color of p with whatever color was found in direction of pp.\n    //\n    // Rays cast: 1 per \"normal cast\". 2 per normal cast that hits an object.\n\n    // AA 2 is 4 passes. Costs.\n    #define AA 2\n    \n    // Mouse top half - no AA\n    // Mouse lower left - fixed blur\n    // Mouse lower right - variable blur.\n    bool useAA = (iMouse.y/iResolution.y < 0.5);\n    \n    // Don't cast additional AA rays unless the first ray hit an object.\n    //useAA = useAA && objIndex > 0;\t// XXX Have to or edge can be missed. Blur avoided by not blurring if all points was on object.\n\n\tvec3 tot = vec3(0.0);\t// Summary of all render passes.\n    int m, n;\n    int samples = 0;\n    bool allPointsOnObject = true;\n    for( m=0; m<AA; m++ ) {\n        for( n=0; n<AA; n++ ) {\n            // How to calculate backwards from uv into a ray direction?\n            // Seems better than to ray with small angular difference.\n            vec2 uvorg = uv;\n            \n            // Create offset for the cast ray.\n            vec2 of = vec2(m, n) - 0.5;\n            of /= fact;\n\t\t\t\n            // Modify camera ray direction a little for each AA pass.\n            rd = normalize( rd + vec3(of.x, of.y, 0) );\n\n            // Render what the ray hits.\n            int objIndexOld = objIndex;\n            float distDummy;\n            vec3 col = Render(ro, rd, uvorg,\n                              objIndex, distDummy);  // Color of hit point\n\n \t\t\t// accumulate for AA\n            tot += col;\n            samples++;\n            allPointsOnObject = allPointsOnObject && objIndexOld == objIndex;\n  \t    }        \n    }\n    if (useAA && true) {//!allPointsOnObject) {\n    \tcol = tot / (float(samples));\n    }\n    \n    //if (dist < 7.5) col*= 0.0;\n            \n\n\n    // hdr->ldr tonemap (iniqo)\n    col = col*1.6/(1.0+col);\n    col = col*col*(3.0-2.0*col);\n\n    // Gamma\n    col = pow( clamp(col,0.0,1.0), vec3(1.0 / 2.2) );\n\n    // Output to screen\n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKcWm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2573, 2597, 2669, 2669, 2754], [2757, 2793, 2839, 2839, 2925], [2928, 2954, 2983, 2983, 3117], [3118, 3118, 3147, 3147, 3279], [3280, 3280, 3309, 3309, 3439], [3442, 3476, 3526, 3526, 3625], [3628, 3662, 3714, 3714, 4233], [4236, 4270, 4313, 4313, 4345], [4348, 4518, 4581, 4619, 10352], [10355, 10576, 10676, 10724, 11684], [11687, 11970, 12017, 12017, 12625], [12628, 12684, 12720, 12720, 14196], [14199, 14199, 14247, 14247, 19037], [19040, 19273, 19305, 19651, 21441], [21444, 21457, 21481, 21515, 21863], [21865, 21950, 22033, 22107, 22989], [22992, 22992, 23049, 23193, 27563]]}
{"id": "tdKyRc", "name": "Fractal rivers", "author": "jarble", "description": "This is based on my \"metamorphic rock texture\" fractal.", "tags": ["fractal", "river"], "likes": 8, "viewed": 288, "published": "Public API", "date": "1603405729", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float col;\n    float t = iTime*.1;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y+vec2(t,t*2.0);\n        float factor = 1.5;\n        for(int i=0;i<9;i++)\n        {\n            uv *= -factor*factor;\n            uv += sin(uv.yx/factor)/factor;\n            col += sin(uv.x-uv.y+col)+cos(uv.y-uv.x);\n        }\n    fragColor = vec4(vec3(col/5.0),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKyRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 418]]}
{"id": "tdKyRy", "name": "HexagonalTilingShader", "author": "madoodia", "description": "Hexagonal tiling\n\nsource: https://www.youtube.com/watch?v=VmrIDyYiJBA", "tags": ["glsl", "hexagon", "shader", "tiling"], "likes": 5, "viewed": 113, "published": "Public", "date": "1603170225", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float HexDist(vec2 p)\n{\n    \n    p = abs(p);\n\n    float c = dot(p, normalize(vec2(1., 1.73)));\n    c = max(c, p.x);\n    \n    return sin(c*10.+iTime);\n    //return c;\n}\n\nvec4 HexCoords(vec2 uv)\n{   \n    vec2 r = vec2(1., 1.73);\n    vec2 h = r*.5;\n    vec2 a = mod(uv, r)-h;\n    vec2 b = mod(uv-h, r)-h;\n    \n    vec2 gv;\n    if(length(a)<length(b)) gv = a; else gv = b;\n    \n    vec2 id = uv-gv;\n    float y = .5-HexDist(gv);\n    float x = 0.;\n    \n    return vec4(x, y, id.x, id.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n    vec3 color = vec3(0.);\n\n       \n    // color += sin(HexDist(uv)*10.+iTime);\n    \n    uv *= 10.;\n    \n    // vec2 a = fract(uv)-.5;\n    // vec2 b = fract(uv-.5)-.5;\n    \n    \n    // color.rg = HexCoords(uv).xy;\n    \n    vec4 hc = HexCoords(uv);\n    // float c = 1.-smoothstep(0.05, .1, hc.y*.9);\n    // float c = 1.-smoothstep(0.05, .1, hc.y*sin(hc.z*hc.y+iTime));\n    float c = 1.-smoothstep(0.1, .2, hc.y*sin(hc.z*hc.w+iTime*.5));\n    // float c = 1.-smoothstep(0.05, .1, hc.y*sin(hc.z*hc.z+iTime));\n    // float c = 1.-smoothstep(0.05, .1, hc.y*sin(hc.w*hc.z+iTime));\n    color += c;;\n    \n    fragColor = vec4(color,1.0);    \n}\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKyRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 167], [169, 169, 194, 194, 484], [486, 486, 543, 543, 1238]]}
{"id": "tdKyzW", "name": "z IFS fractal 2", "author": "illus0r", "description": "z IFS fractal", "tags": ["ifs"], "likes": 3, "viewed": 191, "published": "Public API", "date": "1602362756", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/10.;\n        for(int i=0;i<6;i++){\n            uv = normalize(uv)/length(uv);\n            uv=abs(uv);\n            uv-=.6;\n            uv=uv*rot(t/float(i+1));\n            uv*=1.5;\n        }\n        col[c]=length(uv);\n        //col[c]=fract(uv.x*.5);\n\t    col[c]=step(.5,col[c]);\n    }\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKyzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 590]]}
{"id": "tdVyzK", "name": "cells with random ids", "author": "StrangerintheQ", "description": "cells with random ids", "tags": ["cells"], "likes": 10, "viewed": 85, "published": "Public", "date": "1603279097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy/iResolution.xy-0.5;\n    uv *= 10.;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float cellId = fract(sin(dot(floor(uv), vec2(11.989, 4.1414)))*44241.1123);\n    \n    uv = fract(uv) - 0.5;\n\n    uv = abs(uv)/dot(uv, uv);\n    uv = abs(uv)/dot(uv, uv) - cellId*cellId;\n    uv = abs(uv)/dot(uv, uv);\n    uv = abs(uv)/dot(uv, uv) - cellId;\n    \n    float c,\n        s = fract(cellId+iTime/10.),\n    \td = length(uv);\n    \n    for (float dt = 0.0; dt < 1.0; dt += 0.5) {\n      float r = fract(iTime / 10. + dt+s);\n      c += smoothstep(r + 0.05, r, d);\n      r -=  0.07;\n      c -= smoothstep(r + 0.05, r, d);\n    }\n    \n    fragColor = vec4(vec3(c), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVyzK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 56, 56, 737]]}
{"id": "tdy3Wz", "name": "grid - woz", "author": "woz", "description": "grid test", "tags": ["grid"], "likes": 0, "viewed": 152, "published": "Public API", "date": "1603062520", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f(vec2 uv)\n{\n    float x = uv.x;\n    float l = length(uv - vec2(x, x * x + sin(iTime * 1.)));\n    \n    return l;\n    return min(l, length(uv - vec2(x, sin(x + iTime * 10.))));\n}\n\nfloat grid(vec2 fragCoord)\n{\n    ivec2 coord = ivec2(fragCoord);\n    coord -= ivec2(iResolution.xy) / 2;\n    return float(1 - clamp(abs(coord.x) * abs(coord.y), 0, 1));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    \n    uv *= 10.;\n\n    float d = smoothstep(.2, .1, f(uv));\n    \n    d += grid(fragCoord);\n    \n    vec3 col = vec3(d);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdy3Wz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 183], [185, 185, 213, 213, 355], [357, 357, 414, 414, 635]]}
{"id": "tdyyR3", "name": " Cells Under a Microscope - edit", "author": "mosaic", "description": "Combination of https://www.shadertoy.com/view/3sKyDw and  https://www.shadertoy.com/view/wtjfRV", "tags": ["2d", "fractal"], "likes": 2, "viewed": 54, "published": "Public", "date": "1603334601", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4  fC ( in vec2 fragCoord ) {\n    vec3 col;\n    float t = iTime*.05;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y+vec2(t+2.0);\n        //uv *= 10.0;\n        int c = 0;\n        for(int i=0;i<9;i++)\n        {\n            c = i%3;\n            float factor = 1.5;\n            vec2 uv1 = uv;\n            uv /= factor;\n            uv += uv1;\n            uv += (sin(uv.yx))/factor;\n            uv *= factor;\n            col[c] += sin(uv.x+uv.y);\n        }\n    return  vec4(col*100.0,1.0);\n}\n\n\n// Add this code to the bottom of any shader that has aliasing:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float A = 7.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    \n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n        \n\tfragColor /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyyR3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 496], [499, 563, 620, 620, 922]]}
{"id": "tdyyzc", "name": "uniform/Poisson distrib in grid", "author": "FabriceNeyret2", "description": "Generating large distrib of random points is costly at rendering, and problematic for infinite worlds.\nPer-cell generation with 1 (or N) point per cell doesn't give a Uniform distrib (i.e. Poissonian, in screen space).\nHere:Worley \"voronoï guy\" solution.", "tags": ["voronoi", "voronoi", "worley", "stars", "tuto", "pointdistribution"], "likes": 6, "viewed": 263, "published": "Public API", "date": "1603373096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DENS = 10.;                         // target average density per cell\n\n#define hash2(p)      fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) // https://www.shadertoy.com/view/llySRh\n#define lcg(p)        toFloat( p = p * 1664525u + 1013904223u )\n#define toFloat(p)  ( float(p)  / float(0xffffffffu) )\n#define toUint(p)     uint( (p) * float(0xffffffffu) )\n\n// Poisson generator via Inverse transform sampling ( for small d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat Poisson(vec2 U, float d) {          // d = target average density\n    float x = 0., p = exp(-d), s = p;\n    uint r = toUint( hash2(U+.5).x );     // seed\n    \n    for( ; lcg(r) > s && x<50. ; ) \n        s += p *= d/++x; \n        \n    return x;\n}\n    \nvoid mainImage( out vec4 O,  vec2 u )\n{\n    vec2 R = iResolution.xy,\n         M = length(iMouse.xy) < 10. ? vec2(0) : 2.*iMouse.xy/R-1.,\n         S = 4.*exp2(2.*M.x) / R.yy,\n         U = S * ( 2.*u - R ) - iTime,\n         I = floor(U), F = fract(U), P;\n    \n // O = vec4( 2.-R.y/8.*length(hash2(I)-F) ); return; // test: one single value per cell\n\n    float d = 1e5, i = 0.,\n           n = Poisson(I, DENS );         // number of dot per cell = Poisson law\n    for( ; i < n; i++ )                   // then, generates n Uniform dots in the cell\n        P = F - hash2(I+i/100.),\n        d = min(d, dot(P,P) );\n                         // dot size proportional if big or 1 pixel if small \n    O = vec4( max(0., 1. - min(R.y/8.,.5/S.x)* sqrt(d) ) );   // draw points \n    O.b += .2*mod(I.x+I.y,2.);            // show cells\n    O = sqrt(O);                          // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[378, 545, 577, 616, 796], [802, 802, 841, 841, 1677]]}
{"id": "tdyyzy", "name": "My First Torus Knot", "author": "oneshade", "description": "My first torus knot thanks to The Art of Code.", "tags": ["3d", "raymarching", "sdf", "torus", "knot"], "likes": 2, "viewed": 67, "published": "Public", "date": "1603118688", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThis shader uses an older version of my Raymarcher Template (https://www.shadertoy.com/view/3styDs)\nand I do not plan on implementing the newer features as they are not necessary.\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1300.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.1, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2000.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 500;\n\n// Signed Distance Functions (SDFs):\nfloat sdPlane(in vec3 p, in vec3 n) {\n    return dot(n, normalize(p)) * length(p);\n}\n\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    return max(abs(p.x) - 0.5 * w, max(abs(p.y) - 0.5 * h, abs(p.z) - 0.5 * d));\n}\n\nfloat sdCone(in vec3 p, in float h, in float r) {\n    return 0.0;\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    return max(abs(p.y) - 0.5 * h, length(p.xz) - r);\n}\n\nfloat sdTorus(in vec3 p, in float r1, in float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nfloat Union(in float sdf1, in float sdf2) {\n    return min(sdf1, sdf2);\n}\n\nfloat Subtraction(in float sdf1, in float sdf2) {\n    return max(sdf1, -sdf2);\n}\n\nfloat Intersection(in float sdf1, in float sdf2) {\n    return max(sdf1, sdf2);\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\nvec3 Scale(in vec3 p, in vec3 s) {\n    return p / s;\n}\n\n// Scene mapping function:\nfloat mapScene(in vec3 p) {\n    p = Rotate(p, vec3(-45.0, iTime * 20.0, 0.0));\n    vec2 p2D = vec2(length(p.xz) - 200.0, p.y);\n    float angle = atan(p.z, p.x) * 3.0;\n    float c = cos(angle);\n    float s = sin(angle);\n    p2D *= mat2( c, s,\n                -s, c);\n    p2D.y = abs(p2D.y) - 75.0;\n    return (length(p2D) - 50.0) * 0.4;\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy);\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy);\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx);\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Material calculation functions:\nvec3 calculateAmbient(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 calculateDiffuse(in vec3 p, in vec3 normal) {\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 calculateSpecular(in vec3 p, in vec3 normal) {\n    return vec3(1.0, 1.0, 1.0);\n}\n\nfloat calculateShininess(in vec3 p, in vec3 normal) {\n    return 8.0;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in vec3 ro, in vec3 rd) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ro + rd * distanceTraveled;\n        float distanceToClosest = mapScene(currentPosition);\n        if (abs(distanceToClosest) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n\n            // Illumination is calculated using the Phong illumination model.\n            vec3 materialAmbient = calculateAmbient(currentPosition, normal);\n            vec3 materialDiffuse = calculateDiffuse(currentPosition, normal);\n            vec3 materialSpecular = calculateSpecular(currentPosition, normal);\n            float materialShininess = calculateShininess(currentPosition, normal);\n\n            vec3 illuminationAmbient = materialAmbient * lightColor;\n            float lambertian = max(0.0, dot(normal, lightDirection));\n            vec3 illuminationDiffuse = lambertian * materialDiffuse * lightColor;\n            vec3 reflection = reflect(lightDirection, normal);\n            float specularAngle = max(0.0, dot(reflection, rd));\n            vec3 illuminationSpecular = pow(specularAngle, materialShininess) * materialSpecular * lightColor;\n\n            return vec4(illuminationAmbient + illuminationDiffuse + illuminationSpecular, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += distanceToClosest;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = rayMarch(rayOrigin, rayDirection);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyyzy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[773, 810, 847, 847, 894], [896, 896, 959, 959, 1042], [1044, 1044, 1093, 1093, 1111], [1113, 1113, 1166, 1166, 1222], [1224, 1224, 1276, 1276, 1332], [1334, 1334, 1373, 1373, 1401], [1403, 1451, 1494, 1494, 1524], [1526, 1526, 1575, 1575, 1606], [1608, 1608, 1658, 1658, 1688], [1690, 1710, 1748, 1748, 1768], [1770, 1770, 1805, 1805, 2416], [2418, 2418, 2452, 2452, 2472], [2474, 2501, 2528, 2528, 2838], [2840, 2889, 2922, 2922, 3252], [3254, 3289, 3339, 3339, 3373], [3375, 3375, 3425, 3425, 3459], [3461, 3461, 3512, 3512, 3546], [3548, 3548, 3601, 3601, 3619], [3621, 3642, 3681, 3681, 5164], [5166, 5199, 5254, 5254, 5574]]}
{"id": "tllBRl", "name": "Tangent Line to cosh Curve", "author": "athibaul", "description": "Experiments with 2D graphics and equations.", "tags": ["2d", "graph", "geometry", "tangent"], "likes": 3, "viewed": 94, "published": "Public", "date": "1602715452", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Construct some 2D geometry related to tangent curves,\n// catenary, gears, and square wheels.\n//\n// https://mathcurve.com/courbes2d.gb/engrenage/engrenage2.shtml\n// http://aesculier.fr/fichiersMaple/rouesdroles/rouesdroles.html\n\nvec2 uv;\n\nfloat ZeroSet(float f, float linewidth)\n{\n    vec2 grad = vec2(dFdx(f), dFdy(f));\n    float pxSize = max(length(grad), fwidth(uv.y));\n    return clamp(linewidth-abs(f)/pxSize, 0., 1.);\n}\nfloat ZeroSet(float f) { return ZeroSet(f, 2.); }\nfloat Point(vec2 x) { return ZeroSet(length(x), 5.); }\n\nfloat Segment(vec2 a, vec2 b, vec2 p)\n{\n    float h = clamp(dot(p-a,b-a) / dot(b-a,b-a), 0., 1.);\n    float d = length(p-a - h*(b-a));\n    return ZeroSet(d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Set coordinates to [-1.,1.] vertically, and a little bit more\n    // horizontally.\n    uv = fragCoord/iResolution.xy;\n    uv = uv*2.-1.;\n    uv.x *= iResolution.x/iResolution.y;\n    // Scale and pan to taste\n    uv *= 3.;\n    uv.y -= 2.;\n    \n    float fx = -cosh(uv.x);\n    // Tangent line at x0\n    float x0 = 2.*sin(iTime);\n    vec2 p0 = vec2(x0, -cosh(x0));\n    float a = -sinh(x0), b = x0*sinh(x0) - cosh(x0);\n    float tang = a*uv.x+b;\n    vec2 q;\n    q.x = x0 - tanh(x0);\n    q.y = a*q.x+b;\n    vec2 q1 = q + normalize(vec2(sinh(x0), 1.));\n    \n    vec3 col = vec3(0.95,0.94,0.9);\n    col = mix(col, vec3(0.8), ZeroSet(uv.y));\n    col = mix(col, vec3(0.), ZeroSet(fx - uv.y));\n    col = mix(col, vec3(0.1,0.8,0.1), ZeroSet(tang - uv.y));\n    col = mix(col, vec3(0.1,0.2,0.8), Segment(q, q1, uv));\n    col = mix(col, vec3(0.9,0.,0.1), Point(p0-uv));\n    col = mix(col, vec3(0.6,0.1,0.8), Point(q-uv));\n    col = mix(col, vec3(0.1,0.5,0.8), Point(q1-uv));\n\n    // Output to screen\n    fragColor.rgb = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tllBRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 241, 282, 282, 427], [428, 428, 452, 452, 477], [478, 478, 499, 499, 532], [534, 534, 573, 573, 693], [695, 695, 752, 842, 1772]]}
{"id": "tsccW2", "name": "Slimy Cogs", "author": "nobonen", "description": "Slurp.", "tags": ["psychedelic"], "likes": 1, "viewed": 44, "published": "Public", "date": "1601801921", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159;\n\nvec3 tex(vec2 uv)\n{\n\tfloat rot = atan(uv.y, uv.x) / pi + 1.0;\n\trot += sin(iTime * 0.25) * 0.2;\n\tfloat t = sin(length(uv) * 10.0 + iTime + sin(rot * pi * 10.0));\n\t#if 0\n\tt = step(t, 0.5);\n    #else // alternate the movement of the different colored cogs\n\tt = step(t, sin(iTime * 1.5) * 0.5 + 0.5);\n    #endif\n\treturn mix(vec3(.0, .4, .7), vec3(.0, .8, .8), t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - vec2(1.0);\n    uv.y /= iResolution.x / iResolution.y;\n    fragColor = vec4(tex(uv), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsccW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[27, 27, 46, 46, 388], [390, 390, 447, 447, 586]]}
{"id": "tsdyWB", "name": "You are feeling sleepy 2", "author": "itgaz", "description": "Very Very Sleepy...", "tags": ["hypnotise"], "likes": 2, "viewed": 181, "published": "Public API", "date": "1601667757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nCopyright 2020 Gareth Francis\n\nRedistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:\n\n1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\n\n2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\nOF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n*/\n\n\nvec2 rotate(vec2 v, float a, vec2 origin) {\n    v = v - origin;\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn (m * v) + origin;\n}\n\nvec2 aspectCorrect( in vec2 uv )\n{\n   vec2 p = vec2(uv.x * (iResolution.x / iResolution.y), uv.y);\n   return p;\n}\n\n// Angle between axis and coord, around center of screen\nfloat angle( vec2 origin, vec2 axis, vec2 coord ) {\n    vec2 a = normalize( axis );\n    vec2 b = normalize( origin - coord );\n    return acos( dot(a, b) );\n}\n\nvoid tunnel( out vec4 fragColor, in vec2 uv )\n{\n    uv = aspectCorrect(uv);\n    vec2 origin = aspectCorrect(vec2(0.5));\n    \n    float anglePc = angle(origin, vec2(0.0, -1.0), uv) / radians(360.0);\n    float dist = - (anglePc* 2.0) - distance(uv, origin);\n    vec4 baseColour = vec4(sin(iTime), cos(iTime * 2.0), sin(iTime * 8.0), 1.0);\n    \n    fragColor = sin((iTime * 12.0) + (dist * 32.0)) * baseColour;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // read frequency info (for le bass)\n    vec4 bassFFT1 = texture( iChannel0, vec2(0.05, 0.25) );\n    vec4 bassFFT2 = texture( iChannel0, vec2(0.10, 0.25) );\n    vec4 bassFFT3 = texture( iChannel0, vec2(0.15 , 0.25) );\n    \n    \n    // Rotate around the center\n    // uv = rotate(uv,(2.0 * /*sin*/(iTime * 0.5)) /*+ (bassFFT1.x)*/, vec2(0.0, 0.0));\n    \n\t// Mirror\n    uv = uv.x > 0.5 ? vec2(1.0 - uv.x, uv.y) : uv.xy;\n    \n    \n    // Mirror again <3\n    uv = uv.y > 0.5 ? vec2(uv.x, 1.0 - uv.y) : uv.xy;\n    \n    // Zoom/Repeat effect\n    // uv = fract(uv + /*cos(iTime / 3.0)*/ + (bassFFT2.x * bassFFT1.x * 7.0));\n    \n    vec2 uvDir = uv - vec2(0.0);\n    uv = fract((distance(uv, vec2(0.5)) + cos(iTime / 3.0) + (bassFFT2.r * bassFFT1.r)) * 2.0) * uvDir ;\n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    tunnel(fragColor, uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdyWB.jpg", "access": "shaders20k", "license": "bsd-simplified", "functions": [[0, 1275, 1318, 1318, 1433], [1435, 1435, 1469, 1469, 1548], [1550, 1607, 1658, 1658, 1764], [1766, 1766, 1813, 1813, 2175], [2177, 2177, 2234, 2284, 3216]]}
{"id": "tsGcWV", "name": "MIS scene with blue noise", "author": "koiava", "description": "white noise vs blue noise.\nScene is from my old shader : https://www.shadertoy.com/view/4sSXWt", "tags": ["motionblur", "mis", "rendering", "bluenoise", "directlight", "veach"], "likes": 29, "viewed": 1006, "published": "Public API", "date": "1603782497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Implementation of Multiple Importance Sampling technique(E.Veach 1995)\n//example shows MIS for direct light calculation\n//Idea behind technique is that every monte-carlo sampling technique has \n//variance and this variance comes from low probability of success.\n//So if you have 2 or more unbiased monte-carlo sampling techniques \n//which gives you different response on same situation you can predict \n//which of those responses contains more variance and weight them\n//correspondingly to decrease overal variance and stay unbiased.\n#define PIXEL_SAMPLES 1\n#define LIGHT_SAMPLES 1\n#define BSDF_SAMPLES 1\n#define FRAME_TIME 0.05\t//for motion blur\n//#define IMPORTANCE_SAMPLE_LIGHTS\n#define SHADOWS\n\n//light sampling technique *******************\n#define IMPORTANCE_SAMPLE_LIGHT_SOURCE\n//#define SAMPLE_LIGHT_AREA\n#define SAMPLE_LIGHT_SOLIDANGLE\n//********************************************\n\n#define SHOW_PLANES\n#define SHOW_TEXT\n\n#define GAMMA 2.2\nconst vec3 backgroundColor = vec3( 0.2 );\n\n//used macros and constants\n#define HALF_PI \t\t\t1.5707963\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.0001\n#define IN_RANGE(x,a,b)\t\t(((x) > (a)) && ((x) < (b)))\n#define EQUAL_FLT(a,b,eps)\t(abs(a-(b))<eps)\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n//********************************************\n\n\n#define MATERIAL_COUNT \t\t8\n#define BSDF_COUNT \t\t\t3\n#define BSDF_R_DIFFUSE \t\t0\n#define BSDF_R_GLOSSY \t\t1\n#define BSDF_R_LIGHT \t\t2\n\n//***********************************\n//sampling types\n#define SAMPLING_BLUE_NOISE\t\t\t0\n#define SAMPLING_WHITE_NOISE\t\t1\n#define SAMPLING_NONE\t\t\t\t2\nint samplingTechnique;\nfloat split;\n\nvoid initSamplingTechnique(float p) {\n    float k = iMouse.x/iResolution.x;\n    if(iMouse.z<0.0 /*|| iMouse.x==0.0*/) {\n      \tsplit = iResolution.x * 0.5;\n    } else {\n        split = iMouse.x;\n    }\n    \n    if(p < split-1.0) {\n        samplingTechnique = SAMPLING_WHITE_NOISE;\n    } else if(p > split+1.0) {\n        samplingTechnique = SAMPLING_BLUE_NOISE;\n    } else {\n        samplingTechnique = SAMPLING_NONE;\n    }\n}\n//***********************************\n\n#define LIGHT_COUNT (4)\n#define LIGHT_COUNT_INV (0.25)\n#define WALL_COUNT \t(2)\n\n//MIS heuristics *****************************\n#define MIS_HEURISTIC_BALANCE\n//#define MIS_HEURISTIC_POWER\n\nfloat misWeightPower( in float a, in float b ) {\n    float a2 = a*a;\n    float b2 = b*b;\n    float a2b2 = a2 + b2;\n    return a2 / a2b2;\n}\nfloat misWeightBalance( in float a, in float b ) {\n    float ab = a + b;\n    \n    return a / ab;\n}\nfloat misWeight( in float pdfA, in float pdfB ) {\n#ifdef MIS_HEURISTIC_POWER\n    return misWeightPower(pdfA,pdfB);\n#else\n    return misWeightBalance(pdfA,pdfB);\n#endif\n}\n//********************************************\n            \n// random number generator **********\n// taken from iq :)\nfloat seed;\t//seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n//***********************************\n\n// Color corversion code from: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 hsv2rgb(vec3 c) {\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n//************************************************************************************\n\n\n//////////////////////////////////////////////////////////////////////////\n// Converting PDF from Solid angle to Area\nfloat PdfWtoA( float aPdfW, float aDist2, float aCosThere ){\n    if( aDist2 < EPSILON )\n        return 0.0;\n    return aPdfW * abs(aCosThere) / aDist2;\n}\n\n// Converting PDF between from Area to Solid angle\nfloat PdfAtoW( float aPdfA, float aDist2, float aCosThere ){\n    float absCosTheta = abs(aCosThere);\n    if( absCosTheta < EPSILON )\n        return 0.0;\n    \n    return aPdfA * aDist2 / absCosTheta;\n}\n//////////////////////////////////////////////////////////////////////////\n\n// Data structures ****************** \nstruct Sphere { vec3 pos; float radius; float radiusSq; float area; };\nstruct LightSamplingRecord { vec3 w; float d; float pdf; };\nstruct Plane { vec4 abcd; };\nstruct Range { float min_; float max_; };\nstruct Material { vec3 color; float roughness_; int bsdf_; };\nstruct RaySurfaceHit { vec3 N; vec3 E; int mtl_id; int obj_id; float dist; };\nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera { mat3 rotate; vec3 pos; float fovV; };\n//***********************************\n    \n// ************ SCENE ***************\nPlane walls[WALL_COUNT];\nSphere lights[LIGHT_COUNT];\n\n#ifdef SHOW_PLANES\n#define PLANE_COUNT (3)\nPlane planes[PLANE_COUNT];\nRange planeZRanges[PLANE_COUNT];\nfloat planeHalfWidth = 2.3;\n#endif\n//***********************************\n\n// ************************  INTERSECTION FUNCTIONS **************************\nbool raySphereIntersection( Ray ray, in Sphere sph, out float t ) {\n    t = -1.0;\n\tvec3  ce = ray.origin - sph.pos;\n\tfloat b = dot( ray.dir, ce );\n\tfloat c = dot( ce, ce ) - sph.radiusSq;\n\tfloat h = b*b - c;\n    if( h > 0.0 ) {\n\t\tt = -b - sqrt(h);\n\t}\n\t\n\treturn ( t > 0.0 );\n}\n\nbool rayPlaneIntersection( Ray ray, Plane plane, out float t ){\n    float dotVN = dot( ray.dir, plane.abcd.xyz );\n   \n    if ( abs( dotVN ) < EPSILON ) {\n        return false;\n    }\n    \n\tt = -(dot( ray.origin, plane.abcd.xyz ) + plane.abcd.w)/dotVN;\n    \n    return ( t > 0.0 );\n}\n// ***************************************************************************\n\nvoid updateScene(float t) {\n    //init lights\n    t *= 4.0;\n\n    float moveSize = 0.7;\n    float a = 0.0;\n    float speed = 2.0;\n    float val;\n    \n    //1\n    val = a+t*speed;    \n    lights[0].pos = vec3( -2.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //2\n    val = a+t*speed;    \n    lights[1].pos = vec3( -1.1, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //3\n    val = a+t*speed;    \n    lights[2].pos = vec3( 0.0, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //4\n    val = a+t*speed;    \n    lights[3].pos = vec3( 1.6, 1.4, -5.0 ) + vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);\n    a += 0.4;\n}\n\nvoid initScene() {\n    //init lights\n    lights[0] = Sphere( vec3( -2.0, 1.4, -5.0 ), 0.05, 0.0025, 0.0314159 );\n\tlights[1] = Sphere( vec3( -1.1, 1.4, -5.0 ), 0.2, 0.04, 0.5026548 );\n\tlights[2] = Sphere( vec3( 0.0, 1.4, -5.0 ), 0.4, 0.16, 2.0106193 );\n\tlights[3] = Sphere( vec3( 1.6, 1.4, -5.0 ), 0.8, 0.64, 8.0424770 );\n    \n    float moveSize = 0.7;\n    float a = 0.0;\n    float speed = 2.0;\n    float val;\n    \n    //1\n    val = a+iTime*speed;    \n    lights[0].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(0)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //2\n    val = a+iTime*speed;    \n    lights[1].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(1)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //3\n    val = a+iTime*speed;    \n    lights[2].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(2)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //4\n    val = a+iTime*speed;    \n    lights[3].pos += vec3( 0.0, sin(val), cos(val) )*moveSize*(1.0-float(3)*LIGHT_COUNT_INV);\n    a += 0.4;\n    \n    //init walls\n    walls[0].abcd = vec4( normalize(vec3(0.0, 1.0, -EPSILON)), 1.0 );\n    //walls[0].abcd = vec4( 0.0, 1.0, 0.0, 1.0 );\n    walls[1].abcd = vec4( 0.0, 0.0, 1.0, 6.2 );\n    \n#ifdef SHOW_PLANES\n    //init planes\n    vec3 planeNormal = normalize( vec3( 0.0, 1.0, 1.2 ) );\n    planes[0].abcd = vec4( planeNormal, 3.8 );\n    planeZRanges[0].min_ = -5.8;\n    planeZRanges[0].max_ = -5.0;\n    \n    planeNormal = normalize( vec3( 0.0, 1.0, 0.7 ) );\n    planes[1].abcd = vec4( planeNormal, 2.8 );\n    planeZRanges[1].min_ = -4.8;\n    planeZRanges[1].max_ = -4.0;\n    \n    planeNormal = normalize( vec3( 0.0, 1.0, 0.3 ) );\n    planes[2].abcd = vec4( planeNormal, 1.8 );\n    planeZRanges[2].min_ = -3.8;\n    planeZRanges[2].max_ = -3.0;\n#endif\n}\n\n#define GET_LIGHT_SPHERE_CONST(i) lights[i]\n\n\nMaterial materialLibrary[MATERIAL_COUNT];\n\n#define INIT_MTL(i,bsdf,phongExp,colorVal) materialLibrary[i].bsdf_=bsdf; materialLibrary[i].roughness_=phongExp; materialLibrary[i].color=colorVal;\nvoid initMaterialLibrary()\n{\n    vec3 white = vec3( 1.0, 1.0, 1.0 );\n    vec3 gray = vec3( 0.8, 0.8, 0.8 );\n    \n    //walls\n    INIT_MTL( 0, BSDF_R_DIFFUSE, 0.0, white );\n\t\n    //planes\n    INIT_MTL( 1, BSDF_R_GLOSSY, 4096.0, gray );\n    INIT_MTL( 2, BSDF_R_GLOSSY, 128.0, gray );\n    INIT_MTL( 3, BSDF_R_GLOSSY, 32.0, gray );\n    \n    //lights\n    float totalIntencity = 6.0;\n    float min_x = lights[0].pos.x;\n    float max_x = lights[3].pos.x;\n    float x_range = max_x - min_x;\n    float h1 = ((lights[0].pos.x-min_x)/x_range)*0.6;\n    float h2 = ((lights[1].pos.x-min_x)/x_range)*0.6;\n    float h3 = ((lights[2].pos.x-min_x)/x_range)*0.6;\n    float h4 = ((lights[3].pos.x-min_x)/x_range)*0.6;\n    float s = 0.7;\n    float v1 = 1.0/(FOUR_PI*lights[0].radiusSq);\n    float v2 = 1.0/(FOUR_PI*lights[1].radiusSq);\n    float v3 = 1.0/(FOUR_PI*lights[2].radiusSq);\n    float v4 = 1.0/(FOUR_PI*lights[3].radiusSq);\n    \n    INIT_MTL( 4, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h1, s, v1 ) )*totalIntencity );\n    INIT_MTL( 5, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h2, s, v2 ) )*totalIntencity );\n    INIT_MTL( 6, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h3, s, v3 ) )*totalIntencity );\n    INIT_MTL( 7, BSDF_R_LIGHT, 0.0, hsv2rgb( vec3( h4, s, v4 ) )*totalIntencity );\n}\n\nMaterial getMaterialFromLibrary( int index ){\n#if __VERSION__ >= 300\n    return materialLibrary[index];\n#else\n    if(index == 0) return materialLibrary[0];\n    if(index == 1) return materialLibrary[1];\n    if(index == 2) return materialLibrary[2];\n    if(index == 3) return materialLibrary[3];\n    if(index == 4) return materialLibrary[4];\n    if(index == 5) return materialLibrary[5];\n    if(index == 6) return materialLibrary[6];\n    return materialLibrary[7];\n#endif\n}\n\nvoid getLightInfo( in int index, out Sphere sphere, out vec3 intensity ) {\n#if __VERSION__ >= 300\n    sphere = lights[index];\n#else\n    if(index == 0) { sphere = lights[0]; } else\n    if(index == 1) { sphere = lights[1]; } else\n    if(index == 2) { sphere = lights[2]; } else\n    \t\t\t   { sphere = lights[3]; }\n#endif\n    intensity = getMaterialFromLibrary(4+index).color;\n}\n\n// Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2*TWO_PI;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvoid basis(in vec3 n, out vec3 b1, out vec3 b2) {\n    float sign_ = sign(n.z);\n\tfloat a = -1.0 / (sign_ + n.z);\n\tfloat b = n.x * n.y * a;\n\tb1 = vec3(1.0 + sign_ * n.x * n.x * a, sign_ * b, -sign_ * n.x);\n\tb2 = vec3(b, sign_ + n.y * n.y * a, -n.y);\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal ) {\n    vec3 a,b;\n    basis( normal, a, b );\n\treturn localDir.x*a + localDir.y*b + localDir.z*normal;\n}\n\nvec3 sphericalToCartesian( in float rho, in float phi, in float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n//*****************************************************************************\n\n\n// BSDF functions *************************************************************\nfloat evaluateBlinn( in  vec3 N, in vec3 E, in vec3 L, in float roughness ) {\n    vec3 H = normalize(E + L);\n    float cosTheta = dot(N,H);\n    return (roughness + 2.0) / (8.0 * PI) * pow(cosTheta, roughness);\n}\n\nfloat pdfBlinn(in vec3 N, in vec3 E, in vec3 L, in float roughness ) {\n    vec3 H = normalize(E + L);\n    float cosTheta = dot(N,H);\n\tfloat normalizationFactor = (roughness + 1.0) / TWO_PI;\n    return pow( cosTheta, roughness ) * normalizationFactor / (4.0 * dot(E, H));\n}\n\nvec3 sampleBlinn( in vec3 N, in vec3 E, in float roughness, in float r1, in float r2, out float pdf ) {\n    float cosTheta = pow( r1, 1.0/( roughness ) );\n    float phi = r2*TWO_PI;\n    float theta = acos( cosTheta );\n    vec3 H = localToWorld( sphericalToCartesian( 1.0, phi, theta ), N );\n    float dotNH = dot(H,N);\n    vec3 L = reflect( E*(-1.0), H );\n    \n    pdf = pdfBlinn(N, E, L, roughness );\n    \n    return L;\n}\n\nfloat evaluateLambertian( in vec3 N, in vec3 L ) {\n    return INV_PI;\n}\n\nfloat pdfLambertian( in vec3 N, in vec3 L ) {\n    return max(.0, dot( N, L )) * INV_PI;\n}\n\nvec3 sampleLambertian( in vec3 N, in float r1, in float r2, out float pdf ){\n    vec3 L = sampleHemisphereCosWeighted( N, r1, r2 );\n    pdf = pdfLambertian(N, L);\n    return L;\n}\n//*****************************************************************************\n\n///////////////////////////////////////////////////////////////////////\nvoid initCamera( in vec3 pos, in vec3 frontDir, in vec3 upDir, in float fovV, out Camera dst ) {\n\tvec3 back = normalize( -frontDir );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    dst.rotate[0] = right;\n    dst.rotate[1] = up;\n    dst.rotate[2] = back;\n    dst.fovV = fovV;\n    dst.pos = pos;\n}\n\nRay genRay( in Camera camera, in vec2 pixel ) {\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x/iResolution.y,1.);\n\tvec2 ixy=(pixel/iResolution.xy - 0.5)*iPlaneSize;\n    \n    Ray ray;\n    ray.origin = camera.pos;\n\tray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n\n\treturn ray;\n}\n\n\nbool raySceneIntersection( \tin Ray ray,\n                          \tin float distMin,\n                          \tout RaySurfaceHit hit ) {\n    hit.obj_id = -1;\n    hit.dist = 1000.0;\n    hit.E = ray.dir*(-1.0);\n    \n    //check lights\n    for( int i1=0; i1<LIGHT_COUNT; i1++ ){\n        float dist;\n        if( raySphereIntersection( ray, lights[i1], dist ) && (dist>distMin) && ( dist < hit.dist ) ) {\n            hit.dist = dist;\n          \tvec3 hitpos = ray.origin + ray.dir*hit.dist;\n    \t\thit.N = (hitpos - lights[i1].pos)*(1.0/lights[i1].radius);\n    \t\thit.mtl_id = 4 + i1;\n            hit.obj_id = i1;\n        }\n    }\n    \n    //check walls\n    for( int i=0; i<WALL_COUNT; i++ ){\n        float dist;\n        if( rayPlaneIntersection( ray, walls[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){\n            hit.dist = dist;\n//            hit.pos = ray.origin + ray.dir*hit.dist;\n    \t\thit.N = walls[i].abcd.xyz;\n    \t\thit.mtl_id = 0;\n            hit.obj_id = LIGHT_COUNT + i;\n        }\n    }\n    \n#ifdef SHOW_PLANES\n    //check planes\n    for( int i=0; i<PLANE_COUNT; i++ ){\n        float dist;\n        if( rayPlaneIntersection( ray, planes[i], dist ) && (dist>distMin) && (dist < hit.dist ) ){\n            vec3 hitPos = ray.origin + ray.dir*dist;\n            if( (hitPos.z < planeZRanges[i].max_ ) && (hitPos.z > planeZRanges[i].min_) && (hitPos.x < planeHalfWidth ) && (hitPos.x > -planeHalfWidth ) ) {\n                hit.dist = dist;\n//                hit.pos = hitPos;\n                hit.N = planes[i].abcd.xyz;\n                hit.mtl_id = 1+i;\n                hit.obj_id = LIGHT_COUNT + WALL_COUNT + i;\n            }        \n        }\n    }\n#endif\n    \n    return ( hit.obj_id != -1 );\n}\n\nvoid sampleSphericalLight( in vec3 x, in Sphere sphere, float Xi1, float Xi2, out LightSamplingRecord sampleRec ) {\n#ifdef SAMPLE_LIGHT_AREA\n    vec3 n = randomDirection( Xi1, Xi2 );\n    vec3 p = sphere.pos + n*sphere.radius;\n    float pdfA = 1.0/sphere.area;\n    \n    vec3 Wi = p - x;\n    \n    float d2 = dot(Wi,Wi);\n    sampleRec.d = sqrt(d2);\n    sampleRec.w = Wi/sampleRec.d; \n    float cosTheta = max( 0.0, dot(n, -sampleRec.w) );\n    sampleRec.pdf = PdfAtoW( pdfA, d2, cosTheta );\n#else\n    vec3 w = sphere.pos - x;\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sphere.radiusSq ) {\n    \tfloat sin_theta_max_2 = sphere.radiusSq / dc_2;\n\t\tfloat cos_theta_max = sqrt( 1.0 - clamp( sin_theta_max_2, 0.0, 1.0 ) );\n    \tfloat cos_theta = mix( cos_theta_max, 1.0, Xi1 );\n        float sin_theta_2 = 1.0 - cos_theta*cos_theta;\n    \tfloat sin_theta = sqrt(sin_theta_2);\n        sampleRec.w = uniformDirectionWithinCone( w, TWO_PI*Xi2, sin_theta, cos_theta );\n    \tsampleRec.pdf = 1.0/( TWO_PI * (1.0 - cos_theta_max) );\n        \n        //Calculate intersection distance\n\t\t//http://ompf2.com/viewtopic.php?f=3&t=1914\n        sampleRec.d = dc*cos_theta - sqrt(sphere.radiusSq - dc_2*sin_theta_2);\n    } else {\n        sampleRec.w = randomDirection( Xi1, Xi2 );\n        sampleRec.pdf = 1.0/FOUR_PI;\n    \traySphereIntersection( Ray(x,sampleRec.w), sphere, sampleRec.d );\n    }\n#endif\n}\n\nfloat sphericalLightSamplingPdf( in vec3 x, in vec3 wi, float d, in vec3 n1, in Sphere sphere ) {\n#ifdef SAMPLE_LIGHT_SOLIDANGLE\n    float solidangle;\n    vec3 w = sphere.pos - x;\t//direction to light center\n\tfloat dc_2 = dot(w, w);\t\t//squared distance to light center\n    float dc = sqrt(dc_2);\t\t//distance to light center\n    \n    if( dc_2 > sphere.radiusSq ) {\n    \tfloat sin_theta_max_2 = clamp( sphere.radiusSq / dc_2, 0.0, 1.0);\n\t\tfloat cos_theta_max = sqrt( 1.0 - sin_theta_max_2 );\n    \tsolidangle = TWO_PI * (1.0 - cos_theta_max);\n    } else { \n    \tsolidangle = FOUR_PI;\n    }\n    \n    return 1.0/solidangle;\n#else\n    float lightPdfA = 1.0/sphere.area;\n    float cosTheta1 = max( 0.0, dot( n1, -wi ) );\n    return PdfAtoW( lightPdfA, d*d, cosTheta1 );\n#endif\n}\n\nfloat lightChoosingPdf(in vec3 x, in int lightId) {\n#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE\n    float cdf[LIGHT_COUNT];\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        float len = length(lights[i].pos - x);\n        cdf[i] = 1.0 / (len * len);\n    }\n    \n    for(int i=1; i<LIGHT_COUNT; i++) {\n        cdf[i] += cdf[i - 1];\n    }\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        cdf[i] /= cdf[LIGHT_COUNT-1];\n    }\n    \n    return cdf[lightId] - (lightId==0? 0.0 : cdf[lightId-1]);\n#else\n   \treturn 1.0/float(LIGHT_COUNT);\n#endif\n}  \t\n\nint chooseOneLight(in vec3 x, in float Xi, out float pdf) {\n#ifdef IMPORTANCE_SAMPLE_LIGHT_SOURCE\n    float cdf[LIGHT_COUNT];\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        float len = length(lights[i].pos - x);\n        cdf[i] = 1.0 / (len * len);\n    }\n    \n    for(int i=1; i<LIGHT_COUNT; i++) {\n        cdf[i] += cdf[i - 1];\n    }\n    \n    for(int i=0; i<LIGHT_COUNT; i++) {\n        cdf[i] /= cdf[LIGHT_COUNT-1];\n    }\n    \n    int id = 0;\n    for(int i=0; i<LIGHT_COUNT; i++) {\n        if(Xi < cdf[i]) {\n        \tid = i;\n            pdf = cdf[i] - (i==0? 0.0 : cdf[i-1]);\n            break;\n        }\n    }\n    \n    return id;\n#else\n   \tpdf = 1.0/float(LIGHT_COUNT);\n    return int(Xi*float(LIGHT_COUNT));\n#endif\n}\n\nvec3 sampleBSDF( in vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS, vec2 xi ) {\n    vec3 Lo = vec3( 0.0 );\n    float bsdfSamplingPdf = 1.0/float(BSDF_SAMPLES);\n    vec3 n = hit.N * vec3((dot(hit.E, hit.N) < 0.0) ? -1.0 : 1.0);\n    \n    for( int i=0; i<BSDF_SAMPLES; i++ ) {\n        //Generate direction proportional to bsdf\n        vec3 bsdfDir;\n        float bsdfPdfW;\n        float Xi1 = xi.x;//rnd();\n        float Xi2 = xi.y;//rnd();\n        float strataSize = 1.0 / float(BSDF_SAMPLES);\n        Xi2 = strataSize * (float(i) + Xi2);\n        float brdf;\n        \n        if( mtl.bsdf_ == BSDF_R_GLOSSY ) {\n            bsdfDir = sampleBlinn( n, hit.E, mtl.roughness_, Xi1, Xi2, bsdfPdfW );\n            brdf = evaluateBlinn( n, hit.E, bsdfDir, mtl.roughness_ );\n        } else {\n            bsdfDir = sampleLambertian( n, Xi1, Xi2, bsdfPdfW );\n            brdf = evaluateLambertian( n, bsdfDir );\n        }\n        \n        float dotNWi = dot( bsdfDir, n );\n\n        //Continue if sampled direction is under surface\n        if( (dotNWi > 0.0) && (bsdfPdfW > EPSILON) ){\n            //calculate light visibility\n            RaySurfaceHit newHit;\n            if( raySceneIntersection( Ray( x, bsdfDir ), EPSILON, newHit ) && (newHit.obj_id < LIGHT_COUNT) ) {\n                //Get hit light Info\n                vec3 Li;\n                Sphere lightSphere;\n                getLightInfo( newHit.obj_id, lightSphere, Li );\n\n                //Read light info\n                float weight = 1.0;\n\t\t\t\tfloat lightPdfW;\n                if ( useMIS ) {\n                    lightPdfW = sphericalLightSamplingPdf( x, bsdfDir, newHit.dist, newHit.N, lightSphere );\n                    lightPdfW *= lightChoosingPdf(x, newHit.obj_id);\n                    weight = misWeight( bsdfPdfW, lightPdfW );\n                }\n\n                Lo += brdf*dotNWi*(Li/bsdfPdfW)*weight;\n            }\n        }\n    }\n\n    return Lo*bsdfSamplingPdf;\n}     \n\nvec3 sampleLight( \tin vec3 x, in RaySurfaceHit hit, in Material mtl, in bool useMIS, vec2 xi, float sl ) {\n    vec3 Lo = vec3( 0.0 );\t//outgoing radiance\n    float lightSamplingPdf = 1.0/float(LIGHT_SAMPLES);\n   \n    for( int i=0; i<LIGHT_SAMPLES; i++ ) {\n        //select light uniformly\n        \n        float Xi = xi.x;\n        float strataSize = 1.0 / float(LIGHT_SAMPLES);\n        Xi = strataSize * (float(i) + Xi);\n        float lightPickPdf;\n        int lightId = chooseOneLight(x, sl, lightPickPdf);\n\n        //Read light info\n        vec3 Li;\t\t\t\t//incomming radiance\n        Sphere lightSphere;\n        getLightInfo( lightId, lightSphere, Li );\n        \n        float Xi1 = xi.x;//rnd();\n        float Xi2 = xi.y;//rnd();\n        LightSamplingRecord sampleRec;\n        sampleSphericalLight( x, lightSphere, Xi1, Xi2, sampleRec );\n        \n        float lightPdfW = lightPickPdf*sampleRec.pdf;\n        vec3 Wi = sampleRec.w;\n        \n        float dotNWi = dot(Wi,hit.N);\n\n        if ( (dotNWi > 0.0) && (lightPdfW > EPSILON) ) {\n            Ray shadowRay = Ray( x, Wi );\n            RaySurfaceHit newHit;\n            bool visible = true;\n#ifdef SHADOWS\n            visible = ( raySceneIntersection( shadowRay, EPSILON, newHit ) && EQUAL_FLT(newHit.dist,sampleRec.d,EPSILON) );\n#endif\n            if(visible) {\n                float brdf;\n    \t\t\tfloat brdfPdfW;\t\t\t//pdf of choosing Wi with 'bsdf sampling' technique\n                \n                if( mtl.bsdf_ == BSDF_R_GLOSSY ) {\n                    brdf = evaluateBlinn( hit.N, hit.E, Wi, mtl.roughness_ );\n                    brdfPdfW = pdfBlinn(hit.N, hit.E, Wi, mtl.roughness_ );\t//sampling Pdf matches brdf\n                } else {\n                    brdf = evaluateLambertian( hit.N, Wi );\n                    brdfPdfW = pdfLambertian( hit.N, Wi );\t//sampling Pdf matches brdf\n                }\n\n                float weight = 1.0;\n                if( useMIS ) {\n                    weight = misWeight( lightPdfW, brdfPdfW );\n                }\n                \n                Lo += ( Li * brdf * weight * dotNWi ) / lightPdfW;\n            }\n        }\n    }\n    \n    return Lo*lightSamplingPdf;\n}\n\nvec3 Radiance( in Ray ray, vec2 xi1, vec2 xi2, float sl ) {\n    RaySurfaceHit hit;\n    if( raySceneIntersection( ray, 0.0, hit ) ) {\n    \tMaterial mtl = getMaterialFromLibrary( hit.mtl_id );\n\n        vec3 f, Le;\n\n        if( mtl.bsdf_ == BSDF_R_LIGHT ) {\n            Le = mtl.color;\n            f = vec3( 1.0, 1.0, 1.0 );\n        } else {\n            Le = vec3( 0.0 );\n            f = mtl.color;\n        }\n        \n        vec3 hitPos = ray.origin + ray.dir*hit.dist;\n            \n        vec3 directLight = vec3(0.0);\n        directLight += sampleBSDF( hitPos, hit, mtl, true, xi2 );\n        directLight += sampleLight( hitPos, hit, mtl, true, xi1, sl );\n        return Le + f * directLight;\n    }\n\n    return backgroundColor;\n}\n\nvec4 bluenoise(int s, vec2 fc) {\n    vec2 blue_noise_res = iChannelResolution[0].xy;\n    vec2 tileRes = vec2(256.0, 256.0);\n\tint tilex = s % 4;\n    int tiley = s / 4;\n    \n    vec2 coord = mod(fc, tileRes);\n    \n    return texture( iChannel0, (vec2(tilex, tiley) * tileRes + coord) / blue_noise_res);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = /*iTime +*/ iResolution.y * fragCoord.x / iResolution.x + fragCoord.y / iResolution.y;\n    \n\tfloat sinTime = sin(iTime*0.2);\n    \n    Camera camera;\n    initScene();\n    initMaterialLibrary();\n    \n    vec2 splitterPos = iMouse.xy;\n    if ( splitterPos.x == 0.0 && splitterPos.y == 0.0 ) {\n        splitterPos = iResolution.xy*0.5;\n    }\n    initSamplingTechnique((iMouse.x==0.0)?iResolution.x*0.5:fragCoord.x);\n\t\n    if (samplingTechnique == SAMPLING_NONE) {\n        fragColor = vec4( 1.0 );\n    } else {\n        Ray ray;\n        vec3 accumulatedColor = vec3( 0.0 );\n        for(int si=0; si<PIXEL_SAMPLES; ++si ){\n            vec4 xi;\n            if(samplingTechnique == SAMPLING_BLUE_NOISE) {\n                xi = bluenoise(si, fragCoord);\n            } else {\n                xi = vec4(rnd(), rnd(), rnd(), rnd());\n            }\n\n            //stratified sampling for t\n            float tprev = iTime;\n            float tnext = iTime+FRAME_TIME;\n            float tStrata = 1.0/float(PIXEL_SAMPLES);\n            float tnorm = tStrata*(float(si)  + xi.w);\n            float t = mix(tprev,tnext,tnorm);\n\n\n            //for object motion blur\n            updateScene(t);\n\n            //update camera for camera motion blur\n            vec3 cameraPos = vec3( 0.0, 1.0 + sin(t*0.45), 3.0 + sin(t*0.4)*3.0 );\n            vec3 cameraTarget = vec3( sin(t*0.4)*0.3, 0.0, -5.0 );\n            initCamera( cameraPos, cameraTarget - cameraPos, vec3( 0.0, 1.0, 0.0 ), radians(45.0), camera );\n\n            vec2 subPixelCoord = vec2(rnd(), rnd());\n            vec2 screenCoord = fragCoord.xy + subPixelCoord;\n            ray = genRay( camera, screenCoord );\n\n            accumulatedColor += Radiance( ray, xi.xy, xi.xy, xi.z );\n        }\n\n        //devide to sample count\n        accumulatedColor = accumulatedColor*(1.0/float(PIXEL_SAMPLES));\n\n        //gamma correction\n        accumulatedColor = pow( accumulatedColor, vec3( 1.0 / GAMMA ) );\n\n        fragColor = vec4( accumulatedColor,1.0 );\n    }\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGcWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1579, 1762, 1799, 1799, 2185], [2382, 2413, 2461, 2461, 2551], [2552, 2552, 2602, 2602, 2650], [2651, 2651, 2700, 2700, 2820], [2881, 2978, 2991, 2991, 3034], [3074, 3161, 3183, 3183, 3352], [3442, 3560, 3620, 3620, 3713], [3715, 3766, 3826, 3826, 3966], [4829, 4908, 4975, 4975, 5183], [5185, 5185, 5248, 5248, 5466], [5467, 5547, 5574, 5592, 6374], [6376, 6376, 6394, 6412, 8141], [8381, 8381, 8409, 8409, 9633], [9635, 9635, 9680, 9680, 10106], [10108, 10108, 10182, 10182, 10481], [10483, 10565, 10643, 10643, 10751], [10753, 10753, 10843, 10843, 10993], [10995, 10995, 11044, 11044, 11244], [11246, 11246, 11301, 11301, 11401], [11403, 11403, 11476, 11476, 11584], [11586, 11586, 11661, 11661, 11804], [11806, 11806, 11858, 11858, 11986], [12069, 12149, 12226, 12226, 12360], [12362, 12362, 12432, 12432, 12634], [12636, 12636, 12739, 12739, 13058], [13060, 13060, 13110, 13110, 13131], [13133, 13133, 13178, 13178, 13222], [13224, 13224, 13300, 13300, 13402], [13484, 13556, 13652, 13652, 13890], [13892, 13892, 13939, 13939, 14192], [14195, 14195, 14332, 14332, 15899], [15901, 15901, 16016, 16016, 17398], [17400, 17400, 17497, 17497, 18171], [18173, 18173, 18224, 18224, 18708], [18713, 18713, 18772, 18772, 19436], [19438, 19438, 19532, 19532, 21376], [21383, 21383, 21489, 21489, 23548], [23550, 23550, 23609, 23609, 24279], [24281, 24281, 24313, 24313, 24583], [24585, 24585, 24642, 24642, 26647]]}
{"id": "tsGcWW", "name": "Moon Phases JLM", "author": "vtgco", "description": "test", "tags": ["test"], "likes": 5, "viewed": 71, "published": "Public", "date": "1602869390", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.2832\n\nbool ALIASED = false;\n\nfloat MOON_SIZE = 0.02;\nfloat BREATHING_ROOM = 0.01;\nfloat R_STEP;\n\nfloat ANTI_ALIAS_RADIUS;\nfloat ARC_ANTI_ALIAS_RADIUS;\n    \nfloat DISPLACEMENT_FACTOR;\n\nvoid setup() {\n    R_STEP = (MOON_SIZE + BREATHING_ROOM)*2.;\n    \n    float rel_moon_size = 0.02 / MOON_SIZE;\n    \n    ARC_ANTI_ALIAS_RADIUS = (0.05 * rel_moon_size);\n    ANTI_ALIAS_RADIUS = 1. - ARC_ANTI_ALIAS_RADIUS;\n    \n    ANTI_ALIAS_RADIUS *= MOON_SIZE;\n    \n    DISPLACEMENT_FACTOR = 0.01 / pow(rel_moon_size, 0.5);\n    \n}\n\nvec2 findClosestMoonCenter(vec2 point) {\n    \n    float r = length(point);\n    float theta = atan(point.y, point.x) + TWO_PI*float(point.y<0.);\n    \n    float new_r = (floor(r / R_STEP) + 0.5) * R_STEP;\n  \n    float THETA_STEP = TWO_PI / floor(new_r * TWO_PI / R_STEP);\n \n    float new_theta = (floor(theta / THETA_STEP) + 0.5) * THETA_STEP;\n    \n    \n    return vec2(cos(new_theta),sin(new_theta)) * new_r;\n}\n\n\n\nfloat withinMoon(vec2 point, vec2 center, float phase0) {  \n    vec2 p = point - center;\n    bool inside_circle = length(p) <= MOON_SIZE;\n    \n    if (!inside_circle) { return 0.0; }\n    \n    float phase = mod(phase0, 2.);\n    \n    bool color_on = false;\n    float brightness = 0.;\n    \n    bool on_dark_side = (p.x <= 0.) ^^ (phase >= 1.);\n    if (phase == 1.)\n    {\n        on_dark_side = true;\n    }\n    else if (phase == 0.) {\n        on_dark_side = false;\n    }\n    \n    bool crescent = abs(phase - 1.) <= 0.5;\n    \n    vec2 p_sub_arc = p;\n    p_sub_arc.x /= (0.5 - mod(phase, 1.)) * 2.;\n    \n    bool inside_arc = length(p_sub_arc) <= MOON_SIZE;\n\n    \n    if (crescent && (!on_dark_side && !inside_arc)) {\n        color_on = true;\n\t} \n\telse if (!crescent && (!on_dark_side || inside_arc)) {\n    \tcolor_on = true;\n\t}\n    \n    \n    if (color_on) {\n        float circle_brightness = smoothstep(MOON_SIZE, ANTI_ALIAS_RADIUS, length(p));\n        \n        float arc_brightness = 1.;\n        \n        if (on_dark_side ^^ crescent) \n        \tarc_brightness = smoothstep(0., ARC_ANTI_ALIAS_RADIUS, abs(length(p_sub_arc)-MOON_SIZE)/MOON_SIZE);\n        \n        brightness = min(circle_brightness, arc_brightness);\n        \n        if (ALIASED)\n            brightness = 1.;\n    }\n    \n    return brightness;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    setup();\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n     uv -= vec2(0.5, 0.5);\n    uv.x *= iResolution.x / iResolution.y;\n    \n    vec2 closest_center = findClosestMoonCenter(uv);\n    \n    float new_theta = atan(closest_center.y, closest_center.x) + TWO_PI*float(closest_center.y<0.);\n    float new_r_index = (floor(length(closest_center) / R_STEP) + 0.5);\n    \n    float phase = new_theta*2./TWO_PI + new_r_index*0.25 + iTime * 0.25;\n    \n    vec3 col = vec3(0.0);\n\n    for (int i = -1; i < 2; i++) {\n        //vec2 displacement = vec2(new_r_index * new_r_index * float(i) * 0.00005;\n        vec2 displacement = float(i) * DISPLACEMENT_FACTOR * length(closest_center) * closest_center;\n        \n    \tfloat brightness = withinMoon(uv, closest_center - displacement, phase);\n        col[int(mod(3. + float(i), 3.))] += brightness;\n   \n    }\n    fragColor = vec4(col, 1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGcWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[201, 201, 215, 215, 530], [532, 532, 572, 572, 941], [945, 945, 1002, 1002, 2249], [2251, 2251, 2308, 2308, 3243]]}
{"id": "tsGczz", "name": "Deterministic Integer Noise", "author": "pyBlob", "description": "simply functional deterministic integer noise", "tags": ["noise", "random", "deterministic"], "likes": 2, "viewed": 232, "published": "Public API", "date": "1602105422", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://www.shadertoy.com/view/llGSzw\nuint hash1(uint n)\n{\n    // integer hash copied from Hugo Elias\n\tn = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nfloat extract(uint n)\n{\n    return float(n & 0x7fffffffU)/float(0x7fffffff);\n}\n\nuint next(uint n)\n{\n    //return hash1(n); // hash != random number sequence, it will converge in less than 30 iterations\n    \n    // https://en.wikipedia.org/wiki/Linear_congruential_generator\n    return n * 134775813U + 1U; // Pascal 32-bit\n}\n\nvoid mainImage(out vec4 C, in vec2 O)\n{\n    // perturb sequence\n    uint seed = 0u;\n    seed = hash1(seed + uint(iFrame));\n    seed = hash1(seed + uint(O.x));\n    seed = hash1(seed + uint(O.y));\n\n    //for( int i=0; i<30; i++ ) seed = next(seed);\n\n    // extract value\n    float r = extract(seed);\n\n    // advance generator\n    seed = next(seed);\n\n    // profit ...\n    float g = extract(seed);\n    seed = next(seed);\n    float b = extract(seed);\n    seed = next(seed);\n\n    C = vec4(r, g, b, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGczz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 41, 61, 104, 195], [197, 197, 220, 220, 275], [277, 277, 296, 470, 521], [523, 523, 562, 586, 1023]]}
{"id": "tsGyDm", "name": "New York-Athens", "author": "teraspora", "description": ".", "tags": ["minkowski"], "likes": 1, "viewed": 191, "published": "Public API", "date": "1602974067", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// organismus - a fragment shader in GLSL, built on shadertoy.com;\n// Author: John Lynch (@teraspora);\n// Based on voronoi-2\n// Date: 9 OCT 2018.\n\n// Copyright © 2018 John Lynch\n\n// Permission is hereby granted, free of charge, to any person obtaining a copy\n// of this software and associated documentation files (the \"Software\"), to deal\n// in the Software without restriction, including without limitation the rights\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n// copies of the Software, and to permit persons to whom the Software is\n// furnished to do so, subject to the following conditions:\n\n// The above copyright notice and this permission notice shall be included in all\n// copies or substantial portions of the Software.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n// SOFTWARE.\n// -----------------------------------------------------------------------------\n\n#define PI 3.141592653588\n\n// Some useful colours:\nconst vec3 white =      vec3(1.,   1.,   1.  );\nconst vec3 crimson =      vec3(1.,   0.,   0.4  );\nconst vec3 yellow =      vec3(1.,   1.,   0.  );\nconst vec3 black =      vec3(0.,   0.,   0.  );\nconst vec3 orange = vec3(1.0, 0.4, 0.);\nconst vec3 cyan = vec3(0., 0.4, 1.0);\nconst vec3 magenta = vec3(1.0, 0., 1.0);\nconst vec3 gold = vec3(1.0, 0.84, 0.66);\n\nvec3[] cols = vec3[](white, crimson, yellow, magenta, gold, cyan, orange);\nvec3 col;\n\n// ==================================================================\n// Some functions adapted from Github - \n// https://github.com/tobspr/GLSL-Color-Spaces/blob/master/ColorSpaces.inc.glsl\n// - not tested!\n\nvec3 hue2rgb(float hue)\n{\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return clamp(vec3(R,G,B), 0., 1.);\n}\n\n// Converts a value from linear RGB to HCV (Hue, Chroma, Value)\nvec3 rgb2hcv(vec3 rgb) {\n    // Based on work by Sam Hocevar and Emil Persson\n    vec4 P = (rgb.g < rgb.b) ? vec4(rgb.bg, -1.0, 2.0/3.0) : vec4(rgb.gb, 0.0, -1.0/3.0);\n    vec4 Q = (rgb.r < P.x) ? vec4(P.xyw, rgb.r) : vec4(rgb.r, P.yzx);\n    float C = Q.x - min(Q.w, Q.y);\n    float H = abs((Q.w - Q.y) / (6. * C + 1.e-10) + Q.z);\n    return vec3(H, C, Q.x);\n}\n\n// Converts from HSL to linear RGB\nvec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n}\n\n// Converts from linear rgb to HSL\nvec3 rgb2hsl(vec3 rgb) {\n    vec3 HCV = rgb2hcv(rgb);\n    float L = HCV.z - HCV.y * 0.5;\n    float S = HCV.y / (1. - abs(L * 2. - 1.) + 1.e-10);\n    return vec3(HCV.x, S, L);\n}\n\n// My inline library of useful functions:\n// =======================================\n\nfloat arg(vec2 z) {\n    return atan(z.y, z.x);\n}\n\nvec2 polar(float r, float phi) {\n    return vec2(r * cos(phi), r * sin(phi));\n}\n\nvec2 times(vec2 v, vec2 w) {\n    return vec2(v.x * w.x - v.y * w.y, v.x * w.y + v.y * w.x);\n}\n\nvec2 rotate(vec2 v, float phi) {\n    return times(v, polar(1.0, phi)) ;\n}\n\nfloat om(float x) {\n\treturn 1. - x;\n}\n\nvec3 om(vec3 v) {\n\treturn 1. - v;\n}\n\nfloat op(float x) {\n\treturn 1. + x;\n}\n\nfloat nsin(float x) {\n\treturn op(sin(x)) * 0.5;\n}\n\nfloat ncos(float x) {\n\treturn op(cos(x)) * 0.5;\n}\n\nfloat sqrtp(float x) {\n\treturn sqrt(x < 0. ? -x : x); \n}\n\nfloat nmmod(float x, float y) {\n\tfloat xmn = 2. * mod(x, y) / y;\n    return xmn < 1. ? xmn : om(xmn);\n}\n\nvec3 omss(float mn, float mx, vec3 val) {\n\treturn om(smoothstep(mn, mx, val));\n}\n\nvec2 nmouse() {\n\treturn iMouse.xy / iResolution.xy;\n}\n\nvec3 invert(vec3 col) {\n \treturn 1. - clamp(col, 0., 1.);   \n}\n\nbool isOdd(float p) {\n    return fract(p * 0.5) >= 0.5;\n}\n\nfloat minkd(vec2 u, vec2 v, float order) {\t// Minkowski distance order 1\n    if (order <= 0.) return 0.;\t\t\t\t// i.e. Manhattan distance\n\treturn abs(pow(abs(pow(v.x - u.x, order)) + abs(pow(v.y - u.y, order)), 1. / order)); \n}\n\n\n// =======================================\n\n// rand generator from \n// https://www.youtube.com/watch?v=l-07BXzNdPw&t=740s\nvec2 r22(vec2 p) {\n\tvec3 a = fract(p.xyx * vec3(4483.34, 234.34, 345.65));\n\ta += dot(a, a - 34.45);\n    return fract(vec2(a.x * a.y, a.y * a.z));\n}\n\n\nfloat f(float x) {\n\treturn sin(cos(0.2 * iTime * x)) + cos(2. * sin(0.23 * iTime * x)) - sqrt(0.2 *abs(x) * cos(0.02 * iTime * x));\n}\n\nvec3 drawBorder(vec3 col, float b, vec3 insetColour, vec2 pp, vec2 hr, float tileIndex) {\n    // `b` is the border width\n    // `col` is the input (and output) colour\n    // `pp` is (unnormalised) coordinate of pixel\n    // `hr` is (unnormalised) resolution\n    // Make a border: `b` px solid black; with `insetColour` inset:\n    if (tileIndex != -1.) {\n    \t//  any special code for single-pane use goes here    \n    }\n    // Make a line inset:\n    if ((pp.x > b - 1. && pp.x <= b + 1.) || (pp.x > hr.x - b - 1. && pp.x < hr.x - b + 1.)) col = insetColour;\n    if ((pp.y > b - 1. && pp.y <= b + 1.) || (pp.y > hr.y - b - 1. && pp.y < hr.y - b + 1.)) col = insetColour;\n    \n    // Now put a black border on top:\n    col *= step(b, pp.x);\n    col *= step(b, pp.y);\n    col *= (1. - step(hr.x - b, pp.x));\n    col *= (1. - step(hr.y - b, pp.y));\n    return col;\n    \n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float t = iTime / 2. + 2.;\n    float numPoints = clamp(floor(t / 2.), 0., 1000.);\n    \n    //t = 1. - t;\n    float scale =  1.;0.5; // / numPoints;\n    float cut = 200.;\n    float slowness = 20.;\n    scale = iTime < cut ? 1. : (iTime > cut + slowness * 0.9 ? 0. : 1. - (1. / slowness * (iTime - cut)));\n\tfloat asp = iResolution.x/iResolution.y;\n    \n    // Normalized pixel coordinates (y from -1 to 1)\n    vec2 uv = (2. * fragCoord - iResolution.xy) / (iResolution.y * scale);\n\t//uv.y = abs(uv.y);\n    \n    uv = abs(uv);\n    uv += vec2(0.2 * sin(t / 3.), 0.3 * cos(t / 7.));\n    \n    uv = rotate(uv, iTime * 0.5);\n    // if (nmouse().x >= 0.5) uv = abs(uv);\n    \n    vec2 friz = vec2(100. * sin(t * uv.x), 100. * cos(t * uv.y));\n    vec2 vel = vec2(1., 100.);\n    \n    //uv *= vec2(om(sin(friz.x * cos(vel.x * t) * uv.x) / 7.), om(cos(friz.y * sin(vel.y * t) * uv.y) / 11.)); \n    \n    // col = crimson;\n    \n    float mind = 100.;\n    float ci;\n    \n    // generate a bunch of random points\n    for (float i = 0.; i < numPoints; i++) {\n    \tvec2 n = r22(vec2(i));\n        // sin of both components varied with time\n        vec2 p = sin(n * t);\n        // get distance to point\n        float d = minkd(uv, p, (nsin(t / 12.) * 2.1) + 0.2);\n        //m += smoothstep(.05, .01, d);\n        if (d < mind) {\n        \tmind = d;\n            ci = i;\n        }\n    }\n    \n    col = invert(vec3(mind));\n    col.b -= nsin(3. * t + length(20. * uv));\n    col.r += 0.5 * smoothstep(0., 1., col.g + col.b);\n    col.g *= nsin(t / 11. * length(uv * 12.));\n    \n    if (rgb2hcv(col).z < 0.01) col = 0.5 * cos(0.5 * t + uv.xyx / 6. + vec3(14.6, 3.8, 5.1));\n    \n    \n    fragColor = vec4(col, 1.);\n}\n\n//col = vec3(m, nsin(length(uv)), ncos(t));\n ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyDm.jpg", "access": "shaders20k", "license": "mit", "functions": [[1824, 2033, 2058, 2058, 2216], [2218, 2282, 2306, 2359, 2642], [2644, 2679, 2703, 2703, 2823], [2825, 2860, 2884, 2884, 3036], [3038, 3124, 3143, 3143, 3172], [3174, 3174, 3206, 3206, 3253], [3255, 3255, 3283, 3283, 3348], [3350, 3350, 3382, 3382, 3423], [3425, 3425, 3444, 3444, 3462], [3464, 3464, 3481, 3481, 3499], [3501, 3501, 3520, 3520, 3538], [3540, 3540, 3561, 3561, 3589], [3591, 3591, 3612, 3612, 3640], [3642, 3642, 3664, 3664, 3698], [3700, 3700, 3731, 3731, 3803], [3805, 3805, 3846, 3846, 3885], [3887, 3887, 3902, 3902, 3940], [3942, 3942, 3965, 3965, 4004], [4006, 4006, 4027, 4027, 4063], [4065, 4065, 4107, 4137, 4289], [4336, 4414, 4432, 4432, 4561], [4564, 4564, 4582, 4582, 4697], [4699, 4699, 4788, 5024, 5570], [5572, 5572, 5629, 5629, 7316]]}
{"id": "tsGyDR", "name": "Marching Squares with Meta Balls", "author": "iradicator", "description": "Visualizing marching-squares on meta-balls generated data using only the fragment shader. \nBased on ideas from Zero-Wind (Jamie Wong).\n\nFor full explanation, check out: https://iradicator.com/2d-surface-reconstruction-marching-squares-with-meta-balls", "tags": ["metaballs", "marching", "volumetric", "visualize", "marchingsquares"], "likes": 0, "viewed": 576, "published": "Public", "date": "1602653373", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Visualizing marching-squares on meta-balls generated data using only the fragment shader. \n// For full explanation, check out: https://iradicator.com/2d-surface-reconstruction-marching-squares-with-meta-balls.\n// Based on ideas from Zero-Wind: http://jamie-wong.com/2014/08/19/metaballs-and-marching-squares/\n\n#define clamp01(x) clamp((x),0.0,1.0)\n#define smoothstep01(x) smoothstep(0.0,1.0,(x))\n#define sqr(x) ((x)*(x))\n#define lerp(a,b,t) mix((a),(b),(t))\n\nfloat sqrMagnitude(in vec2 v) { return dot(v,v); }\nfloat sqrMagnitude(in vec3 v) { return dot(v,v); }\nfloat sqrMagnitude(in vec4 v) { return dot(v,v); }\n\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b)\n{\n  vec2 pa = p-a, ba = b-a;\n  float h = clamp01(dot(pa,ba)/dot(ba,ba));\n  return length(pa - ba*h);\n}\n\nfloat sceneWeight(in vec2 p, in float t)\n{    \n\tfloat aspect = iResolution.x / iResolution.y;\n    \n    vec3[17] aSpheres;\n    aSpheres[1 ] = vec3(aspect*(0.5 + 0.5*sin(2.124*t+8.164)), 0.5 + 0.5*sin(3.823*t+5.812), 2.4 / 32.0);\n    aSpheres[2 ] = vec3(aspect*(0.5 + 0.5*sin(2.878*t+1.414)), 0.5 + 0.5*cos(2.816*t+0.752), 2.0 / 32.0);\n    aSpheres[3 ] = vec3(aspect*(0.5 + 0.5*cos(0.818*t+4.142)), 0.5 + 0.5*sin(1.183*t+4.127), 4.1 / 32.0);\n    aSpheres[4 ] = vec3(aspect*(0.5 + 0.5*sin(5.123*t+8.214)), 0.5 + 0.5*sin(6.182*t+5.612), 5.6 / 32.0);\n    aSpheres[5 ] = vec3(aspect*(0.5 + 0.5*sin(5.123*t+1.814)), 0.5 + 0.5*cos(3.182*t+8.834), 0.5 / 32.0);\n    aSpheres[6 ] = vec3(aspect*(0.5 + 0.5*sin(8.179*t+8.174)), 0.5 + 0.5*sin(6.182*t+3.178), 2.3 / 32.0);\n    aSpheres[7 ] = vec3(aspect*(0.5 + 0.5*sin(2.812*t+7.214)), 0.5 + 0.5*sin(8.182*t+6.714), 0.3 / 32.0);\n    aSpheres[8 ] = vec3(aspect*(0.5 + 0.5*cos(5.902*t+9.123)), 0.5 + 0.5*sin(2.232*t+2.873), 3.4 / 32.0);\n    aSpheres[9 ] = vec3(aspect*(0.5 + 0.5*sin(3.173*t+9.124)), 0.5 + 0.5*cos(6.743*t+8.238), 1.0 / 32.0); \n    aSpheres[10] = vec3(aspect*(0.5 + 0.5*sin(8.145*t+8.145)), 0.5 + 0.5*sin(5.743*t+8.475), 4.2 / 32.0); \n    aSpheres[11] = vec3(aspect*(0.5 + 0.5*sin(1.723*t+3.134)), 0.5 + 0.5*sin(4.127*t+1.456), 1.9 / 32.0); \n    aSpheres[12] = vec3(aspect*(0.5 + 0.5*cos(5.823*t+1.824)), 0.5 + 0.5*cos(7.151*t+5.235), 3.8 / 32.0); \n    aSpheres[13] = vec3(aspect*(0.5 + 0.5*sin(5.823*t+1.235)), 0.5 + 0.5*sin(3.131*t+2.327), 4.2 / 32.0); \n    aSpheres[14] = vec3(aspect*(0.5 + 0.5*sin(9.823*t+8.153)), 0.5 + 0.5*cos(5.912*t+4.235), 2.5 / 32.0); \n    aSpheres[15] = vec3(aspect*(0.5 + 0.5*cos(1.742*t+8.193)), 0.5 + 0.5*sin(3.874*t+4.121), 1.8 / 32.0); \n    aSpheres[16] = vec3(aspect*(0.5 + 0.5*sin(9.187*t+1.792)), 0.5 + 0.5*cos(1.894*t+1.247), 3.3 / 32.0); \n\n    float w = 0.0;\n    for (int k = 0; k < aSpheres.length(); ++k)\n\t\tw += sqr(aSpheres[k].z) / sqrMagnitude(p - aSpheres[k].xy);                \n    return w;\n}\n\nfloat marchsquares(\n    in float alpha, in float isovalue, in vec2 gridSize, \n    in vec2 uv, in vec2 uv00, in int code, \n    in float w00, in float w10, in float w11, in float w01\n)\n{    \n  const float thick = 0.0018;\n    \n  vec2 px0 = lerp(vec2(0.0,0.0), vec2(1.0,0.0), (isovalue - w00) / (w10 - w00));\n  px0 = lerp(vec2(0.5,0.0),px0,alpha);\n  px0 = uv00 + px0 / vec2(gridSize);\n  \n  vec2 px1 = lerp(vec2(0.0,1.0), vec2(1.0,1.0), (isovalue - w01) / (w11 - w01));\n  px1 = lerp(vec2(0.5,1.0),px1,alpha);\n  px1 = uv00 + px1 / vec2(gridSize);\n  \n  vec2 p0y = lerp(vec2(0.0,0.0), vec2(0.0,1.0), (isovalue - w00) / (w01 - w00));\n  p0y = lerp(vec2(0.0,0.5),p0y,alpha);\n  p0y = uv00 + p0y / vec2(gridSize);\n  \n  vec2 p1y = lerp(vec2(1.0,0.0), vec2(1.0,1.0), (isovalue - w10) / (w11 - w10));\n  p1y = lerp(vec2(1.0,0.5),p1y,alpha);\n  p1y = uv00 + p1y / vec2(gridSize);\n    \n  switch(code)\n  {\n    case 0:\n    {\n      return 0.0;\n    } break;\n    case 1:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, px0));\n    } break;\n    case 2:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px0, p1y));\n    } break;\n    case 3:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, p1y));\n    } break;\n    case 4:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px1, p1y));\n    } break;\n    case 5:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px0, p1y))\n           + smoothstep(thick,0.0,sdSegment(uv, p0y, px1));\n    } break;\n    case 6:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px0, px1));\n    } break;\n    case 7:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, px1));\n    } break;\n    case 8:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, px1));\n    } break;\n    case 9:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px0, px1));\n    } break;\n    case 10:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px1, p1y))\n           + smoothstep(thick,0.0,sdSegment(uv, p0y, px0));\n    } break;\n    case 11:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px1, p1y));\n    } break;\n    case 12:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, p1y));\n    } break;\n    case 13:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, px0, p1y));\n    } break;\n    case 14:\n    {\n      return smoothstep(thick,0.0,sdSegment(uv, p0y, px0));\n    } break;\n    case 15:\n    {\n      return 0.0;\n    } break;\n  }\n}\n\nfloat isosurface(\n    in float isovalue, in float t, in vec2 gridSize, \n    in vec2 uv, in vec2 uv00, \n    in float w00, in float w10, in float w11, in float w01\n)\n{\n  int code = 15;\n  if (w00 < isovalue) code -= 1;\n  if (w10 < isovalue) code -= 2;\n  if (w01 < isovalue) code -= 8;\n  if (w11 < isovalue) code -= 4;\n  return marchsquares(t, isovalue, gridSize, uv, uv00, code, w00, w10, w11, w01);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n\tconst float kisovalue = 1.0;\n    \n    float timer = 76.0 * fract(iTime / 76.0);\n    float sceneTimer = iTime / 15.6;    \n\n    vec2 gridSize = vec2(lerp(8.0,128.0,smoothstep01(step(27.0,timer)*(timer-27.0)/(32.0-27.0))));\n\n    float aspect = iResolution.x / iResolution.y;\n    vec2 uv = fragCoord/iResolution.xy;        \n    uv.x *= aspect;\n\n    vec2 uvc  = floor(vec2(gridSize) * uv + vec2(0.5,0.5)) / vec2(gridSize);\n  \tvec2 uv00 = floor(vec2(gridSize) * uv + vec2(0.0,0.0)) / vec2(gridSize);\n  \tvec2 uv10 = floor(vec2(gridSize) * uv + vec2(1.0,0.0)) / vec2(gridSize);\n  \tvec2 uv01 = floor(vec2(gridSize) * uv + vec2(0.0,1.0)) / vec2(gridSize);\n  \tvec2 uv11 = floor(vec2(gridSize) * uv + vec2(1.0,1.0)) / vec2(gridSize); \n  \tvec2 fuv  = fract(vec2(gridSize) * uv + vec2(0.5));\n            \n    float w   = sceneWeight(uv,   sceneTimer);\n    float wc  = sceneWeight(uvc,  sceneTimer);\n    float w00 = sceneWeight(uv00, sceneTimer);\n    float w10 = sceneWeight(uv10, sceneTimer);\n    float w01 = sceneWeight(uv01, sceneTimer);\n    float w11 = sceneWeight(uv11, sceneTimer);\n    \n  \tif (w < kisovalue) w = 0.0;\n    if (wc < kisovalue) wc = 0.0;    \n    \n  \tvec3 col = w * vec3(1.0);\n\n    float showVoxels = 0.95*(smoothstep(11.0,15.0,timer)-smoothstep(40.0,42.0,timer));\n    col = lerp(col, wc * vec3(1.0), showVoxels);\n    \n    col *= 1.0-smoothstep(0.05,0.0,abs(kisovalue-w));\n  \tcol = lerp(col, 90.0*vec3(0.03,0.01,0.8), smoothstep(0.05,0.0,abs(kisovalue-w)));\n      \n    float showGrid = smoothstep(5.0,7.0,timer-length(uv)) - smoothstep(45.0,52.0,timer+0.45*length(uv));\n    col *= lerp(1.0,smoothstep01(50.0*sqrMagnitude(fuv-vec2(0.5))),showGrid);\n  \tcol += showGrid * (1.0 - smoothstep01(50.0 * sqrMagnitude(fuv - vec2(0.5)))) * clamp01(vec3(kisovalue-w,w,0.0)) * vec3(1.0,1.0,0.0);\n\n    col = 0.06*col + vec3(0.003,0.005,0.004);\n    \n    col *= pow(clamp(0.5*(smoothstep(60.0,56.0,timer)+smoothstep(65.0,68.0,timer)),0.0005,1.0),0.92);\n    \n    float a0 = smoothstep(45.0,48.0,timer)-smoothstep(69.0,71.0,timer);\n  \tfloat a1 = smoothstep(20.0,22.0,timer)-smoothstep(73.0,76.0,timer);\n    float a2 = smoothstep(51.0,54.0,timer)-smoothstep(69.0,71.0,timer);\n    float a3 = smoothstep(50.0,54.0,timer)-smoothstep(70.0,72.0,timer);\n    \n    float isovalue0 = lerp(1.0,0.5,smoothstep(45.0,48.0,timer)-smoothstep(69.0,71.0,timer));\n    float isovalue1 = 1.0;\n    float isovalue2 = lerp(1.0,2.0,smoothstep(51.0,54.0,timer)-smoothstep(69.0,72.0,timer));\n    float isovalue3 = lerp(1.0,3.0,smoothstep(50.0,54.0,timer)-smoothstep(70.0,72.0,timer));\n    \n    float edgeInterp = smoothstep(22.0,23.0,timer) - smoothstep(25.0,26.0,timer) + smoothstep(37.0,42.0,timer);\n    float a = a0 * 0.05 * isosurface(isovalue0, edgeInterp, gridSize, uv, uv00, w00, w10, w11, w01)\n            + a1 * 0.5  * isosurface(isovalue1, edgeInterp, gridSize, uv, uv00, w00, w10, w11, w01)\n        \t+ a2 * 5.0  * isosurface(isovalue2, edgeInterp, gridSize, uv, uv00, w00, w10, w11, w01)\n        \t+ a3 * 20.0 * isosurface(isovalue3, edgeInterp, gridSize, uv, uv00, w00, w10, w11, w01)\n    ;    \n  \tvec3 edgeCol = lerp(vec3(0.0,0.9,0.88), vec3(0.8,0.9,0.0), edgeInterp);\n    col = lerp(col, edgeCol, a);\n    \n    col = col / (vec3(1.0) + col);\n    col = pow(col,vec3(1.0/2.2));    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 462, 493, 493, 512], [513, 513, 544, 544, 563], [564, 564, 595, 595, 614], [616, 616, 666, 666, 767], [769, 769, 811, 811, 2756], [2758, 2758, 2942, 2942, 5144], [5146, 5146, 5311, 5311, 5544], [5546, 5546, 5601, 5601, 8891]]}
{"id": "tsGyRD", "name": "negatives", "author": "Carandiru", "description": "comparing the interpolating functions behaviour with negative values.\n\nanyone know of a trick to avoid ZERO without conditional expressions?", "tags": ["mix", "smoothstep", "negative"], "likes": 1, "viewed": 213, "published": "Public API", "date": "1602304613", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 mixed = vec3(1,0,0);\nconst vec3 smoothed = vec3(0,0,1);\nconst vec3 avoid_zero = vec3(0.4,0.1,0.9);\n\nfloat line(float width, float offset, float magnitude) {\n    float mid = 0.5f + offset;\n    return (smoothstep(mid - width, mid - width + 0.01f, magnitude) - \n            smoothstep(mid + width, mid + width + 0.01f, magnitude));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    uv = uv * 2.0f; \t\t\t\t\t\t\t   // make it smaller\n    \n    float t0 = cos(uv.x + iTime * 0.5f);\t\t   // input = advancing x axis -1,1 w/cos \n    \n    float bn = textureLod(iChannel0, \t\t\t   // sample blue noise\n                          (uv * iResolution.xy) / iChannelResolution[0].xy, 0.0f).r;\n    \n    vec3 color = vec3(0);\n    \n    // highlight area when input is negative\n    if (bool(uint(fragCoord.x) & 5u)) {   \t\t\t// every n columns\n        color.r = step(0.0f, t0);\t\t\t\t\t// if less than zero\n        color.r *= abs(t0) + bn * (17.0f/255.0f);\t// shade with bluenoise dithering\n        color.r *= abs(fract(iTime) * 2.0f - 1.0f); // pulse w/ triangle wave\n    }\n    \n    float c0 = uv.y + mix(0.0f, 1.0f, t0);\t\t\t// input -1,1 to 0,1 w/mix\n    float c1 = uv.y + smoothstep(0.0f, 1.0f, t0);\t// input -1,1 to 0,1 w/smoothstep\n    float c2 = uv.y + mix(0.1f, 1.0f, t0);\n    \n    color += mixed * line(0.05f, 0.5f, c0);\t\t\t// red = mix\n    color += smoothed * line(0.05f, 0.5f, c1);\t\t// blue = smoothstep\n\tcolor += avoid_zero * line(0.05f, 0.5f, c2);\n    \n    color.g += mix(0.0f, 1.0f, bool(0.0f == t0));\n    \n    fragColor = color.rgbr;\n}", "image_inputs": [{"id": "XsBSR3", "previewfilepath": "/media/ap/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "channel": 0, "sampler": {"filter": "nearest", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cb49c003b454385aa9975733aff4571c62182ccdda480aaba9a8d250014f00ec.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[111, 111, 167, 167, 341], [344, 344, 401, 401, 1581]]}
{"id": "tsGyW3", "name": "CHILL MIND by Kamel Ghabte", "author": "kamelghabte", "description": "CHILL MIND BY KAMEL GHABTE", "tags": ["cineshader"], "likes": 4, "viewed": 3812, "published": "Public API", "date": "1603876358", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.9*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n} \n\nfloat map(vec3 p)\n{\n\tfloat d = 2.0;\n\tfor (int i = 0; i < 16; i++) {\n\t\tfloat fi = float(i);\n\t\tfloat time = iTime * (fract(fi * 412.531 + 0.513) - 0.5) * 2.0;\n\t\td = opSmoothUnion(\n            sdSphere(p + sin(time + fi * vec3(52.5126, 64.62744, 632.25)) * vec3(2.0, 2.0, 0.8), mix(0.5, 1.0, fract(fi * 412.531 + 0.5124))),\n\t\t\td,\n\t\t\t0.4\n\t\t);\n\t}\n\treturn d;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ) + \n                      k.yyx*map( p + k.yyx*h ) + \n                      k.yxy*map( p + k.yxy*h ) + \n                      k.xxx*map( p + k.xxx*h ) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n\tvec3 rayOri = vec3((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0) * 6.0, 3.0);\n\tvec3 rayDir = vec3(0.0, 0.0, -1.0);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tfloat dist = map(p);\n        depth += dist;\n\t\tif (dist < 1e-6) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(6.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = (0.9 + 0.5 * cos((b + iTime * 9.0) + uv.xyx * 2.0 + vec3(0,2,4))) * (0.85 + b * 0.35);\n    col *= exp( -depth * 0.15 );\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 0.5) / 2.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"MY MIND\",\n\t\"description\": \"Kamel Ghabte\",\n\t\"model\": \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 52, 52, 151], [153, 153, 188, 188, 212], [215, 215, 234, 234, 569], [571, 571, 601, 601, 883], [885, 885, 942, 942, 1660]]}
{"id": "tsGyWR", "name": "radion", "author": "manthrax", "description": "some radial fx tests for mario", "tags": ["radial"], "likes": 1, "viewed": 67, "published": "Public", "date": "1602564126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat fn(in vec2 coord){\n    float len2 = pow((dot(coord,coord)+(iTime*-.01)),2.);\n    return ((sin(len2*1000.)+1.)*.25)+.5;\n}\n\nvec2 wobble(in vec2 fc,in float amount,in float rate){\n    float r = iTime*rate;\n\treturn fc+(vec2(sin(r),cos(r))*amount);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = ((fragCoord.xy-(iResolution.xy*.5))-.5)/iResolution.x;\n    vec2 uvr = wobble(uv,0.05,1.);\n    vec2 uvg = wobble(uv,0.04,-0.85);\n    vec2 uvb = wobble(uv,0.035,0.89);\n    fragColor = vec4(fn(uvr),fn(uvg),fn(uvb),1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 25, 25, 127], [129, 129, 183, 183, 252], [254, 254, 311, 311, 543]]}
{"id": "tsGyWW", "name": "Techno Ringing / HUD+", "author": "UrbanClubProfessional", "description": "Remix of \"Tech Ring / HUD\" by yusef28", "tags": ["2d", "remix", "palette", "glitch", "ring", "tech", "weird", "polar", "hud"], "likes": 3, "viewed": 262, "published": "Public API", "date": "1602829527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(227.1,411.7)),\n              dot(st,vec2(369.5,283.3)) );\n    return -1.0 + 2.0*fract(sin(st)*53758.5453123 );\n}\n\n// Value Noise by Inigo Quilez - iq/2013\n// https://www.shadertoy.com/view/lsf3WH\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    vec2 u = f*f*(4.0-3.0*f);\n\n    return mix( mix( dot( random2(i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( random2(i + vec2(2.0,0.0) ), f - vec2(2.0,0.0) ), u.x),\n                mix( dot( random2(i + vec2(0.0,2.0) ), f - vec2(0.0,2.0) ), \n                     dot( random2(i + vec2(2.0,2.0) ), f - vec2(2.0,2.0) ), u.x), u.y);\n}\nmat2 rot(float a)\n    {\n    float cs = cos(a);\n    float si = sin(a);\n    mat2 mat = mat2(cs, si, -si, cs);\n    return mat;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 st = fragCoord.xy / iResolution.xy;\n\n\tfloat u_time = iTime;//because I was using a glsl editor that names time \"u_time\n    //vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= iResolution.x/iResolution.y;\n    st = st*3.-1.8;\n    st.x-=0.85;//not sure why I have to add this now to shift the thing but I do.\n    \n  \t\n    vec4 color;\n    //floor creates an \"id\" because floor(length(st*10)) means 0, 1, 2, 3, 4 ect id's for anything \n    //within the ranges of those numbers. 0 to 1 is on id, 3 tp 4 is one id, etc\n    st*=rot(floor(length(st*20.)));//initial rotation of each ring based on it's id\n    \n    //same thing but this time to rotate the rings in time\n    st*=rot(floor(length(st*20.))+(u_time) );\n  \tfloat a = atan(st.y, st.x)+4.14159;//add pi so it's 0 - 2pi not -pi to pi\n    \n    \n    //get length for whole circle\n    float l = length(st);\n    \n    //I end up multiplying the length by this smoothsteps for some reason\n    l*=smoothstep(0., 0.2, l)*(2.0-smoothstep( 0.9,0.9, l));\n    float i = floor(l*20.);\n    \n    \n    //then for each id, make a cell within that cell that is a bit smaller.\n    //cell has length span and angle span. cell length span is j\n    float j = fract(l*20.);\n    //cell width span is b\n    \n    //here I smoothstep the inner and outer edges of each ring to get like an outline\n    float ls =smoothstep(0.2, 0.24, j)*(2.0-smoothstep( 1.9,1.94, j));\n\n    //here I change the span of each arc based on time in noise so it's more random\n    a-=(noise(i+vec2(u_time))*2.);\n    a = smoothstep(4.1, 4.14, a);\n    \n    //I attemped to smoothstep the arcs edges \n    float b = smoothstep(.3, 0.2, a)*(2.0-smoothstep(4.0, 4.14, a));\n    \n       //here I use iq's procedural palette technique based on b and ls\n    //and modulated by time\n    vec3 cc = (0.6+0.6*sin(vec3(0.2, 0.3, 0.4)-i/3.+b*ls*sin(u_time*3.)));\n    \n    //and I top it off with a pulsating light in the middle.\n        cc+=pow(2.0-l, 5.-sin(u_time*9.))-(l/6.);\n    \n\n    \n \tfragColor = vec4(cc,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGyWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 162], [164, 246, 268, 268, 674], [675, 675, 698, 698, 800], [801, 801, 858, 858, 2870]]}
{"id": "tsKcR1", "name": "3D Structured Cloud Sampling", "author": "Rakosi", "description": "Original: https://www.shadertoy.com/view/Mt3GWs by huwb\n\nThe region is divided into 3D sampling positions that are repeated on parallel planes.\nWhen marching, the point on the closest plane is considered. This eliminates aliasing when moving / rotating.", "tags": ["volume", "clouds", "sampling", "structed"], "likes": 9, "viewed": 368, "published": "Public", "date": "1603699115", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is a modification of https://www.shadertoy.com/view/Mt3GWs by huwb\n\n// by sending rays through bevelled cube faces. \n// 4 normals are considered to cover all directions: 1 for axes, 3 for planes between axes\n\n//The noise,mapping logic and ray marching (except for choosing \"t\") are taken as-is without any modifications\n\n#define SAMPLE_COUNT 40\n#define PERIOD 1.\n#define M_PI 3.141592657\n\n// mouse toggle\nbool STRUCTURED;\n\n// cam moving in a straight line\nvec3 sundir;\n\n// LUT based 3d value noise\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    \n    vec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n    vec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n    return mix( rg.x, rg.y, f.z );\n}\n\n\nvec4 map( in vec3 p )\n{\n\tfloat d = 0.1 + .8 * sin(0.6*p.z)*sin(0.5*p.x) - p.y;\n\n    vec3 q = p;\n    float f;\n    \n    f  = 0.5000*noise( q ); q = q*2.02;\n    f += 0.2500*noise( q ); q = q*2.03;\n    f += 0.1250*noise( q ); q = q*2.01;\n    f += 0.0625*noise( q );\n    d += 2.75 * f;\n\n    d = clamp( d, 0.0, 1.0 );\n    \n    vec4 res = vec4( d );\n    \n    vec3 col = 1.15 * vec3(1.0,0.95,0.8);\n    col += vec3(1.,0.,0.) * exp2(res.x*10.-10.);\n    res.xyz = mix( col, vec3(0.7,0.7,0.7), res.x );\n    \n    return res;\n}\n\n// to share with unity hlsl\n#define float2 vec2\n#define float3 vec3\n#define fmod mod\nfloat mymax (float3 x) {return max(x.x, max(x.y, x.z));}\nfloat mymin (float3 x) {return min(x.x, min(x.y, x.z));}\n\n// compute ray march start offset and ray march step delta and blend weight for the current ray\nvec4 SetupSampling( out vec4 t, out vec4 dt, out vec4 wt, in float3 ro, in float3 rd )\n{    \n    if( !STRUCTURED )\n    {\n        dt = vec4(PERIOD);\n        t = dt;\n        wt = vec4(0.25);\n        return t;\n    }\n    \n    //Every possible direction under each normal type are orthogonal   \n    \n    //Axis planes\n    vec3 n0 = vec3(rd.x * float(abs(rd.x) > abs(rd.y)),\n              rd.y * float(abs(rd.y) > abs(rd.x)),\n              rd.z);\n    n0 = vec3(n0.xy * float(abs(n0.z) < max(abs(n0.x), abs(n0.y))),\n              n0.z  * float(abs(n0.z) > max(abs(n0.x),abs(n0.y))));\n    n0 = normalize(n0);\n    \n    vec3 n1 = float3(sign(rd.x), 0., sign( rd.z )); // XZ diagonals\n    vec3 n2 = float3(sign(rd.x), sign( rd.y ), 0.); //XY diagonals\n    vec3 n3 = float3(0., sign( rd.y ), sign( rd.z )); //YZ diagonals\n        \n    // normal lengths\n    vec4 ln = vec4(length( n0 ), length( n1 ), length( n2 ), length(n3));\n    n0 = normalize(n0);\n    n1 = normalize(n1);\n    n2 = normalize(n2);    \n    n3 = normalize(n3);\n\n    // some useful DPs\n    vec4 ndotro = vec4(dot( ro, n0 ), dot( ro, n1 ), dot(ro, n2), dot(ro, n3));\n    vec4 ndotrd = vec4(dot( rd, n0 ), dot( rd, n1 ), dot(rd, n2), dot(rd, n3));\n\n    // step size\n    // Gets smaller for planes that are orthogonal to the ray\n    // As we always take step until the next closest sample, sample size is independent for each plane type\n    vec4 period = ln * PERIOD;\n    dt = period / abs( ndotrd );\n   \n    // raymarch start offset - skips leftover bit to get from ro to first strata lines\n    t = -sign( ndotrd ) * fmod( ndotro, period ) / abs(ndotrd);\n\n    if( ndotrd.x > 0. ) t.x += dt.x;\n    if( ndotrd.y > 0. ) t.y += dt.y;\n\tif( ndotrd.z > 0. ) t.z += dt.z;\n    if( ndotrd.w > 0. ) t.w += dt.w;\n    \n    // sample weights\n    float minperiod = PERIOD;\n    \n    //This is related to maximum length between parallel lines, sqrt2 for diagonals\n    float maxperiod = sqrt(2.) * PERIOD;\n    wt = smoothstep( maxperiod, minperiod, dt / ln );\n\n    wt /= (wt.x + wt.y + wt.z + wt.w);\n    \n    return vec4(wt);\n}\n\nvec4 raymarch( in vec3 ro, in vec3 rd )\n{\n    vec4 sum = vec4(0, 0, 0, 0);\n    \n    // setup sampling - compute intersection of ray with 2 sets of planes\n    vec4 t, dt;\n    vec4 wt;\n\tSetupSampling( t, dt, wt, ro, rd );\n    \n    // fade samples at far extent\n    float f = .6; // magic number - TODO justify this\n    float endFade = f*float(SAMPLE_COUNT)*PERIOD;\n    float startFade = .8*endFade;\n    \n    for(int i=0; i<SAMPLE_COUNT; i++)\n    {\n        if( sum.a > 0.99 ) continue;\n        \n        vec3 pos;\n        float w;\n        \n        vec4 dataT = vec4(float(t.x <= t.y),\n                          float(t.y < t.x),\n                          float(t.z <= t.w),\n                          float(t.w < t.z));\n\n        dataT = vec4(dataT.xy * float(min(t.z, t.w) >= min(t.x, t.y)),\n                     dataT.zw * float(min(t.z, t.w) < min(t.x, t.y)));\n\n        pos = ro + length(t * dataT) * rd;\n        w = length(wt * dataT);\n        \n        // fade samples at far extend\n        w *= smoothstep( endFade, startFade, length(t * dataT) );\n\n        t += dataT * dt;   \n        \n        vec4 col = map( pos );\n        \n        // iqs goodness\n        float dif = clamp((col.w - map(pos+0.6*sundir).w)/0.6, 0.0, 1.0 );\n        vec3 lin = vec3(0.51, 0.53, 0.63)*1.35 + 0.55*vec3(0.85, 0.57, 0.3)*dif;\n        col.xyz *= lin;\n        \n        col.xyz *= col.xyz;\n        \n        col.a *= 0.75;\n        col.rgb *= col.a;\n\n        // integrate. doesn't account for dt yet, wip.\n        sum += col * (1.0 - sum.a) * w;\n    }\n\n    sum.xyz /= (0.001+sum.w);\n\n    return clamp( sum, 0.0, 1.0 );\n}\n\nvec3 sky( vec3 rd )\n{\n    vec3 col = vec3(0.);\n    \n    float hort = 1. - clamp(abs(rd.y), 0., 1.);\n    col += 0.5*vec3(.99,.5,.0)*exp2(hort*8.-8.);\n    col += 0.1*vec3(.5,.9,1.)*exp2(hort*3.-3.);\n    col += 0.55*vec3(.6,.6,.9);\n    \n    float sun = clamp( dot(sundir,rd), 0.0, 1.0 );\n    col += .2*vec3(1.0,0.3,0.2)*pow( sun, 2.0 );\n    col += .5*vec3(1.,.9,.9)*exp2(sun*650.-650.);\n    col += .1*vec3(1.,1.,0.1)*exp2(sun*100.-100.);\n    col += .3*vec3(1.,.7,0.)*exp2(sun*50.-50.);\n    col += .5*vec3(1.,0.3,0.05)*exp2(sun*10.-10.); \n    \n    float ax = atan(rd.y,length(rd.xz))/1.;\n    float ay = atan(rd.z,rd.x)/2.;\n    float st = texture( iChannel0, vec2(ax,ay) ).x;\n    float st2 = texture( iChannel0, .25*vec2(ax,ay) ).x;\n    st *= st2;\n    st = smoothstep(0.65,.9,st);\n    col = mix(col,col+1.8*st,clamp(1.-1.1*length(col),0.,1.));\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // click mouse to use naive raymarching\n    STRUCTURED = iMouse.z <= 0.;\n    sundir = normalize(vec3(-1.0,0.0,-1.));\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n    vec2 mo = -1.0 + 2.0*iMouse.xy / iResolution.xy;\n   \n    // camera\n    vec3 lookDir = vec3(cos(.53*iTime), cos(0.5*iTime) - 0.5 ,sin(iTime));    \n\n    vec3 camVel = vec3(-2.,0.,0.);\n\n    vec3 ro = vec3(0.0, cos(iTime) + 1.0, 0.0) + iTime*camVel;    \n\n    vec3 ta = ro + lookDir; //vec3(ro.x, ro.y, ro.z-1.);\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(0.0,1.0,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    float fov = 1.;\n    vec3 rd = normalize( fov*p.x*uu + fov*1.2*p.y*vv + 1.5*ww );\n    \n    // divide by forward component to get fixed z layout instead of fixed dist layout\n    vec3 rd_layout = rd/mix(dot(rd,ww),1.0,0.0);\n    vec4 clouds = raymarch( ro, rd );\n    \n    vec3 col = clouds.xyz;\n        \n    // sky if visible\n    if( clouds.w <= 0.99 )\n\t    col = mix( sky(rd), col, clouds.w );\n    \n\tcol = clamp(col, 0., 1.);\n    col = smoothstep(0.,1.,col);\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.12 ); //Vign\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKcR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[483, 511, 537, 537, 763], [766, 766, 789, 789, 1279], [1281, 1366, 1390, 1390, 1422], [1423, 1423, 1447, 1447, 1479], [1481, 1577, 1665, 1665, 3637], [3639, 3639, 3680, 3680, 5233], [5235, 5235, 5256, 5256, 6096], [6099, 6099, 6156, 6200, 7393]]}
{"id": "tsKyRd", "name": "CirlesInHexGrid", "author": "Arseny", "description": "Just fun", "tags": ["procedural", "2d"], "likes": 15, "viewed": 261, "published": "Public API", "date": "1603983284", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 colorA = vec3(255., 252., 167.) / 255.;\nconst vec3 colorB = vec3(117., 252., 167.) / 255.;\nconst vec3 colorC = vec3(167., 247., 255.) / 255.;\n\nconst vec3 cols[3] = vec3[3](colorA, colorB, colorC);\n\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += vec2(523.124, 244.155);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nfloat sDistToArc(vec2 uv, vec2 A, vec2 B, float d){ \n    vec2 v = B - A;\n    vec2 n = normalize(vec2(-v.y, v.x));\n    vec2 c = A + v / 2.;\n    float l = length(v) / 2.;\n    vec2 p;\n    p.x = dot(normalize(v), uv - c);\n    if (abs(d) < 1e-6){\n        return abs(p.x) > l ?\n            1e9\n            : dot(n, uv - c);\n    }\n    float h = (l * l) / 2. / d - d / 2.;\n    p.y = dot(n, uv - c) + h;\n    return (d * p.y < 0. || abs(p.x) > l) ?\n        1e9\n        : (length(p) - abs(h + d)) * sign(d);\n}\n\nfloat getD(vec2 id){\n    float d = 1./sqrt(3.) - .5,\n          k = 1.2;\n    \n#define get(op)  floor( hash12( vec2( hash12(id), op(iTime*k) ) ) * 2.)\n                 \n    return d * ( mix( get(floor), get(ceil), fract(iTime*k) ) * 2. - 1. );\n}\n\nfloat getDist(vec2 lv, vec2 A, vec2 B, vec2 id){\n    float s = sign((A - B).x + (A - B).y);\n    return sDistToArc(lv, A, B, getD(id + (A + B) / 2.) * s);\n}\n\nvec3 TriCoord(vec2 uv){\n    vec2 id;\n    const float sqrt3 = sqrt(3.);\n    vec2 v = normalize(vec2(3., sqrt3));\n    id.y = floor(uv.y / sqrt3 * 2.) * sqrt3 / 2. + sqrt3 / 4.;\n    id.x = floor(dot(uv, v) / sqrt3 * 2.) - id.y / sqrt3 + 0.5;\n    float h = sqrt3 / 6.;\n    vec2 lv = uv - id;\n    float d = sqrt(0.25 + h * h) - 0.5;\n    vec2 LC = vec2(-0.25, h / 2.);\n    vec2 RC = vec2(0.25, -h / 2.);\n    vec2 LLC = vec2(-0.75, -h / 2.);\n    vec2 RDC = vec2(0.25, -h / 2. - h * 2.);\n    vec2 RRC = vec2(0.75, h / 2.);\n    vec2 UC = vec2(-0.25, h / 2. + h * 2.);\n    float dd = abs(getDist(lv, RC, LC, id));\n    dd = min(dd, abs(getDist(lv, LC, LLC, id)));\n    dd = min(dd, abs(getDist(lv, RC, RDC, id)));\n    dd = min(dd, abs(getDist(lv, RRC, RC, id)));\n    dd = min(dd, abs(getDist(lv, UC, LC, id)));\n    dd *= 40.;\n    dd = min(dd, 1.);\n    if (getDist(lv, LC, RC, id) < 0. || getDist(lv, LLC, LC, id) < 0. || getDist(lv, RC, RDC, id) < 0.){\n        return cols[int(mod(id.x + mod(id.y, 2.), 3.))] * dd;\n    }\n    if (getDist(lv, RC, LC, id) < 0. || getDist(lv, RRC, RC, id) < 0. || getDist(lv, LC, UC, id) < 0.){\n        return cols[int(mod(id.x + mod(id.y, 2.) + 2., 3.))] * dd;\n    }\n    return cols[int(mod(id.x + mod(id.y, 2.) + 1., 3.))] * dd;\n    return vec3(dd * 20.);\n}\n\nvoid mainImage( out vec4 ans, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\t\n    ans.rgb = TriCoord(uv * 5.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKyRd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[210, 251, 273, 273, 423], [425, 425, 476, 476, 923], [925, 925, 945, 945, 1168], [1170, 1170, 1218, 1218, 1325], [1327, 1327, 1350, 1350, 2604], [2606, 2606, 2657, 2657, 2753]]}
{"id": "tsKyzw", "name": "Underground Trains", "author": "dr2", "description": "Beneath the city streets...", "tags": ["architecture", "train", "london", "station"], "likes": 17, "viewed": 288, "published": "Public API", "date": "1602515049", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Underground Trains\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Beneath the city streets... (viewpoint varies, mouseable, mouse in lower-left \n// corner for mono image)\n\n#define AA  1   // optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat Minv2 (vec2 p);\nfloat Maxv2 (vec2 p);\nfloat Maxv3 (vec3 p);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nfloat Hashfv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec4 cSize, dSize;\nvec3 ltDir, qHit, statSz;\nfloat tCur, dstFar, trnSpc, cxId, gGap, trnPos, trnUp, trnDir, tunSpc, stpWd, wThk, whlRad;\nint idObj;\nbool opDoor, colImg;\nconst int idCar = 1, idWin = 2, idWhl = 3, idTrk = 4, idTun = 5, idPlat = 6, idBase = 7,\n   idWal = 8, idCeil = 9, idStp = 10, idHrail = 11, idSup = 12, idLamp = 13;\nconst float pi = 3.1415927, sqrt2 = 1.41421;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat GObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, db, dr, dx, dy, dd, stSize;\n  dMin = dstFar;\n  p.x -= gGap * (cxId + 0.5) + trnDir * (0.5 * gGap - tunSpc);\n  q = p;\n  q.xy -= vec2 (- trnDir * 4., - trnUp - whlRad + 0.1);\n  stSize = 0.3;\n  q.z *= trnDir;\n  q.z -= stSize * floor (4. / stSize);\n  dx = abs (q.x) - stpWd;\n  dr = length (vec2 (dx, mod (q.z, stSize) - 0.5 * stSize)) - 0.03;\n  dr = max (dr, abs (q.z - 2.4) - 2.4);\n  q.yz = Rot2Cs (q.yz, vec2 (1. / sqrt2));\n  d = max (length (vec2 (dx, q.y - 0.78)) - 0.03, abs (q.z - 4.12) - 3.4);\n  DMIN (idHrail);\n  d = max (dr, abs (q.y - 0.53) - 0.26);\n  d = min (d, PrSphDf (vec3 (dx, q.y - 0.78, q.z - 7.55), 0.05));\n  DMIN (idHrail);\n  d = abs (p.y - trnUp) - 2.7;\n  q.z = (abs (mod (q.z * sqrt2, 2. * stSize) - stSize) + stSize) / sqrt2;\n  d = 0.8 * max (max (max (q.y - q.z, 0.1 - q.y), dx - 0.05), d);\n  DMIN (idStp);\n  p.z = mod (p.z - trnDir * trnPos + 0.5 * trnSpc, trnSpc) - 0.5 * trnSpc; \n  q = p;\n  db = abs (max (PrRoundBoxDf (q, vec3 (0., cSize.yz), cSize.x), - trnUp - q.y));\n  d = db - cSize.w;\n  dy = 0.5 - abs (q.y - cSize.y);\n  d = max (d, min (min (0.4 - abs (mod (q.z, 1.) - 0.5), cSize.z - abs (q.z)), dy));\n  d = max (d, - max (max (PrRoundBox2Df (q.xy, vec2 (0., cSize.x - 0.2), cSize.x - 0.3), - dy),\n     0.05 - abs (q.x)));\n  dd = max (PrRoundBox2Df (vec2 (trnDir * q.x + cSize.x, q.z), dSize.xy, dSize.z),\n     - dSize.w - q.y);\n  if (opDoor) d = max (d, - dd);\n  DMINQ (idCar);\n  d = db - 0.5 * cSize.w;\n  if (opDoor) d = max (d, - dd);\n  DMINQ (idWin);\n  d = PrCylDf (vec3 (q.x, q.y + trnUp - (2. * cSize.y - 0.1), abs (q.z) - 4. * dSize.z).xzy, 0.05,\n     2. * cSize.y - 0.1);\n  DMIN (idHrail);\n  q.xz = abs (q.xz) - vec2 (0.65, 0.75) * cSize.xz;\n  q.z = abs (q.z) - 0.6;\n  q.y -= - trnUp;\n  d = max (PrCylDf (q.yzx, whlRad, 0.08), q.y);\n  DMINQ (idWhl);\n  return dMin;\n}\n\nvoid SetTrnConf ()\n{\n  float t;\n  t = mod (8. * tCur / trnSpc + 0.5 * step (1.5, cxId), 1.);\n  trnPos = trnSpc * smoothstep (0.08, 0.92, t);\n  trnDir = 1. - 2. * mod (cxId, 2.);\n  opDoor = (0.5 - abs (t - 0.5) < 0.05);\n}\n\nfloat GObjRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float s;\n  float dHit, d, cxIdP, eps;\n  eps = 0.0001;\n  dHit = eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  cxIdP = -99.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    p = ro + dHit * rd;\n    cxId = floor (p.x / gGap);\n    if (cxId != cxIdP) {\n      cxIdP = cxId;\n      SetTrnConf ();\n    }\n    s = ((cxId + step (0., rd.x)) * gGap - p.x) / rd.x;\n    d = (cxId >= 0. && cxId <= 3.) ? GObjDf (p) : dstFar;\n    d = min (d, abs (s) + eps);\n    dHit += d;\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 GObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = GObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, dt, dx, dz;\n  dMin = dstFar;\n  p.x -= 2. * gGap;\n  q = p;\n  dx = abs (q.x) - statSz.x;\n  dz = abs (q.z) - 9.5;\n  q.x = abs (abs (q.x) - gGap) - tunSpc;\n  dt = max (PrRoundBox2Df (q.xy, vec2 (0., cSize.y), cSize.x + 0.4), - cSize.y - 1.2 - q.y);\n  d = max (abs (dt) - 0.1, statSz.z - 0.5 - abs (q.z));\n  DMIN (idTun);\n  q.y -= - trnUp - whlRad - 0.1;\n  d = PrRoundBox2Df (vec2 (abs (q.x) - 0.65 * cSize.x, q.y), vec2 (0.06, 0.1) - 0.03, 0.03);\n  DMIN (idTrk);\n  q = p;\n  d = max (max (abs (PrBox2Df (q.xz, statSz.xz + wThk)) - wThk, - dt),\n     - PrRoundBoxDf (vec3 (dx - 0.5 * wThk, q.y - 5.16, dz), vec3 (wThk, 1.56, 0.8), 0.05));\n  DMIN (idWal);\n  q.y -= statSz.y + 2.6;\n  d = max (abs (length (vec2 (mod (q.x + 0.25 * gGap, 0.5 * gGap) - 0.25 * gGap, q.y)) -\n     0.4 * gGap) - 0.1, - q.y);\n  DMIN (idCeil);\n  q = p;\n  q.y -= - trnUp - whlRad + 0.1;\n  d = max (PrBox2Df (q.yz, vec2 (0.4, 1.7 * cSize.z)), 2.8 - abs (abs (q.x) - gGap));\n  DMIN (idPlat);\n  d = abs (q.y + 0.35 + wThk) - wThk;\n  DMIN (idBase);\n  q = p;\n  q.y -= 3.58;\n  q.z = dz;\n  d = PrBoxDf (q, vec3 (statSz.x, 0.1, 0.85));\n  DMIN (idStp);\n  q = p;\n  q.y -= 4.1;\n  d = PrCylDf (vec3 (q.y - 0.4, abs (dz) - 0.82, q.x), 0.03, statSz.x);\n  d = min (d, max (PrCylDf (vec3 (mod (q.x + 0.15, 0.3) - 0.15, q.y + 0.01, abs (dz) - 0.82).xzy,\n     0.03, 0.41), dx));\n  q.x = abs (q.x + 5.7 * sign (q.z)) - gGap;\n  q.z = dz + 0.8;\n  d = max (d, - PrBox2Df (q.xz, vec2 (stpWd, 0.5)));\n  DMIN (idHrail);\n  q = p;\n  d = max (PrCylDf (vec3 (mod (q.x + 0.5 * gGap, gGap) - 0.5 * gGap, q.y - 0.8,\n     abs (dz) - 0.3).xzy, 0.07, 2.7), dx);\n  DMIN (idSup);\n  d = PrCapsDf (vec3 (dx, q.y - statSz.y - 2.5, mod (q.z + 2., 4.) - 2.), 0.25, 0.5);\n  DMIN (idLamp);\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 160; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 ShStagGrid (vec2 p, vec2 g)\n{\n  vec2 q, sq, ss;\n  q = p * g;\n  if (2. * floor (0.5 * floor (q.y)) != floor (q.y)) q.x += 0.5;\n  sq = smoothstep (0.02 * g, 0.03 * g, abs (fract (q + 0.5) - 0.5));\n  q = fract (q) - 0.5;\n  ss = 0.2 * smoothstep (0.35, 0.5, abs (q.xy)) * sign (q.xy);\n  if (abs (q.x) < abs (q.y)) ss.x = 0.;\n  else ss.y = 0.;\n  return vec3 (ss.x, sq.x * sq.y, ss.y);\n}\n\nvec4 ShStagGrid3d (vec3 p, vec3 vn, vec2 g)\n{\n  vec3 rg;\n  rg = ShStagGrid ((abs (vn.x) > 0.99) ? p.zy : ((abs (vn.y) > 0.99) ? p.zx : p.xy), g);\n  if (abs (vn.x) > 0.99) {\n    rg.xz *= sign (vn.x);\n    if (rg.x == 0.) vn.xy = Rot2D (vn.xy, rg.z);\n    else vn.xz = Rot2D (vn.xz, rg.x);\n  } else if (abs (vn.y) > 0.99) {\n    rg.xz *= sign (vn.y);\n    if (rg.x == 0.) vn.yx = Rot2D (vn.yx, rg.z);\n    else vn.yz = Rot2D (vn.yz, rg.x);\n  } else if (abs (vn.z) > 0.99) {\n    rg.xz *= sign (vn.z);\n    if (rg.x == 0.) vn.zy = Rot2D (vn.zy, rg.z);\n    else vn.zx = Rot2D (vn.zx, rg.x);\n  }\n  return vec4 (vn, rg.y);\n}\n\nfloat Truch (vec2 p)\n{\n  vec2 ip;\n  ip = floor (p);\n  p -= ip + 0.5;\n  if (Hashfv2 (ip) < 0.5) p = vec2 (- p.y, p.x);\n  return min (length (0.5 + p), length (0.5 - p));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4, rg4;\n  vec3 col, vn, ltDirL, stg;\n  vec2 vf, u;\n  float dstObj, dstObjG, nDotL, dSum, sSum, s, dx;\n  bool isMet;\n  gGap = 8.;\n  trnSpc = 210.;\n  cSize = vec4 (1., 0.7, 6., 0.06);\n  dSize = vec4 (0.1, 0.8, 0.2, 1.3 * cSize.y);\n  tunSpc = 1.7 * cSize.x;\n  whlRad = 0.5;\n  trnUp = 0.98;\n  statSz = vec3 (18., 7., 3. * cSize.z);\n  stpWd = 0.9;\n  wThk = 0.5;\n  dstObjG = GObjRay (ro, rd);\n  dstObj = ObjRay (ro, rd);\n  if (min (dstObj, dstObjG)  < dstFar) {\n    if (dstObjG < dstObj) {\n      dstObj = dstObjG;\n      ro += dstObj * rd;\n      vn = GObjNf (ro);\n    } else {\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n    }\n    dx = abs (ro.x - 2. * gGap);\n    vf = vec2 (0.);\n    stg = vec3 (0.);\n    if (idObj == idCar) {\n      col4 = vec4 (1., 0.3, 0.3, 0.1) * (0.4 + 0.6 * smoothstep (0.005, 0.01,\n         min (abs (max (PrRoundBox2Df (vec2 (abs (qHit.x) - cSize.x, qHit.z), dSize.xy, dSize.z),\n         - dSize.w - qHit.y)), max (abs (qHit.z), abs (qHit.y - 0.42 * cSize.y) - 1.72 * cSize.y))));\n      s = max (PrRoundBoxDf (qHit, vec3 (0., cSize.yz), cSize.x), - trnUp - qHit.y);\n      col4 *= 1. - 0.7 * step (abs (s), 0.6 * cSize.w);\n      if (s < 0.) {\n        col4 *= 0.5 + 0.3 * smoothstep (0.05, 0.07, abs (mod (4. * qHit.x / cSize.x, 1.) - 0.5));\n      } else {\n        u = vec2 (abs (qHit.z) - 0.6 * cSize.z, qHit.y + 0.5 * cSize.y);\n        col4 = mix (col4, vec4 (0.7, 0.1, 0.1, 0.1), step (abs (length (u) - 0.2), 0.04));\n        u = abs (u) - vec2 (0.3, 0.05);\n        col4 = mix (col4, vec4 (0.1, 0.1, 0.7, 0.1), step (max (u.x, u.y), 0.));\n        if (abs (qHit.z) < cSize.z + 0.5) col4 *= 0.7 + 0.3 * smoothstep (0.01, 0.02,\n           length (vec2 (qHit.x, mod (qHit.z + 0.5, 1.) - 0.5)) - 0.2 * cSize.x);\n        else if (length (qHit.xy - vec2 (0., - 0.5 * cSize.y)) < 0.3 * cSize.y) col4 =\n           (trnDir * sign (qHit.z) > 0.) ? vec4 (1., 1., 0.3, -1.) : vec4 (1., 0., 0., -1.);\n      }\n    } else if (idObj == idWin) {\n      col4 = vec4 (0.1, 0.1, 0.2, 0.1);\n    } else if (idObj == idWhl) {\n      col4 = vec4 (0.4, 0.4, 0.45, 0.2);\n    } else if (idObj == idTrk) {\n      col4 = vec4 (0.8, 0.8, 0.85, 0.2) * ( 1. - 0.9 * smoothstep (0., 5.,\n         max (abs (ro.z) - statSz.z, 0.)));\n      cxId = floor (ro.x / gGap);\n      SetTrnConf ();\n      u = vec2 (ro.x - gGap * (cxId + 0.5) - trnDir * (0.5 * gGap - tunSpc),\n         mod (ro.z - trnDir * trnPos + 0.5 * trnSpc, trnSpc) - 0.5 * trnSpc); \n      col4 *= 0.7 + 0.3 * smoothstep (0., 0.3, PrRoundBox2Df (u, cSize.xz, cSize.x));\n    } else if (idObj == idTun) {\n      col4 = vec4 (0.4, 0.3, 0., 0.) * (0.8 + 0.2 * step (0.2, mod (8. * ro.y, 1.)));\n      col4 *= 1. - 0.9 * smoothstep (0., 5., abs (ro.z) - statSz.z);\n    } else if (idObj == idPlat) {\n      col4 = vec4 (0.5, 0.4, 0.2, 0.1);\n      if (ro.y > -1.) {\n        if (abs (dx - gGap) > 2.98) {\n          u = abs (vec2 (abs (ro.x - 2. * gGap + 5.7 * sign (ro.z)) - gGap,\n             abs (ro.z) - 6.5)) - vec2 (stpWd, 2.5);\n          col4 *= 0.85 + 0.15 * smoothstep (-0.1, 0.3, max (u.x, u.y));\n          stg = ro;\n        } else {\n          col4 = mix (vec4 (0.8, 0.1, 0.1, 0.1), vec4 (0.1, 0.2, 0.1, 0.1), step (0.,\n             sign (sin (4. * pi * ro.z))));\n        }\n      } else col4 *= 0.9 + 0.1 * cos (16. * pi * ro.z);\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idStp) {\n      col4 = vec4 (0.4, 0.45, 0.4, 0.);\n      vf = vec2 (64., 1.);\n    } else if (idObj == idHrail) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.2);\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.2) * (0.85 + 0.15 * sin (16. * pi * ro.y));\n    } else if (idObj == idBase) {\n      col4 = vec4 (0.2, 0.2, 0.2, 0.) * (0.5 + 0.5 * Fbm2 (32. * ro.xz));\n      if (abs (abs (dx - gGap) - 1.7) < 0.65 * cSize.x)\n         col4 *= (0.5 + 0.5 * step (0.8, mod (2. * ro.z, 1.)));\n      vf = vec2 (32., 2.);\n    } else if (idObj == idWal) {\n      if (dx < statSz.x + 0.1 * wThk) {\n        col4 = vec4 (0.45, 0.5, 0.6, 0.1);\n        stg = ro + vec3 (0., 0.23, 0.);\n        u = vec2 (mod (ro.z + 4., 8.) - 4., ro.y - 1.);\n        col4 = mix (col4, vec4 (0.7, 0.1, 0.1, 0.1), step (abs (length (u) - 0.6), 0.12));\n        u = abs (u) - vec2 (0.9, 0.15);\n        col4 = mix (col4, vec4 (0.1, 0.1, 0.7, 0.1), step (max (u.x, u.y), 0.));\n        s = PrRoundBox2Df (vec2 (ro.y - statSz.y - 2.5,\n           mod (ro.z + 2., 4.) - 2.), vec2 (0., 0.5), 0.25);\n        col4.rgb += vec3 (0.9, 0.9, 0.8) / (3. + 50. * s * s);\n      } else col4 = vec4 (0.1, 0.15, 0.2, 0.);\n      vf = vec2 (64., 0.5);\n    } else if (idObj == idCeil) {\n      col4 = vec4 (0.65, 0.75, 0.7, 0.1);\n      col4.rgb *= 0.85 + 0.15 * smoothstep (0.08, 0.1, abs (Truch (2. * ro.xz) - 0.5));\n      col4 = mix (vec4 (1., 1., 0.9, -1.), col4, \n         smoothstep (0.06, 0.08, abs (mod (ro.x + 0.25 * gGap, 0.5 * gGap) - 0.25 * gGap)));\n    } else if (idObj == idLamp) {\n      col4 = vec4 (vec3 (0.9, 0.9, 0.8) * (0.95 + 0.05 * cos (32. * pi * ro.y)), -1.);\n    }\n    if (stg != vec3 (0.)) {\n      rg4 = ShStagGrid3d (stg, vn, vec2 (4./3., 2.));\n      vn = rg4.xyz;\n      col4.rgb *= 0.9 + 0.1 * rg4.w;\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    if (col4.a >= 0.) {\n      isMet = (idObj == idCar || idObj == idTrk || idObj == idWhl);\n      dSum = 0.;\n      sSum = 0.;\n      for (int k = VAR_ZERO; k < 5; k ++) {\n        if (k < 4) {\n          ltDirL = normalize (vec3 (vec2 (min (statSz.x, statSz.z) - 1.), statSz.y + 2.).xzy);\n          ltDirL.xz = Rot2D (ltDirL.xz, 0.5 * pi * float (k));\n        } else ltDirL = ltDir;\n        nDotL = max (dot (vn, ltDirL), 0.);\n        if (isMet) nDotL *= nDotL;\n        dSum += ((k < 4) ? 1. : 0.5) * nDotL;\n        sSum += ((k < 4) ? 1. : 0.5) * pow (max (dot (normalize (ltDirL - rd), vn), 0.), 32.);\n      }\n      col = col4.rgb * (0.1 + 0.4 * dSum) + 0.5 * col4.a * sSum;\n    } else col = col4.rgb * (0.6 - 0.4 * dot (rd, vn));\n    if (idObj == idWin) col += vec3 (0., 0., 0.03);\n  } else {\n    col = vec3 (0.1);\n  }\n  if (! colImg) col = vec3 (0.9, 0.7, 0.5) * Maxv3 (col);\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, mMid[2], ut[2], mSize, msw;\n  float el, az, zmFac, asp, vuId, regId, sr, t;\n  int vuMode;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  colImg = true;\n  asp = canvas.x / canvas.y;\n  mSize = (1./6.) * vec2 (asp, 1.);\n  if (mPtr.z > 0. && Minv2 (- mPtr.xy + 0.03 * vec2 (1. / asp, 1.) - 0.5) > 0.) colImg = ! colImg;\n  mMid[0] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (-1., 1.);\n  mMid[1] = vec2 (asp, 1.) * (1. - mSize.y) * vec2 (1., 1.);\n  for (int k = 0; k < 2; k ++) ut[k] = abs (uv - mMid[k]) - mSize;\n  regId = -1.;\n  if (mPtr.z > 0. && colImg) {\n    for (int k = 0; k < 2; k ++) {\n      msw = 2. * mPtr.xy - mMid[k] / vec2 (asp, 1.);\n      if (Maxv2 (abs (msw)) < mSize.y) {\n        regId = 1. + float (k);\n        msw /= 2. * mSize.y;\n        break;\n      }\n    }\n    if (regId == -1.) msw = mPtr.xy;\n  }\n  vuId = 0.;\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0.) {\n      uv = (uv - mMid[k]) / mSize.y;\n      vuId = float (k + 1);\n      break;\n    }\n  }\n  if (regId > 0. && (vuId == 0. || vuId == regId)) vuId = regId - vuId;\n  t = mod (0.05 * tCur, 6.);\n  vuMode = int (mod (vuId + floor (t / 2.), 3.)) + 1;\n  t = mod (t, 2.);\n  t = SmoothBump (0.25, 0.75, 0.22, mod (t, 1.)) * sign (t - 1.);\n  if (vuMode == 1) {\n    az = -0.5 * pi;\n    el = -0.05 * pi;\n  } else if (vuMode == 2) {\n    az = 0.55 * pi;\n    el = -0.15 * pi;\n  } else if (vuMode == 3) {\n    az = 0.75 * pi;\n    el = -0.15 * pi;\n  }\n  if ((mPtr.z <= 0. || ! colImg)  && vuId == 0.) {\n    if (vuMode == 1) az += 0.25 * pi * t;\n    else if (vuMode == 2 || vuMode == 3) el += 0.15 * pi * t;\n  }\n  if (mPtr.z > 0. && (vuId == 0. || vuId == regId)) {\n    az += 2. * pi * msw.x;\n    el += pi * msw.y;\n  }\n  el = clamp (el, -0.4 * pi, 0.4 * pi);\n  vuMat = StdVuMat (el, az);\n  if (vuMode == 1) {\n    ro = vuMat * vec3 (0., 0., -4.);\n    ro.xy += vec2 (17., 1. /*3.*/);\n    ro.y = max (ro.y, 0.);\n    zmFac = 2.7;\n  } else if (vuMode == 2) {\n    ro = vec3 (4., 8., 5.);\n    zmFac = 3.;\n  } else if (vuMode == 3) {\n    ro = vec3 (4., 6., 15.);\n    zmFac = 3.;\n  }\n  dstFar = 150.;\n  ltDir = vuMat * normalize (vec3 (0.3, 1., -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a +\n       0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  for (int k = 0; k < 2; k ++) {\n    if (Maxv2 (ut[k]) < 0. && Minv2 (abs (ut[k])) * canvas.y < 2.1)\n       col = colImg ? vec3 (0.3, 0.7, 0.3) : vec3 (0.9, 0.7, 0.5);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., clamp (p.z, - h, h))) - r;\n}\n\nfloat Minv2 (vec2 p)\n{\n  return min (p.x, p.y);\n}\n\nfloat Maxv2 (vec2 p)\n{\n  return max (p.x, p.y);\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKyzw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[126, 1402, 1425, 1425, 3258], [3260, 3260, 3280, 3280, 3480], [3482, 3482, 3516, 3516, 4068], [4070, 4070, 4092, 4092, 4348], [4350, 4350, 4372, 4372, 6128], [6130, 6130, 6163, 6163, 6347], [6349, 6349, 6370, 6370, 6625], [6627, 6627, 6661, 6661, 7013], [7015, 7015, 7060, 7060, 7626], [7628, 7628, 7650, 7650, 7798], [7800, 7800, 7835, 7835, 13909], [13911, 13911, 13967, 13967, 16959], [16961, 16961, 16993, 16993, 17093], [17095, 17095, 17128, 17128, 17217], [17219, 17219, 17265, 17265, 17312], [17314, 17314, 17361, 17361, 17408], [17410, 17410, 17443, 17443, 17470], [17472, 17472, 17514, 17514, 17565], [17567, 17567, 17610, 17610, 17674], [17676, 17676, 17698, 17698, 17725], [17727, 17727, 17749, 17749, 17776], [17778, 17778, 17800, 17800, 17838], [17840, 17840, 17897, 17897, 17980], [17982, 17982, 18018, 18018, 18224], [18226, 18226, 18256, 18256, 18369], [18371, 18371, 18402, 18402, 18466], [18500, 18500, 18524, 18524, 18584], [18586, 18586, 18610, 18610, 18722], [18724, 18724, 18749, 18749, 18935], [18937, 18937, 18958, 18958, 19113], [19115, 19115, 19144, 19144, 19356], [19358, 19358, 19397, 19397, 19577]]}
{"id": "tstcDB", "name": "julia revolt vr", "author": "TjaMeu", "description": "gedhtedh", "tags": ["vr"], "likes": 11, "viewed": 363, "published": "Public API", "date": "1601675438", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Stephane Cuillerdier - Aiekick/2017 (twitter:@aiekick)\n\n// VR part by TjaMeu\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nconst vec3 ld = vec3(0.,1., .5);\n\nfloat t = 0.;\n\nfloat fullAtan(vec2 p)\n{\n    return step(0.0,-p.x)*3.1415926535 + sign(p.x) * atan(p.x, sign(p.x) * p.y);\n}\n\nfloat fractus(vec2 p, vec2 v)\n{\n\tvec2 z = p;\n    vec2 c = v;\n\tfloat k = 1., h = 1.0;    \n    for (float i=0.;i<30.;i++)\n    {\n        if (i>7.8) break;\n\t\th *= 4.*k;\n\t\tk = dot(z,z);\n        if(k > 4.) break;\n\t\tz = vec2(z.x * z.x - z.y * z.y, 2. * z.x * z.y) + c;\n    }\n\treturn sqrt(k/h)*log(k);   \n}\n\nvec2 df(vec3 p)\n{\n\tfloat a = fullAtan(p.xz)*0.5 +  iTime * 0.5; // axis y\n    \n    vec2 rev = vec2(length(p.xz),p.y) - 1.52;\n    rev *= mat2(cos(a),-sin(a),sin(a),cos(a)); // rot near axis y\n\t\n\tvec2 res = vec2(100);\n\t\n\tfloat ftus = fractus(rev, vec2(-0.3,-0.649));\n\t\n\tfloat thickStep = 0.12;\n\t\n\tfor (int i =0;i <5;i++)\n\t{\n\t\tfloat lay = max(ftus, -ftus - thickStep * float(i+1)); // change only the interior thickness\n\t\tif (lay < res.x)\n\t\t\tres = vec2(lay, float(i));\n\t}\n\t\n\tvec2 q = p.xz;\n\tfloat a0 = mix(0.,1.57,res.y/5. * mix(-.1,.1,sin(iTime * 0.5)*.5+.5));\n\tq *= mat2(cos(a0),-sin(a0),sin(a0),cos(a0));\n\t\n\tvec2 cut = vec2(q.y, 10);\n\tif (cut.x > res.x)\n\t\tres = cut;\n\t\t\n\tfloat plane = p.y+1.;\n\tif (plane < res.x)\n\t\treturn vec2(plane,12);\n\t\t\n\treturn res;\n\t\n}\n\nvec3 nor( vec3 p, float prec )\n{\n    vec2 e = vec2( prec, 0. );\n    vec3 n = vec3(\n\t\tdf(p+e.xyy).x - df(p-e.xyy).x,\n\t\tdf(p+e.yxy).x - df(p-e.yxy).x,\n\t\tdf(p+e.yyx).x - df(p-e.yyx).x );\n    return normalize(n);\n}\n\n// from iq code\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    for( int i=0; i<1; i++ )\n    {\n\t\tfloat h = df( ro + rd*t ).x;\n        res = min( res, 8.0*h/t );\n        t += h*.25;\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0., 1. );\n}\n\n// from iq code\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<10; i++ )\n    {\n        float hr = 0.01 + 0.12*float(i)/4.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = df( aopos ).x;\n        occ += -(dd-hr)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 );    \n}\n\n//--------------------------------------------------------------------------\n// Grab all sky information for a given ray from camera\n// from Dave Hoskins // https://www.shadertoy.com/view/Xsf3zX\nvec3 GetSky(in vec3 rd, in vec3 sunDir, in vec3 sunCol)\n{\n\tfloat sunAmount = max( dot( rd, sunDir), 0.0 );\n\tfloat v = pow(1.0-max(rd.y,0.0),6.);\n\tvec3  sky = mix(vec3(.1, .2, .3), vec3(.32, .32, .32), v);\n\tsky = sky + sunCol * sunAmount * sunAmount * .25;\n\tsky = sky + sunCol * min(pow(sunAmount, 800.0)*1.5, .3);\n\treturn clamp(sky, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tt = 3.14159*0.5;\n\t\n\tvec2 camp = vec2(643./958.,356./816.) * 5.;\n\t\n\tvec3 rayOrg = vec3(cos(t),sin(camp.y),sin(t)) * camp.x;\n\tvec3 camUp = vec3(0,1,0);\n\tvec3 camOrg = vec3(0,1.5,0);\n\t\n\tfloat fov = .5;\n\tvec3 axisZ = normalize(camOrg - rayOrg);\n\tvec3 axisX = normalize(cross(camUp, axisZ));\n\tvec3 axisY = normalize(cross(axisZ, axisX));\n\tvec3 rayDir = normalize(axisZ + fov * uv.x * axisX + fov * uv.y * axisY);\n\t\n\tfloat s = 1.;\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 20.;\n\tfloat sMin = 0.0001;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (abs(s) < d*d*1e-5 || d>dMax) break; // thanks to iq for the simpler form of the condition\n\t\ts = df(p).x;\n\t\td += s * 0.3;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.01178);\n\t\t\n\t\t// \tiq primitive shader : https://www.shadertoy.com/view/Xds3zN\n\t\t\n      \n        fragColor.rgb = vec3(.5);\n\n        // iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.4).x);\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( p, ld, 0.1, 10. );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.2*dif*vec3(1,1,1);\n        brdf += 1.*spe*vec3(1.00,0.90,0.60)*dif;\n        //brdf += 1.*amb*vec3(0.50,0.70,1.00)*occ;\n        //brdf += 0.02;\n        fragColor.rgb *= brdf;\n\n        fragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.01*d*d ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n}\n\nvoid mainVR( out vec4 fragColor, in vec2 fragCoord, in vec3 fragRayOri, in vec3 fragRayDir ){\n    \n    \n    \n    fragColor = vec4(1);\n\t\n\tvec2 g = fragCoord.xy;\n\tvec2 si = iResolution.xy;\n\tvec2 uv = (2.*g-si)/min(si.x, si.y);\n\t\n\tt = 3.14159*0.5;\n\t\n\tvec2 camp = vec2(643./958.,356./816.) * 5.;\n\t\n\tvec3 rayOrg = fragRayOri+vec3(0,1,2);\n\t\n\t\n\tfloat fov = .5;\n\t\n\tvec3 rayDir = fragRayDir;\n\t\n\tfloat s = 1.;\n\tfloat d = 0.;\n\tvec3 p = rayOrg + rayDir * d;\n\tfloat dMax = 20.;\n\tfloat sMin = 0.0001;\n\t\n\tfor (float i=0.; i<250.; i++)\n\t{\n\t\tif (abs(s) < d*d*1e-5 || d>dMax) break; // thanks to iq for the simpler form of the condition\n\t\ts = df(p).x;\n\t\td += s * 0.3;\n\t\tp = rayOrg + rayDir * d;\t\n\t}\n\t\n    vec3 sky = GetSky(rayDir, ld, vec3(1.5));\n    \n\tif (d<dMax)\n\t{\n\t\tvec3 n = nor(p, 0.01178);\n\t\t\n\t\t// \tiq primitive shader : https://www.shadertoy.com/view/Xds3zN\n\t\t\n      \n        fragColor.rgb = vec3(.5);\n\n        // iq lighting\n\t\tfloat occ = calcAO( p, n );\n        float amb = clamp( 0.5+0.5*n.y, 0.0, 1.0 );\n        float dif = clamp( dot( n, ld ), 0.0, 1.0 ) * (df(p+n*1.4).x);\n        float spe = pow(clamp( dot( rayDir, ld ), 0.0, 1.0 ),16.0);\n\n        dif *= softshadow( p, ld, 0.1, 10. );\n\n        vec3 brdf = vec3(0.0);\n        brdf += 1.2*dif*vec3(1,1,1);\n        brdf += 1.*spe*vec3(1.00,0.90,0.60)*dif;\n        //brdf += 1.*amb*vec3(0.50,0.70,1.00)*occ;\n        //brdf += 0.02;\n        fragColor.rgb *= brdf;\n\n        fragColor.rgb = mix( fragColor.rgb, sky, 1.0-exp( -0.01*d*d ) ); \n\t}\n\telse\n\t{\n\t\tfragColor.rgb = sky;\n\t}\n    \n}\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstcDB.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[70, 228, 252, 252, 335], [337, 337, 368, 368, 635], [637, 637, 654, 654, 1394], [1396, 1396, 1428, 1428, 1606], [1608, 1624, 1698, 1698, 1937], [1939, 1955, 1997, 1997, 2296], [2298, 2493, 2550, 2550, 2838], [2840, 2840, 2897, 2897, 4560], [4562, 4562, 4655, 4655, 6088]]}
{"id": "tstcDX", "name": "One-liner RGB+HSV Converters", "author": "kowbell", "description": "Small & efficient RGB -> HSV and HSV -> RGB conversion functions for your shaders! Public domain/CC0. Original algorithms by Sam Hocevar, licensed under the WTFPL (which can be re-licensed however you want, e.g. to CC0!)", "tags": ["color", "rgb", "hsv", "conversion", "oneliner"], "likes": 3, "viewed": 182, "published": "Public API", "date": "1601912039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/** \n * Public Domain drag-n-drop RGB <-> HSV converters for your shaders.\n * All you need are the two following one-liner functions!\n * You can even drop the preceeding comment with attribution\n * if you want!\n *\n * Non-minified, easier-to-read functions available\n * commented out below.\n *\n * These are both originally by Sam Hocevar \n * who has generously released these over the WTFPL, \n * which can be freely relicensed as CC0/Public Domain.\n * See https://stackoverflow.com/a/17897228/8940353\n * and http://www.wtfpl.net/faq/ (profanity warning)\n *\n * So, these are public domain! But please credit Mr. Hocevar\n * if you don't mind! Or link back to this shader so we can\n * credit Mr. Hocevar AND show folks the unminified source :)\n *\n * Check out my other handy one-liner shader utilities at\n * https://www.shadertoy.com/playlist/l323Wz\n */\n\n\n// Combined one-liner with signatures first & attrib link:\n/* shadertoy.com/view/tstcDX */ vec3 rgb2hsv(vec3 c); vec3 hsv2rgb(vec3 c); vec3 rgb2hsv(vec3 c){const vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);const float e=1.e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);} vec3 hsv2rgb(vec3 c){const vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}\n\n\n\n// OR, Separate one-liners with attribution:\n/* RGB<->HSV Algorithms by Sam Hocevar. CC0. See https://www.shadertoy.com/view/tstcDX for more info. */\n//vec3 rgb2hsv(vec3 c){const vec4 K=vec4(0.,-1./3.,2./3.,-1.);vec4 p=mix(vec4(c.bg,K.wz),vec4(c.gb,K.xy),step(c.b,c.g));vec4 q=mix(vec4(p.xyw,c.r),vec4(c.r,p.yzx),step(p.x,c.r));float d=q.x-min(q.w,q.y);const float e=1.e-10;return vec3(abs(q.z+(q.w-q.y)/(6.*d+e)),d/(q.x+e),q.x);}\n//vec3 hsv2rgb(vec3 c){const vec4 K=vec4(1.,2./3.,1./3.,3.);vec3 p=abs(fract(c.xxx+K.xyz)*6.-K.www);return c.z*mix(K.xxx,clamp(p-K.xxx,0.,1.),c.y);}\n\n\n\n\n\n\n\n/** NON-MINIFIED VERSIONS ******************************************* */\n/*\nvec3 rgb2hsv(vec3 c)\n{\n    const vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    const float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    const vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n*/\n\n\n\n\n\n/** DEMO ******************************************* */\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 mouse = iMouse.xy/iResolution.xy;\n    \n    float scaledTime = iTime * 0.1;\n    float time01 = mod(scaledTime, 1.);\n    \n    // vary hue over time,\n    // map saturation to mouse x,\n    // map value to mouse y\n    // Mouse values are inverted bc the first time you open this\n    // shader mouse will be at (0,0), and I don't want you to\n    // think this is broken ;)\n    vec3 col = hsv2rgb(vec3(time01, 1. - mouse.x, 1. - mouse.y));\n    \n    // Demonstrate that these functions inverse each other\n    // If you see a difference in the left & right halves of\n    // the intro, then the formulas are borked :(\n    if (uv.x > .5)\n    {\n        col = hsv2rgb(rgb2hsv(col));\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstcDX.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[852, 987, 1008, 1008, 1265], [1266, 1266, 1287, 1287, 1412], [2652, 2708, 2765, 2765, 3521]]}
{"id": "tsVcDR", "name": "GenerOETive", "author": "Kaeylos", "description": "#3 Vasarely\nmade during the Ink-MAC-tober 2020\na generative representation of \"OET - OET.\" 1955 by Victor Vasarely", "tags": ["vasarely", "imac"], "likes": 0, "viewed": 26, "published": "Public", "date": "1602624396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// inspired by : https://www.shadertoy.com/view/4dfSDj\n// source: https://www.shadertoy.com/view/ttc3zr\nuint murmurHash11(uint src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash11(float src) { return uintBitsToFloat(murmurHash11(floatBitsToUint(src)) & 0x007fffffu | 0x3f800000u) - 1.0; }\n\nuint murmurHash12(uvec2 src) {\n    const uint M = 0x5bd1e995u;\n    uint h = 1190494759u;\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src.x; h *= M; h ^= src.y;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nfloat hash12(vec2 src) { return uintBitsToFloat(murmurHash12(floatBitsToUint(src)) & 0x007fffffu | 0x3f800000u) - 1.0; }\n\nuvec2 murmurHash21(uint src) {\n    const uint M = 0x5bd1e995u;\n    uvec2 h = uvec2(1190494759u, 2147483647u);\n    src *= M; src ^= src>>24u; src *= M;\n    h *= M; h ^= src;\n    h ^= h>>13u; h *= M; h ^= h>>15u;\n    return h;\n}\nvec2 hash21(float src) { return uintBitsToFloat(murmurHash21(floatBitsToUint(src)) & 0x007fffffu | 0x3f800000u) - 1.0; }\n\n#define rot2(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nfloat band (vec2 id, float threshold) {\n    return step(hash12(id), threshold);\n}\n\nfloat randomLines(vec2 uv, float seed) {\n\t// dilated uv on y axis\n    vec2 duv = uv;\n    duv.x *= 0.8*(1.+.5*(1.+mod(iTime/20., 0.3)*cos(iTime/10.*seed)));\n    duv.y *= 0.02*(1.+mod(floor(iTime*0.1), seed+.1)/(seed+.1)); \n    return max(band(floor(duv*100.), .25), band(floor((duv +0.01*mod(iTime/10., seed+.1)/(seed+.1)*cos(iTime/2.) )*80.), .25));\n}\n\nfloat rottingSquareMask(vec2 uv, float seed, float radius) {\n// rotating squares\n    float a = clamp(cos((iTime/1.) * (.5 + 0.1*hash11(seed))), -.1, .1) / .1 + clamp(cos(seed + (iTime/2.) * .6), -.15, .15) / .12;\n    vec2 center = vec2(cos(seed + mod(iTime/12., hash11(seed))/0.5), sin(mod(iTime/10., hash11(seed))/hash11(seed))) /2.0;\n    vec2 suv = uv * rot2(a) + center;\n    return step(abs(suv.x) + abs(suv.y), radius);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5*iResolution.xy)  / iResolution.y;\n    vec2 Ouv = uv; // keep original UV\n    // adding noise to uv to generate motion\n    float uvNoise = 0.05*((1.+cos(iTime))/20. + mod(iTime/10., 0.2)*cos(1.*iTime)*0.4);\n    uv += uvNoise;\n    \n    float color = 1.; // color in b&w \n    \n    // basic bg lines\n    color *= randomLines(uv, 1.);\n    \n    // horizontal band\n    float hm = step(0.3, abs(uv.y));\n    color = mix(color, randomLines(uv, 2.), hm);\n    \n    //  cubes \n    for(float i; i < 8.; ++i) {\n    \tfloat cubemask = rottingSquareMask(uv, i*10., 0.45 + 0.3*hash11(i*10.0));\n    \t//color *= cubemask;\n    \tcolor = mix(color, randomLines(uv, i), cubemask);\n    }\n\t\t\n\t// horizontal band\n\thm = step(0.3, abs(uv.y + mod(iTime/10., 0.2)*cos(1.*iTime)*0.5));\n    color = mix(color, randomLines(uv, 5.), hm);\n        \n    // periodic inversion\n    color = mix(color, (1.-color), step(.08, iTime / 60.) * round(cos(iTime) *.5+.5));\n    \n    // white border\n    vec2 w = step(abs(Ouv), vec2(.42));\n    float borderMask = w.x*w.y;\n    color = mix(1., color, borderMask);\n    \n    // square mask\n    vec2 s = step(abs(Ouv), vec2(.45));\n    float squareMask = s.x*s.y;\n    \n    vec3 yColor = vec3(1., 1., 0.95); // yellowish background color\n    vec3 finalColor = mix(vec3(.92), yColor * color, squareMask);\n    \n\t\n    fragColor = vec4(finalColor, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVcDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 104, 133, 133, 308], [309, 309, 334, 334, 430], [432, 432, 462, 462, 659], [660, 660, 684, 684, 780], [782, 782, 812, 812, 1008], [1009, 1009, 1033, 1033, 1129], [1186, 1186, 1225, 1225, 1267], [1269, 1269, 1309, 1334, 1620], [1622, 1622, 1682, 1702, 2047], [2049, 2049, 2106, 2106, 3478]]}
{"id": "tsVcDz", "name": "Strange fractal kaleidoscope", "author": "jarble", "description": "This is an edit of [url=https://www.shadertoy.com/view/tsKcWz]another shader[/url] that I found.", "tags": ["fractal"], "likes": 6, "viewed": 284, "published": "Public API", "date": "1602648585", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*50.0-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/10.;\n        for(int i=0;i<20;i++)\n        {\n            uv=abs(uv.yx);\n            uv /= 1.1;\n        \tuv -= 1.0;\n        \tuv=uv*rot(t/float(i+2))+col.xy;\n        }\n     col[c] = fract((uv.x)/(uv.y));\n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 522]]}
{"id": "tsVcRK", "name": "outline of sdf", "author": "FabriceNeyret2", "description": "controling outline thickness  as minimal 1pixel thick vs given pixel width vs %scale.\n( compare at various resolutions )", "tags": ["outline", "tuto", "mm"], "likes": 2, "viewed": 195, "published": "Public API", "date": "1603277677", "time_retrieved": "2021-10-01T00:00:00", "image_code": "  #define S(v) clamp(1. - (v)/scale, 0., 1. )  // Antialiased draw\n//#define S(v) smoothstep(1.5*scale, 0., v  )  // Note that these are assymetrical:\n                                               // it's usually a bad idea, but here an abs() is expected in v \n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;               // centred - normalize coordinates. Vertical = [-1,1]\n    float scale = 2./R.y,                      // pixel width\n            sdf = min( length(U)-.3 ,          // disk1 UNION disk2\n                       length(U+.2+.2*sin(iTime) ) - .3);\n    O = vec4( S(sdf) );                        // antialiased drawing of main shape\n    O.r +=  S ( abs(sdf-.1) );                 // 1pix thick outline offsetted by 10% of unit scale.\n    O.g +=  S ( abs(sdf-.3) -.05 );            // 5% of unit scale thick outline \n    O.b +=  S ( abs(sdf-.5) -4.*scale );       // 4 pixel outline \n    \n    O = pow( O, vec4(1./2.2) );                // to sRGB\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVcRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[67, 263, 301, 301, 1019]]}
{"id": "tsVczz", "name": "First shader ever woohoo", "author": "020406", "description": "Just dipping my toes in this wild world.", "tags": ["n00b"], "likes": 0, "viewed": 32, "published": "Public", "date": "1602172501", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tvec2 center = vec2((1. + sin(iTime))/2., 0.5);\n    vec2 result = uv - center;\n    float xDist = abs(uv.x - center.x);\n    \n    float lineW = 1./iResolution.x * 100. * (1. + cos(iTime*3.))*0.5;\n    vec3 col = vec3(xDist < lineW ? 1.0 : 0., 0., xDist);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVczz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 457]]}
{"id": "tsVyz1", "name": "snakeRotation", "author": "Kaeylos", "description": "#1 Rotation\nmade during the Ink-MAC-tober 2020\n", "tags": ["sdf", "rotation", "imac"], "likes": 1, "viewed": 55, "published": "Public", "date": "1602260818", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// #define FREE_CAM\n\n// ----- Render options ----- //\n#define AA_SAMPLES 1 // antialisaing\n\n// ----- Ray marching options ----- //\n// #define LOW_QUALITY // if your computer isn't powerful enough\n#ifdef LOW_QUALITY\n    #define MAX_STEPS 25\n#else\n    #define MAX_STEPS 150\n#endif\n#define MAX_DIST 50.\n#define SURF_DIST 0.0001\n#define NORMAL_DELTA 0.0001\n\n// ----- Post process ----- //\n#define VIGNETTAGE_STRENGHT 0.8\n\n// ----- Useful constants ----- //\n#define PI  3.14159265358979323846264338327\n#define TAU 6.28318530717958647692528676655\n\n// ----- useful functions ----- //\nfloat maxComp(vec2 v) { return max(v.x , v.y); }\nfloat maxComp(vec3 v) { return max(maxComp(v.xy), v.z); }\nfloat dot2(vec2 v) { return dot(v,v); }\nfloat cro(in vec2 a, in vec2 b ) { return a.x*b.y - a.y*b.x; }\nfloat map(float t, float c, float d) {  return c + t * (d - c);} // considering that t is in [0-1]\n\nvec2 matMin(vec2 a, vec2 b) { return (a.x < b.x) ? a : b; }\nvec3 saturate(vec3 a) { return clamp(a, 0.0, 1.0); }\nvec2 saturate(vec2 a) { return clamp(a, 0.0, 1.0); }\nfloat saturate(float a) { return clamp(a, 0.0, 1.0); }\n\n// ----- easingFunct -----//\nfloat quadin(float t) { return t*t;}\nfloat quadOut(float t) { return -t*(t-2.0);}\nfloat cubicIn(float t) { return t*t*t;}\nfloat cubicOut(float t) { return -t*t*t+1.0;}\nfloat circleOut(float t) { return pow(1.0-(1.0-t)*(1.0-t), 0.5); }\nfloat circleIn(float t) { return 1.0- pow(1.0-t*t, 0.5); }\n\n// ----- distance functions modifiers ----- //\n// source: https://www.iquilezles.org/www/articles/smin/smin.htm\n\nfloat smin( float a, float b, float k ) {\n    float h = max(k-abs(a-b), 0.0)/k;\n    return min(a, b) - h*h*0.25;\n}\n\nfloat polysmin( float a, float b, float k ) {\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\n// ----- distance functions for 3D primitives ----- //\n// source: http://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat cylSDF(vec2 p, float radius) { return length(p) - radius; }\n\nfloat boxSDF(vec3 p, vec3 boxDim) {\n    vec3 q = abs(p) - boxDim;\n    return length(max(q, 0.0)) + min(maxComp(q), 0.0);\n}\n\n// ---- Hash functions ---- //\nfloat v31(vec3 a) { return a.x + a.y * 37.0 + a.z * 521.0; }\nfloat v21(vec2 a) { return a.x + a.y * 37.0; }\nfloat Hash21(vec2 uv) {return fract(sin(v21(uv))*104003.9);}\n\nvec2 glow = vec2(0, 0);\n\n\nvec2 sceneSDF(vec3 p) {\n    \n    float freq = 5.0;\n\tfloat theta;\n\tfloat snakeRadius = 0.8;\n\tfloat distoRadius = 0.15;\n\tfloat thickness = 0.02;\n\t\n    float angle = atan(p.z, p.x);\n\n    float amp = cubicIn(sin(angle + iTime/2.0) * 0.5 + 0.5);\n\t\n\tvec2 cylWarp = vec2(cylSDF(p.xz, snakeRadius), p.y + cos((angle+iTime)*3.0)*0.1);\n\t// cylWarp = vec2(cylSDF(p.xz, 1.0), cos(p.y)/15);\n\t\n    theta = angle*freq;\n    float wave1 = boxSDF(vec3(cylWarp + vec2(sin(theta), cos(theta)) * distoRadius * amp, 0.0), vec3(thickness));\n    \n    theta = angle*freq + TAU / 3.0;\n    float wave2 = boxSDF(vec3(cylWarp + vec2(sin(theta), cos(theta)) * distoRadius * amp, 0.0), vec3(thickness));\n\t\n\ttheta = angle*freq - TAU / 3.0;\n    float wave3 = boxSDF(vec3(cylWarp + vec2(sin(theta), cos(theta)) * distoRadius * amp, 0.0), vec3(thickness));\n\t\n\tfloat snake = polysmin(wave1, wave2, 0.1);\n\tsnake = polysmin(snake, wave3, 0.1);\n\t\n\tfloat centerGlow = boxSDF(vec3(cylWarp, 0), vec3(thickness*2.0, vec2(thickness*0.5)));\n    vec2 snakeMat = matMin(vec2(snake, 1.0), vec2(centerGlow, -1.0));\n    \n    float innerRadius = 0.5;\n    float center = cylSDF(vec2(cylSDF(p.xz, innerRadius), p.y), 0.01);\n    float nb = 5.0;\n   \tfor(float i = 0.0; i < nb; ++i) {\n   \t\tcenter = min(center, cylSDF(vec2(cylSDF(p.xz, circleOut((nb-i-0.8f)/nb)*innerRadius), p.y+i/nb*innerRadius), 0.01));\n   \t\tcenter = min(center, cylSDF(vec2(cylSDF(p.xz, circleOut((nb-i-0.8f)/nb)*innerRadius), p.y-i/nb*innerRadius), 0.01));\n   \t}\n    // center = max(center, abs(fract(cylWarp.z*freq-2.0*iTime)-0.5)-0.4);\n    \n    const float fallOffStrenght = 0.5; \n    glow.y += fallOffStrenght / (center * center + fallOffStrenght);\n\n    return matMin(snakeMat, vec2(center, -1.0));\n}\n\n\n// source: https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 getNormal(vec3 p) {\n    const float h = NORMAL_DELTA;\n\tconst vec2 k = vec2(1., -1.);\n    return normalize( k.xyy * sceneSDF( p + k.xyy*h ).x + \n                      k.yyx * sceneSDF( p + k.yyx*h ).x + \n                      k.yxy * sceneSDF( p + k.yxy*h ).x + \n                      k.xxx * sceneSDF( p + k.xxx*h ).x );\n}\n\n// return dist, mat, marchingCount\nvec3 rayMarching(vec3 O, vec3 D) { // ray origin and dir\n    vec2 sceneHit;\n    float d = 0.0;\n    float marchingCount = 0.0;\n \t\n    for(int i = 0; i < MAX_STEPS; i++) {\n    \tvec3 newPos = O + D * d;\n    \tsceneHit = sceneSDF(newPos);\n        float distToScene = sceneHit.x;\n        \n        d += distToScene * 0.7; // precision handling\n        // If we are very close to the object, consider it as a hit and exit this loop\n        if( d > MAX_DIST || abs(distToScene) < SURF_DIST*0.99) break;\n        ++marchingCount;\n        \n        // glow\n        const float fallOffStrenght = 2.0; \n        glow.x += fallOffStrenght / (distToScene * distToScene + fallOffStrenght); // with gaussian fallOff\n    }\n    return vec3(d, sceneHit.y, marchingCount);\n}\n\nvec3 render(vec3 O, vec3 D) { // ray origin and dir\n\t\n\tvec3 finalColor = vec3(2,43,58)/255.0; // background\n\t\n\tglow = vec2(0, 0); // reset glow\n    vec3 marching = rayMarching(O, D);\n    \n    // if we hit an object\n    \n    if( marching.x <= MAX_DIST) {\n\t\t// material handling\n        if (marching.y < 0.0) {\n        \tfinalColor = vec3(255,166,43)/255.0;\n        }else {\n        \tfinalColor = vec3(130,192,204)/255.0;\n        }\n    }\n    \n    // Glow if we're close to the part of the ring with the braid.\n    float cyc = (-sin(marching.y * TAU))*0.5+0.7;\n    \n    // glow\n    \n    finalColor +=  vec3(255,166,43)/255.0 * cyc * glow.x * 0.01;\n    // glow if we are close to the center of our cyl\n    finalColor += vec3(35,100,170)/255.0 * glow.y * 0.01 ;\n\t\n    // finalColor *= vec3(0.2); // mate\n            \n\t// return finalColor;\n\treturn vec3(saturate(finalColor));\n}\n\nvec3 computeCamDir(vec2 uv, vec3 camPos, vec3 camUp, vec3 lookAtPos) {\n\tvec3 camVec = normalize(lookAtPos - camPos);\n\tvec3 sideNorm = normalize(cross(camUp, camVec));\n\tvec3 upNorm = cross(camVec, sideNorm);\n\tvec3 worldFacing = (camPos + camVec);\n\tvec3 worldPix = worldFacing + uv.x * sideNorm + uv.y * upNorm;\n\treturn normalize(worldPix - camPos);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\n\tvec2 uv = (fragCoord-.5 * iResolution.xy)/iResolution.y * 2.0; // get centered & normalized [-1.0, 1.0]\n    uv /= 2.7; // zoom\n    \n    // setup camera\n    vec3 camPos;\n    vec3 camUp = vec3(0, 1, 0);\n#ifdef FREE_CAM\n    const float mx = iMouse.x/iResolution.x*PI*2.0;\n\tconst float my = -iMouse.y/iResolution.y*10.0;\n\tcamPos = vec3(cos(my)*cos(mx),sin(my),cos(my)*sin(mx))*3.0;\n#else\n    camPos = vec3(0.0);\n    camPos.y = sin(iTime*0.4)*3.0;\n    camPos.z = cos(iTime*0.4)*3.0;\n    camUp.y = camPos.z;\n    camUp.z = -camPos.y;\n    camUp = normalize(camUp);\n#endif\n\tvec3 camDir = computeCamDir(uv, camPos, camUp, vec3(0));\n    vec3 finalColor = vec3(0.0);\n\t\n#if AA_SAMPLES > 1\n    for (float i = 0.0; i < AA_SAMPLES; i++) {\n    \tfor (float j = 0.0; j < AA_SAMPLES; j++) {\n\t        vec2 deltaUV = (vec2(i, j) / float(AA_SAMPLES) *2.0 - 1.0) / iResolution.y;\n\t        uv += deltaUV;\n#endif\n\t    \tfinalColor += render(camPos, camDir);\n#if AA_SAMPLES > 1\n    \t}\n    }\n    finalColor /= float(AA_SAMPLES * AA_SAMPLES); // Average samples\n#endif\n\n    // gamma corection\n    // finalColor = pow( finalColor, vec3( 1 / 2.2));\n    \n    // color grading\n    finalColor *= vec3(1.0 ,1.05, 0.95);\n    \n    // vignetting \n#ifdef VIGNETTAGE_STRENGHT\n    finalColor *= clamp(1.0 - length(uv * VIGNETTAGE_STRENGHT), 0.0, 1.0); //  saturate(1.0 - length(uv * VIGNETTAGE_STRENGHT));\n#endif\n    \n    fragColor = vec4(sqrt(clamp(finalColor, 0.0, 1.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVyz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[542, 577, 600, 600, 625], [626, 626, 649, 649, 683], [684, 684, 704, 704, 723], [724, 724, 758, 758, 786], [787, 787, 825, 825, 851], [852, 887, 916, 916, 946], [947, 947, 970, 970, 999], [1000, 1000, 1023, 1023, 1052], [1053, 1053, 1078, 1078, 1107], [1109, 1138, 1161, 1161, 1174], [1175, 1175, 1199, 1199, 1219], [1220, 1220, 1244, 1244, 1259], [1260, 1260, 1285, 1285, 1305], [1306, 1306, 1332, 1332, 1372], [1373, 1373, 1398, 1398, 1431], [1433, 1546, 1587, 1587, 1660], [1662, 1662, 1707, 1707, 1800], [1802, 1936, 1972, 1972, 2001], [2003, 2003, 2038, 2038, 2125], [2127, 2158, 2177, 2177, 2218], [2219, 2219, 2238, 2238, 2265], [2266, 2266, 2289, 2289, 2326], [2354, 2354, 2377, 2377, 4073], [4076, 4149, 4173, 4173, 4476], [4478, 4513, 4547, 4569, 5263], [5265, 5265, 5294, 5316, 6135], [6137, 6137, 6207, 6207, 6486], [6488, 6488, 6545, 6545, 7986]]}
{"id": "tsVyzc", "name": "Meandering Canyons", "author": "jarble", "description": "These canyons were generated using a modified version of my [url=https://www.shadertoy.com/view/tdKyRc]\"Fractal Rivers\"[/url] pattern as a heightmap.", "tags": ["fractal", "river", "canyon"], "likes": 3, "viewed": 226, "published": "Public API", "date": "1603418425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 20.0;\nconst float MAX_DIST = 1000.0;\nconst float EPSILON = 0.1;\n\nconst float size = 1000.0;\n\n\nconst float scale = EPSILON*.1; //to prevent rendering artifacts\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nfloat heightmap(vec2 uv)\n{\n    \tuv /= 25.0;\n        float factor = 1.5;\n    \tfloat col = 0.0;\n        for(int i=0;i<6;i++)\n        {\n            uv *= -factor*factor;\n            uv += sin(uv.yx/factor)/factor;\n            col += (sin(uv.x-uv.y+col)+cos(uv.y-uv.x+col));\n        }\n    return -col/2.0;\n}\n\nfloat sceneSDF(vec3 p) {\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    p.y *= 1.0;\n    return (-p.y+20.0-heightmap(p.xz))*scale/2.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    vec3 p1 = p;\n    p /= scale*500.0;\n    return vec3(heightmap(p.xz*100.0)+1.0)/20.0 + vec3(.6-p.y,.5-p1.y/10.0,.2+p1.y);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < EPSILON) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.yz *= rot(3.14*0.666);\n    float speed = 2.0;\n    float t1 = speed*iTime+5.0;\n\tvec3 eye = vec3(-t1,-10,-t1*2.0);\n    eye.y -= 20.0;\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(0,5,1), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVyzc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[344, 585, 611, 611, 888], [890, 890, 914, 976, 1044], [1046, 1046, 1074, 1074, 1200], [1203, 1624, 1715, 1715, 2021], [2036, 2290, 2355, 2355, 2487], [2489, 2578, 2607, 2607, 2917], [2919, 3411, 3551, 3551, 4161], [4163, 4533, 4618, 4618, 5033], [5035, 5362, 5411, 5446, 5577], [5579, 5579, 5636, 5636, 6618]]}
{"id": "tsyyDt", "name": "Stuck between magnetic fields", "author": "eimink", "description": "This is only a test. Or is it.", "tags": ["testing"], "likes": 0, "viewed": 28, "published": "Public", "date": "1604001559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by eimink\n// Based on https://www.shadertoy.com/view/MdfGRX by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nfloat hash12(vec2 p){\n\treturn fract(sin(dot(p, vec2(3.9898, 78.233))) * 803758.5453);\n}\n\nfloat noiseMod( in vec3 x )\n{\n    vec3 p = floor(x);\n\treturn hash12(p.xy);\n}\n\nvec4 map( vec3 p )\n{\n\tfloat den = 0.3 - p.y;\n\n    // invert space\t\n\tp = -9.0*p/dot(p,p);\n\n    // twist space\t\n\tfloat co = cos(den - 0.45*iTime);\n\tfloat si = sin(den - 1.25*iTime);\n\tp.xz = mat2(si,-co,-si,co)*p.xz;\n\n    // smoke\t\n\tfloat f;\n\tvec3 q = p                          - vec3(0.0,1.0,0.0)*iTime;;\n    f  = 0.40000*noiseMod( q ); q = q*3.02 - vec3(0.0,1.0,1.0)*iTime;\n    f += 0.25000*noiseMod( q ); q = q*2.03 - vec3(1.0,1.0,1.0)*iTime;\n    f += 0.12500*noiseMod( q ); q = q*2.01 - vec3(1.0,1.0,0.0)*iTime;\n    f += 0.06250*noiseMod( q ); q = q*1.02 - vec3(0.0,1.0,1.0)*iTime;\n    f += 0.03125*noiseMod( q );\n\n\tden = clamp( den +4.0*f, 0.0, 3.0+2.0*sin(iTime) );\n\t\n\tvec3 col = mix( vec3(1.0,0.9,0.8), vec3(0.4,0.15,0.1), den );\n\t\n\treturn vec4( col, den );\n}\n\nvec3 raymarch( in vec3 ro, in vec3 rd, in vec2 pixel )\n{\n\tvec4 sum = vec4( 0.0 );\n\n\tfloat t = 0.0;\n\n    // dithering\t\n\tt += 0.07*hash12(pixel);\n\t\n\tfor( int i=0; i<100; i++ )\n\t{\n\t\tif( sum.a > 0.99 ) break;\n\t\t\n\t\tvec3 pos = ro + t*rd;\n\t\tvec4 col = map( pos );\n\t\t\n\t\tcol.xyz *= mix( 3.1*vec3(0.2,0.5,1.05), vec3(0.48,0.53,1.5), clamp( (pos.y-0.2)/2.0, 0.0, 1.0 ) );\n\t\t\n\t\tcol.a *= 0.3;\n\t\tcol.rgb *= col.a;\n\n\t\tsum = sum + col*(1.0 - sum.a);\t\n\n\t\tt += 0.05;\n\t}\n\n\treturn clamp( sum.xyz, 0.0, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 1.7*q;\n    p.x *= iResolution.x/ iResolution.y;\n\t\n    // camera\n    vec3 ro = 3.0*normalize(vec3(0.2,.4 - 1.0*(-.1), 0.3));\n\tvec3 ta = vec3(sin(iTime), cos(iTime), 0.1);\n\tfloat cr = 0.3 * hash12(ro.xy);\t\t\n\t\n\t// build ray\n    vec3 ww = normalize( ta - ro);\n    vec3 uu = normalize(cross( vec3(cr,cr,0.0), ww ));\n    vec3 vv = normalize(cross(ww,uu));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 2.0*ww );\n\t\n    // raymarch\t\n\tvec3 col = raymarch( ro, rd, fragCoord );\n\t\n\t// contrast and vignetting\t\n\tcol = col*0.5 + 0.5*col*col*(3.0-2.0*col);\n\tcol *= 0.25 + 0.75*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyyDt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 185, 206, 206, 272], [274, 274, 303, 303, 350], [352, 352, 372, 372, 1116], [1118, 1118, 1174, 1174, 1608], [1610, 1610, 1667, 1667, 2372]]}
{"id": "tsyyWK", "name": "Freistil in colors", "author": "mrange", "description": "License CC0: Freistil in Colors\n  Created for twitch streamer FullStackLive just for fun\n", "tags": ["3d", "grid"], "likes": 6, "viewed": 248, "published": "Public API", "date": "1603741153", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// License CC0: Freistil in Colors\n//  Created for twitch streamer FullStackLive just for fun\n\n// Heavily inspired by \"Grid of Cylinders\" and while I understood how it worked\n//  in concept I didn't get the math so I had to resort to pen and paper to recreate it :)\n\n// Cylinder intersection by IQ: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\n// SDFs by IQ: https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n// Smooth min by IQ: https://www.iquilezles.org/www/articles/smin/smin.htm\n\nconst float globalHeight    = 2.75;\nconst float eps             = 1E-4;\nconst float miss            = -1E6;\nconst float delta           = 1.0 ;\n\nconst vec3 lightPos1        = 100.0*vec3(2.0, .35, -1.0);\nconst vec3 lightPos2        = 100.0*vec3(-2.0, 3.0, 1.0);\nconst vec3 lightCol1        = vec3(8.0/8.0,7.0/8.0,6.0/8.0);\nconst vec3 lightCol2        = vec3(8.0/8.0,6.0/8.0,7.0/8.0);\n\nconst vec3 lightDir1        = normalize(lightPos1);\nconst vec3 lightDir2        = normalize(lightPos2);\nconst float pi              = 3.14159654;\nconst float tau             = 2.0*pi;\n\nfloat hash1(vec2 n) { \n  return fract(43758.5453123*sin(dot(n,vec2(1.0,113.0)))); \n}\n\nvec2 mod2_1(inout vec2 x) {\n  vec2 n = floor(x+0.5);\n  x = fract(x+0.5)-0.5;\n  return n;\n}\n\nfloat pmin(float a, float b, float k) {\n  float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n  return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat circle(vec2 p, float r) {\n  return length(p) - r;\n}\n\nfloat box(vec2 p, vec2 b, float r) {\n  vec2 d = abs(p)-(b - r);\n  return length(max(d,0.0)) + min(max(d.x,d.y),0.0) - r;\n}\n\nfloat tanh_approx(float z) {\n  float z2 = z*z;\n  // z / (1 + z2/(3 + z2/(5 + z2/(7 + ...))))\n  return clamp(z / (1.0 + z2/(3.0+ z2/5.0)), -1.0, 1.0);\n}\n\nvec2 freistil_logo(vec2 p) {\n  vec2 mp = p;\n  vec2 mn = mod2_1(mp);\n  vec2 amp = abs(mp);\n\n  const float lw = 0.03;\n  \n  float d0 = circle(mp, 0.40);\n  vec2 d1 = -(amp-(0.5)) - lw;\n  float d3 = pmin(d1.x, d1.y, 0.1);\n  float d4 = box(p, vec2(3.0/2.0+lw), 0.1);\n\n\n  float d = 1E6;\n  d = (mn.x + mn.y) == 1.0 || mn.y == -1.0 ? d0 : d;\n  d = min(d, d3);\n  d = max(d, d4);\n  return vec2(d, d4);\n}\n\nfloat height(vec2 x, float t) {\n  vec2 n = x;\n  vec2 p = (x) * 0.025;\n  vec2 f = freistil_logo(p)-0.02;\n  float d = f.x;\n  float fh = max(tanh_approx(-d*5.0), 0.0);\n  float nh = hash1(n)*mix(0.35, 1.0, psin(iTime+max(10.0*f.y, 0.0)));\n  float m = 1.0-smoothstep(-0.1, 0.125, f.y);\n  return globalHeight*mix(nh, fh, 0.9*m);\n}\n\nvec4 cylinder(vec3 ro, vec3 rd, vec3 pa, vec3 pb, float ra) {\n  vec3 ba     = pb-pa;\n\n  vec3  oc    = ro - pa;\n\n  float baba  = dot(ba,ba);\n  float bard  = dot(ba,rd);\n  float baoc  = dot(ba,oc);\n   \n  float k2    = baba            - bard*bard;\n  float k1    = baba*dot(oc,rd) - baoc*bard;\n  float k0    = baba*dot(oc,oc) - baoc*baoc - ra*ra*baba;\n    \n  float h     = k1*k1 - k2*k0;\n    \n  if (h<0.0) return vec4(miss);\n  h = sqrt(h);\n    \n  float t = (-k1-h)/k2;\n\n  // body\n  float y = baoc + t*bard;\n  if (y>0.0 && y<baba) return vec4(t, (oc+t*rd - ba*y/baba)/ra);\n   \n  // caps\n  t = (((y<0.0) ? 0.0 : baba) - baoc)/bard;\n  if (abs(k1+k2*t)<h) return vec4(t, ba*sign(y)/sqrt(baba));\n\n  return vec4(miss);\n}\n\nvec4 gridTrace(vec3 ro, vec3 rd, float initial, const int max_iter) {\n  float t = initial;\n\n  vec2 x = 0.5*(1.0 + sign(rd.xz));\n  vec2 y = 1.0/rd.xz;\n  \n  float mt = (-globalHeight - ro.y)/rd.y;\n\n  for (int i = 0; i < max_iter; ++i) {\n    vec3 p = ro + t*rd;\n    vec2 n = floor(p.xz);\n    vec2 m = fract(p.xz);\n\n    float h = height(n, t);\n    float dt = (h - p.y)/rd.y;\n    vec3 tp = p + dt*rd;\n    \n    if (p.y < -globalHeight) {\n      return vec4(mt, vec3(0.0, 1.0, 0.0));\n    }\n    \n    float hh = hash1(n+100.0);\n    \n    if (n == floor(tp.xz)||h > p.y) {\n      vec3 lp = vec3(m.x, p.y, m.y);\n      vec4 c = cylinder(lp, rd, vec3(0.5, -globalHeight, 0.5), vec3(0.5, h, 0.5), 0.35 + 0.145*hh);\n      float tt = t + c.x;\n      \n      if (mt >= 0.0 && tt > mt) {\n        return vec4(mt, vec3(0.0, 1.0, 0.0));\n      }\n      \n      if (c.x >= 0.0) {\n        return vec4(tt, c.yzw);\n      }\n    }\n\n    vec2 z = (x - fract(p.xz))*y;\n    t += min(z.x, z.y) + eps;\n  }\n  \n  return vec4(miss);\n}\n\nvec3 skyColor(vec3 rayDir) {\n  float ld1      = max(dot(lightDir1, rayDir), 0.0);\n  vec3 final     = vec3(0.125);\n  final += 1.0*pow(lightCol1, vec3(2.0, 1.5, 1.5)) * pow(ld1, 8.0);\n  final += 1.0*lightCol1 * pow(ld1, 200.0);\n  return final;\n}\n\n\nvec3 render(vec3 ro, vec3 rd) {\n  vec3 col = vec3(0.125);\n  \n  float dup = (1.025*globalHeight - ro.y)/rd.y;\n  vec3 upp = ro + rd*dup;\n\n  vec3 sky = skyColor(rd);\n\n  if (dup > 0.0) {\n    vec4 dgt  = gridTrace(ro, rd, dup, 40);\n    float t   = dgt.x;\n    vec3 nor  = dgt.yzw;\n    vec3 gtp  = ro + rd*t;\n\n    vec2 n = floor(gtp.xz);\n    vec2 m = fract(gtp.xz);\n    float h = height(n, t);\n    float l2 = dot(gtp.xz, gtp.xz);\n\n    vec4 dst  = gridTrace(gtp + nor*0.01, lightDir1, 0.0, 8);\n\n    vec3 refl     = reflect(rd, nor);\n    vec3 reflCol  = skyColor(refl);\n\n    vec3 refr     = refract(rd, nor, 1.25);\n\n    \n    float dif1 = max(dot(lightDir1, nor), 0.0);  \n    float dif2 = max(dot(lightDir2, nor), 0.0);  \n    \n    vec3 baseCol = pow(vec3(0.5 + 0.5*sin(iTime + 0.1*vec3(n, n.x + n.y)/(1.0+0.0000125*l2)))*mix(vec3(1.0), vec3(0.125), tanh(abs(2.0*h))), vec3(1.0, 1.5, 0.5)/(1.0+0.00005*l2));\n\n    float shade = dst.x > miss ? tanh_approx(0.25*dst.x) : 1.0;\n\n    dif1 *= shade;\n    if (dgt.x > miss) {\n      col += baseCol*0.75*mix(0.125, 1.0, sqrt(dif1 + dif2));\n      col += 0.5*sqrt(reflCol)*mix(1.0, shade, max(dot(refl, lightDir1), 0.0));\n      if (refr != vec3(0.0)) {\n        col += 0.3*vec3(1.0)*pow(max(dot(refr, rd), 0.0), 100.0);\n      }\n    } else {\n      col = sky;\n    }\n    \n    float mm = 1.0-max(dot(rd, vec3(0.0, -1.0, 0.0)), 0.0);\n    mm*=mm;\n    col = mix(col, sky, mm*(1.0-exp(-0.0125*max(t-100.0, 0.0))));\n  } else {\n    col = sky;\n  }\n\n  return col;\n}\n\nvec3 pos(float time) {\n  float m1 = smoothstep(0.0, 10.0, time);\n  float m2 = smoothstep(13.0, 30.0, time);\n  float h = mix(10.0, 25.0, m1);\n  vec3 p1 = vec3(15.0*time-250.0, h, 0.5);\n  const float r = 100.0;\n  time *= 0.2;\n  float h2 = mix(25.0, 350.0, m2);\n  vec3 p2 = vec3(-r*sin(time), h2, -r*cos(time));\n  return mix(p1, p2, m2);\n}\n\nvec3 dpos(float time) {\n  float m = smoothstep(0.0, 10.0, time);\n  vec3 dp = (pos(time + delta) - pos(time - delta))/(2.0*delta);\n  rot(dp.xy, mix(1.0, 0.5, m)); \n  return dp;\n}\n\nvec3 ddpos(float time) {\n  vec3 ddp = (dpos(time + delta) - dpos(time - delta))/(2.0*delta);\n  return ddp;\n}\n\nvec3 dir(vec3 ro, float time) {\n  vec3 dpos =  normalize(dpos(time));\n  vec3 la = normalize(vec3(0.0)-ro);\n  float m = smoothstep(13.0, 20.0, time);  \n  return normalize(mix(dpos, la, m));\n}\n\nvec3 up(float time) {\n  vec3 ddp = ddpos(time);  \n  vec3 up = normalize(vec3(0.0, 1.0, 0.0) + 0.1*ddp);\n  float m = 0.5*(tanh(time - 11.0)+1.0);\n  rot(up.yz, m*tau);\n  return up;\n}\n\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.75)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.33))), -0.4);  // satuation\n//  col*=0.5+0.5*pow(19.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n  vec2 q = fragCoord.xy/iResolution.xy;\n  vec2 p = -1.0 + 2.0*(fragCoord.xy) / iResolution.xy;\n  p.x *= iResolution.x/ iResolution.y;\n  \n  float aa = 2.0/iResolution.y;\n\n  float tm = mod(iTime, 35.0);\n  vec3 ro  = pos(tm);\n  vec3 dir = dir(ro, tm);\n  vec3 up = up(tm);\n\n  vec3 ww = dir;\n  vec3 uu = normalize(cross(up, ww));\n  vec3 vv = normalize(cross(ww, uu));\n  \n  vec3 rd = normalize(p.x*uu + p.y*vv + 2.0*ww);\n\n  vec3 col = render(ro, rd);\n  \n  float ss1 = smoothstep(28.00, 35.0, tm);\n  float ss2 = smoothstep(33.0, 35.0, tm);\n  float ss3 = smoothstep(28.00, 31.40, tm);\n  float scale = 0.22+0.1*ss1;\n\n  vec2 lp = p;\n  rot(lp, -0.5*(1.0-tanh((tm-30.0))));\n  vec2 df = freistil_logo(lp/scale)*scale;\n  vec3 col2 = mix(vec3(1.0), vec3(ss2*ss2), smoothstep(-aa, aa, -df.x));\n  col = mix(col, col2, ss3*ss3);\n  \n  float fadeIn = 1.0 - smoothstep(0.0, 3.0, tm);\n  col += fadeIn;\n\n  col = postProcess(col, q);\n    \n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsyyWK.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[267, 1105, 1126, 1126, 1189], [1191, 1191, 1218, 1218, 1281], [1283, 1283, 1322, 1322, 1411], [1413, 1413, 1434, 1434, 1463], [1465, 1465, 1498, 1498, 1583], [1585, 1585, 1616, 1616, 1642], [1644, 1644, 1680, 1680, 1766], [1768, 1768, 1796, 1796, 1919], [1921, 1921, 1949, 1949, 2313], [2315, 2315, 2346, 2346, 2639], [2641, 2641, 2702, 2702, 3351], [3353, 3353, 3422, 3422, 4343], [4345, 4345, 4373, 4373, 4588], [4591, 4591, 4622, 4622, 6069], [6071, 6071, 6093, 6093, 6407], [6409, 6409, 6432, 6432, 6586], [6588, 6588, 6612, 6612, 6696], [6698, 6698, 6729, 6729, 6888], [6890, 6890, 6911, 6911, 7070], [7073, 7073, 7110, 7110, 7361], [7363, 7363, 7415, 7415, 8362]]}
{"id": "Wd3Bzr", "name": "Halloween Boze", "author": "kaiware007", "description": "Trick or Salvation!", "tags": ["raymarching", "halloween", "boze"], "likes": 1, "viewed": 75, "published": "Public", "date": "1604150039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n//#define ENABLE_REFLECTION\n//#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n#define USE_BRDF_1\n//#define USE_RAYCAST\n#define ENABLE_FOG\n//#if HW_PERFORMANCE==0\n#define AA 1\n//#else\n//#define AA 2\n//#endif\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 200\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\nconst float CAMERA_SPEED = 0.1;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 4.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n/*\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n*/\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n/*\nsurface SURF_WATERMELON(float d, vec3 pos, vec3 center)\n{\n    pos = center - pos;\n    vec2 uv = vec2(atan(pos.z,pos.x), pos.y);\n    uv.x = abs(uv.x)-M_PI/5.;\n    vec2 guv = fract(uv*1.5)-0.5;\n    vec2 id = floor(uv*1.5)-0.5;\n    float mask = step(abs(guv.x),0.25+sin((uv.y+id.x)*200.)*0.05);\n    \n    vec4 col = vec4(mix (vec3(0.05,0.3,0.025),vec3(0.025, 0.05, 0.025), mask), 1);\n    return surface(d, col, vec3(0), 0.2, 0.001, 0, false, 2.2, true);\n}\n*/\n\n//#define SURF_LOAD(d) \t(surface(d, vec4(0.2,0.2,0.2,1), \tvec3(0), 0.0001, 0.01, 0, false, 0.0, true))\nsurface SURF_LOAD(float d, vec3 p, vec3 cp)\n{\n\tfloat len = length(cp - p);\n        \n    vec3 col = mix(vec3(0), vec3(0,0.4,1), smoothstep(0.4, 0.41, len));\n    \n    return surface(d, vec4(0.2,0.2,0.2,1), \tcol, 0.01, 0.5, 0, false, 0.5, true);\n}\n\n//#define SURF_DESERT(d) \t(surface(d, vec4(0.8,0.5,0.4,1), \tvec3(0), 0.0001, 0.01, 0, false, 0.0, true))\n\n#define SURF_SHARI(d) \t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.3, 0.1, 0, false, 1.1, true))\n#define SURF_NETA(d, col) \t(surface(d, vec4(col,1), vec3(0), 0.01, 0.2, 0, false, 1.1, true))\n\n#define SURF_PUMPKIN(d) \t\t(surface(d, vec4(0.9,0.3,0.1,1), vec3(0), 0.5, 0.0, 0, false, 1.1, true))\n#define SURF_PUMPKIN_STALK(d) \t(surface(d, vec4(0.5,0.9,0.2,1), vec3(0), 0.5, 0.0, 0, false, 1.1, true))\n\n//==================================================================\n// Catmull-Rom Spline\n// https://www.shadertoy.com/view/ls3SRr\n//==================================================================\nconst int POINT_COUNT = 8;\nstruct CtrlPts\n{\n    vec3 p[POINT_COUNT];\n};\n\nvec3 PointArray(int i, CtrlPts ctrlPts)\n{\n    i = int(mod(float(i), float(POINT_COUNT)));\n    return ctrlPts.p[i];\n    /*\n    if(i==0 || i==POINT_COUNT  ) return ctrlPts.p[0];\n    if(i==1 || i==POINT_COUNT+1) return ctrlPts.p[1];\n    if(i==2 || i==POINT_COUNT+2) return ctrlPts.p[2];\n    if(i==3) return ctrlPts.p[3];\n    if(i==4) return ctrlPts.p[4];\n    if(i==5) return ctrlPts.p[5];\n    if(i==6) return ctrlPts.p[6];\n    if(i==7) return ctrlPts.p[7];\n    return vec3(0);\n*/\n}\n\nvec3 catmullRom(float fTime, CtrlPts ctrlPts)\n{\n    float t = fTime;\n    const float n = float(POINT_COUNT);\n    \n    int idxOffset = int(t*n);\n    vec3 p1 = PointArray(idxOffset,ctrlPts);\n    vec3 p2 = PointArray(idxOffset+1,ctrlPts);\n    vec3 p3 = PointArray(idxOffset+2,ctrlPts);\n    vec3 p4 = PointArray(idxOffset+3,ctrlPts);\n    \n    //For some reason, fract(t*n) returns garbage on my machine with small values of t.\n    //return fract(n*t);\n    //Using this below yields the same results, minus the glitches.\n    t *= n;\n    t = (t-float(int(t)));\n    \n    //A classic catmull-rom\n    //e.g.\n    //http://steve.hollasch.net/cgindex/curves/catmull-rom.html\n    //http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/\n    vec3 val = 0.5 * ((-p1 + 3.*p2 -3.*p3 + p4)*t*t*t\n               + (2.*p1 -5.*p2 + 4.*p3 - p4)*t*t\n               + (-p1+p3)*t\n               + 2.*p2);\n    return val;\n}\n\nfloat distanceToLineSeg(vec3 p, vec3 a, vec3 b, out vec3 e, out vec3 forward)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    forward = normalize(a-b);\n    return length(p-e);\n}\n\nfloat sdCatmullRomSpline(vec3 p, CtrlPts ctrlPts, out vec3 cp)\n{\n\tconst float maxDist = 10000.0;\n    float bestX = 0.0;\n    \n    //Primary (rough) estimate : decent results with 2 lines per control point (faint blue lines)\n    const int iter = POINT_COUNT*2+1;\n    //const int iter = POINT_COUNT*1+1; //<-Faster\n    //const int iter = POINT_COUNT*3+1; //<-Nicer\n    float primarySegLength = 1.0/float(iter-1);\n    vec3 pA = catmullRom(0., ctrlPts);\n    float minRoughDist = maxDist;\n    float x = 0.0;\n    vec3 e, fwd;\n    for(int i=0; i < iter; ++i)\n    {\n        vec3 pB = catmullRom(x, ctrlPts);\n        \n        float d = distanceToLineSeg(p, pA, pB, e, fwd);\n        pA = pB;\n        if(d<minRoughDist)\n        {\n            bestX = x;\n            minRoughDist = d;\n        }\n         \n        x += primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    //Secondary (smooth) estimate : refine (red curve)\n    const int iter2 = 8;\n    x = max(bestX-1.25*primarySegLength,0.0); //Starting 25% back on previous seg (50% overlap total)\n    float minDist = maxDist;\n    pA = catmullRom(x, ctrlPts);\n    for(int i=0; i < iter2; ++i)\n    {\n        vec3 pB = catmullRom(x, ctrlPts);\n        float d = distanceToLineSeg(p, pA, pB, e, fwd);\n        pA = pB;\n        \n        if(d<minDist)\n        {\n            bestX = x;\n            minDist = d;\n            cp = e;\n        }\n         \n        //Covering 1.5x primarySegLength (50% overlap with prev, next seg)\n        x += 1.5/float(iter2-1)*primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    return minDist;\n}\n\n//==================================================================\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    vec4 col = vec4(vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0), 1);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\nsurface SURF_BG_COLORFULL(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    float flg = mod(mod(index.x + index.y, 2.0) + index.z, 2.0);\n    //vec4 col = vec4(vec3(0.25) + vec3(0.5,0,0.5) * flg, 1);\n    //vec4 col = vec4(vec3(0.25) + sinebow((hash13(index) + iTime*0.5) * M_PI) * flg, 1);\n    return surface(d, vec4(vec3(0.25)*(1.-flg), 1), sinebow(hash13(index*3165.5) * M_PI + iTime*0.5) * flg, 0.5, 0.1 + 0.7 * (1.-flg), 0, false, 0., true);\n\t//return SURF_MIRROR(d);\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nvec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t){\n\n    return ((-p0 + p1*3. - p2*3. + p3)*t*t*t +\n            (p0*2. - p1*5. + p2*4. - p3)*t*t +\n            (-p0 + p2)*t + p1*2.)*.5;\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opU( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opS( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opI( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec4 quat_from_axis_angle(vec3 axis, float angle)\n{ \n  vec4 qr;\n  //float half_angle = (angle * 0.5) * 3.14159 / 180.0;\n    float half_angle = (angle * 0.5);\n  qr.x = axis.x * sin(half_angle);\n  qr.y = axis.y * sin(half_angle);\n  qr.z = axis.z * sin(half_angle);\n  qr.w = cos(half_angle);\n  return qr;\n}\n\nvec4 quat_conj(vec4 q)\n{ \n  return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quat_mult(vec4 q1, vec4 q2)\n{ \n  vec4 qr;\n  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n  return qr;\n}\n\nvec3 rotate_vertex_position(vec3 position, vec3 axis, float angle)\n{ \n  vec4 qr = quat_from_axis_angle(axis, angle);\n  vec4 qr_conj = quat_conj(qr);\n  vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n  \n  vec4 q_tmp = quat_mult(qr, q_pos);\n  qr = quat_mult(q_tmp, qr_conj);\n  \n  return vec3(qr.x, qr.y, qr.z);\n}\n\nvec2 foldRotate(in vec2 p, in float s, out float index) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    index = floor(a / n);\n    a = index * n;\n    p *= rot(a);\n    return p;\n}\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\nfloat sdMouseTunnel(vec3 p, float ms)\n{\n    //vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(p - vec3(0,0,0.2), vec3(0.08, 0.01 * ms,2));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opU(opU(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n*/\nsurface sdColorBoze(vec3 p, vec3 sc, float ms, vec3 color)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\thead.albedo.rgb = color;\n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n/*\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n    \n    float spd = iTime * 2.5;\n    \n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n        \n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n    \n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n    \n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n    \n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n    \n    result = SURF_MIRROR(body);\n    \n    // head\n    vec3 b = p;\n    \n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\t\n    return result;\n}\n\nsurface sdWatermelonBoze(vec3 p, vec3 sc, float ms)\n{\n    //surface result = sdBoze(p, vec3(1), 1.);\n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n    // outer skin\n\tsurface head = SURF_WATERMELON(d, p, vec3(0));\n\n    if(head.dist < 0.){\n        if(head.dist > -0.01){\n\t    \t// inner skin\n        \thead.albedo = mix(head.albedo, vec4(1,1,0.5,1), smoothstep(0., 0.01, abs(head.dist)));\n    \t}else{\n            // flesh meat\n            float n = fbm(p * 25.);\n            head.albedo = mix(vec4(1,1,0.5,1), vec4(1,0,0,1) + n * 0.2, smoothstep(0.01, 0.015, abs(head.dist)));\n            // seed\n            const float mb = M_PI2 / 32.;\n            vec3 ps = p;\n            ps.y -= 0.025;\n    \t\tfloat b = mod(atan(ps.y, ps.z), mb) - 0.5 * mb;\n    \t\tfloat c = smoothstep(.15, .18, length(vec2(b*12.,abs(head.dist)*15.0 - 0.5)));\n            head.roughness = mix(0.01, 0.1, c);\n            head.albedo = mix(vec4(0.02), head.albedo, c);\n    \t}\n    }\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    //surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    //surface mouse = SURF_MOUSE(d6);\n    d4 = min(d4, d6);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    //eye.dist = opUnion(eye.dist, d9);\n    d4 = min(d4, d9);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n\t//surface cheep = SURF_BLACK(d7); \n    \n    head.dist = min(head.dist, d7);\n    head.dist = max(-d4, head.dist);\n    \n    // integration\n    //mouse = opU(eye, mouse);\n    //result = opS(mouse, head);\n    //result = opU(cheep, result);\n    result = head;\n    result.dist *= minsc;\n    \n    return result;\n}\n*/\n\nsurface sdBozeGate(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opU(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouseTunnel(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opU(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\n// Base Pumpkin Distance function @ P_Malin\n// https://www.shadertoy.com/view/MdBXR3\nfloat sdPumpkinBody(vec3 p, float radius, float height)\n{\n\tfloat fAngle1 = atan(p.x, p.z);\n    float fSin = sin(fAngle1 * 16.0);\n    fSin = 1.0 - sqrt(abs(fSin));\n    vec3 sc = 1.0 + fSin * vec3(0.05, 0.025, 0.05);\n    p *= sc;\n    p.y *= height + 0.5 * (radius - length(p.xz)) / radius;\n    \n    return length(p) - radius;\n}\n\nsurface sdPumpkinBoze(vec3 p, float ms)\n{\n    surface result = SURF_NOHIT(1e5);\n    \n    float fSphereRadius = 0.2;\n\t\n\tvec3 vOffset = p;\n\tfloat fFirstDist = length(vOffset);\n\t\n\t//float fOutDist;\n\tif(fFirstDist < 1.5)\n\t{\n        // body\n        float bottom = sdPumpkinBody(vOffset, fSphereRadius, 1.75);\n        float top = sdPumpkinBody(vOffset + vec3(0, -0.075, 0), fSphereRadius * 0.65, 0.5);\n        \n        result = SURF_PUMPKIN(smin(bottom, top, 0.05));\n\n        // stalk(heta)\n        vec3 vStalkOffset = p;\n        vStalkOffset.x += -(vStalkOffset.y - fSphereRadius) * 0.1;\n        float fDist2d = length(vStalkOffset.xz);\n        float fStalkDist = fDist2d - 0.02;\n        fStalkDist = max(fStalkDist, p.y - 0.25 + p.x * 0.2);\n        fStalkDist = max(fStalkDist, -p.y);\n        surface stalk = SURF_PUMPKIN_STALK(fStalkDist);\n        \n        result = opSU(result, stalk, 0.02);\n        \n        vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n        // ear\n        float d2 = sdEar(mxp + vec3(0.01,-0.01,0));\n        result.dist = smin(result.dist, d2, 0.005);\n\n        // eye\n#define eyeZ 0.12\n        //float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n        float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, eyeZ+0.01), vec3(-EYE_SPACE, 0.1, eyeZ), 0.0175);\n        surface eye = SURF_BLACK(d4);\n\n        // mouse\n        float d6 = sdMouse(p, ms);\n        surface mouse = SURF_MOUSE(d6);\n\n        // cheep\n        float d7 = sdCheep(mxp + vec3(0,0,-0.015));\n        surface cheep = SURF_CHEEP(d7);\n\n        // eyebrows\n        float d9 = sdEyeBrow(mxp);\n        eye.dist = opU(eye.dist, d9);\n\n        // integration\n        mouse = opU(eye, mouse);\n        result = opS(mouse, result);\n        //result = opU(mouse, result);\n        result = opU(cheep, result);\n\t}\n\t\t\n\n\treturn result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface sdSushi(vec3 p, vec3 sc, vec3 col) {\n    surface result = SURF_NOHIT(1e5);\n    \n\tfloat minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // shari\n    float shari = sdRoundBox(p, vec3(0.75,0.5,1.75), 0.125);\n    \n    result = SURF_SHARI(shari);\n    \n    //float neta = sdRoundBox(p-vec3(0,0.5625,0), vec3(1,0.25,2), 0.05);\n    \n    surface neta = SURF_NETA(sdRoundBox(p-vec3(0,0.5625,0), vec3(1,0.25,2), 0.05), col);\n    \n    result = opU(result, neta);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\nCtrlPts ctrlPts;\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(1e5);\n    \n    float ms = 1.;\n    // boze\n    //vec3 q = rotate(p, iTime * 0.2, vec3(0,1,0));\n    //vec3 q = p;\n    //surface boze = sdBoze(q-vec3(0.5,0.0,0), vec3(1), ms);\n    \n    surface pumpkin = sdPumpkinBoze(p, ms);\n    \n    // sushi\n#define SUSHI_REP_Y 0.2\n    \n    float r = M_PI2 / 27.;\n    for(int i = 0; i < 3; i++)\n    {\n        float index;\n        float angle = float(i) * r;\n\n        float yindex = floor((p.y +0.5*SUSHI_REP_Y + iTime * 0.1) / SUSHI_REP_Y );\n        \n        vec3 q = rotate(p, angle + iTime + hash11(yindex * 30.2)*RAD90, vec3(0,1,0));\n        vec2 sr = foldRotate(q.xz, 9., index);\n        \n        q.y = mod(q.y+0.5*SUSHI_REP_Y + iTime * 0.1, SUSHI_REP_Y)-0.5 * SUSHI_REP_Y;\n        vec3 sq =vec3(sr.x, q.y - abs(sin(index * 0.85+ iTime * 5. + angle))*0.05, sr.y -0.35 + sin(hash11(yindex * 13.24) * M_PI2 + iTime * 3.6 + hash11(index) * 0.6)*0.05);\n        \n        float sp = step(hash11(yindex * 561.817), 0.1);\n        sq = rotate(sq, RAD90 * sp, vec3(1,0,0));\n        sq = rotate(sq, (iTime *10.+ angle) * sp, vec3(0,0,1));\n        \n        // maguro\n        vec3 col1 = mix(vec3(1,0.8,0.9), vec3(0.95,0,0.01), smoothstep(0.0, 0.2, fract(abs(sq.x + sq.y + sq.z)*100.)));\n        // tamago\n\t\tvec3 col2 = vec3(0.9,0.87,0.05);\n        // sake\n        vec3 col3 = mix(vec3(1,0.8,0.7), vec3(0.95,0.3,0.01), smoothstep(0.0, 0.2, fract(abs(sq.x + sq.y + sq.z+2.3)*220.)));\n        vec3 col = (i == 0) ? col1 : (i == 1) ? col2 : col3;\n        \n        surface sushi = sdSushi(sq, vec3(0.025), col);\n\n        result = opU(result, sushi);\n    }\n    \n    //surface sushi = sdSushi(p + vec3(0.25), vec3(0.1), vec3(1,0,0));\n    //result = opU(result, sushi);\n    \n    //result = opU(result, boze);\n    result = opU(result, pumpkin);\n    \n    \n    return result;\n}\n/*\nfloat mapNormal(vec3 p)\n{\n\tsurface result;\n    \n    // background\n    float h = sea_octave(p.xz * 0.75, 5.5) * 0.2;\n    //h += sea_octave(p.xz * 100., 0.1) * 0.01;\n    //float gl = noise(p*500.);\n    //h += noise(p*500.) * 0.00075;\n    h += hash12(p.xz*100.) * 0.0002;\n    float sand = abs(p.y - h * length(p.xz*0.5) + 0.2);\n    \n    float dist = sand * 0.5;\n    //result = SURF_DESERT(sand * 0.5);\n    //result.roughness = 0.0001;\n    //result.metalness = 0.1;\n    //result.metalness = saturate(gl*10.);\n    //result.roughness = 0.1;\n    \n    // boze\n    p = rotate(p, M_PI, vec3(0,1,0));\n    \n    float a = 1. - smoothstep(0., 5., cos(iTime*1.) * 5. + 2.5);\n    vec3 b = p;\n    b.y += (1.-a)*0.1;\n    b.x += 0.15 * a;\n    b = rotate(b, (-RAD90-RAD90*0.25)*a, vec3(0,0,1));\n    \n    float boze = sdBoze(b, vec3(1), 2.).dist;\n    //surface boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    b = p;\n    b.y += (1.-a)*0.1;\n    b.x -= 0.15 * a;\n    b = rotate(b, (RAD90+RAD90*0.25)*a, vec3(0,0,1));\n    boze = sdBoze(b, vec3(1), 2.).dist;\n    //boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(-0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    //return result;\n    return dist;\n}\n*/\n#if 0\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=mapNormal(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(mapNormal(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(position+0.0005*e).dist;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    /*\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t*/\n}\n#endif\n\n/*\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n*/\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).dist;\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 1.0 * d / t);\n    }\n    \n    return res;\n}\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n/*\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n*/\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // sinebow\n    return sinebow(iTime*0.5) * 0.1;\n    \n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 10.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    /*\n    // fake unity default sky-box\n\tvec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.5, 0.8, 1.), saturate(abs(rd.y) * 10.0));\n    return rd.y < 0. ? ground :sky;\n    */\n    /*\n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 500., 0.99 ));\n    */\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n#ifdef USE_BRDF_1\n//------------------------------------------------------------------------------\n// BRDF 1\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n#else\n//------------------------------------------------------------------------------\n// BRDF 2\n//------------------------------------------------------------------------------\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (M_PI * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//surface surf\n//vec3 shade(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\nvec3 shade(vec3 pos, vec3 N, vec3 V, vec3 L, vec3 Lradiance, surface surf)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), surf.albedo.rgb, surf.metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), surf.roughness);\n\tfloat D = ndfGGX(NdotH, surf.roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, surf.roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), surf.metalness);\n\n    float shadow = shadow(pos, L);\n\tvec3 diffuseBRDF = kd * surf.albedo.rgb / M_PI;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL * shadow;\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\n// Specular Occlusion\n// https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/course-notes-moving-frostbite-to-pbr-v2.pdf\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nvec3 calcAmbient(vec3 pos, vec3 N, vec3 V, float t, vec3 ambientColor, surface surf)\n{\n\tvec3 F0 = mix(vec3(0.04), surf.albedo.rgb, surf.metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), surf.roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), surf.metalness);\n    \n\tfloat aoRange = t/40.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    //vec3 ambientColor = mix(vec3(0.2,0.5,0.85)*0.5, vec3(0.2,0.25,0.8) * 0.75, 0.5+0.5*N.y);\n    //ambientColor = mix(vec3(0.3, 0.15, 0.05), ambientColor, 1.0 - smoothstep(0.2, -0.5, sunDir.y));\n    //ambientColor = mix(vec3(0.03), ambientColor,  1.0 - smoothstep(-0.2, -0.5, sunDir.y));\n    \n    vec3 diffuseAmbient = kd * surf.albedo.rgb * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    //vec3 col = mix(fakeSky(R) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 col = ambientColor;\n    vec3 ref = EnvBRDFApprox(F0, surf.roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), occlusion, surf.roughness);\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n#endif\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n#ifdef USE_RAYCAST\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n*/\nfloat densitycalc(vec3 p){\n    //p = rotate(p, 0.45, vec3(0,0,1));\n    //p = rotate(p, M_PI, vec3(0,1,0));\n    p = opRep(p, vec3(0.5,100,100.0));\n    p = rotate(p + vec3(0,0.04,0.2), RAD90, vec3(1,0,0));\n    float d = 10000.;\n    for(int i = 0; i < 5; i++)\n    {\n        float k = fract(float(i) / 5. + iTime * 0.25);\n        vec3 q = p + vec3(0, -2.8*k, -0.1*k);\n        //surface r = sdBoze(p, vec3(1), (sin(iTime * 2.0) * 0.5 + 0.5)*1.5);\n        //surface r = sdBoze(p, vec3(1.2), 1.);\n        //float d = sdCapsule(p, vec3(0,0.01,0.2), vec3(0,0.1,1.0), 0.01, 0.1);\n        //float d = sdTorus(p, vec2(0.2 + sin(iTime) * 0.1, 0.05));\n        float d2 = sdTorus(q, vec2(0.2*k, 0.05*k));\n        //return fbm(p * 25. + iTime * 2.2) - min(d, 1.) * 25.;\n        //return fbm(p * (25. + p.y * 25.) *vec3(1,0.5,1)+ vec3(0, iTime * -5.2, 0)) - min(d, 1.) * (20. - p.y * 20.);\n        //return fbm(p * (25. + p.y * 25.) *vec3(1,0.5,1)+ vec3(0, iTime * -5.2, 0)) - min(d, 1.) * (20. - p.x * 20.);\n        d = min(d, d2);\n    }\n    return fbm(p * (25. + p.z * 25.) * vec3(1,1,0.5)+ vec3(0, 0, iTime * -5.2)) - min(d, 1.) * 25.;\n}\n\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0,0,0);\n    const vec3 boxSize = vec3(100., 0.5, 10.);\n    vec2 sd = GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\t//const float lightStep = 2.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 5.5) * 0.001;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 20.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 2. - dd * absorption;\n                if(transmittance < 0.001)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                //result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n                //result.emission.rgb += vec3(1,0.3,0.05) * (150. * dd * transmittance);\n                result.emission.rgb += vec3(0.1,0.3,1.0) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        //result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n#endif\n\n#define fog_density(x) (1.0 - saturate(exp2(4.5 - (x) * 11.0)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d * 0.2;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n\n#ifdef USE_BRDF_1\n        // BRDF 1\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n#else\n        // BRDF 2\n        //Shade \n        hit.albedo.rgb = shade(pos, nor, -direction, normalize(lightPos), lightColor, hit);\n        // Calc Ambient\n        hit.albedo.rgb += calcAmbient(pos, nor, -direction, hit.dist, vec3(0.5), hit);\n#endif\n        \n#ifdef ENABLE_FOG\n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n#endif\n    }\n    \n#ifdef USE_RAYCAST\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        hit.isHit = volume.isHit;\n    }\n    \n    if(d <= EPS || volume.isHit){\n#else\n    if(d <= EPS){\n#endif\n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    //if (!mat.isHit && mat.albedo.a <= EPS) {\n    if (!mat.isHit) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 1; i++)\n            {\n                vec3 nor = norm(pos);\n                nor = normalize(nor + hash33(ray*3823.) * mat.roughness);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                //orientingNormal = normalize(orientingNormal + hash33(pos) * mat.roughness * 0.05);\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    //ray = normalize(ray + hash33(ray) * mat.roughness * 0.05);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define ZERO (min(iFrame,0))\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        //vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        //vec2 mouseUV = iMouse.xy / iResolution.xy;\n\n        // init ctrl points\n        ctrlPts.p[0] = vec3(0.5, 0, 0.5)*5.;\n        ctrlPts.p[1] = vec3(0.75, 0.025, 0.1)*5.;\n        ctrlPts.p[2] = vec3(0.75, 0.05, -0.1)*5.;\n        ctrlPts.p[3] = vec3(0.5, 0.025, -0.25)*5.;\n        ctrlPts.p[4] = vec3(-0.5, 0, -0.25)*5.;\n        ctrlPts.p[5] = vec3(-0.75, 0.1, -0.1)*5.;\n        ctrlPts.p[6] = vec3(-0.75, 0.05, 0.1)*5.;\n        ctrlPts.p[7] = vec3(-0.5, 0., 0.25)*5.;\n\n        //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n        //vec2 p = (fragCoord.xy) / iResolution.xy;\n\n        //vec2 idx = floor(p*3.0);\n        //p = fract(p*3.0) - 0.5;\n        //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n\n        float t = iTime * M_PI2 * -0.1;\n        //float t = iTime * -1.0;\n        //float t = 0.;\n        //float y = sin(t * 2.5) * 0.125-0.0;\n        //float y = sin(t * 5.) * 0.1 + 0.5;\n        float y = 0.2;\n        //float r = 1.5 + sin(t * 2.5);\n        float r = 0.5;\n        //float distortionPower = sin(iTime * 0.2 * M_PI2) * 0.5 + 0.5;\n        //float distortionPower = sin(iTime * 0.05 * M_PI2);\n        //float theta = t + RAD90 + RAD90*0.25;\n        //float theta = RAD90 + RAD90*0.25;\n        //float theta = 0.;\n        //float theta = M_PI - RAD90*0.25;\n        float theta = t + RAD90;\n        //float theta = RAD90 + noise(vec2(p.x * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n        //float theta = -RAD90;\n        //float theta = t + RAD90 + (mouseUV.x) * M_PI2;\n        //float theta = RAD90 + (mouseUV.x) * M_PI2;\n        //float phi   = noise(vec2(p.y * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n        float phi   = sin(t*3.) * 0.2;\n        //float phi   = 0.;\n        //float phi   = RAD90*0.5;\n        //float phi   = cos(mouseUV.y * M_PI);\n        //float phi   = (mouseUV.y) * RAD90;\n        //vec3 ro = vec3( 0., 0.05, -0.75 );\n\n        vec3 ro = vec3(cos(theta) * r, y + sin(phi)*0.5, -sin(theta) * r);\n        //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n        vec3 ta = vec3(0., 0., 0);\n        //vec3 ta = vec3(0. + t, -0.5, 0.);\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 1.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \n         tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    //col = postEffect(col, idx);\n    \n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3Bzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1110, 1355, 1378, 1378, 1451], [3307, 3410, 3455, 3455, 3654], [4160, 4434, 4475, 4475, 4912], [4914, 4914, 4961, 4961, 5820], [5822, 5822, 5901, 6023, 6168], [6170, 6170, 6234, 6234, 7819], [8389, 8465, 8487, 8487, 8818], [8821, 9009, 9032, 9032, 9117], [9119, 9138, 9160, 9160, 9277], [9279, 9298, 9321, 9321, 9424], [9426, 9446, 9467, 9467, 9601], [9603, 9622, 9644, 9644, 9777], [9779, 9799, 9821, 9821, 9946], [9948, 9948, 9985, 10050, 10268], [10270, 10270, 10316, 10381, 10822], [10824, 10824, 10845, 10845, 10915], [10917, 10917, 10940, 10940, 11019], [11022, 11022, 11044, 11044, 11461], [11572, 11572, 11593, 11593, 11734], [11736, 11736, 11766, 11766, 11896], [11898, 11898, 11959, 11959, 12097], [12099, 12099, 12125, 12125, 12434], [12436, 12496, 12522, 12522, 13388], [13390, 13470, 13511, 13511, 13682], [13684, 13684, 13741, 13741, 13876], [13878, 13978, 14014, 14014, 14042], [14044, 14044, 14090, 14090, 14146], [14148, 14148, 14179, 14179, 14270], [14272, 14272, 14322, 14322, 14440], [14442, 14442, 14503, 14503, 14634], [14636, 14636, 14673, 14673, 14762], [14764, 14764, 14834, 14834, 14968], [14970, 14970, 15034, 15034, 15151], [15153, 15153, 15205, 15205, 15312], [15314, 15314, 15347, 15373, 15404], [15406, 15406, 15431, 15431, 15450], [15451, 15451, 15476, 15476, 15495], [15496, 15496, 15532, 15532, 15560], [15562, 15562, 15621, 15621, 15934], [15936, 15936, 15969, 15969, 16034], [16036, 16060, 16112, 16112, 16231], [16233, 16343, 16375, 16375, 16469], [16471, 16471, 16505, 16505, 16656], [16658, 16658, 16692, 16692, 16840], [16842, 16842, 16876, 16876, 17011], [17013, 17013, 17041, 17041, 17126], [17127, 17185, 17256, 17256, 17584], [17586, 17586, 17668, 17668, 18036], [18038, 18123, 18167, 18167, 18391], [18393, 18450, 18487, 18528, 18611], [18613, 18613, 18652, 18824, 18933], [18935, 18935, 18984, 18984, 19543], [19545, 19545, 19584, 19630, 19715], [19717, 19717, 19758, 19868, 19982], [19997, 20048, 20081, 20081, 20103], [20105, 20105, 20138, 20138, 20160], [20162, 20162, 20195, 20195, 20216], [20218, 20218, 20261, 20261, 20360], [20363, 20363, 20408, 20408, 20837], [20839, 20839, 20860, 20860, 20924], [20926, 20926, 20977, 20977, 21229], [21231, 21231, 21255, 21255, 21297], [21301, 21301, 21335, 21335, 21650], [21652, 21652, 21720, 21720, 21972], [21974, 21974, 22031, 22031, 22175], [22177, 22177, 22212, 22212, 22360], [22362, 22362, 22396, 22396, 22572], [22574, 22574, 22609, 22609, 22644], [22646, 22646, 22683, 22683, 22718], [22720, 22891, 22976, 22976, 23053], [23055, 23098, 23173, 23173, 23592], [23594, 24172, 24256, 24256, 24599], [24601, 24607, 24659, 24659, 24815], [24817, 24817, 24877, 24877, 24918], [24920, 25135, 25166, 25166, 25215], [25217, 25217, 25244, 25244, 25282], [25284, 25284, 25313, 25313, 25351], [25353, 25353, 25380, 25380, 25429], [25432, 25661, 25682, 25682, 25821], [25847, 25847, 25879, 25879, 25992], [25994, 25994, 26026, 26026, 26166], [26168, 26168, 26201, 26201, 26433], [26434, 26434, 26473, 26506, 26698], [26700, 26700, 26723, 26723, 27294], [27296, 27296, 27321, 27321, 27482], [27484, 27484, 27527, 27527, 28533], [28534, 29235, 29295, 29295, 30331], [30538, 36883, 36930, 36930, 37942], [37944, 38029, 38086, 38086, 38354], [38356, 38356, 38397, 38397, 40197], [40198, 40416, 40460, 40460, 40941], [40961, 40961, 40982, 40982, 42802], [45576, 45930, 45966, 45966, 46299], [46565, 46633, 46661, 46661, 46788], [46790, 46880, 46943, 46943, 47149], [47151, 47217, 47281, 47451, 48082], [48083, 48217, 48243, 48243, 50303], [58221, 58423, 58456, 58512, 58698], [58700, 58700, 58739, 58739, 58782]]}
{"id": "Wd3cDl", "name": "PewDiePie Simple Pattern", "author": "saafan", "description": "PewDiePie Brand Pattern", "tags": ["waves", "pewdiepie"], "likes": 1, "viewed": 174, "published": "Public API", "date": "1601932612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float speed = 3.0f;\nconst float frequencyX = 15.0f;\nconst float frequencyY = 13.0f;\nconst float yTrans = 0.0f;\nconst float wavesHeight = 0.0f;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    \n    vec3 yColor = vec3(0,0,0);\n\tif (sin((uv.y + sin(uv.x * frequencyY - (iTime * speed))) * frequencyX + sin(iTime))   > wavesHeight)\n\t\tyColor = vec3(0.98, 0, 0.25);\n\t//color = vec4(yColor, 1.0f);\n    \n    fragColor = vec4(yColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3cDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 207, 257, 654]]}
{"id": "Wd3cDs", "name": "#inktober2020 d4: pixel redux", "author": "zaiyugi", "description": "Day 4 of Inktober 2020. Revisiting the pixely circle from d3. ", "tags": ["inktober"], "likes": 5, "viewed": 87, "published": "Public", "date": "1601967699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define nTiles 50.0\n\n#define quant(v, n) floor((v) * (n)) / (n)\n#define line(e0, d, f) (smoothstep(e0-d, e0, f)-smoothstep(e0, e0+d, f))\n#define rot(a) mat2(cos(a), -sin(a), sin(a), cos(a))\n\nvec3 colormap(float t)\n{\n    return 0.5 + 0.5 * cos(6.283 * (t + vec3(0.0, 0.1, 0.2)));\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    // pixel -> uv\n    float dn = 1.0 / (2.*nTiles);\n    vec2 p = (U - 0.5*iResolution.xy) / iResolution.x + dn;\n    \n    float t = iTime;\n    vec3 col = vec3(0.0);\n    \n    float pix = nTiles / iResolution.y;\n    float wave_t = mix(-.3, .75, fract(t * 0.15));\n    float shape = line(wave_t, 1.5*pix, length(p));\n    \n    vec2 qp = rot(shape * 1.571)*vec2(-dn)+dn+p;\n    float f = length(quant(qp, nTiles));\n    shape = line(wave_t, 3.*pix, f);\n    col = colormap(shape)*shape;\n    \n    float pts = line(0.0, pix, length(fract(qp * nTiles)-.5));\n    col = mix(vec3(pts), col*(1.-pts), shape);\n    \n    C = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3cDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[191, 191, 215, 215, 280], [282, 282, 323, 342, 947]]}
{"id": "wd3cDX", "name": "Dancing Blobbies", "author": "lil_chickehh", "description": "Can someone teach me how arrays work there has to be a better way than to type all those zero's out.", "tags": ["voronoi", "voronoidiagram"], "likes": 3, "viewed": 58, "published": "Public", "date": "1601850503", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float points[20]=float[20](0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.,0.);\nint len=points.length();\nfloat speed=0.3;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 4.*(fragCoord/iResolution.xy-vec2(0.5,0.5))*vec2(1.,iResolution.y/iResolution.x);\n\n    //Dancing\n    for(int i=0;i<len/2;i++){\n    \tpoints[i*2]=cos(speed*iTime*float(i)/17.35)*sin(speed*iTime*float(i+1)+4.);\n    \tpoints[i*2+1]=cos(speed*iTime*float(i)/27.54)*cos(speed*iTime*float(i+1)-23.)+cos(speed*iTime*float(i))*0.4;\n    }\n    //Voronoi Diagram\n    float dist=100000000.;\n    for(int i=0;i<len/2;i++){\n        if((dot(uv-vec2(points[2*i],points[2*i+1]),uv-vec2(points[2*i],points[2*i+1])))<dist){\n        \tdist=(dot(uv-vec2(points[2*i],points[2*i+1]),uv-vec2(points[2*i],points[2*i+1])));\n        }\n    }\n    float col=1.-(sqrt(dist));\n    // Output to screen\n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3cDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[131, 131, 188, 188, 908]]}
{"id": "wd3cWl", "name": "Cosine Scales", "author": "Ezra_Szanton", "description": "found a cool effect I liked from overlapping cosine functions", "tags": ["cosine", "periodic"], "likes": 1, "viewed": 38, "published": "Public", "date": "1601956669", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 blobLayer(vec2 uv, vec2 timeOffset)\n{\n    vec3 col = vec3(0.);\n    uv += iTime * timeOffset;\n    \n    float r = (sin(uv.x)/(2. + abs(4.*sin(iTime))) + cos(uv.y)/(2. + abs(4.*cos(iTime))));\n    float g = (sin(uv.x)/(2. + abs(2.2*sin(iTime))) + cos(uv.y)/(2.523 + abs(4.*cos(iTime))));\n    float b = (sin(uv.x)/(2. + abs(3.14*cos(iTime))) + cos(uv.y)/(2. + abs(4.*cos(iTime))));\n    \n    col += abs (vec3(r,g,b) / 3.);\n    \n    return col;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.*iResolution.xy)/iResolution.y;\n\n    float size = 20.;\n    \n    uv *= size;\n    \n    \n    vec2 gv = fract(uv * size);\n    vec2 id = floor(uv * size) / size;\n    \n    vec3 col = vec3(0.);\n    col += blobLayer(uv, vec2(-0.2, 0.3));\n    col += blobLayer(uv, vec2(1));\n    col += blobLayer(uv, vec2(1.4, -2.321));\n    \n    col.z = (col.z + 0.5) / 2.;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3cWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 447], [449, 449, 506, 506, 942]]}
{"id": "wd3fRn", "name": "Mindwaves", "author": "hamoid", "description": "radial distorted waves", "tags": ["circles"], "likes": 1, "viewed": 53, "published": "Public", "date": "1604166020", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = fragCoord/iResolution.xy;\n    vec3 col = texture(iChannel0, uv).rgb;\n    float di = 10000.0 / (50.0+distance(gl_FragCoord.xy, vec2(300.0, 250.0)));\n    float d = mod(di + col.r * 50.0 + iTime * 20.0, 100.0);\n    float cut = 30.0;\n    float shift = (smoothstep(cut - 3.0, cut, d) - pow(smoothstep(cut+1.0, cut+30.0, d), 0.3)) * 0.45\n        * fract(d * 0.1);\n    col.r += shift;\n    col.g += shift * 0.8;        \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4df3zn", "previewfilepath": "/media/ap/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3405e48f74815c7baa49133bdc835142948381fbe003ad2f12f5087715731153.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3fRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 517]]}
{"id": "wd3yDS", "name": "#inktober2020 d1: circles", "author": "zaiyugi", "description": "Personal challenge for Inktober 2020: shader every day. Circles with a little chromatic aberration", "tags": ["sdf", "inktober"], "likes": 4, "viewed": 114, "published": "Public", "date": "1601615606", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define td 1.\n#define nCircles 64\n#define PI 3.141592\n#define dog 0.25\n\nvec2 rotate2D(vec2 _st, float _angle)\n{\n\t_st -= 0.5;\n    _st = mat2(\n        cos(_angle),-sin(_angle),\n        sin(_angle),cos(_angle)\n    ) * _st;\n    _st += 0.5;\n    \n    return _st;\n}\n\nfloat ring(float e0, float d, float f)\n{\n    return smoothstep(e0, e0 + d, f) - smoothstep(e0 + d, e0 + 2. * d, f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalize uv and account for aspect ratio\n    vec2 uv = fragCoord / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    uv.x = (uv.x - 0.5) * ar + 0.5;\n\n    // Preserve original uv\n    vec2 p = uv;\n    \n    float t = iTime * td;\n    \n    float even_t = 0.5 * (tan(t) + 1.0);\n    even_t *= -dog;\n    \n    float odd_t = 0.5 * (tan(t - 0.9) + 1.0);\n    odd_t *= -dog;\n    \n    float rot_t = 2.0 * PI * t * 0.3;\n    \n    vec3 col = vec3(0.0);\n    \n    float angle_d = 2.0 * PI / float(nCircles);\n    float radius = dog;\n    int i = 0;\n    for(; i < nCircles; ++i)\n    {\n        float flag = float(i % 2);\n        \n        float ang = angle_d * float(i);\n        vec2 C = vec2(cos(ang), sin(ang));\n        C *= radius * mix(1., .75, flag);\n        \n        vec2 circ_p = rotate2D(p, mix(-1. * rot_t, rot_t, flag)) - 0.5;\n        float f = length(circ_p - C);\n        \n        for(int j = 0; j < 3; ++j)\n        {\n            float col_d = float(j) * 0.005;\n            float ring_t = mix(odd_t * -1.0, even_t, flag);\n        \tcol[j] += ring(dog, 0.004, f + ring_t + col_d);\n        }\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3yDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 111, 111, 258], [260, 260, 300, 300, 377], [379, 379, 436, 485, 1581]]}
{"id": "wd3yWX", "name": "Mixing Periodic Functions", "author": "Ezra_Szanton", "description": "Interpolates between a circle and a lissajous curve", "tags": ["sine"], "likes": 4, "viewed": 95, "published": "Public", "date": "1601837714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 square(vec2 uv, vec2 point, float size, vec3 color)\n{\n    vec3 col = color;\n    if(uv.x < point.x - size || uv.x > point.x + size || uv.y < point.y - size || uv.y > point.y + size)\n        col = vec3(0);\n    \n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float numPoints = 100.;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy - 0.5;\n    uv.x = uv.x * iResolution.x / iResolution.y;\n    uv *= 4.2;\n    \n    vec3 col = vec3(0.);\n    \n    for(float i = 0.; i < 1.; i += 1./numPoints){\n        vec2 pos = vec2((i-0.5) * 5., 0.5  * sin(iTime*5. + i * 10.));\n        \n        vec2 circle = vec2(0.4 * cos(iTime*0.5 + i * 0.9 * sin(iTime / 10.12) * 100.), 0.5 * sin(iTime/5. + i * 100.));\n        \n        float siny = sin(iTime / 4.)*0.5 + 0.5;\n        \n        vec2 m = mix(pos, circle, siny * siny);\n        \n        if(uv.x - m.x < .5){\n        col += square(uv, m, (uv.y+2.)/100., vec3(0.7, 0.2, abs(fract(i + iTime/4.2234)*2. - 1. )));\n        }\n        \n    }\n    //col += square(uv, vec2(0., 0.), 2.);\n\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3yWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 236], [239, 239, 296, 296, 1163]]}
{"id": "WdccDl", "name": "raymarching belgian glitch", "author": "snolot", "description": "Try to makesome raymarching with post effects", "tags": ["raymarching", "posteffect"], "likes": 8, "viewed": 98, "published": "Public", "date": "1601948381", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// effect from TefK sample 'https://www.shadertoy.com/view/4lGBWV'\n\n\n#define PI 3.14159265358979323846264338327950288\n#define DEG_TO_RAD (PI / 180.0)\n\n#define BEAT (time*170.0/60.0)\n#define time iTime\n#define lofi(x,d) (floor((x)/(d))*(d))\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n\nfloat accum;\nfloat seed;\n\nfloat fractsin(float v){\n  return fract(sin(v*121.445)*34.59);\n}\n\nfloat rand(){\n  seed=fractsin(seed);\n  return seed;\n}\n\n// object transformation\nvec3 rotate_x(vec3 p, float phi){\n    float c = cos(phi);\tfloat s = sin(phi);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\nvec3 rotate_y(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x + s*p.z, p.y, c*p.z - s*p.x);\n}\nvec3 rotate_z(vec3 p, float phi)\n{\n\tfloat c = cos(phi);\tfloat s = sin(phi);\n\treturn vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z);\n}\n\nmat2 r2(float r){ return mat2(cos(r),sin(r),-sin(r),cos(r)); }\n\nvec2 rotatev2(vec2 p, float ang)\n{\n    float c = cos(ang);\n    float s = sin(ang);\n    return vec2(p.x*c - p.y*s, p.x*s + p.y*c);\n}\n\n//-------------------------------------------------\nvec2 sdBox(vec3 p,vec3 r, float id){\n    p=abs(p)-r;\n    return vec2(max(max(p.x,p.y),p.z),id);\n} \n\n//---------------------------------\nfloat g, tt;\n\nvec2 map(in vec3 pos)\n{\n    vec2 d = vec2(1e10, 0.0);\n    float b= asin(sin(pos.z*.2 +  tt));\n    //float an = sin(iTime);\n\t\n    for(int i=0;i<3;i++){\n        pos=abs(pos);\n        pos.xy*=r2(.000148);\n        pos.yz*=r2(iTime*sin(pos.x*.25)*.00025);\n    }\n    \n\n    vec3 q = pos - vec3(0.0,0.0,0.0);\n    q = rotate_x(q, PI * iTime * .25);\n    q = rotate_y(q, -PI * iTime * .35);\n    q = rotate_z(q, -PI * iTime * .5);\n    \n    vec2 d1 = sdBox(q, vec3(0.6,0.5,0.6), .5 );\n    vec2 d2 = sdBox(q, vec3(0.7,0.1,0.7), .5 ); \n    vec2 dt = max(-d1,d2);\n    \n    //g+=0.1/(.01+d1.x*d1.x*999.) * sin(tt  * .3);\n    //g-=0.1/(0.1*dt.x*dt.x*(20.-abs(sin(abs(q.x*.1)-tt*3.))*1.7));\n    \n    d = d.x < dt.x  ? d : dt;\n    \n    q = rotate_y(q,  -PI * iTime * .25);\n    \n    vec2 d3 = sdBox(q, vec3(0.5,0.5,0.5), .3 );\n    vec2 d4 = sdBox(q, vec3(0.6,0.1,0.6), .3 ); \n    dt = max(d3,d4);\n    vec2 d5 = sdBox(q, vec3(0.4,0.8,0.4),  .5 );\n    vec2 dt2 = max(-d5, dt);\n    g+=(0.1/(.01+d5.x*d5.x*999.) * sin(iTime  * .5));\n    d = d.x < dt.x  ? d : dt2;\n    \n    dt = max(-d5,d);\n\t\n    d = d.x < dt.x  ? d : dt;\n    \n    q = rotate_z(q, PI * iTime * .5);\n    vec2 d6 = sdBox(q, vec3(.3,0.1, .3), .7 );\n    \n    \n    d = d.x < d6.x  ? d : d6;\n    \n    return d;\n}\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    const float ep = 0.0001;\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    return normalize( e.xyy*map( pos + e.xyy*ep ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*ep ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*ep ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*ep ).x );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, float tmin, float tmax, const float k )\n{\n\tfloat res = 1.0;\n    float t = tmin;\n    for( int i=0; i<50; i++ )\n    {\n\t\tvec2 h = map( ro + rd*t );\n        res = min( res, k*h.x/t );\n        t += clamp( h.x, 0.02, 0.20 );\n        if( res<0.005 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec2 glitch(vec2 v){\n    \n  vec2 vt=v;\n  for(int i=0;i<6;i++)\n  {\n    float fac=4.0*pow(2.2,-float(i));\n    float s=fractsin(lofi(vt.x,1.6*fac));\n    s+=fractsin(lofi(vt.y,0.4*fac));\n    s+=fractsin(time);\n    float proc=fractsin(s);\n    vt+=0.2*step(proc,0.4*exp(-3.0*mod(BEAT,8.0))-0.01)*(vec2(\n      fractsin(s+22.56),\n      fractsin(s+17.56)\n    )-0.5);\n  }\n  return vt;\n}\n\n#define AA 2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.y += .2*tan(-.5*(iTime+1.4*sin(iTime*.8+.05))+.6*fragCoord.y/iResolution.y);\n    \n    tt=mod(iTime,62.8318);\n    \n   vec3 tot = vec3(.5,0.0,0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n \t\t\n        p = glitch(p);\n        vec3 ro = vec3(0.0,2.5,4.0);\n        vec3 rd = normalize(vec3(p-vec2(0.0,1.6),-2.5));\n\n        vec2 t = vec2(.1);\n        for( int i=0; i<64; i++ )\n        {\n            vec3 p = ro + t.x*rd;\n            vec2 h = map(p);\n            if( abs(h.x)<0.001 || t.x>11.0 ) break;\n            t.x+=h.x;t.y=h.y;\n        }\n\n        vec3 col = vec3(0.0);\n\t\t\n        \n        if( t.x<11.0 )\n        {\n            vec3 _col;\n            \n            if(t.y == .3)\n                _col = vec3(1., .7, 0.0);\n            else if(t.y == .5)\n                _col = vec3(1., 0.0, 0.0);\n            else if(t.y == .7)\n                _col = vec3(0.0, 0.0, 0.0);\n            \n            vec3 pos = ro + t.x*rd;\n            vec3 nor = calcNormal(pos);\n            //vec3 refl = reflect(rd, nor);\n            //vec3 r = texture(iChannel0,refl).rgb;\n            vec3  lig = normalize(vec3(1.0,0.8,-0.2));\n            float dif = clamp(dot(nor,lig),0.0,1.0);\n            float sha = calcSoftshadow( pos, lig, 0.001, 1.0, 16.0 );\n            float amb = 0.5 + 0.5*nor.y;\n            col = vec3(0.05,0.1,0.15)*amb + (_col )  *dif*sha  + g *.005 ;\n        }\n\n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\t\n\tfragColor = vec4( tot, 1.0 );\n    \n    fragColor.rgb *= smoothstep( 1.5, 0.4, length(fragCoord.xy-iResolution.xy*.5)/length(iResolution.xy*.5) );\n    vec3 grunge = texture( iChannel1, fragCoord/iChannelResolution[1].xy + vec2(.7549,.5698)*float(iFrame) ).rgb;\n    fragColor.rgb = mix( fragColor.rgb*mix( vec3(1), grunge, .2 ), grunge*vec3(.3,1,.6), .02 );\n    fragColor.rgb *= 1.+.4*sin(6.283185*fragCoord.y*.5*.618+iTime);\n    fragColor.rgb *= mix( 1., 1.8, smoothstep(.0,.3,cos(iTime/7.)) );    \n    fragColor.rgb = max(vec3(0),fragColor.rgb-.02);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdccDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 364, 388, 388, 428], [430, 430, 443, 443, 483], [485, 510, 543, 543, 641], [642, 642, 676, 676, 768], [769, 769, 803, 803, 895], [897, 897, 914, 914, 959], [961, 961, 995, 995, 1092], [1094, 1146, 1182, 1182, 1243], [1246, 1296, 1319, 1319, 2543], [2544, 2608, 2640, 2640, 2882], [2884, 2946, 3033, 3033, 3294], [3296, 3296, 3316, 3316, 3672]]}
{"id": "wdcczs", "name": "Dodecahedron & Icosahedron", "author": "gaz", "description": "sdf", "tags": ["icosahedron", "dodecahedron"], "likes": 3, "viewed": 147, "published": "Public", "date": "1601508957", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void rot3(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 q=cross(a,p),u=cross(q,a);\n\tp=u*cos(t)+q*sin(t)+a*dot(p,a);   \n}\n\n#define sabs(p) sqrt((p)*(p)+2e-3)\n#define smin(a,b) (a+b-sabs(a-b))*.5\n#define smax(a,b) (a+b+sabs(a-b))*.5\n\nfloat dodec(vec3 p,float r){\n\tfloat G=sqrt(5.)*.5+.5;\n\tvec3 n=normalize(vec3(G,1,0));\n\tfloat d=0.;\n    p=sabs(p);\n    d=smax(d,dot(p,n));\n    d=smax(d,dot(p,n.yzx));\n    d=smax(d,dot(p,n.zxy));\n\treturn d-r;\n}\n\nfloat icosa(vec3 p,float r){\n\tfloat G=sqrt(5.)*.5+.5;\n\tvec3 n=normalize(vec3(G,1./G,0));\n\tfloat d=0.;\n    p=sabs(p);\n    d=smax(d,dot(p,n));\n    d=smax(d,dot(p,n.yzx));\n    d=smax(d,dot(p,n.zxy));\n\td=smax(d,dot(p,normalize(vec3(1))));\n    return d-r;\n}\n\nfloat map(vec3 p){\n\trot3(p,vec3(1,2,3),iTime);\n\treturn (fract(iTime*.2)<.5)?icosa(p,1.):dodec(p,1.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 rd=normalize(vec3((fragCoord-.5*iResolution.xy)/iResolution.y,1));\n\tvec3 ro=vec3(0,0,-3.5);\n\tfloat i,g,e;\n\tfor(i=0.;++i<50.;){\n\t\tg+=e=map(g*rd+ro);\n\t\tif(e<.001)break;\n\t}\n\tfragColor+=3./i;  \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcczs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 39, 39, 127], [239, 239, 267, 267, 447], [449, 449, 477, 477, 701], [703, 703, 721, 721, 805], [807, 807, 864, 864, 1062]]}
{"id": "wdcyW2", "name": "Fab6 #inktober2020 \"roden\" 275ch", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: \n[img]https://i.imgur.com/b3gMiu0.png[/img]\n\nfractal: because roden fast turn to many :-p", "tags": ["2tweets", "short", "golf", "inktober2020"], "likes": 11, "viewed": 245, "published": "Public API", "date": "1601741047", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define C(r) clamp( 1. - R.y/2.* ( length(U) - r ) , 0.,1. )           //\nvoid mainImage(out vec4 O, vec2 u) {\n    vec2 R = iResolution.xy,\n         U = ( u+u - R ) / R.y; U.y += .6;\n    O *=  C(.1);                U.y -= .2;\n    for(float i=1.; i<7.; i+= i==1. ? .1 : 1. )\n        U.x = abs(U.x),\n        O += (1.-O.a) * C(.5) / vec4(i,i,i,1),\n        U = (U/.6-.9) * mat2(cos(.8+.3*sin(6.*iTime)+vec4(0,33,11,0))),\n        R *= .6;}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[74, 74, 110, 110, 434]]}
{"id": "WdcyWf", "name": "OverlaySST", "author": "Del", "description": "Attract & Repel shader overlay - Red=Repel, Blue=Attract\nHold Mouse for radial\n - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]", "tags": ["lines", "sin", "pow"], "likes": 3, "viewed": 180, "published": "Public API", "date": "1601827172", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Attract & Repel shader overlay - Red=Repel, Blue=Attract\n\nfloat Lines(float x,float dir)\n{\n    //x+=sin(iTime*2.0)*1.5; // offset\n    float d = 1.0-abs(x);\n    float r = pow(abs(x*0.5),3.0);\n\tfloat v = 0.75 + 0.5*sin((r+dir)/0.006);\n    return v * smoothstep(-0.2,0.8,d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (iResolution.xy - 2.0*fragCoord.xy)/iResolution.y; \n    float t = iTime;\n\n    uv += (sin(t*1.5+uv*16.0)*0.025).yx;   \t// +=wibble\n    if (iMouse.z>0.5)\n        uv = vec2(dot(uv,uv));\n    \n    // Change X,Y,Direction,Colour every 4 seconds\n    float mcount = t - mod(t,4.0);\n    float cmult1 = step(8.0, mod(mcount,16.0));\n    float cmult2 = step(4.0, mod(mcount,8.0));\n    float speed = mix(0.035,-0.035,cmult1);\n    vec3 col = mix(vec3(0.4,0.5,0.9), vec3(0.9,0.2,0.2), cmult1);\n    float v = mix(uv.x,uv.y,cmult2);\n    float c = Lines(v,t*speed);\n\tfragColor = vec4(col*c,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 61, 93, 132, 276], [278, 278, 335, 335, 926]]}
{"id": "wdcyWs", "name": "INKTtober - Keep", "author": "Flopine", "description": "Fourth day of the Inktober challenge! For 2020 I'm using the Inkt-Tober list: https://twitter.com/Trish_Argh/status/1304878524797419525", "tags": ["3d", "raymarching", "sound", "octopus", "twitch", "inktober"], "likes": 9, "viewed": 102, "published": "Public", "date": "1601972751", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.283185\n\n#define time iTime\n#define dt(speed) fract(time*speed)\n#define swanim(speed) floor(sin(dt(speed)*TAU)+1.)\n\n#define moda(puv,rep) float a=mod(atan(puv.y,puv.x),TAU/rep)-(TAU/rep)*0.5;puv=vec2(cos(a),sin(a))*length(puv)\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define hash21(x) fract(sin(dot(x,vec2(12.5,32.4)))*1284.4)\n\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r,abs(p.z)-h);}\n\nfloat caps( vec3 p, vec3 a, vec3 b, float r )\n{\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length (pa - ba*h) - r*h;\n}\n\n#define anim (swanim(0.1) < 0.5)\nfloat g1 = 0.;\n\nfloat SDF (vec3 p)\n{\n    if (anim) p.yz *= rot(PI/2.);\n\n    float s = length(p-vec3(0.,2.,0.))-0.6;\n    g1 += 0.01/(0.01+s*s);\n    float body = caps(p,vec3(0.,8.,0.),vec3(0.,4.5,0.), 1.);\n\n    p.xz *= rot(sin(p.y*0.5+dt(0.1)*TAU));\n    moda(p.xz, 7.);\n    p.z += cos(p.y*2.+dt(.5)*TAU)*0.1;\n    p.x -= 1.2-s*0.4;\n    float d = smin(cyl(p.xzy, 0.05+p.y*0.06, 4.),cyl(p.xzy-vec3(0.,0.,4.),0.25, 0.1),0.5);\n\n    d = min(d, s);\n\n    d = smin(d,body,0.3);\n\n    return d;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    float dither = hash21(uv);\n\n    vec3 ro;\n    if (anim) ro = vec3(0.001,0.001,-1.2);\n    else   ro = vec3(0.001,3.5,-5.); \n\n    vec3 rd = normalize(vec3(uv,1.)), p = ro, col = vec3(0.,0.,0.05);\n\n    bool hit = false;\n    float shad, d = 0.;\n\n    for (float i=0.; i<64.;i++)\n    {\n        d = SDF(p);\n        if (d<0.01)\n        {\n            hit=true; shad = i/64.; break;\n        }\n        d *= 0.5+dither*0.2;\n        p += d*rd;\n    }\n\n    if (hit) col = vec3(shad);\n    \n    col += g1*vec3(length(uv)*0.5,0.05,0.3)*texture(iChannel0, vec2(0.0001,0.25)).r*2.;\n\n    fragColor = vec4(col,1.);\n}", "image_inputs": [{"id": "XsXGzn", "previewfilepath": "/media/ap/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/29de534ed5e4a6a224d2dfffab240f2e19a9d95f5e39de8898e850efdb2a99de.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcyWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 691, 732, 732, 825], [827, 827, 865, 865, 904], [906, 906, 953, 953, 1081], [1132, 1132, 1152, 1152, 1599], [1601, 1601, 1657, 1657, 2318]]}
{"id": "WddcDf", "name": "Stable cone frustum raytracing", "author": "M_cgode", "description": "A shader for raytracing a stable cone frustum (or a cone if you need to), useful when working with cone frustums when the angle gets really low.\nHandles the limit case where the cone frustum becomes a cylinder.", "tags": ["raytracing", "cone", "frustum", "conefrustum"], "likes": 2, "viewed": 91, "published": "Public", "date": "1602061927", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n    \nstruct Sphere {\n    vec3 center;\n    float radius;\n};\n    \n    \nstruct ConeFrustum {\n\tvec3 origin;\n    vec3 axis;\n    vec2 radii;\n    float height;\n};\n    \n \n// Perspective projection ray from screen coordinate\nRay getScreenRay(in vec2 uv)\n{\n    float vFov = 3.14 / 6.0;\n    float hFov = atan(iResolution.x / iResolution.y * tan(vFov));\n    \n    vec2 coord = 2.0 * uv - 1.0;\n    \n    //// Orthographic projection\n    //return Ray(2. * vec3(coord.x * iResolution.x / iResolution.y, coord.y, -2), vec3(0, 0, 1));\n    \n    float dv = atan(coord.y * tan(vFov));\n    float dh = atan(coord.x * tan(hFov));\n    \n    vec3 direction = vec3(coord.x * iResolution.x / iResolution.y, coord.y, -1.5);\n    return Ray(vec3(0,0,3), normalize(direction));\n}\n\nbool intersectConeFrustum( in Ray ray, in ConeFrustum cone, out float t, out vec3 normal )\n{\n    float dr = cone.radii.y - cone.radii.x;\n    float r = 1. + pow(dr / cone.height, 2.);\n    float R = cone.radii.x * dr / cone.height;\n    \n    vec3 D = ray.origin - cone.origin;\n    float DdA = dot(D, cone.axis);\n    float DdD = dot(D, D);\n    float VdA = dot(ray.direction, cone.axis);\n    float VdD = dot(ray.direction, D);\n    float VdV = dot(ray.direction, ray.direction);\n    \n    float c0 = pow(cone.radii.x, 2.) + 2. * R * DdA + r * pow(DdA, 2.) - DdD;\n    float c1 = R * VdA + r * DdA * VdA - VdD;\n    float c2 = r * pow(VdA, 2.) - VdV;\n    \n    // Quadratic equation, solve with discriminant\n    if ( c2 != 0. ) {\n    \tfloat discr = c1 * c1 - c2 * c0;\n        \n        // No real solution, no intersection\n        if ( discr < 0. ) \n            return false;\n        \n        // Two intersection points. Select best or reject.\n        else if ( discr > 0. ) {\n        \tfloat root = sqrt(discr);\n            int quantity = 0;\n            \n            float x0 = (-c1 -root) / c2;\n            vec3 p = D + x0 * ray.direction;\n            \n            // Check if valid ray-cone section intersection\n            float d = dot(cone.axis, p);\n            if (x0 >= 0. && d >= 0. && d <= cone.height) {\n                vec3 n = normalize(p - d * cone.axis);\n                float theta = atan((cone.radii.x - cone.radii.y) / cone.height);\n                normal = normalize(cone.axis * sin(theta) + cos(theta) * n);\n            \tt = x0;\n                quantity += 1;\n            } \n            \n            float x1 = (-c1 + root) / c2;\n            p = D + x1 * ray.direction;\n            d = dot(cone.axis, p);\n            \n            // Check if valid ray-cone section intersection and if x0 isn't a more adequate solution\n            if (x1 >= 0. && (x1 < x0 || quantity == 0) && d >= 0. && d <= cone.height) {\n                vec3 n = normalize(p - d * cone.axis); \n                float theta = atan((cone.radii.x - cone.radii.y) / cone.height);\n                normal = normalize(cone.axis * sin(theta) + cos(theta) * n);\n                t = x1;\n                quantity += 1;\n            }\n            \n            return quantity > 0;\n            \n        // One intersection. Ray tangent to the cone surface, but not parallel\n        } else {\n            float x = -c1 / c2;\n            vec3 p = D + x * ray.direction;\n            float d = dot(cone.axis, p);\n            \n            // Check if valid ray-cone section intersection\n            if (x > 0. && d >= 0. && d <= cone.height) {\n                vec3 n = normalize(p - d * cone.axis); \n                float theta = atan((cone.radii.x - cone.radii.y) / cone.height);\n                normal = normalize(cone.axis * sin(theta) + cos(theta) * n);\n                t = x;\n                return true;\n            }\n            return false;\n        }\n    \n    // Linear solution. Ray is parallel to cone surface.\n    } else if (c1 != 0.) {\n        float x = 0.5 * c0 / c1;\n        vec3 p = D + x * ray.direction;\n        float d = dot(cone.axis, p);\n        if (x > 0. && d >= 0. && d <= cone.height) {\n            vec3 n = normalize(p - d * cone.axis); \n            float theta = atan((cone.radii.x - cone.radii.y) / cone.height);\n            normal = normalize(cone.axis * sin(theta) + cos(theta) * n);\n            t = x;\n            return true;\n        }\n        return false;\n    }\n    \n    return false;        \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 origin; vec3 dir;\n    Ray screenRay = getScreenRay(uv);\n    screenRay.origin += 0.2 * screenRay.direction;\n    \n    float t = PI +iTime;\n    vec3 normal = vec3(0,0,0);\n    \n    vec3 axis = vec3(0,1,0.4);\n    ConeFrustum cone;\n    cone.origin = vec3(0,-1.2,0.1);\n    cone.axis = normalize(axis);\n    cone.radii = vec2(0.7, 0.7 + 0.4 * cos(iTime / 3.));\n    cone.height = 2.;\n    \n    bool intersect = intersectConeFrustum(screenRay, cone, t, normal);\n    \n\n    // Output to screen \n    if (intersect) {\n        fragColor = vec4(vec3(1) * (dot(normalize(-vec3(1,1,1)), -normal) * 0.7 + 0.3), 1);\n        fragColor = vec4(normal * 0.5 + 0.5, 1);\n    } else {\n        fragColor = vec4(screenRay.direction*0.5+0.5,1.0);\n        fragColor = vec4(1);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddcDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[235, 288, 318, 318, 817], [819, 819, 911, 911, 4303], [4306, 4306, 4363, 4413, 5308]]}
{"id": "wddcDN", "name": "大龙猫  - Wetshader", "author": "totetmatt", "description": "Still learning 3D . \nExperiment based on @evvvvil_ ray caster. ", "tags": ["3d"], "likes": 6, "viewed": 198, "published": "Public API", "date": "1601827368", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 z,v,e=vec2(.001,-.001); \n\n\nmat2 r(float a){\n    float c=cos(a),s=sin(a);\n    return mat2(c,s,-s,c);\n}\nvoid md(inout vec2 uv,vec2 p){\n    uv = abs(uv) - p;\n    if(uv.x < uv.y) uv.xy = uv.yx;\n}\nvec2 pModMirror2(inout vec2 p, vec2 size) {\n    vec2 halfsize = size*0.5;\n    vec2 c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    p *= mod(c,vec2(2.))*2. - vec2(1.);\n    return c;\n}\nfloat pMod1(inout float p, float size) {\n    float halfsize = size*0.5;\n    float c = floor((p + halfsize)/size);\n    p = mod(p + halfsize, size) - halfsize;\n    return c;\n}\nvec2 sdf(vec3 p){\n\n       p.z   -=(iTime);\n       p.xy  *=r(iTime*.2);\n       float c= pMod1(p.z,12.);\n       p.xy  *=r(c*.5);\n    p.x = abs(p.x)-12.5;\n    p.y = abs(p.y)-4.5;\n      p.xy  *=r(iTime*.5);\n     vec2 h,t=vec2(length(p)-2.,4.);\n\n   \n        p.x = abs(p.x)-1.3;\n        p.y -=1.8;\n     h = vec2(length(p)-1.,5.);\n     t = t.x< h.x ? t : h; \n     t.x*=.7;\n\n \n    return t;\n\n}\n#define TRLIMIT 256.\nvec2 tr(vec3 ro, vec3 rd){\n    vec2 h,t=vec2(.1);\n    for(float i=0.;i<TRLIMIT;i++){\n        h= sdf(ro+rd*t.x);\n        if(h.x < .0001 || t.x > TRLIMIT) break;\n        t.x+=h.x;\n        t.y=h.y;\n    }\n    if(t.x>TRLIMIT) t.y=0.;\n    return t;\n    \n}\n\n#define a(d) clamp(sdf(po+no*d).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,sdf(po+ld*d).x/d)\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec4 cam = vec4(sin(iTime*.5)*.5,cos(iTime*1.),10.0,1.50);\n    vec2 uv = (fragCoord.xy -.5* iResolution.xy)/iResolution.y;\n    vec3 ro = vec3(cos(cam.w+cam.x)*cam.z, cam.y,sin(cam.w+cam.x)*cam.z);\n   \n    vec3 cw = normalize(vec3(0.)-ro);\n    vec3 cu = normalize(cross(cw,vec3(0.,1.,0.)));\n    vec3 cv = normalize(cross(cu,cw));\n    vec3 rd = mat3(cu,cv,cw)*normalize(vec3(uv,.5));\n    \n    vec3 co, fo = vec3(.0)-length(uv)*.1-rd.y*.1;\n    co = fo;\n    vec3 ld = normalize(vec3(1.2,1.3,10.5));\n    \n    vec2 z = tr(ro,rd);\n    float t = z.x;\n    vec3 al ;\n    if(z.y > 0.) { \n        vec3 po  = ro+rd*t;\n        vec3 no = normalize(e.xyy*sdf(po+e.xyy).x +\n        e.yyx*sdf(po+e.yyx).x +\n        e.yxy*sdf(po+e.yxy).x +\n        e.xxx*sdf(po+e.xxx).x );\n        if(z.y ==3.){\n        al = vec3(1.0,1.0,1.0);\n        }\n        if (z.y == 4.) {\n            al=vec3(1.0,.0,.0);\n        }\n        if(z.y == 5.) {\n         al = vec3(1.0,1.0,1.0);\n        }\n        float dif = max(0.,dot(no,ld)),\n        fr = pow(1.+dot(no,rd),4.), //Fersnel\n        sp = pow(max(dot( reflect(-ld,no),-rd),0.),40.); //specular\n        co = mix(sp+al*(a(.05)*a(.1)+.2)*(dif+s(2.)),fo,min(fr,.5));\n    }\n    \n    fragColor = vec4(pow(co,vec3(.945)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddcDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 32, 48, 48, 106], [107, 107, 137, 137, 196], [197, 197, 240, 240, 411], [412, 412, 452, 452, 585], [586, 586, 603, 603, 971], [993, 993, 1019, 1019, 1242], [1336, 1336, 1391, 1391, 2629]]}
{"id": "WddcWB", "name": "Fab2 #inktober2020 \"wisp\"  176ch", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: \n[img]https://i.imgur.com/b3gMiu0.png[/img]\n", "tags": ["2tweets", "short", "golf", "inktober2020"], "likes": 5, "viewed": 228, "published": "Public API", "date": "1601649581", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// -10 by Xor\n\n#define S O  = min( O, abs( .1*U* sin(8.*U-iTime) - U.y ) ), \\\n          U *= mat2(1,.2,-.2,1)                       //\nvoid mainImage(out vec4 o, vec2 u) {\n    vec2 R = iResolution.yy, O=R/R,\n         U = u / R -.5;\n    U.x > 0. && U.x < 1.\n     ?  S, S, S,\n        o += 1. - O.x *R.y/3.     : o; }    /*\n\n\n\n            \n\n// --- 176 chars\n\n//#define S O  = min( O, abs( .1* sin(8.*U.x) - U.y ) ), // old variant\n#define S O  = min( O, abs( .1*U.x* sin(8.*U.x-iTime) - U.y ) ), \\\n          U *= mat2(1,.2,-.2,1)                       //\n#define mainImage(o,u)                                 \\\n    vec2 R = iResolution.xy, O=R-R,                    \\\n         U = u / R.y -.5;                              \\\n    U.x > 0. && U.x < 1.                               \\\n     ?  O++, S, S, S,                                  \\\n        o += 1. - O.x *R.y/3.     : o                 /*\n\n/**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddcWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 135, 171, 171, 314]]}
{"id": "wddcWs", "name": "Interference Grid", "author": "Ezra_Szanton", "description": "Making a grid using the interference patterns of perpendicular sin waves", "tags": ["interferencepatterns"], "likes": 2, "viewed": 81, "published": "Public", "date": "1602037605", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 paint(vec3 current, vec3 new)\n{\n    float threshold = (sin(iTime * 3.)+.7)/2.5;\n    \n    if(new.x < threshold && new.y < threshold && new.z < threshold)\n        return current;\n    \n    return new;\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    \n    return mat2(c, -s, s, c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    uv *= 40.;\n    uv *= Rot(iTime/10.);//3.14159 / 4.);\n    \n    vec3 col = 0.5 + 0.5*cos(uv.xyx/40.+vec3(0,2,4));\n\n    vec3 baseCol = vec3(0.2, 0.6, 0.8);\n    col = paint(col, baseCol * vec3(sin(uv.x) / 2. + sin(uv.y) / 2.) + 0.01);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddcWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 204], [206, 206, 225, 225, 306], [308, 308, 365, 365, 698]]}
{"id": "wddyzl", "name": "jeff's mandelbro", "author": "jefflimbacher", "description": "yyms", "tags": ["mandelbrot"], "likes": 1, "viewed": 69, "published": "Public", "date": "1601567922", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float R = 10000.0;\n    // Normalized pixel coordinates (from 0 to 1)\n    \n    vec2 uv = (fragCoord - iResolution.xy / 2.)/iResolution.x * 4.;\n    uv.x = uv.x;\n    float cx = uv.x / (iTime * iTime * iTime) + 0.26010 ;\n    float cy = uv.y / (iTime * iTime * iTime) + 0.49210 ;\n    float zx = 0.0;\n    float zy = 0.0;\n    float iteration = 0.0;\n    float max_iteration = 1000.0;\n  \n    while (zx * zx + zy * zy < R*R  &&  iteration < max_iteration) \n    {\n        float xtemp = zx * zx - zy * zy;\n        zy = 2. * zx * zy  + cy;\n        zx = xtemp + cx;\n    \n        iteration = iteration + 1.;\n    }\n  \n    if (iteration == max_iteration){\n        fragColor = vec4(0.);\n    }\n    else{\n        fragColor = vec4(hsv2rgb(vec3(1.0 - iteration / max_iteration,1.0,1.0)),1.);\n    }\n\n    // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddyzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 154], [157, 157, 214, 214, 1021]]}
{"id": "wdGcD3", "name": "dot9999", "author": "tripzilch", "description": "yeaaaa GLSL stippling", "tags": ["flarmclaarm"], "likes": 4, "viewed": 217, "published": "Public", "date": "1603922760", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PHI1 0.6180339887498949\n#define PHI4096 6627.4672179195695\n\nvec2 hash(vec2 seed)\n{\n    return fract(sin(seed - PHI1 * seed.yx)*PHI4096);\n}\n\nfloat stip(vec2 p, float r) {\n\treturn smoothstep(.9 * r, r, length(p));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.y;\n    float R = 32.0;\n\n//    float sa = hash( dot( fragCoord, vec2(12.9898, 78.233) ) + 1113.1*hash(iTime));\n    \n    float cam = smoothstep(.6, .05, dot(texture( iChannel0, fragCoord / iResolution.xy).xyz, vec3(.3,.6,.1)));\n    float col = 1.0;\n    for (float i = -1.; i < 2.; i++) {\n        for (float j = -1.; j < 2.; j++) {\n            vec2 ij = vec2(i, j);\n            for (float k = 0.; k < 4.; k++) {\n                float t = (1. + k) * 0.25;\n                vec2 xf = uv * R + vec2(0, iTime * t * 1.);\n                vec2 xi = floor(xf);\n                xf -= xi + .5;\n                vec2 off = 1. * (hash(xi + ij + t * vec2(2223.5, 3125.0)) - .5);\n                col *= stip(xf + off - ij, cam * .7 * t * t);\n            }\n        }\n    }\n    // Output to screen\n    fragColor = vec4(col,col,col,1.0);\n}", "image_inputs": [{"id": "4sf3zn", "previewfilepath": "/presets/webcam.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/webcam.png", "ctype": "webcam"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGcD3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 90, 90, 146], [148, 148, 177, 177, 221], [223, 223, 278, 278, 1134]]}
{"id": "wdGcDR", "name": "Through the streets into time.", "author": "90k9", "description": "How do I use resolution as a variable?", "tags": ["is50a"], "likes": 0, "viewed": 41, "published": "Public", "date": "1602574787", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 xy = fragCoord.xy / iResolution.xy;\n    \n   vec4 texColor = texture(iChannel0,xy);\n   vec4 texColor2 = texture(iChannel1,xy);\n   vec4 texColor3 = texture(iChannel2,xy);\n   vec4 texColor4 = texture(iChannel3,xy);\n\n   \n    if (iTime < 10.0) {\n    texColor.r *= abs(sin(iTime));\n    texColor.g *= abs(cos(iTime));\n    texColor.b *= abs(sin(iTime));\n     texColor.xy = abs(sin(xy/iTime-2.0));\n   \n        fragColor = texColor;    \n    }\n    \n     else if ( iTime > 10.0 && iTime < 20.0) {\n    texColor2.r *= abs(cos(iTime));\n    texColor2.g *= abs(sin(iTime));\n    texColor2.b *= abs(cos(iTime));\n       texColor2.xy = abs(cos(xy*iTime - 10.0 ));\n         \n      fragColor = texColor2;   \n         \n    }\n    \n    else if ( iTime > 20.0 && iTime < 30.0) {\n    texColor3.r *= abs(sin(iTime));\n    texColor3.g *= abs(cos(iTime));\n    texColor3.b *= abs(sin(iTime));\n          texColor3.xy = abs(sin(xy/iTime- 20.0));\n        \n      fragColor = texColor3;\n        \n    }\n    \n     else if ( iTime > 30.0 && iTime < 40.0) {\n    texColor4.r *= abs(cos(iTime));\n    texColor4.g *= abs(sin(iTime));\n    texColor4.b *= abs(cos(iTime));\n         texColor4.xy = abs(cos(xy*iTime - 30.0 ));\n         \n        fragColor = texColor4;    \n    }\n    else {\n         texColor.b *= abs(cos(iTime));\n          fragColor = texColor;    \n    }\n    \n \n} ", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGcDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1394]]}
{"id": "WdGcRy", "name": "cloth bells", "author": "melissaran", "description": ":)", "tags": ["raymarching"], "likes": 10, "viewed": 195, "published": "Public", "date": "1603083396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\n\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\nvec3 proj(vec3 a , vec3 b){\n    return (dot(a,b)/dot(b,b))*b;\n}\n\nfloat line(vec3 a, vec3 b, vec3 c, float r){\n    vec3 norm = (a-c)-proj(a-c,a-b);\n    return length(norm)-r;\n}\n\n\nfloat bell(vec3 p, float o){\n    vec3 n=vec3(0.,-1.,0.);\n    vec3 pproj=vec3(p.x,0.,p.z);\n    \n    float sintime=sin(iTime+o);\n    \n    n=rotate_x(n,sintime*0.2);\n    p=rotate_x(p,-sintime*0.2);\n\n    float angle=acos(dot(pproj,vec3(1.,0.,0.)/(length(pproj))));\n\n    float plane = dot(p-n*0.1,n);\n    float planar0=-sin(iTime+angle*2.+o+1.)*0.1;\n    float planar1=-abs(sin(iTime+angle*4.+o*2.))*0.2;\n    \n    p*=smoothstep(0.,1.,1.-plane+planar1);\n    \n    //float radial0=0.;\n    float radial0=sin(iTime+angle*3.)*0.07;\n    float radial1=-abs(sin(angle*6.+iTime+o)*0.05);\n\t//float radial0=0.;\n    \n    float r=sintime*0.1+0.6;\n    float f=max(\n        abs(\n            radial0+radial1+(length(p))-r)-0.04/(1.+o),\n        plane+planar0);\n    \n    float bump = 0.01 * texture(iChannel0, p.xy*(5.+o)).r/(1.+o);\n\n    f-=bump;\n        \n    return f;\n}\n\n\nfloat beaded(vec3 a, vec3 b, vec3 p){\n   float r=abs(sin(dot(p,a-b)*0.5)*0.1)+0.01;\n    return line(a,b,p,r);\n}\n\n\n\nfloat map(vec3 p){\n    float bells=min(min(bell(p,0.), bell(p*0.75+vec3(0.,-0.5,0.),1.)),bell(p*0.5+vec3(0.,-0.7,0.),2.));\n    vec3 a=vec3(-2.,20.,10.);\n    vec3 b=vec3(-3.,0.,4.);\n    \n    vec3 c=vec3(0.,10.,10.);\n    vec3 d=vec3(3.,-5.,4.);\n    \n    vec3 e=vec3(0.,10.,2.);\n    vec3 f=vec3(2.,-5.,-2.);\n    \n    vec3 pwarp= vec3(p.xy+sin(iTime)*0.1,p.z);\n    \n    float lines= min(beaded(a,b,pwarp),beaded(c,d,pwarp));\n    lines=min(lines,beaded(e,f,pwarp));\n    return min(bells,lines);\n}\n\nvec3 norm(vec3 p){\n    //approx\n    \n    float d=map(p);\n    vec2 e = vec2(0.02,0.);\n    vec3 n= d- vec3(map(p-e.xyy),\n                    map(p-e.yxy),\n                    map(p-e.yyx));\n    \n                    \n\treturn normalize(n);\n}\n\n\nfloat march(vec3 ro, vec3 rd){\n    float d=0.;\n    for(int i=0;i<80;i++){\n        vec3 p= ro+d*rd;\n        float dist = map(p);\n        d+=dist;\n        if(abs(dist)<0.01 || d>10.) break;\n    }\n    return d;\n}\n\nfloat getLight(vec3 p, vec3 n){\n    vec3 lp=vec3(0.,5.,-4.);\n    vec3 l=normalize(lp-p);\n    float d =march(p,l);\n    float nl = dot(n,l)*5.;\n    if(d<length(p-lp))nl*=0.1;\n    \n    \n    \n    \n\tvec3 r = reflect(l,n);\n\t\n\tfloat reflectance = dot(l,r)*.5+.5;\n    \n    \n    float fog=1./(1.+(p.z*p.z));\n    //float fog=1.;\n    \n    \n    return nl*reflectance*reflectance*fog;\n    //return nl;\n}\n\nvec3 pal(float i, vec3 p, vec3 n){\n    p.y=clamp(0.,1.,p.y);\n    float T = 1500. + 1400.*i;\n    vec3 L = mix(vec3(6.4, 1.6, 3.4),vec3(8.4, 6.4, 6.4),1.2-p.y);\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    vec4 c =texture(iChannel1, p.xz*0.1)*(p.y+1.);\n    c=c*c*c*c;\n    c*=max(dot(n,vec3(0.,1.,0.)),0.);\n    return 1.0-exp(-8e8/L)+c.xyz;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 ro= vec3(0.,0.5,-3.);\n    vec3 rd= normalize(vec3(uv.x,uv.y,1.2));\n\n    \n    float d= march(ro,rd);\n    // Output to screen\n    \n        if(d>10.){\n            //vec4 col = texture(iChannel2,rd);\n            vec4 col = vec4(0.);\n            fragColor=vec4(col.xyz,1.);\n            \n        }else{\n            vec3 n = norm(ro+d*rd);\n    fragColor = vec4(pal(getLight(ro+d*rd,n)*2.,ro+d*rd,n),1.0);\n        }\n            \n    \n    /*\n    if(d>20.){\n        float star = smoothstep(0.7, 1.0,texture(iChannel1, uv*0.5).r);\n        float star1 =smoothstep(0.7, 1.0,texture(iChannel1, uv*0.5+0.005).r);\n        float grad=(sin(iTime)*0.4-uv.y+uv.x*0.4)*0.5;\n        fragColor = vec4(grad,star,star1,1.);\n    }*/\n\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}, {"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "4dX3zn", "previewfilepath": "/media/ap/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/550a8cce1bf403869fde66dddf6028dd171f1852f4a704a465e1b80d23955663.png", "ctype": "cubemap"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGcRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 153], [155, 155, 191, 191, 309], [311, 311, 338, 338, 374], [376, 376, 420, 420, 486], [489, 489, 517, 517, 1335], [1338, 1338, 1375, 1375, 1449], [1453, 1453, 1471, 1471, 1944], [1946, 1946, 1964, 1977, 2183], [2186, 2186, 2216, 2216, 2395], [2397, 2397, 2428, 2428, 2787], [2789, 2789, 2823, 2823, 3148], [3152, 3152, 3208, 3208, 3986]]}
{"id": "WdGcW3", "name": "Parallel Dragon Curve", "author": "Blake447", "description": "Simple demonstration rendering a dragon curve using a fully parallel algorithm ideal for use on a GPU. As far as I'm aware I haven't seen any one else use this particular method", "tags": ["fractal", "dragon", "dragoncurve", "harterheighway", "paperfolding"], "likes": 6, "viewed": 158, "published": "Public", "date": "1603834881", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdfLineSegment(vec2 p, vec2 a, vec2 b)\n{\n    float h = clamp(dot(p - a, normalize(b - a)), 0.0, 1.0);\n    return length(p - (a + (b - a) * h) );\n}\n\nfloat sdf0(vec2 uv, vec2 p, vec2 middle_point, float size, float invalidation)\n{\n    float d = sdfLineSegment(uv, p, middle_point);\n    if (invalidation > 0.5)\n    {\n        vec2 offset = p - middle_point;\n\n        d = 0.5;\n    }\n\n    return d;\n}\n\nvec2 T(vec2 v, int i)\n{\n    float t = (float(i) + 1.0) * 3.14159265 * 0.25;\n\n    float scale = pow(2.0, float(i - 1) / 2.0);\n    mat2x2 change_of_basis = mat2x2(cos(t), sin(t), -sin(t), cos(t)) / scale;\n    mat2x2 invert_of_basis = mat2x2(cos(t), -sin(t), sin(t), cos(t)) * scale;\n\n    vec2 v_index = floor((change_of_basis*v)*0.5 + vec2(0.5, 0.5));\n    float direction = 1.0 - 2.0 * ( mod(v_index.x + v_index.y + 4096.0, 2.0));\n\n    vec2 v_center = (invert_of_basis*v_index*2.0);\n    vec2 v_off = v - v_center;\n\n    vec2 v_prime = vec2(v_off.x + v_off.y * direction, v_off.y - v_off.x * direction) + v_center;\n\n    return v_prime;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv_original = fragCoord/iResolution.xx*5.0;\n    uv_original = mat2x2(cos(iTime*0.1), -sin(iTime*0.1), cos(iTime*0.1), sin(iTime*0.1))*uv_original;\n    \n    \n    vec2 uv = fragCoord/iResolution.xy - vec2(0.5,0.5);\n    uv *= vec2(1.0, iResolution.y/iResolution.x);\n    \n    float sin_time = 7.0 + 7.0 * sin(iTime*0.5);\n    \n    int ITERATIONS = int(sin_time);\n    //int ITERATIONS = 12;\n    const float size = 5.0;\n    \n    \n    for (int k = 0; k < ITERATIONS; k++)\n    {\n        uv = vec2(uv.x + uv.y, uv.y - uv.x);\n    }\n    vec2 uv_scaled = uv * size * 0.5;\n    vec2 uv_midpoint = floor(uv * size*0.5 + vec2(0.5, 0.5));\n\n    vec2 p_cont = uv_scaled;\n\n    vec2 p0 = uv_midpoint + vec2(0.5, 0);\n    vec2 p1 = uv_midpoint + vec2(0, 0.5);\n    vec2 p2 = uv_midpoint - vec2(0.5, 0);\n    vec2 p3 = uv_midpoint - vec2(0, 0.5);\n\n    vec2 m = uv_midpoint;\n\n    vec2 c0 =  vec2(0.5, 0.0);\n    vec2 c1 =  vec2(0.0, 0.5);\n    vec2 c2 = -vec2(0.5, 0.0);\n    vec2 c3 = -vec2(0.0, 0.5);\n\n    vec2 v0 = p0;\n    vec2 v1 = p1;\n    vec2 v2 = p2;\n    vec2 v3 = p3;\n\n\n    for (int j = 0; j < ITERATIONS; j++)\n    {\n        c0 = T(c0, j);\n        c1 = T(c1, j);\n        c2 = T(c2, j);\n        c3 = T(c3, j);\n\n\n        v0 = T(v0, j);\n        v1 = T(v1, j);\n        v2 = T(v2, j);\n        v3 = T(v3, j);\n\n        p_cont = T(p_cont, j);\n    }\n\n    vec2 comparison = c0;\n\n    vec4 invalidate0 = vec4(step(0.05, length(v0 - c0)), step(0.05, length(v1 - c0)), step(0.05, length(v2 - c0)), step(0.05, length(v3 - c0)));\n    //int4 invalidate1 = int4(step(0.05, length(v0 - c1)), step(0.05, length(v1 - c1)), step(0.05, length(v2 - c1)), step(0.05, length(v3 - c1)));\n    //int4 invalidate2 = int4(step(0.05, length(v0 - c2)), step(0.05, length(v1 - c2)), step(0.05, length(v2 - c2)), step(0.05, length(v3 - c2)));\n    //int4 invalidate3 = int4(step(0.05, length(v0 - c3)), step(0.05, length(v1 - c3)), step(0.05, length(v2 - c3)), step(0.05, length(v3 - c3)));\n\n\n    float d0_sdf = sdf0(uv_scaled, p0, uv_midpoint, size, invalidate0.x);\n    float d1_sdf = sdf0(uv_scaled, p1, uv_midpoint, size, invalidate0.y);\n    float d2_sdf = sdf0(uv_scaled, p2, uv_midpoint, size, invalidate0.z);\n    float d3_sdf = sdf0(uv_scaled, p3, uv_midpoint, size, invalidate0.w);\n\n\n\n    float dist = min(min(d0_sdf, d1_sdf), min(d2_sdf, d3_sdf));\n    //float distance = length(uv_scaled - uv_midpoint) * length(uv_scaled);\n    //float distance = length( (mapping + int2(32, 32)) / float(size) - i.uv) * size;\n\n\n    float dist_scale = 0.25;\n    float dist_smooth = 0.05;\n\n    float dragon_edge = 1.0-step(dist_scale, dist);\n    \n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv_original.xyx+vec3(0,2,4));\n\n    fragColor = vec4(col*dragon_edge, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 46, 46, 152], [154, 154, 234, 234, 400], [402, 402, 425, 425, 1035], [1037, 1037, 1094, 1144, 3878]]}
{"id": "WdGcWt", "name": "Trypophobia \"Skin\" Holes", "author": "AlancitoBalanza", "description": "trypophobia", "tags": ["skin", "trypophobia"], "likes": 2, "viewed": 80, "published": "Public", "date": "1603983618", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.141592\n\n#define MAX_ITER 1000\n#define MAX_DIST 6.0\n\n#define SET_NEAREST(dst,src) if (src.distance < dst.distance) dst = src\n\n\n\n#define HOLE_THRESH .7\n#define HOLE_DEPTH .0\n#define BORDER_THRESH .65\n#define BORDER_HEIGHT .025\n\nconst vec3 SKIN_COLOR = vec3(1, .6, .47);\nconst vec3 BORDER_COLOR = vec3(1, .68, .5);\n\n//----------------------------------------------------------------------------------------\n///  2 out, 2 in...\nvec2 hash22norm(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\nvec2 hash22(vec2 p)\n{\n\treturn hash22norm(p) * 2. - 1.;\n\n}\n\n// From https://www.shadertoy.com/view/Msf3WH\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash22(i+0.0)), dot(b,hash22(i+o)), dot(c,hash22(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\nfloat noise2(in vec2 p) {\n\treturn noise(p + 100.);\n}\nfloat noise3(in vec2 p) {\n\treturn noise2(p + 100.);\n}\n\n// From https://www.shadertoy.com/view/XlB3zW\nfloat voronoi(vec2 n)\n{\n    float i = 0.0;\n    float dis = 2.0;\n    for(int x = -1;x<=1;x++)\n    {\n        for(int y = -1;y<=1;y++)\n        {\n            vec2 p = floor(n)+vec2(x,y);\n            float d = length(hash22norm(p)+vec2(x,y)-fract(n));\n            if (dis>d)\n            {\n             \tdis = d;\n                i = hash22norm(p).x;\n            }\n        }\n    }\n    return dis;\n}\n\n\nmat3 rotationX(float angle) {\n    vec3 u = vec3(1, 0, 0);\n    vec3 v = vec3(0, cos(angle), -sin(angle));\n    vec3 w = vec3(0, sin(angle), cos(angle));\n    return mat3(u, v, w);\n}\n\nmat3 rotationY(float angle) {\n    vec3 u = vec3(cos(angle), 0, sin(angle));\n    vec3 v = vec3(0, 1, 0);\n    vec3 w = vec3(-sin(angle), 0, cos(angle));\n    return mat3(u, v, w);\n}\n\nmat3 rotationZ(float angle) {\n    vec3 u = vec3(cos(angle), -sin(angle), 0);\n    vec3 v = vec3(sin(angle), cos(angle), 0);\n    vec3 w = vec3(0, 0, 1);\n    return mat3(u, v, w);\n}\n\nmat3 rotationMatrix(vec3 angles) {\n    return rotationZ(angles.z) * rotationY(angles.y) * rotationX(angles.x);\n}\n\n\nstruct DistanceObject {\n    float distance;\n    vec3 color;\n};\nstruct HitData {\n    vec3 color;\n    float distance;\n    int iterations;\n    vec3 position;\n};\n\nfloat sdSphere(vec3 pos, float rad) {\n    return length(pos) - rad;\n}\n\n\nfloat sdPlane(vec3 pos) {\n\treturn pos.y;\n}\n\n\nfloat dSkin(vec2 pos) {\n    float voro = max(-.05, -voronoi(pos*20.)*.005);\n    \n    return (1.-exp(sin(noise2(pos*.3)*100.+pos.y*10.*5.)*.5 +.5)) * 0.005 + voro;\n    //return noise(vec2(noise(pos + 100.) * 10., 0.)) * .01;\n}\n\nDistanceObject map(vec3 pos) {\n\t\n    DistanceObject nearest = DistanceObject(MAX_DIST, vec3(1, 0, .5));\n    \n    \n    //  WRITE OBJECTS HERE\n    \n    //SET_NEAREST(nearest, DistanceObject(sdPlane(pos), vec3(.9, .5, .3)));\n    float baseDistance = pos.y - (noise(pos.xz * .2) * .5 + .5) * .1;\n   \t\n    //float dist = getHoleDistance(pos.xz * .5);\n    float n = noise(pos.xz) * .5 + .5 + noise(vec2(iTime, 0)) * .05;\n    \n    if (n > HOLE_THRESH) {\n\t\tfloat holeDepth = (n - HOLE_THRESH) * 5. - BORDER_HEIGHT;\n        //Hole walls\n        SET_NEAREST(nearest, DistanceObject(baseDistance + holeDepth, BORDER_COLOR));\n    } else if (n > BORDER_THRESH) {\n        float h = (n - BORDER_THRESH) / (HOLE_THRESH - BORDER_THRESH);\n        float bumps = dSkin(pos.xz)*(1.-h);\n        h *= BORDER_HEIGHT;\n        SET_NEAREST(nearest, DistanceObject(baseDistance - h + bumps, BORDER_COLOR));\n    } else {\n        //Skin surface\n\t    float skinDistance = baseDistance + dSkin(pos.xz);\n        //float skinDistance = baseDistance;\n        SET_NEAREST(nearest, DistanceObject(skinDistance, SKIN_COLOR));\n    }\n    //Hole bottom surface\n    float r = noise3(pos.xz*2.) * .5 + .5;\n    r *= .8;\n    //r = round(r * 10.) / 10.;\n    SET_NEAREST(nearest, DistanceObject(sdPlane(pos + vec3(0, HOLE_DEPTH, 0)), vec3(1, .72*r, .55*r)));\n    \n    \n    return nearest;\n}\n\n\nHitData render(vec3 pos, vec3 rayDir) {\n\tDistanceObject obj;\n    int i;\n    float dist = 0.;\n    for (i = 0; i < MAX_ITER; i++) {\n    \tobj = map(pos);\n        obj.distance *= .2;\n        dist += obj.distance;\n        pos += rayDir * obj.distance;\n        \n        if (obj.distance < .0001) {\n        \tbreak;\n        }\n    }\n    \n    if (i == MAX_ITER || dist > MAX_DIST) {\n    \tdist = MAX_DIST;\n        obj.color = vec3(0.);\n    }\n    \n    HitData res = HitData(obj.color, dist, i, pos);\n    \n    return res;\n}\n\n\n// From https://www.shadertoy.com/view/Xds3zN\n// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).distance;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n}\n\n\nfloat calculateIncidence(vec3 pos) {\n    vec3 nor = calcNormal(pos);\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).distance;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n    /*\n    \n    float epsilon = 1e-3;\n\tvec3 posaa = pos;\n    vec3 right = normalize(cross(dir, vec3(0, 1, 0)));\n    vec3 posab = pos + right * epsilon;\n    vec3 posba = pos + vec3(0, 1, 0) * epsilon;\n    posaa += render(posaa, dir).distance * dir;\n    posab += render(posab, dir).distance * dir;\n    posba += render(posba, dir).distance * dir;\n    vec3 norm = cross(posba - posaa, posab - posaa);\n    return dot(norm, dir) / (length(norm)*length(dir));\n*/\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord / iResolution.y;\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 coord = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    \n    mat3 cameraMatrix = rotationY(iTime * .1) * rotationX((sin(iTime*.2)*0.3+1.)*-PI/2.0*0.5);\n    \n    vec3 cameraPosition = cameraMatrix * -vec3(0, 0, 1) * (sin(iTime * .1) * 1. + 2.) + vec3(iTime, 1, 0);\n    //vec3 cameraPosition = cameraMatrix * -vec3(0, 0, 1) * (.1) + vec3(iTime, 1, 0);\n    \n    \n    vec3 direction = cameraMatrix * vec3(coord.x, coord.y, 2.5);\n    direction = normalize(direction);\n\n    vec3 col;\n    \n    HitData data = render(cameraPosition, direction);\n    \n    col = data.color;\n    //col *= inversesqrt(data.distance);\n    //col *= float(data.iterations) / 10.0;\n    col *= calculateIncidence(data.position);\n    col = mix(col, vec3(0), clamp((exp(data.distance*.5) - 1.)*.1, 0., 1.));\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGcWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[326, 437, 462, 462, 595], [596, 596, 617, 617, 653], [655, 701, 727, 727, 1212], [1213, 1213, 1238, 1238, 1265], [1266, 1266, 1291, 1291, 1319], [1321, 1367, 1390, 1390, 1758], [1761, 1761, 1790, 1790, 1939], [1941, 1941, 1970, 1970, 2119], [2121, 2121, 2150, 2150, 2299], [2301, 2301, 2335, 2335, 2413], [2575, 2575, 2612, 2612, 2644], [2647, 2647, 2672, 2672, 2689], [2692, 2692, 2715, 2715, 2917], [2919, 2919, 2949, 2949, 4262], [4265, 4265, 4304, 4304, 4775], [5902, 5966, 5998, 6096, 6343], [6346, 6346, 6382, 6382, 7183], [7185, 7185, 7242, 7292, 8240]]}
{"id": "wdGcz1", "name": "#inktober2020 d6: subdiv mouse", "author": "zaiyugi", "description": "Day 6 of my Inktober challenge. Playing around with subdividing down to match the mouse position", "tags": ["interactive", "subdiv", "inktober"], "likes": 4, "viewed": 67, "published": "Public", "date": "1602215933", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 8\n#define line(e0, d, f) smoothstep( d, 0., abs(f-(e0)) )\n\nvec3 colormap(float t)\n{\n    return .5 + .5 * cos(6.28 * (t + vec3(.8, .9, .3)));\n}\n\nfloat box( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nvoid mainImage( out vec4 C, in vec2 U )\n{\n    // pixel -> uv\n    vec2 p = 2.*(U/iResolution.xy-0.5);\n    vec2 m_p = 2.*(iMouse.xy/iResolution.xy-0.5);\n    float d = 1.5 / iResolution.y;\n    \n    vec3 col = vec3(0.);\n    \n    vec2 llc = vec2(-1.), urc = vec2(1.);\n    float border = 0.;\n    float c_d = 1. / float(N);\n    float c_t = iTime * .1;\n    for(int i = 0; i < N; ++i)\n\t{\n        vec2 mid = (llc+urc)*.5;\n        float f = box(p - mid, (urc-llc)*.5);\n        border += line(0., d, f);\n        c_t += mix(0., c_d, step(0., -f));\n        \n        vec2 flag = step(mid, m_p);\n        llc = mix(llc, mid, flag);\n        urc = mix(mid, urc, flag);\n    }  \n\n    col = colormap(c_t) + vec3(border);\n    \n    C = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGcz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 93, 93, 152], [154, 154, 189, 189, 269], [271, 271, 312, 331, 1000]]}
{"id": "wdGczD", "name": "Phong+AA+AO+Shadow", "author": "emedan", "description": "Phong light model. White sphere. Light color is changing.\nAmbient occlusion is distance based.\nAA is just blur. One ray is alwas cast. Only if that hits an object, then 4 more are cast around it and blurs.", "tags": ["test"], "likes": 2, "viewed": 109, "published": "Public", "date": "1602449366", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ray march - not ray trace - to find object.\n// Ray trace is easier, analytic expression.\n\n// Important to not have ; here.\n#define MAX_STEPS 600\n#define SURF_DIST 0.0001\n#define MAX_DIST 1000.0\n\n#define pi 3.141593\n#define pi2 6.28318530718\n#define pi4 12.5663706144\n\n\n// Camera\n//vec3 ro;\t// Camera position\n\n// Global list to simplify function returns.\nfloat objectDistances[10];\n\n\n// map from to, clamped\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1), min2, max2);\n}\n\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n\n// Return rotation matrix\nmat3 rotate3dx(float _angle){\n    float c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        1, 0,  0, \n        0, c, -s,\n        0, s,  c\n    );\n}\nmat3 rotate3dy(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n         c, 0, s,\n         0, 1, 0,  \n        -s, 0, c\n    );\n}\nmat3 rotate3dz(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        c, -s, 0,\n        s,  c, 0,\n        0,  0, 1\n    );\n}\n\n\n// Signed, negative inside object\nfloat SDF_box(vec3 p, vec3 size, float rounding) {\n\tp = abs(p)-size;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0) - rounding;\n}\n\n\n// Signed, negative inside object\nfloat SDF_capsule(vec3 p, vec3 A, vec3 B, float r) {\n    vec3 AB = B-A;\n    vec3 AP = p-A;\n    \n    float t = dot(AB, AP) / dot(AB, AB);\n    t = clamp(t, 0.0, 1.0);\n    \n    //return length(p - (A + t*AB)) - r;\n    float tt = 2.0*abs(0.5 - t);\t// 1 .. 0 .. 1\n    tt = t;\n    return length(p - (A + t*AB)) -r + r*smoothstep(1.0, 0.0, pow(tt, 0.9));\n    \n    float s1 = length(p - (A + t*AB)) - r*smoothstep(1.0, 0.0, tt);\n    float s2 =  length(p - (A + t*AB)) - r*(1.0+1.0*pow((t-0.5), 2.0));\n    float s = 0.5*(1.0+sin(iTime));\n    s = 0.0;\n    return s*s1+(1.0-s)*s2;\n}\n\n\n//Signed, negative inside object.\nfloat SDF_sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\n\n// Get the distance from point p to the closest object of all objects in the scene.\n// Returns: distance, object index\n// Distance can be constrained to selected object.\nfloat GetDist(vec3 p, out int objIndex, in int objConstraint) {\n    // Reusable translation variable.\n    vec3 trans;\n    \n    // Sphere /////////////////////////////////////////\n    //vec4 sphere = vec4(2.*sin(iTime), 0, 10.+6.*cos(iTime), 2);\n    vec4 sphere;\n    sphere = vec4(0, 3, 4, 2.1);\n    float sdf_sphere = SDF_sphere(p, sphere.xyz, sphere.w);\n    //sdf_sphere = abs(sdf_sphere) - 0.05;\t// Shell\n\t///////////////////////////////////////////////////\n    \n    // A sphere above the light to make a lamp\n    float sdf_sphereLight = SDF_sphere(p, vec3(12.*sin(iTime/4.), 13, 12.*cos(iTime/4.) + 6.), 0.8);\n\tsdf_sphereLight = SDF_sphere(p, vec3(0, 15, 0), 0.8);\n    \n    // Capsule ///////////////////////////////////////\n\tvec3 cpA, cpB;\n    float cr;\n    cr = 0.85;\n\n    // Position object before rotating around world origo\n\t// Rotate around origo\n    float xang = iTime*0.6+pi/4.0;\n    float yang = iTime*0.3;\n    float zang = iTime*0.3+pi/3.0;\n    mat3 rot = rotate3dy(yang) * rotate3dx(xang) * rotate3dz(zang);\n    \n    float a = 1.0;\n    float b = 4.0;\n    vec3 cpA1 = vec3(a, 0, 0);\n    vec3 cpB1 = vec3(b, 0, 0);\n    vec3 cpA2 = vec3(-a, 0, 0);\n    vec3 cpB2 = vec3(-b, 0, 0);\n    vec3 cpA3 = vec3(0, a, 0);\n    vec3 cpB3 = vec3(0, b, 0);\n    vec3 cpA4 = vec3(0, -a, 0);\n    vec3 cpB4 = vec3(0, -b, 0);\n    vec3 cpA5 = vec3(0, 0, a);\n    vec3 cpB5 = vec3(0, 0, b);\n    vec3 cpA6 = vec3(0, 0, -a);\t\t\n    vec3 cpB6 = vec3(0, 0, -b);\n    vec3 baseT = vec3(0, 3, 4);\n    cpA1 *= rot;\n    cpB1 *= rot;\n    cpA2 *= rot;\n    cpB2 *= rot;\n    cpA3 *= rot;\n    cpB3 *= rot;\n    cpA4 *= rot;\n    cpB4 *= rot;\n    cpA5 *= rot;\n    cpB5 *= rot;\n    cpA6 *= rot;\n    cpB6 *= rot;\n    cpA1 += baseT;\n    cpB1 += baseT;\n    cpA2 += baseT;\n    cpB2 += baseT;\n    cpA3 += baseT;\n    cpB3 += baseT;\n    cpA4 += baseT;\n    cpB4 += baseT;\n    cpA5 += baseT;\n    cpB5 += baseT;\n    cpA6 += baseT;\n    cpB6 += baseT;\n    \n    \n    ///////////////////////////////////////////////////\n    float sdf_capsule1 = SDF_capsule(p, cpA1, cpB1, cr);\n    float sdf_capsule2 = SDF_capsule(p, cpA2, cpB2, cr);\n    float sdf_capsule3 = SDF_capsule(p, cpA3, cpB3, cr);\n    float sdf_capsule4 = SDF_capsule(p, cpA4, cpB4, cr);\n    float sdf_capsule5 = SDF_capsule(p, cpA5, cpB5, cr);\n    float sdf_capsule6 = SDF_capsule(p, cpA6, cpB6, cr);\n    \n    // Box ////////////////////////////////////////////\n    vec3 boxSize = vec3(0.7);\n    vec3 boxCenter = vec3(-6, 3., 6);\n    float boxRounding = 1.5;\n    float boxThickness = 0.05;\n    vec3 boxPos = p-boxCenter;\n    \n    // Mirror in x. Works because position contains marching point and box sdf function\n    //  is made for box at origo.\n    //boxPos.x = abs(boxPos.x); \n    //boxPos.x -= 4.;\t\t\t\t// Space mirrored out from original pos.\n    \n    float sdf_box = SDF_box(boxPos, boxSize, boxRounding);\n    //sdf_box = abs(sdf_box) - boxThickness;\t// Makes shell with thickness.\n    ///////////////////////////////////////////////////\n    \n    // Floor plane ////////////////////////////////////\n    float sdf_plane = p.y;\t//  flat and at y = 0.\n    sdf_plane = dot(p, normalize(vec3(0, 1, 0 )));\t// Tilt plane\n    sdf_plane += sin(p.x/4. +iTime/4.) /5.;\n    sdf_plane += sin(p.x/2. +iTime/2.) /7.;\n    sdf_plane += sin(p.x    +iTime/1.) /9.;\n\n    sdf_plane += sin(p.z/2. +iTime)    /3.;\n    sdf_plane += sin(p.z    +iTime*3.) /7.;\n    ///////////////////////////////////////////////////\n    \n    // Info about hit object.\n    int objIndexDist = 0;\n    float objLimit = SURF_DIST;\n\n    // Capsules + sphere\n    if      (sdf_capsule1   < objLimit) objIndexDist = 1;\n    else if (sdf_capsule2   < objLimit) objIndexDist = 2;\n    else if (sdf_capsule3   < objLimit) objIndexDist = 3;\n    else if (sdf_capsule4   < objLimit) objIndexDist = 4;\n    else if (sdf_sphere     < objLimit) objIndexDist = 5;\n    else if (sdf_capsule5   < objLimit) objIndexDist = 6;\n    else if (sdf_capsule6   < objLimit) objIndexDist = 7;\n\n    ///////////////////////////////////////////////////    \n    // Copy all distances to a global array\n    objectDistances[0] = sdf_capsule1;\n    objectDistances[1] = sdf_capsule2;\n    objectDistances[2] = sdf_capsule3;\n    objectDistances[3] = sdf_capsule4;\n    objectDistances[4] = sdf_sphere;\n    objectDistances[5] = sdf_capsule5;\n    objectDistances[6] = sdf_capsule6;\n\t    \n    // Return the distance to any object for this position p.\n    // The ray marcher will march until the distance is really small.\n    // Distance functions must be signed, and return negative value inside object.\n    //\n    // abs(object distance) - Creates shell. Distance will increase from edges.\n    //\n    // Using: \n    //  min(d1, d2)  - Ray will stop at closest to either one. Typical usage.\n    //  max(d1, d2)  - Ray point requires both d1 and d2 small. Will get the intersection.\n    //  max(-d1, d2) - Object 1 will cut out object 2.\n    float d = MAX_DIST;\n    \n    \n        \n    // Capsules + sphere\n    d = MAX_DIST;\n    d = min(d, sdf_capsule1);\n    d = min(d, sdf_capsule2);\n    d = min(d, sdf_capsule3);\n    d = min(d, sdf_capsule4);\n    d = min(d, sdf_capsule5);\n    d = min(d, sdf_capsule6);\n    d = min(d, sdf_sphere);\n\n    \n    // With object constraint, only give the distance to the selected object.\n    if (objConstraint > -1) {\n        d = MAX_DIST;\n        if      (objConstraint == 1) d = min(d, sdf_capsule1);\n        else if (objConstraint == 2) d = min(d, sdf_capsule2);\n        else if (objConstraint == 3) d = min(d, sdf_capsule3);\n        else if (objConstraint == 4) d = min(d, sdf_capsule4);\n        else if (objConstraint == 5) d = min(d, sdf_sphere);\n        else if (objConstraint == 6) d = min(d, sdf_capsule5);\n        else if (objConstraint == 7) d = min(d, sdf_capsule6);\n    }\n    \n    objIndex = objIndexDist;\n    return d;\n    //return vec2(d, float(objIndexDist));\n}\n\n\n// Ray march / sphere trace. Walk in ray direction, but the distance of the closest object.\n//  Guarantees to not oveshoot the second closest object.\n// Returns: distance to first hit object, hit object index, iterations\nvoid RayMarch(vec3 ro, vec3 rd, \n              out float dO, out int objIndex, out int iterations) {\n\t\n    // Distance from origin start 0 each loop\n    dO = 0.0;\n    float dS;\n    vec2 distResult;\n    int i;\n    for ( i=0; i<MAX_STEPS; i++ ) {\n        // Point marches along ray direction.\n        vec3 p = ro + dO*rd;\n        \n        // Check if the point is so close to a surface that it's a hit.\n        // GetDist returns (distance, object index)\n        dS = GetDist(p, objIndex, -1);\n        //dS = distResult.x;\n        \n        // March the length of closest distance, but in ray direction.\n        dO += dS; \n        \n        // Exit loop if hit object or too long distance.\n        if (abs(dS) < SURF_DIST || dO > MAX_DIST) {\n        \tbreak;\n        } \n    }\n    \n    //Outputs\n    //dO\n    //objIndex\n    iterations = i;\n    return;\n    //return; vec3(dO, float(objIndex), float(i));\n    //return vec3(dO, float(distResult.y), float(i));\t// Always return distance for when loop was exited.\n    // Return nbr of iterations for glow effect. Iteratons increase for rays passing close to objects. \n}\n\n\n// Approximate normal calculation. Uses GetDist to \"find\" the actual object.\n//  Needs p on object for relevant result.\n// The approximate surface of different objects is used if they are close.\n// Approxmation of normal can be constrained to surface of the object found at point p.\nvec3 GetNormal(vec3 p, bool useObjConstraint) {\n    int objConstraint;\n    int dummy;\n    float d =  GetDist(p, objConstraint, -1);\t// Since p is passed here, the distance to p is likely known.\n\tvec2 eps = vec2(0.01 ,0);\n    \n    if (!useObjConstraint) objConstraint = -1;\n    \n    // Get tangent plane\n    float xd =  GetDist(p + eps.xyy, dummy, objConstraint);\n    \n    float yd = GetDist(p + eps.yxy, dummy, objConstraint);\n    \n    float zd = GetDist(p + eps.yyx, dummy, objConstraint);\n    \n    // Normal?? Detta är väl planet?\n    // Det är normalen. Färglägger man blir planet grönt, dvs y = 1.\n    return normalize( vec3(xd, yd, zd) - d );\n}\n\n\nvec3 PhongLight(vec3 p, int objIndex, vec3 ro) {\n    // Famous because it's a computer efficient approximation.\n    \n\t// For each light source in the scene, components (often in rgb values)\n    //  L_is - intensity of specular component\n    //  L_id - intensity of diffuse component\n    // A single term sum of all ambient\n    //  L_ia - intensity of ambient\n    //\n    // For each material in the scene, the following parameters are defined:\n\t//  M_ks - specular reflection constant, ratio of reflection of the specular term of incoming light,\n\t//  M_kd - diffuse reflection constant, ratio of reflection of the diffuse term of incoming light \n    //         (Lambertian reflectance),\n    //  M_ka - ambient reflection constant, ratio of reflection of the ambient term present \n    //         in all points in the scene rendered.\n    //  M_a  - shininess constant which is larger for surfaces that are smoother \n    //         and more mirror-like. When this constant is large the specular highlight is small.\n        \n    // v_L - which is the direction vector from the point on the surface toward each light source \n    //        (m specifies the light source),\n    // v_N  - which is the normal at this point on the surface,\n    //\n    // v_R - which is the direction that a perfectly reflected ray of light would take from \n    //        this point on the surface\n    // v_V  - which is the direction pointing towards the viewer (such as a virtual camera).\n    \n    // Ip = M_ka * L_ia + \n    //      sum of all ligths:\n    //      M_kd * dot(v_L,v_N) * L_id + \n    //      M_ks * dot(v_R,v_V)^M_a * L_is\n    \n    // v_R = 2 * dot(v_L,v_N) * v_N - v_L\n    \n    \n    // Point light ////////////////////////////////////////\n    vec3 LPos;\n    LPos = vec3(25.0*sin(iTime/4.), 20.0+5.0*pow(cos(iTime/4.), 2.0), 2);\n\tLPos = vec3(10.0, 25, -5);\n    float LPower = 2500.0;\n        \n    // Light distance and intensity falloff\n    float LDist = length(LPos - p);\n    float LI = LPower/pi4/LDist/LDist;\n    \n    // Get normal of point on object.\n    //  Light directly to object, dot = 1. At 90 deg angle, dot = 0.\n    vec3 v_L = normalize(LPos - p);\n    vec3 v_N = GetNormal(p, true);\n    \n    // Light color\n    vec3 v_L_is = vec3(1, 1, 0.6);\t// Skumt att light kan ha specular component.\n    vec3 v_L_id = vec3(1, 1, 1);\n    vec3 v_L_ia = vec3(0.4);\n    \n    // Vary the light color \n    float ph1 = pi2*sin(iTime*0.1);\n    float ph2 = pi2*sin(iTime*0.1+0.3*ph1);\n    v_L_id = vec3(0.5+0.5*sin(iTime), 0.5+0.5*sin(iTime*0.9+ph1), 0.5+0.5*sin(iTime*0.57+ph2));\n    // Vary the light tone\n    v_L_id += 0.5+0.5*sin(iTime*0.5);\n\n    // v_R\n    float dotLN = dot(v_L, v_N);\n    vec3 v_R = normalize( 2.0 * dotLN * v_N - v_L );\n    vec3 v_V = normalize( ro - p );\n    \n    \n    // Get object info /////////////////////////////////////\n    // Material \n    float M_ks = 1.0;\n    float M_kd = 1.0;\n    float M_ka = 0.2;//0.1;\n    float M_a = 4.;\n    \n    vec3 objSpecCol = vec3(1); \n    vec3 objDiffCol = vec3(0); // The object finder did not find an object.\n\n    if (objIndex == 1) { \n        objDiffCol = vec3(1, 0, 0);\n        M_ks = 3.;\n\t    M_a = 4.;\n    }\n    else if (objIndex == 2) { \n        objDiffCol = vec3(0, 1, 0);\n        M_ks = 3.;\n\t    M_a = 8.;\n    }\n    else if (objIndex == 3) {\n\t\tobjDiffCol = vec3(0, 0, 1);\n        M_ks = 3.;\n\t    M_a = 16.;\n    }\n    else if (objIndex == 4) {\n        objDiffCol = vec3(1, 0, 1);\n        M_ks = 3.;\n\t    M_a = 32.;\n    }\n    else if (objIndex == 5) {\t// Sphere\n        objDiffCol = vec3(1, 1, 1);\n        M_ks = 3.;\n\t    M_a = 8.;\n    }\n    else if (objIndex == 6) {\n        objDiffCol = vec3(1, 1, 0);\n        M_ks = 3.;\n\t    M_a = 32.;\n    }\n    else if (objIndex == 7) {\n        objDiffCol = vec3(0, 1, 1);\n        M_ks = 3.;\n\t    M_a = 32.;\n    }\n\n    \n    // Phong output\n    vec3 I_ambient = M_ka * v_L_ia;\n    // Below should be summed for all lights.\n    vec3 I_diffuse = M_kd * max(dotLN, 0.0) * v_L_id;\n    vec3 I_specular = M_ks * pow( max(dot(v_R,v_V), 0.0), M_a ) * v_L_is;\n\n    \n    // Additional shading. Not Phong.\n    // Add ambient occlusion where dot L N is -1, and the diffuse part is already 0.\n    //  This will make the core shadow darker. \n    // Material parameter.\n    float M_da = 0.8;\t// Reduction of ambient light in the shadow.\n    I_ambient *= M_da * (1.0 + clamp(dotLN, -1.0, 0.0));\n    \n    // Add more shadows if no path to light source from point p.  //////////\n    // This causes extra ray march. Approximation.\n    // Go from point towards light. If hit an object first - no light path.\n    //  But start a little bit above the surface of p.\n    // Must shadow a point by its own object or else a strange gradient comes.\n    float dShadowObject;\n    int dummy_iterations;\n    int shadowindex;\n    const float SHADOW_FO = 2.5;\t// Falloff\n    RayMarch(p + 3.0*SURF_DIST*v_N, v_L, \n             dShadowObject, shadowindex, dummy_iterations);\n    bool inShade = dShadowObject < LDist + SURF_DIST;\n    bool selfShade = inShade && shadowindex == objIndex;\n    if (inShade) {\n        // Point is affected by shadow.\n        float sf = clamp(M_da*dShadowObject/SHADOW_FO, 0.0, 1.0);\n        sf = pow(sf, 2.0);\n        I_diffuse *= sf;\n        I_specular *= pow(sf, 1.1);\n    }\n    //if (selfShade) { I_ambient = vec3(1); I_diffuse = vec3(1); } // Debug\n    //if (inShade && !selfShade) { I_ambient = vec3(0); I_diffuse = vec3(0); } // Debug\n    ////////////////////////////////////////////////\n    \n    \n    return objDiffCol * I_ambient + \n           objDiffCol * I_diffuse * LI + \n           objSpecCol * I_specular * LI;\n}\n\n\n// Ambient occlusion affect objects close to each other.\n// It's an simplification. \n//  Don't detect the object intersect edge, but should shadow narrow angles more.\n//  Improve by using normal of the other object. How to get that?\nfloat AO(vec3 p, int objIndex) {\n    // Point p is on the surface of object[objIndex], so the distance to other objects\n    //  will be from this.\n    // But when objects intersect the distance will be wrong - it should be only distances\n    //  to visible parts. Can the GetDist / RayMarch also return p of all other distances, and\n    //  not only the p of the \"found\" object?\n    float ao, ao_sum = 0.0;\t\t\t// 0: No ao at all\n    const int NBR_RODS = 6;\n    const int sphereIndex = 5;\n    const float d_fo = 0.3;\t\t// 0..r Fall off distance\n    const float ao_max = 0.8;\t// 0..1 Maximum amount of ao \n    \n    // Make sure global distance variables are updated. XXX now it starts becoming unnecessary (costly).\n    int dummy_index;\n    GetDist(p, dummy_index, -1);\n    \n    // Point is on the sphere.\n    if (objIndex == sphereIndex) {\n        // Move the rod distances to array for iteration possibility.\n        float rd[NBR_RODS];\n        rd[0] = objectDistances[0];\n        rd[1] = objectDistances[1];\n        rd[2] = objectDistances[2];\n        rd[3] = objectDistances[3];\n        rd[4] = objectDistances[5];\n        rd[5] = objectDistances[6];\n\n        // Shadow depending on the distance to each rod.\n        for (int i = 0; i < NBR_RODS; i++) {\n            // Normalize distance between 0..1\n            float d = clamp(rd[i] / d_fo, 0.0, 1.0);\n            \n            // Calculate ao based on distance function.\n            ao = clamp(pow((1.0-d), 3.0), 0.0, 1.0);\n            //ao = 0.3*d;\n            \n            // Add to existing ao with a reduction factor.\n            ao_sum += clamp(0.75*min(ao, ao_max), 0.0, 1.0);\n        }\n    }\n    else {\n    \t// Point is on a rod.\n        // Normalize distance between 0..1\n        float d = clamp(objectDistances[4] / d_fo, 0.0, 1.0);\n\n        // Calculate ao based on distance function.\n        ao = clamp(pow((1.0-d), 3.0), 0.0, 1.0);\n        //ao = 0.3*d;\n\n        // Add to existing ao with a reduction factor. Will matter when several nearby objects\n        //  contribute to the same occlusion.\n        ao_sum += clamp(0.75*min(ao, ao_max), 0.0, 1.0); \n    }\n    \n    return 1.0 - min(ao_sum, ao_max);\n}\n\n\n// Sky color\nvec3 skyColor(vec2 uv) {\n    // 077b88 = \n    // 9dc6ca = \n\tvec3 col; \n    col = mix(vec3(0.615, 0.776, 0.792), vec3(0.027, 0.482, 0.533), 2.0*sqrt(abs(uv.y)));\n    \n    // Lighten middle, darken out. Multiply with > 1.\n    col *= mix(vec3(2), vec3(1), 2.0*pow(abs(uv.y), 0.25));\n        \n    col = pow( clamp(col,0.0,1.0), vec3(2.2) );\t// Inverse gamma bc sky color was chosen from palette.\n\treturn col;\n}\n\n// Render the point of the ray\n// returns: vec3 color, object index, object distance\nvec3 Render(vec3 ro, vec3 rd, vec2 uv,\n            out int objIndex, out float d) {\n    \n    // Ray march in direction for this uv-coordinate / screen pixel.\n    int raySteps;\n    RayMarch(ro, rd, \n             d, objIndex, raySteps);\t// Returns (distance, object index, ray iterations)\n    \n    // Light and color for the intersected point.\n    // Don't do color calculations if there was no hit.\n    vec3 col = vec3(1);\n    if (d < MAX_DIST) {\n        vec3 p = ro + d*rd;\n        col = PhongLight(p, objIndex, ro);\n\n        // Ambient occlusion \n        col *= AO(p, objIndex);\n\n        // Use the nbr of marched steps for glow.\n        //if (objIndex > 1) {\n        //    float stepF = float(raySteps)/float(MAX_STEPS); \n        //    difCol += (pow(stepF*10., 2.0)*1.);   \n        //}\n\n        // Do not shade the light ball\n        //if (objIndex == 5) col = vec3(1, 1, 0);\n    }\n    else {\n        // Background. Remove anything when marcher did not reach because of distance.\n        col = skyColor(uv);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Rescale x so a circle looks like a circle, and move to new center.\n    // uv.y: -0.5 .. 0.5\n    // uv.x: ( -0.5 .. 0.5 ) * aspect ratio.\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Camera ////////////////////////////////////////////////////////////\n    // Camera ray origin, ray direction, ro, rd\n    // x, y view plane and z is depth.\n    vec3 ro;\n\n    // Camera ray direction - look from origin in the direction of each screen pixel.\n    // XXX - Är det ortogonal view genom att sätta x, y, 1 alltid. Nej...\n\tvec3 rd;\n    \n    // Pixel color for what the ray hit.\n    vec3 col;\n    \n    // Camera ray origin\n    ro = vec3(0, 7, -8);\t\n\n    // Camera ray direction\n    rd = normalize( vec3(uv.x, uv.y-0.3, 1) );\n    //////////////////////////////////////////////////////////////////////\n\n    // Cast original ray\n\tvec2 uvorg = uv;\n            \n    // Render what the ray hits.\n    int objIndex;\n    float dist;\n    col = Render(ro, rd, uvorg,\n          objIndex, dist);  // Color of hit point\n    \n    \n    // Focus blur /////////////////////////////////////\n    float fact;\n    fact = 700.0;\t// Use 700 for good AA.\n\n    float range = 0.5;\n    float fp = 4.5;\n    fact =  clamp(pow(abs(dist-fp), 3.2), 20.0, 700.0);\n    ///////////////////////////////////////////////////\n    \n    \n    // Calculate distance\n    //XXXvec3 p = GetDist();\n    //float centerDist = p.z-ro.z;\t// Orthogonal distance to object from camera.\n    //if (objIndex1 == 0) centerDist = MAX_DIST;\n    \n    // Cast ray\n    // How to calculate backwards from uv into a ray direction?\n    // Seems better than to ray with small angular difference.\n\n    // Anti-aliasing - sample 4 points (or perhaps only affect when point is on object edge).\n    // 4 sample is just blur everywhere.\n    // \n    \n    // Procesing saving algorithm for at least few objects:\n    //  Cast the ray.\n    //  If ray hits an object\n    //    Cast the AA rays.\n    //    Optional:\n    //    Blur only if one or more AA ray does not hit object. Prevents pure object internal blur.\n    //\n    // Rays cast: 1 per \"normal cast\". 5 per normal cast that hits an object.\n    \n    // And AA only on \"edge between objects\" but not \"edges within the same object\"\n    //  Cast the ray\n    //  If ray hits Object obj at Point p:\n    //    Calculate a new point pp that is a small view angle in the normal direction of p\n    //     Point pp distance from p depends on camera and perspective transform.\n    //    Cast a ray towards pp\n    //      If ray does not hit obj:\n    //        Blur color of p with whatever color was found in direction of pp.\n    //\n    // Rays cast: 1 per \"normal cast\". 2 per normal cast that hits an object.\n\n    // AA 2 is 4 passes. Costs.\n    #define AA 2\n    \n    // Mouse top half - no AA\n    // Mouse lower left - fixed blur\n    // Mouse lower right - variable blur.\n    bool useAA = (iMouse.y/iResolution.y < 0.5);\n    \n    // Don't cast additional AA rays unless the first ray hit an object.\n    //useAA = useAA && objIndex > 0;\t// XXX Have to or edge can be missed. Blur avoided by not blurring if all points was on object.\n\n\tvec3 tot = vec3(0.0);\t// Summary of all render passes.\n    int m, n;\n    int samples = 0;\n    bool allPointsOnObject = true;\n    for( m=0; m<AA; m++ ) {\n        for( n=0; n<AA; n++ ) {\n            // How to calculate backwards from uv into a ray direction?\n            // Seems better than to ray with small angular difference.\n            vec2 uvorg = uv;\n            \n            // Create offset for the cast ray.\n            vec2 of = vec2(m, n) - 0.5;\n            of /= fact;\n\t\t\t\n            // Modify camera ray direction a little for each AA pass.\n            rd = normalize( rd + vec3(of.x, of.y, 0) );\n\n            // Render what the ray hits.\n            int objIndexOld = objIndex;\n            float distDummy;\n            vec3 col = Render(ro, rd, uvorg,\n                              objIndex, distDummy);  // Color of hit point\n\n \t\t\t// accumulate for AA\n            tot += col;\n            samples++;\n            allPointsOnObject = allPointsOnObject && objIndexOld == objIndex;\n  \t    }        \n    }\n    if (useAA && true) {//!allPointsOnObject) {\n    \tcol = tot / (float(samples));\n    }\n    \n    //if (dist < 7.5) col*= 0.0;\n            \n\n\n    // hdr->ldr tonemap (iniqo)\n    col = col*1.6/(1.0+col);\n    col = col*col*(3.0-2.0*col);\n\n    // Gamma\n    col = pow( clamp(col,0.0,1.0), vec3(1.0 / 2.2) );\n\n    // Output to screen\n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGczD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[387, 411, 483, 483, 568], [571, 607, 653, 653, 739], [742, 768, 797, 797, 931], [932, 932, 961, 961, 1093], [1094, 1094, 1123, 1123, 1253], [1256, 1290, 1340, 1340, 1439], [1442, 1476, 1528, 1528, 2047], [2050, 2084, 2127, 2127, 2159], [2162, 2332, 2395, 2433, 8166], [8169, 8390, 8490, 8538, 9498], [9501, 9784, 9831, 9831, 10439], [10442, 10442, 10490, 12168, 16044], [16047, 16280, 16312, 16658, 18448], [18451, 18464, 18488, 18522, 18870], [18872, 18957, 19040, 19114, 19996], [19999, 19999, 20056, 20200, 24570]]}
{"id": "wdGczy", "name": "Procedural Bell Pepper", "author": "oneshade", "description": "A procedural modelling exercise. It is an elongated sphere with some polar and sinusoidal displacements. I might try adding a stem too.", "tags": ["procedural", "3d", "raymarching", "sdf", "bell", "pepper"], "likes": 2, "viewed": 62, "published": "Public", "date": "1603119333", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThis shader uses an older version of my raymarcher template (https://www.shadertoy.com/view/3styDs)\nand I do not plan on implementing the newer features as they are not necessary.\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.5, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1300.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.01, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 1600.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 800;\n\n// Signed Distance Functions (SDFs):\nfloat sdPlane(in vec3 p, in vec3 n) {\n    return dot(n, normalize(p)) * length(p);\n}\n\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    return max(abs(p.x) - 0.5 * w, max(abs(p.y) - 0.5 * h, abs(p.z) - 0.5 * d));\n}\n\nfloat sdCone(in vec3 p, in float h, in float r) {\n    return 0.0;\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    return max(abs(p.y) - 0.5 * h, length(p.xz) - r);\n}\n\nfloat sdTorus(in vec3 p, in float r1, in float r2) {\n    return length(vec2(length(p.xz) - r1, p.y)) - r2;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nfloat Union(in float sdf1, in float sdf2) {\n    return min(sdf1, sdf2);\n}\n\nfloat Subtraction(in float sdf1, in float sdf2) {\n    return max(sdf1, -sdf2);\n}\n\nfloat Intersection(in float sdf1, in float sdf2) {\n    return max(sdf1, sdf2);\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\nvec3 Scale(in vec3 p, in vec3 s) {\n    return p / s;\n}\n\n// Scene mapping function:\nfloat mapScene(in vec3 p) {\n    float radius = 200.0;\n    float aspectRatio = 1.2;\n    float segments = 6.0;\n    float pronouncement = 15.0;\n    float bumps = 3.0;\n    float bumpSize = 3.0;\n\n    p = Rotate(p, vec3(-45.0, iTime * 20.0, 0.0));\n    p.y /= aspectRatio;\n\n    float sphere = sdSphere(p, radius);\n    float t = atan(p.z, p.x) * segments;\n    float r = (length(p.xz) / radius) * pronouncement;\n    float baseShape = sphere + sin(t) * r;\n    float displacement = (sin(p.x / (bumps * 6.28)) + sin(p.y / (bumps * 6.28)) + sin(p.z / (bumps * 6.28))) * bumpSize;\n    float pepper = baseShape + displacement;\n    return pepper;\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy) - mapScene(p - GRADIENT_STEP.xyy);\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy) - mapScene(p - GRADIENT_STEP.yxy);\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx) - mapScene(p - GRADIENT_STEP.yyx);\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Material calculation functions:\nvec3 calculateAmbient(in vec3 p, in vec3 normal) {\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec3 calculateDiffuse(in vec3 p, in vec3 normal) {\n    return vec3(1.0, 0.0, 0.0);\n}\n\nvec3 calculateSpecular(in vec3 p, in vec3 normal) {\n    return vec3(1.0, 1.0, 1.0);\n}\n\nfloat calculateShininess(in vec3 p, in vec3 normal) {\n    return 8.0;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in vec3 ro, in vec3 rd) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ro + rd * distanceTraveled;\n        float distanceToClosest = mapScene(currentPosition);\n        if (abs(distanceToClosest) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n\n            // Illumination is calculated using the Phong illumination model.\n            vec3 materialAmbient = calculateAmbient(currentPosition, normal);\n            vec3 materialDiffuse = calculateDiffuse(currentPosition, normal);\n            vec3 materialSpecular = calculateSpecular(currentPosition, normal);\n            float materialShininess = calculateShininess(currentPosition, normal);\n\n            vec3 illuminationAmbient = materialAmbient * lightColor;\n            float lambertian = max(0.0, dot(normal, lightDirection));\n            vec3 illuminationDiffuse = lambertian * materialDiffuse * lightColor;\n            vec3 reflection = reflect(lightDirection, normal);\n            float specularAngle = max(0.0, dot(reflection, rd));\n            vec3 illuminationSpecular = pow(specularAngle, materialShininess) * materialSpecular * lightColor;\n\n            return vec4(illuminationAmbient + illuminationDiffuse + illuminationSpecular, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += distanceToClosest;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = rayMarch(rayOrigin, rayDirection);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGczy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[774, 811, 848, 848, 895], [897, 897, 960, 960, 1043], [1045, 1045, 1094, 1094, 1112], [1114, 1114, 1167, 1167, 1223], [1225, 1225, 1277, 1277, 1333], [1335, 1335, 1374, 1374, 1402], [1404, 1452, 1495, 1495, 1525], [1527, 1527, 1576, 1576, 1607], [1609, 1609, 1659, 1659, 1689], [1691, 1711, 1749, 1749, 1769], [1771, 1771, 1806, 1806, 2417], [2419, 2419, 2453, 2453, 2473], [2475, 2502, 2529, 2529, 3134], [3136, 3185, 3218, 3218, 3548], [3550, 3585, 3635, 3635, 3669], [3671, 3671, 3721, 3721, 3755], [3757, 3757, 3808, 3808, 3842], [3844, 3844, 3897, 3897, 3915], [3917, 3938, 3977, 3977, 5460], [5462, 5495, 5550, 5550, 5870]]}
{"id": "wdGyDm", "name": "RayMarchingggggg", "author": "EcureuilViolent", "description": "Ray March", "tags": ["raymarching"], "likes": 4, "viewed": 82, "published": "Public", "date": "1603035202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision highp float;\n\n#define PI 3.1415925359\n#define TWO_PI 6.2831852\n#define MAX_DISTANCE 100.\n#define MAX_STEPS 100\n#define SURF_DIST .01\n#define RITER 5\n\nstruct Ray {\n    vec3 o,d;\n};\n\nstruct Material {\n    vec4 c;\n    float r;\n};\n\nstruct Light {\n    vec3 p;\n    vec4 c;\n};\n\nstruct Object {\n    vec3 p;\n    float d;\n    Material m;\n};\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p)-r;\n}\n\nfloat boxSDF(vec3 p, vec3 c) {\n    vec3 q=abs(p)-c;\n    return length(max(q,0.0))+ min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat cylSDF(vec3 p, float r, float h) {\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat torusSDF(vec3 p, float a, float b) {\n    vec2 pp = normalize(p.xz)*(a);\n    return(length(vec3(pp.x,0.,pp.y)-p)-b);\n}\n\nmat2 Rotate(float t) {\n    float s=sin(t), c=cos(t);\n    return mat2(c,-s,s,c);\n}\n\nObject Add(Object a, Object b) {\n    if (a.d < b.d) {return a;}\n    return b;\n}\n\nObject Sub(Object a, Object b) {\n       if (a.d > -b.d) {return a;}\n    return Object(b.p, -b.d, b.m);\n}\n\nObject Inter(Object a, Object b) {\n       if (a.d > b.d) {return a;}\n    return Object(b.p, b.d, b.m);\n}\n\nfloat SmoothMin(float a, float b, float k){\n    float h = clamp(.5 + .5 *(b-a)/k, 0., 1.);\n    return  mix(b, a, h) - k * h * (1.- h);\n}\n\nObject sAdd(Object a, Object b, float k) {\n    if (a.d < SmoothMin(b.d,a.d,k)+.1) {return Object(a.p, SmoothMin(a.d,b.d,k),a.m);}\n    return Object(b.p, SmoothMin(a.d,b.d,k),b.m);;\n}\n\nObject sSub(Object b, Object a, float k) {\n    if (a.d < SmoothMin(-b.d,a.d,k)+.3) {return Object(a.p, -SmoothMin(a.d,-b.d,k),a.m);}\n    return Object(b.p, -SmoothMin(a.d,-b.d,k),b.m);\n}\n\nfloat sInter(float d0, float d1, float k) {\n    return -SmoothMin(-d0,-d1,k);\n}\n\n\nObject SafeDist(vec3 p) {\n\n    \n    Material M1 = Material(vec4(.9,.7,.0,1.),.8);\n    Material M2 = Material(vec4(.9,.99,1.,1.),.0);\n    \n    Object oa[2];\n    \n    float size = 1.3;\n    p = (p - vec3(0.,0.,4.))/size+vec3(0.,0.,4.);\n    \n    for (float i = 0.; i <= 1.; i++) {\n        \n        vec3 off = vec3(0.,.6*cos(iTime*2.)*i+.5*size,0.);\n        \n        vec3 ps0 = vec3(0.,0.,4.)+off;\n        vec3 s0 = p - ps0;\n        float ds0 = sphereSDF(s0,2.5);\n        Material ms0 = M1;\n        Object os0 = Object(ps0,ds0,ms0);\n\n        vec3 ps2 = vec3(0.,0.,4.)+off;\n        vec3 s2 = p - ps0;\n        float ds2 = sphereSDF(s2,2.3);\n        Material ms2 = M1;\n        Object os2 = Object(ps2,ds2,ms2);\n\n\n        vec3 pt0 = vec3(0.,0.,4.)+off;\n        vec3 t0 = p-pt0;\n        Material mt0 = M1;\n        float dt0 = torusSDF(t0,3.,1.);\n        Object ot0 = Object(pt0,dt0,mt0);\n\n        vec3 pb0 = vec3(0.,0.,4.)+off;\n        vec3 b0 = p-pb0;\n        b0.xz*=Rotate(PI/4.*i);\n        Material mb0 = M1;\n        float db0 = boxSDF(b0,vec3(2.));\n        Object ob0 = Object(pb0,db0,mb0);\n        \n        vec3 pb3 = vec3(0.,2.3*pow(-1.,i),4.)+off;\n        vec3 b3 = p-pb3;\n        b3.xz*=Rotate(PI/4.*i);\n        Material mb3 = M2;\n        float db3 = boxSDF(b3,vec3(4.,2.,4.));\n        Object ob3 = Object(pb3,db3,mb3);\n        \n        Object o = Sub(ob0,ot0);\n        o = Inter(o,os0);\n        o = Sub(o,os2);\n        \n        oa[int(i)] = Sub(o,ob3);\n        \n    }\n    \n    p = (p - vec3(0.,0.,4.))*size+vec3(0.,0.,4.);\n    \n    vec3 pb0 = vec3(10.,0.,13.);\n    vec3 b0 = p - pb0;\n    b0.xz*=Rotate(PI/4.);\n    float db0 = boxSDF(b0,vec3(15.,15.,.4));\n    Material mb0 = M1;\n    Object ob0 = Object(pb0,db0,mb0);\n    \n\n    vec3 pb1 = vec3(0.,5.5,4.);\n    vec3 b1 = p-pb1;\n    Material mb1 = M2;\n    float db1 = boxSDF(b1,vec3(15.,8.,15.));\n    Object ob1 = Object(pb1,-db1,mb1);\n\n\n    \n\n    Object o = sAdd(oa[0],oa[1],.01);\n\n    o = Add(o,ob1);\n    o = Add(o,ob0);    \n    \n    return o;\n}\n\nvec3 GetNormal(vec3 p) { \n    vec2 e = vec2(.01,0.);\n    float d = SafeDist(p).d;\n    vec3 n = d-vec3(\n\t\tSafeDist(p-e.xyy).d,\n\t\tSafeDist(p-e.yxy).d,\n\t\tSafeDist(p-e.yyx).d);\n    return normalize(n);\n}\n\n\nRay GetRay(vec3 camOgn, vec3 lookAt, float zoom, vec2 uv) {\n    Ray a;\n    a.o = camOgn;\n    vec3 up = vec3(0., 1., 0.);\n    vec3 fwd = normalize(lookAt - camOgn);\n    vec3 right = cross(fwd, up);\n\n    vec3 i = camOgn + zoom * fwd + up * uv.y + right * uv.x;\n    a.d = normalize(i-a.o);\n    return a;\n}\n\nObject RayMarch(Ray ray) {\n    \n    float d = 0.;\n    Object o;\n    \n    for (int i = 0; i < MAX_STEPS; i++) {\n        o = SafeDist(ray.o+d*ray.d);\n        d+=o.d*.75;\n        if (abs(o.d) < SURF_DIST) \n            { return Object(o.p, d, o.m);; }\n        else if (d>MAX_DISTANCE)\n            { return Object(o.p, d, Material(vec4(vec3(0.),0.), 0.)); }\n    }\n}\n\nvec3 GetLight(vec3 p) {\n    \n    Light lArray[2] = Light[](Light(vec3(0.*cos(iTime)+0., 10., 4.),vec4(1.,1.,1., 3.)),Light(vec3(0., 1., 4.),vec4(.9,.3,.0,3.)));\n    \n    vec3 n = GetNormal(p);\n    \n    vec3 lInt = vec3(0.);\n\t\n    for (int i = 0; i<lArray.length();i++) {\n        vec3 l = lArray[i].p;\n\n        \n        vec3 dir = l-p;\n        float r = length(dir);\n        dir /= r;\n        float coef = clamp(pow(dot(dir, n),1.), 0.0, 1.);\n\n        vec3 pp = p+2.*SURF_DIST*n;\n\n        float dl = RayMarch(Ray(pp, normalize(l-pp))).d;\n\n        if (dl<length(pp-l)) \n            { coef*=.1;}\n        lInt += coef*lArray[i].c.xyz/r*lArray[i].c.w;\n    }\n    return vec3(clamp(lInt,0.,1.));\n}\n\nvec3 GetColor(Ray r) {\n    \n    //Couleur de l'objet\n    Object o = RayMarch(r);\n    vec3 q = r.o;\n    vec3 p = r.o + r.d * o.d;\n    vec3 c = o.m.c.xyz * GetLight(p);\n    \n    //Calcul de sa reflection\n    \n    int i = 0;\n    \n    while (o.m.r > 0. && i < RITER) {\n   \t\t\n        float ref = o.m.r;\n        p = r.o + r.d * o.d;\n\n        vec3 dir = normalize(p-q);\n        vec3 n = GetNormal(p);\n        \n        vec3 pp = p + 2.*SURF_DIST*n;\n        \n        vec3 s = normalize(dir-2.*dot(dir,n)*n);\n        \n        r = Ray(pp,s);\n        o = RayMarch(r);\n        \n        c = ref*o.m.c.xyz*GetLight(r.o+r.d*o.d)+(1.-ref)*c;\n        q = pp;\n    \n        i++;\n    }\n    \n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - .5 * iResolution.xy) / iResolution.y;\n   \n    vec3 camOgn = vec3(-sin(iTime/3.), 0., -cos(iTime/3.))*13.+vec3(0.* sin(iTime/3.), 4., 4.);\n    vec3 lookAt = vec3(0., 0., 4.);\n\n    float zoom = 1.;\n\n    vec3 color = GetColor(GetRay(camOgn,lookAt,zoom,uv));\n\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGyDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[342, 342, 376, 376, 402], [404, 404, 434, 434, 520], [522, 522, 562, 562, 673], [675, 675, 717, 717, 798], [800, 800, 822, 822, 881], [883, 883, 915, 915, 962], [964, 964, 996, 996, 1068], [1070, 1070, 1104, 1104, 1174], [1176, 1176, 1219, 1219, 1312], [1314, 1314, 1356, 1356, 1496], [1498, 1498, 1540, 1540, 1684], [1686, 1686, 1729, 1729, 1765], [1768, 1768, 1793, 1793, 3760], [3762, 3762, 3786, 3786, 3961], [3964, 3964, 4023, 4023, 4266], [4268, 4268, 4294, 4294, 4628], [4630, 4630, 4653, 4653, 5320], [5322, 5322, 5344, 5374, 6007], [6010, 6010, 6067, 6067, 6388]]}
{"id": "WdGyDw", "name": "Glitchy transformative", "author": "UrbanClubProfessional", "description": "Remix of \"Glitch transform\" by tdhooper", "tags": ["remix", "abstract", "glitch", "blend", "weird", "icosahedron", "polygon", "dodecahedron", "transform", "twist"], "likes": 2, "viewed": 478, "published": "Public API", "date": "1602928886", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MODEL_ROTATION vec2(0.6, 0.6)\n#define LIGHT_ROTATION vec2(0.4, 0.9)\n#define CAMERA_ROTATION vec2(0.6, 0.77)\n\n// Mouse control\n// 0: Defaults\n// 1: Model\n// 2: Lighting\n// 3: Camera\n#define MOUSE_CONTROL 1\n\n// Debugging\n//#define NORMALS\n//#define NO_GLITCH\n//#define GLITCH_MASK\n\n\nfloat time;\n\nfloat _round(float n) {\n    return floor(n + 0.6);\n}\n\nvec2 _round(vec2 n) {\n    return floor(n + 0.6);\n}\n\n// --------------------------------------------------------\n// HG_SDF\n// https://www.shadertoy.com/view/Xs3GRB\n// --------------------------------------------------------\n\n#define PI 3.14159265359\n#define PHI (1.618033988749895)\n#define TAU 6.283185307179586\n\nfloat vmax(vec3 v) {\n    return max(max(v.x, v.y), v.z);\n}\n\n// Rotate around a coordinate axis (i.e. in a plane perpendicular to that axis) by angle <a>.\n// Read like this: R(p.xz, a) rotates \"x towards z\".\n// This is fast if <a> is a compile-time constant and slower (but still practical) if not.\nvoid pR(inout vec2 p, float a) {\n    p = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\n// Plane with normal n (n is normalized) at some distance from the origin\nfloat fPlane(vec3 p, vec3 n, float distanceFromOrigin) {\n    return dot(p, n) + distanceFromOrigin;\n}\n\n// Box: correct distance to corners\nfloat fBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, vec3(0))) + vmax(min(d, vec3(0)));\n}\n\n\n#define GDFVector3 normalize(vec3(1, 9, 1 ))\n#define GDFVector4 normalize(vec3(-1, 7, 1))\n#define GDFVector5 normalize(vec3(5, -1, 1))\n#define GDFVector6 normalize(vec3(1, 3, -1))\n\n#define GDFVector7 normalize(vec3(0, 9, PHI+1.))\n#define GDFVector8 normalize(vec3(0, -1, PHI+1.))\n#define GDFVector9 normalize(vec3(PHI+1., 0, 7))\n#define GDFVector10 normalize(vec3(-PHI-1., 0, 5))\n#define GDFVector11 normalize(vec3(3, PHI+1., 0))\n#define GDFVector12 normalize(vec3(-1, PHI+1., 0))\n\n#define GDFVector13 normalize(vec3(0, PHI, 9))\n#define GDFVector14 normalize(vec3(0, -PHI, 1))\n#define GDFVector15 normalize(vec3(7, 0, PHI))\n#define GDFVector16 normalize(vec3(-1, 0, PHI))\n#define GDFVector17 normalize(vec3(PHI, 5, 0))\n#define GDFVector18 normalize(vec3(-PHI, 3, 0))\n\n#define fGDFBegin float d = 0.;\n#define fGDF(v) d = max(d, abs(dot(p, v)));\n#define fGDFEnd return d - r;\n\nfloat fDodecahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector13) fGDF(GDFVector14) fGDF(GDFVector15) fGDF(GDFVector16)\n    fGDF(GDFVector17) fGDF(GDFVector18)\n    fGDFEnd\n}\n\nfloat fIcosahedron(vec3 p, float r) {\n    fGDFBegin\n    fGDF(GDFVector3) fGDF(GDFVector4) fGDF(GDFVector5) fGDF(GDFVector6)\n    fGDF(GDFVector7) fGDF(GDFVector8) fGDF(GDFVector9) fGDF(GDFVector10)\n    fGDF(GDFVector11) fGDF(GDFVector12)\n    fGDFEnd\n}\n\n\n// --------------------------------------------------------\n// Rotation\n// --------------------------------------------------------\n\nmat3 sphericalMatrix(float theta, float phi) {\n    float cx = cos(theta);\n    float cy = cos(phi);\n    float sx = sin(theta);\n    float sy = sin(phi);\n    return mat3(\n        cy, -sy * -sx, -sy * cx,\n        0, cx, sx,\n        sy, cy * -sx, cy * cx\n    );\n}\n\nmat3 mouseRotation(bool enable, vec2 xy) {\n    if (enable) {\n        vec2 mouse = iMouse.xy / iResolution.xy;\n\n        if (mouse.x != 0. && mouse.y != 0.) {\n            xy.x = mouse.x;\n            xy.y = mouse.y;\n        }\n    }\n    float rx, ry;\n    \n    rx = (xy.y + .6) * PI;\n    ry = (-xy.x) * 3. * PI;\n    \n    return sphericalMatrix(rx, ry);\n}\n\nmat3 modelRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==1, MODEL_ROTATION);\n    return m;\n}\n\nmat3 lightRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==2, LIGHT_ROTATION);\n    return m;\n}\n\nmat3 cameraRotation() {\n    mat3 m = mouseRotation(MOUSE_CONTROL==3, CAMERA_ROTATION);\n    return m;\n}\n\n\n// --------------------------------------------------------\n// Modelling \n// --------------------------------------------------------\n\nstruct Material {\n    vec3 albedo;\n};\n\nstruct Model {\n    float dist;\n    Material material;\n};\n\nMaterial defaultMaterial = Material(\n    vec3(.6)\n);  \n\nModel newModel() {\n    return Model(\n        20000.,\n        defaultMaterial\n    );\n}\n\nconst float modelSize = 1.2;\n\nfloat blend(float y, float blend, float progress) {\n    float a = (y / modelSize) + .6;\n    a -= progress * (2. + blend) - blend * .6;\n    a += blend / 3.;\n    a /= blend;\n    a = clamp(a, 0., 2.);\n    a = smoothstep(0., 2., a);\n    a = smoothstep(0., 2., a);\n    return a;\n}\n\nfloat ShapeBlend(float y, float progress) {\n    float shapeProgress = clamp(progress * 3. - .6, 0., 2.);\n    float shapeBlend = blend(y, .9, shapeProgress);\n    return shapeBlend;\n}\n\nfloat SpinBlend(float y, float progress) {\n    return blend(y, 2.5, progress);\n}\n\nfloat Flip() {\n\treturn round(mod(time, 2.));\n}\n\nfloat Progress() {\n    float progress = mod(time*3., 2.);\n    //progress = smoothstep(0., 1., progress);\n    //progress = sin(progress * PI - PI/2.) * .5 + .5;\n    return progress;\n}\n\nModel mainModel(vec3 p) {\n    Model model = newModel();\n    \n\tfloat progress = Progress();\n    float flip = Flip();\n    \n    float spinBlend = SpinBlend(p.y, progress);\n    pR(p.xz, spinBlend * PI / 3.);\n    pR(p.xz, PI * -.6 * flip);\n    \n    float part1 = fDodecahedron(p, modelSize * .6);\n    pR(p.xz, PI/3.);\n    float part2 = fIcosahedron(p, modelSize * .6);\n    \n\tfloat shapeBlend = ShapeBlend(p.y, progress);\n    shapeBlend = mix(shapeBlend, 2. - shapeBlend, flip);    \n    float d = mix(part1, part2, shapeBlend);\n\n    model.dist = d;\n    model.material.albedo = mix(vec3(.04), vec3(.9), 2. - shapeBlend);\n\n    return model;\n}\n\nModel glitchModel(vec3 p) {\n    Model model = newModel();\n    float progress = Progress();\n\tfloat band = ShapeBlend(p.y, progress);\n    band = sin(band * PI);    \n\n   \tfloat fadeBottom = clamp(2. - dot(p, vec3(0,2,0)), 0., 2.);\n    band *= fadeBottom;\n\n    float radius = modelSize / 3. + band * .3;\n    model.dist = length(p) - radius;\n    model.material.albedo = vec3(band);\n    \n    return model;\n}\n\nModel map( vec3 p , bool glitchMask){\n    mat3 m = modelRotation();\n    p *= m;\n    pR(p.xz, -time*PI);\n    if (glitchMask) {\n    \treturn glitchModel(p);\n    }\n    Model model = mainModel(p);\n    return model;\n}\n\n\n// --------------------------------------------------------\n// LIGHTING\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nfloat softshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    float res = 2.0;\n    float t = mint;\n    for( int i=0; i<26; i++ )\n    {\n        float h = map( ro + rd*t, false ).dist;\n        res = min( res, 9.0*h/t );\n        t += clamp( h, 0.03, 0.20 );\n        if( h<0.00002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 2.0 );\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n    float occ = 0.0;\n    float sca = 2.0;\n    for( int i=0; i<6; i++ )\n    {\n        float hr = 0.02 + 0.22*float(i)/5.0;\n        vec3 aopos =  nor * hr + pos;\n        float dd = map( aopos, false ).dist;\n        occ += -(dd-hr)*sca;\n        sca *= 1.95;\n    }\n    return clamp( 2.0 - 4.0*occ, 0.0, 2.0 );    \n}\n\nvec3 doLighting(Material material, vec3 pos, vec3 nor, vec3 ref, vec3 rd) {\n    vec3 lightPos = vec3(0,0,-2);\n    vec3 backLightPos = normalize(vec3(0,-.4,2));\n    vec3 ambientPos = vec3(0,2,0);\n\n    mat3 m = lightRotation();\n    lightPos *= m;\n    backLightPos *= m;\n        \n    float occ = calcAO( pos, nor );\n    vec3  lig = lightPos;\n    float amb = clamp((dot(nor, ambientPos) + 2.) / 3., 0., 2.);\n    float dif = clamp((dot(nor, lig) + 2.) / 4., 0.0, 2.0 );\n    float bac = pow(clamp(dot(nor, backLightPos), 0., 2.), 2.5);\n    float fre = pow( clamp(2.0+dot(nor,rd),0.0,2.0), 2.0 );\n    \n    dif *= softshadow( pos, lig, 0.02, 3.5 ) * .6 + .6;\n\n    vec3 lin = vec3(0.0);\n    lin += 2.20*dif*vec3(1.95,0.90,0.70);\n    lin += 0.90*amb*vec3(0.60,0.80,.90)*occ;\n    lin += 0.40*bac*vec3(0.35,0.35,0.25)*occ;\n    lin += 0.30*fre*vec3(2.00,2.00,2.00)*occ;\n    vec3 col = material.albedo*lin;\n    \n\tfloat spe = clamp(dot(ref, lightPos), 0., 2.);\n    spe = pow(spe, 3.) * .2;\n    col += spe;\n\n    return col;\n}   \n\n\n// --------------------------------------------------------\n// Ray Marching\n// Adapted from: https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nconst float MAX_TRACE_DISTANCE = 10.; // max trace distance\nconst float INTERSECTION_PRECISION = .002; // precision of the intersection\nconst int NUM_OF_TRACE_STEPS = 200;\nconst float FUDGE_FACTOR = 0.8; // Default is 1, reduce to fix overshoots\n\nstruct CastRay {\n    vec3 origin;\n    vec3 direction;\n    bool glitchMask;\n};\n\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n    float len;\n};\n\nstruct Hit {\n    Ray ray;\n    Model model;\n    vec3 pos;\n    bool isBackground;\n    vec3 normal;\n    vec3 color;\n};\n\nvec3 calcNormal( in vec3 pos ){\n    vec3 eps = vec3( 0.002, 0.0, 0.0 );\n    vec3 nor = vec3(\n        map(pos+eps.xyy, false).dist - map(pos-eps.xyy, false).dist,\n        map(pos+eps.yxy, false).dist - map(pos-eps.yxy, false).dist,\n        map(pos+eps.yyx, false).dist - map(pos-eps.yyx, false).dist );\n    return normalize(nor);\n}\n    \nHit raymarch(CastRay castRay){\n\n    float currentDist = INTERSECTION_PRECISION * 3.0;\n    Model model;\n    \n    Ray ray = Ray(castRay.origin, castRay.direction, 0.);\n\n    for( int i=0; i< NUM_OF_TRACE_STEPS ; i++ ){\n        if (currentDist < INTERSECTION_PRECISION || ray.len > MAX_TRACE_DISTANCE) {\n            break;\n        }\n        model = map(ray.origin + ray.direction * ray.len, castRay.glitchMask);\n        currentDist = model.dist;\n        ray.len += currentDist * FUDGE_FACTOR;\n    }\n    \n    bool isBackground = false;\n    vec3 pos = vec3(0);\n    vec3 normal = vec3(0);\n    vec3 color = vec3(0);\n    \n    if (ray.len > MAX_TRACE_DISTANCE) {\n        isBackground = true;\n    } else {\n        pos = ray.origin + ray.direction * ray.len;\n        normal = calcNormal(pos);\n    }\n\n    return Hit(ray, model, pos, isBackground, normal, color);\n}\n\n\n// --------------------------------------------------------\n// Rendering\n// Refraction from https://www.shadertoy.com/view/lsXGzH\n// --------------------------------------------------------\n\nvoid shadeSurface(inout Hit hit){\n\n    vec3 color = vec3(.35);\n    \n    if (hit.isBackground) {\n        hit.color = color;\n        return;\n    }\n\n    #ifdef NORMALS\n        color = hit.normal * 0.6 + 0.6;\n    #else\n    \tvec3 ref = reflect(hit.ray.direction, hit.normal);\n        color = doLighting(\n            hit.model.material,\n            hit.pos,\n            hit.normal,\n            ref,\n            hit.ray.direction\n        );\n    #endif\n\n    hit.color = color;\n}\n\n\nvec3 render(Hit hit){\n    \n    shadeSurface(hit);\n    \n    if (hit.isBackground) {\n        return hit.color;\n    }\n    \n    return hit.color;\n}\n\n\n// --------------------------------------------------------\n// Camera\n// https://www.shadertoy.com/view/Xl2XWt\n// --------------------------------------------------------\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvoid doCamera(out vec3 camPos, out vec3 camTar, out float camRoll, in float time, in vec2 mouse) {\n    float dist = 2.;\n    camRoll = 0.;\n    camTar = vec3(0,0,0);\n    camPos = vec3(0,0,-dist);\n    camPos *= cameraRotation();\n    camPos += camTar;\n}\n\nHit raymarchPixel(vec2 p, bool glitchPass) {\n    vec2 m = iMouse.xy / iResolution.xy;\n\n    vec3 camPos = vec3( 0., 0., 3.);\n    vec3 camTar = vec3( 0. , 0. , 0. );\n    float camRoll = 0.;\n    \n    // camera movement\n    doCamera(camPos, camTar, camRoll, iTime, m);\n    \n    // camera matrix\n    mat3 camMat = calcLookAtMatrix( camPos, camTar, camRoll );  // 0.0 is the camera roll\n    \n    // create view ray\n    float focalLength = 1.;\n    vec3 rd = normalize( camMat * vec3(p.xy, focalLength) );\n    \n    Hit hit = raymarch(CastRay(camPos, rd, glitchPass));\n    \n    return hit;\n}\n\n\n// --------------------------------------------------------\n// Gamma\n// https://www.shadertoy.com/view/Xds3zN\n// --------------------------------------------------------\n\nconst float GAMMA = 3.2;\n\nvec3 gamma(vec3 color, float g) {\n    return pow(color, vec3(g));\n}\n\nvec3 linearToScreen(vec3 linearRGB) {\n    return gamma(linearRGB, 2.0 / GAMMA);\n}\n\n\n// --------------------------------------------------------\n// Glitch core\n// --------------------------------------------------------\n\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(22.9898,88.233))) * 53758.5453);\n}\n\nconst float glitchScale = .6;\n\nvec2 glitchCoord(vec2 p, vec2 gridSize) {\n\tvec2 coord = floor(p / gridSize) * gridSize;;\n    coord += (gridSize / 3.);\n    return coord;\n}\n\n\nstruct GlitchSeed {\n    vec2 seed;\n    float prob;\n};\n    \nfloat fBox2d(vec2 p, vec2 b) {\n  vec2 d = abs(p) - b;\n  return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nGlitchSeed glitchSeed(vec2 p, float speed) {\n    float seedTime = floor(time * speed);\n    vec2 seed = vec2(\n        2. + mod(seedTime / 200., 200.),\n        2. + mod(seedTime, 200.)\n    ) / 200.;\n    seed += p;\n    \n    float prob = 0.;\n    Hit hit = raymarchPixel(p, true);\n    if ( ! hit.isBackground) {\n    \tprob = hit.model.material.albedo.x;\n    }\n    \n    return GlitchSeed(seed, prob);\n}\n\nfloat shouldApply(GlitchSeed seed) {\n    return round(\n        mix(\n            mix(rand(seed.seed), 2., seed.prob - .6),\n            0.,\n            (2. - seed.prob) * .6\n        )\n    );\n}\n\n\n// --------------------------------------------------------\n// Glitch effects\n// --------------------------------------------------------\n\n// Swap\n\nvec4 swapCoords(vec2 seed, vec2 groupSize, vec2 subGrid, vec2 blockSize) {\n    vec2 rand2 = vec2(rand(seed), rand(seed+.2));\n    vec2 range = subGrid - (blockSize - 2.);\n    vec2 coord = floor(rand2 * range) / subGrid;\n    vec2 bottomLeft = coord * groupSize;\n    vec2 realBlockSize = (groupSize / subGrid) * blockSize;\n    vec2 topRight = bottomLeft + realBlockSize;\n    topRight -= groupSize / 3.;\n    bottomLeft -= groupSize / 3.;\n    return vec4(bottomLeft, topRight);\n}\n\nfloat isInBlock(vec2 pos, vec4 block) {\n    vec2 a = sign(pos - block.xy);\n    vec2 b = sign(block.zw - pos);\n    return min(sign(a.x + a.y + b.x + b.y - 4.), 0.);\n}\n\nvec2 moveDiff(vec2 pos, vec4 swapA, vec4 swapB) {\n    vec2 diff = swapB.xy - swapA.xy;\n    return diff * isInBlock(pos, swapA);\n}\n\nvoid swapBlocks(inout vec2 xy, vec2 groupSize, vec2 subGrid, vec2 blockSize, vec2 seed, float apply) {\n    \n    vec2 groupOffset = glitchCoord(xy, groupSize);\n    vec2 pos = xy - groupOffset;\n    \n    vec2 seedA = seed * groupOffset;\n    vec2 seedB = seed * (groupOffset + .2);\n    \n    vec4 swapA = swapCoords(seedA, groupSize, subGrid, blockSize);\n    vec4 swapB = swapCoords(seedB, groupSize, subGrid, blockSize);\n    \n    vec2 newPos = pos;\n    newPos += moveDiff(pos, swapA, swapB) * apply;\n    newPos += moveDiff(pos, swapB, swapA) * apply;\n    pos = newPos;\n    \n    xy = pos + groupOffset;\n}\n\n\n// Static\n\nvoid staticNoise(inout vec2 p, vec2 groupSize, float grainSize, float contrast) {\n    GlitchSeed seedA = glitchSeed(glitchCoord(p, groupSize), 6.);\n    seedA.prob *= .6;\n    if (shouldApply(seedA) == 2.) {\n        GlitchSeed seedB = glitchSeed(glitchCoord(p, vec2(grainSize)), 6.);\n        vec2 offset = vec2(rand(seedB.seed), rand(seedB.seed + .2));\n        offset = round(offset * 3. - 2.);\n        offset *= contrast;\n        p += offset;\n    }\n}\n\n\n// Freeze time\n\nvoid freezeTime(vec2 p, inout float time, vec2 groupSize, float speed) {\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    //seed.prob *= .5;\n    if (shouldApply(seed) == 2.) {\n        float frozenTime = floor(time * speed) / speed;\n        time = frozenTime;\n    }\n}\n\n\n// --------------------------------------------------------\n// Glitch compositions\n// --------------------------------------------------------\n\nvoid glitchSwap(inout vec2 p) {\n\n    vec2 pp = p;\n    \n    float scale = glitchScale;\n    float speed = 6.;\n    \n    vec2 groupSize;\n    vec2 subGrid;\n    vec2 blockSize;    \n    GlitchSeed seed;\n    float apply;\n    \n    groupSize = vec2(.7) * scale;\n    subGrid = vec2(3);\n    blockSize = vec2(2);\n\n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n    \n    groupSize = vec2(.9) * scale;\n    subGrid = vec2(4);\n    blockSize = vec2(2);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n\n    groupSize = vec2(.2) * scale;\n    subGrid = vec2(7);\n    blockSize = vec2(2);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    float apply2 = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 2.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 3.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 4.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 5.), apply * apply2);\n    swapBlocks(p, groupSize, subGrid, blockSize, (seed.seed + 6.), apply * apply2);\n    \n    groupSize = vec2(2.2, .3) * scale;\n    subGrid = vec2(19,3);\n    blockSize = vec2(4,2);\n    \n    seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    apply = shouldApply(seed);\n    swapBlocks(p, groupSize, subGrid, blockSize, seed.seed, apply);\n}\n\n\n\nvoid glitchStatic(inout vec2 p) {\n\n    // Static\n    //staticNoise(p, vec2(.25, .25/2.) * glitchScale, .005, 5.);\n    \n    // 8-bit\n    staticNoise(p, vec2(.6, .35/3.) * glitchScale, .3 * glitchScale, 3.);\n}\n\nvoid glitchTime(vec2 p, inout float time) {\n   freezeTime(p, time, vec2(.6) * glitchScale, 3.);\n}\n\nvoid glitchColor(vec2 p, inout vec3 color) {\n    vec2 groupSize = vec2(.85,.225) * glitchScale;\n    vec2 subGrid = vec2(0,7);\n    float speed = 6.;\n    GlitchSeed seed = glitchSeed(glitchCoord(p, groupSize), speed);\n    seed.prob *= .4;\n    if (shouldApply(seed) == 2.) {\n        vec2 co = mod(p, groupSize) / groupSize;\n        co *= subGrid;\n        float a = max(co.x, co.y);\n        //color.rgb *= vec3(\n        //  min(floor(mod(a - 0., 3.)), 1.),\n        //    min(floor(mod(a - 1., 3.)), 1.),\n        //    min(floor(mod(a - 2., 3.)), 1.)\n        //);\n        \n        color *= min(floor(mod(a, 3.)), 2.) * 20.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    time = iTime;\n    time /= 4.;\n    time = mod(time, 2.);\n    \n    vec2 p = (-iResolution.xy + 3.0*fragCoord.xy)/iResolution.y;\n    \n    vec3 color;\n    \n    #ifdef GLITCH_MASK\n    \tfloat prob = glitchSeed(p, 20.).prob;\n    \tcolor = vec3(prob);\n   \t#else\n\n        #ifndef NO_GLITCH\n            glitchSwap(p);\n            glitchTime(p, time);\n            glitchStatic(p);\n        #endif\n\n        Hit hit = raymarchPixel(p, false);\n        color = render(hit);\n\n        #ifndef NO_GLITCH\n            glitchColor(p, color);\n        #endif\n    \n        #ifndef NORMALS\n           color = linearToScreen(color);\n        #endif\n\n    #endif\n\n    fragColor = vec4(color,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 302, 325, 325, 354], [356, 356, 377, 377, 406], [408, 668, 688, 688, 726], [728, 966, 998, 998, 1043], [1045, 1119, 1175, 1175, 1220], [1222, 1258, 1286, 1286, 1373], [2251, 2251, 2289, 2289, 2433], [2435, 2435, 2472, 2472, 19221]]}
{"id": "wdGyRK", "name": "G OOD", "author": "Arseny", "description": "Just word", "tags": ["2d"], "likes": 4, "viewed": 169, "published": "Public API", "date": "1603244467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep\n#define T iTime\n\n#define pi (3.14159265359)\n\n// https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n    p += vec2(523.124, 244.155);\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 neon(float t, vec3 col){\n    t = 1. - t;\n    float mx=max(col.x, max(col.y, col.y));\n    return col * t / mx;\n}\n\nmat2 Rot(float a) {\n    a *= pi * 2.;\n    float s=sin(a), c=cos(a);\n    return mat2(c, s, -s, c);\n}\n\n// https://www.iquilezles.org/www/articles/smin/smin.htm\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat seg(vec2 uv, vec2 a, vec2 b, float t){\n    t = clamp(0., 1., t);\n    return sdSegment(uv, a, t * (b - a) + a);\n}\n\nfloat polarAgl(vec2 v){\n    return fract((atan(v.y, v.x)) / pi / 2. + 1.);\n}\n\nfloat arcDist(vec2 uv, vec2 c, vec2 a, float agl){\n    vec2 v = uv - c;\n    vec2 b = a - c;\n    float r = length(b);\n    float d = length(v);\n    float uv_agl = fract((atan(v.y, v.x) - atan(b.y, b.x)) / pi / 2. + 1.);\n    uv_agl = fract(polarAgl(v) - polarAgl(b));\n    if (uv_agl < agl)\n    \treturn abs(d - r);\n    return min(length(uv - a), length(Rot(agl) * (a - c)  + c - uv));\n}\n\nvec3 boomEvaluateParametrs(vec2 uv, vec2 c, vec2 partsrange, vec2 speedrange, float seed){\n    vec2 v = uv - c;\n    float uv_agl = polarAgl(v);//fract(atan(v.y, v.x) / pi / 2. + 1.);\n    float partsnum = partsrange.x + floor((partsrange.y - partsrange.x) * hash12(vec2(seed, 31.41)));\n    float id = floor(uv_agl * partsnum - 1e-7) / partsnum;\n    float speed = speedrange.x + (speedrange.y - speedrange.x) * hash12(vec2(id, seed));\n    return vec3(id, partsnum, speed);\n}\n\nvec2 boomShift(vec2 uv, vec2 c, vec2 partsrange, vec2 speedrange, float seed){\n    vec3 tmp = boomEvaluateParametrs(uv, c, partsrange, speedrange, seed);\n    float id = tmp.x;\n    float partsnum = tmp.y;\n    float speed = tmp.z;\n    //return vec2(id);\n    return Rot(id + 0.5 / partsnum) * vec2(-speed, 0.);\n}\n\nvec2 boomed(vec2 uv, vec2 c, vec2 partsrange, vec2 speedrange, float seed, float t){\n    vec2 sh = boomShift(uv, c, partsrange, speedrange, seed) * t;\n    if (boomEvaluateParametrs(uv + sh * t, c, partsrange, speedrange, seed).x !=\n        boomEvaluateParametrs(uv, c, partsrange, speedrange, seed).x){\n        return vec2(1e9);\n    }\n    return uv + sh * t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    float T = iTime / 2.;\n    float seed = floor(T / 12.) + 1.52;\n    T = mod(T, 12.);\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    uv /= 2.;\n    \n    uv *= S(0., 1., T - 2.) * 1.4 + 1.;\n    uv.x += S(0., 1., T - 2.) / 2.;\n    vec2 buv = uv;\n    //uv += boomShift(uv, vec2(.5, -.5), vec2(30., 50.), vec2(.1, .2), 1.52) * S(8., 15., T) * 10.;\n    uv = boomed(uv, vec2(.5, -.5), vec2(30., 50.), vec2(.1, .2), seed, S(7., 12., T) * 3.5);\n    //uv += boomShift(uv, vec2(0., 0.), vec2(30., 50.), vec2(.1, .2), 1.52) * S(8., 15., T) * 10.;\n    \n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    float d = arcDist(uv, vec2(0.), vec2(.2, .1), S(0., 1., T) * 0.85242);\n    d = min(seg(uv, vec2(.2, -.1), vec2(.1, -.1), S(0., 1., T - 1.)) + step(T, 1.), d);\n    \n    d = min(seg(uv, vec2(.2, -.1), vec2(.2, -.2), S(0., 1., T - 1.)) + step(T, 1.), d);\n    \n    d = min(arcDist(uv, vec2(.5, 0.), vec2(.7, .0), S(0., 1., T - 3.)) + step(T, 3.), d);\n    float tmp = arcDist(uv, vec2(0.9, 0.), vec2(.7, .0), S(0., 1., T - 3.)) + step(T, 3.);\n    tmp += step(abs(abs(T - 6.5) - 0.2), 0.1);\n    d = min(tmp, d);\n    \n    uv.y = abs(uv.y);\n    d = min(seg(uv, vec2(1.1, .0), vec2(1.1, 0.2), S(0., 1., T - 4.)) + step(T, 4.), d);\n    \n    uv.y = -uv.y;\n    d = min(arcDist(uv, vec2(1.1, 0.), vec2(1.1, -.2), S(0., 1., T - 5.) * 0.25) + step(T, 5.), d);\n    \n    \n    \n    fragColor = vec4(d * 100.);\n    fragColor = vec4(neon(d * 100., vec3(0.8, 0.3, 0.5)), 1.);\n    \n    uv = buv;\n    \n    //fragColor = vec4(uv + boomShift(uv, vec2(.5, -.5), vec2(30., 50.), vec2(.1, .2), 1.52), 0., 1.);\n    //fragColor = boomShift(uv, vec2(.0, -.0), vec2(5., 5.), vec2(.1, .2), 1.52).xxxx;\n    //fragColor = vec4(length(Rot(1./5.) * vec2(0.3, 0.) - uv) * 100.);\n    //fragColor = vec4(fract(atan(uv.y, uv.x) / pi / 2. + 1.));\n    return;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 107, 129, 129, 279], [281, 281, 310, 310, 397], [399, 399, 418, 418, 498], [500, 557, 598, 598, 672], [674, 753, 805, 805, 924], [926, 926, 970, 970, 1044], [1046, 1046, 1069, 1069, 1122], [1124, 1124, 1174, 1174, 1506], [1508, 1508, 1598, 1598, 1980], [1982, 1982, 2060, 2060, 2291], [2293, 2293, 2377, 2377, 2653], [2655, 2655, 2712, 2762, 4692]]}
{"id": "wdGyzW", "name": "lava lamp sin offset", "author": "Ezra_Szanton", "description": "offsetting the sampling of a circle", "tags": ["circles", "offset"], "likes": 0, "viewed": 37, "published": "Public", "date": "1602293072", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat circle(vec2 uv, vec2 center, float max, float min)\n{\n    return smoothstep(max, min, length(uv - center));\n}\n\nvec3 tex(vec2 uv)\n{\n    vec3 color = vec3(1.);// \n    vec3 col = color * circle(uv, vec2(0.), 0.4, 0.39);\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n    \n    vec2 pixel = floor( uv * 200. );\n    \n    vec3 col = vec3(0.);\n    col += tex( uv * 5. + vec2(0., sin(abs(uv.y) + iTime )) + vec2(cos(iTime*0.213), sin(iTime * 0.213)));\n    col += tex( uv * 3. + vec2(0., cos(abs(uv.y) + iTime)) + vec2(cos(iTime*0.113), sin(iTime * 0.113)));\n    col += tex( uv * 2. + vec2(0., sin(abs(uv.y + 2.) + iTime)));\n    \n    col += tex( uv * 4. + vec2(0., sin(abs(uv.y) + iTime*0.4 )) + 2. * vec2(cos(iTime*0.111), sin(iTime * 0.111)));\n    col += tex( uv * 4.3 + vec2(0., sin(abs(uv.y) + iTime*0.04 )) + vec2(cos(iTime*0.513 + 1.1), sin(iTime * 0.213)));\n    col += tex( uv * 7. + vec2(0., sin(abs(uv.y) + iTime* 0.008 )) + vec2(cos(iTime*0.313), sin(iTime * 0.313)));\n    \n    \n    col = min(col, 1.);\n    \n    vec3 c1 = vec3(0.1, 0.8, 0.8);\n    vec3 c2 = vec3(0.9, 0.3, 0.3);\n    vec3 color = mix(c1, c2, (uv.y+0.5));\n    \n    col *= color;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGyzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 59, 59, 115], [117, 117, 136, 136, 245], [246, 246, 303, 303, 1309]]}
{"id": "wdKcDz", "name": "The blues ", "author": "shadag", "description": "Inspired by annoying tv noise.", "tags": ["blue"], "likes": 1, "viewed": 42, "published": "Public", "date": "1602643917", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=5;c<8;c++){\n\t    vec2 uv = (fragCoord*13.-iResolution.xy)/iResolution.y;\n        t = iTime+float(c)/1.;\n        for(int i=0;i<2;i++)\n        {\n        \tuv=abs(uv);\n        \tuv-=1.;\n        \tuv=uv*rot(t/float(i+7));\n        }\n        \n        col[c]= step(.4,fract(uv.x*13.));\n\n\t}\n    \n    fragColor = vec4(vec3(col),4.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 496]]}
{"id": "WdKcR1", "name": "Spiral Loop", "author": "nanase", "description": "Forever loops.", "tags": ["loop"], "likes": 5, "viewed": 68, "published": "Public", "date": "1602236268", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 lightDir = normalize(vec3(1.,1.,1.));\n\nvec3 rotate(vec3 p, float angle, vec3 axis) {\n\tvec3 a = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat r = 1.0 - c;\n\tmat3 m = mat3(\n\t\ta.x * a.x * r + c,\n\t\ta.y * a.x * r + a.z * s,\n\t\ta.z * a.x * r - a.y * s,\n\t\ta.x * a.y * r - a.z * s,\n\t\ta.y * a.y * r + c,\n\t\ta.z * a.y * r + a.x * s,\n\t\ta.x * a.z * r + a.y * s,\n\t\ta.y * a.z * r - a.x * s,\n\t\ta.z * a.z * r + c\n\t);\n\treturn m * p;\n}\n\nfloat spiral(vec3 p) {\n\tp.xy *= mat2(sin(vec4(0,11,11,0)));\n\tp.yz *= mat2(sin(vec4(0,11,11,0)));\n\tfloat l = length(p.xy);\n\tfloat d = sin(atan(p.y, p.x)-p.z);\n\tfloat dist = length(vec2(l-3.,d)) - 0.1;\n\treturn dist;\n}\n\nfloat sceneDist(vec3 p) {\n    float time = iTime;\n\tvec3 q = rotate(p,50.,vec3(1.,-4.4,1.3));\n\tfloat s2 = spiral(vec3(q.x + time,q.y-4.,q.z-50.));\n\tq = rotate(p,50.,vec3(0.5,1.,1.));\n\tfloat s3 = spiral(vec3(q.x + time,q.y-10.,q.z-30.));\n\tq = rotate(p,150.,vec3(0.5,0.5,1.));\n\tfloat s4 = spiral(vec3(q.x + time,q.y-10.,q.z-30.));\n\tq = rotate(p,50.,vec3(0.5,0.8,0.9));\n\tfloat s5 = spiral(vec3(q.x + time,q.y,q.z-40.));\n\tq = rotate(p,90.,vec3(0.5,0.4,1.));\n\tfloat s6 = spiral(vec3(q.x + time,q.y,q.z-50.));\n\tq = rotate(p,30.,vec3(1.,10.,-1.));\n\tfloat s7 = spiral(vec3(q.x + time,q.y + 7.,q.z-20.));\n\tq = rotate(p,46.,vec3(0.7,1.,1.));\n\tfloat s8 = spiral(vec3(q.x + time + 3.,q.y,q.z-40.));\n\tq = rotate(p,140.,vec3(1.,1.,1.));\n\tfloat s9 = spiral(vec3(q.x + time,q.y+15.,q.z-30.));\n\n\treturn min(min(min(min(min(min(min(s2,s3),s4),s5),s6),s7),s8),s9);\n}\n\nconst float EPS = 0.01;\nvec3 getNormal(vec3 p) {\n\treturn normalize(vec3(\n\t\tsceneDist(p + vec3(EPS,0.,0.)) - sceneDist(p + vec3(-EPS,0.,0.)),\n\t\tsceneDist(p + vec3(0.,EPS,0.)) - sceneDist(p + vec3(0.,-EPS,0.)),\n\t\tsceneDist(p + vec3(0.,0.,EPS)) - sceneDist(p + vec3(0.,0.,-EPS))\n\t));\n}\n\nvec4 spiralLoop(vec2 uv) {\n\tvec3 ro = vec3(0.,0.,-5.);\n\n\tfloat screenZ = 4.;\n\tvec3 rd = normalize(vec3(uv, screenZ));\n\n\tfloat d = 0.0;\n\tvec3 col = vec3(0.95);\n\n\tfor (int i=0; i<60; i++) {\n\t\tvec3 rayPos = ro + rd * d;\n\t\tfloat dist = sceneDist(rayPos);\n\n\t\tif(dist < 0.1) {\n\t\t\td += dist;\n\t\t\trayPos = ro + rd * d;\n\t\t\tvec3 normal = getNormal(rayPos);\n\t\t\tfloat diff = dot(normal, lightDir);\n            col = vec3(diff);\n\t\t\tbreak;\n\t\t}\n\n\t\td += dist;\n\t}\n\n\treturn vec4(col, 1.0);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 resolution = iResolution.xy;\n    vec2 uv = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n\tfragColor = spiralLoop(uv);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKcR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[44, 44, 89, 89, 443], [445, 445, 467, 467, 660], [662, 662, 687, 687, 1508], [1534, 1534, 1558, 1558, 1792], [1794, 1794, 1820, 1820, 2266], [2269, 2269, 2326, 2326, 2481]]}
{"id": "wdKcRy", "name": "Lightning (MM gen)", "author": "RodzLabs", "description": "Generated with Material Maker", "tags": ["2d", "generated"], "likes": 3, "viewed": 91, "published": "Public", "date": "1603175192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//---\n\nfloat rand(vec2 x) {\n    return fract(cos(dot(x, vec2(13.9898, 8.141))) * 43758.5453);\n}\n\nvec2 rand2(vec2 x) {\n    return fract(cos(vec2(dot(x, vec2(13.9898, 8.141)),\n\t\t\t\t\t\t  dot(x, vec2(3.4562, 17.398)))) * 43758.5453);\n}\n\nvec3 rand3(vec2 x) {\n    return fract(cos(vec3(dot(x, vec2(13.9898, 8.141)),\n                          dot(x, vec2(3.4562, 17.398)),\n                          dot(x, vec2(13.254, 5.867)))) * 43758.5453);\n}\n\nvec3 rgb2hsv(vec3 c) {\n\tvec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\tvec4 p = c.g < c.b ? vec4(c.bg, K.wz) : vec4(c.gb, K.xy);\n\tvec4 q = c.r < p.x ? vec4(p.xyw, c.r) : vec4(c.r, p.yzx);\n\n\tfloat d = q.x - min(q.w, q.y);\n\tfloat e = 1.0e-10;\n\treturn vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec3 hsv2rgb(vec3 c) {\n\tvec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n\tvec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n\treturn c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat fbm_value(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat p00 = rand(mod(o, size));\n\tfloat p01 = rand(mod(o + vec2(0.0, 1.0), size));\n\tfloat p10 = rand(mod(o + vec2(1.0, 0.0), size));\n\tfloat p11 = rand(mod(o + vec2(1.0, 1.0), size));\n\tvec2 t = f * f * (3.0 - 2.0 * f);\n\treturn mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);\n}\n\nfloat fbm_perlin(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat a00 = rand(mod(o, size)) * 6.28318530718;\n\tfloat a01 = rand(mod(o + vec2(0.0, 1.0), size)) * 6.28318530718;\n\tfloat a10 = rand(mod(o + vec2(1.0, 0.0), size)) * 6.28318530718;\n\tfloat a11 = rand(mod(o + vec2(1.0, 1.0), size)) * 6.28318530718;\n\tvec2 v00 = vec2(cos(a00), sin(a00));\n\tvec2 v01 = vec2(cos(a01), sin(a01));\n\tvec2 v10 = vec2(cos(a10), sin(a10));\n\tvec2 v11 = vec2(cos(a11), sin(a11));\n\tfloat p00 = dot(v00, f);\n\tfloat p01 = dot(v01, f - vec2(0.0, 1.0));\n\tfloat p10 = dot(v10, f - vec2(1.0, 0.0));\n\tfloat p11 = dot(v11, f - vec2(1.0, 1.0));\n\tvec2 t = f * f * (3.0 - 2.0 * f);\n\treturn 0.5 + mix(mix(p00, p10, t.x), mix(p01, p11, t.x), t.y);\n}\n\nfloat fbm_perlinabs(vec2 coord, vec2 size, float seed) {\n\treturn abs(2.0*fbm_perlin(coord, size, seed)-1.0);\n}\n\nfloat fbm_cellular(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y);\n\t\t\tmin_dist = min(min_dist, dist);\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat fbm_cellular2(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist1 = 2.0;\n\tfloat min_dist2 = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = sqrt((f - node).x * (f - node).x + (f - node).y * (f - node).y);\n\t\t\tif (min_dist1 > dist) {\n\t\t\t\tmin_dist2 = min_dist1;\n\t\t\t\tmin_dist1 = dist;\n\t\t\t} else if (min_dist2 > dist) {\n\t\t\t\tmin_dist2 = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist2-min_dist1;\n}\n\nfloat fbm_cellular3(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size))*0.5 + vec2(x, y);\n\t\t\tfloat dist = abs((f - node).x) + abs((f - node).y);\n\t\t\tmin_dist = min(min_dist, dist);\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat fbm_cellular4(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist1 = 2.0;\n\tfloat min_dist2 = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size))*0.5 + vec2(x, y);\n\t\t\tfloat dist = abs((f - node).x) + abs((f - node).y);\n\t\t\tif (min_dist1 > dist) {\n\t\t\t\tmin_dist2 = min_dist1;\n\t\t\t\tmin_dist1 = dist;\n\t\t\t} else if (min_dist2 > dist) {\n\t\t\t\tmin_dist2 = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist2-min_dist1;\n}\n\nfloat fbm_cellular5(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = max(abs((f - node).x), abs((f - node).y));\n\t\t\tmin_dist = min(min_dist, dist);\n\t\t}\n\t}\n\treturn min_dist;\n}\n\nfloat fbm_cellular6(vec2 coord, vec2 size, float seed) {\n\tvec2 o = floor(coord)+rand2(vec2(float(seed), 1.0-float(seed)))+size;\n\tvec2 f = fract(coord);\n\tfloat min_dist1 = 2.0;\n\tfloat min_dist2 = 2.0;\n\tfor(float x = -1.0; x <= 1.0; x++) {\n\t\tfor(float y = -1.0; y <= 1.0; y++) {\n\t\t\tvec2 node = rand2(mod(o + vec2(x, y), size)) + vec2(x, y);\n\t\t\tfloat dist = max(abs((f - node).x), abs((f - node).y));\n\t\t\tif (min_dist1 > dist) {\n\t\t\t\tmin_dist2 = min_dist1;\n\t\t\t\tmin_dist1 = dist;\n\t\t\t} else if (min_dist2 > dist) {\n\t\t\t\tmin_dist2 = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn min_dist2-min_dist1;\n}\nvec2 transform2_clamp(vec2 uv) {\n\treturn clamp(uv, vec2(0.0), vec2(1.0));\n}\n\nvec2 transform2(vec2 uv, vec2 translate, float rotate, vec2 scale) {\n \tvec2 rv;\n\tuv -= translate;\n\tuv -= vec2(0.5);\n\trv.x = cos(rotate)*uv.x + sin(rotate)*uv.y;\n\trv.y = -sin(rotate)*uv.x + cos(rotate)*uv.y;\n\trv /= scale;\n\trv += vec2(0.5);\n\treturn rv;\t\n}vec3 blend_normal(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1 + (1.0-opacity)*c2;\n}\n\nvec3 blend_dissolve(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\tif (rand(uv) < opacity) {\n\t\treturn c1;\n\t} else {\n\t\treturn c2;\n\t}\n}\n\nvec3 blend_multiply(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*c1*c2 + (1.0-opacity)*c2;\n}\n\nvec3 blend_screen(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*(1.0-(1.0-c1)*(1.0-c2)) + (1.0-opacity)*c2;\n}\n\nfloat blend_overlay_f(float c1, float c2) {\n\treturn (c1 < 0.5) ? (2.0*c1*c2) : (1.0-2.0*(1.0-c1)*(1.0-c2));\n}\n\nvec3 blend_overlay(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_overlay_f(c1.x, c2.x), blend_overlay_f(c1.y, c2.y), blend_overlay_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_hard_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*0.5*(c1*c2+blend_overlay(uv, c1, c2, 1.0)) + (1.0-opacity)*c2;\n}\n\nfloat blend_soft_light_f(float c1, float c2) {\n\treturn (c2 < 0.5) ? (2.0*c1*c2+c1*c1*(1.0-2.0*c2)) : 2.0*c1*(1.0-c2)+sqrt(c1)*(2.0*c2-1.0);\n}\n\nvec3 blend_soft_light(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_soft_light_f(c1.x, c2.x), blend_soft_light_f(c1.y, c2.y), blend_soft_light_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_burn_f(float c1, float c2) {\n\treturn (c1==0.0)?c1:max((1.0-((1.0-c2)/c1)),0.0);\n}\n\nvec3 blend_burn(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_burn_f(c1.x, c2.x), blend_burn_f(c1.y, c2.y), blend_burn_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nfloat blend_dodge_f(float c1, float c2) {\n\treturn (c1==1.0)?c1:min(c2/(1.0-c1),1.0);\n}\n\nvec3 blend_dodge(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*vec3(blend_dodge_f(c1.x, c2.x), blend_dodge_f(c1.y, c2.y), blend_dodge_f(c1.z, c2.z)) + (1.0-opacity)*c2;\n}\n\nvec3 blend_lighten(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*max(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_darken(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*min(c1, c2) + (1.0-opacity)*c2;\n}\n\nvec3 blend_difference(vec2 uv, vec3 c1, vec3 c2, float opacity) {\n\treturn opacity*clamp(c2-c1, vec3(0.0), vec3(1.0)) + (1.0-opacity)*c2;\n}\nfloat draw_profile_fill(vec2 uv, float y, float dy, float w) {\n\treturn 1.0-clamp(sin(1.57079632679-atan(dy))*(1.0-uv.y-y)/w, 0.0, 1.0);\n}\n\nfloat draw_profile_curve(vec2 uv, float y, float dy, float w) {\n\treturn 1.0-clamp(sin(1.57079632679-atan(dy))*abs(1.0-uv.y-y)/w, 0.0, 1.0);\n}const float p_o249839_gradient_0_pos = 0.000000000;\nconst float p_o249839_gradient_0_r = 0.000000000;\nconst float p_o249839_gradient_0_g = 0.000000000;\nconst float p_o249839_gradient_0_b = 0.000000000;\nconst float p_o249839_gradient_0_a = 1.000000000;\nconst float p_o249839_gradient_1_pos = 0.890909091;\nconst float p_o249839_gradient_1_r = 0.433593750;\nconst float p_o249839_gradient_1_g = 0.787597656;\nconst float p_o249839_gradient_1_b = 1.000000000;\nconst float p_o249839_gradient_1_a = 1.000000000;\nconst float p_o249839_gradient_2_pos = 1.000000000;\nconst float p_o249839_gradient_2_r = 1.000000000;\nconst float p_o249839_gradient_2_g = 1.000000000;\nconst float p_o249839_gradient_2_b = 1.000000000;\nconst float p_o249839_gradient_2_a = 1.000000000;\nvec4 o249839_gradient_gradient_fct(float x) {\n  if (x < p_o249839_gradient_0_pos) {\n    return vec4(p_o249839_gradient_0_r,p_o249839_gradient_0_g,p_o249839_gradient_0_b,p_o249839_gradient_0_a);\n  } else if (x < p_o249839_gradient_1_pos) {\n    return mix(vec4(p_o249839_gradient_0_r,p_o249839_gradient_0_g,p_o249839_gradient_0_b,p_o249839_gradient_0_a), vec4(p_o249839_gradient_1_r,p_o249839_gradient_1_g,p_o249839_gradient_1_b,p_o249839_gradient_1_a), ((x-p_o249839_gradient_0_pos)/(p_o249839_gradient_1_pos-p_o249839_gradient_0_pos)));\n  } else if (x < p_o249839_gradient_2_pos) {\n    return mix(vec4(p_o249839_gradient_1_r,p_o249839_gradient_1_g,p_o249839_gradient_1_b,p_o249839_gradient_1_a), vec4(p_o249839_gradient_2_r,p_o249839_gradient_2_g,p_o249839_gradient_2_b,p_o249839_gradient_2_a), ((x-p_o249839_gradient_1_pos)/(p_o249839_gradient_2_pos-p_o249839_gradient_1_pos)));\n  }\n  return vec4(p_o249839_gradient_2_r,p_o249839_gradient_2_g,p_o249839_gradient_2_b,p_o249839_gradient_2_a);\n}\nconst float p_o232797_amount = 1.000000000;\nconst float p_o224452_amount = 1.000000000;\nconst float p_o19407_gradient_0_pos = 0.000000000;\nconst float p_o19407_gradient_0_r = 0.000000000;\nconst float p_o19407_gradient_0_g = 0.000000000;\nconst float p_o19407_gradient_0_b = 0.000000000;\nconst float p_o19407_gradient_0_a = 1.000000000;\nconst float p_o19407_gradient_1_pos = 0.504545000;\nconst float p_o19407_gradient_1_r = 0.550000012;\nconst float p_o19407_gradient_1_g = 0.550000012;\nconst float p_o19407_gradient_1_b = 0.550000012;\nconst float p_o19407_gradient_1_a = 1.000000000;\nconst float p_o19407_gradient_2_pos = 1.000000000;\nconst float p_o19407_gradient_2_r = 1.000000000;\nconst float p_o19407_gradient_2_g = 1.000000000;\nconst float p_o19407_gradient_2_b = 1.000000000;\nconst float p_o19407_gradient_2_a = 1.000000000;\nvec4 o19407_gradient_gradient_fct(float x) {\n  if (x < p_o19407_gradient_0_pos) {\n    return vec4(p_o19407_gradient_0_r,p_o19407_gradient_0_g,p_o19407_gradient_0_b,p_o19407_gradient_0_a);\n  } else if (x < p_o19407_gradient_1_pos) {\n    return mix(vec4(p_o19407_gradient_0_r,p_o19407_gradient_0_g,p_o19407_gradient_0_b,p_o19407_gradient_0_a), vec4(p_o19407_gradient_1_r,p_o19407_gradient_1_g,p_o19407_gradient_1_b,p_o19407_gradient_1_a), 0.5-0.5*cos(3.14159265359*(x-p_o19407_gradient_0_pos)/(p_o19407_gradient_1_pos-p_o19407_gradient_0_pos)));\n  } else if (x < p_o19407_gradient_2_pos) {\n    return mix(vec4(p_o19407_gradient_1_r,p_o19407_gradient_1_g,p_o19407_gradient_1_b,p_o19407_gradient_1_a), vec4(p_o19407_gradient_2_r,p_o19407_gradient_2_g,p_o19407_gradient_2_b,p_o19407_gradient_2_a), 0.5-0.5*cos(3.14159265359*(x-p_o19407_gradient_1_pos)/(p_o19407_gradient_2_pos-p_o19407_gradient_1_pos)));\n  }\n  return vec4(p_o19407_gradient_2_r,p_o19407_gradient_2_g,p_o19407_gradient_2_b,p_o19407_gradient_2_a);\n}\nconst float p_o19407_width = 0.020000000;\nconst float p_o126525_default_in1 = 0.000000000;\nconst float p_o126525_default_in2 = 0.500000000;\nconst float p_o58378_amount = 1.000000000;\nconst float p_o107398_default_in1 = 0.000000000;\nconst float p_o107398_default_in2 = -0.290000000;\nconst float p_o47177_repeat = 1.000000000;\nconst float p_o47177_rotate = 0.000000000;\nconst float p_o47177_gradient_0_pos = 0.000000000;\nconst float p_o47177_gradient_0_r = 0.000000000;\nconst float p_o47177_gradient_0_g = 0.000000000;\nconst float p_o47177_gradient_0_b = 0.000000000;\nconst float p_o47177_gradient_0_a = 1.000000000;\nconst float p_o47177_gradient_1_pos = 0.481818182;\nconst float p_o47177_gradient_1_r = 1.000000000;\nconst float p_o47177_gradient_1_g = 1.000000000;\nconst float p_o47177_gradient_1_b = 1.000000000;\nconst float p_o47177_gradient_1_a = 1.000000000;\nconst float p_o47177_gradient_2_pos = 1.000000000;\nconst float p_o47177_gradient_2_r = 0.000000000;\nconst float p_o47177_gradient_2_g = 0.000000000;\nconst float p_o47177_gradient_2_b = 0.000000000;\nconst float p_o47177_gradient_2_a = 1.000000000;\nvec4 o47177_gradient_gradient_fct(float x) {\n  if (x < p_o47177_gradient_0_pos) {\n    return vec4(p_o47177_gradient_0_r,p_o47177_gradient_0_g,p_o47177_gradient_0_b,p_o47177_gradient_0_a);\n  } else if (x < p_o47177_gradient_1_pos) {\n    return mix(vec4(p_o47177_gradient_0_r,p_o47177_gradient_0_g,p_o47177_gradient_0_b,p_o47177_gradient_0_a), vec4(p_o47177_gradient_1_r,p_o47177_gradient_1_g,p_o47177_gradient_1_b,p_o47177_gradient_1_a), 0.5-0.5*cos(3.14159265359*(x-p_o47177_gradient_0_pos)/(p_o47177_gradient_1_pos-p_o47177_gradient_0_pos)));\n  } else if (x < p_o47177_gradient_2_pos) {\n    return mix(vec4(p_o47177_gradient_1_r,p_o47177_gradient_1_g,p_o47177_gradient_1_b,p_o47177_gradient_1_a), vec4(p_o47177_gradient_2_r,p_o47177_gradient_2_g,p_o47177_gradient_2_b,p_o47177_gradient_2_a), 0.5-0.5*cos(3.14159265359*(x-p_o47177_gradient_1_pos)/(p_o47177_gradient_2_pos-p_o47177_gradient_1_pos)));\n  }\n  return vec4(p_o47177_gradient_2_r,p_o47177_gradient_2_g,p_o47177_gradient_2_b,p_o47177_gradient_2_a);\n}\nconst float p_o32998_translate_x = 0.000000000;\nconst float p_o32998_rotate = 0.000000000;\nconst float p_o32998_scale_x = 1.000000000;\nconst float p_o32998_scale_y = 43.780000000;\nconst int seed_o7904 = 42043;\nconst float p_o7904_scale_x = 2.000000000;\nconst float p_o7904_scale_y = 2.000000000;\nconst float p_o7904_folds = 0.000000000;\nconst float p_o7904_iterations = 4.000000000;\nconst float p_o7904_persistence = 0.740000000;\nfloat o7904_fbm(vec2 coord, vec2 size, int folds, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tfloat noise = fbm_cellular(coord*size, size, seed);\n\t\tfor (int f = 0; f < folds; ++f) {\n\t\t\tnoise = abs(2.0*noise-1.0);\n\t\t}\n\t\tvalue += noise * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\nconst float p_o220060_gradient_0_pos = 0.000000000;\nconst float p_o220060_gradient_0_r = 0.000000000;\nconst float p_o220060_gradient_0_g = 0.000000000;\nconst float p_o220060_gradient_0_b = 0.000000000;\nconst float p_o220060_gradient_0_a = 1.000000000;\nconst float p_o220060_gradient_1_pos = 0.504545000;\nconst float p_o220060_gradient_1_r = 0.550000012;\nconst float p_o220060_gradient_1_g = 0.550000012;\nconst float p_o220060_gradient_1_b = 0.550000012;\nconst float p_o220060_gradient_1_a = 1.000000000;\nconst float p_o220060_gradient_2_pos = 1.000000000;\nconst float p_o220060_gradient_2_r = 1.000000000;\nconst float p_o220060_gradient_2_g = 1.000000000;\nconst float p_o220060_gradient_2_b = 1.000000000;\nconst float p_o220060_gradient_2_a = 1.000000000;\nvec4 o220060_gradient_gradient_fct(float x) {\n  if (x < p_o220060_gradient_0_pos) {\n    return vec4(p_o220060_gradient_0_r,p_o220060_gradient_0_g,p_o220060_gradient_0_b,p_o220060_gradient_0_a);\n  } else if (x < p_o220060_gradient_1_pos) {\n    return mix(vec4(p_o220060_gradient_0_r,p_o220060_gradient_0_g,p_o220060_gradient_0_b,p_o220060_gradient_0_a), vec4(p_o220060_gradient_1_r,p_o220060_gradient_1_g,p_o220060_gradient_1_b,p_o220060_gradient_1_a), 0.5-0.5*cos(3.14159265359*(x-p_o220060_gradient_0_pos)/(p_o220060_gradient_1_pos-p_o220060_gradient_0_pos)));\n  } else if (x < p_o220060_gradient_2_pos) {\n    return mix(vec4(p_o220060_gradient_1_r,p_o220060_gradient_1_g,p_o220060_gradient_1_b,p_o220060_gradient_1_a), vec4(p_o220060_gradient_2_r,p_o220060_gradient_2_g,p_o220060_gradient_2_b,p_o220060_gradient_2_a), 0.5-0.5*cos(3.14159265359*(x-p_o220060_gradient_1_pos)/(p_o220060_gradient_2_pos-p_o220060_gradient_1_pos)));\n  }\n  return vec4(p_o220060_gradient_2_r,p_o220060_gradient_2_g,p_o220060_gradient_2_b,p_o220060_gradient_2_a);\n}\nconst float p_o220060_width = 0.020000000;\nconst float p_o220043_default_in1 = 0.000000000;\nconst float p_o220043_default_in2 = 0.500000000;\nconst float p_o220044_amount = 1.000000000;\nconst float p_o220045_default_in1 = 0.000000000;\nconst float p_o220045_default_in2 = 0.090000000;\nconst float p_o220046_repeat = 1.000000000;\nconst float p_o220046_rotate = 0.000000000;\nconst float p_o220046_gradient_0_pos = 0.000000000;\nconst float p_o220046_gradient_0_r = 0.000000000;\nconst float p_o220046_gradient_0_g = 0.000000000;\nconst float p_o220046_gradient_0_b = 0.000000000;\nconst float p_o220046_gradient_0_a = 1.000000000;\nconst float p_o220046_gradient_1_pos = 0.481818182;\nconst float p_o220046_gradient_1_r = 1.000000000;\nconst float p_o220046_gradient_1_g = 1.000000000;\nconst float p_o220046_gradient_1_b = 1.000000000;\nconst float p_o220046_gradient_1_a = 1.000000000;\nconst float p_o220046_gradient_2_pos = 1.000000000;\nconst float p_o220046_gradient_2_r = 0.000000000;\nconst float p_o220046_gradient_2_g = 0.000000000;\nconst float p_o220046_gradient_2_b = 0.000000000;\nconst float p_o220046_gradient_2_a = 1.000000000;\nvec4 o220046_gradient_gradient_fct(float x) {\n  if (x < p_o220046_gradient_0_pos) {\n    return vec4(p_o220046_gradient_0_r,p_o220046_gradient_0_g,p_o220046_gradient_0_b,p_o220046_gradient_0_a);\n  } else if (x < p_o220046_gradient_1_pos) {\n    return mix(vec4(p_o220046_gradient_0_r,p_o220046_gradient_0_g,p_o220046_gradient_0_b,p_o220046_gradient_0_a), vec4(p_o220046_gradient_1_r,p_o220046_gradient_1_g,p_o220046_gradient_1_b,p_o220046_gradient_1_a), 0.5-0.5*cos(3.14159265359*(x-p_o220046_gradient_0_pos)/(p_o220046_gradient_1_pos-p_o220046_gradient_0_pos)));\n  } else if (x < p_o220046_gradient_2_pos) {\n    return mix(vec4(p_o220046_gradient_1_r,p_o220046_gradient_1_g,p_o220046_gradient_1_b,p_o220046_gradient_1_a), vec4(p_o220046_gradient_2_r,p_o220046_gradient_2_g,p_o220046_gradient_2_b,p_o220046_gradient_2_a), 0.5-0.5*cos(3.14159265359*(x-p_o220046_gradient_1_pos)/(p_o220046_gradient_2_pos-p_o220046_gradient_1_pos)));\n  }\n  return vec4(p_o220046_gradient_2_r,p_o220046_gradient_2_g,p_o220046_gradient_2_b,p_o220046_gradient_2_a);\n}\nconst float p_o220042_translate_x = 0.000000000;\nconst float p_o220042_rotate = 0.000000000;\nconst float p_o220042_scale_x = 1.000000000;\nconst float p_o220042_scale_y = 43.780000000;\nconst int seed_o220041 = -7647;\nconst float p_o220041_scale_x = 2.000000000;\nconst float p_o220041_scale_y = 2.000000000;\nconst float p_o220041_folds = 0.000000000;\nconst float p_o220041_iterations = 4.000000000;\nconst float p_o220041_persistence = 0.740000000;\nfloat o220041_fbm(vec2 coord, vec2 size, int folds, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tfloat noise = fbm_cellular(coord*size, size, seed);\n\t\tfor (int f = 0; f < folds; ++f) {\n\t\t\tnoise = abs(2.0*noise-1.0);\n\t\t}\n\t\tvalue += noise * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\nconst float p_o221299_gradient_0_pos = 0.000000000;\nconst float p_o221299_gradient_0_r = 0.000000000;\nconst float p_o221299_gradient_0_g = 0.000000000;\nconst float p_o221299_gradient_0_b = 0.000000000;\nconst float p_o221299_gradient_0_a = 1.000000000;\nconst float p_o221299_gradient_1_pos = 0.504545000;\nconst float p_o221299_gradient_1_r = 0.550000012;\nconst float p_o221299_gradient_1_g = 0.550000012;\nconst float p_o221299_gradient_1_b = 0.550000012;\nconst float p_o221299_gradient_1_a = 1.000000000;\nconst float p_o221299_gradient_2_pos = 1.000000000;\nconst float p_o221299_gradient_2_r = 1.000000000;\nconst float p_o221299_gradient_2_g = 1.000000000;\nconst float p_o221299_gradient_2_b = 1.000000000;\nconst float p_o221299_gradient_2_a = 1.000000000;\nvec4 o221299_gradient_gradient_fct(float x) {\n  if (x < p_o221299_gradient_0_pos) {\n    return vec4(p_o221299_gradient_0_r,p_o221299_gradient_0_g,p_o221299_gradient_0_b,p_o221299_gradient_0_a);\n  } else if (x < p_o221299_gradient_1_pos) {\n    return mix(vec4(p_o221299_gradient_0_r,p_o221299_gradient_0_g,p_o221299_gradient_0_b,p_o221299_gradient_0_a), vec4(p_o221299_gradient_1_r,p_o221299_gradient_1_g,p_o221299_gradient_1_b,p_o221299_gradient_1_a), 0.5-0.5*cos(3.14159265359*(x-p_o221299_gradient_0_pos)/(p_o221299_gradient_1_pos-p_o221299_gradient_0_pos)));\n  } else if (x < p_o221299_gradient_2_pos) {\n    return mix(vec4(p_o221299_gradient_1_r,p_o221299_gradient_1_g,p_o221299_gradient_1_b,p_o221299_gradient_1_a), vec4(p_o221299_gradient_2_r,p_o221299_gradient_2_g,p_o221299_gradient_2_b,p_o221299_gradient_2_a), 0.5-0.5*cos(3.14159265359*(x-p_o221299_gradient_1_pos)/(p_o221299_gradient_2_pos-p_o221299_gradient_1_pos)));\n  }\n  return vec4(p_o221299_gradient_2_r,p_o221299_gradient_2_g,p_o221299_gradient_2_b,p_o221299_gradient_2_a);\n}\nconst float p_o221299_width = 0.020000000;\nconst float p_o221282_default_in1 = 0.000000000;\nconst float p_o221282_default_in2 = 0.500000000;\nconst float p_o221283_amount = 1.000000000;\nconst float p_o221284_default_in1 = 0.000000000;\nconst float p_o221284_default_in2 = 0.230000000;\nconst float p_o221285_repeat = 1.000000000;\nconst float p_o221285_rotate = 0.000000000;\nconst float p_o221285_gradient_0_pos = 0.000000000;\nconst float p_o221285_gradient_0_r = 0.000000000;\nconst float p_o221285_gradient_0_g = 0.000000000;\nconst float p_o221285_gradient_0_b = 0.000000000;\nconst float p_o221285_gradient_0_a = 1.000000000;\nconst float p_o221285_gradient_1_pos = 0.481818182;\nconst float p_o221285_gradient_1_r = 1.000000000;\nconst float p_o221285_gradient_1_g = 1.000000000;\nconst float p_o221285_gradient_1_b = 1.000000000;\nconst float p_o221285_gradient_1_a = 1.000000000;\nconst float p_o221285_gradient_2_pos = 1.000000000;\nconst float p_o221285_gradient_2_r = 0.000000000;\nconst float p_o221285_gradient_2_g = 0.000000000;\nconst float p_o221285_gradient_2_b = 0.000000000;\nconst float p_o221285_gradient_2_a = 1.000000000;\nvec4 o221285_gradient_gradient_fct(float x) {\n  if (x < p_o221285_gradient_0_pos) {\n    return vec4(p_o221285_gradient_0_r,p_o221285_gradient_0_g,p_o221285_gradient_0_b,p_o221285_gradient_0_a);\n  } else if (x < p_o221285_gradient_1_pos) {\n    return mix(vec4(p_o221285_gradient_0_r,p_o221285_gradient_0_g,p_o221285_gradient_0_b,p_o221285_gradient_0_a), vec4(p_o221285_gradient_1_r,p_o221285_gradient_1_g,p_o221285_gradient_1_b,p_o221285_gradient_1_a), 0.5-0.5*cos(3.14159265359*(x-p_o221285_gradient_0_pos)/(p_o221285_gradient_1_pos-p_o221285_gradient_0_pos)));\n  } else if (x < p_o221285_gradient_2_pos) {\n    return mix(vec4(p_o221285_gradient_1_r,p_o221285_gradient_1_g,p_o221285_gradient_1_b,p_o221285_gradient_1_a), vec4(p_o221285_gradient_2_r,p_o221285_gradient_2_g,p_o221285_gradient_2_b,p_o221285_gradient_2_a), 0.5-0.5*cos(3.14159265359*(x-p_o221285_gradient_1_pos)/(p_o221285_gradient_2_pos-p_o221285_gradient_1_pos)));\n  }\n  return vec4(p_o221285_gradient_2_r,p_o221285_gradient_2_g,p_o221285_gradient_2_b,p_o221285_gradient_2_a);\n}\nconst float p_o221281_translate_x = 0.000000000;\nconst float p_o221281_rotate = 0.000000000;\nconst float p_o221281_scale_x = 1.000000000;\nconst float p_o221281_scale_y = 43.780000000;\nconst int seed_o221280 = 16006;\nconst float p_o221280_scale_x = 2.000000000;\nconst float p_o221280_scale_y = 2.000000000;\nconst float p_o221280_folds = 0.000000000;\nconst float p_o221280_iterations = 4.000000000;\nconst float p_o221280_persistence = 0.740000000;\nfloat o221280_fbm(vec2 coord, vec2 size, int folds, int octaves, float persistence, float seed) {\n\tfloat normalize_factor = 0.0;\n\tfloat value = 0.0;\n\tfloat scale = 1.0;\n\tfor (int i = 0; i < octaves; i++) {\n\t\tfloat noise = fbm_cellular(coord*size, size, seed);\n\t\tfor (int f = 0; f < folds; ++f) {\n\t\t\tnoise = abs(2.0*noise-1.0);\n\t\t}\n\t\tvalue += noise * scale;\n\t\tnormalize_factor += scale;\n\t\tsize *= 2.0;\n\t\tscale *= persistence;\n\t}\n\treturn value / normalize_factor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\nvec2 UV = fragCoord/iResolution.xy;\nfloat o47177_0_r = 0.5+(cos(p_o47177_rotate*0.01745329251)*((UV).x-0.5)+sin(p_o47177_rotate*0.01745329251)*((UV).y-0.5))/(cos(abs(mod(p_o47177_rotate, 90.0)-45.0)*0.01745329251)*1.41421356237);vec4 o47177_0_1_rgba = o47177_gradient_gradient_fct(fract(o47177_0_r*p_o47177_repeat));\nfloat o107398_0_clamp_false = (dot((o47177_0_1_rgba).rgb, vec3(1.0))/3.0)*p_o107398_default_in2;\nfloat o107398_0_clamp_true = clamp(o107398_0_clamp_false, 0.0, 1.0);\nfloat o107398_0_2_f = o107398_0_clamp_false;\nfloat o7904_0_1_f = o7904_fbm((fract(transform2((UV), vec2(p_o32998_translate_x*(2.0*1.0-1.0), (50.0*iTime)*(2.0*1.0-1.0)), p_o32998_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o32998_scale_x*(2.0*1.0-1.0), p_o32998_scale_y*(2.0*1.0-1.0))))), vec2(p_o7904_scale_x, p_o7904_scale_y), int(p_o7904_folds), int(p_o7904_iterations), p_o7904_persistence, float(seed_o7904));\nvec4 o32998_0_1_rgba = vec4(vec3(o7904_0_1_f), 1.0);\nvec4 o58378_0_s1 = vec4(vec3(o107398_0_2_f), 1.0);\nvec4 o58378_0_s2 = o32998_0_1_rgba;\nfloat o58378_0_a = p_o58378_amount*1.0;\nvec4 o58378_0_2_rgba = vec4(blend_multiply((UV), o58378_0_s1.rgb, o58378_0_s2.rgb, o58378_0_a*o58378_0_s1.a), min(1.0, o58378_0_s2.a+o58378_0_a*o58378_0_s1.a));\nfloat o126525_0_clamp_false = (dot((o58378_0_2_rgba).rgb, vec3(1.0))/3.0)+p_o126525_default_in2;\nfloat o126525_0_clamp_true = clamp(o126525_0_clamp_false, 0.0, 1.0);\nfloat o126525_0_2_f = o126525_0_clamp_false;\nfloat o19407_0_1_f = draw_profile_curve((UV), o126525_0_2_f, (dot(o19407_gradient_gradient_fct((UV).x+0.001).xyz, vec3(1.0/3.0))-dot(o19407_gradient_gradient_fct((UV).x-0.001).xyz, vec3(1.0/3.0)))/0.002, max(0.0001, p_o19407_width));\nfloat o220046_0_r = 0.5+(cos(p_o220046_rotate*0.01745329251)*((UV).x-0.5)+sin(p_o220046_rotate*0.01745329251)*((UV).y-0.5))/(cos(abs(mod(p_o220046_rotate, 90.0)-45.0)*0.01745329251)*1.41421356237);vec4 o220046_0_1_rgba = o220046_gradient_gradient_fct(fract(o220046_0_r*p_o220046_repeat));\nfloat o220045_0_clamp_false = (dot((o220046_0_1_rgba).rgb, vec3(1.0))/3.0)*p_o220045_default_in2;\nfloat o220045_0_clamp_true = clamp(o220045_0_clamp_false, 0.0, 1.0);\nfloat o220045_0_2_f = o220045_0_clamp_false;\nfloat o220041_0_1_f = o220041_fbm((fract(transform2((UV), vec2(p_o220042_translate_x*(2.0*1.0-1.0), (50.0*iTime)*(2.0*1.0-1.0)), p_o220042_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o220042_scale_x*(2.0*1.0-1.0), p_o220042_scale_y*(2.0*1.0-1.0))))), vec2(p_o220041_scale_x, p_o220041_scale_y), int(p_o220041_folds), int(p_o220041_iterations), p_o220041_persistence, float(seed_o220041));\nvec4 o220042_0_1_rgba = vec4(vec3(o220041_0_1_f), 1.0);\nvec4 o220044_0_s1 = vec4(vec3(o220045_0_2_f), 1.0);\nvec4 o220044_0_s2 = o220042_0_1_rgba;\nfloat o220044_0_a = p_o220044_amount*1.0;\nvec4 o220044_0_2_rgba = vec4(blend_multiply((UV), o220044_0_s1.rgb, o220044_0_s2.rgb, o220044_0_a*o220044_0_s1.a), min(1.0, o220044_0_s2.a+o220044_0_a*o220044_0_s1.a));\nfloat o220043_0_clamp_false = (dot((o220044_0_2_rgba).rgb, vec3(1.0))/3.0)+p_o220043_default_in2;\nfloat o220043_0_clamp_true = clamp(o220043_0_clamp_false, 0.0, 1.0);\nfloat o220043_0_2_f = o220043_0_clamp_false;\nfloat o220060_0_1_f = draw_profile_curve((UV), o220043_0_2_f, (dot(o220060_gradient_gradient_fct((UV).x+0.001).xyz, vec3(1.0/3.0))-dot(o220060_gradient_gradient_fct((UV).x-0.001).xyz, vec3(1.0/3.0)))/0.002, max(0.0001, p_o220060_width));\nvec4 o224452_0_s1 = vec4(vec3(o19407_0_1_f), 1.0);\nvec4 o224452_0_s2 = vec4(vec3(o220060_0_1_f), 1.0);\nfloat o224452_0_a = p_o224452_amount*1.0;\nvec4 o224452_0_2_rgba = vec4(blend_lighten((UV), o224452_0_s1.rgb, o224452_0_s2.rgb, o224452_0_a*o224452_0_s1.a), min(1.0, o224452_0_s2.a+o224452_0_a*o224452_0_s1.a));\nfloat o221285_0_r = 0.5+(cos(p_o221285_rotate*0.01745329251)*((UV).x-0.5)+sin(p_o221285_rotate*0.01745329251)*((UV).y-0.5))/(cos(abs(mod(p_o221285_rotate, 90.0)-45.0)*0.01745329251)*1.41421356237);vec4 o221285_0_1_rgba = o221285_gradient_gradient_fct(fract(o221285_0_r*p_o221285_repeat));\nfloat o221284_0_clamp_false = (dot((o221285_0_1_rgba).rgb, vec3(1.0))/3.0)*p_o221284_default_in2;\nfloat o221284_0_clamp_true = clamp(o221284_0_clamp_false, 0.0, 1.0);\nfloat o221284_0_2_f = o221284_0_clamp_false;\nfloat o221280_0_1_f = o221280_fbm((fract(transform2((UV), vec2(p_o221281_translate_x*(2.0*1.0-1.0), (50.0*iTime)*(2.0*1.0-1.0)), p_o221281_rotate*0.01745329251*(2.0*1.0-1.0), vec2(p_o221281_scale_x*(2.0*1.0-1.0), p_o221281_scale_y*(2.0*1.0-1.0))))), vec2(p_o221280_scale_x, p_o221280_scale_y), int(p_o221280_folds), int(p_o221280_iterations), p_o221280_persistence, float(seed_o221280));\nvec4 o221281_0_1_rgba = vec4(vec3(o221280_0_1_f), 1.0);\nvec4 o221283_0_s1 = vec4(vec3(o221284_0_2_f), 1.0);\nvec4 o221283_0_s2 = o221281_0_1_rgba;\nfloat o221283_0_a = p_o221283_amount*1.0;\nvec4 o221283_0_2_rgba = vec4(blend_multiply((UV), o221283_0_s1.rgb, o221283_0_s2.rgb, o221283_0_a*o221283_0_s1.a), min(1.0, o221283_0_s2.a+o221283_0_a*o221283_0_s1.a));\nfloat o221282_0_clamp_false = (dot((o221283_0_2_rgba).rgb, vec3(1.0))/3.0)+p_o221282_default_in2;\nfloat o221282_0_clamp_true = clamp(o221282_0_clamp_false, 0.0, 1.0);\nfloat o221282_0_2_f = o221282_0_clamp_false;\nfloat o221299_0_1_f = draw_profile_curve((UV), o221282_0_2_f, (dot(o221299_gradient_gradient_fct((UV).x+0.001).xyz, vec3(1.0/3.0))-dot(o221299_gradient_gradient_fct((UV).x-0.001).xyz, vec3(1.0/3.0)))/0.002, max(0.0001, p_o221299_width));\nvec4 o232797_0_s1 = o224452_0_2_rgba;\nvec4 o232797_0_s2 = vec4(vec3(o221299_0_1_f), 1.0);\nfloat o232797_0_a = p_o232797_amount*1.0;\nvec4 o232797_0_2_rgba = vec4(blend_lighten((UV), o232797_0_s1.rgb, o232797_0_s2.rgb, o232797_0_a*o232797_0_s1.a), min(1.0, o232797_0_s2.a+o232797_0_a*o232797_0_s1.a));\nvec4 o249839_0_1_rgba = o249839_gradient_gradient_fct((dot((o232797_0_2_rgba).rgb, vec3(1.0))/3.0));\nfragColor = o249839_0_1_rgba;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKcRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 7, 27, 27, 95], [97, 97, 117, 117, 229], [231, 231, 251, 251, 436], [438, 438, 460, 460, 757], [759, 759, 781, 781, 941], [943, 943, 995, 995, 1368], [1370, 1370, 1423, 1423, 2173], [2175, 2175, 2231, 2231, 2285], [2287, 2287, 2342, 2342, 2742], [2744, 2744, 2800, 2800, 3338], [3340, 3340, 3396, 3396, 3774], [3776, 3776, 3832, 3832, 4348], [4350, 4350, 4406, 4406, 4784], [4786, 4786, 4842, 4842, 5358], [5359, 5359, 5391, 5391, 5434], [5436, 5436, 5504, 5504, 5689], [5689, 5689, 5750, 5750, 5791], [5793, 5793, 5856, 5856, 5924], [5926, 5926, 5989, 5989, 6033], [6035, 6035, 6096, 6096, 6158], [6160, 6160, 6203, 6203, 6269], [6271, 6271, 6333, 6333, 6463], [6465, 6465, 6530, 6530, 6611], [6613, 6613, 6659, 6659, 6754], [6756, 6756, 6821, 6821, 6960], [6962, 6962, 7002, 7002, 7055], [7057, 7057, 7116, 7116, 7237], [7239, 7239, 7280, 7280, 7325], [7327, 7327, 7387, 7387, 7511], [7513, 7513, 7575, 7575, 7625], [7627, 7627, 7688, 7688, 7738], [7740, 7740, 7805, 7805, 7878], [7879, 7879, 7941, 7941, 8016], [8018, 8018, 8081, 8081, 8159], [8915, 8915, 8960, 8960, 9908], [10738, 10738, 10782, 10782, 11747], [12857, 12857, 12901, 12901, 13866], [14297, 14297, 14392, 14392, 14758], [15515, 15515, 15560, 15560, 16558], [17686, 17686, 17731, 17731, 18729], [19176, 19176, 19273, 19273, 19639], [20396, 20396, 20441, 20441, 21439], [22567, 22567, 22612, 22612, 23610], [24057, 24057, 24154, 24154, 24520], [24522, 24522, 24577, 24577, 30397]]}
{"id": "WdKcWd", "name": "Truchet Passages", "author": "dr2", "description": "Starting from a hexagonal truchet tiling...", "tags": ["truchet", "architecture"], "likes": 15, "viewed": 274, "published": "Public API", "date": "1604051524", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Truchet Passages\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Minv3 (vec3 p);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nfloat Hashfv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir;\nvec2 gId, cMid;\nfloat tCur, dstFar, hgSize, cDir, trWidf;\nint idObj;\nconst int idPath = 1, idRail = 2, idBod = 3, idSup = 4, idBas = 5, idCone = 6,\n   idRfC = 7, idRfT = 8, idGrnd = 9;\nconst float pi = 3.1415927, sqrt3 = 1.7320508;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  vec2 qa, qb;\n  float dMin, d, wThk, r, s1, s2;\n  dMin = dstFar;\n  wThk = 0.005;\n  p.xz -= cMid;\n  p /= hgSize;\n  p.xz = Rot2D (p.xz, cDir * pi / 6.);\n  p.xz = Rot2D (p.xz, 2. * pi * floor (3. * atan (p.z, - p.x) / (2. * pi) + 0.5) / 3.);\n  q = p;\n  q.x += 1.;\n  r = length (q.xz);\n  d = max (abs (r - 0.5) - trWidf, abs (q.y - 0.1) - 0.02);\n  DMIN (idPath);\n  d = length (vec2 (abs (r - 0.5) - trWidf + 0.02, q.y - 0.27)) - 0.007;\n  DMIN (idRail);\n  q = p;\n  q.x += 1.;\n  q.xz = Rot2D (q.xz, 2. * pi * floor (12. * atan (q.z, - q.x) / (2. * pi) + 0.5) / 12.);\n  q.y -= 0.17;\n  q.x = abs (q.x + 0.5) - trWidf + 0.02;\n  d = PrCylDf (q.xzy, 0.007, 0.1);\n  DMIN (idRail);\n  q = p;\n  q.x += 0.46 * sqrt3 - 0.02;\n  q.y -= 0.51;\n  d = 0.9 * PrCylDf (q.xzy, 0.01 * (1. - 0.6 * q.y), 0.51);\n  DMIN (idSup);\n  q = p;\n  d = PrCylDf (q.xzy, 0.46 * sqrt3, 0.08);\n  DMIN (idBas);\n  q.y -= 0.2;\n  d = PrCylDf (q.xzy, 0.1 - 0.2 * q.y, 0.2);\n  DMIN (idCone);\n  q = p;\n  q.y -= 1.;\n  s1 = length (vec2 (abs (r - 0.5), abs (q.y))) - 0.8 * trWidf;\n  s2 = length (vec2 (abs (length (q.xz) - 0.46 * sqrt3 + trWidf), abs (q.y))) - 0.8 * trWidf;\n  d = SmoothMax (max (abs (s1), - s2) - wThk, - q.y, 0.02);\n  DMIN (idRfT);\n  d = SmoothMax (max (abs (s2), - s1) - wThk, - q.y, 0.02);\n  DMIN (idRfC);\n  q = p;\n  d = q.y;\n  DMIN (idGrnd);\n  q = p;\n  q.x += 1.;\n  q.xz = Rot2D (q.xz, mod (0.5 * cDir * tCur + pi / 3., 2. * pi / 3.) - pi / 3.);\n  qa = 0.5 * q.xz - vec2 (0.5, 0.);\n  qb = 0.5 * sqrt3 * q.zx * vec2 (1., -1.);\n  r = sqrt (dot (qa, qa) + dot (qb, qb) - 2. * abs (dot (qa, qb)));\n  d = min (max (r, abs (q.y - 0.21) - 0.09), length (vec2 (r, q.y - 0.34))) - 0.025;\n  DMIN (idBod);\n  return dMin;\n}\n\nvoid SetTrConf ()\n{\n  cMid = HexToPix (gId * hgSize);\n  cDir = 2. * step (Hashfv2 (gId), 0.5) - 1.;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]),\n     dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 240; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) {\n      dHit += d;\n    } else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  gIdP = vec2 (-99.);\n  for (int j = VAR_ZERO; j < 50; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetTrConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += clamp (h, 0.02, 0.5);\n    if (sh < 0.05 ) break;\n  }\n  return 0.4 + 0.6 * sh;\n}\n\nvec4 PathCol (vec2 p)\n{\n  vec4 col4;\n  vec2 q;\n  float a, d, f;\n  p = Rot2D (p, cDir * pi / 6.);\n  p = Rot2D (p, 2. * pi * floor (3. * atan (p.y, - p.x) / (2. * pi) + 0.5) / 3.);\n  p.x += 1.;\n  col4 = vec4 (0.9, 0.9, 0.95, 0.1);\n  col4 *= 0.3 + 0.7 * smoothstep (0.05, 0.1, abs (mod (72. * atan (p.y, - p.x) / (2. * pi) + 0.5, 1.) - 0.5));\n  f = abs (length (p) - 0.5);\n  if (f < trWidf - 0.04) {\n    q = Rot2D (p, mod (0.5 * cDir * tCur + pi / 3., 2. * pi / 3.) - pi / 3.);\n    a = mod (15. * atan (cDir * q.y, - q.x) / (2. * pi), 1.) - 0.5;\n    for (float s = 1.; s >= 0.; s -= 1.) {\n      d = 1.;\n      if (abs (a - 0.2) - 0.2 < 0.006 * s) d = min (d, smoothstep (0., 0.002,\n         f - 0.015 * (1. - a / 0.2) - 0.002 * s));\n      else if (abs (a + 0.2) - 0.2 < 0.006 * s) d = min (d, smoothstep (0., 0.002, f - 0.005 - 0.003 * s));\n      if (abs (mod (4. * a + 0.5, 1.) - 0.5) - 0.3 < 0.03 * s)\n         d = min (d, smoothstep (0., 0.002, abs (f - 0.05) - 0.004 - 0.003 * s));\n      col4 = mix (vec4 (1. - 0.9 * s, 0., 0., -1.), col4, d);\n    }\n  }\n  return col4;\n}\n\nvec3 SkyHrzCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol;\n  vec2 q;\n  float f, fd, ff;\n  if (rd.y > -0.05 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = mix (vec3 (0.1, 0.35, 0.1), vec3 (0.3, 0.35, 0.35),\n       smoothstep (-0.05, 0.01, rd.y));\n  } else if (rd.y > 0.) {\n    q = 0.005 * (ro.xz + tCur * vec2 (0.5, 2.) + ((200. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.1, 0.8, ff);\n    fd = smoothstep (0.1, 0.8, Fbm2 (q + 0.01 * sunDir.xz)) - f;\n    clCol = (0.8 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    fd = smoothstep (0.01, 0.1, rd.y);\n    col = mix (mix (vec3 (0.8, 0.8, 0.75), vec3 (0.4, 0.5, 0.8), 0.3 + 0.7 * fd), clCol,\n       0.1 + 0.9 * f * fd);\n  }\n  return 0.5 * col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 q, vf;\n  float dstObj, sh, nDotL, s;\n  dstObj = ObjRay (ro, rd);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    vf = vec2 (0.);\n    q = (ro.xz - cMid) / hgSize;\n    if (idObj == idPath) {\n     col4 = PathCol (q);\n    } else if (idObj == idRail) {\n      col4 = vec4 (0.8, 0.7, 0.2, 0.2);\n    } else if (idObj == idBod) {\n      col4 = mix (vec4 (0.2, 0.7, 0.2, 0.2), vec4 (0.2, 1., 0.2, -1.), step (0.66, ro.y));\n    } else if (idObj == idSup) {\n      col4 = vec4 (0.8, 0.8, 0.85, 0.1);\n    } else if (idObj == idBas) {\n      s = length (q);\n      col4 = vec4 (0.55, 0.5, 0.5, 0.1) * (0.8 + 0.2 * smoothstep (0.12, 0.15, s));\n      col4 = mix (vec4 (0., 0., 1., 0.1), col4, 0.5 + 0.5 * smoothstep (0.12, 0.18, s));\n      vf = vec2 (64., 0.2);\n    } else if (idObj == idCone) {\n      col4 = vec4 (0.1, 0.1, 0.6, -1.);\n    } else if (idObj == idRfT) {\n      if (vn.y < 0.) {\n        s = abs (length (q) - 0.46 * sqrt3 + trWidf);\n        q = Rot2D (q, cDir * pi / 6.);\n        q = Rot2D (q, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n        q.x += 1.;\n        s = min (s, abs (abs (length (q) - 0.5)));\n      }\n    } else  if (idObj == idRfC) {\n      if (vn.y < 0.) s = abs (length (q) - 0.46 * sqrt3 + trWidf);\n    } else  if (idObj == idGrnd) {\n      col4 = vec4 (0.3, 0.4, 0.3, 0.);\n      vf = vec2 (32., 1.);\n    }\n    if (idObj == idRfT || idObj == idRfC) {\n      col4 = vec4 (0.5, 0.5, 0.55, 0.1);\n      if (vn.y < 0.) col4 = mix (vec4 (1., 1., 0.9, -1.), col4, smoothstep (0.004, 0.008, s));\n      if (vn.y > 0. || s > 0.008) vf = vec2 (64., 0.5);\n    } else if (idObj == idGrnd || idObj == idBas && abs (vn.y) < 0.1) {\n      q = Rot2D (q, cDir * pi / 6.);\n      q = Rot2D (q, 2. * pi * floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) / 3.);\n      q.x += 1.;\n      col4 = mix (vec4 (0., 1., 0., 0.1), col4, smoothstep (0.02, 0.12, abs (abs (length (q) - 0.5))));\n    }\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    nDotL = max (dot (vn, sunDir), 0.);\n    if (idObj == idRail || idObj == idSup) nDotL *= nDotL;\n    sh = ObjSShadow (ro, sunDir);\n    if (col4.a >= 0.) col = col4.rgb * (0.2 + 0.8 * sh * nDotL) +\n       col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    else col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n    col = mix (col, vec3 (0.1, 0.2, 0.1), 1. - max (0., 1. - 2. * smoothstep (0., 1.,\n       dstObj / (2. * dstFar))));\n  } else col = SkyHrzCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec2 TrkPath (float t)\n{\n  vec2 r;\n  float tt;\n  tt = mod (t, 4.);\n  if (tt < 1.) r = mix (vec2 (sqrt3/2., -0.5), vec2 (sqrt3/2., 0.5), tt);\n  else if (tt < 2.) r = mix (vec2 (sqrt3/2., 0.5), vec2 (0., 1.), tt - 1.);\n  else if (tt < 3.) r = mix (vec2 (0., 1.), vec2 (0., 2.), tt - 2.);\n  else r = mix (vec2 (0., 2.), vec2 (sqrt3/2., 2.5), tt - 3.);\n  r += vec2 (0.001, 3. * floor (t / 4.));\n  return r * hgSize;\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv, uvv, p1, p2, vd;\n  float el, az, zmFac, asp, sr, vel, tCyc, s;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  asp = canvas.x / canvas.y;\n  hgSize = 2.;\n  trWidf = 0.1;\n  vel = 0.2;\n  tCyc = 4. / vel;\n  p1 = 0.5 * (TrkPath (vel * tCur + 0.05) + TrkPath (vel * tCur + 0.15));\n  p2 = 0.5 * (TrkPath (vel * tCur - 0.05) + TrkPath (vel * tCur - 0.15));\n  s = SmoothBump (0.25, 0.75, 0.05, mod (tCur / (1. * tCyc), 1.));\n  ro.xz = 0.5 * (p1 + p2);\n  ro.x += 0.2 * (2. * SmoothBump (0.25, 0.75, 0.15, mod (0.07 * vel * tCur, 1.)) - 1.);\n  ro.y = 1.2 + 1.8 * s;\n  vd = p1 - p2;\n  az = atan (vd.x, vd.y);\n  el = -0.2 * pi * (s + 0.3);\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  vuMat = StdVuMat (el, az);\n  zmFac = 2.5;\n  dstFar = 60.;\n  sunDir = normalize (vec3 (1., 1.5, -1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    uvv = (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.), sr * (0.667 * a + 0.5) * pi)) / zmFac;\n    rd = vuMat * normalize (vec3 ((2. * tan (0.5 * atan (uvv.x / asp))) * asp, uvv.y, 1.));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKcWd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 925, 947, 947, 2640], [2642, 2642, 2661, 2661, 2743], [2745, 2745, 2778, 2778, 4020], [4022, 4022, 4043, 4043, 4298], [4300, 4300, 4337, 4337, 4745], [4747, 4747, 4770, 4770, 5817], [5819, 5819, 5854, 5854, 6612], [6614, 6614, 6649, 6649, 9191], [9193, 9193, 9217, 9217, 9606], [9608, 9608, 9664, 9664, 11168], [11170, 11170, 11203, 11203, 11230], [11232, 11232, 11274, 11274, 11325], [11327, 11327, 11351, 11351, 11581], [11583, 11583, 11607, 11607, 11667], [11669, 11669, 11691, 11691, 11729], [11731, 11731, 11776, 11776, 11879], [11881, 11881, 11926, 11926, 11964], [11966, 11966, 12023, 12023, 12106], [12108, 12108, 12144, 12144, 12350], [12352, 12352, 12382, 12382, 12495], [12529, 12529, 12553, 12553, 12613], [12615, 12615, 12639, 12639, 12692], [12694, 12694, 12718, 12718, 12830], [12832, 12832, 12857, 12857, 13003], [13005, 13005, 13030, 13030, 13216], [13218, 13218, 13240, 13240, 13394], [13396, 13396, 13417, 13417, 13572], [13574, 13574, 13603, 13603, 13815], [13817, 13817, 13856, 13856, 14036]]}
{"id": "wdKcWV", "name": "Sunset City", "author": "Dragonpeak", "description": "2D sunset City", "tags": ["2d", "sunset", "city"], "likes": 9, "viewed": 224, "published": "Public API", "date": "1603827030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define time iTime*0.1\nconst int COUNT = 10;\nconst float SCALE = 32.;\n\nfloat rand(float x)\n{\n\treturn fract(sin(x)*1276818.27865);\n}\n\nfloat rand2(vec2 x)\n{\n\treturn fract(sin(dot(x ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = fragCoord/iResolution.x;\n\n    \n    vec3 col = vec3(0.2);\n    int l = 0;\n    float r = 0.;\n    for(int i = 0; i < COUNT; i++)\n    {\n        vec2 coord = uv*SCALE/float(i);\n        coord.x += time*float(i);\n\t\tint l2 = max(l, int(step(rand(floor(coord.x))*uv.y*2.*float(i), 0.1))*i);\n        if(l2 != l)\n        {\n\t\t\tr = clamp(rand2(floor(coord*vec2(8, 32)))-0.8, 0., 1.)*4.;\n        }\n        \n        \n        l = l2;\n        \n\n    }\n    col = vec3(l)/float(COUNT);\n    \n    float sun = clamp(length((uv-vec2(0.5, 0.1))*vec2(0.5, 1.))*1.3, 0., 1.);\n    vec3 sky = mix(vec3(.6, 0.3, 0.4)*3., vec3(0.1, 0.1, 0.4), sun)*0.7;\n    col = vec3(sky);\n    \n    if(l > 0)\n    {\n\t\tcol = vec3(0.3);\n        col = mix(col, vec3(0.8, 0.8, 0.2)*2., r);\n        col = mix(sky, col, float(l)/float(COUNT)*0.5);\n    }\n    \n   \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKcWV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[72, 72, 93, 93, 132], [134, 134, 155, 155, 220], [224, 224, 281, 281, 1162]]}
{"id": "WdKcWw", "name": "Algae Pond", "author": "jarble", "description": "It's a mix of green and brown algae floating on a pond. This is based on my \"Acid Wave\" fractal.", "tags": ["fractal", "algae"], "likes": 1, "viewed": 164, "published": "Public API", "date": "1602999773", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t = iTime*.5;\n    vec2 uv = (.1)*(fragCoord*10.0-iResolution.xy)/iResolution.y;\n        int c = 0;\n        for(int i=0;i<27;i++)\n        {\n            c = i % 5;\n            float factor = 1.2;\n            vec2 uv1 = uv;\n            uv /= factor;\n            uv += uv1;\n            //uv += sin(col.yx);\n        \tuv += float(i) + (sin(uv.x+uv.y)+cos(uv.y+t)+sin(t-uv.x));\n            uv *= factor;\n            col[c] = (col[c] + sin(uv.x+uv.y))/2.0;\n        }\n    col*=2.0;\n    fragColor = vec4(col,1.0);\n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKcWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 594]]}
{"id": "WdKcz1", "name": "Gliders Over Voropolis", "author": "dr2", "description": "Paper plane flyover (based on \"Voronoi Towers\"); mouseable", "tags": ["voronoi", "plane", "city", "flight"], "likes": 11, "viewed": 269, "published": "Public API", "date": "1602239652", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Gliders Over Voropolis\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // (=0/1) optional antialiasing (recommended if not fullscreen)\n\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nvoid HexVorInit ();\nvec4 HexVor (vec2 p);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec3 HsvToRgb (vec3 c);\nfloat Hashfv2 (vec2 p);\nvec2 Hashv2v2 (vec2 p);\nfloat Fbm2 (vec2 p);\n\nmat3 flyerMat[3], flMat;\nvec3 flyerPos[3], flPos, trkF, trkA, sunDir, qHit;\nfloat tCur, dstFar, dstBld, hBase, vorScl;\nint idObj;\nconst float pi = 3.1415927, sqrt3 = 1.732051;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat FlyerDf (vec3 p)\n{\n  vec3 q, qq;\n  float dMin, d, a;\n  dMin = dstFar;\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    q = flyerMat[k] * (p - flyerPos[k]);\n    q.x = abs (q.x);\n    a = 0.22 * pi;\n    q.z += 0.25;\n    qq = q;\n    qq.xy = Rot2D (vec2 (abs (qq.x), qq.y), - a);\n    qq.xz = Rot2D (vec2 (qq.x, qq.z - 1.1), -0.012 * pi);\n    qq.xy = Rot2D (vec2 (abs (qq.x), qq.y), a);\n    d = abs (max (max (abs (qq.y) - 0.002, 0.), max (dot (q.xz, sin (0.15 * pi +\n       vec2 (0.5 * pi, 0.))) - 0.5, - q.z - 0.5))) - 0.002;\n    DMINQ (1 + k);\n  }\n  return dMin;\n}\n\nfloat FlyerRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = FlyerDf (ro + dHit * rd);\n    dHit += d;\n    if (d < 0.0005 || dHit > dstFar) break;\n  }\n  return dHit;\n}\n\nvec3 FlyerNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.0002, -0.0002);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = FlyerDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat BldDf (vec3 p)\n{\n  vec4 vc;\n  float h;\n  vc = HexVor (vorScl * p.xz);\n  h = 0.5 * (floor (16. * vc.w) + 2.) + 0.04 * dstBld *\n     smoothstep (0.8, 1., dstBld / dstFar);\n  return min (0.2 * SmoothMax (0.75 - vc.x, p.y - h, 0.03), p.y + hBase);\n}\n\nfloat BldRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  if (rd.y < 0.) {\n    dHit = - (ro.y - 9.) / rd.y;\n    for (int j = VAR_ZERO; j < 320; j ++) {\n      dstBld = dHit;\n      d = BldDf (ro + dHit * rd);\n      dHit += d;\n      if (d < 0.001 || dHit > dstFar) break;\n    }\n  } else dHit = dstFar;\n  return dHit;\n}\n\nvec3 BldNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = BldDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  vec3 col;\n  float sd, f;\n  rd.y = abs (rd.y);\n  sd = max (dot (rd, sunDir), 0.);\n  ro.x += 0.5 * tCur;\n  f = Fbm2 (0.05 * (rd.xz * (50. - ro.y) / (rd.y + 0.0001) + ro.xz));\n  col = vec3 (0.1, 0.3, 0.5) + 0.3 * pow (1. - max (rd.y, 0.), 4.);\n  col += vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.));\n  return mix (col, vec3 (0.9), clamp ((f - 0.2) * rd.y + 0.3, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 vc;\n  vec3 col, vn;\n  float dstBld, dstFlyer, c, hw;\n  HexVorInit ();\n  vorScl = 0.3;\n  hBase = 5.;\n  dstBld = BldRay (ro, rd);\n  dstFlyer = FlyerRay (ro, rd);\n  if (min (dstFlyer, dstBld) < dstFar) {\n    if (dstFlyer < dstBld) {\n      ro += dstFlyer * rd;\n      col = (idObj == 1) ? vec3 (1., 0., 0.) : ((idObj == 2) ? vec3 (0., 1., 0.) :\n         vec3 (0., 0., 1.));\n      col = mix (col, vec3 (1., 1., 0.), smoothstep (0.02, 0.03,\n         abs (abs (qHit.x - 0.3) - 0.05)) * (1. - smoothstep (0.95, 0.97, qHit.z)));\n      vn = FlyerNf (ro);\n      col = col * (0.3 + 0.1 * max (- dot (vn, sunDir), 0.) +\n         0.7 * max (dot (vn, sunDir), 0.)) +\n         0.2 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else {\n      ro += dstBld * rd;\n      vc = HexVor (vorScl * ro.xz);\n      vn = BldNf (ro);\n      hw = mod (ro.y + 0.5, 1.) - 0.5;\n      if (abs (hw) < 0.18 && vn.y < 0.01) col = 0.7 * SkyCol (ro, reflect (rd, vn));\n      else {\n        c = 0.1 * floor (73. * mod (vc.w, 1.) + 0.5);\n        col = HsvToRgb (vec3 (0.1 + 0.8 * c, 0.3 + 0.5 * mod (25. * c, 1.), 1.));\n        if (ro.y > 0.1 - hBase) col *= (0.5 + 0.3 * mod (37. * c, 1.)) *\n           ((vn.y > 0.99) ? 1.2 : (1. - 0.5 * step (abs (hw), 0.25) * sign (hw)));\n        else col = mix (col, vec3 (1.) * (0.1 +\n           0.9 * step (abs (vc.x - 0.04), 0.02)), step (vc.x, 0.4));\n        col = col * (0.2 + 0.8 * max (0., max (dot (vn, sunDir), 0.))) +\n           0.05 * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n      }\n      col *= 1. + 0.6 * min (ro.y / hBase, 0.);\n      col = mix (col, 0.8 * SkyCol (ro, rd), smoothstep (0.4, 0.95, dstBld / dstFar));\n    }\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nvec3 TrkPath (float t)\n{\n  return vec3 (dot (trkA, sin (trkF * t)), 12., t);\n}\n\nvec3 TrkVel (float t)\n{\n  return vec3 (dot (trkF * trkA, cos (trkF * t)), 0., 1.);\n}\n\nvec3 TrkAcc (float t)\n{\n  return vec3 (dot (trkF * trkF * trkA, - sin (trkF * t)), 0., 0.);\n}\n\nvec3 GlareCol (vec3 rd, vec3 sd, vec2 uv)\n{\n  vec3 col;\n  vec2 e;\n  e = vec2 (1., 0.);\n  if (sd.z > 0.) col = 0.05 * pow (abs (sd.z), 4.) *\n     (4. * e.xyy * max (dot (normalize (rd + vec3 (0., 0.3, 0.)), sunDir), 0.) +\n      e.xxy * SmoothBump (0.03, 0.05, 0.01, length (uv - 0.7 * sd.xy)) +\n      e.yxx * SmoothBump (0.2, 0.23, 0.02, length (uv - 0.5 * sd.xy)) +\n      e.xyx * SmoothBump (0.6, 0.65, 0.03, length (uv - 0.3 * sd.xy)));\n  else col = vec3 (0.);\n  return col;\n}\n\nvoid FlyerPM (float t, int isOb)\n{\n  vec3 vel, va, flVd;\n  vec2 cs;\n  float oRl;\n  flPos = TrkPath (t);\n  vel = TrkVel (t);\n  va = cross (TrkAcc (t), vel) / length (vel);\n  flVd = normalize (vel);\n  oRl = ((isOb > 0) ? 10. : 20.) * length (va) * sign (va.y);\n  cs = sin (oRl + vec2 (0.5 * pi, 0.));\n  flMat = mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.) *\n     mat3 (flVd.z, 0., flVd.x, 0., 1., 0., - flVd.x, 0., flVd.z);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, vd, col, gCol;\n  vec2 canvas, uv;\n  float az, el, zmFac, flyVel, vDir, sr, t;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = -0.17 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.45 * pi * mPtr.y;\n  }\n  tCur += 50.;\n  trkA = 0.2 * vec3 (1.9, 2.9, 4.3);\n  trkF = vec3 (0.23, 0.17, 0.13);\n  flyVel = 3.;\n  vDir = sign (0.5 * pi - abs (az));\n  for (int k = VAR_ZERO; k < 3; k ++) {\n    t = flyVel * tCur + vDir * (3. + 5. * float (k));\n    FlyerPM (t, 0);\n    flyerMat[k] = flMat;\n    flyerPos[k] = flPos;\n    flyerPos[k].y += 0.8 * (2. * SmoothBump (0.25, 0.75, 0.25, mod (0.05 * t, 1.)) - 1.) - 1.;\n  }\n  t = flyVel * tCur;\n  FlyerPM (t, 1);\n  ro = flPos;\n  vuMat = StdVuMat (el, az);\n  zmFac = 2.;\n  dstFar = 200.;\n  sunDir = normalize (vec3 (sin (0.02 * pi * tCur), 0.2, cos (0.02 * pi * tCur)));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    rd = vuMat * (rd * flMat);\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  col += GlareCol (rd, flMat * sunDir * vuMat, uv);\n  fragColor = vec4 (col, 1.);\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 gVec[7], hVec[7];\n\nvoid HexVorInit ()\n{\n  vec3 e = vec3 (1., 0., -1.);\n  gVec[0] = e.yy;\n  gVec[1] = e.xy;\n  gVec[2] = e.yx;\n  gVec[3] = e.xz;\n  gVec[4] = e.zy;\n  gVec[5] = e.yz;\n  gVec[6] = e.zx;\n  for (int k = 0; k < 7; k ++) hVec[k] = HexToPix (gVec[k]);\n}\n\nvec4 HexVor (vec2 p)\n{\n  vec4 sd, udm;\n  vec2 ip, fp, d, u;\n  float amp, a;\n  amp = 0.5;\n  ip = PixToHex (p);\n  fp = p - HexToPix (ip);\n  sd = vec4 (4.);\n  udm = vec4 (4.);\n  for (int k = 0; k < 7; k ++) {\n    u = Hashv2v2 (ip + gVec[k]);\n    a = 2. * pi * (u.y - 0.5);\n    d = hVec[k] + amp * (0.4 + 0.6 * u.x) * vec2 (cos (a), sin (a)) - fp;\n    sd.w = dot (d, d);\n    if (sd.w < sd.x) {\n      sd = sd.wxyw;\n      udm = vec4 (d, u);\n    } else sd = (sd.w < sd.y) ? sd.xwyw : ((sd.w < sd.z) ? sd.xyww : sd);\n  }\n  sd.xyz = sqrt (sd.xyz);\n  return vec4 (SmoothMin (sd.y, sd.z, 0.05) - sd.x, udm.xy, Hashfv2 (udm.zw));\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  return q * cos (a) + q.yx * sin (a) * vec2 (-1., 1.);\n}\n\nvec3 HsvToRgb (vec3 c)\n{\n  vec3 p;\n  p = abs (fract (c.xxx + vec3 (1., 2./3., 1./3.)) * 6. - 3.);\n  return c.z * mix (vec3 (1.), clamp (p - 1., 0., 1.), c.y);\n}\n\nconst float cHashM = 43758.54;\n\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (dot (p, cHashVA2) + vec2 (0., cHashVA2.x)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKcz1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 889, 913, 913, 1451], [1453, 1453, 1488, 1488, 1674], [1676, 1676, 1699, 1699, 1958], [1960, 1960, 1982, 1982, 2211], [2213, 2213, 2246, 2246, 2523], [2525, 2525, 2546, 2546, 2801], [2803, 2803, 2835, 2835, 3228], [3230, 3230, 3265, 3265, 4997], [4999, 4999, 5023, 5023, 5077], [5079, 5079, 5102, 5102, 5163], [5165, 5165, 5188, 5188, 5258], [5260, 5260, 5303, 5303, 5737], [5739, 5739, 5773, 5773, 6169], [6171, 6171, 6227, 6227, 7747], [7749, 7749, 7773, 7773, 8003], [8005, 8005, 8029, 8029, 8089], [8115, 8115, 8135, 8135, 8355], [8357, 8357, 8379, 8379, 8976], [8978, 8978, 9023, 9023, 9126], [9128, 9128, 9173, 9173, 9211], [9213, 9213, 9270, 9270, 9353], [9355, 9355, 9391, 9391, 9597], [9599, 9599, 9629, 9629, 9687], [9689, 9689, 9713, 9713, 9849], [9884, 9884, 9908, 9908, 9968], [9970, 9970, 9994, 9994, 10106], [10108, 10108, 10133, 10133, 10319], [10321, 10321, 10342, 10342, 10497]]}
{"id": "wdKyRt", "name": "high heel raytracer 2", "author": "iuryBorgesRodrigues", "description": "high heel raytracer ", "tags": ["raytracer", "sdf", "high", "heel"], "likes": 3, "viewed": 259, "published": "Public", "date": "1603578967", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n#define EPSILON 0.001\n#define MAX_STEPS 1000\n#define MAX_DISTANCE 80.0\n#define AA 1\n\nstruct Light {\n    vec3 position;\n    vec3 color;\n};\n\nstruct Material {\n    vec3 albedo;\n    float metallic;\n    float roughness;\n    vec3 reflection;\n    vec3 refraction;\n};\n    \nstruct Hit {\n    float dist;\n    int matIndex; //material info at the intersection point\n};\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p, n.xyz) + n.w;\n}\n\n\nHit unionSDF(Hit d1, Hit d2) \n{\n    if (d1.dist < d2.dist) {\n        return d1;\n    } else {\n        return d2;\n    }  \n}\n\nvec3 doTranslate(vec3 p, vec3 offset) \n{\n    return p - offset;\n}\n\nmat3 rotate_x(float a){float sa = sin(a); float ca = cos(a); return mat3(1.,.0,.0,    .0,ca,sa,   .0,-sa,ca);}\nmat3 rotate_y(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,.0,sa,    .0,1.,.0,   -sa,.0,ca);}\nmat3 rotate_z(float a){float sa = sin(a); float ca = cos(a); return mat3(ca,sa,.0,    -sa,ca,.0,  .0,.0,1.);}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat comp(float a,float b){\n    \n    return (a < b) ? a : b;\n}\n\nfloat sapatoAlto( in vec3 p )\n{\n   \n    vec3 pd1=p;\n   \n   \n    vec3 pd5=p;\n    vec3 pd6=p;\n    vec3 pd8=p;\n    vec3 pd9=p;\n    vec3 pd10=p;\n    \n    \n    \n    pd1.z*=exp2(-pd1.y);\n    pd1.x*=cos(pd1.y*2.7);\n    pd1.x/=1.5;\n    pd1*=rotate_z(0.8);\n\tpd1.x+=sin(pd1.y-0.8)*sin(-pd1.y*-0.5);\n   \n \tpd1.y/=2.;\n    \n   \n    \n    pd6*=rotate_z(1.2);\n    pd6.y-=0.5;\n    pd6.x-=0.055;\n    \n   \n   \n\n \n    \n   \n    \n    \n    pd5.x+=0.5;\n    pd5.y+=0.1;\n    pd5.y/=0.65;\n  \n    pd5.x/=0.3;\n    pd5.z/=0.3;\n    \n    \n    pd6.x-=0.01;\n    pd6.y+=0.03;\n    pd6.z*=exp2(-pd6.y*2.0);\n    pd6.z/=0.8;\n    \n    pd6*=rotate_z(0.12);\n    \n    \n    \n  \n    pd8.x-=0.4;\n    pd8.y+=0.35;\n    pd8.y/=1.2;\n    pd8.z/=0.55;\n    pd8*=rotate_z(1.2);\n    pd8*=rotate_y(-1.5);\n    pd8*=rotate_x(0.1);\n    \n    \n   \n    pd9.x/=1.1;\n    pd9.y+=0.0;\n    pd9.y/=1.5;\n    pd9.z/=0.71;\n    \n    pd9*=rotate_z(1.6);\n    pd9*=rotate_y(-1.5);\n    pd9*=rotate_x(0.5);\n    \n    pd10.x+=0.4;\n    pd10.y-=0.3;\n    \n   \tpd10.y/=2.0;\n    pd10.z/=0.9;\n    pd10*=rotate_z(1.2);\n    pd10*=rotate_y(-1.5);\n    pd10*=rotate_x(-1.1);\n   \n   \n    \n   \n    float d1 = sdBox(pd1,vec3(0.05,0.2,0.2))*0.2;\n    \n\n    float d5 = sdBox(pd5,vec3(0.02,0.45,0.02))*0.2;\n    \n    float d6 = sdBox(pd6,vec3(-0.01,0.15,0.15))*0.2;\n    \n    \n    \n    float d8= max(sdCappedCylinder(pd8,0.3,0.01),-sdCappedCylinder(pd8,0.3,0.02))*0.2;\n    d8=max(d8,-pd8.z);\n    \n    \n    float d9= max(sdCappedCylinder(pd9,0.3,0.01),-sdCappedCylinder(pd9,0.3,0.02))*0.2;\n    d9=max(d9,-pd9.z);\n    \n    float d10= max(sdCappedCylinder(pd10,0.3,0.01),-sdCappedCylinder(pd10,0.3,0.02))*0.2;\n    d10=max(d10,-pd10.z);\n           \n    \n   \n    d1=comp(d1,d5-0.01);\n    d1=comp(d1,d6-0.01);\n    d1=comp(d1,d8);\n    d1=comp(d1,d9);\n    d1=comp(d1,d10);\n    \n   \n    \n    return d1;\n    \n\t\n}\n\nfloat Sphere(vec3 p){\n    \n    \n    float sph[6];\n    \n    float d1;\n    \n    \n    d1= sdSphere(p+vec3(-0.01,0.01,-0.18),0.05);\n    sph[1]= sdSphere(p+vec3(-0.01,0.01,0.18),0.05);\n    \n    sph[2]= sdSphere(p+vec3(-0.4,0.38,-0.15),0.025);\n    sph[3]= sdSphere(p+vec3(-0.4,0.38,0.15),0.025);\n    sph[4]= sdSphere(p+vec3(0.4,-0.28,-0.25),0.04);\n    sph[5]= sdSphere(p+vec3(0.4,-0.28,0.25),0.04);\n    \n    \n    d1=comp(d1, sph[1]);\n    d1=comp(d1, sph[2]);\n    d1=comp(d1, sph[3]);\n    d1=comp(d1, sph[4]);\n    d1=comp(d1, sph[5]);\n    \n    \n    return d1;\n    \n}\n\nHit sceneSDF(vec3 p) {\n    Hit rst;\n    \n    \n   \n    \n   \n   \n    vec3 p1 = doTranslate(vec3(abs(p.x),p.yz), vec3(3.0, 1.5, -2.0));\n    p1/=vec3(3.0);\n    \n    \n    \n    p1.z-=0.8;\n    p1.x+=0.5;\n    p1*=rotate_y(-1.8);\n    \n    p1.y-=0.0;\n   \n  \n    Hit is1 = Hit(sapatoAlto(p1), 2);\n    Hit is2 = Hit(Sphere(p1), 1);\n    \n   \n    /*\n    Hit is2 = Hit(sdPlane(p, vec4(0.0, 1.0, 0.0, 0.0)), 3);\n    Hit is3 = Hit(sdPlane( p, vec4(0.0, 0.0, 1.0, 20.0)), 3);\n    Hit is4 = Hit(sdPlane( p, vec4(1.0, 0.0, 0.0, 20.0)), 3);\n    Hit is5 = Hit(sdPlane( p, vec4(-1.0, 0.0, 0.0, 20.0)), 3);\n    Hit is6 = Hit(sdPlane( p, vec4(0.0, 0.0, -1.0, 20.0)), 3);\n    Hit is7 = Hit(sdPlane( p, vec4(0.0, -1.0, 0.0, 30.0)), 3);\n    */\n    \n   Hit outerBox = Hit(sdBox(p-vec3(0.0,25.0,0.0), vec3(25.0,25.0,25.0)), 3); \n    outerBox.dist = -outerBox.dist-0.1;\n    \n    \n    \n   \n    rst = unionSDF( is1, outerBox);\n    rst = unionSDF( rst, is2);\n    \n    /*\n    rst = unionSDF(rst, is2);\n    rst = unionSDF(rst, is3);\n    rst = unionSDF(rst, is4);\n    rst = unionSDF(rst, is5);\n    rst = unionSDF(rst, is6);\n    rst = unionSDF(rst, is7);\n\t*/\n    return rst;\n}\n\nvec3 getNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)).dist - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)).dist - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)).dist,\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)).dist - sceneSDF(vec3(p.x, p.y, p.z - EPSILON)).dist\n    ));\n}\n\nHit marching(vec3 ro, vec3 rd) \n{\n    float tmax = MAX_DISTANCE;\n    float t = 0.001;\n    Hit result = Hit(-1.0, -1);\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        vec3 p = ro + rd * t;\n        Hit res = sceneSDF(p);\n        if (res.dist < EPSILON)\n        {\n            return result;\n        }\n        else if (t > tmax)\n        {\n            result.matIndex = -1;\n            result.dist = tmax;\n            break;\n        }\n        t += res.dist;\n        result.dist = t;\n        result.matIndex = res.matIndex;\n    }\n    \n    return result;\n}\n\nfloat calcShadow(in vec3 ro, in vec3 rd) {\n    float mint = 0.1;\n    float t = mint;\n    float res = 1.0;\n    float k = 4.0;\n    for (int i = 0; i < 40; i++)\n    {\n        float h = sceneSDF(ro + rd * t).dist;\n        \n\t\tres = min( res, k * h / t );\n        t += clamp( h, 0.02, 0.20 );\n     \n        if ( h < EPSILON ) \n        {\n            res = min(res, 0.0);\n            break;\n        } \n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    float h = 0.001;\n    for( float i = 0.0; i < 5.0; i++ )\n    {\n        float d = sceneSDF( pos + h * nor ).dist;\n        occ += ( h - d ) * sca;\n        sca *= 0.85;\n        h += 0.45 * i / 5.0;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n//Fresnel/reflectivity\nvec3 Fs(vec3 h, vec3 v, vec3 f0)\n{\n    float dothv = max(dot(h, v), 0.0);\n    return max(f0 + (1.0 - f0) * pow((1.0 - dothv), 5.0), 0.0);\n}\n\n//Distribution/concentration\nfloat D_GGX(float dotnh, float roughness) \n{\n    float a = roughness * roughness;\n    float a2 = a * a;\n    float dotnh2 = dotnh * dotnh;\n    float denom =  max(dotnh2 * (a2 - 1.0) + 1.0, EPSILON);\n    return a2 /(PI * denom * denom);\n}\n\nfloat G_SGGX(float dotnv, float roughness)\n{\n    float r = roughness + 1.0; \n    float k = (r * r) / 8.0;\n    return dotnv / (dotnv * (1.0 - k) + k);\n}\n\n//Geometry/shadowing masking\nfloat G_Smith(float dotnv, float dotnl, float roughness)\n{\n    \n    float ggx1 = G_SGGX(dotnv, roughness);\n    float ggx2 = G_SGGX(dotnl, roughness);\n    return ggx1 * ggx2;\n}\n\n//Fresnel/reflectivity\nvec3 Fs(float dothv, vec3 f0)\n{\n    vec3 F = f0 + (1.0 - f0) * pow((1.0 - dothv), 5.0);\n    return max(F, 0.0);\n}\n\nvec3 shading(vec3 ro, vec3 p, vec3 normal, Light lightInfo, inout Material mat) \n{\n    vec3 Lo = vec3(0.0);\n    \n    //material and light\n    vec3 albedo = mat.albedo; //vec3(0.2, 0.87, 0.6);\n    float roughness = mat.roughness;\n    float metallic = mat.metallic;\n    vec3 lightDir = lightInfo.position - p;\n    vec3 lightColor = lightInfo.color; \n    \n    //calculating vectors\n    vec3 viewDir = ro - p;\n    vec3 V = normalize(viewDir);\n    vec3 N = normal;\n    vec3 L = normalize(lightDir);\n    vec3 H = normalize(V + L);\n    \n    float dist = length(lightDir);\n\n    float sd = calcShadow(p, L);\n    float att = 1.0 / ( dist);\n    vec3 radiance = lightColor * att * sd;\n\n    float dothv = max(dot(H, V), 0.0);\n    float dotnh = max(dot(N, H), 0.0);\n    float dotnv = max(dot(N, V), 0.0);\n    float dotnl = max(dot(N, L), 0.0);\n      \n    //fresnel\n    vec3 f0 = vec3(0.04); \n    f0 = mix(f0, albedo, metallic);\n    vec3 F = Fs(dothv, f0);\n    \n    //cook-torrance specualr term\n    float D = D_GGX(dotnh, roughness);\n    float GS = G_Smith(dotnv, dotnl, roughness);\n    vec3 nom = D * GS * F;\n    float denom = 4.0 * dotnv * dotnl;\n    vec3 Fct = nom / max(denom, EPSILON); //avoid zero denom\n\n    vec3 Ks = F; //reflect\n    vec3 Kd = 1.0 - Ks; \n    Kd *= 1.0 - metallic; //diffuse\n    vec3 Fl = albedo/PI; //lambert\n    \n    mat.reflection = Ks;\n    \n    Lo += (Kd * Fl + Fct) * radiance * dotnl; \n    \n    float ao = calcAO(p, N);\n    vec3 ambient = vec3(0.01) * albedo * ao;\n    return ambient + Lo;\n}\n\nmat3 getCamera( in vec3 ro, in vec3 ta) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n//hacks for non-constant index expression\nMaterial getMaterial(int index) {\n    Material mat[4];\n    mat[0] = Material(vec3(1.0), 0.5, 0.1, vec3(0.0), vec3(0.0)); //white\n    mat[1] = Material(vec3(0.5, 0.8, 0.5), 0.9, 0.2, vec3(0.0), vec3(0.0)); //green\n    mat[2] = Material(vec3(1.0,1.0,0.0), 0.5, 0.2, vec3(0.0), vec3(0.0)); //yellow\n    mat[3] = Material(vec3(0.8, 0.5, 0.5), 0.5, 0.3, vec3(0.0), vec3(0.0)); //pink\n    if (index == 0) {\n        return mat[0];\n    } else if (index == 1) {\n        return mat[1];\n    } else if (index == 2) {\n        return mat[2];\n    } else if (index == 3) {\n        return mat[3];\n    }\n}\n   \n  \n\nvec3 render(in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5; \n    uv.x *= iResolution.x/iResolution.y; \n    \n    vec3 col = vec3(0.0);\n    vec2 mouse = vec2(0.01) + iMouse.xy  / iResolution.xy ;\n    mouse -= 0.5;\n    \n    vec3 ro = vec3(10.0 * cos(mouse.x * 2.0 * PI), 6.0 + 5.0 * mouse.y, 10.0 * sin(mouse.x * 2.0 * PI));\n    vec3 ta = vec3(0.0, 4.0, 0.0);\n    mat3 cam = getCamera(ro, ta);\n    vec3 rd = normalize(cam * vec3(uv, 1.0));\n     \n    Light lightInfo = Light(vec3(5.0 * sin(iTime), 10.0, 2.0), vec3(200.0));\n    \n    Hit icp;\n    vec3 nor = vec3(0.0);  \n    vec3 ori = ro;\n    vec3 dir = rd;\n    vec3 interP = vec3(0.0);\n    vec3 mask = vec3(1.0);\n    float travelDist = 0.0; //calculate how far a ray travels\n     \n    for (float i = 0.0; i < 3.0; i++) {\n        icp = marching(ori, dir);\n        interP = ori + (icp.dist) * dir; //interception point\n        travelDist += length(ori - interP);\n        nor = getNormal(interP);\n        if (icp.dist >= MAX_DISTANCE) {\n            col += vec3(0.0);\n        } else {\n            Material mat = getMaterial(icp.matIndex);\n            col += mask * shading(ori, interP, nor, lightInfo, mat);\n            \n            vec3 ref = reflect(dir, nor);\n            ori = interP + EPSILON*ref;\n           \n            dir = ref;\n            mask *= mat.reflection * 0.8;\n        }\n    }\n    \n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    \n    vec3 col = vec3(0.0);\n    vec2 offset = vec2(0.0);\n#if AA>1\n    for (int y = 0; y < AA; ++y)\n    {\n        for (int x = 0; x < AA; ++x)\n        {\n            offset = -0.5+vec2(float(x), float(y))/float(AA);\n\n        \tcol += render(fragCoord+offset);\n        }\n    }\n    col /= float(AA*AA);\n#else\n    col += render(fragCoord);\n#endif\n    \n    //col = col/(col + vec3(1.0)); //Reinhard tone mapping\n    col = vec3(1.0) - exp(-col * 0.5);//exposure\n\tcol = pow(col, vec3(1.0/2.2)); \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKyRt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[379, 379, 412, 438, 470], [473, 473, 504, 504, 594], [596, 596, 636, 636, 661], [663, 663, 686, 686, 773], [774, 774, 797, 797, 884], [885, 885, 908, 908, 994], [996, 996, 1031, 1031, 1057], [1059, 1059, 1090, 1090, 1177], [1179, 1179, 1231, 1231, 1338], [1340, 1340, 1368, 1368, 1403], [1405, 1405, 1436, 1436, 3208], [3210, 3210, 3231, 3231, 3769], [3771, 3771, 3793, 3793, 4909], [4911, 4911, 4935, 4935, 5275], [5277, 5277, 5310, 5310, 5837], [5839, 5839, 5881, 5881, 6275], [6278, 6278, 6320, 6320, 6610], [6612, 6635, 6669, 6669, 6774], [6776, 6805, 6849, 6849, 7041], [7043, 7043, 7087, 7087, 7194], [7196, 7225, 7283, 7283, 7400], [7402, 7425, 7456, 7456, 7538], [7540, 7540, 7622, 7622, 9047], [9049, 9049, 9090, 9090, 9260], [9262, 9304, 9337, 9337, 9891], [9900, 9900, 9932, 9932, 11294], [11296, 11296, 11353, 11353, 11876]]}
{"id": "WdKyWw", "name": "Moiré 2", "author": "Good", "description": "obtained by the superimposition of two similar patterns", "tags": ["moire", "pattern"], "likes": 7, "viewed": 115, "published": "Public", "date": "1602990026", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate(in float a){ float c = cos(a), s = sin(a); return mat2(c, -s, s, c); }\nfloat rasp(vec2 uv, float s, float a, float shift){\n  uv *= rotate(a);     \n  return  sin(uv.x*s)*9.+shift;\n}\nfloat trigrid(vec2 uv, float shift ){\n  float r1 = rasp(uv, 50.,0.,shift); \n  float r2 = rasp(uv, 50., 3.14/3.,shift);  \n  float r3 = rasp(uv, 50., 3.14/3.*2.,shift); \n  return r1+r2+r3;\n}\n \nconst vec3 c1 = vec3(.1,.05,.2);\nconst vec3 c2 = vec3(1,.5,.1);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n  vec2 uv = (fragCoord-iResolution.xy/2.0) / iResolution.yy *2. ;  \n    \n  vec2 uv1 = uv*rotate(-iTime/9.);  \n  float r1 = trigrid(uv1, 3.);\n  vec2 uv2 = (uv*1.18734+vec2(0,1.25))*rotate(iTime/95.);  \n  float r2 = trigrid(uv2, -6.);\n    \n  float w = clamp(r1+r2, .0, 1.);\n  vec3 col = mix(c1, c2, w);\n  col+= vec3(0,0,clamp(r2, 0.,.25));    \n  fragColor = vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKyWw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 82], [83, 83, 134, 134, 192], [193, 193, 230, 230, 381], [449, 449, 505, 505, 877]]}
{"id": "WdKyzV", "name": "crystal.ex", "author": "tijit", "description": "blue crystal texture", "tags": ["tijit"], "likes": 7, "viewed": 127, "published": "Public", "date": "1603263006", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n*/\n\nconst float GRID = 4.;\nconst float PI = 3.14159265;\n\nfloat random (in vec2 st) {\n    return fract(sin(dot(st.xy,\n                         vec2(12.9898,78.233)))\n                 * 43758.5453123);\n}\n\nfloat circle(in vec2 _st, in vec2 _circle, in float _radius) {\n    vec2 d = _circle - _st;\n    return step(dot(d, d), _radius * _radius);\n}\n\nfloat poly(in vec2 _st, in vec2 _poly, in float _rad) {\n    // polygon is 4 points on a circle\n    // _poly is coordinates of origin of polygon\n    vec4 _angles = vec4(random(_poly+vec2(.1)), random(_poly+vec2(.2)),\n                    random(_poly+vec2(.3)), random(_poly+vec2(.4)) );\n    float _total = _angles[0] + _angles[1] + _angles[2] + _angles[3];\n    _angles *= 2. * PI / _total;\n    \n    _angles[1] += _angles[0];\n    _angles[2] += _angles[1];\n    _angles[3] += _angles[2];\n    \n    vec4 _a2 = vec4(0.);\n    \n    vec2 _p0 = vec2(_poly.x+_rad*cos(_angles[0]), _poly.y+_rad*sin(_angles[0]));\n    vec2 _p1 = vec2(_poly.x+_rad*cos(_angles[1]), _poly.y+_rad*sin(_angles[1]));\n    vec2 _p2 = vec2(_poly.x+_rad*cos(_angles[2]), _poly.y+_rad*sin(_angles[2]));\n    vec2 _p3 = vec2(_poly.x+_rad*cos(_angles[3]), _poly.y+_rad*sin(_angles[3]));\n    \n    _a2[0] = atan(_p0.y-_st.y, _p0.x-_st.x); // cant assign these in a loop?\n    _a2[1] = atan(_p1.y-_st.y, _p1.x-_st.x);\n    _a2[2] = atan(_p2.y-_st.y, _p2.x-_st.x);\n    _a2[3] = atan(_p3.y-_st.y, _p3.x-_st.x);\n    \n    vec4 _a3 = _a2.gbar;\n    \n    float _ret = 1.;\n    \n    for (int _i = 0; _i < 4; _i++) {\n        float _aDiff = _a3[_i] - _a2[_i];\n        \n        _aDiff = mod(_aDiff + 2.*PI, 2.*PI);\n        \n        // if angle difference > 180 degrees then return 0\n        _ret *= step(_aDiff,PI);\n    }\n    \n    \n    return _ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord / 8.;\n    \n    float shade = 0.;\n    \n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    \n    vec3 col = vec3(0.);\n    \n    for (float xx = -GRID; xx <= GRID; xx++) {\n        for (float yy = -GRID; yy <= GRID; yy++) {\n        \n            vec2 i2 = i+vec2(xx,yy);\n            \n            float merge = random(i2+vec2(-1000.));\n            vec3 _col = vec3(0.,merge,1.);\n            \n            float brightOff = random(i2+vec2(-2000.)) * 2. * PI;\n            float brightness = (1.+sin(iTime + brightOff))*.5;\n            brightness = brightness * brightness * brightness;\n            _col = (1.-brightness)*_col + brightness * vec3(1.);\n            \n            float rad = .5+(GRID-.5)*random(i2);\n            \n            float _a = .5 * poly(st, i2+vec2(.5), rad);\n            col = (1.-_a) * col + _a * _col;\n        }\n    }\n    \n    \n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKyzV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 355, 382, 382, 499], [501, 501, 563, 563, 640], [642, 642, 697, 785, 2031], [2033, 2033, 2090, 2090, 2990]]}
{"id": "wdKyzW", "name": "cityfolding", "author": "jj99", "description": "space folding", "tags": ["sdf", "folding", "city"], "likes": 11, "viewed": 262, "published": "Public API", "date": "1602362952", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A quick shadertoy port of City Shader from MagicaVoxel - original by mode_vis / paulofalcao\n\n#define AA 2\n\nfloat box(vec3 r, vec3 p, vec3 size)\n{\n    r = abs(r-p) - size;\n    return max(max(r.x,r.y),r.z);\n}\n\nfloat sphere(vec3 r,vec3 p, float radius)\n{\n    return length(r-p) - radius;\n}\n\nfloat cylinder(vec3 r,vec3 p, float radius, float height)\n{\n    return max(length(r.xy-p.xy) - radius, abs(r.z-p.z)-height);\n}\nmat2 rot(float a)\n{\n\tfloat c=cos(a),s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\n\nvec3 Folding(vec3 p)\n{\n    p *= -0.3;\n    \n    \n    float f = 2.65;\n    float ic = 0.0;\n    if (iMouse.z>0.5)\n    {\n        f+=sin(iTime*0.7);\n        ic  = sin(iTime*1.2)*0.1;\n    }\n    \n    \n    \n    float s=3.;\n\tfor(int i=0;i<10;i++)\n    {\n\t\tp.xy=abs(p).xy-s;\n        p.xy *= rot(f*0.1);\n\t    p.xz *= rot(ic*0.1);\n\t\ts=s/1.3;\n\t}\n    \n    return p;\n}\n\n\nfloat map( in vec3 p )\n{\n    \n\tfloat d = cylinder(p.xzy,vec3(0.0),4.75,1.0);\n    \n    p.yz*=rot(3.14*0.5);\n    \n    \n    p = Folding(p);\n    p += .05;\n    \n    vec3 pos1 = p;\n    pos1.x = abs(p.x);\n    vec3 pos2 = p;\n    \n    p.xy = abs(p.xy);\n    \n    \n\tfloat sdf = 0.;\n    sdf = box(p,vec3(0.0,0.0,-0.1),vec3(2.,10.0,0.1));\n\tsdf = min(sdf,box(p,vec3(0.08,0.08,0.0),vec3(0.05,0.05,0.004)));\n\tsdf = max(sdf,-box(p,vec3(0.08,0.08,0.0),vec3(0.045,0.045,0.0025)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(0.02,10.0,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(10.,0.02,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.15,0.0,0.0),vec3(0.01,10.0,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.15,0.0),vec3(10.,0.01,0.002)));\n\n    vec3 b1 = p;\n\tb1.xy -= vec2(0.22,0.08);\n    b1 = abs(b1);\n    float XYsize =  max(0.0,.5*p.z-0.02);\n    float Zsize =  max(0.,0.4*max(b1.x,b1.y)-0.008);\n    sdf = min(sdf,box(b1,vec3(-0.0,0.,0.0),vec3(0.05-XYsize,0.05-XYsize,0.06-Zsize)));\n    sdf = max(sdf,-box(b1,vec3(0.0,0.0,0.052),vec3(0.02+XYsize,0.02+XYsize,0.05)));\n    sdf = min(sdf,box(b1,vec3(0.02,0.04,0.046),vec3(0.005,0.009,0.007)));\n\tsdf = min(sdf,box(b1,vec3(0.04,0.02,0.05),vec3(0.004,0.002,0.006)));\n    b1.xy *= 0.56;\n    b1 = abs(b1-0.02);\n\tsdf = max(sdf,-box(b1,vec3(0.01,0.01,0.01),vec3(0.003,0.003,0.008)));\n\n    vec3 b0 = pos1;\n    b0.xy -= 0.08;\n\tb0=abs(b0);\n    sdf = min(sdf,box(b0,vec3(0.,0.,0.005),vec3(0.05,0.05,0.005)));\n    sdf = max(sdf,-box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));\n\tsdf = min(sdf,box(b0,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b0,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n    float noise = 1.+0.05*length(sin(p*2000.0))+0.2*length(sin(p*900.0)); \n    b0.xy = abs(b0.xy);\n    b0.xy -= 0.02;\n    b0.xy = abs(b0.xy);\n    b0 -= vec3(0.01,0.01,0.02);\n    sdf = min(sdf,cylinder(b0,vec3(0.,0.,-0.015),0.001,0.009));\n    b0*=noise;\n    sdf = min(sdf,sphere(b0,vec3(0.),0.007));\n    sdf = min(sdf,sphere(b0,vec3(0.,0.,-.006),0.011));\n\n    vec3 b2 = p;\n    b2.xy -= 0.22;\n    b2 = abs(b2);\n\tsdf =  min(sdf,box(b2,vec3(0.,0.,0.0),vec3(0.05,0.03,0.1)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.04),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.07),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.1),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.05),vec3(0.02,0.02,0.1)));\n\tsdf = min(sdf,box(b2,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b2,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.03),vec3(0.03,0.04,0.1)));\n\tsdf = max(sdf,-box(b2,vec3(0.,0.,0.025),vec3(0.03,0.025,0.1)));\n\n    vec3 b3 = pos2;\n    b3.xy -=  vec2(0.08,0.-0.08);\n    b3 = abs(b3);\n\tsdf = min(sdf,box(b3,vec3(0.,0.,0.053),vec3(0.045,0.045,0.008)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.033),vec3(0.04,0.04,0.033)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.0,0.064),vec3(0.04,0.04,0.006)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.02),vec3(0.051,0.051,0.002)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.04),vec3(0.051,0.051,0.002)));\n    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.033),vec3(0.01,0.051,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.033),vec3(0.051,0.01,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.053),vec3(0.01,0.051,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.053),vec3(0.051,0.01,0.003)));\n\tsdf = max(sdf,-box(b3,vec3(0.,0.016,0.003),vec3(0.051,0.01,0.003)));\n    sdf = min(sdf,box(b3,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));\n\n    vec3 b4 = pos2;\n    b4.xy -= vec2(0.08,0.-0.22);\n    b4 = abs(b4);\n    sdf = min(sdf,box(b4,vec3(0.,0.,0.003),vec3(0.051,0.051,0.003)));\n    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.049,0.049,0.004)));\n    sdf = min(sdf,box(b4,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b4,vec3(0.05,0.05,0.04),vec3(0.005,0.001,0.001)));\n    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.052,0.01,0.004)));\n    vec3 cone = b4;\n    vec3 stairs = b4;\n    sdf = min(sdf,cylinder(b4,vec3(0.008,0.008,0.015),0.0005,0.006));\n    cone.xy += (cone.z-0.021);\n    sdf = min(sdf,cylinder(cone,vec3(0.,0.,0.026),0.015,0.006));\n    stairs.xy += floor(stairs.z * 800.0)/800.0;\n\tsdf = min(sdf,box(stairs,vec3(0.008,0.008,0.0),vec3(0.02,0.02,0.01)));\n\n    vec3 b5 = pos2;\n    b5.xy -= vec2(-0.08,0.-0.22);\n\tb5 = abs(b5);\n    sdf = min(sdf,box(b5,vec3(0.014,0.0018,0.0),vec3(0.002,0.001,0.03)));\n\tsdf = min(sdf,box(b5,vec3(0.01,0.0018,0.03),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.02,0.0018,0.032),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.01,0.0018,0.024),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.04,0.01,0.0),vec3(0.01,0.016,0.01)));\n\tsdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.004),0.004));\n\tsdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.010),0.006));\n    sdf = min(sdf,box(b5,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b5,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n\n    sdf = max(sdf,d);\n    \n    return sdf;\n}\n\n\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.125*iTime;\n\tvec3 ro = vec3( 6.0*cos(an), .8+sin(iTime)*0.4, 6.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 30.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 ldir = normalize(vec3(0.5,0.2,0.4));\n            \n            float dif = clamp( dot(nor,ldir), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.2,0.2)*amb + vec3(0.8,0.7,0.5)*dif;\n   \t\t\tcol+= pow(dif, 40.);\n\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKyzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 110, 148, 148, 209], [211, 211, 254, 254, 289], [291, 291, 350, 350, 417], [418, 418, 437, 437, 489], [492, 492, 514, 514, 843], [846, 846, 870, 870, 5822], [5826, 5890, 5922, 5922, 6160], [6167, 6167, 6224, 6249, 7916]]}
{"id": "WdtcDS", "name": "Eli's Path Tracer", "author": "SNAKFRIEN", "description": "Triangle?", "tags": ["pathtracing"], "likes": 2, "viewed": 76, "published": "Public", "date": "1602263961", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI = 3.1415926538;\nconst float epsilon = 0.001;\n\nconst int nSpheres = 20;\nconst int nSamples = 8;\nconst int maxDepth = 4;\n\nconst int lightIndex = 0;\n\nvec2 NewSeed(vec2 seed)\n{\n\treturn seed += 0.1;\n}\n\nfloat repeatRand(inout vec2 seed)\n{\n\tseed = NewSeed(seed);\n\treturn fract(sin(dot(seed.xy ,vec2(12.3215,78.233))) * 9.5453);\n}\n\nvec2 repeatRand2(inout vec2 seed)\n{\n\tseed = NewSeed(seed);\n\treturn vec2(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.xy ,vec2(35431.1234,45.567))) * 15454.5675));\n}\n\nvec3 repeatRand3(inout vec2 seed)\n{\n\tseed = NewSeed(seed);\n\treturn vec3(fract(sin(dot(seed.xy ,vec2(1334.9898,128.233))) * 7.5453),\n\t\t\t\tfract(sin(dot(seed.xy ,vec2(1342.1234,45.567))) * 53.5675), \n\t\t\t\tfract(sin(dot(seed.xy ,vec2(5904.2344,2.244))) * 234.6451));\n}\n\nfloat SameRand(vec2 seed)\n{\n\treturn fract(sin(dot(seed.xy ,vec2(12.3215,78.233))) * 9.5453);\n}\n\nvec3 SameRand3(vec2 seed)\n{\n\treturn vec3(fract(sin(dot(seed.xy ,vec2(12.9898,78.233))) * 43758.5453),\n\t\t\t\tfract(sin(dot(seed.xy ,vec2(1.1234,45.567))) * 23454.5675), \n\t\t\t\tfract(sin(dot(seed.xy ,vec2(56.2344,23.244))) * 46442.6451));\n}\n\nstruct Material\n{\n\tvec3 albedo;\n\tvec3 emission;\n\tint type; //0 = diffuse, 1 = specular, 2 = refractive\n\t\n};\n\nstruct Sphere\n{\n\tvec3 pos;\n\tfloat radius;\n\tMaterial material;\n};\n\nstruct Intersection\n{\n\tbool isFound;\n\tfloat dist;\n\tvec3 pos;\n\tMaterial material;\n\tvec3 normal;\n};\n\nvec3 GenerateRayDirection(vec2 uv, vec2 seed)\n{\n\tvec2 pixelScale = 1.0 / iResolution.xy;\n\tfloat xOffset = repeatRand(seed) * pixelScale.x;\n\tfloat yOffset = repeatRand(seed) * pixelScale.y;\n\treturn normalize(vec3(uv.x + xOffset, uv.y + yOffset, 1));\n}\n\nvoid GenerateSpheres(inout Sphere spheres[nSpheres])\n{\n\tvec2 seed = vec2(2);\n\tfor(int i = 0; i < nSpheres; i++)\n\t{\n\t\tspheres[i].pos = SameRand3(seed);\n\t\tspheres[i].pos.x = (spheres[i].pos.x - 0.5) * 10.0;\n\t\tspheres[i].pos.y = (spheres[i].pos.y - 0.5) * 5.0 * sin(iTime * 1.1234 * SameRand(vec2(float(i)))) - 3.;\n\t\tspheres[i].pos.z = spheres[i].pos.z * 20.0 + 5.0;\n\t\tif(false) //toggle side view\n\t\t{\n\t\t\tfloat temp = spheres[i].pos.x;\n\t\t\tspheres[i].pos.x = spheres[i].pos.y;\n\t\t\tspheres[i].pos.y = temp;\n\t\t}\n\t\t\n\t\tspheres[i].radius = 1.0;\n\t\tMaterial m;\n\t\tm.albedo = repeatRand3(seed) * 0.5 + 0.5;\n\t\tm.emission = vec3(0);\n\t\tspheres[i].material = m;\n\t}\n\t//Add light source\n\tspheres[lightIndex].pos = vec3(sin(iTime) * 2.0, 3.0, 15.0 + cos(iTime) * 2.0);\n\t//spheres[lightIndex].pos = vec3(0.0, 4.0, 15.0);\n\tspheres[lightIndex].material.emission = vec3(1);\n\tspheres[lightIndex].radius = 1.0;\n\t//Add walls\n\tspheres[5].pos = vec3(1000, 0, 0);\n\tspheres[5].radius = 995.0;\n\tspheres[5].material.albedo = vec3(0.9, 0, 0);\n\t\n\tspheres[4].pos = vec3(-1000, 0, 0);\n\tspheres[4].radius = 995.0;\n\tspheres[4].material.albedo = vec3(0, 0.9, 0);\n\t\n\tspheres[3].pos = vec3(0, 1000, 0);\n\tspheres[3].radius = 995.0;\n\tspheres[3].material.albedo = vec3(0.9, 0.9, 0.9);\n\t\n\tspheres[2].pos = vec3(0, -1000, 0);\n\tspheres[2].radius = 995.0;\n\tspheres[2].material.albedo = vec3(0.9, 0.9, 0.9);\n\n\tspheres[1].pos = vec3(0, 0, 1000);\n\tspheres[1].radius = 970.0;\n\tspheres[1].material.albedo = vec3(0.9, 0.9, 0.9);\n}\n\nvoid MakeOrthonormal(vec3 v1, inout vec3 v2, inout vec3 v3)\n{\n\tif(abs(v1.x) > abs(v1.y))\n\t{\n\t\t//Project to the y = 0 plane and construct a normalized orthogonal vector in this plane\n\t\tfloat invertedLength = 1.0 / sqrt(v1.x * v1.x + v1.z * v1.z);\n\t\tv2 = vec3(-v1.z * invertedLength, 0.0, v1.x * invertedLength);\n\t}\n\telse\n\t{\n\t\t//Project to the x = 0 plane and construct a normalized orthogonal vector in this plane\n\t\tfloat invertedLength = 1.0 / sqrt(v1.y * v1.y + v1.z * v1.z);\n\t\tv2 = vec3(0.0, v1.z * invertedLength, -v1.y * invertedLength);\n\t}\n\tv3 = cross(v1, v2);\n}\n\nvec3 HemisphereDirection(vec2 uv)\t//Projects flat points onto a hemisphere\n{\n\tfloat r = sqrt(1.0 - uv.x * uv.x);\n\tfloat phi = 2.0 * PI * uv.y;\n\treturn vec3(cos(phi) * r, sin(phi) * r, uv.x);\n}\n\nvec3 RandomSpherePoint(inout vec2 seed, float radius)\n{\n\twhile(true)\n\t{\n\t\tvec3 result = repeatRand3(seed);\n\t\tresult * radius;\n\t\tif(length(result) < radius)\n\t\t{\n\t\t\treturn result;\n\t\t}\n\t}\n}\n\nvec3 RandomSphereDirection(inout vec2 seed) {\n    vec2 h = repeatRand2(seed) * vec2(2.,6.28318530718)-vec2(1,0);\n    float phi = h.y;\n\treturn vec3(sqrt(1.-h.x*h.x)*vec2(sin(phi),cos(phi)),h.x);\n}\n\nbool TraceLightRay(vec3 rayOrigin, inout Sphere spheres[nSpheres], inout vec2 seed)\n{\n\tvec3 randomLightPoint = RandomSphereDirection(seed) * spheres[lightIndex].radius + spheres[lightIndex].pos;\n\tvec3 rayDirection = normalize(randomLightPoint - rayOrigin);\n\tint intersectionIndex = 1000;\n\tfloat closestDistance = 5000.0;\n\tfor(int i = 0; i < nSpheres; i++)\n\t{\n\t\tfloat t = dot(spheres[i].pos - rayOrigin, rayDirection);\n\t\tvec3 p = rayOrigin + rayDirection * t;\n\t\tfloat y = length(spheres[i].pos - p);\n\t\tif(y < spheres[i].radius)\n\t\t{\n\t\t\tfloat x = sqrt(spheres[i].radius * spheres[i].radius - y * y);\n\t\t\tfloat t1 = t - x;\n\t\t\tfloat t2 = t + x;\n\t\t   \tfloat dist;\n\t\t\tif(t1 < epsilon)\n\t\t\t{\n\t\t\t\tdist = t2;\n\t\t\t}\n\t\t\telse if(t2 < epsilon)\n\t\t\t{\n\t\t\t\tdist = t1;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdist = min(t1, t2);\n\t\t\t}\n\t\t\tif(dist < closestDistance && dist > epsilon)\n\t\t\t{\n\t\t\t\tintersectionIndex = i;\n\t\t\t\tclosestDistance = dist;\n\t\t\t}\n\t\t}\n\t}\n\treturn intersectionIndex == lightIndex;\n}\n\nvec3 TraceRay(vec3 rayOrigin, vec3 rayDirection, vec2 uv, int depth, inout vec2 seed, bool justAlbedo)\n{\n\tSphere spheres[nSpheres];\n\tGenerateSpheres(spheres);\n\n\tvec3 result = vec3(0);//0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));\n\tvec3 collectedAlbedo[maxDepth];\n\tvec3 collectedEmission[maxDepth];\n\tvec3 collectedIncomingLight[maxDepth]; //Collects incoming light from the light source at this poin\n\n\tfor(int i; i < maxDepth; i++)\n\t{\n\t\tIntersection intersection;\n\t\tintersection.dist = 5000.0;\n\t\tintersection.isFound = false;\n\n\t\tfor(int j = 0; j < nSpheres; j++)\n\t\t{\n\t\t\t//Calculate collision with sphere\n\t\t\tfloat t = dot(spheres[j].pos - rayOrigin, rayDirection);\n\t\t\tvec3 p = rayOrigin + rayDirection * t;\n\t\t\tfloat y = length(spheres[j].pos - p);\n\t\t\tif(y < spheres[j].radius)\n\t\t\t{\n\t\t\t\tfloat x = sqrt(spheres[j].radius * spheres[j].radius - y * y);\n\t\t\t\tfloat t1 = t - x;\n\t\t\t\tfloat t2 = t + x;\n\t\t\t   \tfloat dist = min(t1, t2);\n\t\t\t\tif(dist < intersection.dist && dist > epsilon)\n\t\t\t\t{\n\t\t\t\t\tvec3 intersectionPoint = rayOrigin + rayDirection * dist;\n\t\t\t\t\tintersection.isFound = true;\n\t\t\t\t\tintersection.dist = dist;\n\t\t\t\t\tintersection.pos = intersectionPoint;\n\t\t\t\t\tintersection.material = spheres[j].material;\n\t\t\t\t\tintersection.normal = normalize(intersectionPoint - spheres[j].pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif(intersection.isFound)\n\t\t{\n\t\t\tMaterial m = intersection.material;\n\t\t\tif(justAlbedo)\n\t\t\t{\n\t\t\t\tif(TraceLightRay(intersection.pos, spheres, seed))\n\t\t\t\t{\n\t\t\t\t\treturn m.albedo;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\treturn m.albedo * 0.2;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//Calculate direction for next ray\n\t\t\tvec3 rotationX;\n\t\t\tvec3 rotationY;\n\t\t\tMakeOrthonormal(intersection.normal, rotationX, rotationY);\n\t\t\tvec3 sampleDirection = HemisphereDirection(repeatRand2(seed));\n\t\t\tvec3 rotatedDirection;\n\t\t\trotatedDirection.x = dot(vec3(rotationX.x, rotationY.x, intersection.normal.x), sampleDirection);\n\t\t\trotatedDirection.y = dot(vec3(rotationX.y, rotationY.y, intersection.normal.y), sampleDirection);\n\t\t\trotatedDirection.z = dot(vec3(rotationX.z, rotationY.z, intersection.normal.z), sampleDirection);\n\t\t\tfloat cosTerm = dot(rotatedDirection, intersection.normal);\n\n\t\t\t//Set up next ray\n\t\t\trayOrigin = intersection.pos;\n\t\t\trayDirection = rotatedDirection;//sampleDirection;\n\n\t\t\t//Store emitted light and albedo for current ray\n\t\t\tcollectedAlbedo[i] = m.albedo * cosTerm;\n\t\t\tcollectedEmission[i] = m.emission * 2.0; //2.0 to account for lack of infinite light bounces\n\n\t\t\t//Direct light sampling\n\t\t\tif(TraceLightRay(intersection.pos, spheres, seed))\n\t\t\t{\n\t\t\t\tcollectedIncomingLight[i] = spheres[lightIndex].material.emission;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tcollectedIncomingLight[i] = vec3(0.0);\n\t\t\t}\n\t\t}\n\t}\n\n\t//Get light from the final bounce\n\tvec3 transmittedRadiance = vec3(0.0);//vec3(0.3);//collectedEmission[maxDepth - 1];\n\t//Apply reflected light in reverse order\n\tfor(int i = maxDepth - 1; i >= 0; i--)\n\t{\n\t\ttransmittedRadiance = collectedEmission[i] + collectedAlbedo[i] * transmittedRadiance + collectedAlbedo[i] * collectedIncomingLight[i];\n\t}\n\t\n\treturn result = transmittedRadiance;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\tvec2 seed = uv * PI * fract(1.12345314312*iTime);\n\n\tvec3 col = vec3(0);\n\t\n\tbool justAlbedo;\n\tif(sin(iTime * 1.1) < 0.0)\n\t{\n\t\tjustAlbedo = true;\n\t}\n\telse\n\t{\n\t\tjustAlbedo = false;\n\t}\n\n\t//Trace ray through scene to retrieve color for current pixel\n\tfor(int i = 0; i < nSamples; i++)\n\t{\n\t\t//Generate ray\n\t\tvec3 rayOrigin = vec3(0);\n\t\tvec3 rayDirection = GenerateRayDirection(uv, seed);\n\t\tcol += TraceRay(rayOrigin, rayDirection, uv, 0, seed, justAlbedo);\n\t}\n\t\n\tcol /= float(nSamples);\n\t\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtcDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 187, 187, 210], [212, 212, 247, 247, 337], [339, 339, 374, 374, 542], [544, 544, 579, 579, 807], [809, 809, 836, 836, 903], [905, 905, 932, 932, 1139], [1415, 1415, 1462, 1462, 1665], [1667, 1667, 1721, 1721, 3141], [3143, 3143, 3204, 3204, 3710], [3712, 3712, 3788, 3788, 3904], [3906, 3906, 3961, 3961, 4092], [4094, 4094, 4139, 4139, 4289], [4291, 4291, 4376, 4376, 5247], [5249, 5249, 5353, 5353, 8300], [8302, 8302, 8359, 8359, 8938]]}
{"id": "wdtcRs", "name": "Cyclostationary noise", "author": "cycloEG2020", "description": "This is a simple shader illustrating the possibility of adapting noise models to the cyclostationary context. It uses a spatially-varying and periodic PSD (the PSD of the polyphase components) for each sample of the output, and keeps the random phase.", "tags": ["noise"], "likes": 0, "viewed": 133, "published": "Public API", "date": "1601572378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//=================================================================\n//= Cyclostationary noise - paper 1152 - For Eurographics 2021\n//=================================================================\n//= Based on the shadertoys of Arthur Cavalier (LRPN, phasor) and Fabrice Neyret (Gabor noise).\n//- Shaders : https://www.shadertoy.com/view/WscGD8\n//-           https://www.shadertoy.com/view/WsSSWG\n//=================================================================\n\n//The spectrum model is based on manipulating the frequency, orientation and range\n//of a bi-lobe spectrum according to the spatial coordinates with a period.\n//The viewer is invited to play with the definitions of F (range of frequencies) \n//and O (range of orientations) from line 188 to 202\n//in order to modify the spatially-varying spectrum used.\n\n//--------------------------------------------------------------------------------------------------------\n//-- User Parameters -------------------------------------------------------------------------------------  \n#define MOUSE_CONTROL\n#define TIMER_OFFSET\nconst int   LRPN_COSINES     = 3;\nconst float LRPN_RESOLUTION  = 5.0;\nconst float LRPN_SLOPE_SCALE = 0.1;\nconst uint  LRPN_GLOBAL_SEED = 0u;\n\nfloat \t\tGABOR_SIZE   = 0.07;\nfloat\t\tGABOR_NB_KERNELS = 300.; //lower if running on a low-end PC\n\n//--------------------------------------------------------------------------------------------------------\n//-- Constants -------------------------------------------------------------------------------------------  \nconst float m_pi_2 \t\t= 1.5707963267;         \nconst float m_pi   \t\t= 3.1415926535;          \nconst float m_2_pi \t\t= 6.2831853071;\nconst float m_isqrt2 \t= 0.7071067811865;\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Pseudo Random Number Generation ---------------------------------------------------------------------  \n// From Texton Noise Source Code provided by Arthur Leclaire et al. \n// https://www.idpoisson.fr/galerne/texton_noise/index.html\n// Sourced ::\n/* \n * From http://www.reedbeta.com/blog/2013/01/12/quick-and-easy-gpu-random-numbers-in-d3d11/\n * Same strategy as in Gabor noise by example\n * Apply hashtable to create cellseed\n * Use a linear congruential generator as fast PRNG\n */\n\nuint  wang_hash(uint seed)                                          {seed=(seed^61u)^(seed>>16u);seed*=9u;seed=seed^(seed>>4u);seed*=668265261u;seed=seed^(seed>>15u);return(seed);}\nuint  cell_seed(const in ivec2 c, const in uint offset)             {const uint period=1024u;uint s=((uint(c.y)%period)*period+(uint(c.x)%period))*period+offset; if(s==0u){s = 1u;}return(s);}\nuint  myrand(inout uint p)                                          {p^=(p<<13u);p^=(p>>17u);p^=(p<<5u);return p;}\nfloat myrand_uniform_0_1(inout uint p)                              {return float(myrand(p))/float(4294967295u);}\nfloat myrand_uniform_m_M(inout uint p, in float mi, in float ma)    {return mi + (myrand_uniform_0_1(p) * (ma - mi));}\nbool keyToggle(int ascii) \n{\n\treturn (texture(iChannel2,vec2((.5+float(ascii))/256.,0.75)).x > 0.);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Normal Mapping Function -----------------------------------------------------------------------------  \nvec3 normal_map_from_slope(float dx, float dy) // using partial derivatives\n{\n    float norm = length(vec3(dx,dy,1.0));\n    float nx = -dx / norm; \n    float ny = -dy / norm; \n    float nz = 1.0 / norm; \n    return 0.5 + 0.5 * vec3(nx,ny,nz);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Gaussian Window Function ----------------------------------------------------------------------------  \nfloat gaussian(in vec2 st, in float c, in vec2 mu, in mat2 sig)\n{\n    vec2 p = st-mu;\n    float body = -0.5*dot(p,inverse(sig)*p);\n    return c*exp(body);\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Profile Functions ----------------------------------------------------------------------------------- \n//-- From Thibault Tricard source : https://www.shadertoy.com/view/wlsXWf\nfloat PWM(float x, float r) {return mod(x,m_2_pi)> m_2_pi *r ? 1.0 : 0.0;}\nfloat wave_square(float x)  {return PWM(x,0.5);}\nfloat wave_saw(float x)     {return mod(x,m_2_pi)/(m_2_pi);}\nfloat wave_sine(float x)    {return 0.5+0.5*sin(x);}\n\n\n\n//--------------------------------------------------------------------------------------------------------\n//-- Local Random Phase Noise ----------------------------------------------------------------------------\nvec4 local_random_phasor_noise(\n        in vec2  texcoords,\n        in float resolution,\n        in int   cosines,\n        in vec2  range_frequency,\n        in vec2  range_orientation\n    )\n{\n    vec2  scaled_coords = texcoords * resolution;\n    vec2  cell_coords   = fract(scaled_coords);\n    vec2  cell_index    = floor(scaled_coords);\n    \n    ivec2 cell_ID;\n    uint  prng, seed;\n    \n    vec4  lrpn   = vec4(0.);\n    float weight = 1. / float(cosines);\n    mat2  sigma  = mat2( (1.2*1.2)/m_2_pi );\n\n    for (int m=-1; m<=+1; m++)\n    for (int n=-1; n<=+1; n++)\n    {\n        cell_ID.x = int(cell_index.x) + m;\n        cell_ID.y = int(cell_index.y) + n;\n        seed = cell_seed(cell_ID,LRPN_GLOBAL_SEED);\n        prng = wang_hash(seed);\n\n        vec2 xy = cell_coords - vec2(m,n) - vec2(0.5);\n        float d = dot(xy,xy);\n        \n        vec2  sum_of_cosines    = vec2(0.); \n        float sum_of_partial_x  = 0.; \n        float sum_of_partial_y  = 0.; \n        for(int k=0; k<cosines; k++)\n        {\n            float fr = myrand_uniform_m_M(prng,range_frequency.x,range_frequency.y) * resolution;   // Scaled Frequency \n            float or = myrand_uniform_m_M(prng,range_orientation.x,range_orientation.y);            // Orientation\n            float ph = m_pi*(myrand_uniform_0_1(prng)*2.-1.);                                       // Phase\n            float ff = m_2_pi * dot(xy, fr * vec2(cos(or),sin(or)) );                               // Oriented Frequency\n            vec2  sc = vec2( cos(ff+ph), sin(ff+ph) ); \n\n            sum_of_cosines   += sc;\n            sum_of_partial_x += -m_2_pi * fr * cos(or) * sc.y;\n            sum_of_partial_y += -m_2_pi * fr * sin(or) * sc.y; \n        }\n\n        lrpn += gaussian(xy, 1., vec2(0.0), sigma) * weight * vec4(sum_of_cosines, sum_of_partial_x, sum_of_partial_y);\n    }\n    return vec4(lrpn); // vec3(Cosines, Sines, Partial X, Partial Y); \n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Utils -----------------------------------------------------------------------------------------------\nfloat looped_smooth_stairs(float t, float ratio, float nof_values)\n{\n    t*= nof_values;\n    return mix(floor(mod(t/ratio, nof_values)), floor(mod((t+1.)/ratio, nof_values)), smoothstep(0.0, 1.0, fract(t)));\n}\n\nfloat gauss(float x,float s) {\n    return exp(-.5*(x*x)/(s*s)); \n}\nfloat gauss(vec2 v,float s) { return gauss(v.x,s)*gauss(v.y,s); }\n\n\nfloat rndi(float i, float j) {\n    return fract(1e5*sin(i+3.*j+0.567));\n}\n\n\n// --- complex Gabor ------------------------------\nvec2 Gabor(vec2 pos, float freq, float a) {\n    float t = (keyToggle(64+20))? 0. : iTime; // 'T'\n    float g = gauss(pos, GABOR_SIZE);\n    if (g < 1e-3) return vec2(0.);\n    vec2 dir = m_isqrt2*(cos(a)*vec2(1.,1.)+ sin(a)*vec2(-1.,1.));\n    float phi = freq*dot(pos,dir) * 2.* m_pi + 10.*t;\n\n    return g*vec2(cos(phi),sin(phi)); // NB: only the real part is used, classically\n}\n\n// --- complex Gabor noise = kernel * point distrib\nvec2 GaborNoise(vec2 uv, vec2 F, vec2 O) {\n    const uint seed = uint(0);\n    uint prng = wang_hash(seed);\n    vec2 f=vec2(0.);\n\tfor (float i=0.; i<GABOR_NB_KERNELS; i++) { \n\t\tvec2 pos = vec2(1.8*rndi(i,0.),-1.+rndi(i,1.)*2.);\n        float a = myrand_uniform_m_M(prng, O.x, O.y);\n        float F = myrand_uniform_m_M(prng, F.x, F.y);\n\t\tf += Gabor(uv-pos, F, a);\n\t}\n\treturn f *sqrt(200./GABOR_NB_KERNELS); // /6.;\n}\n\n//--------------------------------------------------------------------------------------------------------\n//-- Main ------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pixcoords = fragCoord.xy / iResolution.xy;\n    vec2 texcoords = (2.*fragCoord.xy-iResolution.xy) / iResolution.y;\n    vec2 mouse = clamp(iMouse.xy / iResolution.xy, 0., 1.);\n    \n    //===========================================\n\n    //Definition of a spatially-varying amplitude - teaser\n    vec2  F = vec2(0.5,0.6);        \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//~ Frequecy range [fmin;fmax]\n    vec2  O = vec2(0. + texcoords.x * m_pi * 1.66 , m_pi/6. + texcoords.x * 1.66* m_pi);   \t\t\t//~ Orientation range [omin;omax]\n    \n    //Definition of a spatially-varying amplitude - sup mat. (1)\n    //vec2  F = vec2(0.5,0.6);\n    //vec2  O = vec2(0. + m_pi * 1.66 , 1.66* m_pi + cos(16.*texcoords.y));\n    \n    //Definition of a spatially-varying amplitude - sup mat. (2)\n    //vec2  F = vec2(0.5,0.6);\n    //vec2  O = vec2(0. + texcoords.x * m_pi * 1.66 , texcoords.x * 1.66* m_pi + (m_pi/4.)*cos(5.*texcoords.y));\n    \n    //===========================================\n    \n    float R = LRPN_RESOLUTION;      \t\t\t\t\t\t\t\t\t\t//~ Grid resolution\n    int   K = LRPN_COSINES;         \t\t\t\t\t\t\t\t\t\t//~ Number of cosines\n\n#ifdef TIMER_OFFSET\n    texcoords += vec2(0.1*iTime);\n#endif\n\n    vec4  lrpn = local_random_phasor_noise(texcoords,R,K,F,O);\n    float Sc = lrpn.x;\n    float Ss = lrpn.y;\n    float Dx = lrpn.z * LRPN_SLOPE_SCALE;\n    float Dy = lrpn.w * LRPN_SLOPE_SCALE;\n\n    float Phi = atan(Ss,Sc);\n\n\tif(pixcoords.x < 0.66)\n    {\n      \tif(pixcoords.x < 0.33)\n        \tfragColor.rgb = vec3(0.5+0.5*Sc);\n        else\n        {\n          \tfloat Weight = looped_smooth_stairs(iTime,4.,3.);\n        \tfloat Phasor = wave_sine(Phi);\n                        //+ max(1.-abs(Weight-1.),0.) * wave_saw(Phi) //different phasor noise profiles\n                        //+ max(1.-abs(Weight-2.),0.) * wave_square(Phi);\n        \tfragColor.rgb = vec3( Phasor );\n        }\n    }\n    else\n    {\n        texcoords -= vec2(0.1*iTime);\n        vec2 f  = .5 * GaborNoise(texcoords, F*25., O - m_pi/4.); //sqrt((O.y-O.x)*(O.y-O.x)\n    \n    \t// --- Normalize and display Gabor noise\n    \tfragColor = vec4(.5+.5*f.x);  \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtcRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1708, 2304, 2373, 2373, 2484], [2485, 2485, 2554, 2554, 2676], [2677, 2677, 2746, 2746, 2791], [2792, 2792, 2861, 2861, 2905], [2906, 2906, 2975, 2975, 3024], [3025, 3025, 3053, 3053, 3126], [3128, 3344, 3421, 3421, 3588], [3590, 3806, 3871, 3871, 3962], [3964, 4253, 4282, 4282, 4327], [4328, 4328, 4357, 4357, 4376], [4377, 4377, 4406, 4406, 4437], [4438, 4438, 4467, 4467, 4490], [4494, 4708, 4899, 4899, 6611], [6613, 6827, 6895, 6895, 7036], [7038, 7038, 7068, 7068, 7104], [7105, 7105, 7134, 7134, 7170], [7173, 7173, 7203, 7203, 7246], [7249, 7301, 7344, 7344, 7679], [7681, 7733, 7775, 7775, 8148], [8150, 8364, 8421, 8421, 10505]]}
{"id": "wdtcWj", "name": "MM - My first ray marching", "author": "MatMercer", "description": "From this tutorial https://www.youtube.com/watch?v=PGtv-dBi2wE", "tags": ["raymarching"], "likes": 2, "viewed": 27, "published": "Public", "date": "1601788008", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 1024\n#define MIN_DIST 0.01\n#define MAX_DIST 100.0\n\nfloat getDist(vec3 p) {\n    vec4 s = vec4(0, 1, 6, 1);\n    \n    float sphereDist = length(p - s.xyz) - s.w;\n    float planeDist = p.y;\n    \n    return min(sphereDist, planeDist);\n}\n\nfloat rayMarch(vec3 orig, vec3 dir) {\n   \tvec3 curPoint;\n    \n    float dist = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        curPoint = orig + dir * dist;\n        \n        float minDist = getDist(curPoint);\n                \n        dist += minDist;\n        \n        if (minDist < MIN_DIST || minDist > MAX_DIST) break;\n    }\n    \n    return dist;\n}\n\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat getLight(vec3 p) {\n    vec3 lightPos = vec3(0, 4, 6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(lightPos - p);\n    vec3 n = getNormal(p);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    float d = rayMarch(p+n*MIN_DIST*2., l);\n    if (d < length(lightPos - p)) dif *= .5;\n    \n    return dif;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center coords\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 pos = vec3(0, 1, 0);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1));\n    float d = rayMarch(pos, dir);\n    //d /= 10.;\n\n    vec3 p = pos + dir * d;\n    \n    float dif = getLight(p);\n\tcol = vec3(dif);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtcWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 92, 92, 249], [251, 251, 288, 288, 612], [614, 614, 638, 638, 836], [838, 838, 862, 862, 1173], [1176, 1176, 1233, 1254, 1621]]}
{"id": "wdtcWl", "name": "Extruded Curve", "author": "Ezra_Szanton", "description": "I'm not quite sure what this is, I think it's some extruded form of a lissajous curve, as that is what the leftmost dot is tracing out.", "tags": ["periodic", "lissajous"], "likes": 1, "viewed": 47, "published": "Public", "date": "1602020891", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv, vec2 center, float min, float max)\n{\n    return (1. - smoothstep(min, max, length(uv - center)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord-0.*iResolution.xy)/iResolution.y;\n    uv.y -= 0.5;\n    \n    \n    vec2 polar = vec2(length(uv), atan(uv.x / uv.y) * 1.14);\n    //uv = polar;\n    \n    \n    uv *= 15.;\n\n    vec3 col = vec3(0.);\n    \n    float numCircles = cos(iTime) * 50.  + 55.;\n    \n    for(float i = 0.; i < numCircles; i = i + 1.){\n          vec2 temp = uv;\n          temp.x -= i*0.7 + 5.;\n          vec3 color = vec3(0.8, 0.6, i / numCircles);\n          float circ = circle(temp, vec2(sin(iTime * 7.1 - i*0.3), cos(iTime * 6. - i*0.3)), 0.1, 0.13);\n          col += circ * color;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 121], [123, 123, 180, 180, 823]]}
{"id": "wdtcWn", "name": "Rasterization-Viewport", "author": "sapporo_dynamite", "description": "multi-viewport\nvp1. FILL_SOILD\nvp2. FILL_LINE\nvp3. OUT_COLOR_ZBUFFER", "tags": ["rasterizer", "viewport", "zbuffer", "perspectivecorrect", "cullmode", "fillmode"], "likes": 6, "viewed": 187, "published": "Public", "date": "1601981986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\tRasterizer\n\n\tSoftware Rasterization\n\tImplemented Viewport\n\n\tauthor:\n\tsapporo_dynamite/2020 \n\n\tLicense :\n\tCreative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n*/\n\n/*\n2020/10/06\n\t0.0.0 → 1.0.0\n\t・最初のリリース\n*/\n\nstruct Triangle\n{\n    vec3 p0;\n    vec3 p1;\n    vec3 p2;\n    vec3 c0;\n    vec3 c1;\n    vec3 c2;\n};\n\nTriangle triangles[1];\n\nmat4 setTranslation( float x, float y, float z )\n{\n    return mat4( 1.0, 0.0, 0.0, 0.0,\n\t\t\t\t 0.0, 1.0, 0.0, 0.0,\n\t\t\t\t 0.0, 0.0, 1.0, 0.0,\n\t\t\t\t x,     y,   z, 1.0 );\n}\n\nmat4 setRotation( float x, float y, float z )\n{\n    float a = sin(x); float b = cos(x); \n    float c = sin(y); float d = cos(y); \n    float e = sin(z); float f = cos(z); \n\n    float ac = a*c;\n    float bc = b*c;\n\n    return mat4( d*f,      d*e,       -c, 0.0,\n                 ac*f-b*e, ac*e+b*f, a*d, 0.0,\n                 bc*f+a*e, bc*e-a*f, b*d, 0.0,\n                 0.0,      0.0,      0.0, 1.0 );\n}\n\nmat4 setPerspective( float fovy, float aspect, float near, float far)\n{\n    float d = 1. / (tan( radians(fovy) * 0.5 ));\n    float q = far  / ( far - near );\n    return mat4( d/aspect,    0,   0,        0,\n        \t\t        0,    d,   0,        0,\n                        0,    0,  -q,       -1,\n                        0,    0,  -q * near, 0 );\n}\n\nmat4 SetOrtho( float l, float r, float b, float t, float near, float far)\n{\n    return mat4( 2./(r-l),        0,              0,                             0,\n                 0,               2./(t-b),       0,                             0,\n                 0,               0,              (1. / (far - near) * 0.5),     0,\n                 -(r+l)/(r-l),   -(t+b)/(t-b),    (-near / (far - near) + 0.5),  1 );\n}\n\n\nvoid createTriangle( void )\n{\n    triangles[0].p0 = vec3( 0.0,  1.0, -0.0); \n    triangles[0].c0 = vec3( 1.0,  0.0,  0.0); \n    triangles[0].p1 = vec3(-1.0, -1.0, -0.0);\n    triangles[0].c1 = vec3( 0.0,  1.0,  0.0); \n    triangles[0].p2 = vec3( 1.0, -1.0, -0.0);\n    triangles[0].c2 = vec3( 0.0,  0.0,  1.0);\n}\n\nfloat cross2d( vec2 a, vec2 b )\n{\n    return a.x*b.y - a.y*b.x;\n}\n\nfloat edge(vec2 a, vec2 b, vec2 c) \n{ \n    return ((c.x - a.x) * (b.y - a.y) - (c.y - a.y) * (b.x - a.x)); \n} \n\nfloat line( vec2 a, vec2 b, vec2 p, float r)\n{\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return (length( pa - ba*h ) - r);    \n}\n\n// draw endless line trough A and B\nfloat DrawLine(vec2 P, vec2 A, vec2 B, float r)\n{\n\tvec2 g = B - A;\n    float d = abs(dot(normalize(vec2(g.y, -g.x)), P - A));\n\treturn smoothstep(r, 0.5*r, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    bool PERSP = true;\n    bool OUT_COLOR = true;\n    bool PERSP_CORRECT = true;\n    bool FILL_SOILD =  true;\n    bool CULL_MODE  =  true;\n   \n    float n = 1.0;\n    float f = 100.0;\n    float fov = 90.0;\n    \n    vec2 uv = (fragCoord.xy) / iResolution.xy;\n    \n    // viewport settging\n    vec4 viewport[3] = vec4[]( \n        vec4( 0., 0, iResolution.x/3., iResolution.y),\n        vec4( iResolution.x/3., 0, iResolution.x/3.,  iResolution.y),\n        vec4( 2.*iResolution.x/3., 0., iResolution.x/3.,  iResolution.y)\n    );\n    \n    // current viewport\n    vec4 vp = vec4(0);\n    \n    // clear color\n    vec3 col = vec3(float(0x4c)/255.0, float(0x7f)/255.0, float(0xb2)/255.0);\n    \n    bool draw = false;\n    if(fragCoord.x >= viewport[0].x && fragCoord.x <= (viewport[0].z + viewport[0].x) &&\n       fragCoord.y >= viewport[0].y && fragCoord.y <= (viewport[0].w + viewport[0].y) )    \n    {\n        draw = true;\n        vp = viewport[0];\n    }\n    else if(fragCoord.x >= viewport[1].x && fragCoord.x <= (viewport[1].z + viewport[1].x) &&\n            fragCoord.y >= viewport[1].y && fragCoord.y <= (viewport[1].w + viewport[1].y) ) \n    {\n        draw = true;\n        FILL_SOILD = false;\n        vp = viewport[1];\n    }\n    else if(fragCoord.x >= viewport[2].x && fragCoord.x <= (viewport[2].z + viewport[2].x) &&\n            fragCoord.y >= viewport[2].y && fragCoord.y <= (viewport[2].w + viewport[2].y) ) \n    {\n        draw = true;\n        OUT_COLOR = false;\n        vp = viewport[2];\n        col = vec3(1,1,1);\n    }\n    \n    if(draw)\n    { \n        float aspect = vp.z / vp.w;\n    \n        // Projeciotn Matrix\n        mat4 proj = PERSP ? setPerspective(fov, aspect, n, f) : SetOrtho(-1.5 * aspect, 1.5 * aspect, -1.5, 1.5, n, f);    \n\n        mat4 modelViewProj = proj * setTranslation( 0.0, 0.0, -3.5 ) * setRotation( 0.0, 3.1*sin(0.3*iTime), 0.0);\n        \n        vec2 px = (fragCoord - vp.xy)/(vp.zw);\n        px -= vec2(0.5);\n        \n        // line width\n        float line_width = 0.004;\n\n        // clear zbuffer\n        float mindist = 1000000.0;\n\n        // setup triangle\n        createTriangle();\n\n        // 三角形の描画\n        // render triangles\n        for( int i = 0; i < 1; i++ )\n        {\n            // モデル&ビュー&投影 座標系 変換\n            // transform modelViewProj space\n            vec4 v0 = (modelViewProj * vec4(triangles[i].p0, 1));\n            vec4 v1 = (modelViewProj * vec4(triangles[i].p1, 1));\n            vec4 v2 = (modelViewProj * vec4(triangles[i].p2, 1));\n\n            // クリップ座標系 変換\n            // transform clip space\n            float w0 = 1.0 / v0.w;\n            float w1 = 1.0 / v1.w;\n            float w2 = 1.0 / v2.w;\n\n\n            // 正規化デバイス座標系 変換\n            // transform NDC\n            vec3 c0_ndc = triangles[i].c0 * (PERSP_CORRECT ? w0 : 1.0);\n            vec3 c1_ndc = triangles[i].c1 * (PERSP_CORRECT ? w1 : 1.0);\n            vec3 c2_ndc = triangles[i].c2 * (PERSP_CORRECT ? w2 : 1.0);\n\n            // xy\n            vec2 v0_ndc = v0.xy * w0;\n            vec2 v1_ndc = v1.xy * w1;\n            vec2 v2_ndc = v2.xy * w2;\n\n            // z\n            float z0_ndc = v0.z * w0;\n            float z1_ndc = v1.z * w1;\n            float z2_ndc = v2.z * w2;\n\n            // サブ三角形の面積計算\n            // calculate areas for subtriangles        \n            float e = edge( v1_ndc, v0_ndc, v2_ndc);\n\n            vec3 area_ccw = vec3( edge( v1_ndc, v0_ndc, px),\n                                  edge( v2_ndc, v1_ndc, px),\n                                  edge( v0_ndc, v2_ndc, px) );\n\n            vec3 line_area = vec3( line(v0_ndc, v1_ndc, px, line_width),\n                                   line(v1_ndc, v2_ndc, px, line_width),\n                                   line(v2_ndc, v0_ndc, px, line_width) );\n\n             // ピクセルが三角形に重なるかどうか  \n             // pixel overlaps the triangle\n             bool ccw_test  = all(greaterThan(area_ccw,vec3(0.0))) && FILL_SOILD;\n             bool cw_test   = all(lessThan(area_ccw,vec3(0.0))) && FILL_SOILD && CULL_MODE;\n             bool line_test = !all(greaterThan(line_area,vec3(0.0))) && !FILL_SOILD;;\n\n\n             // ラスタライズ\n             // Rasterize \n             if( ccw_test || cw_test || line_test)\n             {\n                 // 重心座標は サブ三角形の面積を全体の三角形の面積で割ったもの \n                 // barycentric coordinates are the sub-triangle area divided by total triangle area.\n                  vec3 ba = vec3(ccw_test || cw_test) * area_ccw.yzx / ( area_ccw.x + area_ccw.y + area_ccw.z) + \n                            vec3(line_test)  *  area_ccw.yzx / ( e );\n\n\n                 // 頂点属性の 重心補間\n                 // barycentric interpolation of attributes and 1/z\n                 float iz = ba.x*w0 + ba.y*w1 + ba.z*w2;\n                 vec2  uv = vec2(0, 0);            \n                 vec3  color = vec3(ba.x * c0_ndc.x + ba.y * c1_ndc.x + ba.z * c2_ndc.x,\n                                    ba.x * c0_ndc.y + ba.y * c1_ndc.y + ba.z * c2_ndc.y,\n                                    ba.x * c0_ndc.z + ba.y * c1_ndc.z + ba.z * c2_ndc.z );\n\n                 // zs[ 0～1 ]\n                 float zs = ba.x*z0_ndc + ba.y*z1_ndc + ba.z*z2_ndc;\n                 // 補間された値 を 戻す\n                 // recover interpolated attributes\n                 float z =  1.0/iz;\n\n                 // z near/far clip\n                 // ニア/ファー クリップ\n                 if( zs >= 0.0 && zs <= 1.0)\n                 {\n                     // depth buffer test\n                     // Zバッファ テスト\n                     if( zs < mindist )\n                     {\n                            mindist = zs;\n                            color *= (PERSP_CORRECT ? z : 1.0);\n                            col = OUT_COLOR ? vec3( color) :vec3( zs ) ;\n                     }\n                 }\n             }\n        }\n    }\n    \n    float intensity = DrawLine(uv, vec2(viewport[0].x/iResolution.x,0), vec2(viewport[0].x/iResolution.x,1), 0.001); \n    intensity += DrawLine(uv, vec2(viewport[1].x/iResolution.x,0), vec2(viewport[1].x/iResolution.x,1), 0.001); \n    intensity += DrawLine(uv, vec2(viewport[2].x/iResolution.x,0), vec2(viewport[2].x/iResolution.x,1), 0.001); \n    \n    col = mix(col, vec3(0,0,0), intensity);\n    \n    \n    // 出力\n    // Output to screen\n    fragColor = vec4(col,1.0);\n  \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtcWn.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[189, 374, 424, 424, 540], [542, 542, 589, 589, 946], [948, 948, 1019, 1019, 1295], [1297, 1297, 1372, 1372, 1712], [1715, 1715, 1744, 1744, 2025], [2027, 2027, 2060, 2060, 2092], [2094, 2094, 2131, 2131, 2203], [2206, 2206, 2252, 2252, 2394], [2396, 2432, 2481, 2481, 2592], [2594, 2594, 2651, 2651, 9165]]}
{"id": "wdtyDX", "name": "modmunch", "author": "DJDoomz", "description": "some cool patterns", "tags": ["2d", "int", "bitwise", "munching"], "likes": 6, "viewed": 204, "published": "Public API", "date": "1601910254", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage(out vec4 O, vec2 U)\n{\n    O = vec4( (int(O.xy = U*.3 + iTime/.1) ^ int(O.y)+211) %  (int(iTime*1.5) % 60 + 9)  ) *.2;\n}\n\n//Unknown error: ERROR: Undefined function 'mainImage()' used in the following call chain:main)\n//I guess shadertoy broke the define trick?\n//93 chars by Fabrice\n//#define mainImage(O,U)\t\t\t\\\n\t//O = vec4( (int(O.xy = U*.3 + iTime/.1) ^ int(O.y)+211) %  (int(iTime*1.5) % 60 + 9)  ) *.2/*\n\n/*\n\n//improvement by Fabrice\n#define mainImage(O,U)\t\t\t\\\n    O.xy = U*.3 + iTime/.1;\t\t\\\n\tO = vec4( (int(O) ^ int(O.y)+211) %  (int(iTime*1.5) % 60 + 9)  ) *.2\n  \n\n97 by Xor:\n#define mainImage(O,U)\t\t\t\\\n    O.xy = U*.3 + iTime/.1;\t\t\\\n\tO = vec4( (int(O) ^ int(O.y+211.)) %  (int(iTime*1.5) % 60 + 9)  ) *.2\n\n\n105 char by Fabrice:\n#define mainImage(O,U)                                 \\\n    ivec2 u = ivec2( U*.3 + vec2(0,221) + iTime/.1 );  \\\n\tO = vec4( (u.x^u.y) % ( int(iTime*1.5)%60 +9 ) ) *.2\n\n\n-10 by Xor:\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u *= .3;\n    u.y += 221.;\n    u += iTime/.1;    \n\to=vec4((int(u.x)^ int(u.y))%(int(iTime*1.5)%60+9))*.2;\n}\n\n\nog shader:\nvoid mainImage(out vec4 o, vec2 u)\n{\n    u *= .3;\n    u.y += 221.;\n    u += 10.*iTime;    \n\to=vec4((int(u.x)^ int(u.y))%int(fract(iTime/40.0)*60.0+9.))*.2;\n}\n\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtyDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 37, 37, 135]]}
{"id": "wdVcRD", "name": "cityfolding2", "author": "jj99", "description": " A quick shadertoy port of City Shader from MagicaVoxel - original by mode_vis / paulofalcao\nusing sabs for folds", "tags": ["sdf", "folding", "kifs", "city", "sabs"], "likes": 11, "viewed": 406, "published": "Public API", "date": "1602374684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A quick shadertoy port of City Shader from MagicaVoxel - original by mode_vis / paulofalcao\n// using sabs for the folds as suggested by ollj\n\n#define AA 1\n\nfloat box(vec3 r, vec3 p, vec3 size)\n{\n    r = abs(r-p) - size;\n    return max(max(r.x,r.y),r.z);\n}\n\nfloat sphere(vec3 r,vec3 p, float radius)\n{\n    return length(r-p) - radius;\n}\n\nfloat cylinder(vec3 r,vec3 p, float radius, float height)\n{\n    return max(length(r.xy-p.xy) - radius, abs(r.z-p.z)-height);\n}\nmat2 rot(float a)\n{\n\tfloat c=cos(a),s=sin(a);\n\treturn mat2(c,s,-s,c);\n}\n\n#define less(a,b,c)      mix(a,b,step(0.,c))\n#define sabs(x,k) less((.5/k)*x*x+k*.5,abs(x),abs(x)-k)\n\nvec3 Folding(vec3 p)\n{\n    p *= -0.3;\n    \n    float f = 2.65;\n    float ic = 0.0;\n    if (iMouse.z>0.5)\n    {\n        f+=sin(iTime*0.7);\n        ic  = sin(iTime*1.2)*0.1;\n    }\n    \n    \n    \n    float s=3.;\n\tfor(int i=0;i<10;i++)\n    {\n\t\tp.xy=sabs(p,0.01).xy-s;\n        p.xy *= rot(f*0.1);\n\t    p.xz *= rot(ic*0.1);\n\t\ts=s/1.3;\n\t}\n    \n    return p;\n}\n\n\nfloat map( in vec3 p )\n{\n    \n\tfloat d = cylinder(p.xzy,vec3(0.0),4.75,1.0);\n    \n    p.yz*=rot(3.14*0.5);\n    \n    \n    p = Folding(p);\n    p += .05;\n    \n    vec3 pos1 = p;\n    pos1.x = abs(p.x);\n    vec3 pos2 = p;\n    \n    p.xy = abs(p.xy);\n    \n    \n\tfloat sdf = 0.;\n    sdf = box(p,vec3(0.0,0.0,-0.1),vec3(2.,10.0,0.1));\n\tsdf = min(sdf,box(p,vec3(0.08,0.08,0.0),vec3(0.05,0.05,0.004)));\n\tsdf = max(sdf,-box(p,vec3(0.08,0.08,0.0),vec3(0.045,0.045,0.0025)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(0.02,10.0,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.0,0.0),vec3(10.,0.02,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.15,0.0,0.0),vec3(0.01,10.0,0.002)));\n    sdf = max(sdf,-box(p,vec3(0.0,0.15,0.0),vec3(10.,0.01,0.002)));\n\n    vec3 b1 = p;\n\tb1.xy -= vec2(0.22,0.08);\n    b1 = abs(b1);\n    float XYsize =  max(0.0,.5*p.z-0.02);\n    float Zsize =  max(0.,0.4*max(b1.x,b1.y)-0.008);\n    sdf = min(sdf,box(b1,vec3(-0.0,0.,0.0),vec3(0.05-XYsize,0.05-XYsize,0.06-Zsize)));\n    sdf = max(sdf,-box(b1,vec3(0.0,0.0,0.052),vec3(0.02+XYsize,0.02+XYsize,0.05)));\n    sdf = min(sdf,box(b1,vec3(0.02,0.04,0.046),vec3(0.005,0.009,0.007)));\n\tsdf = min(sdf,box(b1,vec3(0.04,0.02,0.05),vec3(0.004,0.002,0.006)));\n    b1.xy *= 0.56;\n    b1 = abs(b1-0.02);\n\tsdf = max(sdf,-box(b1,vec3(0.01,0.01,0.01),vec3(0.003,0.003,0.008)));\n\n    vec3 b0 = pos1;\n    b0.xy -= 0.08;\n\tb0=abs(b0);\n    sdf = min(sdf,box(b0,vec3(0.,0.,0.005),vec3(0.05,0.05,0.005)));\n    sdf = max(sdf,-box(b0,vec3(0.,0.,0.006),vec3(0.048,0.048,0.005)));\n\tsdf = min(sdf,box(b0,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b0,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n    float noise = 1.+0.05*length(sin(p*2000.0))+0.2*length(sin(p*900.0)); \n    b0.xy = abs(b0.xy);\n    b0.xy -= 0.02;\n    b0.xy = abs(b0.xy);\n    b0 -= vec3(0.01,0.01,0.02);\n    sdf = min(sdf,cylinder(b0,vec3(0.,0.,-0.015),0.001,0.009));\n    b0*=noise;\n    sdf = min(sdf,sphere(b0,vec3(0.),0.007));\n    sdf = min(sdf,sphere(b0,vec3(0.,0.,-.006),0.011));\n\n    vec3 b2 = p;\n    b2.xy -= 0.22;\n    b2 = abs(b2);\n\tsdf =  min(sdf,box(b2,vec3(0.,0.,0.0),vec3(0.05,0.03,0.1)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.04),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.07),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.1),vec3(0.04,0.05,0.01)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.05),vec3(0.02,0.02,0.1)));\n\tsdf = min(sdf,box(b2,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b2,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n\tsdf = min(sdf,box(b2,vec3(0.,0.,0.03),vec3(0.03,0.04,0.1)));\n\tsdf = max(sdf,-box(b2,vec3(0.,0.,0.025),vec3(0.03,0.025,0.1)));\n\n    vec3 b3 = pos2;\n    b3.xy -=  vec2(0.08,0.-0.08);\n    b3 = abs(b3);\n\tsdf = min(sdf,box(b3,vec3(0.,0.,0.053),vec3(0.045,0.045,0.008)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.033),vec3(0.04,0.04,0.033)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.0,0.064),vec3(0.04,0.04,0.006)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.02),vec3(0.051,0.051,0.002)));\n    sdf = min(sdf,box(b3,vec3(0.,0.,0.04),vec3(0.051,0.051,0.002)));\n    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.033),vec3(0.01,0.051,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.033),vec3(0.051,0.01,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.016,0.,0.053),vec3(0.01,0.051,0.003)));\n    sdf = max(sdf,-box(b3,vec3(0.,0.016,0.053),vec3(0.051,0.01,0.003)));\n\tsdf = max(sdf,-box(b3,vec3(0.,0.016,0.003),vec3(0.051,0.01,0.003)));\n    sdf = min(sdf,box(b3,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));\n\n    vec3 b4 = pos2;\n    b4.xy -= vec2(0.08,0.-0.22);\n    b4 = abs(b4);\n    sdf = min(sdf,box(b4,vec3(0.,0.,0.003),vec3(0.051,0.051,0.003)));\n    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.049,0.049,0.004)));\n    sdf = min(sdf,box(b4,vec3(0.05,0.05,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b4,vec3(0.05,0.05,0.04),vec3(0.005,0.001,0.001)));\n    sdf = max(sdf,-box(b4,vec3(0.,0.,0.004),vec3(0.052,0.01,0.004)));\n    vec3 cone = b4;\n    vec3 stairs = b4;\n    sdf = min(sdf,cylinder(b4,vec3(0.008,0.008,0.015),0.0005,0.006));\n    cone.xy += (cone.z-0.021);\n    sdf = min(sdf,cylinder(cone,vec3(0.,0.,0.026),0.015,0.006));\n    stairs.xy += floor(stairs.z * 800.0)/800.0;\n\tsdf = min(sdf,box(stairs,vec3(0.008,0.008,0.0),vec3(0.02,0.02,0.01)));\n\n    vec3 b5 = pos2;\n    b5.xy -= vec2(-0.08,0.-0.22);\n\tb5 = abs(b5);\n    sdf = min(sdf,box(b5,vec3(0.014,0.0018,0.0),vec3(0.002,0.001,0.03)));\n\tsdf = min(sdf,box(b5,vec3(0.01,0.0018,0.03),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.02,0.0018,0.032),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.01,0.0018,0.024),vec3(0.015,0.001,0.001)));\n\tsdf = min(sdf,box(b5,vec3(0.04,0.01,0.0),vec3(0.01,0.016,0.01)));\n\tsdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.004),0.004));\n\tsdf = min(sdf,sphere(b5,vec3(0.04,0.04,0.010),0.006));\n    sdf = min(sdf,box(b5,vec3(0.052,0.052,0.0),vec3(0.001,0.001,0.04)));\n\tsdf = min(sdf,box(b5,vec3(0.052,0.052,0.04),vec3(0.005,0.001,0.001)));\n\n    sdf = max(sdf,d);\n    \n    return sdf;\n}\n\n\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an = 0.125*iTime;\n\tvec3 ro = vec3( 6.0*cos(an), .8+sin(iTime)*0.4, 6.0*sin(an) );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n\n    \n    \n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n\n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n\n        // raymarch\n        const float tmax = 30.0;\n        float t = 0.0;\n        for( int i=0; i<256; i++ )\n        {\n            vec3 pos = ro + t*rd;\n            float h = map(pos);\n            if( h<0.0001 || t>tmax ) break;\n            t += h;\n        }\n    \n        // shading/lighting\n        float v = 1.0-abs(p.y);\n        vec3 col = vec3(v*0.1);\n        if( t<tmax )\n        {\n            vec3 pos = ro + t*rd;\n            vec3 nor = calcNormal(pos);\n            \n            vec3 ldir = normalize(vec3(0.5,0.2,0.4));\n            \n            float dif = clamp( dot(nor,ldir), 0.0, 1.0 );\n            float amb = 0.5 + 0.5*dot(nor,vec3(0.0,0.8,0.6));\n            col = vec3(0.2,0.2,0.2)*amb + vec3(0.8,0.7,0.5)*dif;\n   \t\t\tcol+= pow(dif, 40.);\n\n        }\n\n        // gamma        \n        col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n\tfragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVcRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 159, 197, 197, 258], [260, 260, 303, 303, 338], [340, 340, 399, 399, 466], [467, 467, 486, 486, 538], [642, 642, 664, 664, 994], [997, 997, 1021, 1021, 5973], [5977, 6041, 6073, 6073, 6311], [6318, 6318, 6375, 6400, 8067]]}
{"id": "wdVcRy", "name": "Fab21 #inktober2020 \"sleep\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 17, "viewed": 269, "published": "Public API", "date": "1603180578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define L length//\n#define rot(a)      mat2( cos(a+vec4(0,11,33,0)) )            // rotation                  \n#define B(q,a,b,c)  max( (q).x-a, max( (q).y-b, (q).z-c) )    // box\n#define T(q,R,r)   ( L( vec2( L(L((q).xy) -R ), (q).z ) ) -r )// torus\n\nvoid mainImage(out vec4 O, vec2 U) {    \n    float t=9.,s,S,c,r,f,F=t;\n    vec3  R = iResolution, Y = vec3(0,1,0),\n          M = iMouse.z > 0. ? iMouse.xyz/R-.5 : vec3(4,2,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -1.5*R.y ) - R ),          // ray direction\n          p = vec3(0), q,a,k;                                 // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.015 )\n        q = p, t=9.,\n        q.yz *= rot(-6. *M.y),                                // rotations,\n        q.xz *= rot(-6.4*M.x),  q +=  vec3(0,9,10),           // translation\n        k=q, k.xz = abs(k.xz), k.x<k.z ? k.xz=k.zx : U,       // crypt walls\n        t = min(t, s = min( 15.-L(k.yx), k.y )  ),\n        a = k, a.xz*=mat2(1,-1,1,1)*.5,                       // crypt arches\n        t = min(t, S = T( a.yzx, 15.,.3) ), \n        t = min(t, r = T( q- 14.2*Y, .6,.1) ),                // ring\n        a = abs(q+vec3(0,0,10)), t = min(t, B(a, 2.,1.,5.) ), // white base\n        q = vec3( abs(q.x)-7., q.y-5., q.z+10. ),\n        t = min(t, c = min( B(a, 1.8,3.,4.5) ,                // black coffin\n                            max( L( q.xz ) - .3, q.y) )),     // candlesticks\n        t = min(t, f = L((q-Y)/vec3(1,3,1)-.03*sin(30.*iTime+q.y))-.2 ), // flame\n        F = min(F,f),                                         // for glow\n        p += t*D;                                             // step forward = dist to obj          \n\n    \n    O = exp(-2.5*O);                                          // --- coloring\n    O += vec4(1,.5,.2,0)* ( 2./(f*f) + .05/(F*F) );           // flame lighting + halo\n    if (t==c || t==r) O *= .3;                                // coffin && roof ring\n    if (t==S)  s=S, k.z=5.;                                   // arches\n    if (t==s)  O *= vec4(1,.9,.8,1)                           // crypt walls\n                  * texture(iChannel0, vec2( .1*k.z, atan(k.y,k.x)/.63 ));\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVcRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[252, 252, 288, 288, 2196]]}
{"id": "wdVczd", "name": "first shader, hello circle", "author": "aylictal", "description": "i guess if theres a hello world for this, this is the type.", "tags": ["circle", "colorchange", "blurchange"], "likes": 2, "viewed": 251, "published": "Public API", "date": "1603560332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv, vec2 pos, float radius, float blur){\n    \n    float d = length(uv-pos);\n    float c = smoothstep(radius, radius-blur, d);\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat t = iTime;\n    \n    uv -= .5; // converts range from 0=>1 to -.5=>.5\n    uv.x *= iResolution.x/iResolution.y; //convert aspect ratio to viewing display\n\tfloat blur = abs(sin(t));\n    //normalized cartesian coordinates where 0 is center of screen, range -1.0 => 1.0\n    vec2 pos = vec2(0.0, 0.0);\n    float mask = circle(uv, pos, .5, blur);\n    vec3 color = vec3(sin(t), cos(t), atan(t)) * mask;\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 159], [161, 161, 217, 267, 774]]}
{"id": "WdVyDK", "name": "Utils_BarycentricInterpolation", "author": "bigt", "description": "Barycentric Interpolation\n重心坐标插值", "tags": ["barycentricinterpolation"], "likes": 1, "viewed": 52, "published": "Public", "date": "1603866122", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ROTATE 1\n\nmat2 rotateZ(float angle)\n{\n    return mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n}\n\nconst float PI = 3.1415926535;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 c1 = vec3(1.0,0.0,0.0);// O\n    vec3 c2 = vec3(0.0,1.0,0.0);// A\n    vec3 c3 = vec3(0.0,0.0,1.0);// B\n    \n    // rotate\n    \n    //     A(p2)\n    //     /\\\n    //    /  \\\n    //   /____\\\n    // O(p1)   B(p3)\n    //vec2 O = vec2(0.25,0.2);\n    //vec2 A = vec2(0.5,0.9);\n    //vec2 B = vec2(0.7,0.3);\n    //vec2 C = uv;\n    \n    vec2 O = vec2(90.0,100.0);\n    vec2 A = vec2(230.0,180.0);\n    vec2 B = vec2(280.0,60.0);\n    vec2 C = fragCoord;\n    \n#if ROTATE == 1\n      vec2 center = (O+A+B)/3.0;\n      C = C-center;\n\t  C *= rotateZ(sin(iTime*0.5) * PI * 2.0);\n      C = C+center;\n#endif\n    \n    vec2 OA = A - O;\n    vec2 OB = B - O;\n    vec2 OC = C - O;\n    \n    vec2 AC = C - A;\n    vec2 AB = B - A;\n    \n    // 用叉乘计算平行四边形面积\n    float s = abs(OA.y*OB.x-OA.x*OB.y);// 总面积\n    float s2 = abs(OC.y*OB.x-OC.x*OB.y) / s;\n    float s3 = abs(OC.y*OA.x-OC.x*OA.y) / s;\n    //float s1 = 1.0 - s2 - s3;\n    float s1 = abs(AC.y*AB.x-AC.x*AB.y) / s;\n \n    vec3 col = c1*s1 + c2*s2 + c3*s3;\n    float t = 1.0-smoothstep(1.0, 1.02, s1+s2+s3);// 在三角形里为1\n    col *= vec3(t);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVyDK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 45, 45, 113], [146, 146, 203, 203, 1394]]}
{"id": "wdVyDR", "name": "Rocket planet", "author": "sylvain69780", "description": "Can a dodecahedron be used as launch pad for rockets ?\n", "tags": ["rocket", "dodecahedron"], "likes": 22, "viewed": 163, "published": "Public", "date": "1602624970", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Rocket planet\n    -------------\n    \n    Again the magic of domain repetition.\n    \n    Related references\n    \n    IQ Distance functions\n    https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm    \n\n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n\n    Iridescent crystals - tdhooper\n    https://www.shadertoy.com/view/llcXWM\n\n*/\n\n#define PHI (1.618033988749895)\n#define PI acos(-1.)\n#define TAU 6.283185\n#define MAX_STEPS 100\n#define MAX_DIST 10.\n#define SURF_DIST .001\n#define S smoothstep\n\n\n// Nearest icosahedron vertex and id\nfloat quadrant(float a, float b) {\n\treturn ((sign(a) + sign(b) * 2.) + 3.) / 2.;\n}\nvec4 icosahedronVertex(vec3 p) {\n    vec3 v1, v2, v3, result, plane;\n    float id;\n    float idMod = 0.;\n\tv1 = vec3(sign(p.x) * PHI,sign(p.y) * 1.,0);\n\tv2 = vec3(sign(p.x) * 1.,0,sign(p.z) * PHI);\n\tv3 = vec3(0,sign(p.y) * PHI,sign(p.z) * 1.);\n    plane = normalize(cross(\n        mix(v1, v2, .5),\n        cross(v1, v2)\n    ));\n    if (dot(p, plane) > 0.) {\n    \tresult = v1;\n        id = quadrant(p.y, p.x);\n    } else {\n    \tresult = v2;\n        id = quadrant(p.x, p.z) + 4.;\n    }\n    plane = normalize(cross(\n        mix(v3, result, .5),\n        cross(v3, result)\n    ));\n    if (dot(p, plane) > 0.) {\n    \tresult = v3;\n        id = quadrant(p.z, p.y) + 8.;\n    }\n    return vec4(normalize(result), id);\n}\n\n// --------------------------------------------------------\n// http://math.stackexchange.com/a/897677\n// --------------------------------------------------------\n\nmat3 orientMatrix(vec3 A, vec3 B) {\n    mat3 Fi = mat3(\n        A,\n        (B - dot(A, B) * A) / length(B - dot(A, B) * A),\n        cross(B, A)\n    );\n    mat3 G = mat3(\n        dot(A, B),              -length(cross(A, B)),   0,\n        length(cross(A, B)),    dot(A, B),              0,\n        0,                      0,                      1\n    );\n    return Fi * G * inverse(Fi);\n}\n\n// https://iquilezles.org/www/articles/noacos/noacos.htm\nmat3 rotationAlign( vec3 d, vec3 z )\n{\n    vec3  v = cross( z, d );\n    float c = dot( z, d );\n    float k = 1.0f/(1.0f+c);\n\n    return mat3( v.x*v.x*k + c,     v.y*v.x*k - v.z,    v.z*v.x*k + v.y,\n                   v.x*v.y*k + v.z,   v.y*v.y*k + c,      v.z*v.y*k - v.x,\n                   v.x*v.z*k - v.y,   v.y*v.z*k + v.x,    v.z*v.z*k + c    );\n}\n\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n//-------------------------------------------------\n// https://www.shadertoy.com/view/4lyfzw\nvec2 opRevolution( in vec3 p, float w )\n{\n    return vec2( length(p.xz) - w, p.y );\n}\nfloat opExtrussion( in vec3 p, in float sdf, in float h )\n{\n    vec2 w = vec2( sdf, abs(p.z) - h );\n  \treturn min(max(w.x,w.y),0.0) + length(max(w,0.0));\n}\n\n// http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdVesica(vec2 p, float r, float d)\n{\n    p = abs(p);\n\n    float b = sqrt(r*r-d*d); // can delay this sqrt\n    return ((p.y-b)*d > p.x*b) \n            ? length(p-vec2(0.0,b))\n            : length(p-vec2(-d,0.0))-r;\n}\nfloat sdCircle(vec2 p, float r)\n{\n    return length(p)-r; \n}\nfloat sdCylinder( vec3 p, vec3 c )\n{\n  return length(p.xz-c.xy)-c.z;\n}\n\n// AKA ModPolar !\nvec3 opRepRoundabout(vec3 p,float radius,float sectors) {\n    float angle = TAU/sectors;\n    float sector = round(atan(p.z,p.x)/angle); // thanks to IQ video https://youtu.be/sl9x19EnKng?t=1745\n    p.xz *= Rot(-angle*sector);\n    p.x -= radius;\n    return p;\n}\n\n// http://iquilezles.org/www/articles/smin/smin.htm\nfloat smax( float a, float b, float k )\n{\n    float h = max(k-abs(a-b),0.0);\n    return max(a, b) + h*h*0.25/k;\n}\n\n\nfloat sdRocket( vec3 pos)\n{\n\tvec3 q=pos;\n\tfloat d = -0.03+abs(-0.1 + sdVesica(opRevolution(q,0.0), 1.4, 1.1 ));  // ABS for onioning\n    // porthole\n    // hole with cylinder\n    d = max(d,-max(-q.z,sdCylinder(q.yzx, vec3(0.,0.,0.15))));\n    // 3 sectors for engines\n\tq = opRepRoundabout(pos,0.,3.);\n    d = min(d, -0.05 + sdVesica(opRevolution(vec3(q.x-.6,q.y+.8,q.z),0.0), 0.65, 0.5 )) ;\n    // cut the bottom\n\td = smax( d, -pos.y-1.1, 0.05 );\n    // link between engines and rocket's body\n\tq += vec3(0.1,1.13,0.0);\n    float lnd = sdCircle(q.xy, 1.00 );\n        lnd = max(lnd,-sdCircle(q.xy+vec2(-0.3,0.3),0.6));\n        lnd = max(lnd,-sdCircle(q.xy+vec2(0.8,-1.1),1.3));\n        lnd = max(lnd,q.x-0.8);\n        lnd = max(lnd,-q.y+0.2);\n    d = min(d,opExtrussion (q,lnd,0.02)-0.01);\n    return d;\n}\n\n\nfloat sdCone( vec3 p, vec2 c )\n{\n    // c is the sin/cos of the angle\n    vec2 q = vec2( length(p.xz), p.y );\n    float d = length(q-c*max(dot(q,c), 0.0));\n    return d * ((q.x*c.y-q.y*c.x<0.0)?-1.0:1.0);\n}\n\nvec4 getRocketPath(float key) {\n\tfloat h=2.*S(1.,2.,key)*S(10.,9.,key);\n\tfloat r=S(1.2,3.,key)*S(9.8,8.,key);\n\tfloat a = 3.*TAU*S(1.2,9.5,key);\n\treturn vec4(0.,h+r*sin(a),r*cos(a),a);    \n}\n\nvec3 animateRocket(vec3 p,float time) {\n    time*=.3;\n    vec3 q=p;\n    float key = 20.*fract(time);\n\tfloat key2 =  20.*fract(time+.01);\n\tvec4 p1 = getRocketPath(key);\n\tq-=p1.xyz;\n\tq.y-=1.05;\n    q.yz*=Rot(p1.w);\n\treturn q;   \n}\n\n\nvec2 GetDist(vec3 p) {\n    float time = iTime;\n    p.xz *= Rot(time*.01*6.2831);        \n    p.yz *= Rot(time*.005*6.2831);        \n\ttime=time*.2;\n\tvec3 q=p;\n    vec4 ico = icosahedronVertex(q);\n    float id = ico.w;\n    q*=transpose(rotationAlign(ico.xyz,vec3(0.,1.,0.)));\n    float rocket = sdRocket(3.*animateRocket(q,time+id))*.333;\n    float earth = length(p)-.7;\n\tfloat c = -sdCone(q,vec2(sin(PI/6.),cos(PI/6.)));   // disance to domain bouding cone \n    float d=min(rocket,earth);    \n    d=min(d,max(c,.5));  // this is trying to slow down the ray marcher when approaching the bound of the cone over the face of the dode\n    return vec2(d,id);\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd) {\n\tfloat dO=0.;    \n    vec2 m;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        m = GetDist(p);\n        float dS = m.x;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }    \n    return vec2(dO,m.y);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0, 3, -3);\n    if ( iMouse.x != 0. ) {\n        vec2 mo = 2.*iMouse.xy/iResolution.xy-vec2(1.);\n        ro.yz *= Rot(-mo.y);\n        ro.xz *= Rot(-mo.x*6.2831);\n    }\n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec2 m = RayMarch(ro, rd);\n    float d=m.x;\n    \n    if(d<MAX_DIST) {\n    \tvec3 p = ro + rd * d;\n    \tvec3 n = GetNormal(p);\n        vec3  sun_lig = normalize( vec3(0.2, 0.35, -0.5) );        \n    \tfloat dif = clamp(dot( n, sun_lig ), 0.0, 1.0 )+.1;\n        vec3  sun_hal = normalize( sun_lig-rd );\n\t\tfloat sun_spe = pow(clamp(dot(n,sun_hal),0.0,1.0),8.0)*dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n        float sun_sha = step(-RayMarch(p+0.01*n, sun_lig).x,-MAX_DIST);\n        col += 1.*sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n        vec3 c = hsv2rgb(vec3(m.y/12.+fract(iTime*.05),0.8,.9)); // nice ?\n    \tcol += dif*c*(sun_sha*.9+.1);  \n    } else { col = vec3(.1)*(.5-abs(uv.y));}\n    col = pow(col, vec3(.4545));\t// gamma correction\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVyDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[632, 669, 703, 703, 751], [752, 752, 784, 784, 1460], [1462, 1625, 1660, 1660, 2012], [2014, 2071, 2109, 2109, 2423], [2426, 2426, 2453, 2453, 2579], [2582, 2582, 2601, 2601, 2663], [2665, 2758, 2799, 2799, 2843], [2844, 2844, 2903, 2903, 2999], [3001, 3079, 3121, 3121, 3300], [3301, 3301, 3334, 3334, 3361], [3362, 3362, 3398, 3398, 3432], [3434, 3452, 3509, 3509, 3712], [3714, 3766, 3807, 3807, 3879], [3882, 3882, 3909, 3909, 4684], [4687, 4687, 4719, 4756, 4893], [4895, 4895, 4926, 4926, 5084], [5086, 5086, 5125, 5125, 5314], [5317, 5317, 5339, 5339, 5970], [5972, 5972, 6005, 6005, 6253], [6255, 6255, 6279, 6279, 6467], [6469, 6469, 6519, 6519, 6710], [6712, 6712, 6769, 6769, 7875]]}
{"id": "WdVyDW", "name": "Segment Tracing - Blobs", "author": "Moon519", "description": "Official shaderToy release of Eurographics 2020 paper: Segment Tracing using Local Lipschitz Bounds.", "tags": ["tracing", "implicit", "segment"], "likes": 66, "viewed": 3215, "published": "Public API", "date": "1602865994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shadertoy implementation of \"Segment Tracing using Local Lipschitz Bounds\" - Eurographics 2020\n// Eric Galin, Eric Guérin, Axel Paris, Adrien Peytavie\n// Paper:   https://hal.archives-ouvertes.fr/hal-02507361/document\n// Video:\thttps://www.youtube.com/watch?v=NOinlrHyieE&feature=youtu.be\n// Talk:\thttps://www.youtube.com/watch?v=KIOSbWNu-Ms&feature=youtu.be\n// Github:  https://github.com/aparis69/Segment-Tracing\n//\n// Sphere tracing on the left - Segment tracing on the right.\n// You can move the sliders with the mouse.\n// MIT License\n\nconst int StepsMax  = 150;  // Maximum step count for sphere & segment tracing\nconst float Epsilon = 0.1;  // Marching epsilon\nconst float T       = 0.5;  // Surface threshold.\n\nconst float ra      = 20.0; // Ray start interval\nconst float rb      = 60.0; // Ray end interval\nconst float radius  = 8.0;  // Primitive radius\nconst float kappa   = 2.0;  // Segment tracing factor for next candidate segment\n\n// Transforms\nvec3 RotateY(vec3 p, float a)\n{\n    float sa = sin(a);\n    float ca = cos(a);\n    return vec3(ca * p.x + sa * p.z, p.y, -sa * p.x + ca * p.z);\n}\n\n// Cubic falloff\n// x: distance\n// R: radius\nfloat Falloff(float x, float R)\n{\n    float xx = clamp(x / R, 0.0, 1.0);\n    float y = (1.0 - xx * xx);\n    return y * y * y;\n}\n\n// Computes the global lipschitz bound of the falloff function\n// e: energy\n// R: radius\nfloat FalloffK(float e, float R)\n{\n    return e * 1.72 * abs(e) / R;\n}\n\n// Computes the local lipschitz bound of the falloff function\n// a: value at first bound\n// b: value at second bound\n// R: radius\n// e: energy\nfloat FalloffK(float a, float b, float R, float e)\n{\n    if (a > R)\n        return 0.0;\n    if (b < R / 5.0)\n    {\n        float t = (1.0 - b / R);\n    \treturn abs(e) * 6.0 * (sqrt(b) / R) * (t * t);\n    }\n\telse if (a > (R * R) / 5.0)\n    {\n        float t = (1.0 - a / R);\n    \treturn abs(e) * 6.0 * (sqrt(a) / R) * (t * t);\n    }\n    else\n        return FalloffK(e, R);\n}\n\n// Primitives\n// Point primitive field function\n// p: world point\n// c: center\n// R: radius\n// e: energy\nfloat Vertex(vec3 p, vec3 c, float R, float e)\n{\n  \treturn e * Falloff(length(p - c), R);\n}\n\n// Evaluates the local lipschitz bound of a point primitive over a segment [a, b]\n// c: center\n// R: radius\n// e: energy\n// a: segment start\n// b: segment end\nfloat VertexKSegment(vec3 c, float R, float e, vec3 a, vec3 b)\n{\n    vec3 axis = normalize(b - a);  \n    float l = dot((c - a), axis);\n    float kk = 0.0;\n    if (l < 0.0)\n    {\n        kk = FalloffK(length(c - a), length(c - b), R, e);\n    }\n    else if (length(b - a) < l)\n    {\n        kk = FalloffK(length(c - b), length(c - a), R, e);\n    }\n    else\n    {\n        float dd = length(c - a) - (l * l);\n        vec3 pc = a + axis * l;\n        kk = FalloffK(dd, max(length(c - b), length(c - a)), R, e);\n    }\n    float grad = max(abs(dot(axis, normalize(c - a))), abs(dot(axis, normalize(c - b))));\n    return kk * grad;\n}\n\n// Tree root\nfloat Object(vec3 p)\n{\n    float I = Vertex(p, vec3(-radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 2.0, 0, 0), radius, 1.0);\n    I += Vertex(p, vec3(radius / 3.0, radius, 0), radius, 1.0);\n    return I - T;\n}\n\n// K root\nfloat KSegment(vec3 a, vec3 b)\n{\n    float K = VertexKSegment(vec3(-radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 2.0, 0, 0), radius, 1.0, a, b);\n    K += VertexKSegment(vec3(radius / 3.0, radius, 0), radius, 1.0, a, b);\n    return K;\n}\nfloat KGlobal()\n{\n    return FalloffK(1.0, radius) * 3.0;\n}\n\n// Normal evaluation\nvec3 ObjectNormal(in vec3 p )\n{\t\n    float eps = 0.001;\n    float v = Object(p);\n    vec3 n;\n    n.x = Object(vec3(p.x + eps, p.y, p.z)) - v;\n    n.y = Object(vec3(p.x, p.y + eps, p.z)) - v;\n    n.z = Object(vec3(p.x, p.y, p.z + eps)) - v;\n    return normalize(n);\n}\n\n// Trace ray using sphere tracing\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SphereTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float kGlobal = KGlobal();\n    float t = ra;\n  \th = false;\t\n    s = 0;\n  \tfor(int i = 0; i < StepsMax; i++)\n    {\n        vec3 p = o + t * u;\n        float v = Object(p);\n        s++;\n\n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Move along ray\n        t += max(Epsilon, abs(v) / kGlobal);\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n\t}\n    return t;\n}\n\n// Trace ray using ray marching\n// o : ray origin\n// u : ray direction\n// h : hit\n// s : Number of steps\nfloat SegmentTracing(vec3 o, vec3 u, out bool h, out int s)\n{\n    float t = ra;\n  \th = false;   \n    float candidate = 1.0;\n    for(int i = 0; i < StepsMax; i++)\n    {\n        s++;\n        vec3 p = o + t * u;\n        float v = Object(p);\n        \n        // Hit object\n        if (v > 0.0)\n        {\n            h = true;\n            break;\n        }\n        \n        // Lipschitz constant on a segment\n        float lipschitzSeg = KSegment(p, o + (t + candidate) * u);\n        \n        // Lipschitz marching distance\n        float step = abs(v) / lipschitzSeg;\n        \n        // No further than the segment length\n        step = min(step, candidate);\n                     \n        // But at least, Epsilon\n        step = max(Epsilon, step);\n        \n        // Move along ray\n        t += step;\n        \n        // Escape marched far away\n        if (t > rb)\n            break;\n        \n        candidate = kappa * step;\n\t}\n    return t;\n}\n\n// Shading functions\nvec3 Background(vec3 rd)\n{\n    const vec3 C1 = vec3(0.8, 0.8, 0.9);\n\tconst vec3 C2 = vec3(0.6, 0.8, 1.0); \n\treturn mix(C1, C2, rd.y * 1.0 + 0.25);\n}\nvec3 Shade(vec3 p, vec3 n)\n{\n    const vec3 l1 = normalize(vec3(-2.0, -1.0, -1.0));\n    const vec3 l2 = normalize(vec3(2.0, 0.0, 1.0));\n    float d1 = pow(0.5 * (1.0 + dot(n, l1)), 2.0);\n    float d2 = pow(0.5 * (1.0 + dot(n, l2)), 2.0);\n    return vec3(0.6) + 0.2 * (d1 + d2)* Background(n);\n}\nvec3 ShadeSteps(int n)\n{\n    const vec3 a = vec3(97, 130, 234) / vec3(255.0);\n    const vec3 b = vec3(220, 94, 75) / vec3(255.0);\n    const vec3 c = vec3(221, 220, 219) / vec3(255.0);\n    float t = float(n) / float(StepsMax);   \n    if (t < 0.5)\n        return mix(a, c, 2.0 * t);\n    else\n        return mix(c, b, 2.0 * t - 1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{         \n    // Compute ray origin and direction\n  \tvec2 pixel = (gl_FragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n  \tfloat asp = iResolution.x / iResolution.y;\n  \tvec3 rd = normalize(vec3(asp * pixel.x, pixel.y - 1.5, -4.0));\n  \tvec3 ro = vec3(0.0, 18, 40.0);\n    vec2 mouse = (iMouse.xy / iResolution.xy) * 2.0 - 1.0;\n    if (mouse.y <= -0.9999) // show cost at frame 0\n        mouse.xy = vec2(0.0);\n \n    float a = (iTime * 0.25);\n    ro = RotateY(ro, a);\n    rd = RotateY(rd, a);\n    \n    // Trace ray\n    bool hit;   // Ray hit flag\n    int s;      // Number of steps\n    float t;    // Ray hit position\n    float sep = mouse.x;\n    \n    // Sphere tracing on the left\n   \tif (pixel.x < sep)\n    \tt = SphereTracing(ro, rd, hit, s); \n    // Segment tracing on the right\n    else\n        t = SegmentTracing(ro, rd, hit, s);\n\n    // Shade this with object\n    vec3 rgb = Background(rd);\n    if (pixel.y > mouse.y)\n    {\n        if (hit)\n        {\n            vec3 pos = ro + t * rd;    \n            vec3 n = ObjectNormal(pos);\n            rgb = Shade(pos, n);\n        }       \n    }\n    else\n    {\n        rgb = ShadeSteps(s);\n    }    \n    rgb *= smoothstep(1.0, 2.0, abs(pixel.x-sep)/(2.0 / iResolution.x));\n    rgb *= smoothstep(1.0, 2.0, abs(pixel.y-mouse.y)/(2.0 / iResolution.y));\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVyDW.jpg", "access": "shaders20k", "license": "mit", "functions": [[950, 964, 995, 995, 1108], [1110, 1155, 1188, 1188, 1282], [1284, 1373, 1407, 1407, 1443], [1445, 1588, 1640, 1640, 1961], [1963, 2068, 2116, 2116, 2159], [2161, 2320, 2384, 2384, 2944], [2946, 2959, 2981, 2981, 3189], [3191, 3201, 3233, 3233, 3470], [3471, 3471, 3488, 3488, 3530], [3532, 3553, 3584, 3584, 3819], [3821, 3928, 3988, 3988, 4463], [4465, 4570, 4631, 4631, 5512], [5514, 5535, 5561, 5561, 5683], [5684, 5684, 5712, 5712, 5978], [5979, 5979, 6003, 6003, 6311], [6313, 6313, 6368, 6417, 7688]]}
{"id": "WdVyRd", "name": "Balls on a rope", "author": "xjorma", "description": "Remake of an old Atari ST Demoscene Effect by Elric/Holocaust\nhttps://youtu.be/X3f5e8cIDT8?t=706\nMusic by Jess", "tags": ["demoscene", "amiga", "demo", "ball", "atari", "rope", "reproduction", "cineshader"], "likes": 19, "viewed": 2621, "published": "Public API", "date": "1603513319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by David Gallardo - xjorma/2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\nconst int\tnbBall = 8;\nconst float ballRadius = 0.07;\nconst float maxLateralSpeed = 1.;\nconst float Tau = radians(360.);\nconst float minPhaseSpeed = 2.1;\nconst float maxPhaseSpeed = 3.2;\nconst float sinAmplitude = 1.2;\nconst vec3\tdrawColor = vec3(0.2,0.3,0.4);\n\n// Hash without Sine, https://www.shadertoy.com/view/4djSRW\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nfloat udSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 ba = b-a;\n    vec2 pa = p-a;\n    float h =clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length(pa-h*ba);\n}\n\nfloat triangleSignal(float x, float f)\n{\n    f = 1. / f;\n    return (abs((f * x - 4. * floor(0.25 * f * x)) - 2.) - 1.) / f;\n}\n\nfloat smoothFilter(float d)\n{\n    float v = 2. / iResolution.y;\n    return smoothstep(v, -v, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2\tp = (2. * fragCoord - iResolution.xy) / iResolution.y;\n    float\tratio = iResolution.x / iResolution.y;\n    vec3\tcol = vec3(0);\n    \n    // Compute and draw balls\n    vec2\tballArray[nbBall + 1];\n    for(int i = 0; i < nbBall; ++i)\n    {\n        float LateralSpeed = (hash11(float(i) * 1.2544) - 0.5) * 2. * maxLateralSpeed;\n        float phaseOffset = hash11(float(i) * 1.4482) * Tau;\n        float LateralOffset = hash11(float(i) * 1.9528) * (ratio * 2. - 2. * ballRadius);\n        float phaseSpeed = mix(minPhaseSpeed, maxPhaseSpeed, hash11(float(i) * 1.1273));\n        ballArray[i] = vec2(\ttriangleSignal(LateralOffset + LateralSpeed * iTime, ratio - ballRadius),\n                       \t\t\tsinAmplitude * (abs(sin(phaseOffset + phaseSpeed * iTime)) - 0.5) \n                           );\n        float a = smoothFilter(sdCircle( ballArray[i] - p , ballRadius));\n        col = mix(col, drawColor, a);           \n    }\n    \n    // Sort Ball in X (Lame bubble)\n    for(int i = 0; i < nbBall - 1; ++i)\n    {\n\t    for(int j = 0; j < nbBall - 1 - i; ++j)\n        {\n            if(ballArray[j].x > ballArray[j + 1].x)\n            {\n                // templess swap, not sure it's a good idea, I didn't profile it.\n                ballArray[j] += ballArray[j + 1];\n                ballArray[j + 1] = ballArray[j] - ballArray[j + 1];\n                ballArray[j] -= ballArray[j + 1];\n            }\n        }\n    }\n    \n   \t// Find convex using an algorithm similar to gift wraping\n \tballArray[nbBall] = vec2(ratio, 0);\n    vec2 convexHull[nbBall + 2];\t\t\t// Worst case size\n    int  convexSize = 0;\n    convexHull[convexSize++] = vec2(-ratio, 0);\n\n    int\t  SmallestIndex = 0;\n    for(;;)\n    {\n        float SmallestDir = 1.;\n        bool  found = false;\n        for(int i = SmallestIndex; i < nbBall + 1; ++i)\n        {\n            vec2 dir = normalize(ballArray[i] - convexHull[convexSize - 1]);\n            if(dir.y < SmallestDir)\n            {\n                \n                SmallestDir = dir.y;\n                SmallestIndex = i;\n                found = true;\n            }\n        }\n       \tif(found)\n        {\n \t   \t\tconvexHull[convexSize++] = ballArray[SmallestIndex];\n        }\n        else\n        {\n            break;\n        }\n    }\n      \n        \n    // Draw hull\n    for(int i = 0; i < convexSize - 1; ++i)\n    {\n\t    float a = smoothFilter(udSegment(p, convexHull[i] - vec2(0, ballRadius), convexHull[i + 1] - vec2(0, ballRadius)) - 0.005);\n        col = mix(col, drawColor, a);\n          \n    }\n\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4tjGW3", "previewfilepath": "https://soundcloud.com/david-gallardo-492062428/atari-demo-music-by-jess-overlander", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/david-gallardo-492062428/atari-demo-music-by-jess-overlander", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVyRd.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[374, 434, 457, 457, 542], [544, 623, 658, 658, 686], [688, 688, 740, 740, 863], [865, 865, 905, 905, 991], [993, 993, 1022, 1022, 1091], [1093, 1093, 1150, 1150, 3723]]}
{"id": "WdVyzD", "name": "TAL FRI", "author": "genekeats", "description": "Tal Fri", "tags": ["2d", "text"], "likes": 1, "viewed": 64, "published": "Public", "date": "1602919164", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates: 0 (bottom left) to 1 (upper right)\n    vec2 ouv = fragCoord/iResolution.xy;\n    float r = iResolution.x/iResolution.y;\n    \n    // me grid\n\tfloat g1 = 1./9.;\n    float g2 = 2./9.;\n    float g3 = 3./9.;\n    float g4 = 4./9.;\n    float g5 = 5./9.;\n    float g6 = 6./9.;\n    float g7 = 7./9.;\n    float g8 = 8./9.;\n    float g9 = 9./9.;\n    float a = .205;\n    \n    vec2 uv = ouv;\n    uv.x *= r;\n    uv.x -= g4;\n    \n    // rotating vector over time\n    vec2 q = .5+.5*vec2(cos(iTime),sin(iTime));\n    \n    // color mix\n    vec3 col = mix(vec3(1,1,.3),vec3(.8,.1,0),length(ouv-q)); // smoothstep removed\n    \n    // mask: mult color by qty one minus zero to one using step() to form letters\n    // T\n    col *= 1.-(step(g5, uv.y))*(1.-step(g8, uv.y))*(1.-step(g1, uv.x));\n    col *= 1.-(step(g2, uv.x))*(step(g5, uv.y))*(1.-step(g3, uv.x))*(1.-step(g8, uv.y));\n    // A\n    col *= 1.-(step(g3, uv.x))*(step(g5, uv.y))*(1.-step(g2, uv.x-a*uv.y));\n    col *= 1.-(1.-step(g6, uv.x))*(step(g5, uv.y))*(step(g7, uv.x+a*uv.y));\n    col *= 1.-(step(g3, uv.x))*(step(g6, uv.y))*(1.-step(g6, uv.x+a*uv.y))*(step(g3, uv.x-a*uv.y));\n    // L\n    col *= 1.-(step(g7, uv.x))*(step(g6, uv.y));\n    \n    // gaps\n    col *= 1.-(step(g4, uv.y))*(1.-step(g5, uv.y));\n    col *= 1.-(step(-1., uv.x))*(1.-step(.01, uv.x))*(1.-step(g4, uv.y));\n    col *= 1.-(step(g3, uv.x))*(1.-step(g3+.01, uv.x))*(1.-step(g4, uv.y));\n    \n    // F\n    col *= 1.-(step(g1, uv.x))*(step(g2, uv.y))*(1.-step(g3, uv.x))*(1.-step(g3, uv.y));\n    col *= 1.-(step(g1, uv.x))*(1.-step(g1, uv.y))*(1.-step(g3, uv.x));\n    // R\n    col *= 1.-(step(g4, uv.x))*(1.-step(g4, uv.y))*(1.-step(g3+g2*abs(cos(.1+uv.y*10.)), uv.x));\n    col *= 1.-(step(g5+g1*abs(cos(.1+uv.y*10.)), uv.x))*(1.-step(g6, uv.x))*(1.-step(g4, uv.y));\n    // I\n    col *= 1.-(step(g6, uv.x))*(1.-step(g7, uv.x))*(1.-step(g5, uv.y));\n    col *= 1.-(1.-step(g5, uv.y))*(step(g8, uv.x));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVyzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 129, 2059]]}
{"id": "wdycDm", "name": "october v004", "author": "darkczar", "description": "trippy", "tags": ["trippy"], "likes": 4, "viewed": 172, "published": "Public API", "date": "1602989311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// based on...\n// https://www.shadertoy.com/view/lssfW2\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 p=(2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec2 curve_p = vec2(0,200);\n    float d = 10000.0 + 4200.*sin(iTime)+4200.*cos(iTime);\n    float di = 2.;// +3.2*sin(iTime * .1);\n    for(int i = 0;i<300;i++)\n    {\n        di = float(i)*.3;\n        curve_p.x = .5-.3*sin(.3*iTime)-.05*float(di)*cos(float(di)+.4*iTime); // +.01*float(di)*sin(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*sin(7.0*di+.4*iTime);\n        curve_p.y = .5-.3*cos(.3*iTime)-.05*float(di)*sin(float(di)+.2*iTime); // +.01*float(di)*cos(4.0*di+.2*iTime) + .03*sin(iTime*.1)*float(di)*cos(7.0*di+.4*iTime);\n        d = sin(min(d*1.0, 1.*sin(length(p-curve_p))));\n        //d = length(p-curve_p)/(di+1.0);\n  \n    }\n    float r =.05*d + .05*(.05 - .015*pow(dot(sin(p*p + d*d), log(20.0+2.*curve_p -d)),2.0));\n    float g = .0008 + .005*cos(.001*d*d*d+3.1*length(p)); //+.03*dot(p,curve_p + .0005*vec2(iTime, iTime));\n    float b=2.5*abs(.5+.3*cos(iTime*.8 - 2.5*pow(d,2.0))); // +.01*(dot(p,curve_p - .005*vec2(iTime-200.05, iTime-200.05)+10.0));\n    if (d < 2.2)\n    {\n        b = .0 +.04*(.5+ .5*sin(iTime*.1 + 1.28*dot(p,curve_p)));\n    }\n    float checkers = mod(float(uv.x*uv.x +uv.y*uv.y)+r*r*1200.+b*20., .25);\n    float checkers_02 =mod(float( -.01*curve_p.x*curve_p.y)+g*g*1000.,.25);\n    if (checkers + checkers_02 > .25)\n    {\n        r = 0.06*r;\n        g = 1.2*g;\n        b = 1.2*b;\n    }\n    vec3 col = vec3(r, g, b);\n    float dn = col.x + col.y + col.z;\n    col /= dn;\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdycDm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 58, 115, 165, 1828]]}
{"id": "WdycRc", "name": "AssPimpShiny", "author": "jj99", "description": "for of PimpThatAss - added AO + Spec + Ambient changes", "tags": ["raymarch", "fork"], "likes": 9, "viewed": 276, "published": "Public API", "date": "1603321892", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// copy of the original - https://www.shadertoy.com/view/3ty3Dd\n// +AO++\n// copy of the original - https://www.shadertoy.com/view/3ty3Dd\n// +AO++\n#define AA 2\n\nfloat pi = 3.14159265, tau = 6.2831853;\n\nfloat box (in float x, in float x1, in float x2, in float a, in float b) {\n\treturn tanh(a * (x - x1)) + tanh(-b * (x - x2));\n}\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat ex (in float z, in float z0, in float s) {\n    return exp(-(z - z0) * (z - z0) / s);\n}\n\nfloat r(in float z, in float x) {\n    float s = sin (tau * x), c = cos(tau * x),\n\t\tc2 = cos (pi * x), t4z = tanh(4. * z);\n    return /* body */.4 * (1.0 - .4 * ex(z, .8, .15) +\n\t\ts * s + .6 * ex(z, .8, .25) * c * c + .3 * c) *\n\t\t0.5 * (1. + t4z) + /* legs */ (1. - .2 * ex(z, -1.3, .9)) *\n\t\t0.5 * (1. - t4z) * (.5 * (1. + s * s + .3 * c) *\n\t\t(pow(abs(s), 1.3) + .08 * (1. + t4z) ) ) +\n\t\t/* improve butt */ .13 * box(c2, -.45, .45, 5., 5.) *\n\t\tbox(z, -.5, .2, 4., 2.) - 0.1 * box(c2, -.008, .008, 30., 30.) *\n\t\tbox(z, -.4, .25, 8., 6.) - .05 * pow(abs(sin(pi * x)), 16.) * box(z, -.55, -.35, 8., 18.);\n}\n\n// $1M question: how close are we to ParametricPlot3D[...] surface?\nfloat sd( in vec3 p )\n{\n\t/* shift butt belly */\n\tfloat dx = .1 * exp(-pow((p.z-.8),2.)/.6) - .18 * exp(-pow((p.z -.1),2.)/.4);\n\n    // on the surface, we have:\n    // p.x = r * cos + dx\n\t// p.y = r * sin\n\t\n    float jiggle = p.z*1.75;\n    float jsize = 0.5;\n    if (iMouse.z>0.5)\n    {\n        jiggle+=p.y*.5;\n        jsize+=.175;\n    }\n    \n\tdx *= 1.5+(sin(jiggle+iTime*9.65)*jsize);\n\t\n\tfloat angle = atan(p.y, p.x - dx);\n\tfloat r_expected = r(p.z, angle / tau);\n//\tfloat d1 = (.5 + .5 * smoothstep(.4,1.,p.z)) * (length(vec2(p.y, p.x - dx)) - r_expected);\n\tfloat d1 = (length(vec2(p.y, p.x - dx)) - r_expected)*0.5;\n    \n    p.x -= dx;\n\tfloat d2 = sdSphere(p+vec3(-0.35,0.4,-1.875),0.4);\n\tfloat d3 = sdSphere(p+vec3(-0.35,-0.4,-1.875),0.4);\n    d2 = smin(d2,d3,0.35);\n    return smin(d1,d2,0.07);\n    //return min(d1,min(d2,d3));\n}\n\n\nfloat map( in vec3 pos )\n{\n    return sd (pos.zxy);\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773;\n    const float eps = 0.001;\n    return normalize( e.xyy*map( pos + e.xyy*eps ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx*eps ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy*eps ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx*eps ) );\n}\n\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 2.0, occ = 0.0;\n    for( int i=0; i<5; i++ )\n    {\n        float hr = 0.01 + float(i)*0.5/4.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.7;\n    }\n    return clamp( 1.0 - occ, 0.0, 1.0 );    \n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n     // camera movement\t\n\tfloat an =2.+sin(iTime+2.15)*0.7;\t//0.5*iTime - 0.8;\n    // if (iMouse.z>0.5)\n        //an+=iMouse.x/(iResolution.x*0.25);\n    //an+=3.14;\n    \n\tvec3 ro = vec3( 2.55*sin(an), 0.5, 2.55*cos(an) );\n    vec3 ta = vec3( 0.0, .8, 0.0 );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 tot = vec3(0.0);\n    \n    \n    vec2 p1 = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n    float val = sin(iTime+p1.x*3.0+p1.y*20.0)*(0.8+sin(p1.y*24.4+iTime*3.0)*0.3);\n    val = clamp(pow(abs(val),2.6),0.0,2.0);\n    vec3 bcol = vec3(val*0.6,val*0.1,val*0.9);\n\tbcol *= length(p1*p1*p1);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n        #else    \n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n        #endif\n        \n        vec3 col = bcol;\n        // raymarch\n        if (abs(p.x)<0.8)\n        {\n            // create view ray\n            vec3 rd = normalize( p.x*uu + p.y*vv + 1.8*ww );\n            \n            const float tmax = 5.0;\n            float t = 0.0;\n            for( int i=0; i<200; i++ )\n            {\n                vec3 pos = ro + t*rd;\n                float h = map(pos);\n                if( h<0.0001 || t>tmax ) break;\n                t += h;\n            }\n            // shading/lighting\t\n            if( t<tmax )\n            {\n                vec3 pos = ro + t*rd;\n                vec3 nor = calcNormal(pos);\n\t\t    \n\t\tfloat ao = calcAO(pos,nor);\n\t\t    \n\t\t    vec3 ln = normalize(vec3(1.1,-.52,-.4));\n\t\t    \n\t        float spec = pow(max( dot( reflect(-ln, nor), -rd ), 0.0 ), 20.0);\n\t\t    \n                float dif = clamp( dot(nor,ln), 0.0, 1.0 );\n                float amb = 0.25 + 0.5*dot(nor,vec3(.2,0.2,0.2));\n                col = vec3(0.4,0.05,0.3)*amb + (vec3(1.1,0.6,0.4)*2.0)*dif*ao;\n\t\t    col *= 1.1+spec;\n            }\n        }\n\n        // gamma        \n        //col = sqrt( col );\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n    // gamma        \n    tot = sqrt( tot );\n    \n   \tvec2 qq = fragCoord.xy / iResolution.xy;\n    tot *= 0.5 + 0.5*pow( 16.0*qq.x*qq.y*(1.0-qq.x)*(1.0-qq.y), 0.95 );\n\tfragColor = vec4( tot, 1.0 );\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdycRc.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 201, 275, 275, 327], [328, 328, 363, 363, 389], [390, 390, 431, 431, 524], [526, 526, 574, 574, 618], [620, 620, 653, 653, 1222], [1224, 1292, 1315, 1339, 2125], [2128, 2128, 2154, 2154, 2181], [2183, 2247, 2279, 2279, 2517], [2519, 2519, 2559, 2559, 2818], [2821, 2821, 2878, 2903, 5315]]}
{"id": "wdycRG", "name": "Example 47 - raytrace mandelbrot", "author": "jt", "description": "Simple & inefficient way to raytrace the mandelbrot set.", "tags": ["raytracing", "example", "mandelbrot"], "likes": 1, "viewed": 84, "published": "Public", "date": "1603100533", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415926\n\n#define iterations 16\n\nfloat mandelbrot(vec2 p)\n{\n    vec2 c = 4.0 * p - 1.0;\n    c.x -= 1.0;\n    vec2 z = vec2(0.0, 0.0);\n    \n    float h = 1.0;\n    int i = 0;\n    for(i = 0; i < iterations; i++)\n    {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + c;\n        if(length(z) > 2.0)\n        {\n            h = float(i) / float(iterations);\n            break;\n        }\n    }\n    \n    return h;\n}\n\nvec2 lookup(vec2 p)\n{\n    return (p + vec2(iTime, 0.0));\n}\n\nfloat heightmap(vec2 p)\n{\n    vec2 l = lookup(p);\n    //return 0.5 * (0.5 + 0.5 * sin(l.x * 2.0 * pi) * sin(l.y * 2.0 * pi)); // waves\n    //return 0.5 * (1.0 - abs(sin(l.x * 2.0 * pi)) * abs(sin(l.y * 2.0 * pi))); // waffles\n    //return 0.5 * ((1.0 - abs(sin(l.x * 2.0 * pi))) * (1.0 - abs(sin(l.y * 2.0 * pi)))); // spikes\n    return 0.5 * mandelbrot(fract(l));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 d = vec3(2.0 * fragCoord/iResolution.xy - 1.0, 1.0);\n    \n    fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n    \n    float s = 0.001;\n    s /= abs(d.y); // larger step-size for shallow rays\n    for(vec3 q = vec3(0.0); abs(q.y) < 1.0; q += d * s)\n    {\n        float c = heightmap(q.xz);\n        float h = 1.0 * c - 1.0;\n        if(q.y < h)\n        {\n            float W = heightmap(q.xz + vec2(-1.0,0.0)/iResolution.xy);\n            float O = heightmap(q.xz + vec2(+1.0,0.0)/iResolution.xy);\n            float S = heightmap(q.xz + vec2(0.0,-1.0)/iResolution.xy);\n            float N = heightmap(q.xz + vec2(0.0,+1.0)/iResolution.xy);\n            vec3 n = normalize(vec3(O - W, N - S, 0.01));\n            //fragColor = vec4(c);\n            //fragColor = vec4(n.z);\n            float brightness = dot(n, normalize(vec3(1.0, 0.0, 1.0))); // lighting\n            fragColor = vec4(brightness); \n            break;\n        }\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdycRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[45, 45, 71, 71, 427], [429, 429, 450, 450, 487], [489, 489, 514, 514, 855], [857, 857, 914, 914, 1842]]}
{"id": "WdycRw", "name": "cinetunnel", "author": "tomviolin", "description": "for cineshader\n\n", "tags": ["cineshader"], "likes": 5, "viewed": 5361, "published": "Public API", "date": "1602404835", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 center = iResolution.xy/2.;\n    center.x = center.x + sin(iTime*6.)*iResolution.x*.03;\n    center.y = center.y + cos(iTime*5.4)*iResolution.x*.033;\n    float d = length(vec2(fragCoord.x,fragCoord.y) - center)/iResolution.x;\n    float a = -atan(fragCoord.y-center.y,fragCoord.x-center.x)*6.;\n    float r = (sin(a+3.14159*4./3.+4./d*1.+iTime*6.)*.5+.5)*d*2.;\n    float g  = (sin(a+3.14159*2./3.+4./d*1.+iTime*6.)*.5+.5)*d*2.;\n    float b = (sin(a+4./d*1.+iTime*6.)*.5+.5)*d*2.;\n    float w = (sin(a*4.+3.14159*2./3.+3./d*1.+iTime*6.)*.5+.5)*1.*sin(a*7.);\n    w=w>.6?3.:0.;\n    w=w*d;\n    fragColor = vec4(\n        clamp(w+r,0.,1.),\n        clamp(w+g,0.,1.),\n        clamp(w+b,0.,1.),\n        atan(5.-1./d)/3.14159*2.+4.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdycRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 788]]}
{"id": "wdycRy", "name": "Scrolling Truchet Tiles", "author": "oneshade", "description": "I watched The Art of Code's video explaining truchet tiling and this is what I learned from it.", "tags": ["procedural", "truchet", "tiling", "quad"], "likes": 2, "viewed": 64, "published": "Public", "date": "1603116978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash21(in vec2 id) {\n    vec2 n = id * fract(dot(id, vec2(534.75, 65.54)));\n    return fract(dot(id + n, n));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = ((fragCoord - 0.5 * iResolution.xy) / iResolution.y) * 10.0 + iTime;\n    vec2 cellLocation = floor(uv);\n    vec2 cellLocalUV = fract(uv) - 0.5;\n    cellLocalUV.x *= Hash21(cellLocation) < 0.5 ? -1.0 : 1.0;\n\n    vec2 circleUV = cellLocalUV - (cellLocalUV.x + cellLocalUV.y < 0.0 ? -1.0 : 1.0) * 0.5;\n    float circleDist = length(circleUV) - 0.5;\n    vec3 color = vec3(smoothstep(0.3, 0.0, abs(circleDist)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdycRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 117], [119, 119, 174, 174, 633]]}
{"id": "WdycRz", "name": "More Noise with Smooth", "author": "beherca", "description": "More Noise with Smooth", "tags": ["noise"], "likes": 2, "viewed": 43, "published": "Public", "date": "1602069965", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"ShaderToy Tutorial - Value Noise\" \n// by Martijn Steinrucken aka BigWings/CountFrolic - 2019\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n//\n// This shader is part of a tutorial on YouTube\n// https://youtu.be/zXsWftRdsvU\n\nfloat N21(vec2 p) {\n    return fract(sin(p.x*100.+p.y*6574.)*5647.);\n}\n\nfloat SmoothNoise(vec2 uv) {\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float bl = N21(id);\n    float br = N21(id+vec2(1,0));\n    float b = mix(bl, br, lv.x);\n    \n    float tl = N21(id+vec2(0,1));\n    float tr = N21(id+vec2(1,1));\n    float t = mix(tl, tr, lv.x);\n    \n    return mix(b, t, lv.y);\n}\n\nfloat SmoothNoise2(vec2 uv) {\n    float c = SmoothNoise(uv*4.);\n    \n    // don't make octaves exactly twice as small\n    // this way the pattern will look more random and repeat less\n    c += SmoothNoise(uv*8.2)*.5;\n    c += SmoothNoise(uv*16.7)*.25;\n    c += SmoothNoise(uv*32.4)*.125;\n    c += SmoothNoise(uv*64.5)*.0625;\n    \n    c /= 2.;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv += iTime*.1;\n    \n    float c = SmoothNoise2(uv);\n    \n    vec3 col = vec3(c);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdycRz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 268, 287, 287, 338], [340, 340, 368, 368, 687], [689, 689, 718, 718, 1052], [1054, 1054, 1111, 1111, 1276]]}
{"id": "WdycW1", "name": "Sliced Ring SDF 2D", "author": "jniac", "description": "2d shader for UI widget\nbased on https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nnegative part is not exact, but don't care", "tags": ["2d", "sdf", "ring"], "likes": 3, "viewed": 62, "published": "Public", "date": "1602684780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 uv_cover(in vec2 p, in vec2 rect) {\n    vec2 uv = p / rect.x;\n    uv.y += (1.0 - rect.y / rect.x) / 2.0;\n    return uv;\n}\nvec2 uv_contain(in vec2 p, in vec2 rect) {\n    vec2 uv = p / rect.y;\n    uv.x += (1.0 - rect.x / rect.y) / 2.0;\n    return uv;\n}\n\nconst float PI = 3.141592653589793;\n\nfloat safeAngle01(vec2 p, float offset) {\n    \n    float a = fract(atan(p.y, p.x) / PI * 0.5 + offset);\n    return a < 0.0 ? a + 1.0 : a;\n}\n\nvec2 fromPolar(float angle, float radius) {\n    \n    return vec2(radius * cos(angle), radius * sin(angle));\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdSegment(in vec2 p, in vec2 a, in vec2 b) {\n    \n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nfloat sdSliceRing(vec2 p, float r, float r2, float opening, float openingOffset) {\n\t\n    float angle01 = safeAngle01(p, -openingOffset);\n    \n    if (angle01 > opening) {\n        float compOpening = 1.0 - opening;\n        if (angle01 < opening + compOpening * 0.5) {\n            float a = (opening + openingOffset) * 2.0 * PI;\n\t        return sdSegment(p, fromPolar(a, r - r2), fromPolar(a, r + r2));\n        } else {\n            float a = openingOffset * 2.0 * PI;\n\t        return sdSegment(p, fromPolar(a, r - r2), fromPolar(a, r + r2));\n        }\n    }\n    \n    float d = length(p) - r;\n    d = abs(d) - r2;\n    return d;\n}\n\nvec3 distanceToInigoColor(float d) {\n    vec3 col = vec3(1.0) - sign(d)*vec3(0.1,0.4,0.7);\n\tcol *= 1.0 - exp(-4.0*abs(d));\n\tcol *= 0.8 + 0.2*cos(128.0*abs(d));\n\tcol = mix( col, vec3(1.0), 1.0-smoothstep(0.0,0.015,abs(d)) );\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = uv_contain(fragCoord, iResolution.xy) - 0.5;\n\t\n    float radius = .3 + .1 * sin(iTime);\n    float opening = sin(iTime) * .5 + .5;\n    float offset = fract(iTime * .02);\n    float d = sdSliceRing(p, radius, 0.1, opening, offset);\n    \n\n    fragColor = vec4(distanceToInigoColor(d),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdycW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 126], [127, 127, 169, 169, 255], [294, 294, 335, 335, 433], [435, 435, 478, 478, 544], [546, 625, 675, 675, 799], [801, 801, 883, 883, 1427], [1429, 1429, 1465, 1465, 1670], [1673, 1673, 1730, 1730, 2031]]}
{"id": "wdyczG", "name": "Gradient Flow", "author": "hahnzhu", "description": "random background with noise rotation / mesh warp / wave warp", "tags": ["distortion", "flow"], "likes": 6, "viewed": 238, "published": "Public", "date": "1603182372", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n// Created by inigo quilez - iq/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 hash( vec2 p )\n{\n    p = vec2( dot(p,vec2(2127.1,81.17)), dot(p,vec2(1269.5,283.37)) );\n\treturn fract(sin(p)*43758.5453);\n}\n\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float n = mix( mix( dot( -1.0+2.0*hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                   mix( dot( -1.0+2.0*hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                        dot( -1.0+2.0*hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n\treturn 0.5 + 0.5*n;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n\n    vec2 tuv = uv;\n    tuv -= .5;\n\n    // rotate with Noise\n    float degree = noise(vec2(iTime*.1, tuv.x*tuv.y));\n\n    tuv.y *= 1./ratio;\n    tuv *= Rot(radians((degree-.5)*720.+180.));\n\ttuv.y *= ratio;\n\n    \n    // Wave warp with sin\n    float frequency = 5.;\n    float amplitude = 30.;\n    float speed = iTime * 2.;\n    tuv.x += sin(tuv.y*frequency+speed)/amplitude;\n   \ttuv.y += sin(tuv.x*frequency*1.5+speed)/(amplitude*.5);\n    \n    \n    // draw the image\n    vec3 colorYellow = vec3(.957, .804, .623);\n    vec3 colorDeepBlue = vec3(.192, .384, .933);\n    vec3 layer1 = mix(colorYellow, colorDeepBlue, S(-.3, .2, (tuv*Rot(radians(-5.))).x));\n    \n    vec3 colorRed = vec3(.910, .510, .8);\n    vec3 colorBlue = vec3(0.350, .71, .953);\n    vec3 layer2 = mix(colorRed, colorBlue, S(-.3, .2, (tuv*Rot(radians(-5.))).x));\n    \n    vec3 finalComp = mix(layer1, layer2, S(.5, -.3, tuv.y));\n    \n    vec3 col = finalComp;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyczG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 55, 55, 131], [134, 258, 279, 279, 386], [388, 388, 414, 414, 881], [884, 884, 941, 941, 1989]]}
{"id": "WdyyDR", "name": "Great Ideas in Graphics Demo", "author": "sjobalia", "description": "Demo for Great Ideas in Graphics", "tags": ["demo"], "likes": 1, "viewed": 98, "published": "Public", "date": "1602543341", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nby Uğur Güney. March 8, 2014. \n\nHi! I started learning GLSL a month ago. The speedup gained by using\nGPU to draw real-time graphics amazed me. If you want to learn\nhow to write shaders, this tutorial written by a beginner can be\na starting place for you.\n\nPlease fix my coding errors and grammar errors. :-)\n*/\n\n// choose the tutorial by changing the number and compiling the shader again\n// We're going to look at 4, 7, 9, 11, 12, 19, 20, 24, 26, 27\n#define TUTORIAL 0\n\n/* TUTORIAL LIST\n 1 RGB COLOR MODEL AND COMPONENTS OF VECTORS\n 2 COORDINATE TRANSFORMATION\n 3 VISUALISING THE COORDINATE SYSTEM\n 4 MAKING THE ASPECT RATIO OF THE COORDINATE SYSTEM 1.0\n 5 DISK\n 6 FUNCTION PLOTTING\n 7 COLOR ADDITION AND SUBSTRACTION\n 8 TIME, MOTION AND ANIMATION\n 9 TEXTURES\n10 MOUSE INPUT\n*/\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n\n#if TUTORIAL == 1\n// RGB COLOR MODEL AND COMPONENTS OF VECTORS\n//\n// After initialized, the components of vectors can be reached using\n// the dot \".\" notation.\n//\n// RGB: http://en.wikipedia.org/wiki/RGB_color_model\n// A color is represented by three numbers (here in the range [0.0, 1.0])\n// The model assumes the addition of pure red, green and blue lights\n// of given intensities.\n//\n// If you lack design skills like me, and having hard time\n// in choosing nice looking, coherent set of colors \n// you can use one of these websites to choose color palettes, where\n// you can browse different sets of colors \n// https://kuler.adobe.com/create/color-wheel/\n// http://www.colourlovers.com/palettes\n// http://www.colourlovers.com/colors\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// play with these numbers:\n\tfloat redAmount = 0.6; // amount of redness\n\tfloat greenAmount = 0.2; // amount of greenness\n\tfloat blueAmount = 0.9; // amount of blueness\n\t\n\tvec3 color = vec3(0.0); \n\t// Here we only input a single argument. It is a third way of\n\t// contructing vectors.\n\t// \"vec3(x)\" is equivalent to vec3(x, x, x);\n\t// This vector is initialized as\n\t// color.x = 0.0, color.y = 0.0; color.z = 0.0;\n\tcolor.x = redAmount;\n\tcolor.y = greenAmount;\n\tcolor.z = blueAmount;\n\t\n\tfloat alpha = 1.0;\n\tvec4 pixel = vec4(color, alpha);\t\n\tfragColor = pixel;\n}\n\n\n#elif TUTORIAL == 2\n// COORDINATE TRANSFORMATION\n// \n// Instead of working on screen coordinates, using our own coordinate\n// system is more convenient most of the time.\n//\n// Here we will make and use a new coordinate system \"r\", instead of\n// the absolute screen coordinates \"fragCoord\". In \"r\"\n// the x and y coordinates will go from 0 to 1. For x, 0 is the left\n// side and 1 is the right side. For y, 0 is the bottom side, and 1 is\n// the upper side.\n//\n// Using \"r\" let's divide the screen into 3 parts.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2(fragCoord.x / iResolution.x,\n\t\t\t\t  fragCoord.y / iResolution.y);\n\t// r is a vec2. Its first component is pixel x-coordinate divided by\n\t// the frame width. And second component is the pixel y-coordinate\n\t// divided by the frame height.\n\t//\n\t// For example, on my laptop, the full screen frame size is\n\t// 1440 x 900. Therefore iResolution is (1440.0, 900.0).\n\t// The main function should be run 1440*900=1296000 times to\n\t// generate a frame.\n\t// fragCoord.x will have values between 0 and 1439, and\n\t// fragCoord.y will have values between 0 and 899, whereas\n\t// r.x and r.y will have values between [0,1].\n\t\n\tvec3 color1 = vec3(0.841, 0.582, 0.594);\n\tvec3 color2 = vec3(0.884, 0.850, 0.648);\n\tvec3 color3 = vec3(0.348, 0.555, 0.641);\n\tvec3 pixel;\n\t\n\t// sugar syntax for \"if\" conditional. It says\n\t// \"if the x coordinate of a pixel is greater than the half of\n\t// the width of the screen, then use color1, otherwise use\n\t// color2.\"\n\tif( r.x < 1.0/3.0) {\n\t\tpixel = color1;\n\t} else if( r.x < 2.0/3.0 ) {\n\t\tpixel = color2;\n\t} else {\n\t\tpixel = color3;\n\t}\n\t\t\t\n\t// pixel = ( r.x < 1.0/3.0 ) ? color1 : (r.x<2.0/3.0) ? color2: color3;\n\t// same code, single line.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 3\n// VISUALISING THE COORDINATE SYSTEM\n//\n// Let's use a for loop and horizontal and vertical lines to draw\n// a grid of the coordinate center\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy / iResolution.xy );\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\t// start by setting the background color. If pixel's value\n\t// is not overwritten later, this color will be displayed.\n\tvec3 pixel = backgroundColor;\n\t\n\t// Draw the grid lines\n\t// we used \"const\" because loop variables can only be manipulated\n\t// by constant expressions.\n\tconst float tickWidth = 0.1;\n\tfor(float i=0.0; i<1.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.002) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.002) pixel = gridColor;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.005 ) pixel = axesColor;\n\tif( abs(r.y)<0.006 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n#elif TUTORIAL == 4\n// MAKING THE ASPECT RATIO OF THE COORDINATE SYSTEM 1.0\n//\n// As we have seen from the previous examples, we do get rectangles\n// instead of squares when we plot the coordinate systems.\n// It is because, we assigned same numerical interval, [0,1] to different\n// physical distances. Actually the width of the frame is bigger \n// than of its height.\n// So, to keep the aspect ratio, we should not map the actual distances\n// [0, iResolution.x] and [0, iResolution.y] to the same interval.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = vec2( fragCoord.xy - 0.5*iResolution.xy );\n\tr = 2.0 * r.xy / iResolution.y;\n\t// instead of dividing r.x to iResolution.x and r.y to iResolution.y\n\t// divide both of them to iResolution.y.\n\t// This way r.y will be in [-1.0, 1.0]\n\t// and r.x will depend on the frame size. I guess the non-full screen\n\t// mode rx will be in [-1.78, 1.78], and in full screen mode\n\t// for my laptop, it will be in [-1.6, 1.6] (1440./900.=1.6)\n\t\n\tvec3 backgroundColor = vec3(1.0);\n\tvec3 axesColor = vec3(0.0, 0.0, 1.0);\n\tvec3 gridColor = vec3(0.5);\n\n\tvec3 pixel = backgroundColor;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.004) pixel = gridColor;\n\t\tif(abs(r.y - i)<0.004) pixel = gridColor;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesColor;\n\tif( abs(r.y)<0.007 ) pixel = axesColor;\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 5\n// DISK\n//\n// Let's draw disks\n//\n// So, in GLSL we don't give a command of \"draw this disk here with that\n// color\". Instead we use an indirect command such as \"if the pixel \n// coordinate is inside this disk, put that color for the pixel\"\n// The indirect commands are a bit counter intuitive until you\n// get used to that way of thinking.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 colBlue = vec3(0.216, 0.471, 0.698);\n\tvec3 colRed = vec3(1.00, 0.329, 0.298);\n\tvec3 colYellow = vec3(0.867, 0.910, 0.247);\n\n\tvec3 pixel = bgCol;\n\t\n\t// To draw a shape we should know the analytic geometrical\n\t// expression of that shape.\n\t// A circle is the set of points that has the same distance from\n\t// it its center. The distance is called radius.\n\t// The distance from the coordinate center is sqrt(x*x + y*y)\n\t// Fix the distance as the radius will give the formula for\n\t// a circle at the coordinate center\n\t// sqrt(x*x + y*y) = radius\n\t// The points inside the circle, the disk, is given as\n\t// sqrt(x*x + y*y) < radius\n\t// Squaring both sides will give\n\t// x*x + y*y < radius*radius\n\tfloat radius = 0.8;\n\tif( r.x*r.x + r.y*r.y < radius*radius ) {\n\t\tpixel = colBlue;\n\t}\n\t\n\t// There is a shorthand expression for sqrt(v.x*v.x + v.y*v.y)\n\t// of a given vector \"v\", which is \"length(v)\"\n\tif( length(r) < 0.3) {\n\t\tpixel = colYellow;\n\t}\n\t\n\t// draw a disk of which center is not at (0,0).\n\t// Say the center is at c: (c.x, c.y). \n\t// The distance of any point r: (r.x, r.y) to c is \n\t// sqrt((r.x-c.x)^2+(r.y-c.y)^2)\n\t// define a distance vector d: (r.x - c.x, r.y - c.y)\n\t// in GLSL d can be calculated \"d = r - c\".\n\t// Just as in division, substraction of two vectors is done\n\t// component by component.\n\t// Then, length(d) means sqrt(d.x^2+d.y^2)\n\t// which is the distance formula we are looking for.\n\tvec2 center = vec2(0.9, -0.4);\n\tvec2 d = r - center;\n\tif( length(d) < 0.6) {\n\t\tpixel = colRed;\n\t}\n\t// This shifting of the center of the shape works for any\n\t// kind of shape. If you have a formula in terms of r\n\t// f(r) = 0, then f(r-c)=0 expresses the same geometric shape\n\t// but its coordinate is shifted by c.\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// Note how the latest disk is shown and previous ones are left\n// behind it. It is because the last if condition changes the pixel\n// value at the end.\n// If the coordinates of pixel fits multiple if conditions, the last\n// manipulation will remain and fragColor is set to that one.\n\n#elif TUTORIAL == 6\n// FUNCTION PLOTTING\n//\n// It is always useful to see the plots of functions on cartesian\n// coordinate system, to understand what they are doing precisely\n//\n// Let's plot some 1D functions!\n// \n// If y value is a function f of x value, the expression of their\n// relation is: y = f(x)\n// in other words, the plot of a function is all points\n// that satisfy the expression: y-f(x)=0\n// this set has 0 thickness, and can't be seen.\n// Instead use the set of (x,y) that satisfy: -d < y-f(x) < d\n// in other words abs(y-f(x)) < d\n// where d is the thickness. (the thickness in in y direction)\n// Because of the properties of absolute function, the condition\n// abs(y-f(x)) < d is equivalent to the condition:\n// abs(f(x) - y) < d\n// We'll use this last one for function plotting. (in the previous one\n// we have to negate the function that we want to plot)\nfloat linearstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\treturn clamp(t, 0.0, 1.0);\n}\nfloat smootherstep(float edge0, float edge1, float x) {\n\tfloat t = (x - edge0)/(edge1 - edge0);\n\tfloat t1 = t*t*t*(t*(t*6. - 15.) + 10.);\n\treturn clamp(t1, 0.0, 1.0);\n}\n\nvoid plot(vec2 r, float y, float lineThickness, vec3 color, inout vec3 pixel) {\n\tif( abs(y - r.y) < lineThickness ) pixel = color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 r = 2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\t\n\tvec3 bgCol = vec3(1.0);\n\tvec3 axesCol = vec3(0.0, 0.0, 1.0);\n\tvec3 gridCol = vec3(0.5);\n\tvec3 col1 = vec3(0.841, 0.582, 0.594);\n\tvec3 col2 = vec3(0.884, 0.850, 0.648);\n\tvec3 col3 = vec3(0.348, 0.555, 0.641);\t\n\n\tvec3 pixel = bgCol;\n\t\n\t// Draw grid lines\n\tconst float tickWidth = 0.1;\n\tfor(float i=-2.0; i<2.0; i+=tickWidth) {\n\t\t// \"i\" is the line coordinate.\n\t\tif(abs(r.x - i)<0.004) pixel = gridCol;\n\t\tif(abs(r.y - i)<0.004) pixel = gridCol;\n\t}\n\t// Draw the axes\n\tif( abs(r.x)<0.006 ) pixel = axesCol;\n\tif( abs(r.y)<0.007 ) pixel = axesCol;\n\t\n\t// Draw functions\n\tfloat x = r.x;\n\tfloat y = r.y;\n\t// pink functions\n\t// y = 2*x + 5\n\tif( abs(2.*x + .5 - y) < 0.02 ) pixel = col1;\n\t// y = x^2 - .2\n\tif( abs(r.x*r.x-0.2 - y) < 0.01 ) pixel = col1;\n\t// y = sin(PI x)\n\tif( abs(sin(PI*r.x) - y) < 0.02 ) pixel = col1;\n\t\n\t// blue functions, the step function variations\n\t// (functions are scaled and translated vertically)\n\tif( abs(0.25*step(0.0, x)+0.6 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*linearstep(-0.5, 0.5, x)+0.1 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smoothstep(-0.5, 0.5, x)-0.4 - y) < 0.01 ) pixel = col3;\n\tif( abs(0.25*smootherstep(-0.5, 0.5, x)-0.9 - y) < 0.01 ) pixel = col3;\n\t\n\t// yellow functions\n\t// have a function that plots functions :-)\n\tplot(r, 0.5*clamp(sin(TWOPI*x), 0.0, 1.0)-0.7, 0.015, col2, pixel);\n\t// bell curve around -0.5\n\tplot(r, 0.6*exp(-10.0*(x+0.8)*(x+0.8)) - 0.1, 0.015, col2, pixel);\n\t\n\tfragColor = vec4(pixel, 1.0);\n}\n// in the future we can use this framework to see the plot of functions\n// and design and find functions for our liking\n// Actually using Mathematica, Matlab, matplotlib etc. to plot functions\n// is much more practical. But they need a translation of functions \n// from GLSL to their language. Here we can plot the native implementations\n// of GLSL functions.\n\n\n#elif TUTORIAL == 7\n// COLOR ADDITION AND SUBSTRACTION\n//\n// How to draw a shape on top of another, and how will the layers\n// below, affect the higher layers?\n//\n// In the previous shape drawing functions, we set the pixel\n// value from the function. This time the shape function will\n// just return a float value between 0.0 and 1.0 to indice the\n// shape area. Later that value can be multiplied with some color\n// and used in determining the final pixel color.\n\n// A function that returns the 1.0 inside the disk area\n// returns 0.0 outside the disk area\n// and has a smooth transition at the radius\nfloat disk(vec2 r, vec2 center, float radius) {\n\tfloat distanceFromCenter = length(r-center);\n\tfloat outsideOfDisk = smoothstep( radius-0.005, radius+0.005, distanceFromCenter);\n\tfloat insideOfDisk = 1.0 - outsideOfDisk;\n\treturn insideOfDisk;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 black = vec3(0.0);\n\tvec3 white = vec3(1.0);\n\tvec3 gray = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // red\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // yellow\n\t\n\tvec3 ret;\n\tfloat d;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\t// opaque layers on top of each other\n\t\tret = gray;\n\t\t// assign a gray value to the pixel first\n\t\td = disk(r, vec2(-1.1,0.3), 0.4);\n\t\tret = mix(ret, col1, d); // mix the previous color value with\n\t\t                         // the new color value according to\n\t\t                         // the shape area function.\n\t\t                         // at this line, previous color is gray.\n\t\td = disk(r, vec2(-1.3,0.0), 0.4);\n\t\tret = mix(ret, col2, d);\n\t\td = disk(r, vec2(-1.05,-0.3), 0.4); \n\t\tret = mix(ret, col3, d); // here, previous color can be gray,\n\t\t                         // blue or pink.\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\t// Color addition\n\t\t// This is how lights of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Additive_color\n\t\tret = black; // start with black pixels\n\t\tret += disk(r, vec2(0.1,0.3), 0.4)*col1; // add the new color\n\t\t                                         // to the previous color\n\t\tret += disk(r, vec2(-.1,0.0), 0.4)*col2;\n\t\tret += disk(r, vec2(.15,-0.3), 0.4)*col3;\n\t\t// when all components of \"ret\" becomes equal or higher than 1.0\n\t\t// it becomes white.\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\t// Color substraction\n\t\t// This is how dye of different colors add up\n\t\t// http://en.wikipedia.org/wiki/Subtractive_color\n\t\tret = white; // start with white\n\t\tret -= disk(r, vec2(1.1,0.3), 0.4)*col1;\n\t\tret -= disk(r, vec2(1.05,0.0), 0.4)* col2;\n\t\tret -= disk(r, vec2(1.35,-0.25), 0.4)* col3;\t\t\t\n\t\t// when all components of \"ret\" becomes equals or smaller than 0.0\n\t\t// it becomes black.\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 8\n// TIME, MOTION AND ANIMATION\n//\n// One of the inputs that a shader gets can be the time.\n// In ShaderToy, \"iTime\" variable holds the value of the\n// time in seconds since the shader is started.\n//\n// Let's change some variables in time!\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.005, radius+0.005, length(r-center));\n}\n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\t\n\tif(p.x < 1./5.) { // Part I\n\t\tvec2 q = r + vec2(xMax*4./5.,0.);\n\t\tret = vec3(0.2);\n\t\t// y coordinate depends on time\n\t\tfloat y = iTime;\n\t\t// mod constraints y to be between 0.0 and 2.0,\n\t\t// and y jumps from 2.0 to 0.0\n\t\t// substracting -1.0 makes why jump from 1.0 to -1.0\n\t\ty = mod(y, 2.0) - 1.0;\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), 0.1) );\n\t} \n\telse if(p.x < 2./5.) { // Part II\n\t\tvec2 q = r + vec2(xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\t// oscillation\n\t\tfloat amplitude = 0.8;\n\t\t// y coordinate oscillates with a period of 0.5 seconds\n\t\tfloat y = 0.8*sin(0.5*iTime*TWOPI);\n\t\t// radius oscillates too\n\t\tfloat radius = 0.15 + 0.05*sin(iTime*8.0);\n\t\tret = mix(ret, col1, disk(q, vec2(0.0, y), radius) );\t\t\n\t} \n\telse if(p.x < 3./5.) { // Part III\n\t\tvec2 q = r + vec2(xMax*0./5.,0.);\n\t\tret = vec3(0.4);\n\t\t// booth coordinates oscillates\n\t\tfloat x = 0.2*cos(iTime*5.0);\n\t\t// but they have a phase difference of PI/2\n\t\tfloat y = 0.3*cos(iTime*5.0 + PI/2.0);\n\t\tfloat radius = 0.2 + 0.1*sin(iTime*2.0);\n\t\t// make the color mixture time dependent\n\t\tvec3 color = mix(col1, col2, sin(iTime)*0.5+0.5);\n\t\tret = mix(ret, color, rect(q, vec2(x-0.1, y-0.1), vec2(x+0.1, y+0.1)) );\t\t\n\t\t// try different phases, different amplitudes and different frequencies\n\t\t// for x and y coordinates\n\t}\n\telse if(p.x < 4./5.) { // Part IV\n\t\tvec2 q = r + vec2(-xMax*2./5.,0.);\n\t\tret = vec3(0.3);\n\t\tfor(float i=-1.0; i<1.0; i+= 0.2) {\n\t\t\tfloat x = 0.2*cos(iTime*5.0 + i*PI);\n\t\t\t// y coordinate is the loop value\n\t\t\tfloat y = i;\n\t\t\tvec2 s = q - vec2(x, y);\n\t\t\t// each box has a different phase\n\t\t\tfloat angle = iTime*3. + i;\n\t\t\tmat2 rot = mat2(cos(angle), -sin(angle), sin(angle),  cos(angle));\n\t\t\ts = rot*s;\n\t\t\tret = mix(ret, col1, rect(s, vec2(-0.06, -0.06), vec2(0.06, 0.06)) );\t\t\t\n\t\t}\n\t}\n\telse if(p.x < 5./5.) { // Part V\n\t\tvec2 q = r + vec2(-xMax*4./5., 0.);\n\t\tret = vec3(0.2);\n\t\t// let stop and move again periodically\n\t\tfloat speed = 2.0;\n\t\tfloat t = iTime*speed;\n\t\tfloat stopEveryAngle = PI/2.0;\n\t\tfloat stopRatio = 0.5;\n\t\tfloat t1 = (floor(t) + smoothstep(0.0, 1.0-stopRatio, fract(t)) )*stopEveryAngle;\n\t\t\n\t\tfloat x = -0.2*cos(t1);\n\t\tfloat y = 0.3*sin(t1);\n\t\tfloat dx = 0.1 + 0.03*sin(t*10.0);\n\t\tfloat dy = 0.1 + 0.03*sin(t*10.0+PI);\n\t\tret = mix(ret, col1, rect(q, vec2(x-dx, y-dy), vec2(x+dx, y+dy)) );\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n#elif TUTORIAL == 9\n// TEXTURES\n//\n// ShaderToy can use upto four textures. \n\nfloat rect(vec2 r, vec2 bottomLeft, vec2 topRight) {\n\tfloat ret;\n\tfloat d = 0.005;\n\tret = smoothstep(bottomLeft.x-d, bottomLeft.x+d, r.x);\n\tret *= smoothstep(bottomLeft.y-d, bottomLeft.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.y-d, topRight.y+d, r.y);\n\tret *= 1.0 - smoothstep(topRight.x-d, topRight.x+d, r.x);\n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\t\n\t\n\tvec3 bgCol = vec3(0.3);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret;\n\t\n\tif(p.x < 1./3.) { // Part I\n\t\tret = texture(iChannel1, p).xyz;\n\t} \n\telse if(p.x < 2./3.) { // Part II\n\t\tret = texture(iChannel1, 4.*p+vec2(0.,iTime)).xyz;\n\t} \n\telse if(p.x < 3./3.) { // Part III\n\t\tr = r - vec2(xMax*2./3., 0.);\n\t\tfloat angle = iTime;\n\t\tmat2 rotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tvec2 q = rotMat*r;\n\t\tvec3 texA = texture(iChannel1, q).xyz;\n\t\tvec3 texB = texture(iChannel2, q).xyz;\n\t\t\n\t\tangle = -iTime;\n\t\trotMat = mat2(cos(angle), -sin(angle),\n        \t               sin(angle),  cos(angle));\n\t\tq = rotMat*r;\t\t\n\t\tret = mix(texA, texB, rect(q, vec2(-0.3, -0.3), vec2(.3, .3)) );\n\t\t\n\t}\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n#elif TUTORIAL == 10\n// MOUSE INPUT\n//\n// ShaderToy gives the mouse cursor coordinates and button clicks\n// as an input via the iMouse vec4.\n//\n// Let's write a shader with basic Mouse functionality.\n// When clicked on the frame, the little disk will follow the\n// cursor. The x coordinate of the cursor changes the background color.\n// And if the cursor is inside the bigger disk, it'll color will change.\n\n\nfloat disk(vec2 r, vec2 center, float radius) {\n\treturn 1.0 - smoothstep( radius-0.5, radius+0.5, length(r-center));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = vec2(fragCoord.xy / iResolution.xy);\n\tvec2 r =  2.0*vec2(fragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n\tfloat xMax = iResolution.x/iResolution.y;\n\t\n\t// background color depends on the x coordinate of the cursor\n\tvec3 bgCol = vec3(iMouse.x / iResolution.x);\n\tvec3 col1 = vec3(0.216, 0.471, 0.698); // blue\n\tvec3 col2 = vec3(1.00, 0.329, 0.298); // yellow\n\tvec3 col3 = vec3(0.867, 0.910, 0.247); // red\n\t\n\tvec3 ret = bgCol;\n\t\n\tvec2 center;\n\t// draw the big yellow disk\n\tcenter = vec2(100., iResolution.y/2.);\n\tfloat radius = 60.;\n\t// if the cursor coordinates is inside the disk\n\tif( length(iMouse.xy-center)>radius ) {\n\t\t// use color3\n\t\tret = mix(ret, col3, disk(fragCoord.xy, center, radius));\n\t}\n\telse {\n\t\t// else use color2\n\t\tret = mix(ret, col2, disk(fragCoord.xy, center, radius));\n\t}\t\n\t\n\t// draw the small blue disk at the cursor\n\tcenter = iMouse.xy;\n\tret = mix(ret, col1, disk(fragCoord.xy, center, 20.));\n\t\n\tvec3 pixel = ret;\n\tfragColor = vec4(pixel, 1.0);\n}\n\n\n\n/* End of tutorials */\n\n#elif TUTORIAL == 0\n// WELCOME SCREEN\nfloat square(vec2 r, vec2 bottomLeft, float side) {\n\tvec2 p = r - bottomLeft;\n\treturn ( p.x > 0.0 && p.x < side && p.y>0.0 && p.y < side ) ? 1.0 : 0.0;\n}\n\nfloat character(vec2 r, vec2 bottomLeft, float charCode, float squareSide) {\n\tvec2 p = r - bottomLeft;\n\tfloat ret = 0.0;\n\tfloat num, quotient, remainder, divider;\n\tfloat x, y;\t\n\tnum = charCode;\n\tfor(int i=0; i<20; i++) {\n\t\tfloat boxNo = float(19-i);\n\t\tdivider = pow(2., boxNo);\n\t\tquotient = floor(num / divider);\n\t\tremainder = num - quotient*divider;\n\t\tnum = remainder;\n\t\t\n\t\ty = floor(boxNo/4.0); \n\t\tx = boxNo - y*4.0;\n\t\tif(quotient == 1.) {\n\t\t\tret += square( p, squareSide*vec2(x, y), squareSide );\n\t\t}\n\t}\n\treturn ret;\n}\n\nmat2 rot(float th) { return mat2(cos(th), -sin(th), sin(th), cos(th)); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat G = 990623.; // compressed characters :-)\n\tfloat L = 69919.;\n\tfloat S = 991119.;\n\t\n\tfloat t = iTime;\n\n\tvec2 r = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\t//vec2 rL = rot(t)*r+0.0001*t;\n\t//vec2 rL = r+vec2(cos(t*0.02),sin(t*0.02))*t*0.05;\n\tfloat c = 0.05;//+0.03*sin(2.5*t);\n\tvec2 pL = (mod(r+vec2(cos(0.3*t),sin(0.3*t)), 2.0*c)-c)/c;\n\tfloat circ = 1.0-smoothstep(0.75, 0.8, length(pL));\n\tvec2 rG = rot(2.*3.1415*smoothstep(0.,1.,mod(1.5*t,4.0)))*r;\n\tvec2 rStripes = rot(0.2)*r;\n\t\t\t\t\n\tfloat xMax = 0.5*iResolution.x/iResolution.y;\n\tfloat letterWidth = 2.0*xMax*0.9/4.0;\n\tfloat side = letterWidth/4.;\n\tfloat space = 2.0*xMax*0.1/5.0;\n\t\n\tr += 0.001; // to get rid off the y=0 horizontal blue line.\n\tfloat maskGS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskG = character(rG, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*0.0, G, side);\n\tfloat maskL1 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*1.0, L, side);\n\tfloat maskSS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0, S, side);\n\tfloat maskS = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*2.0 + vec2(0.01*sin(2.1*t),0.012*cos(t)), S, side);\n\tfloat maskL2 = character(r, vec2(-xMax+space, -2.5*side)+vec2(letterWidth+space, 0.0)*3.0, L, side);\n\tfloat maskStripes = step(0.25, mod(rStripes.x - 0.5*t, 0.5));\n\t\n\tfloat i255 = 0.00392156862;\n\tvec3 blue = vec3(43., 172., 181.)*i255;\n\tvec3 pink = vec3(232., 77., 91.)*i255;\n\tvec3 dark = vec3(59., 59., 59.)*i255;\n\tvec3 light = vec3(245., 236., 217.)*i255;\n\tvec3 green = vec3(180., 204., 18.)*i255;\n\n\tvec3 pixel = blue;\n\tpixel = mix(pixel, light, maskGS);\n\tpixel = mix(pixel, light, maskSS);\n\tpixel -= 0.1*maskStripes;\t\n\tpixel = mix(pixel, green, maskG);\n\tpixel = mix(pixel, pink, maskL1*circ);\n\tpixel = mix(pixel, green, maskS);\n\tpixel = mix(pixel, pink, maskL2*(1.-circ));\n\t\n\tfloat dirt = pow(texture(iChannel0, 4.0*r).x, 4.0);\n\tpixel -= (0.2*dirt - 0.1)*(maskG+maskS); // dirt\n\tpixel -= smoothstep(0.45, 2.5, length(r));\n\tfragColor = vec4(pixel, 1.0);\n}\n#endif\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyyDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": []}
{"id": "WdyyR1", "name": "SoundEclipse MIC", "author": "FlavioMoreir4", "description": "a twist on DuckMonster's SoundEclipse (https://www.shadertoy.com/view/4tGXzt), adding some rotation.\nIt looks better as a visualization in virtualdj with the rotation and beatmove.", "tags": ["visualization", "mic", "virtualdj"], "likes": 5, "viewed": 319, "published": "Public API", "date": "1602178535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"SoundEclipse rpm\" by sclavel. https://shadertoy.com/view/ls3BDH\n// 2020-10-08 17:32:10\n\n// credit: https://www.shadertoy.com/view/4tGXzt\n\n#define BEATMOVE 1\n\nconst float FREQ_RANGE = 64.0;\nconst float PI = 3.1415;\nconst float RADIUS = 0.6;\nconst float BRIGHTNESS = 0.2;\nconst float SPEED = 0.5;\n\n//convert HSV to RGB\nvec3 hsv2rgb(vec3 c){\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat luma(vec3 color) {\n  return dot(color, vec3(0.299, 0.587, 0.114));\n}\n\nfloat getfrequency(float x) {\n\treturn texture(iChannel0, vec2(floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE, 0.25)).x + 0.06;\n}\n\nfloat getfrequency_smooth(float x) {\n\tfloat index = floor(x * FREQ_RANGE) / FREQ_RANGE;\n    float next = floor(x * FREQ_RANGE + 1.0) / FREQ_RANGE;\n\treturn mix(getfrequency(index), getfrequency(next), smoothstep(0.0, 1.0, fract(x * FREQ_RANGE)));\n}\n\nfloat getfrequency_blend(float x) {\n    return mix(getfrequency(x), getfrequency_smooth(x), 0.5);\n}\n\nvec3 doHalo(vec2 fragment, float radius) {\n\tfloat dist = length(fragment);\n\tfloat ring = 1.0 / abs(dist - radius);\n\t\n\tfloat b = dist < radius ? BRIGHTNESS * 0.3 : BRIGHTNESS;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat angle = atan(fragment.x, fragment.y);\n\tcol += hsv2rgb( vec3( ( angle + iTime * 0.25 ) / (PI * 2.0), 1.0, 1.0 ) ) * ring * b;\n\t\n\tfloat frequency = max(getfrequency_blend(abs(angle / PI)) - 0.02, 0.0);\n\tcol *= frequency;\n\t\n\t// Black halo\n\tcol *= smoothstep(radius * 0.5, radius, dist);\n\t\n\treturn col;\n}\n\nvec3 doLine(vec2 fragment, float radius, float x) {\n\tvec3 col = hsv2rgb(vec3(x * 0.23 + iTime * 0.12, 1.0, 1.0));\n\t\n\tfloat freq = abs(fragment.x * 0.5);\n\t\n\tcol *= (1.0 / abs(fragment.y)) * BRIGHTNESS * getfrequency(freq);\t\n\tcol = col * smoothstep(radius, radius * 1.8, abs(fragment.x));\n\t\n\treturn col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 fragPos = fragCoord / iResolution.xy;\n\tfragPos = (fragPos - 0.5) * 2.0;\n    fragPos.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 color = vec3(0.0134, 0.052, 0.1);\n\tcolor += doHalo(fragPos, RADIUS);\n\n    float c = cos(iTime * SPEED);\n    float s = sin(iTime * SPEED);\n    vec2 rot = mat2(c,s,-s,c) * fragPos;\n\tcolor += doLine(rot, RADIUS, rot.x);\n\t\n\tcolor += max(luma(color) - 1.0, 0.0);\n    \n\tfragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyyR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[308, 329, 350, 350, 519], [521, 521, 545, 545, 595], [597, 597, 626, 626, 719], [721, 721, 757, 757, 968], [970, 970, 1005, 1005, 1069], [1071, 1071, 1113, 1113, 1580], [1582, 1582, 1633, 1633, 1885], [1888, 1888, 1945, 1945, 2378]]}
{"id": "WdyyRK", "name": "Hexagonal Tiling on GlassSphere", "author": "shadermonkey", "description": "It was just some random shader when I was testing my raytracing spherical glass, and adding hexagonal tiling background, but it looks quite cool!", "tags": ["raytracing", "light", "sphere", "abstract", "glass", "hexagon"], "likes": 4, "viewed": 85, "published": "Public", "date": "1603186487", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ng 1.5\n#define PI 3.141529\nstruct Ray{\n    vec3 o;\n    vec3 d;\n    float i;\n};\n    \nRay GetRay(vec2 uv, vec3 camPos, vec3 dir, float zoom){\n    Ray r;\n    r.o = camPos;\n    vec3 f = normalize(dir);\n    vec3 right = cross(vec3(.0,1.,.0), f);\n    vec3 u = cross(f,right);\n    \n    vec3 c = r.o + f*zoom;\n    vec3 i = c + uv.x *right + uv.y *u;\n    r.d = normalize(i -r.o);\n    r.i = 1.;\n    return r;\n}\nmat3 Rotate(vec3 u, float t){\n    float a = 1.-cos(t);\n    return mat3(cos(t) + u.x*u.x*a, u.x*u.y*a - u.z*sin(t), u.x*u.z*a + u.y*sin(t),\n                u.y*u.x*a + u.z*sin(t), cos(t)+u.y*u.y*a, u.y*u.z*a - u.x*sin(t),\n                u.z*u.x*a - u.y*sin(t), u.z*u.y*a+u.x*sin(t), cos(t) + u.z*u.z*a);\n}\nvec3 ClosestPoint(Ray r, vec3 p) {\n    // returns the closest point on ray r to point p\n    return r.o + max(0., dot(p-r.o, r.d))*r.d;\n}\n\nfloat DistRay(Ray r, vec3 p) {\n\treturn length(p-ClosestPoint(r, p));\n}\nfloat GetRefractedAngle(float ni, float thetai, float nf){\n    return asin(ni/nf*sin(thetai));\n}\n\nvec2 Root(float a, float b, float c){\n    float x1 = -b;\n    float x2 = pow(pow(b,2.)-4.*a*c,.5);\n    return vec2((x1+x2)/(2.*a), (x1-x2)/(2.*a));\n}\n\n//Random with iMouse.x as parameter\nfloat Random(float s){ //[0,1]\n    return fract(cos((iMouse.x +.2)*s)*73.17);\n}\n\nRay SphereRefract(Ray ray, vec3 p, float r){\n   \tfloat d = DistRay(ray, p);\n    //return ray;\n    if(d < r){\n        float ai = asin(d/r);\n        float ar = GetRefractedAngle(1., ai, ng);\n        float t = Root(pow(length(ray.d),2.), 2.*(dot(ray.o,ray.d) - dot(ray.d, p)), pow(length(ray.o - p),2.) - pow(r,2.)).y;\n        vec3 pi = ray.o + t * ray.d;\n        vec3 ni = normalize(pi - p);\n        vec3 rdir = ray.d*Rotate(normalize(-cross(ray.d,ni)), ai-ar);\n    \tfloat d2 = 2.*r*cos(ar);\n        vec3 pf = rdir * d2 + pi;\n        vec3 nf = normalize(pf - p);\n        vec3 rdir2 = rdir*Rotate(normalize(-cross(rdir, nf)), ai - ar);\n        Ray ray2;\n        ray2.d = rdir2;\n        ray2.o = pf + rdir2*(t + d2);\n        ray2.i = pow((r-d)/r*2.,1.);\n        return ray2;\n    } else return ray;\n}\n\nfloat S2(float d, float w, float v){\n    return smoothstep(d+w/2., d - w/2., v) * smoothstep(d-w/2., d+w/2.,v);\n}\n\nvec3 DrawBG(Ray ray, float z, float r){\n    float dz = (z - ray.o.z);\n    float dx = ray.d.x/ray.d.z*dz;\n    float dy = ray.d.y/ray.d.z*dz;\n    vec2 uv = vec2(ray.o.x + dx , ray.o.y + dy);\n    uv.y+= iTime;\n    \n    //tiling 1\n    vec2[2] p;\n    float d1 = r*(1.+cos(PI/3.));\n    float nx = floor((uv.x + d1)/(2.*d1));\n    float d2 = r*sin(PI/3.);\n    float ny = floor((uv.y + d2)/(2.*d2));\n    p[0].x = nx*2.*d1;\n    p[0].y = ny*2.*d2;\n    \n    //tiling 2\n    float nx2 = floor(uv.x/(2.*d1));\n    float ny2 = floor(uv.y/(2.*d2));\n    p[1].x = nx2*2.*d1 + d1;\n    p[1].y = ny2*2.*d2 + d2;\n    vec3 col = vec3(0.);\n    \n    for(int i = 0; i < 2; i++){\n        vec2 dv = uv-p[i];//delta vector\n        float l = length(dv);//delta length\n        float a = mod(abs(atan(dv.y/dv.x)),PI/3.);\n        float hl = r*sin(PI/3.)/sin(PI*2./3. - a);//hexagonal length\n        vec3 color1 = vec3(sin(abs(uv.xy)),cos(uv.y))*2.;\n        col += S2(hl, .15,l)*color1;\n    }\n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.);\n    vec2 m = iMouse.xy/iResolution.xy;\n    float d= 10.;\n    float r = 1.;\n    float dt = 2.*r*sin(PI/3.)/d;\n    float dp = PI/3.;\n    vec3 o = vec3(0.);\n\n    Ray ray = GetRay(uv, o, vec3(0.,0.,1.), 1.);\n    ray = SphereRefract(ray, vec3(0.,.0,1.5), .5);\n    col += DrawBG(ray, d, 1.)*ray.i;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyyRK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 147, 147, 408], [409, 409, 438, 438, 714], [715, 715, 749, 802, 851], [853, 853, 883, 883, 923], [924, 924, 982, 982, 1020], [1022, 1022, 1059, 1059, 1170], [1172, 1208, 1230, 1238, 1287], [1289, 1289, 1333, 1333, 2084], [2086, 2086, 2122, 2122, 2199], [2201, 2201, 2240, 2240, 3175], [3178, 3178, 3235, 3235, 3687]]}
{"id": "wdyyRR", "name": "multiplicative vs additive noise", "author": "FabriceNeyret2", "description": "Left: multiplicative noise.   Right: additive noise without 1/2^i scaling.\nCould get ~= look, but multiplicative ~guaranties > 0 and average=1\n\nAbout multiplicative noise: [url]/view/Xs23D3[/url]  , [url]/view/XssBWj[/url] , [url]/view/Ms2GDc[/url]", "tags": ["procedural", "noise"], "likes": 4, "viewed": 232, "published": "Public API", "date": "1602086176", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define hash(p)  fract(sin(dot(p, vec3(12.9898, 78.233, 311.7))) * 43758.5453) // https://www.shadertoy.com/view/llySRh\n#define hash3(p) fract(sin((p)*mat3(127.1,311.7, 74.7,  269.5,183.3,246.1,  113.5,271.9,124.6))*43758.5453123)\n\n//#define T(d)   texture(iChannel0, (i+d+.5)/32. ).x       // noise texture\n//#define T(d)   hash(i+d)                                 // value noise\n  #define T(d) ( .5+ .7*dot( d-F ,  2.*hash3(i+d)-1. ) )   // gradient noise\n\nfloat noise(vec3 x) {  \n    vec3 i = floor(x), \n         F = fract(x), e = vec3(1,0,0),\n         f = smoothstep(0.,1.,F );\n    vec4 T = mix ( vec4(T(e.zzz),T(e.zxz), T(e.zzx), T(e.zxx) ),\n                   vec4(T(e.xzz),T(e.xxz), T(e.xzx), T(e.xxx) ),\n                   f.x );\n    vec2 v = mix( T.xz, T.yw, f.y);\n    return mix(v.x,v.y,f.z);\n        }\n\nfloat add_noise(vec3 x) {  // --- regular Perlin noise\n    float n = noise(x)/2.;  x *= 2.1; // return n*2.;\n         n += noise(x)/4.;  x *= 1.9;\n         n += noise(x)/8.;  x *= 2.3;\n         n += noise(x)/16.; x *= 1.9;\n         n += noise(x)/32.; x *= 2.1;\n         n += noise(x)/64.;\n    return n; \n}\n\nfloat add_noise0(vec3 x) {  // --- cascade raw sum noise\n    float i=0.,\n         n =  noise(x)-.5; i++; x *= 2.1;  // return n*2.;\n         n += noise(x)-.5; i++; x *= 1.9;\n         n += noise(x)-.5; i++; x *= 2.3;\n         n += noise(x)-.5; i++; x *= 1.9;\n         n += noise(x)-.5; i++; x *= 2.1;\n         n += noise(x)-.5; i++;\n    return n/sqrt(i); \n}\n\nfloat mul_noise(vec3 x) {   // --- multiplicative noise \n    float n = 2.*noise(x);  x *= 2.1;  // return n/2.;\n         n *= 2.*noise(x);  x *= 1.9;\n         n *= 2.*noise(x);  x *= 2.3;\n         n *= 2.*noise(x);  x *= 1.9;\n         n *= 2.*noise(x);  x *= 2.1;\n         n *= 2.*noise(x);\n    return n/2.; \n}\n\n//#define draw(v) clamp(1.5 - R.y/8.* abs( v - 4.*U.y), 0.,1.)\n  #define draw(v) clamp(1.5 - abs( v - 4.*U.y) / fwidth( v ), 0.,1.)\n\n#define map(P) ( U.x < 0. ? mul_noise(P) : .5 + 3.*add_noise0(P) )\n\nvoid mainImage( out vec4 O, vec2 u )\n{\n    vec2 R = iResolution.xy,\n         U = ( 2.*u - R ) / R.y;\n\n    vec3 P = vec3( 4.*U-.2*iTime, .5 );                // draw 2D noise\n    O = vec4(  map(P) );       \n // if (abs(O.x-.5)<.1) { O = vec4(0,1,0,0); return; } // check isovalue\n    O *= vec4(1,.7,.5,0);\n    \n    P = vec3( 4.*U.x-.0*iTime, .5, .5 );               // draw curve\n    O.g += draw( map(P) ) + max(0.,1. - R.y/2.*abs(U.y));\n        \n    if ( int(u.x)==int(R/2.) ) O = vec4(1,0,0,0);      // red separator\n}", "image_inputs": [{"id": "XdX3Rr", "previewfilepath": "/media/ap/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/aea6b99da1d53055107966b59ac5444fc8bc7b3ce2d0bbb6a4a3cbae1d97f3aa.bin", "ctype": "volume"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyyRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[233, 461, 482, 482, 814], [816, 816, 841, 870, 1121], [1123, 1123, 1149, 1179, 1479], [1481, 1481, 1506, 1537, 1791], [1793, 1994, 2032, 2032, 2513]]}
{"id": "WdyyWD", "name": "plasma.", "author": "bitwitch", "description": "Oldschool style plasma made with a buncha sins.", "tags": ["oldschool", "plasma", "sin", "cos", "demo"], "likes": 1, "viewed": 69, "published": "Public", "date": "1602802594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{ \n    // Normalized pixel coordinates (from 0 to 1)    \n    vec2 uv = fragCoord/iResolution.xy;\n        \n    vec2 center = iResolution.xy / 2.0;\n    vec2 circle_offset = vec2(center.x * sin(0.17 * iTime), center.y  * cos(0.245 * iTime));\n      \n    float d = length(fragCoord + circle_offset - center);\n    \n \tfloat plasma0 = sin(0.015 * d);\n    \n    float off1 = 69.0 * sin(0.007 * iTime);\n \tfloat plasma1 = sin(0.0211 * fragCoord.x - off1);\n    \n    float off2 = 52.3 * cos(0.023 * iTime);\n    float plasma2 = cos(0.019 * (fragCoord.y + fragCoord.x) + off2);\n    \n    float off3 = 75.2 * cos(0.009 * iTime);\n    float plasma3 = sin(0.02 * fragCoord.y - off3);\n    \n    float off4 = 48.1 * sin(0.007 * iTime);\n    float plasma4 = cos(0.018 * fragCoord.y - off4);\n\n\n    float value = plasma0 + plasma1 + plasma2 + plasma3 + plasma4;\n  \n   \n    // Output to screen\n    fragColor = vec4(0.0,value,0.5*value,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyyWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 112, 969]]}
{"id": "wdyyWz", "name": "Fab14 #inktober2020 \"armor\"", "author": "FabriceNeyret2", "description": "mouse control\n[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 7, "viewed": 239, "published": "Public API", "date": "1602579294", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define L           length\n#define rot(a)      mat2( cos(a+vec4(0,11,33,0)) )                       // rotation                  \n#define B(a,w,h,l)  max( max( abs(a).x -w, abs(a).y -h ), abs(a).z -l )  // bar\n\nvoid mainImage(out vec4 O, vec2 U) {\n    \n    float t=9., a;\n    vec3  R = iResolution, e = vec3(5,-5,0), X=e.xzz, Y=e.zxz, Z=e.zzx,\n          M = iMouse.z > 0. ? iMouse.xyz/R : vec3(4,2,0)/1e2*cos(iTime+vec3(0,11,0)),\n          D = normalize(vec3( U+U, -3.5*R.y ) - R ),       // ray direction\n          p = 50./R, q,s;                                  // marching point along ray \n    \n    for ( O-=O ; O.x < 1. && t > .01 ; O+=.01 )\n        q = p, t=9.,\n        q.yz *= rot( .4 +3.*M.y),                          // rotations\n        q.xz *= rot(-.7 -6.*M.x),\n        s = q += Y, a = 3.14/12.,                          // 12 folds copy-rot\n        s.xz = L(s.xz)* cos(mod( atan(s.z,s.x) +a, a+a) -a +vec2(0,11)), // cylindrical symmetry  \n        t = min(t, max( B( s-X ,.3,7.,1.2 ),               // body plank\n                        2.-L( (q-.7*Y).yz) ) ),            // arm holes\n        t = min(t, max(  B( s-.5*X-2.5*Y, .1,3.,.6 ),      // helmet plank\n                        -B( q -Z-2.7*Y,  1.5,.5,3. )       // eyes hole\n               )      ),\n     // t = min(t, max( L((q-3.*Y).xz)-2.5 , abs(q.y-15.)-.1 )),      // helmet top\n        a = t,\n        t = min(t, max( L(vec2( L(q.x)-3., L((q-.9*Y).yz)-3.7) ) -.2, // handles\n                        4.-q.y )),\n        p += t*D;                                          // step forward = dist to obj          \n\n // if (t==a) O *= vec4(1,.8,.6,0)/.3;                     // coloring\n    if (t==a) O = vec4(1,.8,.6,0) *exp(-5.*O);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyyWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 247, 247, 1704]]}
{"id": "wlsBR8", "name": "log_polar_thingy_1", "author": "balkhan", "description": "toying with this space: https://www.osar.fr/notes/logspherical/", "tags": ["3d", "raymarching", "logspherical"], "likes": 9, "viewed": 247, "published": "Public API", "date": "1602248868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n* License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n* Created by bal-khan\n*/\n\n\n\n#define I_MAX\t\t400\n#define E\t\t\t0.0001\n#define FAR\t\t\t20.\n\n#define\tFUDGE\t\t1.\n\nvec4\tmarch(vec3 pos, vec3 dir);\nvec3\tcamera(vec2 uv);\nvec3\tcalcNormal(in vec3 pos, float e, vec3 dir);\nvoid\trotate(inout vec2 v, float angle);\nfloat\tmylength(vec2 p);\nfloat\tmylength(vec3 p);\n\n#define PI\t\t\t3.14159\n#define TAU\t\t\tPI*2.\n\n/*\n* Leon's mod polar from : https://www.shadertoy.com/view/XsByWd\n*/\n\nvec2 modA (vec2 p, float count) {\n    float an = TAU/count;\n    float a = atan(p.y,p.x)+an*.5;\n    a = mod(a, an)-an*.5;\n    return vec2(cos(a),sin(a))*length(p);\n}\n\n/*\n* end mod polar\n*/\n#define SCALE 2.0/PI\n\nfloat sdCy( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nvec3 ilogspherical(in vec3 p)\n{\n\tfloat erho = exp(p.x);\n\tfloat sintheta = sin(p.y);\n\treturn vec3(\n\t\terho * sintheta * cos(p.z),\n\t\terho * sintheta * sin(p.z),\n\t\terho * cos(p.y)\n\t);\n}\n\nvoid pR(inout vec2 p, float a) {\n\tp = cos(a)*p + sin(a)*vec2(p.y, -p.x);\n}\n\nfloat side = .0, shorten = 20.50;\nfloat layer(in vec3 p, in float twost)\n{\n\tfloat ret = 1e5;\n\tpR(p.yz, twost);\n    vec3 op = p;\n\tp.xyz = abs(p.xyz) - 2.750;\n    float a = .0+p.x*.5;\n    /*\n    p.xy= modA(p.xy, 3.);p.x-=5.;\n    p.zy= modA(p.zy, 3.);p.z-=2.;\n    p.yx= modA(p.yx, 3.);p.y-=4.;\n    */\n    ret = length(vec2(max(p.y, p.x), max(p.z, min(p.x,p.y) ) ) )-.25;\n\n    float sf = .1525+-1.5100251010/(length(p)*length(p)*0.015+10.01)-.0;\n    ret = min(ret,\n              length(\n              fract(sf*vec2(p.z, p.x))/sf-.5\n              )-.10105\n              );\n    ret = min(ret,\n              length(\n              fract(sf*vec2(p.y, p.x))/sf-.5\n              )-.10105\n              );\n    ret = min(ret,\n              length(\n              fract(sf*vec2(p.z, p.y))/sf-.5\n              )-.105105\n              );\n    ret = max(ret,\n              -(length(fract(sf*p)/sf-.5)-.5 )\n              );\n    op.xy = modA(op.xy, 50.);\n    op.zx = modA(op.zx, 50.);\n    float shell_cubes = (mylength(op-vec3(.0,-.0,1.0505)+-.00)-0.0251250905125995);\n    ret = min(ret, shell_cubes );\n    ret = min(ret, (length(p+-4.50705)-3.50905995) );\n\n\treturn ret;\n}\n\nfloat sdf(in vec3 pin)\n{\n    float dens = .25;\n    float idens = 1./dens;\n    float twist = 1.5, stepZoom = 1.;\n\tfloat r = length(pin);\n\tvec3 p = vec3(log(r), acos(pin.z / length(pin)), .0+iTime*.1*-1.0+atan(pin.y, pin.x));\n\n\t// Apply rho-translation, which yields zooming\n\tp.x -= iTime*1.2;\n\n\t// find the scaling factor for the current tile\n\tfloat xstep = floor(p.x*dens) + (iTime*1.2)*dens;\n\t\n\t// Turn tiled coordinates into single-tile coordinates\n\tp.x = mod(p.x, idens);\n\n\t// Apply inverse log-spherical map (box tile -> shell tile)\n\tp = ilogspherical(p);\n\n\tfloat ret = 1e5;\n\tret = min(ret, layer(p/stepZoom, (xstep+1.0)*twist)*stepZoom);\n\n\t// Compensate for scaling applied so far\n\tret = ret * exp(xstep*idens) / shorten;\n\n\treturn ret;\n}\n\nvoid mainImage(out vec4 c_out, in vec2 f)\n{\n    vec3\tcol = vec3(0., 0., 0.);\n    vec2\tR = iResolution.xy;\n\tvec2\tuv  = vec2((f.xy-.5*R.xy)/R.y);\n\tvec3\tdir = normalize(vec3(uv*vec2(1.,-1.), 1.));\n    vec3\tpos = vec3(-.0, -.2105017501050*.450*.0+.033*.0, -2.0*.0-1.52525045);\n    \n\n    vec4\tinter = march(pos, dir);\n    if (inter.y <= E*1.)\n    {\n        vec3\tv = pos+(inter.w-E*0.)*dir;\n        vec3\tn = calcNormal(v, E*1., dir);\n        vec3\tev = normalize(v - pos);\n\t\tvec3\tref_ev = reflect(ev, n);\n        vec3\tlight_pos   = vec3(-100.0, 60.0, -50.0);\n\t\tvec3\tlight_color = vec3(.1, .4, .7);\n        vec3\tvl = normalize(light_pos - v);\n\t\tfloat\tdiffuse  = max(0.0, 1.-dot(vl, n))+.0*max(0.0, dot(vl, n));\n\t\tfloat\tspecular = pow(max(0.0, dot(vl, ref_ev)), 3.);\n        col.xyz += light_color * (specular*1.0)+ diffuse * vec3(.51,.515, .53);\n    }\n    else\n        col *= .0;\n    c_out =  vec4(col, 1.);\n}\n\nvec4\tmarch(vec3 pos, vec3 dir)\n{\n    vec2\tdist = vec2(0.0, 0.0);\n    vec3\tp = vec3(0.0, 0.0, 0.0);\n    vec4\tret = vec4(0.0, 0.0, 0.0, 0.0);\n\n    for (int i = -1; i < I_MAX; ++i)\n    {\n    \tp = pos + dir * dist.y;\n        dist.x = sdf(p);\n        dist.y += dist.x*FUDGE;\n        if ( dist.x < E || dist.y > FAR)\n            break;\n    }\n    ret.w = dist.y;\n    ret.y = dist.x;\n    return (ret);\n}\n\n// Utilities\n\nfloat\tmylength(vec3 p)\n{\n\tfloat\tret = 1e5;\n\n    p = abs(p);\n    ret = max(p.x, max(p.y, p.z));\n    \n    return ret;\n}\n\nfloat\tmylength(vec2 p)\n{\n\tfloat\tret = 1e5;\n\n    p = abs(p);\n    \n    ret = max(p.x, p.y);\n\n    return ret;\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n\nvoid rotate(inout vec2 v, float angle)\n{\n\tv = vec2(cos(angle)*v.x+sin(angle)*v.y,-sin(angle)*v.x+cos(angle)*v.y);\n}\n\nvec3 calcNormal( in vec3 pos, float e, vec3 dir)\n{\n    vec3 eps = vec3(e,0.0,0.0);\n\n\treturn normalize(vec3(\n           sdf(pos+eps.xyy) - sdf(pos-eps.xyy),\n           sdf(pos+eps.yxy) - sdf(pos-eps.yxy),\n           sdf(pos+eps.yyx) - sdf(pos-eps.yyx) ));\n}\n\nvec3\tcamera(vec2 uv)\n{\n    float\t\tfov = 1.;\n\tvec3\t\tforw  = vec3(0.0, 0.0, -1.0);\n\tvec3    \tright = vec3(1.0, 0.0, 0.0);\n\tvec3    \tup    = vec3(0.0, 1.0, 0.0);\n\n    return (normalize((uv.x) * right + (uv.y) * up + fov * forw));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsBR8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[427, 498, 531, 531, 662], [664, 708, 738, 738, 837], [839, 839, 870, 870, 1020], [1022, 1022, 1054, 1054, 1096], [1132, 1132, 1172, 1172, 2249], [2251, 2251, 2275, 2275, 2993], [2995, 2995, 3038, 3038, 3896], [3898, 3898, 3930, 3930, 4293], [4295, 4309, 4333, 4333, 4426], [4428, 4428, 4452, 4452, 4536], [4538, 4538, 4579, 4579, 4647], [4650, 4650, 4690, 4690, 4765], [4767, 4767, 4817, 4817, 5023], [5025, 5025, 5047, 5047, 5253]]}
{"id": "WlSfDV", "name": "Warping Test", "author": "edorobek", "description": "Playing with domain warping", "tags": ["fbm"], "likes": 20, "viewed": 440, "published": "Public", "date": "1603040209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// noise and FBM\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(3.0-2.0*f);\n    float a = textureLod(iChannel0,(p+vec2(0.5,0.5))/256.0,0.0).x;\n\tfloat b = textureLod(iChannel0,(p+vec2(1.5,0.5))/256.0,0.0).x;\n\tfloat c = textureLod(iChannel0,(p+vec2(0.5,1.5))/256.0,0.0).x;\n\tfloat d = textureLod(iChannel0,(p+vec2(1.5,1.5))/256.0,0.0).x;\n    return mix(mix( a, b,f.x), mix( c, d,f.x),f.y);\n}\n\nconst mat2 mtx = mat2( 0.85,  0.60, -0.60,  0.80 );\n\nfloat fbm3( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.8000*(-1.0+2.0*noise( p )); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.5500*(-1.0+2.0*noise( p )); p = mtx*p*2.03;\n    f += 0.1625*(-1.0+2.0*noise( p ));\n    \n    return f/1.8375;\n}\n\nfloat fbm7( vec2 p )\n{\n    float f = 0.0;\n\n    f += 0.005000*noise( p ); p = mtx*p*2.02;\n    f += 0.250000*noise( p ); p = mtx*p*2.03;\n    f += 0.125000*noise( p ); p = mtx*p*2.01;\n    f += 0.562500*noise( p ); p = mtx*p*2.04;\n    f += 0.831250*noise( p ); p = mtx*p*2.01;\n    f += 0.312500*noise( p ); p = mtx*p*2.02;\n    f += 0.15625*noise( p );\n\n    return f/5.41875;\n}\n\nvec2 fbm3_2( vec2 p )\n{\n    return vec2( fbm3(p+vec2(1.5)), fbm3(p+vec2(3.2)) );\n}\n\nvec2 fbm7_2( vec2 p )\n{\n    return vec2( fbm7(p+vec2(3.2)), fbm7(p+vec2(9.7)) );\n}\n\n\n// Domain Warping\nfloat warp(vec2 q, out vec2 o, out vec2 n)\n{\n    // animate q here\n    q += 0.1*sin(vec2(0.11,0.13)*.16*iTime + length( q )*4.0);\n    q *= 0.8;\n    \n    o = 0.5 + 0.5*fbm3_2( q );\n    \n    o += 0.04*sin(vec2(0.11,0.11)*.1*iTime*length( o ));\n\to *= 1.1;\n    \n    n = fbm7_2(.95*o);\n    \n    vec2 p = q + 2.0*n + 1.0;\n    \n    float f = 0.5 + 0.5*fbm3(2.0*p);\n    \n    f = mix(f, f*f*f*3.5, f*abs(n.x));\n    \n    f *= 1.0-0.5*pow( 0.5+0.5*sin(8.0*p.x)*sin(8.0*p.y), 8.0 );\n\n    return f;\n}\n\nfloat warps( in vec2 q )\n{\n    vec2 t1, t2;\n    return warp(q,t1,t2);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec3 tot = vec3(0);\n    for( int mi=0; mi<4; mi++ )\n    for( int ni=0; ni<4; ni++ )\n    {\n    vec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    vec2 o, n;\n    \n    float f = warp(q, o, n);\n    \n    vec3 col = vec3(0.2,0.7,0.3);\n        col = mix( col, vec3(0.2,0.25,0.35), f );\n        col = mix( col, vec3(0.9,0.9,0.9), dot(n,n) );\n        col = mix( col, vec3(0.5,0.4,0.1), 0.5*o.y*o.y );\n        col = mix( col, vec3(0.6,0.2,0.4), 0.5*smoothstep(1.2,1.3,abs(n.y)+abs(n.x)) );\n        col *= f*2.0;\n    \n    vec2 ex = vec2( 1.0 / iResolution.x, 0.0 );\n    vec2 ey = vec2( 0.0, 1.0 / iResolution.y );\n    \n    vec3 nor = normalize( vec3( warps(q+ex) - f, ex.x, warps(q+ey) - f ) );\n    \n    vec3 lig = normalize( vec3( 0.9, -0.2, -0.4 ) );\n    float dif = clamp( 0.3+0.7*dot( nor, lig ), 0.0, 1.0 );\n\n    vec3 bdrf;\n    bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.15,0.10,0.55)*dif;\n    bdrf  = vec3(0.85,0.90,0.95)*(nor.y*0.5+0.5);\n    bdrf += vec3(0.15,0.10,0.05)*dif;\n\n    col *= 2.1*bdrf;\n    col = vec3(1.0)-col;\n    col = col*col;\n    col *= vec3(1.1,1.25,1.2);\n        \n    tot += col;\n    }\n    \n    tot /= 16.0;\n    \n    vec2 p = fragCoord / iResolution.xy;\n\ttot *= 0.5 + 0.5 * sqrt(16.0*p.x*p.y*(1.0-p.x)*(1.0-p.y));\n    \n\tfragColor = vec4(tot, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WlSfDV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 18, 44, 44, 428], [483, 483, 505, 505, 748], [750, 750, 772, 772, 1122], [1124, 1124, 1147, 1147, 1206], [1208, 1208, 1231, 1231, 1290], [1293, 1311, 1355, 1377, 1798], [1800, 1800, 1826, 1826, 1871], [1873, 1873, 1930, 1930, 3233]]}
{"id": "wlsXzS", "name": "vogel_disk_sampling", "author": "myrkott", "description": "Rotating Vogel disk with per-frame radius jittering. This sampling pattern can be used in combination with temporal anti-aliasing for, e.g., SSAO, shadow map filtering, DoF, etc. ", "tags": ["sampling"], "likes": 9, "viewed": 217, "published": "Public", "date": "1603924458", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Rotating Vogel disk with per-frame radius jittering. This sampling pattern\n// provides good spatial coverage with only a few sampling points and can be\n// used in combination with temporal anti-aliasing for, e.g., SSAO, shadow map\n// filtering, DoF, etc. The plot shows the distribution of NUM_SAMPLES over\n// NUM_FRAMES.\n//\n// References:\n// - Spreading points on a disc and on a sphere, http://blog.marmakoide.org/?p=1\n// - M. Gjoel and M. Svendsen, The rendering of INSIDE, GDC 2016, p. 43\n//   https://www.gdcvault.com/play/1023002/Low-Complexity-High-Fidelity-INSIDE.\n//\n// Author: Johan Nysjö\n\n#define NUM_SAMPLES 6\n#define NUM_FRAMES 60\n#define PI 3.14159265398\n\nvec3 srgb2lin(vec3 color)\n{\n\treturn color * color;    \n}\n\nvec3 lin2srgb(vec3 color)\n{\n \treturn sqrt(color);   \n}\n\nfloat hash(float seed)\n{\n    return fract(sin(seed * 12.9899) * 43758.5453); \n}\n\nvec2 vogel_disk(int i, int num_samples, float r_offset, float phi_offset)\n{\n\tfloat r = sqrt((float(i) + r_offset) / float(num_samples));\n    float golden_angle = 2.399963229728;\n    float phi = float(i) * golden_angle + 2.0 * PI * phi_offset;\n    float x = r * cos(phi);\n    float y = r * sin(phi);\n\n    return vec2(x, y);\n}\n\nfloat aastep(float edge, float x)\n{\n    float aawidth = 0.7 * fwidth(x);\n\treturn smoothstep(edge - aawidth, edge + aawidth, x);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    float aspect = iResolution.x / iResolution.y;\n    vec2 p = (2.0 * uv - 1.0) * vec2(aspect, 1.0);\n\n    vec3 background_color = srgb2lin(vec3(0.8, 0.8, 0.8));\n    vec3 glyph_color = srgb2lin(vec3(0.7, 0.1, 0.1));\n    float glyph_size = 0.03;\n\n    // NOTE: the seed should be fetched from, e.g., a tiled blue noise texture\n    // when the vogel disk is used as a filter kernel for postprocessing effects\n    vec2 seed = vec2(0.0, 0.0);\n\n    vec3 output_color = background_color;\n    for (int i = 0; i < NUM_FRAMES; ++i) {\n        float r_offset = hash(seed.x + float((iFrame + i) % 1000));\n        float phi_offset = fract(seed.y + sqrt(3.0) * float((iFrame + i) % 1000));\n        float glyph_alpha = float(i + 1) / float(NUM_FRAMES);\n        for (int j = 0; j < NUM_SAMPLES; ++j) {\n            vec2 q = vogel_disk(j, NUM_SAMPLES, r_offset, phi_offset);\n            float dist = length(p - q);\n            float alpha = glyph_alpha * (1.0 - aastep(glyph_size, dist));\n            output_color = alpha * glyph_color + (1.0 - alpha) * output_color;\n        }\n    }\n\toutput_color = lin2srgb(output_color);\n    \n    fragColor = vec4(output_color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlsXzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 674, 701, 701, 730], [732, 732, 759, 759, 786], [788, 788, 812, 812, 867], [869, 869, 944, 944, 1193], [1195, 1195, 1230, 1230, 1324], [1326, 1326, 1383, 1383, 2577]]}
{"id": "wlySWd", "name": "Waves and Interference", "author": "hhhzzzsss", "description": "Ray-marched render of waves", "tags": ["3d", "raymarching", "waves"], "likes": 1, "viewed": 22, "published": "Public", "date": "1603687750", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926535897932384\n\nvoid sinFunc3D(vec3 p, float freq, float amp, float phase, out float f, out vec3 df) {\n    float m = length(p.xz);\n    f = p.y-cos(freq*(m-phase))*amp*min(1.0, 5./m);\n    df.y = 1.0;\n    if (m == 0.0) {\n        df.x = 0.0;\n        df.z = 0.0;\n    }\n    else {\n        df.x = p.x/m;\n        df.z = p.z/m;\n        df.xz *= freq*sin(freq*(m-phase))*amp*min(1.0, 5./m);\n    }\n}\n\nfloat map(vec3 p) {\n    vec3 p1 = p-vec3(-5.0*PI,0.0,0.0);\n    vec3 p2 = p-vec3(5.0*PI,0.0,0.0);\n    float f1, f2;\n    vec3 df1, df2;\n    sinFunc3D(p1, 1.0, 2.0, 10.0*iTime, f1, df1);\n    sinFunc3D(p2, 1.0, 2.0, 10.0*iTime, f2, df2);\n    return (f1+f2)/length(df1+df2)/1.5;\n}\n\nvec3 getNorm(vec3 p) {\n    vec2 e = vec2(0.0, 0.001);\n    vec3 n;\n    n.x = map(p+e.yxx) - map(p-e.yxx);\n    n.y = map(p+e.xyx) - map(p-e.xyx);\n    n.z = map(p+e.xxy) - map(p-e.xxy);\n    return normalize(n);\n}\n\nfloat trace(vec3 ro, vec3 rd) {\n    float t = 0.001;\n    for (int i=0; i<1000; i++) {\n        float h = map(ro+t*rd);\n        if (abs(h)<0.0001*t)\n            return t;\n        t += 1.0*h;\n        if (t>1024.0) return -1.0;\n    }\n}\n\nfloat softShadow(vec3 ro, vec3 rd) {\n    float sha = 1.0;\n    float t = 0.01;\n    for (int i=0; i<256; i++) {\n    \tfloat h = map(ro+t*rd);\n        sha = min(sha, 2.0*h/t);\n        t += 1.0*clamp(h,0.02,0.20);\n        if (t>16.0) break;\n    }\n    sha = clamp(sha, 0.0, 1.0);\n    return sha*sha*(3.0-2.0*sha);\n}\n\nmat2 rotMat(float theta) {\n    return mat2(cos(theta), sin(theta), -sin(theta), cos(theta));\n}\n\nfloat fresnel(vec3 inc, vec3 nor, float ior) {\n    float cosi = clamp(-1., 1., dot(inc, nor));\n    float n1, n2;\n    if (cosi < 0.0) {\n        n1 = 1.;\n        n2 = ior;\n        cosi = -cosi;\n    }\n    else {\n        n1 = ior;\n        n2 = 1.;\n    }\n    float sint = n1/n2 * sqrt(max(0., 1.-cosi*cosi));\n    if (sint>=1.0) {\n        return 1.0;\n    }\n    else {\n        float cost = sqrt(max(0., 1.-sint*sint));\n        float Rs = ((n1 * cosi) - (n2 * cost)) / ((n1 * cosi) + (n2 * cost));\n        float Rp = ((n2 * cosi) - (n1 * cost)) / ((n2 * cosi) + (n1 * cost));\n        return (Rs * Rs + Rp * Rp) / 2.;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord - iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0,20.0,-20.0);\n    vec3 rd = normalize(vec3(uv, 1.));\n    rd.zy = rotMat(-0.8) * rd.zy;\n    \n    vec3 lig = normalize(vec3(0.5, 1.0, -0.5));\n    \n    float t = trace(ro,rd);\n    \n    vec3 skyCol = vec3(0.9,1.0,1.2);\n    float waterDepth = 2.0;\n    vec3 col;\n    if (t>=0.0) {\n    \tvec3 pos = ro + t*rd;\n    \tvec3 nor = getNorm(pos);\n        //float lig1 = max(dot(nor,lig),0.0);// * softShadow(pos,lig);\n        //float sky = 0.5 + 0.5*nor.y;\n        float spec = max(0.0, dot(reflect(rd, nor), lig));\n        float refl = fresnel(rd, nor, 1.33);\n        float refr = 1.0-refl;\n        vec3 refVec = refract(rd, nor, 1.0/1.33);\n        vec2 refFloorPos = refVec.xz / refVec.y * (pos.y+waterDepth) + pos.xz;\n        \n        //just to make sure floor doesn't clip into water surface. There will be obvious artifacts if it does.\n        if (pos.y+waterDepth<0.0) refFloorPos = vec2(0.0);\n        \n        spec = pow(spec, 50.0);\n        //col = vec3(0.0);\n        //col += vec3(0.6,0.6,0.5) * lig1;\n        //col += vec3(0.15,0.2,0.3) * sky;\n        //col *= vec3(0.2,0.26,0.3);\n        col += 1.0*texture(iChannel0, refFloorPos*0.03).xyz*0.9;\n        col += vec3(spec);\n        col *= refr;\n        col += refl*skyCol;\n    }\n    else {\n        col = skyCol;\n    }\n    \n    col = pow(col,vec3(0.45));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlySWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[34, 34, 120, 120, 407], [409, 409, 428, 428, 684], [686, 686, 708, 708, 895], [897, 897, 928, 928, 1128], [1130, 1130, 1166, 1166, 1439], [1441, 1441, 1467, 1467, 1535], [1537, 1537, 1583, 1583, 2153], [2155, 2155, 2212, 2212, 3634]]}
{"id": "Ws3fRn", "name": "Simple planet shader", "author": "damyvv", "description": "Simple planet shader. Next up is the atmosphere...", "tags": ["noise", "planet"], "likes": 9, "viewed": 135, "published": "Public", "date": "1604106123", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 200\n#define MAX_DIST 30.\n#define SURF_DIST 0.001\n\nfloat N31(vec3 p) {\n    return fract(cos(p.x*25013.+p.y*3539.+p.z*751.)*39863.);\n}\n\nfloat SmoothNoise3D(vec3 p) {\n    vec3 lv = fract(p);\n    vec3 id = floor(p);\n    \n    lv = lv*lv*(3.-2.*lv);\n    \n    float fbl = N31(id+vec3(0,0,0));\n    float fbr = N31(id+vec3(1,0,0));\n    float fb = mix(fbl, fbr, lv.x);\n    \n    float ftl = N31(id+vec3(0,1,0));\n    float ftr = N31(id+vec3(1,1,0));\n    float ft = mix(ftl, ftr, lv.x);\n    \n    float bbl = N31(id+vec3(0,0,1));\n    float bbr = N31(id+vec3(1,0,1));\n    float bb = mix(bbl, bbr, lv.x);\n    \n    float btl = N31(id+vec3(0,1,1));\n    float btr = N31(id+vec3(1,1,1));\n    float bt = mix(btl, btr, lv.x);\n    \n    float f = mix(fb, ft, lv.y);\n    float b = mix(bb, bt, lv.y);\n    \n    return mix(f,b, lv.z);\n}\n\nfloat SmoothNoise3DDetail(vec3 p) {\n    float c = SmoothNoise3D(p*4.);\n    c += SmoothNoise3D(p*8.)*.5;\n    c += SmoothNoise3D(p*16.)*.25;\n    c += SmoothNoise3D(p*32.)*.125;\n    c += SmoothNoise3D(p*64.)*.0625;\n    c += SmoothNoise3D(p*128.)*.03125;\n    return c/(2.-0.03125);\n}\n\nfloat sdSphere(vec3 p, float r) {\n    \n  float ns = length(p) - r + SmoothNoise3DDetail(p)*0.175*r;\n  float ws = length(p) - r + 0.1 + SmoothNoise3D(p*64.)*.0005 + SmoothNoise3D(p*128.)*.00025;\n  return min(ns, ws);\n}\n\nvec3 spherePos() {\n    return vec3(0,sin(iTime/2.)*.15,0);\n}\n\nfloat GetDist(vec3 p) {\n  float t = iTime/15.;\n  p.xz = vec2(p.x * cos(t) - p.z * sin(t),\n              p.x * sin(t) + p.z * cos(t));\n  float d = sdSphere(spherePos()-p, 1.);\n  return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  float d = 0.;\n  for (int i = 0; i < MAX_STEPS; i++) {\n    vec3 p = ro+d*rd;\n    float dS = .9*GetDist(p);\n    d += dS;\n    if (dS < SURF_DIST || d > MAX_DIST) break;\n  }\n\n  return d;\n}\n\nvec3 GetNormal(vec3 p) {\n    vec2 e = vec2(.001, 0);\n    float d = GetDist(p);\n    return normalize(d - vec3(\n      GetDist(p-e.xyy),\n      GetDist(p-e.yxy),\n      GetDist(p-e.yyx)));\n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/3.0;\n        float d = GetDist(pos+h*nor);\n        occ += (h-d)*sca;\n        sca *= 0.95;\n    }\n    return clamp( 1.0 - 2.0*occ, 0.0, 1.0 );\n}\n\nfloat shadow(vec3 ro, vec3 rd)\n{\n    rd = normalize(rd);\n    float mint = 0.1;\n    float maxt = 200.0;\n    \n    float res = 1.0;\n\n    for( float t=mint; t<maxt; )\n    {\n        float h = GetDist(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        res = min(res, 4.*h/t);\n        t += h;\n    }\n    return res;\n}\n\nvec3 GetLight(vec3 rd, vec3 p, vec3 n, vec3 m) {\n    vec3 lo = normalize(vec3(10, 10, -8));\n    \n    float occ = 0.05 + 0.95*calcAO(p,n);\n    float dif = 0.05 + 0.95*smoothstep(-0.2, 0.3, dot(n, lo));\n    float sha = 0.05 + 0.95*shadow(p, lo);\n          sha *= occ;\n    float spe = dot(normalize((lo-p)-2.*dot(lo-p, n)*n), normalize(rd));\n    spe = 1.+5.*smoothstep(0.7, 1.0, spe*smoothstep(0.8, 0.81, m.z));\n    \n    vec3 col = 1.2*vec3(1.0, 0.9, 0.9)*sha*dif*spe;\n    \n    return col;\n}\n\nvec3 materialComponents(vec3 p, vec3 n) {\n    vec2 e = vec2(0, 1);\n    vec3 coreN = normalize(p-spherePos());\n    float steepness = dot(coreN,n);\n    float height = length(p-spherePos());\n    float st = 0.85;\n    float sh = 0.925;\n    float wh = 0.903;\n    vec3 comp = mix(e.yxx, e.xyx, smoothstep(st,st+0.1, steepness));\n          comp = mix(comp, e.yxx, smoothstep(sh, sh+0.01, height));\n          comp = mix(comp, e.xxy, smoothstep(wh, wh-0.002, height));\n    return comp;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 ro = vec3(0, 0, -3);\n    vec3 rd = vec3(vec3(uv, 1));\n    \n    vec3 col = vec3(0);\n    \n    float d = RayMarch(ro, rd);\n    \n    if (d < MAX_DIST) {\n        vec3 p = ro+d*rd;\n        vec3 n = GetNormal(p);\n        vec3 m = materialComponents(p,n);\n        \n        vec3 l = .95*vec3(0.5, 0.7, 0.7)*GetLight(rd, p, n, m);\n        vec3 grass = vec3(0.5, 0.9, 0.2);\n        vec3 stone = 1.2*vec3(0.8, 0.3, 0.1);\n        vec3 water = vec3(0.2, 0.2, 0.9);\n        \n        col = m.x*stone + m.y*grass + m.z*water;\n        \n        col *= l;\n    } else {\n        col = vec3(smoothstep(0.998, 1., N31(vec3(uv, 0.))));\n    }\n\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3fRn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 87, 87, 150], [152, 152, 181, 181, 826], [828, 828, 863, 863, 1107], [1109, 1109, 1142, 1142, 1326], [1328, 1328, 1346, 1346, 1388], [1390, 1390, 1413, 1413, 1578], [1580, 1580, 1614, 1614, 1801], [1803, 1803, 1827, 1827, 1988], [1990, 1990, 2032, 2032, 2288], [2290, 2290, 2322, 2322, 2614], [2616, 2616, 2664, 2664, 3104], [3106, 3106, 3147, 3147, 3583], [3585, 3585, 3642, 3642, 4409]]}
{"id": "ws3yDs", "name": "traveling through wibbly-wobbly", "author": "Jinkweiq", "description": "I Tried to recreate a cool image (see line 1) and ended up with this.", "tags": ["cube", "projection"], "likes": 13, "viewed": 196, "published": "Public", "date": "1601975830", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// A failed attempt to re-create https://www.reddit.com/r/generative/comments/iv9sue/tangled_cube/\n\n#define time iTime*.1+1.3\n\n// from iq - https://www.shadertoy.com/view/XdXBRH\nvec2 hash(in vec2 x)// replace this by something better\n{\n    const vec2 k=vec2(.3183099,.3678794);\n    x=x*k+k.yx;\n    return-1.+2.*fract(16.*k*fract(x.x*x.y*(x.x+x.y)));\n}\n\n// from iq - https://www.shadertoy.com/view/XdXBRH\nvec3 noised(in vec2 p)\n{\n    vec2 i=floor(p);\n    vec2 f=fract(p);\n    \n    vec2 u=f*f*f*(f*(f*6.-15.)+10.);\n    vec2 du=30.*f*f*(f*(f-2.)+1.);\n    \n    vec2 ga=hash(i+vec2(0.,0.));\n    vec2 gb=hash(i+vec2(1.,0.));\n    vec2 gc=hash(i+vec2(0.,1.));\n    vec2 gd=hash(i+vec2(1.,1.));\n    \n    float va=dot(ga,f-vec2(0.,0.));\n    float vb=dot(gb,f-vec2(1.,0.));\n    float vc=dot(gc,f-vec2(0.,1.));\n    float vd=dot(gd,f-vec2(1.,1.));\n    \n    return vec3(va+u.x*(vb-va)+u.y*(vc-va)+u.x*u.y*(va-vb-vc+vd),// value\n    ga+u.x*(gb-ga)+u.y*(gc-ga)+u.x*u.y*(ga-gb-gc+gd)+// derivatives\n    du*(u.yx*(va-vb-vc+vd)+vec2(vb,vc)-va));\n}\n// from iq - https://www.shadertoy.com/view/ll2GD3\nvec3 pal(in float t)\n{\n    vec3 a=vec3(.5,.5,.5),\n    b=vec3(.5,.5,.5),\n    c=vec3(1.,1.,1.),\n    d=vec3(0.,.33,.67);\n    return a+b*cos(6.28318*(c*t+d));\n}\n// from iq - https://www.shadertoy.com/view/3tdSDj\nfloat sdSegment(in vec2 p,in vec2 a,in vec2 b)\n{\n    vec2 pa=p-a,ba=b-a;\n    float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*h);\n}\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\nvec2 cube(vec3 scale,vec3 cam,vec3 rot,vec2 uv){\n    vec2 c=vec2(0);\n    for(float x=0.;x<=1.;x++){\n        for(float y=0.;y<=1.;y++){\n            for(float z=0.;z<=1.;z++){\n                vec3 p3d=vec3(x,y,z);\n                p3d-=.5;\n                p3d*=scale;\n                p3d.xy*=rotate2d(rot.z);\n                p3d.yz*=rotate2d(rot.y);\n                p3d.xz*=rotate2d(rot.x);\n                p3d+=cam;\n                \n                p3d.xy/=p3d.z;\n                // lines\n                float ss = .007;\n\t\t\t\tc.x += (1.0 - smoothstep(0., 1., sdSegment(uv,p3d.xy,normalize(noised(uv+time).yz)) / ss))\n       \t\t\t\t* (-sdSegment(uv,p3d.xy,normalize(noised(uv+time).yz))+.2)*2.;\n                // dots\n                c.y += (smoothstep(1., 0.5, length(uv-p3d.xy) / 1.2 / ss));\n                \n            }\n        }\n    }\n    return c;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv=vec2(fragCoord.x/iResolution.x,fragCoord.y/iResolution.y);\n    uv-=.5;\n    uv/=vec2(iResolution.y/iResolution.x,1);\n    uv*=2.;\n    \n    vec3 cam=vec3(0,0,2);\n    vec3 rot=vec3(time,time*4.5,time*11.);\n    \n    vec2 c=vec2(0);\n    vec3 scale=vec3(1,.1,1);\n    \n    for(int i=0;i<=2;i++){\n        scale=vec3(1);\n        for(float s=.1;s<=1.;s+=.2){\n            scale[i]=s;\n            c+=cube(scale,cam,rot,uv);\n        }\n    }\n    vec3 col=vec3(0);\n    if(abs(uv.x)<1.){\n        col=mix(vec3(1),vec3(0.984,0.933,0.796),clamp(length(uv*.5),0.,1.));\n        col=mix(col,pal(c.x/6.),clamp(c.x,0.,1.));\n        col=mix(col,vec3(0.),clamp(c.y,0.,1.));\n    }\n    fragColor=vec4(col,1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3yDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 178, 235, 235, 351], [353, 404, 428, 428, 1027], [1028, 1079, 1101, 1101, 1235], [1236, 1287, 1335, 1335, 1437], [1438, 1438, 1465, 1465, 1530], [1531, 1531, 1579, 1579, 2382], [2383, 2383, 2440, 2440, 3135]]}
{"id": "ws3yW2", "name": "A Wonderful Rainbow", "author": "Eplor", "description": "A Wonderful Rainbow", "tags": ["noise", "rainbow", "gradients"], "likes": 2, "viewed": 91, "published": "Public", "date": "1601738885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\nfloat noiseOctae(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.9),choppy);\n}\n\nvec3 calcRainbow(vec2 uv, float offset) {\n    return 0.5 + 0.5*cos(offset+uv.xyx+vec3(0,2,4));\n}\n\nvec3 calcMap(vec2 uv) {\n    vec3 color = vec3(0.0);\n    const float count = 16.0;\n    for(float i = 1.0; i <= count; i += 1.0) {\n    \tvec3 rainbow = calcRainbow(uv, iTime + i) * noiseOctae(uv * 0.5 + i, 3.5);\n        color += rainbow;\n    }\n    return color * .25;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = calcMap(uv);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3yW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 102], [104, 104, 130, 130, 431], [433, 433, 474, 474, 644], [646, 646, 687, 687, 742], [744, 744, 767, 767, 1010], [1012, 1012, 1069, 1069, 1176]]}
{"id": "Ws3yWl", "name": "test_xbluebeardx", "author": "xbluebeardx", "description": "test", "tags": ["test"], "likes": 5, "viewed": 159, "published": "Public API", "date": "1601925914", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat DrawLine(vec2 pp, float yTarget) {\n\tfloat res = smoothstep(yTarget-0.01,yTarget+0.1,pp.y)+smoothstep(yTarget+0.01, yTarget-0.01, pp.y);\n    return res;\n}   \nfloat DE( vec2 pp, out bool blood, float t )\n{\n\tpp.y += sin(pp.x)/*(\n\t\t.4 * sin(.5*2.3*pp.x+pp.y) +\n\t\t.2 * sin(.5*5.5*pp.x+pp.y) +\n\t\t0.1*sin(.5*13.7*pp.x)+\n\t\t0.06*sin(.5*23.*pp.x))*/;\n\t\n\tpp += vec2(0.,0.4)*t;\n\t\n\tfloat thresh = 5.3;\n\t\n\tblood = pp.y > thresh;\n\t\n\tfloat d = abs(pp.y - thresh);\n\t// todo use proper implicit dist\n\t//d /= sqrt(1.+grad*grad);\n    pp.y *= 2.0;\n\treturn d;\n}\n\nvec3 sceneColour( in vec2 pp )\n{\n\tfloat endTime = 16.;\n\tfloat rewind = 2.;\n\tfloat t = mod( iTime, endTime+rewind );\n\t\n\tif( t > endTime )\n\t\tt = endTime * (1.-(t-endTime)/rewind);\n\t\n\tbool blood;\n    \n\tfloat d = DE( pp, blood, t );\n    float line = DrawLine(pp, 2.0);\n\t\n\tif( !blood )\n\t{\n\t\t// floor. not really happy with this at the moment..\n\t\tvec3 floorCol = vec3(.25);\n\t\t\n\t\tfloorCol = texture( iChannel0, -(vec2(pp.x/20.,pp.y/33.)+vec2(.5,.02)) ).xyz;\n\t\tfloat floori = (floorCol.x+floorCol.y+floorCol.z)/3.;\n\t\t\n\t\tfloori = smoothstep(0.5,.53,floori) ;\n\t\tfloori = smoothstep(-5.15,1.,floori);\n\t\tfloori = 1.-floori;\n\t\tfloorCol = vec3(floori);\n\t\t\n\t\t// ao from blood\n\t\tfloat ao = clamp( smoothstep(0.,.2,d), 0., 1.);\n\t\tvec3 res = mix(1.,sqrt(ao),.25) * floorCol;\n        res *= line;\n        return res;\n\t}\n\telse\n\t{\n\t\t//blood. fake a 3d look\n\t\t//height\n\t\tfloat h = clamp( smoothstep(.0,.25,d), 0., 1.);\n\t\th = 4.*pow(h,.2);\n\t\t// couldnt get matching results using finite diffs, need to sort this out.\n\t\t/*vec2 eps = vec2(0.,.01);\n\t\tfloat dx = clamp( smoothstep(.0,.25,DE(pp+eps.yx,blood,t)), 0., 1.);\n\t\tdx = (dx - h)/eps.y;\n\t\tfloat dy = clamp( smoothstep(.0,.25,DE(pp+eps.xy,blood,t)), 0., 1.);\n\t\tdy = (dy - h)/eps.y;*/\n\t\t//vec3 N = vec3(-dx, 1., -dy );\n\t\t\n\t\t// gradient instructions. easy but produces artifacts\n\t\tvec3 N = vec3(-dFdx(h), 1., -dFdy(h) );\n        float line2 = DrawLine(pp, (h/4.+2.));\n        //line2 = 1.;\n\t\tN = normalize(N);\n\t\tvec3 L = normalize(vec3(.5,.7,-.5));\n\t\tvec3 res = pow(dot(N,L),10.)*vec3(1.);\n\t\t// make it more red hack\n\t\tres += vec3(.5,-.3,-0.3);\n\t\t// window refl\n\t\tvec2 off = pp-vec2(5.3,2.);\n\t\t\n\t\tfloat r = length(off);\n\t\tfloat v = 1.;\n\t\tfloat band = 20./iResolution.x;\n\t\tv *= smoothstep( 0.8, .8+band, r );\n\t\tv *= smoothstep( 2.1, 2.1-band, r );\n\t\tfloat gap1 = smoothstep(1.3,1.3-band,r) + smoothstep( 1.4,1.4+band,r);\n\t\tv*= gap1;\n\t\t\n\t\t// the witness\n\t\tfloat h1t = 3.;\n\t\tfloat h2t = 4.1;\n\t\tfloat ht = 5.;\n\t\tfloat hand1p = 1.-clamp((t-h1t)/5.,0.,1.);\n\t\tfloat hand2p = 1.-clamp((t-h2t)/5.,0.,1.);\n\t\tfloat headp = smoothstep(0.,1.,1.-clamp((t-ht)/6.,0.,1.));\n\t\tv *= smoothstep(.06,.06+band, length(pp-vec2(6.71,3.61)-vec2(hand1p)));\n\t\tv *= smoothstep(.06,.06+band, length(pp-vec2(7.04,3.25)-vec2(hand2p)));\n\t\tv *= smoothstep(.13,.13+band, length(pp-vec2(6.84,3.4)-vec2(headp)));\n\t\t// ears\n\t\tv *= smoothstep(.02,.02+band, length(pp-vec2(6.74,3.49)-vec2(headp)));\n\t\tv *= smoothstep(.02,.02+band, length(pp-vec2(6.93,3.3)-vec2(headp)));\n\t\t\n\t\tband /= r;\n\t\tfloat a = atan( off.y, off.x );\n\t\tv *= smoothstep( 0.5,0.5+band, a);\n\t\tv *= smoothstep( 1.8,1.8-band, a);\n\t\tfloat gap2 = smoothstep( 1.1,1.1-band, a) + smoothstep( 1.2,1.2+band, a);\n\t\tv *= gap2;\n\t\t\n\t\tv *= .95;\n\t\tres = (1.-v)*res + v*vec3(1.);\n\t\tres *= line;\n        res *= line2;\n\t\treturn res;\n\t}\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x /= iResolution.y/iResolution.x;\n\t\n\tfragColor.a = 1.0;\n\tfragColor.xyz = sceneColour(uv*4.);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3yWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 41, 41, 160], [164, 164, 210, 210, 546], [548, 548, 580, 580, 3323], [3325, 3325, 3382, 3382, 3523]]}
{"id": "ws3yWX", "name": "mandelbrot from z^0 to z^3", "author": "Jinkweiq", "description": "Mandelbrot in 2d from z^0 to z^3. Runs at fine at 4k an a pretty bad computer. Completes a full iteration every 20 sec.", "tags": ["mandelbrot"], "likes": 2, "viewed": 56, "published": "Public", "date": "1601843866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERS 200\n#define pi 3.14159\n\n//from https://www.shadertoy.com/view/XtlGD8\nvec2 cartToPol(vec2 z){\n\treturn vec2(length(z),atan(z.y,z.x));\n}\n\nvec2 polToCart(vec2 p){\n\treturn vec2(p.r*cos(p.g),p.r*sin(p.g));\n}\nvec2 powz(vec2 p , float power){\n    return vec2(pow(p.r,power),power*mod(p.g,2.*pi));\n}\n// from https://iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\nvec3 mandel(vec2 c) {\n    vec2 p = vec2(0.);\n    for (int i=0; i<ITERS; i++) {\n        p = polToCart(powz(cartToPol(p),sin(-iTime / 10. * pi) + 2.));\n        p += c;\n        if (length(p) > 1000.) {\n            return pal(float(i) * -.06248,vec3(0.5),vec3(0.5),vec3(2.0,1.0,0.0),vec3(0.5,0.20,0.2));\n        }\n    }\n    return vec3(0.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (vec2(1.5, 1.5) * (2.*fragCoord-iResolution.xy)/iResolution.y) + vec2(-.5, 0.);\n    vec3 col = mandel(uv);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3yWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[38, 83, 106, 106, 147], [149, 149, 172, 172, 215], [216, 216, 248, 248, 304], [305, 371, 439, 439, 482], [483, 483, 504, 504, 821], [822, 822, 879, 879, 1033]]}
{"id": "wsccWj", "name": "FMS_Cat @ Shader Royale #1", "author": "FMS_Cat", "description": "Twitch archive: https://www.twitch.tv/videos/758603196\nMy perspective (youtube): https://www.youtube.com/watch?v=BpP9r84VqOk", "tags": ["3d", "livecoding"], "likes": 45, "viewed": 842, "published": "Public", "date": "1601734713", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// FMS_Cat!!\n// Since it's written in the shader royale compo,\n// the code is a total mess that is not intended to be read.\n// I heard the compo machine is not a beast enough\n// so I made this less intensive a bit.\n// There are several artifacts that is difficult to ignore :(\n\n\n#define BEAT (time*170.0/60.0)\n#define PI 3.14159265\n#define time iTime\n#define lofi(x,d) (floor((x)/(d))*(d))\n#define saturate(a) (clamp((a),0.,1.))\n#define linearstep(a,b,t) (saturate(((t)-(a))/((b)-(a))))\n\nfloat seed;\n\nfloat fractsin(float v)\n{\n  return fract(sin(v*121.445)*34.59);\n}\n\nfloat rand()\n{\n  seed=fractsin(seed);\n  return seed;\n}\n\nvec3 randsphere()\n{\n  float t=PI*2.*rand();\n  float p=acos(rand()*2.-1.);\n  return vec3(sin(p)*sin(t),cos(p),sin(p)*cos(t));\n}\n\nfloat easeceil(float t, float fac)\n{\n  return floor(t)+.5+.5*cos(PI*exp(fac*fract(t)));\n}\n\nmat2 rot2d(float t)\n{\n  return mat2(cos(t),-sin(t),sin(t),cos(t));\n}\n\nvec3 ifs(vec3 p,vec3 rot,vec3 shift)\n{\n  vec3 pt=abs(p);\n  vec3 t=shift;\n  for(int i=0;i<6;i++)\n  {\n    pt=abs(pt)-abs(lofi(t*pow(1.8,-float(i)),1.0/512.0));\n    t.yz=rot2d(rot.x)*t.yz;\n    t.zx=rot2d(rot.y)*t.zx;\n    t.xy=rot2d(rot.z)*t.xy;\n    pt.xy=pt.x<pt.y?pt.yx:pt.xy;\n    pt.yz=pt.y<pt.z?pt.zy:pt.yz;\n  }\n  return pt;\n}\n\nfloat sdbox(vec3 p,vec3 s)\n{\n  vec3 d=abs(p)-s;\n  return length(max(d,0.));\n}\n\n// ======= map!!!!!!!!!! ====================================\nvec4 map(vec3 p)\n{\n  vec3 pt=p;\n  vec3 haha=lofi(pt,5.0);\n  float scrphase=mod(999.9*fractsin(haha.y+haha.z+3.88),PI*2.0);\n  float scr=(mod(haha.y+haha.z,2.0)*2.0-1.0)*20.0*smoothstep(-0.5,0.5,sin(time*0.5+scrphase));\n  pt.x+=scr;\n  haha=lofi(pt,5.0);\n  float phase=BEAT/8.0;\n  phase+=dot(haha,vec3(2.75,3.625,1.0625));\n  phase=easeceil(phase,-10.0);\n  pt=mod(pt,5.0)-2.5;\n  vec3 pm=pt;\n  pt.yz=rot2d(.5*PI*phase+.25*PI)*pt.yz;\n  float clampBox=sdbox(pt,vec3(2.25,1.5,1.8));\n  pt=ifs(pt,vec3(3.6,3.0+0.4*phase,3.1),vec3(3.0,2.3,3.5));\n  pt=mod(pt-.5,1.)-.5;\n  float dist=sdbox(pt,vec3(.17));\n  dist=max(dist,clampBox);\n  return vec4(\n    dist,\n    sin(PI*fract(phase)),\n    step(0.0,0.01-abs(pt.x+pt.y)),\n    abs(pm.x)+abs(pm.y)+abs(pm.z)\n  );\n}\n\nvec3 normalFunc(vec3 p,vec2 d)\n{\n  return normalize(vec3(\n    map(p+d.yxx).x-map(p-d.yxx).x,\n    map(p+d.xyx).x-map(p-d.xyx).x,\n    map(p+d.xxy).x-map(p-d.xxy).x\n  ));\n}\n\nfloat aoFunc(vec3 p,vec3 n)\n{\n  float accum=0.;\n  for(int i=0;i<32;i++){\n    vec3 d=(0.02+0.02*float(i))*randsphere();\n    d=dot(d,n)<.0?-d:d;\n    //accum+=step(map(p+d).x,0.0)/64.0;\n    accum+=linearstep(0.02,0.0,map(p+d).x)/64.0;\n  }\n  return 1.0-sqrt(saturate(6.0*accum));\n}\n\nvec2 glitch(vec2 v)\n{\n  vec2 vt=v;\n  for(int i=0;i<6;i++)\n  {\n    float fac=4.0*pow(2.2,-float(i));\n    float s=fractsin(lofi(vt.x,1.6*fac));\n    s+=fractsin(lofi(vt.y,0.4*fac));\n    s+=fractsin(time);\n    float proc=fractsin(s);\n    vt+=0.2*step(proc,0.4*exp(-3.0*mod(BEAT,8.0))-0.01)*(vec2(\n      fractsin(s+22.56),\n      fractsin(s+17.56)\n    )-0.5);\n  }\n  return vt;\n}\n\nvoid mainImage( out vec4 o, in vec2 fragCoord )\n{\n  vec2 p=(fragCoord.xy*2.0-iResolution.xy)/iResolution.y;\n  o=vec4(0,0,0,1);\n  seed=texture(iChannel0,p).x;\n  seed+=time;\n  \n  vec2 po=p;\n  p=glitch(p);\n  \n  vec3 ro=vec3(4.0*time,0,lofi(BEAT,8.0));\n  vec3 rd=vec3(p,-1);\n  rd.z+=0.6*length(p);\n  float camphase=lofi(BEAT,8.0)+mod(BEAT,8.0)*0.2;\n  rd.yz=rot2d(0.33*camphase+0.03*sin(3.0*time))*rd.yz;\n  rd.zx=rot2d(0.78*camphase+0.03*cos(3.0*time))*rd.zx;\n  rd.xy=rot2d(0.048*camphase)*rd.xy;\n  rd=normalize(rd);\n  vec3 fp=ro+rd*5.0;\n  ro+=0.02*randsphere();\n  rd=normalize(fp-ro);\n  \n  vec4 dist;\n  float rl=0.01;\n  float glow=0.0;\n  vec3 rp=ro+rl*rd;\n  for(int i=0;i<69;i++){ // nice\n    dist=map(rp);\n    glow=dist.y;\n    rl+=dist.x*0.7;\n    rp=ro+rl*rd;\n  }\n  \n  float fog=exp(-0.1*max(0.,rl-5.0));\n  o.xyz+=(1.0-fog)*vec3(1.);\n  \n  vec3 n2=normalFunc(rp,vec2(0.0,1E-2+4E-2*dist.y));\n  vec3 n=normalFunc(rp,vec2(0.0,2E-3));\n  float edge=saturate(length(n-n2));\n  float gorge=dist.z;\n\n  o.xyz+=fog*0.1*vec3(15.0,1.0,1.5)*glow;\n  \n  if(dist.x<1E-3)\n  {\n    float ao=aoFunc(rp,n);\n    o.xyz+=fog*vec3((0.4-0.1*gorge)*ao);\n    o.xyz+=fog*edge*dist.y*vec3(15.0,1.0,1.5);\n    //o.xyz+=fog*gorge*vec3(2.0,15.0,5.0)*exp(-10.0*mod(time+dist.w,1.0));\n  }\n  \n  o.xyz+=length(p-po)*2.0*sin(3.0+4.0*o.x+vec3(0.0,2.0,4.0));\n  o.xyz=pow(o.xyz,vec3(0.4545));\n  o.xyz-=0.2*length(p);\n  o.xyz=vec3(\n    smoothstep(0.1,0.9,o.x),\n    linearstep(0.0,0.8,o.y),\n    smoothstep(-0.2,1.1,o.z)\n  );\n  o.xyz*=1.0+0.1*sin(vec3(0.,1.,2.)+fragCoord.y*2.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsccWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 501, 526, 526, 566], [568, 568, 582, 582, 622], [624, 624, 643, 643, 750], [752, 752, 788, 788, 841], [843, 843, 864, 864, 911], [913, 913, 951, 951, 1239], [1241, 1241, 1269, 1269, 1318], [1320, 1382, 1400, 1400, 2127], [2129, 2129, 2161, 2161, 2298], [2300, 2300, 2329, 2329, 2577], [2579, 2579, 2600, 2600, 2951], [2953, 2953, 3002, 3002, 4484]]}
{"id": "wsccWs", "name": "Hacking - Matrix", "author": "shadermonkey", "description": "Matrix effect\nUsing the custom texture below will display number instead, remember to change the limit to .1 if use this texture.\nhttps://www.projection-components.co.uk/ekmps/shops/trxgirl1/images/race-numbers-white-black-or-blue--877-p.jpg", "tags": ["math", "number", "shader", "green", "matrix", "hacking", "coding", "programming", "hacker", "whitehacker", "blackhacker"], "likes": 3, "viewed": 195, "published": "Public", "date": "1601974819", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hackGreen = vec3(0.,.3,0.);\nfloat limit = .5; // Change this value to .1 if use custom texture ( link below)\n//  https://www.projection-components.co.uk/ekmps/shops/trxgirl1/images/race-numbers-white-black-or-blue--877-p.jpg\nstruct Ray{\n    vec3 o;\n    vec3 d;\n};\nRay GetRay(vec2 uv, vec3 camPos, vec3 dir, float zoom){\n    Ray r;\n    r.o = camPos;\n    vec3 f = normalize(dir);\n    vec3 right = cross(vec3(.0,1.,.0), f);\n    vec3 u = cross(f,right);\n    \n    vec3 c = r.o + f*zoom;\n    vec3 i = c + uv.x *right + uv.y *u;\n    r.d = normalize(i -r.o);\n    return r;\n}\n\nvec4 GetPlane(vec3 n, vec3 p){\n    n = normalize(n);\n    float D = dot(n,p);\n    return vec4(n, D);\n}\n\nvec3 GetPointOnPlane(vec4 S, vec2 p){\n    return vec3(p.xy,(S.w-dot(S.xy,p))/S.z);\n}\n\nvec3 GetIntersectionPoint(Ray r, vec4 S){\n    float t = - (dot(r.o,S.xyz) + S.w)/(dot(r.d, S.xyz));\n    return r.o + t*r.d;\n}\n\nfloat SetNumber(Ray ray, int num, vec4 S, vec2 p,float size){\n    if(num < 0 || num > 9) return -1000000.;\n    //set Origin\n    float y;\n    float x;\n    if(num <= 4) {\n        y = .75;\n        x =  .1 + float(num) * .2;\n    } else {\n        y = .25;\n        x =  .1 + float(num - 5) * .2;\n    }\n    vec3 P = GetPointOnPlane(S,p);\n    vec3 c = vec3(x,y,P.z); // centre of the number\n    \n    //Cut boxes\n   \tvec3 ip = GetIntersectionPoint(ray, S);\n    vec3 d = ip - P;\n    d/= size;\n    if(abs(d.x) > .085) return 0.;\n    if(abs(d.y) > .235) return 0.;\n    \n    //Set color\n    vec3 st = c + d;\n   \tvec4 tex = texture(iChannel0, st.xy);\n    if(tex.x < limit && tex.y < limit && tex.z < limit){\n        return 1.;\n    } else return 0.;\n}\n\nfloat RandomFloat(float v){\n    return fract(cos(v*84.42)*343.42);\n}\nint RandomNumber(float v){ // 0 - 9\n    return int(RandomFloat(v)*10.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Init\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n    vec3 col = vec3(0.,.05,0.);\n    Ray ray = GetRay(uv, vec3(0.,0.,-10), vec3(0.,0.,1.), 1.);\n    float t = iTime;\n    float X = 7.;\n    float Y = 7.;\n    \n    for(float i = -X; i <= X; i+= .25){\n        float v = float(RandomNumber(i))/2. + 2.;\n        vec4 Surface = GetPlane(vec3(.5,-.0,-1.), vec3(0.,0.,0.));\n        bool isFade = RandomFloat(sin(i)) > 0.5;\n        float minY = RandomFloat(cos(i)) * Y ;\n        if(RandomFloat(sin(i*i)) > .5) minY*= -1.;\n        for(float j = -Y; j < Y; j += .5){\n            float y =j-v*t;\n            if(y < -Y){\n                y = ceil(abs(y + Y)/(Y*2.))*(Y*2.) + y;\n            }\n            vec3 color;\n            float k = t * 2.;\n            bool isLight = RandomFloat(tan(i - j) + (k - fract(k))) > 0.95;\n            color = isLight ? vec3(0.,1.,0.) : hackGreen ;\n            color *= (y - minY)/Y + hackGreen;\n            col += SetNumber(ray, RandomNumber(sin(i + j) - cos(i - j)), Surface, vec2(i,y), 1.) * color;\n        }\n    }\n    \n    //col = texture(iChannel0, uv).xyz;\n    //vec2 pos = vec2(iMouse.x, iMouse.y)/iResolution.xy;\n    //if(length(pos-uv) <.01) col += vec3(1.,0.,0.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGzr", "previewfilepath": "/media/ap/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/08b42b43ae9d3c0605da11d0eac86618ea888e62cdd9518ee8b9097488b31560.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsccWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 269, 324, 324, 571], [573, 573, 603, 603, 674], [676, 676, 713, 713, 760], [762, 762, 803, 803, 887], [889, 889, 950, 950, 1625], [1627, 1627, 1654, 1654, 1695], [1696, 1696, 1722, 1731, 1769], [1771, 1771, 1828, 1840, 3073]]}
{"id": "WscyDf", "name": "Basic Camera 3D", "author": "ferrazrx", "description": "Following this tutorial https://www.youtube.com/watch?v=PBxuVlp7nuM", "tags": ["camera"], "likes": 0, "viewed": 44, "published": "Public", "date": "1601834714", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float distanceBetweenPointAndRay(vec3 point, vec3 ro, vec3 rd){\n\treturn length(cross(point - ro, rd))/length(rd);\n}\n\nfloat drawPoint(vec3 point, vec3 ro, vec3 rd){\n     float d = distanceBetweenPointAndRay(point, ro, rd);\n    \n    d = smoothstep(0.05, 0.045, d);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    //Ray Origin\n    vec3 ro = vec3(cos(iTime),sin(iTime) * -9., -4.);\n    \n    //Look At\n    vec3 lookat = vec3(0., 0., 0.);\n    \n    //Forward\n    vec3 forward = normalize(lookat - ro);\n    \n    vec3 Yaxis = vec3(0.,1.,0.);\n   \n   \t//Right\n    vec3 right = cross(Yaxis, forward);\n    \n    //Up\n    vec3 up = cross(forward, right);\n    \n    //Zoom\n    float zoom = 1.;\n    \n    //Center\n    vec3 center = ro + (forward * zoom);\n    \n    // i\n    vec3 i = center + (uv.x * right) + (uv.y * up);\n    \n    //Ray Distance\n    vec3 rd = i - ro;\n    \n \tfloat d = 0.;\n    \n    d += drawPoint(vec3(-.5,.5,-.5), ro, rd);\n    d += drawPoint(vec3(.5,-.5,-.5), ro, rd);\n    d += drawPoint(vec3(-.5,-.5,.5), ro, rd);\n    d += drawPoint(vec3(-.5,-.5,-.5), ro, rd);\n    d += drawPoint(vec3(.5,.5,-0.5), ro, rd);\n    d += drawPoint(vec3(.5,-.5,.5), ro, rd);\n    d += drawPoint(vec3(-.5,.5,.5), ro, rd);\n    d += drawPoint(vec3(.5,.5,.5), ro, rd);\n \n    vec3 col = vec3(d,1.,1.);\n    \n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscyDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 115], [117, 117, 163, 163, 278], [281, 281, 337, 387, 1519]]}
{"id": "wscyDl", "name": "Blobajous", "author": "fewlinesart", "description": "Metaball + Lisajous", "tags": ["metaball", "blob", "lissajous"], "likes": 2, "viewed": 174, "published": "Public", "date": "1602869815", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define trajectoryR 0.4\n#define xShift 3.0\n#define yShift 3.0\n#define numBlobs 16.0\n#define threshold 9.0\n\nfloat ballThreshold(vec2 origin, float r, vec2 coord) {\n    return r / length(coord - origin);\n}\n\nvec3 blob(vec2 uv){\n    \n\tfloat total = 0.0;\n    \n    vec3 c = vec3(1.0);\n    for(float i = 0.0; i < numBlobs; i++) {\n        // Lissajous\n        //vec2 o = vec2(\n        //    cos(iTime + i * xShift * (iTime / 10.0)), \n        //    sin(iTime - i * yShift)\n        //) * trajectoryR; \n        \n        // Round\n        vec2 o = vec2(\n            cos((iTime * i) / 8. + i * xShift), \n            sin((iTime * i) / 8. + i * yShift)\n        ) * trajectoryR; \n    \t\n        float r = i / 57.0;\n        total += ballThreshold(o, r, uv);\n        c -= vec3(fract(total / 160.0));\n    }\n\t\n    // White on black\n    //vec3 color = vec3(1.0) - vec3(step(total, threshold));\n    \n    // Black on white (gradient)\n    //vec3 color = vec3(step(total, threshold)) + c;\n    \n    // Black on white (no gradient)\n    vec3 color = vec3(step(total, threshold));\n    \n    return color *= vec3(1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (2.0 * fragCoord.xy - iResolution.xy) / iResolution.y;\n    fragColor = vec4(blob(uv),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 162, 162, 203], [205, 205, 224, 224, 1087], [1089, 1089, 1146, 1146, 1253]]}
{"id": "WscyDs", "name": "Normal Map Stuff by Flyguy-v4", "author": "jorge2017a1", "description": "Normal Map Stuff by Flyguy-v4", "tags": ["normalmapstuffbyflyguyv4"], "likes": 4, "viewed": 59, "published": "Public", "date": "1601949030", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Normal Map Stuff */\n/* By: Flyguy */\n/* With help from http://stackoverflow.com/q/5281261 */\n\n// fancified a bit by psonice\n\n\n\n#define PI 3.141592\n\n vec2 mouse;\n\nvec3 heightmap(vec2 position)\n{\n\tfloat row = floor((position.y-15.)/100.);\n\tif (mod(row, 2.0) < 1.0)\n\t\tposition.x += 50.;\n\t\n\tfloat height = 0.0;\n\t\n\theight = sin(position.x*0.0625);\n\theight = clamp(height,0.0,0.5);\n\theight += clamp(sin(position.y*0.0625),0.0,1.0);\n\theight = clamp(height,0.0,0.5);\n\theight = 1.0 - height;\n\t\n\theight += height > 0.75 ? (max(acos(sin(position.x * .125 - PI * .5)) + asin(cos(position.y * .125 + PI)), 0.25) - 0.75) * .25 : 0.;\n\t\n\theight -= height > 0.0 && height < 0.55 ? (max(sin(position.x * .5 + PI * .5) + cos(position.y * .5 - PI *2.), 1.25) - 2.0) * 0.25 : 0.;\n\t\n\treturn vec3(position,height);\n}\n\t\nvec3 n1,n2,n3,n4;\nvec2 size = vec2(-0.4,0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    mouse.x=0.5+0.25*cos(iTime);\n    mouse.y=0.5+0.25*sin(iTime);\n\n\tvec2 pos = fragCoord.xy;\n\n\tvec3 color = vec3(0.0);\n\t\n\tvec2 off = vec2(pos.x,pos.y-1.0);\n\t\n\tn1 = heightmap(off);\n\t\n\toff = vec2(pos.x-1.0,pos.y);\n\t\n\tn2 = heightmap(off);\n\t\n\toff = vec2(pos.x+1.0,pos.y);\n\t\n\tn3 = heightmap(off);\n\t\n\toff = vec2(pos.x,pos.y+1.0);\n\t\n\tn4 = heightmap(off);\n\t\n\tvec3 va = normalize(vec3(size.xy,n2.z-n3.z));\n\tvec3 vb = normalize(vec3(size.yx,n1.z-n4.z));\n\t\n\tvec3 p2m = vec3(-((pos/iResolution.xy)-mouse.xy)*iResolution.xy,64.0);\t\n\t\n\tvec3 normal = vec3(cross(va,vb));\n\t\n\tcolor = vec3(dot(normal.xyz, p2m)/96.0);\n\t\n\tcolor *= vec3(clamp(1.0-distance(mouse.xy*iResolution.xy,pos)/iResolution.x*2.0,0.0,1.0));\n\t\n\tfragColor = vec4( vec3( color ), 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscyDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 165, 196, 196, 796], [846, 846, 903, 903, 1643]]}
{"id": "wscyWl", "name": "Planet w/ Atmosphere", "author": "Giraugh", "description": "Planet w/ atmosphere. Using ray-sphere intersection to compute points on the atmosphere.\nUsing fractional brownian motion to generate random noise for star distribution and planet height-map.", "tags": ["raymarch", "planet", "laggy"], "likes": 0, "viewed": 50, "published": "Public", "date": "1601968634", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* Simplest Possible Raymarcher */\n/* By Giraugh */\n\n#define MAX_STEPS 300\n#define MAX_DIST 1000.\n#define SURF_DIST 0.0005\n#define PI 3.14159\n#define ATMO_COL_DARK vec3(.05, .05, .3)\n#define ATMO_COL_BRIGHT vec3(.6, .9, .95)\n#define SEED 370.\n\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise( in vec2 p )\n{\n    const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n    const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n\tvec2  i = floor( p + (p.x+p.y)*K1 );\n    vec2  a = p - i + (i.x+i.y)*K2;\n    float m = step(a.y,a.x); \n    vec2  o = vec2(m,1.0-m);\n    vec2  b = a - o + K2;\n\tvec2  c = a - 1.0 + 2.0*K2;\n    vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\tvec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n    return dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv) {\n    uv *= .02;\n    mat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n    float f  = 0.5000*noise( uv ); uv = m*uv;\n    f += 0.2500*noise( uv ); uv = m*uv;\n    f += 0.1250*noise( uv ); uv = m*uv;\n    f += 0.0625*noise( uv ); uv = m*uv;\n    f += 0.01125*noise( uv ); uv = m*uv;\n    f += 0.005*noise( uv ); uv = m*uv;\n    return f;\n}\n\nmat2 Rot(float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\treturn mat2(\n    \tc, -s, s, c\n    );\n}\n\n// Return the distance to the nearest point in the scene\n// from (point)\nfloat GetDist(vec3 point) {\n    // Plane SDF at y=0\n    float planeD = point.y;\n    \n    // Sphere SDF at (0, 1, 4) w/ rad 1\n    float amp = .08;\n    float freq = 31.;\n    float n1 = ((2. * fbm(freq * point.xy + SEED))-1.);\n    float n2 = ((2. * fbm(freq * point.zx + SEED))-1.);\n    float r = 1. + (n1 + n2) * amp;\n    float sphereD = length(point - vec3(0, 0, 0)) - r;\n    float oceanD = (length(point - vec3(0, 0, 0)) - .87);\n    \n    return min(sphereD, oceanD) / 2.;\n}\n\n// March a ray forwards into the scene determined by (GetDist)\n// Returns the distance the ray travelled before getting\n// below (SURF_DIST) distance from a surface or too far away \nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection) {\n    float d = 0.;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = rayOrigin + rayDirection * d;\n        float d_delta = GetDist(p);\n        d += d_delta;\n        if (d > MAX_DIST || abs(d_delta) < SURF_DIST) break; \n    }\n    return d;\n}\n\n// Calculate the surface normal at (point)\n// can reduce (off) to improve accuracy\nvec3 GetNormal(vec3 point) {\n    float d = GetDist(point);\n    float off = .01;\n    vec3 n = vec3(\n    \td - GetDist(point - vec3(off,0,0)),\n        d - GetDist(point - vec3(0,off,0)),\n        d - GetDist(point - vec3(0,0,off))\n    );\n    return normalize(n);\n}\n\n// Determine degree of lighting (0 to 1) at (pos) by (lightPos)\nfloat GetLighting(vec3 point, vec3 lightPos, vec3 n) {\n    vec3 l = normalize(lightPos - point);\n    float diff = clamp(dot(l, n), 0., 1.);\n    return diff;\n}\n\n// Get specular highlight\nfloat GetLightingPhong(vec3 point, vec3 view, vec3 lightPos, float shininess) {\n\tvec3 l = normalize(lightPos - point);\n    vec3 n = GetNormal(point);\n    vec3 r = 2. * n * dot(n, l) - l;\n    \n    if (dot(n, l) < 0.0) {\n        return 0.;\n    } else {\n    \treturn .3 * pow(max(0., dot(r, normalize(-view))), shininess);\n    }\n}\n\n// Returns 1. for intersect 0. for no intersect\nfloat RaySphereIntersectLength(vec3 ro, vec3 rd, vec3 so, float r) {\n    // calculate nearest point on ray to sphere (p)\n    float t = dot(so - ro, rd);\n   \tvec3 p = ro + t * rd;\n    \n    // y is dist from sphere to nearest point\n    float y = length(so - p);\n    \n    // x is dist from intersection point to p\n    float x = sqrt(pow(r, 2.) - pow(y, 2.));\n    float w = 2. * x;\n    return w;\n}\n\nfloat RaySphereIntersectDist(vec3 ro, vec3 rd, vec3 so, float r) {\n    // calculate nearest point on ray to sphere (p)\n    float t = dot(so - ro, rd);\n   \tvec3 p = ro + t * rd;\n    \n    // y is dist from sphere to nearest point\n    float y = length(so - p);\n    \n    // x is dist from intersection point to p\n    float x = sqrt(pow(r, 2.) - pow(y, 2.));\n    \n    // Get point of intersection\n    vec3 i = ro + (t - x) * rd;\n    \n    return length(ro - i);\n}\n\nvec3 Atmosphere(vec3 ro, vec3 rd, vec3 so, float r, vec3 lightPos, float depth) {    \n    // calculate nearest point on ray to sphere (p)\n    float t = dot(so - ro, rd);\n   \tvec3 p = ro + t * rd;\n    \n    // y is dist from sphere to nearest point\n    float y = length(so - p);\n    \n    // x is dist from intersection point to p\n    float x = sqrt(pow(r, 2.) - pow(y, 2.));\n    \n    // If it doesn't intersect then no atmosphere here\n    if (y > r) {\n    \treturn vec3(0);\n    }\n    \n    // Calculate intersection width\n    float t1 = max(t - x, 0.);\n    float t2 = min(t + x, depth);\n    float w = max(0., t2 - t1) / (r / 2.);\n    \n    // Get point of intersection\n    vec3 atmoI = ro + (t - x) * rd;\n    \n    // Find point to sample light\n    // this is some hacks to spread the light out more over the sphere\n    vec3 samplePoint = ro + min(t, t2) * rd;\n    vec3 normal = normalize(samplePoint - so);\n    vec3 lightDir = normalize(lightPos - samplePoint);\n    float luminance = max(dot(lightDir, normal), 0.);\n    \n    vec3 atmoCol = mix(ATMO_COL_DARK, ATMO_COL_BRIGHT, luminance);\n    \n    return vec3(atmoCol * min(2., w * luminance));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (square) (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy)/iResolution.y;\n\n    // Declare camera position in terms of ray origin and direction\n    vec3 rayOrigin = vec3(0, 0, 0);\n    vec3 rayDirection = normalize(vec3(uv.x, uv.y, 1));\n    \n\t// rotate the view\n    //rayOrigin.xz *= Rot(iTime);\n    float ang = 2. + iTime / 4.;\n    float viewDist = 4.;\n    rayOrigin.x += cos(ang) * viewDist;\n    rayOrigin.z += sin(ang) * viewDist;\n    \n    // look at center\n    rayDirection.xz *= Rot(ang + PI/2.);\n    \n    // RayMarch to find point\n    float dist = RayMarch(rayOrigin, rayDirection);\n    vec3 hitPoint = rayOrigin + dist * rayDirection;\n    \n    // Determine lighting\n    vec3 lightPos = vec3(-12, 6, 1);\n    vec3 normal = GetNormal(hitPoint);\n    float lighting = GetLighting(hitPoint, lightPos, normal);\n    if (dist < 50.) lighting += .01;\n\tvec3 col = vec3(0);\n    \n    // Colour Terrain\n    if (dist < 100.) {\n     \tfloat pd = length(hitPoint);\n        \n        // Grass\n        col = vec3(.2, .7, .3) * (1. - ((smoothstep(.9, .92, pd)) * .3));\n        \n        // Mountains\n        if (pd > 0.913) {\n            //col = vec3(.2, .8, .3) * .6;\n        }\n        \n        // Sand\n        if (pd <= .887) {\n            col = mix(vec3(.7, .8, .5), vec3(.2, .7, .3), smoothstep(.872, .887, pd));\n        }\n        \n        // Water\n        if (pd <= .874) {\n        \tcol = vec3(.1, .15, 1) * mix(.3, .8, (pd - .7) / .05);\n            col += 2. * GetLightingPhong(hitPoint, rayDirection, lightPos, 30.);\n        }\n    }\n    \n    col = col * lighting;\n    \n    // Atmosphere\n    vec3 atmoOrigin = vec3(0, 0, 0);\n    float atmoRadius = 1.1;\n    vec3 atmosphere = Atmosphere(\n        rayOrigin,\n        rayDirection,\n        atmoOrigin,\n        atmoRadius,\n        lightPos,\n    \tdist\n    );\n    \n    col += atmosphere;\n        \n    \n    // Stars\n    if (dist > 100.) {\n        float noiseX = fbm(rayDirection.xy * 500.);\n        float noiseY = fbm(rayDirection.yz * 500.);\n        vec2 samp = 25. * rayDirection.xy + vec2(noiseX, noiseY);\n        if (mod(samp.x, 2.) < 0.08 && mod(samp.y, 2.) < 0.05) {\n            col += vec3(.7) * max(0., sin(iTime + fbm(samp.xy) * 100.));\n        }\n    }\n    \n\t// A sun\n    if (dist > 100.) {\n        float sun = max(0., dot(rayDirection, normalize(lightPos - rayOrigin)) - 0.97);\n        col += (pow(sun, .75) * 35.) * vec3(1, .8, .6);\n        col += max(0., dot(rayDirection, normalize(lightPos - rayOrigin)) - .8) * vec3(1, .8, .6);\n    }\n    \n    // Ouput colour at full transparency\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscyWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 244, 265, 265, 380], [382, 382, 408, 408, 887], [889, 889, 909, 909, 1230], [1232, 1232, 1251, 1251, 1329], [1331, 1404, 1431, 1455, 1877], [1879, 2061, 2112, 2112, 2361], [2363, 2446, 2474, 2474, 2706], [2708, 2772, 2826, 2826, 2930], [2932, 2958, 3037, 3037, 3284], [3286, 3334, 3402, 3454, 3727], [3729, 3729, 3795, 3847, 4186], [4188, 4188, 4269, 4325, 5328], [5331, 5331, 5388, 5447, 7991]]}
{"id": "wsdcDj", "name": "Plasma effect OldSkool", "author": "GCScholar", "description": "An old school plasma effect. \n\nThe tutorial for the effect I used: https://www.bidouille.org/prog/plasma for the tutorial on the effect. Tnx :)\n", "tags": ["oldschool", "plasma", "old", "school"], "likes": 3, "viewed": 77, "published": "Public", "date": "1601802711", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Tnx to https://www.bidouille.org/prog/plasma for the tutorial on the effect\n\n#define PI 3.14\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Plasma is the sum of three sinusoids\n    float w1 = sin(10.0*uv.x+iTime);\n    float w2 = sin(10.0*(uv.x*sin(iTime/2.0)+uv.y*sin(iTime/3.0))+iTime);\n    vec2 c = vec2(uv.x+sin(iTime*0.5), uv.y+cos(iTime*0.33));\n    float w3 = sin(sqrt(100.0*(c.x*c.x+c.y*c.y)+1.0)+iTime);\n        \n\tfloat w = (w1+w2+w3)/2.0;\n    \n    vec3 col = vec3(sin(PI*w), sin(PI*w+2.0*PI/(3.0+sin(iTime))), cos(PI*w+4.0*PI/(4.0+sin(iTime))));\n    fragColor = vec4(col*0.5 + 0.5,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdcDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 97, 154, 154, 659]]}
{"id": "WsdcDS", "name": "papa flamy DE xD ftw lül xyz", "author": "Nischi", "description": "flamy", "tags": ["papa"], "likes": 2, "viewed": 31, "published": "Public", "date": "1601644565", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Ei(float x){\t\t//Exponential Integral\n    float gamma = 0.57721566490153286060;\n    float result = gamma+log(abs(x));\n    \n    float tmp = 1.;\n    for(float k=1.;k<1000.;k++){\n        tmp = tmp*x/k;\n        result += tmp/k;\n    }\n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //Constants to vary\n    float C = sin(iTime);\n    float scale = 5.;\n\n    //Coordinate transformation from pixels\n    vec2 uv = scale*(2.*fragCoord-iResolution.xy)/iResolution.y;\n    \n    //Implicit function\n    float t = uv.x;\n    float y = uv.y;\n    float f = Ei(log(abs(y+1.))+C)-t*1.-0.;\n    \n    //Function plot\n    fragColor = vec4(abs(f)/fwidth(f))*vec4(0,1,1,1)+vec4(1,0,0,0);\n    \n    //Coordinate system\n    if ( min( abs(uv.x), abs(uv.y) ) < 8./iResolution.y ) fragColor *= 0.;\n    fragColor *= smoothstep( 0., 1.5, length(uv-vec2(1,0))*iResolution.y/8.- 4.);\n    fragColor *= smoothstep( 0., 1.5, length(uv-vec2(0,1))*iResolution.y/8.- 4.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdcDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 42, 255], [257, 257, 314, 338, 972]]}
{"id": "WsdyDX", "name": "Oscillating Voronoi Blobs", "author": "keshav2010", "description": ":) ", "tags": ["voronoi", "glsl"], "likes": 2, "viewed": 80, "published": "Public", "date": "1601888347", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//voronoi\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    const int pointCount=15;\n    \n    //increase power to decrease blending.\n    float power = 2.7;\n    \n    float rate=1. - 0.8*sin(iTime)*sin(iTime);\n    \n    \n    vec2 points[pointCount] = vec2[pointCount](\n    vec2( 0.5 + 0.15*sin(iTime)*rate, 0.5 - 0.25*cos(iTime)*rate), \n    vec2( 0.25 + 0.2*sin(iTime*3.)*rate , 0.8 + 0.2*sin(iTime*3.)*rate),\n    vec2( 0.635+ 0.2*sin(iTime*3.)*rate , 0.7 + 0.2*sin(iTime)*rate),\n    vec2( 0.3+ 0.12*sin(iTime*3.)*rate  , 0.3 + 0.1*sin(iTime)*rate),\n    vec2( 0.5+ 0.2*sin(iTime*2.5)*rate, 0.5 + 0.2*sin(iTime)*rate),\n    vec2( 0.8+ 0.15*sin(iTime*3.)*rate, 0.6 + 0.15*sin(2.*iTime)*rate),\n    vec2( 0.8 + 0.2*sin(iTime*3.)*rate  , 0.5 + 0.2*sin(iTime)*rate),\n    vec2( 0.45 + 0.4*sin(iTime*1.5)*rate, 0.9 + 0.8*sin(iTime)*rate),\n    vec2( 0.15 + 0.12*sin(iTime*2.)*rate, 0.9 + 0.12*sin(iTime)*rate),\n    vec2( 0.4 + 0.12*sin(iTime*2.)*rate, 0.1 + 0.12*sin(iTime)*rate),\n    vec2( 0. + 0.12*sin(iTime*2.)*rate, 0. + 0.41*sin(iTime)*sin(iTime)*rate),\n    vec2( 1. + 0.12*sin(iTime*2.)*rate, 0. + 0.41*sin(iTime)*sin(iTime)*rate),\n    vec2( 0. + 0.12*sin(iTime*2.)*rate, 1. - 0.41*sin(iTime)*sin(iTime)*rate),\n    vec2( 1. + 0.12*sin(iTime*2.)*rate, 1. - 0.41*sin(iTime)*sin(iTime)*rate),\n    vec2( 0. + 1.*sin(iTime)*sin(iTime), 0.5)\n   );\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\tuv.x -= 0.4;\n    \n    float minDist=2.;\n    for(int i=0; i < pointCount; i++){\n    \tminDist = min(distance(uv.xy, points[i]), minDist);      \n    }\n    \n    vec3 col = vec3(1.-minDist, 0.7-minDist,.7 -minDist);\n    \n    \n    col.x = pow(col.x, power);\n    col.y = pow(col.y, power);\n    col.z = pow(col.z, power);\n \t\n \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdyDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 10, 30, 30, 102], [104, 104, 161, 161, 1912]]}
{"id": "wsdyWj", "name": "Circle inversion on a square", "author": "dub", "description": "Demonstration of the circle inversion on a square\nBlue square: square in real plane\nBlue circle: unitary circle that makes the plane inversion\nRed square: square in the inverted plane", "tags": ["2d", "square", "inversion"], "likes": 4, "viewed": 64, "published": "Public", "date": "1601787424", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Demonstration of the circle inversion on a square\n// Blue square: square in real plane\n// Blue circle: unitary circle that makes the plane inversion\n// Red square: square in the inverted plane\n\n#define TH 0.01\n#define COS_PI4 0.70710678118\n\nconst mat2 rot45 = mat2(COS_PI4, COS_PI4, -COS_PI4, COS_PI4);\n\nfloat square(vec2 uv, float s)\n{\n    uv *= rot45;\n    uv.y = abs(uv.y);\n    uv *= rot45;\n    uv.y = abs(uv.y);\n    uv *= rot45;\n    uv.y = abs(uv.y);\n    uv *= rot45;\n    uv = uv.yx;\n    \n    uv.y = abs(uv.y);\n    uv.y -= s;\n    return smoothstep(TH, TH*2., abs(uv.y));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 UV = (fragCoord*2. - iResolution.xy)/iResolution.y;\n\n    float v1, v2, c;\n    \n    {   // real plane\n        vec2 uv = UV;\n\n        uv*=2.;\n        \n        v1 = smoothstep(TH, TH*2., abs(length(uv)-1.));\n\n        uv.x +=(sin(iTime)*1.+1.);\n        v1 *= square(uv, 0.6);\n    }\n    \n    {   // inverted plane\n        vec2 uv = UV;\n\n        uv*=2.;\n        uv /= dot(uv, uv);\n\n        uv.x +=(sin(iTime)*1.+1.);\n        v2 = square(uv, 0.6);\n    }\n    \n    vec3 col = mix(vec3(v1, v1, 1.), vec3(1., v2, v2), .5);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 307, 339, 339, 578], [580, 580, 637, 637, 1192]]}
{"id": "Wsdyzs", "name": "Fall Guys Menu Background", "author": "p5ina", "description": "This is fall guys menu background shader", "tags": ["background", "fall", "guys"], "likes": 1, "viewed": 98, "published": "Public", "date": "1601551791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 Scale1 = vec3(15, 0.4, 0.975);\n    vec3 Scale2 = vec3(25, 0.8, 0.5);\n    vec3 Scale3 = vec3(75, 3.2, 0.8);\n    \n    vec3 Color1 = vec3(1, 0.67256093, 0);\n    vec3 Color2 = vec3(1, 0.7411765, 0);\n    vec3 Color3 = vec3(1, 0.7411765, 0);\n    \n    float pos = length((fragCoord - iResolution.xy * 0.5) / iResolution.yy);\n    float f1 = sin(pos * Scale1.x - iTime * Scale1.y);\n    float f2 = sin(pos * Scale2.x - iTime * Scale2.y);\n    float f3 = sin(pos * Scale3.x - iTime * Scale3.y);\n   \tvec3 col = vec3(1, 0.8078432, 0);\n\n    if (f1 > Scale1.z) {\n        col = Color1;\n    }              \n    else if (f2 > Scale2.z) {\n        col = Color2;\n    }\n    else if (f3 > Scale3.z) {\n    \tcol = Color3;\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wsdyzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 826]]}
{"id": "wsGcRG", "name": "Example 46 - raytrace waffles", "author": "jt", "description": "Simple & inefficient way to raytrace a heightmap-function with normals.", "tags": ["raytracing", "example", "waffles"], "likes": 1, "viewed": 42, "published": "Public", "date": "1603100512", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define pi 3.1415926\n\nvec2 lookup(vec2 p)\n{\n    return (p + vec2(iTime, 0.0));\n}\n\nfloat heightmap(vec2 p)\n{\n    vec2 l = lookup(p);\n    //return 0.5 * (0.5 + 0.5 * sin(l.x * 2.0 * pi) * sin(l.y * 2.0 * pi)); // waves\n    return 0.5 * (1.0 - abs(sin(l.x * 2.0 * pi)) * abs(sin(l.y * 2.0 * pi))); // waffles\n    //return 0.5 * ((1.0 - abs(sin(l.x * 2.0 * pi))) * (1.0 - abs(sin(l.y * 2.0 * pi)))); // spikes\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 d = vec3(2.0 * fragCoord/iResolution.xy - 1.0, 1.0);\n    \n    fragColor = vec4(0.0, 0.0, 0.5, 1.0);\n    \n    float s = 0.001;\n    s /= abs(d.y); // larger step-size for shallow rays\n    for(vec3 q = vec3(0.0); abs(q.y) < 1.0; q += d * s)\n    {\n        float c = heightmap(q.xz);\n        float h = 1.0 * c - 1.0;\n        if(q.y < h)\n        {\n            float W = heightmap(q.xz + vec2(-1.0,0.0)/iResolution.xy);\n            float O = heightmap(q.xz + vec2(+1.0,0.0)/iResolution.xy);\n            float S = heightmap(q.xz + vec2(0.0,-1.0)/iResolution.xy);\n            float N = heightmap(q.xz + vec2(0.0,+1.0)/iResolution.xy);\n            vec3 n = normalize(vec3(O - W, N - S, 0.01));\n            //fragColor = vec4(c);\n            //fragColor = vec4(n.z);\n            float brightness = dot(n, normalize(vec3(1.0, 0.0, 1.0))); // lighting\n            fragColor = vec4(brightness); \n            break;\n        }\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGcRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 43, 43, 80], [82, 82, 107, 107, 407], [409, 409, 466, 466, 1394]]}
{"id": "wsGcWK", "name": "Desert canyons", "author": "jarble", "description": "This canyon has many unusual rock formations. This is an edit of my [url=https://www.shadertoy.com/view/wdKyDG]\"Cratered moonscape\"[/url] fractal terrain.", "tags": ["fractal", "desert", "canyon"], "likes": 1, "viewed": 198, "published": "Public API", "date": "1603742794", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 400;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\nconst float size = 1000.0;\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\nvec3 warp(vec3 a){\n    return (sin(a)+cos(a));\n}\n\nfloat planet_surface(vec3 p){\n    p /= 10.0;\n    //p /= 100.0;\n    p += warp(p.yzx/size)*size;\n    vec3 p1 = p/size;\n    p = (sin(p1.yzx+(length(sin(p/100.0))+sin(p1.yxz))))*size;\n    return (length(p) + p.y - size)*5.0;\n}\n\n\n\nfloat sceneSDF(vec3 p) {\n    p /= .01;\n\n\n    float result = 0.0;\n    float i = 1.0;\n    //p *= 2.0;\n    for(int k = 0; k < 3; k++){\n        result -= min(-result,planet_surface(p*i))/(i*i);\n        i *= -1.5;\n        //p *= -1.0001;\n        //i /= 2.0;\n        //i /= -3.0;\n        //p *= 3.0;\n        //i /= 3.0;\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return (result-p.y*2.0)/2000.0;\n}\n\nvec3 surface_color(vec3 p)\n{\n    p /= 10.0;\n    return sin(vec3(planet_surface(p)*2.0+.5,planet_surface(p)*2.0,planet_surface(p*10.0)*2.0))/12.0+vec3(.7,.5,.3)*1.6;\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth;\n        }\n        depth += dist;\n        eps *= 1.001;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n\n    \n    float speed = 10.0;\n    float t1 = iTime/20.0+10.0;\n\tvec3 eye = vec3(100.0*t1,-10,0);\n    \n    mat3 viewToWorld = -viewMatrix(eye, eye+vec3(-3.0, -1.0, 3.0*sin(t1/3.0)), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGcWK.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[278, 519, 537, 537, 567], [569, 569, 598, 598, 791], [795, 795, 819, 819, 1214], [1216, 1216, 1244, 1244, 1382], [1385, 1806, 1897, 1897, 2258], [2273, 2527, 2592, 2592, 2724], [2726, 2815, 2844, 2844, 3154], [3156, 3648, 3788, 3788, 4398], [4400, 4770, 4855, 4855, 5270], [5272, 5599, 5648, 5683, 5814], [5816, 5816, 5873, 5873, 6829]]}
{"id": "wsGcWt", "name": "Color Weave - Polar", "author": "BackwardsCap", "description": "@@@", "tags": ["colors", "sin", "cos"], "likes": 3, "viewed": 240, "published": "Public API", "date": "1603997009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Color Weave\" by BackwardsCap. https://shadertoy.com/view/tlKGRc\n\nfloat rand (vec2 p)\n{\n    return fract(sin(dot(p.xy,vec2(12389.1253,8941.1283)))*12893.128933);\n}\n\nvoid mainImage( out vec4 c, in vec2 f )\n{\n    vec2 uv = (2.*f-iResolution.xy)/iResolution.y/1.5;\n    uv = vec2(atan(uv.x,uv.y),length(uv));\n    uv.y-=.4+(.25*sin(iTime*.1));\n    vec3 o = vec3(0);\n    \n    uv.x+=iTime;\n    \n    for(float i=-5.,id=0., T=iTime*.075;i<5.;i+=.15,id++)\n    {\n        uv.y *= 1.025;\n        uv.x -= .35*T;\n        float l = abs(uv.y + sin(uv.x+T)/1.-sin(cos(uv.x+T/50.))/2.);\n        o += smoothstep((20.+i*1.)/iResolution.y,0.,l);\n        o *= 1.2 * vec3((0.5+(0.5*rand(vec2(1.,id)))),\n                        (0.5+(0.5*rand(vec2(id+i/2.0,id)))),\n                        (0.5+(0.5*rand(vec2(id-i,10.5)))));\n    }\n    \n    \n    c.rgb = (o+pow(o.b,2.0)*.2);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGcWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 77, 98, 98, 174], [176, 176, 217, 217, 861]]}
{"id": "wsGczd", "name": "corona2", "author": "deaths_angel", "description": "v2 https://www.shadertoy.com/view/wsyyzt", "tags": ["field", "spikes", "accumulation", "virus"], "likes": 4, "viewed": 103, "published": "Public", "date": "1603481387", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n\tFiery Spikeball\n\t---------------\n\n\tMaking some modifications to Duke's \"Cloudy Spikeball\" port to produce a fiery version.\n\n\tI trimmed the original shader down a bit, changed the weighting slightly, made a couple of \n\tsacrifices to the spike shape to tighten up the distance equation, etc.\n\n\n\tCloudy Spikeball - Duke\n\thttps://www.shadertoy.com/view/MljXDw\n\n    // Port from http://glslsandbox.com/e#1802.0, with some modifications.\n    //--------------\n    // Posted by Las\n    // http://www.pouet.net/topic.php?which=7920&page=29&x=14&y=9\n\t// By the way, the demo is really good. Definitely worth watching.\n\n\n*/\n\n\nmat2 rM; // Rotation matrix.\nvec2 a;\n\n// IQ's noise\nfloat pn(in vec3 p){\n\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(3.0 - 2.0*p);\n    vec2 uv = (ip.xy + vec2(37.0, 17.0)*ip.z) + p.xy;\n    uv = texture(iChannel0, (uv+ 0.5)/256.0, -100.0).yx;\n    return mix(uv.x, uv.y, p.z);\n}\n\n// FBM\nfloat fpn(vec3 p){\n    return pn(p*.6125)*0.1*max(1.,cos(iTime)) + pn(p*.125)*0.3*sin(iTime) + pn(p*.25)*.65*sin(iTime);\n}\n\n// Spikeball. Using 16 hardcoded points, reflected to give 32 spikes in all.\nfloat spikeball(vec3 p) {\n   \n    // Ball\n    float d = length(p) - 0.6;\n\tfloat ao = (0.5 * (cos(iTime) + 1.));\n    //    float o = (0.035 * ao * ao);\n    float o = 0.0;\n    // Spikes\n    p = normalize(p);\n    vec4 b = max(max(max(\n        abs(vec4(dot(p,vec3(0.526 + o,0.000,0.851)), dot(p,vec3(-0.526,0.000,0.851)),dot(p, vec3(0.851,0.526,0.000)), dot(p,vec3(-0.851,0.526,0.000)))),\n        abs(vec4(dot(p,vec3(0.357+o,0.934,0.000)), dot(p,vec3(-0.357+o,0.934,0.000)), dot(p, vec3(0.000,0.851,0.526)), dot(p,vec3(0.000,-0.851,0.526))))),\n                     abs(vec4(dot(p,vec3(0.000,0.357 + o,0.934)), dot(p,vec3(0.000,-0.357 - o,0.934)), dot(p, vec3(0.934,0.000,0.357)), dot(p,vec3(-0.934,0.000,0.357))))),\n                 abs(vec4(dot(p,vec3(0.577 + o,0.577 + o,0.577 + o)), dot(p,vec3(-0.577,0.577,0.577)), dot(p, vec3(0.577,-0.577,0.577)), dot(p,vec3(0.577,0.577,-0.577)))));\n    b.xy = max(b.xy, b.zw);\n    b.x = pow(max(b.x, b.y), 64.);\n\n\n    return d - exp2(b.x*(sin(iTime+1.)*0.25 + 0.75));\n}\n\n\n// Distance function.\nfloat map(vec3 p) {\n    \n    \n    //float c = cos(iTime), s = sin(iTime);\n    //p.xy=c*p.xy+s*vec2(p.y, -p.x); // Rotate p.xy\n    //p.xz=c*p.xz+s*vec2(p.z, -p.x); // Rotate p.xz\n    \n    // Performs the same as above. \"rM\" is produced just once, before the raymarching loop.\n    // I think it'd be faster, but GPUs are strange, so who knows.\n    // Duke tells me that \"r *= rM\" can break in some older browsers. Hence, the longhand.\n    p.xy = p.xy*rM;\n    p.xz = p.xz*rM;\n\n    return spikeball(p) +  fpn(p*50. + iTime*15.)*0.8;\n}\n\n// See \"Combustible Voronoi\"\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 1400. + 1000.*i + 200. * (0.5 * (1. + sin(iTime))); // Temperature range (in Kelvin).\n    vec3 L = vec3(7.4 * (0.5 * (sin(iTime) + 1.)), 7.6, 7.4* (0.5 * (cos(iTime) + 1.)) ); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(5.0)) * (exp(1.43876719683e5/(T*L))-1.0);\n    return 1.0 - exp(-2e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n  \n   // p: position on the ray\n   // rd: direction of the ray\n   //\n   // Trimmed \"rd\" down. Plus, moved \"ro\" back 6 units to get rid of the \"p.z += 6\" line\n   // in the distance equation. Also, reversed the Z-coordinates, because it's a personal preference.\n   vec3 rd = normalize(vec3((fragCoord.xy - 0.5*iResolution.xy)/iResolution.y, 1.));\n   vec3 ro = vec3(0., 0., -8.);\n   \n   // ld, td: local, total density \n   // w: weighting factor\n   float ld = 0., td = 0., w;\n\n   // t: length of the ray\n   // d: distance function\n   float d = 1., t = 0.;\n   \n   // Distance threshold.\n   const float h = .01;\n    \n   // total color\n   vec3 tc = vec3(0.);\n    \n    \n   // Setting up the matrix outside of the loop, which might save a few cycles.\n   float cs = cos(iTime*0.4), si = sin(iTime*0.4);\n   rM = mat2(cs, si, -si, cs);\n    //p.xy=c*p.xy+s*vec2(p.y, -p.x); // Rotate p.xy\n    //p.xz=c*p.xz+s*vec2(p.z, -p.x); // Rotate p.xz\n    \n   // Tidied the raymarcher up a bit. Plus, got rid some redundancies... I think.\n\n   // rm loop\n   for (int i=0; i<64*64*64; i++) {\n\n      // Loop break conditions. Seems to work, but let me know if I've \n      // overlooked something. The middle break isn't really used here, but\n      // it can help in certain situations.\n      if(td>(1. - 1./200.) || d<0.001*t || t>1200.)break;\n       \n      // evaluate distance function\n      // Took away the \"0.5\" factor, and put it below. \n      d = map(ro + t*rd); \n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      //const float h = .1;\n      ld = (h - d) * step(d, h);\n      w = (1. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w*w + 1./100.;  // Different weight distribution.\n      td += w + 1./200.;\n\n      \n      // enforce minimum stepsize\n      d = max(d, 0.04); // Increased the minimum, just a little.\n      \n      // step forward\n      t += d*0.5;\n      \n   }\n\n   // Fire palette.\n   tc = firePalette(tc.x);\n    \n   // No gamma correction. It was a style choice, but usually, you should have it.   \n   fragColor = vec4(tc, 1.0); //vec4(tc.x+td*2., ld*3., 0, tc.x);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGczd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[658, 672, 692, 692, 907], [909, 916, 934, 934, 1038], [1040, 1117, 1142, 1158, 2122], [2125, 2147, 2166, 2579, 2677], [2679, 2749, 2775, 2775, 3192], [3195, 3195, 3249, 3509, 5398]]}
{"id": "wsGczz", "name": "Irreptile Triangle Zoom", "author": "tdhooper", "description": "Recursively tiling this hexadrafter irreptile from George Sicherman [url]https://userpages.monmouth.com/~colonel/drirrep/index.html[/url]\n\nFork of [url]https://www.shadertoy.com/view/tddyWl[/url]", "tags": ["irreptile"], "likes": 17, "viewed": 355, "published": "Public API", "date": "1602111181", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Irreptile Triangle Zoom\n    -----------------------\n\n    Recursively tiling this hexadrafter irreptile from George Sicherman\n    https://userpages.monmouth.com/~colonel/drirrep/index.html\n\n\tForked from https://shadertoy.com/view/tddyWl\n\n*/\n\n// Polygon distance, iq https://www.shadertoy.com/view/wdBXRW\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat cross2d( in vec2 v0, in vec2 v1) { return v0.x*v1.y - v0.y*v1.x; }\n\nconst int N = 6;\n\nfloat sdPoly( in vec2[N] v, in vec2 p )\n{\n    const int num = v.length();\n    float d = dot(p-v[0],p-v[0]);\n    float s = 1.0;\n    for( int i=0, j=num-1; i<num; j=i, i++ )\n    {\n        // distance\n        vec2 e = v[j] - v[i];\n        vec2 w =    p - v[i];\n        vec2 b = w - e*clamp( dot(w,e)/dot(e,e), 0.0, 1.0 );\n        d = min( d, dot(b,b) );\n\n        // winding number from http://geomalgorithms.com/a03-_inclusion.html\n        bvec3 cond = bvec3( p.y>=v[i].y, p.y<v[j].y, e.x*w.y>e.y*w.x );\n        if( all(cond) || all(not(cond)) ) s*=-1.0;  \n    }\n    \n    return s*sqrt(d);\n}\n\n\n// Spectrum palette, iq https://www.shadertoy.com/view/ll2GD3\n\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d ) {\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 spectrum(float n) {\n    return 1. - pal( n, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67) );\n}\n\n\n\n// MATRIX\n\nmat3 trs(vec2 t) {\n\treturn mat3(1, 0, t.x, 0, 1, t.y, 0, 0, 1);\n}\n\nmat3 rot(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\nmat3 scl(vec2 s) {\n\treturn mat3(s.x, 0, 0, 0, s.y, 0, 0, 0, 1);\n}\n\nvec2 mul(vec2 p, mat3 m) {\n   return (vec3(p, 1) * m).xy;\n}\n\nvec2 mul(mat3 m, vec2 p) {\n   return (m * vec3(p, 1)).xy;\n}\n\n/*\nfloat decomposeScale(mat3 m) {\n    mat2 m2 = mat2(m);\n\tvec2 a = vec2(0,0) * m2;\n\tvec2 b = vec2(1,0) * m2;\n    return distance(a, b);\n}\n\n// I made this up as I went along, there are probably faster methods?\nvoid decompose(mat3 m, out vec2 translation, out float rotation, out float scale) {\n    mat2 m2 = mat2(m);\n\tvec2 a = vec2(0,0) * m2;\n\tvec2 b = vec2(1,0) * m2;\n\tvec3 c = vec3(0,0,1) * m;\n    translation = c.xy;\n    scale = distance(a, b);\n    rotation = -acos(dot(normalize(b), vec2(1,0)));\n}\n*/\n\n// Optimisations thanks to FabriceNeyret2\n\nfloat decomposeScale(mat3 m) {\n\tvec2 a = vec2(1,0) * mat2(m);\n    return length(a);\n}\n\nvoid decompose(mat3 m, out vec2 translation, out float rotation, out float scale) {\n\tvec2 a = vec2(m[0][0], m[1][0]);\n    translation = vec2(m[0][2], m[1][2]);\n    scale = length(a);\n    rotation = -acos(a.x / scale); // we don't know the real sign, so negating it as a hack\n}\n\n\n// Logarithmic Spiral Center\n// https://www.shadertoy.com/view/tscBDH\nvec2 spiralCenter(vec2 translation, float rotation, float scale) { \n    float l = sqrt(scale * scale - 2. * scale * cos(rotation) + 1.);\n    float S = sin(rotation) * scale / l;\n    float C = sqrt(1. - S * S);\n    return mat2(-S, C, C, S) * translation.yx / l;\n}\n\n\n\n// MAIN\n\nvec2 rotate(vec2 p, float a) {\n    return cos(-a)*p + sin(-a)*vec2(p.y, -p.x);\n}\n\n#define PI 3.1415926\n\nconst int count = 11;\nmat3 tiles[count];\nconst int ITERATIONS = 5;\n//#define ZOOM_OUT\n//#define LOOP\n\nfloat h = sqrt(3.) / 2.;\n\nfloat sdTile(vec2 p) {\n    vec2[] poly = vec2[](\n    \tvec2(0, 0),\n        vec2(2.5, 0),\n        vec2(2.5 - .25, -h / 2.),\n        vec2(1.5 - .25, -h / 2.),\n        vec2(1., -h),\n        vec2(.5, -h)\n    );\n\treturn sdPoly(poly, p);\n}\n\nfloat time;\n\nvec3 shadeTile(float d, float s, int i, int iteration, vec2 p) {\n    d = -d;\n    d *= iResolution.y * 2. / s;\n    d += .0025 * iResolution.y;\n    //d += (.00125 / s + .0015)  * iResolution.y;\n    d = clamp(d, 0., 1.) / 4.;\n    float t = float(i);\n    #ifdef LOOP\n        t /= float(count);\n    \t//t *= 1.666;\n        t += time;\n    #else\n        t /= float(count);\n        t = t * mix(1., 10., cos(iTime / 20.) * .5 + .5);\n        t += iTime / 6.;\n    \tt -= (p.x - 2.5/2.) * .05;\n    #endif\n    vec3 col = d * spectrum(t);\n    return col;\n}\n\nbool drawTiles(inout vec2 p, inout vec3 col, inout float scale, int iteration) {\n    \n\tfloat scaleOut;\n    vec2 pOut;\n    bool hit = false;\n    \n    vec2 p2 = p;\n    float scale2 = scale;\n\n    for(int i = 0; i < count; i++ )\n    {\n        mat3 txm = tiles[i];\n        p = (vec3(p2, 1) * txm).xy;\n        scale = scale2 * decomposeScale(txm);\n\n        float opacity = 1.;\n        \n        if (iteration == 0) {\n        \topacity = 1. - time;\n            #ifdef ZOOM_OUT\n            \topacity = 1. - opacity;\n            #endif\n        }\n        \n        if (iteration == ITERATIONS - 1) {\n        \topacity = time;\n            #ifdef ZOOM_OUT\n            \topacity = 1. - opacity;\n            #endif\n        }\n        \n        float d = sdTile(p);\n        col -= shadeTile(d, scale, i, iteration, p) * opacity;\n\n        if (d < 0.) {\n            pOut = p;\n\t\t\tscaleOut = scale;\n            hit = true;\n        }\n    }\n    \n    p = pOut;\n    scale = scaleOut;\n\n    return hit;\n}\n\nvec3 render(vec2 p, float scale) {\n\n    vec3 col = vec3(1);\n\n    // recurse\n    for(int i = 0; i < ITERATIONS; i++) {\n        if ( ! drawTiles(p, col, scale, i)) {\n            if (i == 0) {\n            \tcol = vec3(.8);\n            }\n            break;\n        }\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\ttime = mod(iTime / 12., 1.);\n\n    vec2 p = (2. * fragCoord - iResolution.xy) / iResolution.y; \n    float pScale = .22;\n    #ifdef ZOOM_OUT\n    \tpScale = .05;\n    #endif\n    p *= pScale;\n    \n\n    // prepare matrices\n    \n    // tri\n    mat3 triOrigin = trs(vec2(-.5, sqrt(3.) / 6.)) * scl(vec2(3));\n    tiles[0] = triOrigin * trs(vec2(1., -h));\n    tiles[1] = triOrigin * rot(PI / 1.5) * trs(vec2(1., -h));\n    tiles[2] = triOrigin * rot(PI / -1.5) * trs(vec2(1., -h));\n    \n    // long\n    mat3 rect = trs(vec2(-3.5, h)) * scl(vec2(-1));\n    mat3 longOrigin = scl(vec2(3. / 1.5)) * trs(vec2(-5, 0)) * scl(vec2(-1, 1));\n    tiles[3] = longOrigin;\n    tiles[4] = tiles[3] * rect;\n    \n    // box\n    mat3 boxOrigin = trs(vec2(-.5, h)) * scl(vec2(1.5 / .25));\n    tiles[5] = boxOrigin * rot(PI / -3.);\n    tiles[6] = tiles[5] * rect;\n    tiles[7] = boxOrigin * trs(vec2(-1, 0)) * rot(PI / -3.);\n    tiles[8] = tiles[7] * rect;\n    tiles[9] = boxOrigin * trs(vec2(-2, 0)) * rot(PI / -3.);\n    tiles[10] = tiles[9] * rect;\n\n    \n    // pick a tile to zoom to, and calculate the translation,\n    // rotation, and scale to smoothly transition to it\n    mat3 zoomTile = inverse(tiles[1]);\n    vec2 translation;\n    float rotation;\n    float scale;\n    decompose(zoomTile, translation, rotation, scale);     \n    vec2 origin = spiralCenter(translation, rotation, scale);\n    \n   \t#ifdef ZOOM_OUT\n\t\tscale = 1./scale;\n    \trotation *= -1.;\n   \t#endif\n    \n    \n    // apply the zoom\n    scale = pow(scale, time);\n    p *= scale;\n    p = rotate(p, rotation * time);\n    p += origin;\n\n    \n    // draw\n   \tvec3 col = render(p, scale * pScale);\n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGczz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[249, 312, 337, 337, 356], [357, 357, 397, 397, 429], [449, 449, 490, 490, 1037], [1040, 1103, 1171, 1171, 1214], [1216, 1216, 1240, 1240, 1343], [1347, 1358, 1376, 1376, 1423], [1425, 1425, 1444, 1444, 1508], [1510, 1510, 1528, 1528, 1575], [1577, 1577, 1603, 1603, 1636], [1638, 1638, 1664, 1664, 1697], [2204, 2247, 2277, 2277, 2332], [2334, 2334, 2417, 2417, 2610], [2613, 2683, 2749, 2749, 2945], [2949, 2958, 2988, 2988, 3038], [3129, 3190, 3212, 3212, 3422], [3437, 3437, 3501, 3501, 3977], [3979, 3979, 4059, 4059, 4950], [4952, 4952, 4986, 4986, 5242], [5245, 5245, 5302, 5302, 7001]]}
{"id": "wsGyDw", "name": "Phong+AA+AO 2", "author": "emedan", "description": "White sphere, colored light.\nPhong light + Ambient occlusion + shadows.", "tags": ["test"], "likes": 3, "viewed": 138, "published": "Public", "date": "1602960464", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ray march - not ray trace - to find object.\n// Ray trace is easier, analytic expression.\n\n// Important to not have ; here.\n#define MAX_STEPS 600\n#define SURF_DIST 0.0001\n#define MAX_DIST 1000.0\n\n#define pi 3.141593\n#define pi2 6.28318530718\n#define pi4 12.5663706144\n\n\n// Camera\n//vec3 ro;\t// Camera position\n\n// Global list to simplify function returns.\nfloat objectDistances[10];\n\n\n// map from to, clamped\nfloat map(float value, float min1, float max1, float min2, float max2) {\n  return clamp(min2 + (value - min1) * (max2 - min2) / (max1 - min1), min2, max2);\n}\n\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n\n// Return rotation matrix\nmat3 rotate3dx(float _angle){\n    float c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        1, 0,  0, \n        0, c, -s,\n        0, s,  c\n    );\n}\nmat3 rotate3dy(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n         c, 0, s,\n         0, 1, 0,  \n        -s, 0, c\n    );\n}\nmat3 rotate3dz(float _angle){\n\tfloat c = cos(_angle);\n    float s = sin(_angle);\n    return mat3(\n        c, -s, 0,\n        s,  c, 0,\n        0,  0, 1\n    );\n}\n\n\n// Signed, negative inside object\nfloat SDF_box(vec3 p, vec3 size, float rounding) {\n\tp = abs(p)-size;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0) - rounding;\n}\n\n\n// Signed, negative inside object\nfloat SDF_capsule(vec3 p, vec3 A, vec3 B, float r) {\n    vec3 AB = B-A;\n    vec3 AP = p-A;\n    \n    float t = dot(AB, AP) / dot(AB, AB);\n    t = clamp(t, 0.0, 1.0);\n    \n    //return length(p - (A + t*AB)) - r;\n    float tt = 2.0*abs(0.5 - t);\t// 1 .. 0 .. 1\n    tt = t;\n    return length(p - (A + t*AB)) -r + r*smoothstep(1.0, 0.0, pow(tt, 0.9));\n    \n    float s1 = length(p - (A + t*AB)) - r*smoothstep(1.0, 0.0, tt);\n    float s2 =  length(p - (A + t*AB)) - r*(1.0+1.0*pow((t-0.5), 2.0));\n    float s = 0.5*(1.0+sin(iTime));\n    s = 0.0;\n    return s*s1+(1.0-s)*s2;\n}\n\n\n//Signed, negative inside object.\nfloat SDF_sphere(vec3 p, vec3 c, float r) {\n    return length(p - c) - r;\n}\n\n\n// Get the distance from point p to the closest object of all objects in the scene.\n// Returns: distance, object index\n// Distance can be constrained to selected object.\nfloat GetDist(vec3 p, out int objIndex, in int objConstraint) {\n    // Reusable translation variable.\n    vec3 trans;\n    \n    // Sphere /////////////////////////////////////////\n    //vec4 sphere = vec4(2.*sin(iTime), 0, 10.+6.*cos(iTime), 2);\n    vec4 sphere;\n    sphere = vec4(0, 3, 4, 2.1);\n    float sdf_sphere = SDF_sphere(p, sphere.xyz, sphere.w);\n    //sdf_sphere = abs(sdf_sphere) - 0.05;\t// Shell\n\t///////////////////////////////////////////////////\n    \n    // A sphere above the light to make a lamp\n    float sdf_sphereLight = SDF_sphere(p, vec3(12.*sin(iTime/4.), 13, 12.*cos(iTime/4.) + 6.), 0.8);\n\tsdf_sphereLight = SDF_sphere(p, vec3(0, 15, 0), 0.8);\n    \n    // Capsule ///////////////////////////////////////\n\tvec3 cpA, cpB;\n    float cr;\n    cr = 0.85;\n\n    // Position object before rotating around world origo\n\t// Rotate around origo\n    float xang = iTime*0.6+pi/4.0;\n    float yang = iTime*0.3;\n    float zang = iTime*0.3+pi/3.0;\n    mat3 rot = rotate3dy(yang) * rotate3dx(xang) * rotate3dz(zang);\n    \n    float a = 1.0;\n    float b = 4.0;\n    vec3 cpA1 = vec3(a, 0, 0);\n    vec3 cpB1 = vec3(b, 0, 0);\n    vec3 cpA2 = vec3(-a, 0, 0);\n    vec3 cpB2 = vec3(-b, 0, 0);\n    vec3 cpA3 = vec3(0, a, 0);\n    vec3 cpB3 = vec3(0, b, 0);\n    vec3 cpA4 = vec3(0, -a, 0);\n    vec3 cpB4 = vec3(0, -b, 0);\n    vec3 cpA5 = vec3(0, 0, a);\n    vec3 cpB5 = vec3(0, 0, b);\n    vec3 cpA6 = vec3(0, 0, -a);\t\t\n    vec3 cpB6 = vec3(0, 0, -b);\n    vec3 baseT = vec3(0, 3, 4);\n    cpA1 *= rot;\n    cpB1 *= rot;\n    cpA2 *= rot;\n    cpB2 *= rot;\n    cpA3 *= rot;\n    cpB3 *= rot;\n    cpA4 *= rot;\n    cpB4 *= rot;\n    cpA5 *= rot;\n    cpB5 *= rot;\n    cpA6 *= rot;\n    cpB6 *= rot;\n    cpA1 += baseT;\n    cpB1 += baseT;\n    cpA2 += baseT;\n    cpB2 += baseT;\n    cpA3 += baseT;\n    cpB3 += baseT;\n    cpA4 += baseT;\n    cpB4 += baseT;\n    cpA5 += baseT;\n    cpB5 += baseT;\n    cpA6 += baseT;\n    cpB6 += baseT;\n    \n    \n    ///////////////////////////////////////////////////\n    float sdf_capsule1 = SDF_capsule(p, cpA1, cpB1, cr);\n    float sdf_capsule2 = SDF_capsule(p, cpA2, cpB2, cr);\n    float sdf_capsule3 = SDF_capsule(p, cpA3, cpB3, cr);\n    float sdf_capsule4 = SDF_capsule(p, cpA4, cpB4, cr);\n    float sdf_capsule5 = SDF_capsule(p, cpA5, cpB5, cr);\n    float sdf_capsule6 = SDF_capsule(p, cpA6, cpB6, cr);\n    \n    // Box ////////////////////////////////////////////\n    vec3 boxSize = vec3(0.7);\n    vec3 boxCenter = vec3(-6, 3., 6);\n    float boxRounding = 1.5;\n    float boxThickness = 0.05;\n    vec3 boxPos = p-boxCenter;\n    \n    // Mirror in x. Works because position contains marching point and box sdf function\n    //  is made for box at origo.\n    //boxPos.x = abs(boxPos.x); \n    //boxPos.x -= 4.;\t\t\t\t// Space mirrored out from original pos.\n    \n    float sdf_box = SDF_box(boxPos, boxSize, boxRounding);\n    //sdf_box = abs(sdf_box) - boxThickness;\t// Makes shell with thickness.\n    ///////////////////////////////////////////////////\n    \n    // Floor plane ////////////////////////////////////\n    float sdf_plane = p.y;\t//  flat and at y = 0.\n    sdf_plane = dot(p, normalize(vec3(0, 1, 0 )));\t// Tilt plane\n    sdf_plane += sin(p.x/4. +iTime/4.) /5.;\n    sdf_plane += sin(p.x/2. +iTime/2.) /7.;\n    sdf_plane += sin(p.x    +iTime/1.) /9.;\n\n    sdf_plane += sin(p.z/2. +iTime)    /3.;\n    sdf_plane += sin(p.z    +iTime*3.) /7.;\n    ///////////////////////////////////////////////////\n    \n    // Info about hit object.\n    int objIndexDist = 0;\n    float objLimit = SURF_DIST;\n\n    // Capsules + sphere\n    if      (sdf_capsule1   < objLimit) objIndexDist = 1;\n    else if (sdf_capsule2   < objLimit) objIndexDist = 2;\n    else if (sdf_capsule3   < objLimit) objIndexDist = 3;\n    else if (sdf_capsule4   < objLimit) objIndexDist = 4;\n    else if (sdf_sphere     < objLimit) objIndexDist = 5;\n    else if (sdf_capsule5   < objLimit) objIndexDist = 6;\n    else if (sdf_capsule6   < objLimit) objIndexDist = 7;\n\n    ///////////////////////////////////////////////////    \n    // Copy all distances to a global array\n    objectDistances[0] = sdf_capsule1;\n    objectDistances[1] = sdf_capsule2;\n    objectDistances[2] = sdf_capsule3;\n    objectDistances[3] = sdf_capsule4;\n    objectDistances[4] = sdf_sphere;\n    objectDistances[5] = sdf_capsule5;\n    objectDistances[6] = sdf_capsule6;\n\t    \n    // Return the distance to any object for this position p.\n    // The ray marcher will march until the distance is really small.\n    // Distance functions must be signed, and return negative value inside object.\n    //\n    // abs(object distance) - Creates shell. Distance will increase from edges.\n    //\n    // Using: \n    //  min(d1, d2)  - Ray will stop at closest to either one. Typical usage.\n    //  max(d1, d2)  - Ray point requires both d1 and d2 small. Will get the intersection.\n    //  max(-d1, d2) - Object 1 will cut out object 2.\n    float d = MAX_DIST;\n    \n    \n        \n    // Capsules + sphere\n    d = MAX_DIST;\n    d = min(d, sdf_capsule1);\n    d = min(d, sdf_capsule2);\n    d = min(d, sdf_capsule3);\n    d = min(d, sdf_capsule4);\n    d = min(d, sdf_capsule5);\n    d = min(d, sdf_capsule6);\n    d = min(d, sdf_sphere);\n\n    \n    // With object constraint, only give the distance to the selected object.\n    if (objConstraint > -1) {\n        d = MAX_DIST;\n        if      (objConstraint == 1) d = min(d, sdf_capsule1);\n        else if (objConstraint == 2) d = min(d, sdf_capsule2);\n        else if (objConstraint == 3) d = min(d, sdf_capsule3);\n        else if (objConstraint == 4) d = min(d, sdf_capsule4);\n        else if (objConstraint == 5) d = min(d, sdf_sphere);\n        else if (objConstraint == 6) d = min(d, sdf_capsule5);\n        else if (objConstraint == 7) d = min(d, sdf_capsule6);\n    }\n    \n    objIndex = objIndexDist;\n    return d;\n    //return vec2(d, float(objIndexDist));\n}\n\n\n// Ray march / sphere trace. Walk in ray direction, but the distance of the closest object.\n//  Guarantees to not oveshoot the second closest object.\n// Returns: distance to first hit object, hit object index, iterations\nvoid RayMarch(vec3 ro, vec3 rd, \n              out float dO, out int objIndex, out int iterations) {\n\t\n    // Distance from origin start 0 each loop\n    dO = 0.0;\n    float dS;\n    vec2 distResult;\n    int i;\n    for ( i=0; i<MAX_STEPS; i++ ) {\n        // Point marches along ray direction.\n        vec3 p = ro + dO*rd;\n        \n        // Check if the point is so close to a surface that it's a hit.\n        // GetDist returns (distance, object index)\n        dS = GetDist(p, objIndex, -1);\n        //dS = distResult.x;\n        \n        // March the length of closest distance, but in ray direction.\n        dO += dS; \n        \n        // Exit loop if hit object or too long distance.\n        if (abs(dS) < SURF_DIST || dO > MAX_DIST) {\n        \tbreak;\n        } \n    }\n    \n    //Outputs\n    //dO\n    //objIndex\n    iterations = i;\n    return;\n    //return; vec3(dO, float(objIndex), float(i));\n    //return vec3(dO, float(distResult.y), float(i));\t// Always return distance for when loop was exited.\n    // Return nbr of iterations for glow effect. Iteratons increase for rays passing close to objects. \n}\n\n\n// Approximate normal calculation. Uses GetDist to \"find\" the actual object.\n//  Needs p on object for relevant result.\n// The approximate surface of different objects is used if they are close.\n// Approxmation of normal can be constrained to surface of the object found at point p.\nvec3 GetNormal(vec3 p, bool useObjConstraint) {\n    int objConstraint;\n    int dummy;\n    float d =  GetDist(p, objConstraint, -1);\t// Since p is passed here, the distance to p is likely known.\n\tvec2 eps = vec2(0.01 ,0);\n    \n    if (!useObjConstraint) objConstraint = -1;\n    \n    // Get tangent plane\n    float xd =  GetDist(p + eps.xyy, dummy, objConstraint);\n    \n    float yd = GetDist(p + eps.yxy, dummy, objConstraint);\n    \n    float zd = GetDist(p + eps.yyx, dummy, objConstraint);\n    \n    // Normal?? Detta är väl planet?\n    // Det är normalen. Färglägger man blir planet grönt, dvs y = 1.\n    return normalize( vec3(xd, yd, zd) - d );\n}\n\n\nvec3 PhongLight(vec3 p, int objIndex, vec3 ro) {\n    // Famous because it's a computer efficient approximation.\n    \n\t// For each light source in the scene, components (often in rgb values)\n    //  L_is - intensity of specular component\n    //  L_id - intensity of diffuse component\n    // A single term sum of all ambient\n    //  L_ia - intensity of ambient\n    //\n    // For each material in the scene, the following parameters are defined:\n\t//  M_ks - specular reflection constant, ratio of reflection of the specular term of incoming light,\n\t//  M_kd - diffuse reflection constant, ratio of reflection of the diffuse term of incoming light \n    //         (Lambertian reflectance),\n    //  M_ka - ambient reflection constant, ratio of reflection of the ambient term present \n    //         in all points in the scene rendered.\n    //  M_a  - shininess constant which is larger for surfaces that are smoother \n    //         and more mirror-like. When this constant is large the specular highlight is small.\n        \n    // v_L - which is the direction vector from the point on the surface toward each light source \n    //        (m specifies the light source),\n    // v_N  - which is the normal at this point on the surface,\n    //\n    // v_R - which is the direction that a perfectly reflected ray of light would take from \n    //        this point on the surface\n    // v_V  - which is the direction pointing towards the viewer (such as a virtual camera).\n    \n    // Ip = M_ka * L_ia + \n    //      sum of all ligths:\n    //      M_kd * dot(v_L,v_N) * L_id + \n    //      M_ks * dot(v_R,v_V)^M_a * L_is\n    \n    // v_R = 2 * dot(v_L,v_N) * v_N - v_L\n    \n    \n    // Point light ////////////////////////////////////////\n    vec3 LPos;\n    LPos = vec3(25.0*sin(iTime/4.), 20.0+5.0*pow(cos(iTime/4.), 2.0), 2);\n\tLPos = vec3(10.0, 25, -5);\n    float LPower = 2500.0;\n        \n    // Light distance and intensity falloff\n    float LDist = length(LPos - p);\n    float LI = LPower/pi4/LDist/LDist;\n    \n    // Get normal of point on object.\n    //  Light directly to object, dot = 1. At 90 deg angle, dot = 0.\n    vec3 v_L = normalize(LPos - p);\n    vec3 v_N = GetNormal(p, true);\n    \n    // Light color\n    vec3 v_L_is = vec3(1, 1, 0.6);\t// Skumt att light kan ha specular component.\n    vec3 v_L_id = vec3(1, 1, 1);\n    vec3 v_L_ia = vec3(0.4);\n    \n    // Vary the light color \n    float ph1 = pi2*sin(iTime*0.1);\n    float ph2 = pi2*sin(iTime*0.1+0.3*ph1);\n    v_L_id = vec3(0.5+0.5*sin(iTime), 0.5+0.5*sin(iTime*0.9+ph1), 0.5+0.5*sin(iTime*0.57+ph2));\n    // Vary the light tone\n    v_L_id += 0.5+0.5*sin(iTime*0.5);\n\n    // v_R\n    float dotLN = dot(v_L, v_N);\n    vec3 v_R = normalize( 2.0 * dotLN * v_N - v_L );\n    vec3 v_V = normalize( ro - p );\n    \n    \n    // Get object info /////////////////////////////////////\n    // Material \n    float M_ks = 1.0;\n    float M_kd = 1.0;\n    float M_ka = 0.2;//0.1;\n    float M_a = 4.;\n    \n    vec3 objSpecCol = vec3(1); \n    vec3 objDiffCol = vec3(0); // The object finder did not find an object.\n\n    if (objIndex == 1) { \n        objDiffCol = vec3(1, 0, 0);\n        M_ks = 3.;\n\t    M_a = 4.;\n    }\n    else if (objIndex == 2) { \n        objDiffCol = vec3(0, 1, 0);\n        M_ks = 3.;\n\t    M_a = 8.;\n    }\n    else if (objIndex == 3) {\n\t\tobjDiffCol = vec3(0, 0, 1);\n        M_ks = 3.;\n\t    M_a = 16.;\n    }\n    else if (objIndex == 4) {\n        objDiffCol = vec3(1, 0, 1);\n        M_ks = 3.;\n\t    M_a = 32.;\n    }\n    else if (objIndex == 5) {\t// Sphere\n        objDiffCol = vec3(1, 1, 1);\n        M_ks = 3.;\n\t    M_a = 8.;\n    }\n    else if (objIndex == 6) {\n        objDiffCol = vec3(1, 1, 0);\n        M_ks = 3.;\n\t    M_a = 32.;\n    }\n    else if (objIndex == 7) {\n        objDiffCol = vec3(0, 1, 1);\n        M_ks = 3.;\n\t    M_a = 32.;\n    }\n\n    \n    // Phong output\n    vec3 I_ambient = M_ka * v_L_ia;\n    // Below should be summed for all lights.\n    vec3 I_diffuse = M_kd * max(dotLN, 0.0) * v_L_id;\n    vec3 I_specular = M_ks * pow( max(dot(v_R,v_V), 0.0), M_a ) * v_L_is;\n\n    \n    // Additional shading. Not Phong.\n    // Add ambient occlusion where dot L N is -1, and the diffuse part is already 0.\n    //  This will make the core shadow darker. \n    // Material parameter.\n    float M_da = 0.8;\t// Reduction of ambient light in the shadow.\n    I_ambient *= M_da * (1.0 + clamp(dotLN, -1.0, 0.0));\n    \n    // Add more shadows if no path to light source from point p.  //////////\n    // This causes extra ray march. Approximation.\n    // Go from point towards light. If hit an object first - no light path.\n    //  But start a little bit above the surface of p.\n    // Must shadow a point by its own object or else a strange gradient comes.\n    float dShadowObject;\n    int dummy_iterations;\n    int shadowindex;\n    const float SHADOW_FO = 2.5;\t// Falloff\n    RayMarch(p + 3.0*SURF_DIST*v_N, v_L, \n             dShadowObject, shadowindex, dummy_iterations);\n    bool inShade = dShadowObject < LDist + SURF_DIST;\n    bool selfShade = inShade && shadowindex == objIndex;\n    if (inShade) {\n        // Point is affected by shadow.\n        float sf = clamp(M_da*dShadowObject/SHADOW_FO, 0.0, 1.0);\n        sf = pow(sf, 2.0);\n        I_diffuse *= sf;\n        I_specular *= pow(sf, 1.1);\n    }\n    //if (selfShade) { I_ambient = vec3(1); I_diffuse = vec3(1); } // Debug\n    //if (inShade && !selfShade) { I_ambient = vec3(0); I_diffuse = vec3(0); } // Debug\n    ////////////////////////////////////////////////\n    \n    \n    return objDiffCol * I_ambient + \n           objDiffCol * I_diffuse * LI + \n           objSpecCol * I_specular * LI;\n}\n\n\n// Ambient occlusion affect objects close to each other.\n// It's an simplification. \n//  Don't detect the object intersect edge, but should shadow narrow angles more.\n//  Improve by using normal of the other object. How to get that?\nfloat AO(vec3 p, int objIndex) {\n    // Point p is on the surface of object[objIndex], so the distance to other objects\n    //  will be from this.\n    // But when objects intersect the distance will be wrong - it should be only distances\n    //  to visible parts. Can the GetDist / RayMarch also return p of all other distances, and\n    //  not only the p of the \"found\" object?\n    float ao, ao_sum = 0.0;\t\t\t// 0: No ao at all\n    const int NBR_RODS = 6;\n    const int sphereIndex = 5;\n    const float d_fo = 0.3;\t\t// 0..r Fall off distance\n    const float ao_max = 0.8;\t// 0..1 Maximum amount of ao \n    \n    // Make sure global distance variables are updated. XXX now it starts becoming unnecessary (costly).\n    int dummy_index;\n    GetDist(p, dummy_index, -1);\n    \n    // Point is on the sphere.\n    if (objIndex == sphereIndex) {\n        // Move the rod distances to array for iteration possibility.\n        float rd[NBR_RODS];\n        rd[0] = objectDistances[0];\n        rd[1] = objectDistances[1];\n        rd[2] = objectDistances[2];\n        rd[3] = objectDistances[3];\n        rd[4] = objectDistances[5];\n        rd[5] = objectDistances[6];\n\n        // Shadow depending on the distance to each rod.\n        for (int i = 0; i < NBR_RODS; i++) {\n            // Normalize distance between 0..1\n            float d = clamp(rd[i] / d_fo, 0.0, 1.0);\n            \n            // Calculate ao based on distance function.\n            ao = clamp(pow((1.0-d), 3.0), 0.0, 1.0);\n            //ao = 0.3*d;\n            \n            // Add to existing ao with a reduction factor.\n            ao_sum += clamp(0.75*min(ao, ao_max), 0.0, 1.0);\n        }\n    }\n    else {\n    \t// Point is on a rod.\n        // Normalize distance between 0..1\n        float d = clamp(objectDistances[4] / d_fo, 0.0, 1.0);\n\n        // Calculate ao based on distance function.\n        ao = clamp(pow((1.0-d), 3.0), 0.0, 1.0);\n        //ao = 0.3*d;\n\n        // Add to existing ao with a reduction factor. Will matter when several nearby objects\n        //  contribute to the same occlusion.\n        ao_sum += clamp(0.75*min(ao, ao_max), 0.0, 1.0); \n    }\n    \n    return 1.0 - min(ao_sum, ao_max);\n}\n\n\n// Sky color\nvec3 skyColor(vec2 uv) {\n    // 077b88 = \n    // 9dc6ca = \n\tvec3 col; \n    col = mix(vec3(0.615, 0.776, 0.792), vec3(0.027, 0.482, 0.533), 2.0*sqrt(abs(uv.y)));\n    \n    // Lighten middle, darken out. Multiply with > 1.\n    col *= mix(vec3(2), vec3(1), 2.0*pow(abs(uv.y), 0.25));\n        \n    col = pow( clamp(col,0.0,1.0), vec3(2.2) );\t// Inverse gamma bc sky color was chosen from palette.\n\treturn col;\n}\n\n// Render the point of the ray\n// returns: vec3 color, object index, object distance\nvec3 Render(vec3 ro, vec3 rd, vec2 uv,\n            out int objIndex, out float d) {\n    \n    // Ray march in direction for this uv-coordinate / screen pixel.\n    int raySteps;\n    RayMarch(ro, rd, \n             d, objIndex, raySteps);\t// Returns (distance, object index, ray iterations)\n    \n    // Light and color for the intersected point.\n    // Don't do color calculations if there was no hit.\n    vec3 col = vec3(1);\n    if (d < MAX_DIST) {\n        vec3 p = ro + d*rd;\n        col = PhongLight(p, objIndex, ro);\n\n        // Ambient occlusion \n        col *= AO(p, objIndex);\n\n        // Use the nbr of marched steps for glow.\n        //if (objIndex > 1) {\n        //    float stepF = float(raySteps)/float(MAX_STEPS); \n        //    difCol += (pow(stepF*10., 2.0)*1.);   \n        //}\n\n        // Do not shade the light ball\n        //if (objIndex == 5) col = vec3(1, 1, 0);\n    }\n    else {\n        // Background. Remove anything when marcher did not reach because of distance.\n        col = skyColor(uv);\n    }\n    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Rescale x so a circle looks like a circle, and move to new center.\n    // uv.y: -0.5 .. 0.5\n    // uv.x: ( -0.5 .. 0.5 ) * aspect ratio.\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    \n    // Camera ////////////////////////////////////////////////////////////\n    // Camera ray origin, ray direction, ro, rd\n    // x, y view plane and z is depth.\n    vec3 ro;\n\n    // Camera ray direction - look from origin in the direction of each screen pixel.\n    // XXX - Är det ortogonal view genom att sätta x, y, 1 alltid. Nej...\n\tvec3 rd;\n    \n    // Pixel color for what the ray hit.\n    vec3 col;\n    \n    // Camera ray origin\n    ro = vec3(0, 7, -8);\t\n\n    // Camera ray direction\n    rd = normalize( vec3(uv.x, uv.y-0.3, 1) );\n    //////////////////////////////////////////////////////////////////////\n\n    // Cast original ray\n\tvec2 uvorg = uv;\n            \n    // Render what the ray hits.\n    int objIndex;\n    float dist;\n    col = Render(ro, rd, uvorg,\n          objIndex, dist);  // Color of hit point\n    \n    \n    // Focus blur /////////////////////////////////////\n    float fact;\n    fact = 700.0;\t// Use 700 for good AA.\n\n    float range = 0.5;\n    float fp = 4.5;\n    fact =  clamp(pow(abs(dist-fp), 3.2), 20.0, 700.0);\n    ///////////////////////////////////////////////////\n    \n    \n    // Calculate distance\n    //XXXvec3 p = GetDist();\n    //float centerDist = p.z-ro.z;\t// Orthogonal distance to object from camera.\n    //if (objIndex1 == 0) centerDist = MAX_DIST;\n    \n    // Cast ray\n    // How to calculate backwards from uv into a ray direction?\n    // Seems better than to ray with small angular difference.\n\n    // Anti-aliasing - sample 4 points (or perhaps only affect when point is on object edge).\n    // 4 sample is just blur everywhere.\n    // \n    \n    // Procesing saving algorithm for at least few objects:\n    //  Cast the ray.\n    //  If ray hits an object\n    //    Cast the AA rays.\n    //    Optional:\n    //    Blur only if one or more AA ray does not hit object. Prevents pure object internal blur.\n    //\n    // Rays cast: 1 per \"normal cast\". 5 per normal cast that hits an object.\n    \n    // And AA only on \"edge between objects\" but not \"edges within the same object\"\n    //  Cast the ray\n    //  If ray hits Object obj at Point p:\n    //    Calculate a new point pp that is a small view angle in the normal direction of p\n    //     Point pp distance from p depends on camera and perspective transform.\n    //    Cast a ray towards pp\n    //      If ray does not hit obj:\n    //        Blur color of p with whatever color was found in direction of pp.\n    //\n    // Rays cast: 1 per \"normal cast\". 2 per normal cast that hits an object.\n\n    // AA 2 is 4 passes. Costs.\n    #define AA 2\n    \n    // Mouse top half - no AA\n    // Mouse lower left - fixed blur\n    // Mouse lower right - variable blur.\n    bool useAA = (iMouse.y/iResolution.y < 0.5);\n    \n    // Don't cast additional AA rays unless the first ray hit an object.\n    //useAA = useAA && objIndex > 0;\t// XXX Have to or edge can be missed. Blur avoided by not blurring if all points was on object.\n\n\tvec3 tot = vec3(0.0);\t// Summary of all render passes.\n    int m, n;\n    int samples = 0;\n    bool allPointsOnObject = true;\n    for( m=0; m<AA; m++ ) {\n        for( n=0; n<AA; n++ ) {\n            // How to calculate backwards from uv into a ray direction?\n            // Seems better than to ray with small angular difference.\n            vec2 uvorg = uv;\n            \n            // Create offset for the cast ray.\n            vec2 of = vec2(m, n) - 0.5;\n            of /= fact;\n\t\t\t\n            // Modify camera ray direction a little for each AA pass.\n            rd = normalize( rd + vec3(of.x, of.y, 0) );\n\n            // Render what the ray hits.\n            int objIndexOld = objIndex;\n            float distDummy;\n            vec3 col = Render(ro, rd, uvorg,\n                              objIndex, distDummy);  // Color of hit point\n\n \t\t\t// accumulate for AA\n            tot += col;\n            samples++;\n            allPointsOnObject = allPointsOnObject && objIndexOld == objIndex;\n  \t    }        \n    }\n    if (useAA && true) {//!allPointsOnObject) {\n    \tcol = tot / (float(samples));\n    }\n    \n    //if (dist < 7.5) col*= 0.0;\n            \n\n\n    // hdr->ldr tonemap (iniqo)\n    col = col*1.6/(1.0+col);\n    col = col*col*(3.0-2.0*col);\n\n    // Gamma\n    col = pow( clamp(col,0.0,1.0), vec3(1.0 / 2.2) );\n\n    // Output to screen\n    fragColor = vec4( col, 1.0 );\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGyDw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[387, 411, 483, 483, 568], [571, 607, 653, 653, 739], [742, 768, 797, 797, 931], [932, 932, 961, 961, 1093], [1094, 1094, 1123, 1123, 1253], [1256, 1290, 1340, 1340, 1439], [1442, 1476, 1528, 1528, 2047], [2050, 2084, 2127, 2127, 2159], [2162, 2332, 2395, 2433, 8166], [8169, 8390, 8490, 8538, 9498], [9501, 9784, 9831, 9831, 10439], [10442, 10442, 10490, 12168, 16044], [16047, 16280, 16312, 16658, 18448], [18451, 18464, 18488, 18522, 18870], [18872, 18957, 19040, 19114, 19996], [19999, 19999, 20056, 20200, 24570]]}
{"id": "WsGyRy", "name": "My Mandelbulb", "author": "edorobek", "description": "For CPSC479", "tags": ["fractal", "ray", "march"], "likes": 1, "viewed": 191, "published": "Public", "date": "1603072614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "precision mediump float;\n\n\n#define ANIMATE 0\n#define MAX_STEPS 255\n#define MIN_DIST 0.0\n#define MAX_DIST 100.0\n#define EPSILON 0.0001\n#define AA 3\n\nfloat dot2(in vec2 v) { return dot(v,v); }\n\n\n\n\n\nfloat mandelbulb(vec3 pos) {\n    float Power = 3.0 + 5.0;\n\tfloat ThetaShift = iTime * .2;\n\tfloat PhiShift = iTime * .2;\n    \n    if(length(pos) > 1.5) return length(pos) - 1.2;\n    vec3 z = pos;\n    float dr = 1.0, r = 0.0, theta, phi;\n    for (int i = 0; i < 15; i++) {\n        r = length(z);\n        if (r>1.5) break;\n        dr =  pow( r, Power-1.0)*Power*dr + 1.0;\n        theta = acos(z.z/r) * Power + ThetaShift;\n        phi = atan(z.y,z.x) * Power + PhiShift;\n        float sinTheta = sin(theta);\n        z = pow(r,Power) * vec3(sinTheta*cos(phi), sinTheta*sin(phi), cos(theta)) + pos;\n    }\n    return 0.5*log(r)*r/dr;\n}\n\n// Combinations\nfloat unionOp(float d1, float d2) { return min(d1,d2); }\nvec2 unionOp(vec2 d1, vec2 d2) { return (d1.x<d2.x) ? d1 : d2; }\nfloat subtractOp(float d1, float d2) { return max(-d1,d2); }\nvec2 subtractOp(vec2 d1, vec2 d2) { return (-d1.x > d2.x) ? -d1 : d2; }\nfloat intersectOp(float d1, float d2) { return max(d1,d2); }\nvec2 intersectOp(vec2 d1, vec2 d2) { return (d1.x > d2.x) ? d1 : d2; }\n\nfloat smoothUnionOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\nvec2 smoothUnionOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2.x-d1.x)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nfloat smoothSubOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); \n}\n\nvec2 smoothSubOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp(0.5 - 0.5*(d2.x + d1.x)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0 - h); \n}\n\nfloat smotherIntersectOp( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2 - d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0 - h); \n}\n\nvec2 smotherIntersectOp( vec2 d1, vec2 d2, float k ) \n{\n    float h = clamp( 0.5 - 0.5*(d2.x - d1.x)/k, 0.0, 1.0 );\n\treturn mix( d2, d1, h ) + k*h*h*(1.0 - h); \n}\n\n\n\n\n/* Experimental smooth minimum function s*/\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminA( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\n// polynomial smooth min (k = 0.1);\nfloat sminCubic( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*h*k*(1.0/6.0);\n}\n\n// power smooth min (k = 8);\nfloat sminB( float a, float b, float k )\n{\n    a = pow( a, k ); b = pow( b, k );\n    \n    \n    return pow( (a*b)/(a+b), 1.0/k );\n}\n\n/* Transformations */\n\n// rotation and scaling\nvec3 linearTOp(vec3 p, mat4 transform)\n{\n\treturn (inverse(transform)*vec4(p,1.0)).xyz;\n}\n\nvec3 translateOp(vec3 p, vec3 h)\n{\n\treturn p - h;\n}\n\n// NOTE: YOU MUST MULTIPLY RESULTING DISTANCE BY 's'\nvec3 scaleOp(vec3 p, float s)\n{\n\treturn p / s;\n}\n\n/* Deformations */\n\n// Displacement: SDF(p) + displace(p)\n\n// ALTERATIONS\n\nvec4 elongateOP(vec3 p, vec3 h)\n{\n\tvec3 q = abs(p)-h;\n\treturn vec4( max(q,0.0), min(max(q.x,max(q.y,q.z)),0.0));\n}\n\nfloat roundOp(float d, float h)\n{\n    return d - h;\n}\n\nvec3 twistOp(vec3 p, float k)\n{\n\tfloat c = cos(k*p.y);\n\tfloat s = sin(k*p.y);\n\tmat2 m = mat2(c,-s,s,c);\n\treturn vec3(m*p.xz,p.y);\n\t\n}\n\nvec3 bendOp(vec3 p)\n{\n\tconst float k = 10.;\n\tfloat c =  cos(k*p.x);\n\tfloat s = sin(k*p.x);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn vec3(m*p.xy, p.z);\n}\n\n\n\nvec2 map(vec3 p)\n{\n\tvec2 result = vec2(1e10, 0.0);\n\t{\n\t\t// PLANE COLOR CODE MUST BE < 1.5\n\t\tresult = unionOp(result, vec2(mandelbulb(p), 4.1)); \n}\n\t\n\treturn result;\n}\n\nconst float sunIntensity = 1.2;\nconst vec3 sunColor = sunIntensity*vec3(1.30,1.00,0.60);\n\nvec3 background(vec3 q)\n{\n\treturn mix( vec3(0.3,0.3,0.8)*0.5, vec3(0.6, 0.8, 1.0), 0.7 + 0.5*q.y );\n}\n\n\n// intersect ray with the scene\nvec2 raycast(vec3 ro, vec3 rd)\n{\n\tvec2 result = vec2(-1.0);\n\tfloat t = MIN_DIST;\n\tfor (int i =0; i < MAX_STEPS && t < MAX_DIST; i++) {\n\t\tvec2 h = map(ro + t*rd);\n\t\tif (abs(h.x) < (EPSILON*t)) {\n\t\t\tresult = vec2(t, h.y);\n\t\t\tbreak;\n\t\t}\n\t\tt += h.x;\n\t}\n\t\n\treturn result;\n}\n\n// get direction of ray with just device coordinates\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\n// calculate the normal via finite differences\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n}\n\nmat4 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat4(\n        vec4(s, 0.0),\n        vec4(u, 0.0),\n        vec4(-f, 0.0),\n        vec4(0.0, 0.0, 0.0, 1)\n    );\n}\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n\n\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=0; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\nvec3 light = normalize( vec3(-0.5, 0.4, 0.6) );\n\n\nvec3 render(vec3 ro, vec3 rd, vec3 rdx, vec3 rdy)\n{\n\t// background\n\tvec3 col = background(rd);\n\t\n\tvec2 tmat = raycast(ro, rd);\n\tfloat t = tmat.x;\n\tfloat m = tmat.y;\n\tif (m > -1.) {\n\t\n\t\t\n\t\tcol = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n\t\n\t\tvec3 pos = ro + tmat.x*rd;\n\t\tvec3  hal = normalize(light - rd );\n\t\tvec3 norm = (m < 1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n\t\tvec3 ref = reflect( rd, norm );\n\t\t\n\t\tif( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            //vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            //vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            col = vec3(0.30);\n            ks = 0.1;\n        }\n\t\t\n\t\tfloat occ = calcAO(pos, norm); \n\t\tvec3 lin = vec3(0.0);\n\t\t\n\t\t// sun\n\t\t{\n            vec3  hal = normalize( light-rd );\n            float dif = clamp( dot( norm, light ), 0.0, 1.0 );\n        \t      dif *= calcSoftshadow( pos, light, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( norm, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.16*pow(clamp(1.0-dot(hal,light),0.0,1.0),2.0);\n            lin += col*2.20*dif*sunColor;\n            lin +=     5.00*spe*sunColor*ks;\n        }\n        \n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+1.5*norm.y, 0.0, 1.0 ));\n            dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n            spe *= dif;\n            spe *= 0.04+0.96*pow(clamp(1.0+dot(norm,rd),0.0,1.0), 5.0 );\n            spe *= calcSoftshadow( pos, ref, 0.02, 4.2 );\n            lin += col*0.70*dif*background(rd);\n            lin +=     1.30*spe*background(rd)*ks;\n        }\n        col = lin;\n\n\t\t// falloff (fakes a depth blur)\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.00002*t*t*t ) );\n\t}\n\t\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n\n    vec3 tot = vec3(0.);\n    for (int m =0; m < AA; m++)\n    for (int n =0; n < AA; n++)\n    {\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord + o);\n    \tvec3 eye = vec3(-2.0, 3.0, 6.0);\n        \n        mat4 viewToWorld = viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    \tvec3 worldDir = (viewToWorld * vec4(viewDir, 0.0)).xyz;\n    \n  \t\t// ray derivatives\n    \tvec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n    \tvec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n    \tvec3 rdx = (viewToWorld * normalize( vec4(px,2.5, 1.0) )).xyz;\n    \tvec3 rdy = (viewToWorld * normalize( vec4(py,2.5, 1.0) )).xyz;\n    \n    \tvec3 col = render(eye, worldDir, rdx, rdy);\n        tot += col;\n    \n    }\n    \n    tot /= float(AA*AA);\n\n\tfragColor = vec4(tot, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGyRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 171, 171, 190], [196, 196, 224, 224, 824], [826, 842, 877, 877, 898], [899, 899, 931, 931, 963], [964, 964, 1002, 1002, 1024], [1025, 1025, 1060, 1060, 1096], [1097, 1097, 1136, 1136, 1157], [1158, 1158, 1194, 1194, 1228], [1230, 1230, 1283, 1283, 1383], [1384, 1384, 1434, 1434, 1538], [1540, 1540, 1591, 1591, 1692], [1694, 1694, 1742, 1742, 1850], [1852, 1852, 1910, 1910, 2014], [2016, 2016, 2071, 2071, 2178], [2183, 2227, 2268, 2268, 2342], [2344, 2380, 2422, 2422, 2506], [2508, 2544, 2590, 2590, 2676], [2678, 2707, 2749, 2749, 2837], [2862, 2886, 2926, 2926, 2974], [2976, 2976, 3010, 3010, 3027], [3029, 3082, 3113, 3113, 3130], [3191, 3207, 3240, 3240, 3321], [3323, 3323, 3356, 3356, 3376], [3378, 3378, 3409, 3409, 3511], [3513, 3513, 3534, 3534, 3661], [3665, 3665, 3683, 3683, 3831], [3923, 3923, 3948, 3948, 4024], [4027, 4059, 4091, 4091, 4327], [4329, 4382, 4447, 4447, 4578], [4581, 4628, 4660, 4660, 4868], [4870, 4870, 4919, 4954, 5180], [5183, 5183, 5261, 5284, 5668], [5673, 5673, 5715, 5715, 6021], [6073, 6073, 6124, 6139, 7881], [7883, 7883, 7938, 7938, 8832]]}
{"id": "wsGyWd", "name": "Coloured donut", "author": "codecontemplator", "description": "Cosine palette", "tags": ["learning"], "likes": 1, "viewed": 175, "published": "Public API", "date": "1604009056", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 colorX(float x)\n{\n    vec3 a = vec3(0.5, 0.5, 0.5);    \n    vec3 b = vec3(0.5, 0.5, 0.5);    \n    vec3 c = vec3(1.0, 1.0, 0.5);    \n    vec3 d = vec3(0.00, 0.33, 0.67);    \n    \n    float t = x;\n    vec3 color = a + b * cos( 2. * 3.1415 * (c * t + d));\n    return color;\n}\n\nvec3 colorY(float x)\n{\n    vec3 a = vec3(0.8, 0.5, 0.4 );    \n    vec3 b = vec3(0.2, 0.4, 0.2);    \n    vec3 c = vec3(2.0, 1.0, 1.0);    \n    vec3 d = vec3(0.00, 0.25, 0.25);    \n    \n    float t = x;\n    vec3 color = a + b * cos( 2. * 3.1415 * (c * t + d));\n    return color;\n}\n\nvec3 calc(vec2 uv)\n{\n    //vec2 uv = -1. + 2. * inData.v_texcoord;\n    float time = iTime;\n    vec3 colorx = colorX(uv.x + time*0.321);\n    vec3 colory = colorY(uv.y + time*0.35);\n    vec3 color = mix(colorx, colory, length(uv)*2.);\n    color = clamp(color, vec3(0.3,0.3,0.2), vec3(0.9,0.5,0.3));\n    color *= 1.5 - 0.2*length(uv); // vignetting\n    color *= smoothstep(0.3, 0., abs(length(uv)-0.5));\n    //fragColor = vec4(color, 1.0);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from -1 to 1)\n    vec2 uv = fragCoord/iResolution.xy * 2.0 - 1.0;\n\n    // Time varying pixel color\n    vec3 col = calc(uv);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGyWd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 277], [279, 279, 301, 301, 557], [559, 559, 579, 625, 1015], [1017, 1017, 1074, 1125, 1293]]}
{"id": "WsGyWy", "name": "shader #2 Perlin", "author": "chepuha", "description": "Perlin noise", "tags": ["perlin"], "likes": 1, "viewed": 64, "published": "Public", "date": "1603577328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 random2(vec2 st){\n    st = vec2( dot(st,vec2(0.330,0.340)),\n              dot(st,vec2(0.520,0.730)) );\n    return -1.0 + 2.0*fract(sin(st)*43758.5453123);\n}\n\nfloat noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f*f*f*f;\n\n    return mix( mix( dot( random2(i + vec2(.9,0.710) ), f - vec2(-0.440,0.380) ),\n                     dot( random2(i + vec2(-0.020,-0.740) ), f - vec2(-0.300,0.210) ), u.x),\n                mix( dot( random2(i + vec2(-0.820,-0.990) ), f - vec2(-0.870,-0.910) ),\n                     dot( random2(i + vec2(-0.100,-0.350) ), f - vec2(0.350,0.940) ), u.x), u.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n\n    vec3 color = vec3(0.0);\n\n    float t = 1.0;\n    t = cos(iTime/5.)*10.;\n    st += noise(st)*t; \n    color = vec3(.4) * smoothstep(.2,.1,noise(st*1000.));\n    color += vec3(1.) * smoothstep(1.784,0.376,noise(st));\n    fragColor = vec4(1.-color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGyWy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 161], [163, 163, 185, 185, 619], [621, 621, 678, 678, 975]]}
{"id": "wsGyzG", "name": "Example 48 - implicitsurface CSG", "author": "jt", "description": "Simple & inefficient visualization of CSG.", "tags": ["example", "csg", "implicit", "surface"], "likes": 2, "viewed": 48, "published": "Public", "date": "1603109035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// some usefull info related to implicit surfaces:\n// http://paulbourke.net/geometry/implicitsurf/\n// http://paulbourke.net/geometry/polygonise/\n// https://developer.nvidia.com/gpugems/gpugems3/part-i-geometry/chapter-1-generating-complex-procedural-terrains-using-gpu\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sphere(vec3 c, float r, vec3 v)\n{\n    return length(v - c) - r;\n}\n\nfloat cyl_x(vec3 c, float r, vec3 v)\n{\n    return length(v.yz - c.yz) - r;\n}\n\nfloat cyl_y(vec3 c, float r, vec3 v)\n{\n    return length(v.xz - c.xz) - r;\n}\n\nmat3 rotate_x(float phi)\n{\n    return mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, cos(phi), sin(phi)),\n        vec3(0.0,-sin(phi), cos(phi)));\n}\n\nmat3 rotate_y(float phi)\n{\n    return mat3(\n        vec3(cos(phi), 0.0, sin(phi)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(phi), 0.0, cos(phi)));\n}\n\nmat3 rotate_z(float phi)\n{\n    return mat3(\n        vec3(cos(phi), sin(phi), 0.0),\n        vec3(-sin(phi), cos(phi), 0.0),\n        vec3(0.0, 0.0, 1.0));\n}\n\nvec3 transform(vec3 v)\n{\n    v += vec3(0.0, 0.0,-2.0); // camera-offset\n    return rotate_x(iTime) * rotate_y(iTime) * rotate_z(iTime) * v;\n}\n\nvec3 tex(vec3 v)\n{\n    v = transform(v);\n    //return fract(v);\n    return vec3(step(0.75, length(2.0 * fract(2.0 * v) - 1.0)));\n}\n\n// primitives can be combined via min, max, negation\n// (https://en.wikipedia.org/wiki/Constructive_solid_geometry)\nfloat scene(vec3 v)\n{\n    v = transform(v);\n\n    //return sphere(vec3(0.5, 0.0, 2.0), 1.0, v);\n    //return min(sphere(vec3(0.5, 0.0, 2.0), 1.0, v), sphere(vec3(-0.5, 0.0, 2.0), 1.0, v));\n    //return max(sphere(vec3(0.5, 0.0, 2.0), 1.0, v), sphere(vec3(-0.5, 0.0, 2.0), 1.0, v));\n    //return max(sphere(vec3(0.75, 0.0, 2.0), 1.0, v), -sphere(vec3(-0.25, 0.0, 2.0), 1.0, v));\n    return max(max(\n        min(cyl_x(vec3(0.0, 0.0, 0.0), 0.5, v), cyl_y(vec3(0.0, 0.0, 0.0), 0.5, v)),\n        sphere(vec3(0.0, 0.0, 0.0), 1.0, v)), -sphere(vec3(0.0, 0.0, 0.0), 0.75, v));\n}\n\n#define EPS 0.001\n\nvec3 gradient(vec3 p)\n{\n    return vec3(\n        scene(p + vec3(+1.0, 0.0, 0.0) * EPS) - scene(p + vec3(-1.0, 0.0, 0.0) * EPS),\n        scene(p + vec3(0.0, +1.0, 0.0) * EPS) - scene(p + vec3(0.0, -1.0, 0.0) * EPS),\n        scene(p + vec3(0.0, 0.0, +1.0) * EPS) - scene(p + vec3(0.0, 0.0, -1.0) * EPS));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 delta = vec3(2.0 * fragCoord/iResolution.xy - 1.0, 1.0);\n    delta.x *= iResolution.x / iResolution.y; // fix aspect\n\n    fragColor = vec4(0.0);\n    float s = 0.01;\n    int iter = 0;\n    int itermax = 280;\n    //for(vec3 p = vec3(0.0); iter < itermax; p += delta * scene(p), iter++) // buggy\n    for(vec3 p = vec3(0.0); iter < itermax; p += delta * s, iter++)\n    {\n        float dist = scene(p);\n        if(dist <= 0.0)\n        {\n            //fragColor = vec4(1.0);\n            //fragColor = vec4(fract(p.z));\n            vec3 n = normalize(gradient(p));\n            fragColor = vec4(0.5 + 0.5 * n, 1.0);\n            //fragColor = vec4(tex(p), 1.0); // apply 3d texture\n            float brightness = dot(n, normalize(vec3(1.0, 0.0, 0.0)));\n            //fragColor *= brightness;\n            //fragColor = vec4(brightness);\n            break;\n        }\n    }\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGyzG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 345, 384, 384, 416], [418, 418, 456, 456, 494], [496, 496, 534, 534, 572], [574, 574, 600, 600, 727], [729, 729, 755, 755, 883], [885, 885, 911, 911, 1039], [1041, 1041, 1065, 1065, 1182], [1184, 1184, 1202, 1202, 1314], [1316, 1432, 1453, 1453, 2001], [2022, 2022, 2045, 2045, 2326], [2328, 2328, 2385, 2385, 3257]]}
{"id": "wsK3R3", "name": "stupid", "author": "tomviolin", "description": "stupid", "tags": ["stupid"], "likes": 0, "viewed": 163, "published": "Public API", "date": "1602402430", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi=3.14159265358;\nconst float rr=5.;\nfloat surface (vec2 st) {\n    \n    return fract(sin(dot(st.xy-vec2(mod(st.x,rr/iResolution.x),mod(st.y,rr/iResolution.y)),\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\nfloat prod(vec2 x){\n    return x.x*x.y;\n}\n\nfloat interpsurface(vec2 st) {\n    vec2  u=rr/iResolution.xy;\n\n    vec2 x = mod(st,u);\n    //if (x.x<u.x/4. && x.y<u.y/4.) return surface(st-x);\n    vec2 u00 = st-x;\n    vec2 u01 = u00 + u*vec2(0,1);\n    vec2 u10 = u00 + u*vec2(1,0);\n    vec2 u11 = u00 + u;\n    float w00=(prod(abs(u00-st)/u));\n    float w01=(prod(abs(u01-st)/u));\n    float w10=(prod(abs(u10-st)/u));\n    float w11=(prod(abs(u11-st)/u));\n\treturn surface(u11) * w00 //x.x * x.y/u.x/u.y\n          +surface(u10) * w01 //x.x/u.x * (1.-x.y/u.y)\n          +surface(u01) * w10 //(1.-x.x/u.x)*(x.y/u.y)\n          +surface(u00) * w11 ; //(1.-x.x/u.x)*(1.-x.y/u.y);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 fg = vec2(fragCoord.x/3.14159*iResolution.x,(fragCoord.y/3.14159*iResolution.y));\n    fg.y+=iTime*200.;\n\tfragColor = vec4(interpsurface((fg)/(iResolution.xy)));\n    fragColor.r *= sin(fragCoord.x/3.14159/10.+iTime)*0.5+0.5;\n    fragColor.g *= cos(fragCoord.y/3.14159/10.-iTime)*0.5+0.5;\n    float d = length(fragCoord - iResolution.xy/2.);\n    fragColor.a = cos(d/15.-iTime*2.4)*0.1; //+(1.-d/iResolution.x);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsK3R3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 74, 74, 246], [247, 247, 266, 266, 288], [290, 290, 320, 320, 915], [921, 921, 978, 978, 1398]]}
{"id": "WsKcDz", "name": "INKTtober - Flower", "author": "Flopine", "description": "Seventh day of the Inktober challenge! For 2020 I'm using the Inkt-Tober list: https://twitter.com/Trish_Argh/status/1304878524797419525", "tags": ["3d", "animation", "glitch", "isometric", "undertale", "inktober"], "likes": 10, "viewed": 196, "published": "Public", "date": "1602608839", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n#define PI acos(-1.)\n#define TAU 6.283185\n\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n#define lrep(p,c,l) p=p-c*clamp(round(p/c),-l,l)\n#define moda(p,rep) float a=mod(atan(p.y,p.x),TAU/rep)-(TAU/rep)*0.5;p=vec2(cos(a),sin(a))*length(p) \n\n#define dt(speed) fract(iTime*speed)\n#define switanim(speed) floor(sin(dt(speed)*TAU)+1.)\n\nstruct obj\n{\n    float d;\n    vec3 color;\n};\n\nobj minobj (obj a, obj b)\n{\n    if (a.d < b.d) return a;\n    else return b;\n}\n    \nfloat box (vec3 p, vec3 c)\n{return length(max(abs(p)-c,0.));}\n\nfloat cyl (vec3 p, float r, float h)\n{return max(length(p.xy)-r, abs(p.z)-h);}\n\nobj ground (vec3 p)\n{\n    vec2 id = round(p.xz/.5)-.5;\n    lrep(p.xz, 0.5,5.);\n    float d = box(p,vec3(.2));\n    \n    return obj(d,clamp(vec3(length(id*0.4)*0.8,1.,length(id*0.1)),0.,1.));\n}\n\nfloat line (vec2 uv, vec2 a, vec2 b, float r, bool s)\n{\n    vec2 pa = uv - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    if (s) return length(pa - ba*h) - r;\n    else return length(pa - ba*h) - r*h*0.5; \n}\n\nfloat face (vec2 uv)\n{\n    vec2 uu = uv;\n    uv.x = abs(uv.x) -0.5;\n    uv.y -= 0.3; \n    float m = smoothstep(0.2,0.22,length(uv))+(1.-smoothstep(0.05,0.06, length(uv+vec2(0.,0.1))));\n    \n    uv = uu;\n    uv.y -= uv.x*uv.x*0.5;\n    float b = smoothstep(0.06,0.08,line(uv,vec2(-.5,-0.5),vec2(.5,-0.5),0.3,true));\n    m *= b;\n    \n    uv.y += 0.5;\n    uv.y = abs(uv.y)+0.05;\n    uv.x = abs(abs(abs(uv.x)-0.4)-.2)-0.1;\n    float d =  smoothstep(0.01,0.011, line(uv,vec2(0.,0.1),vec2(0.,0.42), 0.15,false));\n    m += (1.-d);\n    \n    return clamp(m,0.,1.);\n}\n\nobj flowey (vec3 p)\n{\n    float sy = 1.;\n    float sxz = 1./sy;\n    vec3 new_size = vec3(sxz,sy,sxz);\n    p *= new_size;  \n    p.y -= 0.9;\n    \n    vec3 pp = p;\n    \n    p.x += sin(p.y*3.)*0.1;\n    float sd = cyl(p.xzy, 0.08-p.y*0.05, 0.8);\n    obj stem = obj(sd,vec3(0.1,0.8,0.2)); \n    \n    p = pp;\n    p.y -= 1.;\n    p.x += 0.3;\n    p.xy *= rot(PI/4.);\n    vec2 puv = p.xz*rot(-PI/2.); \n    float ps = cyl(p.xzy, 0.3,length(p.xz*0.3)*0.2);\n    vec3 pcol = (switanim(1.) <= 0.) ? vec3(1.)*face(puv*3.5):vec3(1.);\n    obj pistil = obj(ps, pcol);\n    \n    moda(p.xz,6.);\n    p.x -= 0.49;\n    float pes = box(p,vec3(0.2,0.03-p.x*0.25,0.1-sin(p.x*TAU*2.)*0.05));\n    obj petal = obj(pes,vec3(0.9,0.7,0.));\n    \n    obj flowey = minobj(stem,pistil);\n    flowey = minobj(flowey,petal);\n    \n    flowey.d /= length(new_size);\n    \n    return flowey;\n}  \n\nobj SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n\t\n    obj scene = ground(p);\n    scene = minobj(scene, flowey(p));\n    return scene;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float detail = sin(dt(1.)*TAU)*70.-75.;\n    uv.y = floor(uv.y*detail)/detail;\n    \n    vec3 ro = vec3(uv*2.8,-50.), rd = vec3(0.,0.005,1.), p = ro, col = vec3(0.);\n    bool hit = false;\n    float shad; obj O;\n    for (float i=0.; i<64.;i++)\n    {\n        O = SDF(p);\n        if (O.d<0.001)\n        {\n            hit = true; shad = i/64.; break;\n        }\n        p += O.d*rd;\n    }\n\n    if (hit)\n    {\n        col = O.color;\n        col *= (1.-shad);\n    }\n    \n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKcDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[169, 700, 727, 727, 777], [783, 783, 811, 811, 844], [846, 846, 884, 884, 924], [926, 926, 947, 947, 1117], [1119, 1119, 1174, 1174, 1353], [1355, 1355, 1377, 1377, 1911], [1913, 1913, 1934, 1934, 2759], [2763, 2763, 2781, 2781, 2929], [2931, 2931, 2988, 2988, 3553]]}
{"id": "WsKcR1", "name": "Omnidirectional defense", "author": "gaz", "description": "3d", "tags": ["bokhe"], "likes": 6, "viewed": 108, "published": "Public", "date": "1602236978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.)\n#define pmod(p,n) (length(p)*sin(vec2(0,PI*.5)+mod(atan(p.x,p.y),PI*2./n)-PI/n))\n\nmat3 lookat(vec3 eye, vec3 target, vec3 up){\n    vec3 w=normalize(target-eye), u=normalize(cross(w,up));\n    return mat3(u,cross(u,w),w);\n}\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(u,a);\n\tp=u*cos(t)+v*sin(t)+a*dot(p,a);   \n}\n\nfloat lpNorm(vec2 p, float n){\n\tp = pow(abs(p), vec2(n));\n\treturn pow(p.x+p.y, 1./n);\n}\n\nfloat map(vec3 p){\n\trot(p,vec3(1,6,-3),iTime*.3);\n\trot(p,vec3(5,2,3),iTime*.5);\n    p=abs(p);\n    if(p.x<p.z)p.xz=p.zx;\n\tif(p.y<p.z)p.yz=p.zy;\n \tif(p.x<p.y)p.xy=p.yx;\n \tvec3 nor=normalize(vec3(int(iTime*2.0)%3+3,int(iTime*1.5)%2+2,int(iTime*2.5)%3));\n \tfloat x=dot(p,nor)-.1*fract(sin(iTime+.3*sin(.5*iTime))*2.-1.3);\n \tfloat y=length(cross(p,nor));\n \treturn min(\n        length(vec2(x-clamp(x,.85,2.),y))-.1*mix(1.5,-.5,pow(max(0.,x-.8),2.)),\n \t\tlpNorm(vec2(x-1.,y-.16),5.)-.07\n    );\n}\n\nvec3 calcNormal(vec3 p){\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 bg=vec3(1,1.5,1.8)*.7;\n    vec3 ro0=vec3(0,0,3.5);\n    vec3 ta=vec3(.1,.05,0);\n    vec3 rd0=normalize(vec3(p,2.));\n    vec3 sv=normalize(cross(ta-ro0,vec3(0,1,0)))*.04;\n    float b=6.;  \n\tfor (float j=0.; j<b; j++){\n        vec3 ro = ro0+sv;\n        vec3 rd = lookat(ro,ta,vec3(0,1,0)) * rd0;\n\t\tfloat z = 0., d, i, ITR=70.;\n \t\tfor( i = 0.; i < ITR; i++){\n    \t\tz += d = map(ro + rd * z);\n    \t\tif(d < .001 || z > 30.) break;\n  \t\t}\n    \tif(d < .001){\n\t  \t\tvec3 p = ro + rd * z;\n\t \t\tvec3 nor = calcNormal(p);\n    \t\tvec3 li = normalize(vec3(1));\n        \tvec3 col = vec3(.7,.9,.8)*.9;\n        \tcol *= pow(1.-i/ITR,2.); \n       \t \tcol *= clamp(dot(nor,li),.3,.8);\n        \tcol *= max(.5+.5*nor.y,0.);\n            float rimd = pow(clamp(1.-dot(reflect(-li,nor),-rd),0.,1.),2.5);\n\t\t    float frn = rimd+2.2*(1.0-rimd);\n    \t    col *= frn*.8;\n        \tcol += pow(clamp(dot(reflect(normalize(p-ro),nor),li),0.,1.),30.);\n        \tcol *= exp(-z*z*0.08);\n         \tcol = min(vec3(1),col*2.);\n        \tbg += col;\n    \t}\n        rot(sv, normalize(ta-ro0), PI*2./b);\n\t}\n    bg = clamp(bg/b,0.,1.);\n    fragColor.xyz = pow(bg,vec3(1.5));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKcR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 147, 147, 242], [244, 244, 282, 282, 370], [372, 372, 402, 402, 459], [461, 461, 479, 479, 948], [950, 950, 974, 974, 1117], [1119, 1119, 1176, 1176, 2364]]}
{"id": "wsKcRm", "name": "Peaceful Sunset", "author": "Tech_", "description": "Here is one of my first big shaders! Enjoy!", "tags": ["2d", "simple", "sunset", "parallaxscrolling"], "likes": 10, "viewed": 222, "published": "Public API", "date": "1602594480", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/////////////////////////////////////////////////////////////////////////////\n//\n//\t PEACEFUL SUNSET\n//\n//\t by Tech_\n//\n/////////////////////////////////////////////////////////////////////////////\n\nfloat getCloudNoiseWaves(in vec2 uv, float scale, float speed) \n{\n    float waveColor;\n    vec2 uvVar1 = uv * scale / 8.;\n    vec2 uvVar2 = uv * scale / 0.25;\n    \n    float waves1;\n    waves1 += cos(uvVar1.x * 30. + sin(iTime * speed + uvVar1.y * 10. + cos(uvVar1.x * 60.0 + iTime * speed)));\n    waves1 *= waves1;\n    waves1 *= 0.3;\n    \n    float waves2;\n    waves2 += cos(uvVar2.x / 6. * 5.0 + sin(iTime * speed + uvVar2.y + cos(uvVar2.x + iTime * 2. * speed)));\n    waves2 *= waves2 * 0.2;\n    \n    waveColor = waves1 + waves2 * 2.;\n    \n    return waveColor;\n}\n\nfloat getClouds(in vec2 uv, float cloudOpacity, float cloudHeight, float cloudScale, float cloudAmount) \n{\n    cloudAmount -= 1.;\n    float fog;\n    vec2 st = uv;\n    uv.y *= 4.;\n    uv.x *= 0.4;\n    uv.x += iTime / 1270. / cloudScale;\n    uv.y += sin((uv.x + iTime / 100.) * 30.) * 0.02;\n    fog += getCloudNoiseWaves(uv * cloudScale, 3.4, 0.1);\n    fog -= getCloudNoiseWaves(uv * cloudScale + vec2(2.), 2.4, 0.2);\n    fog = clamp(fog, 0., 1.);\n    float mask;\n    mask = 1. - distance(st.y - (0.35 + cloudHeight), 0.5 + cloudHeight) * 2.;\n    fog *= mask;\n    fog = smoothstep(0.15 - cloudAmount, 0.6 - cloudAmount, fog);\n    return mix(0., clamp(fog, 0., 1.), cloudOpacity);\n}\n\nfloat getWave(in vec2 uv, float waveHeight, float waveSpeed, float waveFrequency, float waveAmplitude, float depth) \n{\n    uv.y -= sin(iTime + depth * 12.) / 60. * waveAmplitude;\n    waveSpeed = iTime / 4. * waveSpeed;\n\tfloat wave = smoothstep(0.0 + waveHeight, 0.003 + waveHeight * (depth + 1.), uv.y + sin((uv.x + waveSpeed) * waveFrequency * 10. + sin(uv.x * 3.)) * 0.03 * waveAmplitude);\n    float result = 1. - wave;\n    return result;\n}\n\nvec4 getOcean(in vec2 uv, float waveHeight, float waveSpeed, float waveFrequency, float waveAmplitude) \n{\n    vec3 waves;\n    waveHeight -= 1.;\n    waveFrequency -= 1.;\n    waves += getWave(uv, 0.325 + waveHeight, 0.025 * waveSpeed, 8. + waveFrequency, 0.06 * waveAmplitude, 0.0) * vec3(0.2);\n    waves += getWave(uv, 0.3 + waveHeight, 0.05 * waveSpeed, 6. + waveFrequency, 0.1 * waveAmplitude, 0.0005) * vec3(0.2);\n    waves += getWave(uv, 0.26 + waveHeight, 0.1 * waveSpeed, 4. + waveFrequency, 0.2 * waveAmplitude, 0.01) * vec3(0.2);\n    waves += getWave(uv, 0.20 + waveHeight, 0.2 * waveSpeed, 2. + waveFrequency, 0.4 * waveAmplitude, 0.05) * vec3(0.2);\n    waves += getWave(uv, 0.11 + waveHeight, 0.35 * waveSpeed, 1.5 + waveFrequency, 0.77 * waveAmplitude, 0.2) * vec3(0.2);\n    waves = pow(waves, vec3(1.)) / 1.6;\n    \n    float oceanOpacity = 1. - getWave(uv, 0.325 + waveHeight, 0.025 * waveSpeed, 8. + waveFrequency, 0.06 * waveAmplitude, 0.0);\n    \n    return vec4(waves, oceanOpacity);\n}\n\nvec3 getSun(in vec2 uv, float oceanOpacity) \n{\n    vec2 st = uv;\n    uv -= .5;\n \tuv.x *= iResolution.x / iResolution.y;\n    \n    uv.y += 0.05;\n    \n    float radius = 0.1;\n    float uvLength = 1. - length(uv);\n    vec3 sun;\n    float sunOpacity = 1.;\n    \n    for(int i = 0; i < 10; i++) \n    {\n        sunOpacity *= 0.6;\n    \tsun += vec3(smoothstep(0.95 - radius, 0.953 - radius, uvLength) * sunOpacity) * vec3(1., 0.6, 0.);\n        sun = clamp(sun, 0., 1.);\n        radius *= 1.3 + sin(iTime) / 100.;\n    }\n\t\n    sun *= oceanOpacity;\n    sun.g *= 0.9;\n    \n    vec3 sunGlow = clamp(1. - vec3(length(uv * 2.)), 0., 1.) * oceanOpacity;\n    sunGlow *= smoothstep(0.1 - sin(iTime) / 10., 1. - sin(iTime) / 10., sunGlow);\n    \n    vec3 flare = 1. - vec3(distance(vec2(st.x * 1.5 - 0.25, st.y * 2. - 0.5), vec2(0.5))) * 2. + sin(iTime) / 40.;\n    flare = clamp(flare * vec3(1., 0.8, 0.), 0., 1.);\n    \n    return sun + (sunGlow + flare) / 4.;\n}\n\nvec3 getSkyGradient(in vec2 uv) \n{\n    float mid = smoothstep(0.2, 0.5, uv.y);\n    \n    vec3 midColLit = vec3(1., 0.341 * 2., 0.09 * 2.2);\n    vec3 midColUnlit = vec3(1., 0.341, 0.09);\n    vec3 midCol = mix(midColUnlit, midColLit, 1. - clamp(distance(uv.x, 0.5) * 1.5, 0., 1.));\n    vec3 upperCol = vec3(0.5, 0.156, 0.225);\n    \n\tvec3 skyColorTop = mix(midCol, upperCol, uv.y);\n    vec3 skyColorBottom = mix(vec3(1., 0.6, 0.1), vec3(1., 0.7, 0.1), 1. - clamp(distance(uv.x, 0.5) * 3., 0., 1.));\n    \n    vec3 skyColor = mix(skyColorBottom, skyColorTop, mid);\n    \n    return skyColor;\n}\n\nfloat luma(vec3 color)\n{\n    return dot(color, vec3(0.2126, 0.7152, 0.0722));\n}\n\nvec3 changeLuminance(vec3 colorIn, float lumaOut)\n{\n    float lumaIn = luma(colorIn);\n    return colorIn * (lumaOut / lumaIn);\n}\n\nvec3 reinhardExtended(vec3 color, float maxWhiteLuma)\n{\n    float lumaOld = luma(color);\n    float numerator = lumaOld * (1.0 + (lumaOld / (maxWhiteLuma * maxWhiteLuma)));\n    float lumaNew = numerator / (1.0 + lumaOld);\n    return changeLuminance(color, lumaNew);\n}\n\nvec3 tonemapping(in vec3 color)\n{\n    color -= 0.06;\n    color *= 1.62;\n    color = reinhardExtended(color, 2.);\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 color;\n    \n    vec3 waveColor = vec3(0.19, 0.21, 0.45); \n    vec3 waves = getOcean(uv, 1.05, 1.2, 1.1, 1.0).rgb;\n    waves *= waveColor;\n    \n    vec3 sun = vec3(getSun(uv, getOcean(uv, 1.05, 1.2, 1.1, 1.0).a));\n    \n    vec3 skyColor = getSkyGradient(uv);\n    vec3 sky = pow(1. - getOcean(uv, 1.05, 1.2, 1.1, 1.0).rgb, vec3(1.5)) * skyColor;\n    \n    float clouds = getClouds(uv, 0.5, 0.01, 1., 0.8);\n    clouds += getClouds(uv, 0.4, 0.015, 2., 0.75);\n    clouds += getClouds(uv, 0.3, 0.02, 2.3, 0.75);\n    \n    color = waves + sky + sun + clouds;\n    \n    color = tonemapping(color);\n    \n    // Output to screen\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKcRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 200, 265, 265, 766], [768, 768, 874, 874, 1447], [1449, 1449, 1567, 1567, 1891], [1893, 1893, 1998, 1998, 2892], [2894, 2894, 2940, 2940, 3834], [3836, 3836, 3870, 3870, 4422], [4424, 4424, 4448, 4448, 4503], [4505, 4505, 4556, 4556, 4633], [4635, 4635, 4690, 4690, 4901], [4903, 4903, 4936, 4936, 5035], [5037, 5037, 5094, 5144, 5846]]}
{"id": "WsKczt", "name": "Equal Relative Luminance plane..", "author": "hanfling", "description": "..in sRGB colorspace.", "tags": ["luminance", "srgb", "colorscience", "relativeluminance"], "likes": 2, "viewed": 263, "published": "Public API", "date": "1603499339", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Configuration.\nconst bool  bAnimateRelativeLuminancePlane = true;  // Set to true automatically modulate relative luminance input.\nconst float AnimationAngularFrequency      = 0.3;   // Angular frequency for rl modulation in 1/s.\nconst float StaticRelativeLuminancePlane   = 0.707; // If bAnimatePlane is not set, use this relative lumianance.\nconst float BorderFraction                 = 0.379; // Amount of combined top-bottom or left-right fraction.\n\n// Piecewise gamma transfer functions for sRGB colorspace.\nvec3 GammaCompress_sRGB( vec3 Color )\n{\n\tvec3 Step = step(vec3(0.0031308),Color);\n\treturn (12.92*Color)*(vec3(1.0)-Step) + (1.055*pow(Color,vec3(0.41666))-vec3(0.055))*Step;\n}\n\n\nconst vec3 Rec709RelativeLuminanceWeights = vec3( 0.2126, 0.7152, 0.0722 );\n\nvoid mainImage( out vec4 FragColor, in vec2 FragCoord )\n{\n    float RelativeLuminancePlane;\n\n    if ( bAnimateRelativeLuminancePlane )\n    {\n        // Use the square of the modulation, to make it look a little more brightness uniform over time.\n    \tRelativeLuminancePlane = pow( 0.5+0.5*cos(AnimationAngularFrequency*iTime), 2.0 );\n    }\n    else // !bAnimateRelativeLuminancePlane\n    {\n    \tRelativeLuminancePlane = StaticRelativeLuminancePlane;\n    }\n    \n    vec3 LinearFragColor;\n\n    if ( RelativeLuminancePlane<0.0 )\n    {\n        LinearFragColor = vec3(0.0,0.0,1.0); // Blue.\n    }    \n    //else if ( RelativeLuminancePlane<0.001 )\n    //{\n    //    LinearFragColor = vec3(0.0,0.0,0.0); // Black.\n    //}\n    else if ( RelativeLuminancePlane>1.0 )\n    {\n        LinearFragColor = vec3(1.0,0.0,0.0); // Red.\n    }\n    //else if ( RelativeLuminancePlane>0.999 )\n    //{\n    //    LinearFragColor = vec3(1.0,1.0,1.0); // White.\n    //}\n    else // RelativeLuminancePlane in (0,1).\n    {\n        // Start with coloring everything with border/out of gamut color.\n        //LinearFragColor = vec3(RelativeLuminancePlane);\n        \n        // Turns out, the above is really annoying, and that black seems to be preferable.\n        LinearFragColor = vec3(0.0);\n        \n        //vec2 NormalizedFragCoord = 2.0*FragCoord/iResolution.xy-vec2(1.0);\n        vec2 NormalizedFragCoord = 2.0*FragCoord/min(iResolution.x,iResolution.y)-vec2(max(iResolution.x/iResolution.y,1.0),max(iResolution.y/iResolution.x,1.0));\n        \n        //\n        \n        vec2 SquareFragCoords = (NormalizedFragCoord)/(1.0-BorderFraction);\n        \n        //SquareFragCoords = NormalizedFragCoord;\n        \n        if ( SquareFragCoords.x>=-1.0 && SquareFragCoords.x<=1.0 && SquareFragCoords.y>=-1.0 && SquareFragCoords.y<=1.0 )\n        {\n            float Red   = (1.0+SquareFragCoords.y)/2.0;\n            float Blue  = (1.0+SquareFragCoords.x)/2.0;\n\n            float Green = (RelativeLuminancePlane-Red*Rec709RelativeLuminanceWeights.r-Blue*Rec709RelativeLuminanceWeights.b)/Rec709RelativeLuminanceWeights.g;\n\n            // Color is in gamut and we can just display it, otherwise gray background remains.\n            if ( Green>=0.0 && Green<=1.0 )\n            {\n                LinearFragColor = vec3(Red,Green,Blue);\n            }\n        }\n    }\n\n    // Output to screen\n    FragColor.rgb = GammaCompress_sRGB( LinearFragColor );\n    FragColor.a   = 1.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKczt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[458, 517, 556, 556, 692], [772, 772, 829, 829, 3214]]}
{"id": "WsKyDy", "name": "Noise functions", "author": "henrmota", "description": "Just a collection of noise functions to practice and understand. Fractal brownian motion is just awesome.", "tags": ["noise"], "likes": 2, "viewed": 67, "published": "Public", "date": "1603664930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 2.*PI\n#define FBM_OCTAVES 4\n#define DX 1./iResolution.x\n#define DY 1./iResolution.y\n\n//1d pseudo-random for shaders\nfloat random(vec2 p) {\n    p = mod(p, 10000.);\n    \n \treturn fract(sin(dot(p, vec2(12.9898,78.233))) * 43758.5453); \n}\n\n//2d pseudo-random\nvec2 random2(vec2 p) {\n    p = mod(p, 10000.);\n    \n \treturn fract(\n        sin( \n            vec2( \n                dot(p,vec2(127.1,311.7)), \n                dot(p,vec2(269.5,183.3)) \n            ) \n        ) \n    \t* 43758.5453\n    ); \n}\n\nfloat noise(vec2 p) {\n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float bottom_left = random(i);\n    float bottom_right = random(i + vec2(1.0, 0.0));\n    float top_left = random(i + vec2(0.0, 1.0));\n    float top_right = random(i + vec2(1.0, 1.0));\n    \n    // Quintic interpolation\n    f = f*f*f*(f*(f*6.-15.)+10.);\n    \n    // Cubic interpolationn\n    //f = f*f*(3.0 - 2.0*f);\n    \n    float bottom = mix(bottom_left, bottom_right, f.x); \n    float top = mix(top_left, top_right, f.x); \n    \n    return mix(bottom, top, f.y);\n}\n\nfloat perlinNoise(vec2 p) {\n \tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    vec2 a = i;\n    vec2 b = i + vec2(1., 0.);\n    vec2 c = i + vec2(0., 1.);\n    vec2 d = i + vec2(1., 1.);\n    \n    //random angles\n    float bl_angle = random(a) * TWO_PI;\n    float br_angle = random(b) * TWO_PI;\n    float tl_angle = random(c) * TWO_PI;\n    float tr_angle = random(d) * TWO_PI;\n    \n    // corner vectors \n    vec2 bl_vec = vec2(-sin(bl_angle), cos(bl_angle));\n    vec2 br_vec = vec2(-sin(br_angle), cos(br_angle));\n    vec2 tl_vec = vec2(-sin(tl_angle), cos(tl_angle));\n    vec2 tr_vec = vec2(-sin(tr_angle), cos(tr_angle));\n   \n    float bl = dot(bl_vec, p - a);\n    float br = dot(br_vec, p - b);\n    float tl = dot(tl_vec, p - c);\n    float tr = dot(tr_vec, p - d);\n    \n    \n     // Quintic interpolation\n    f = f*f*f*(f*(f*6.-15.)+10.);\n    \n    // Cubic interpolationn\n    //f = f*f*(3.0 - 2.0*f);\n    \n    float bottom = mix(bl, br, f.x); \n    float top = mix(tl, tr, f.x); \n    \n    return clamp(mix(bottom, top, f.y) + 0.5, 0., 1.);  \n}\n\nfloat celularNoise(vec2 p) {\n\tvec2 i = floor(p);\n    vec2 f = fract(p);\n    \n    float minDist = 100.;\n    \n    for(float x=-1.; x < 2.; x++) {\n        for(float y=-1.; y < 2.; y++) {\n            vec2 coord = vec2(x, y);\n         \tvec2 point = random2(i + coord) + coord;\n            \n            float dist = distance(f, point);\n            \n            minDist = min(minDist, dist); \n        }\n    }\n    \n    return minDist;\n}\n\nfloat fbm(vec2 p, float shift) {\n   float amplitude = 1.0;\n   float freq = 4.;\n   float normalizeFactor = 0.0;\n   float value = 0.0;\n   \n    \n   for(int i = 0; i <= FBM_OCTAVES; i++) {\n      float angle = float(i) * PI;\n      //avoid axis bias\n      mat2 rotate = mat2(cos(angle), -sin(angle), sin(angle), cos(angle));\n      \n      value += perlinNoise(rotate * p * freq + shift) * amplitude;\n      normalizeFactor += amplitude;\n      amplitude *= 0.5;\n      freq *= 2.1;\n   }\n    \n   return value/normalizeFactor;\n}\n\nvec2 fbmGradient(vec2 p, float shift) {\n \tfloat value = fbm(p, shift);\n    \n    float valueX = (fbm(vec2(p.x + DX, p.y), shift) - value)/DX;\n    float valueY = (fbm(vec2(p.x, p.y + DY), shift) - value)/DY;\n    \n    vec2 result = vec2(valueX, valueY);\n    \n    return normalize(result);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 gv = uv * 10.;\n   \n    float t = abs(cos(iTime));\n    float distortion = fbm(uv + t,  0.);\n    float distortionGradient =  dot(\n        vec2(distortion), \n        fbmGradient(uv + t, 0.)\n    );\n    \n    vec3 col = vec3(0.0);\n    col.gb +=fbm(uv + distortionGradient * 0.01, t);\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKyDy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[125, 156, 178, 178, 274], [276, 295, 317, 317, 534], [536, 536, 557, 557, 1073], [1075, 1075, 1102, 1102, 2119], [2121, 2121, 2149, 2149, 2549], [2551, 2551, 2583, 2583, 3067], [3069, 3069, 3108, 3108, 3356], [3358, 3358, 3415, 3415, 3776]]}
{"id": "WstcWS", "name": "Destructured tilling", "author": "HyiKing", "description": "destructured Tiling rectangles squares", "tags": ["rectangles", "square", "chaos", "tiling"], "likes": 0, "viewed": 34, "published": "Public", "date": "1601638352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\nvec3 blueYonder = vec3(88./255., 105./255., 148./255.);\nvec3 laurelGreen = vec3(180./255., 196./255., 174./255.);\nvec3 paleSpringBud = vec3(229./255., 232./255., 182./255.);\nvec3 romanSilver = vec3(125./255., 134./255., 125./255.);//125, 134, 156  // 125, 1, 1\n\n\nfloat hash21(vec2 co) {\n    return fract(sin(dot(co.xy ,vec2(13.9098,78.2143))) * 43658.5553);\n}\n\nvec4 hash24(vec2 co) {\n \t   return vec4(fract(sin(dot(co.yx ,vec2(13.90128,78.2143))) * 43658.5453),\n                   fract(sin(dot(co.xy ,vec2(83.97128,68.2146))) * 48.5453),\n                   fract(sin(dot(co.yx ,vec2(53.9128,68.3346))) * 46.6453),\n                   fract(sin(dot(co.xy ,vec2(59.9158,68.1))) * 86.324));\n}\n\nvec2 rotate(vec2 uv, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * uv;\n}\n\nfloat Rect(vec2 uv, vec2 bottomLeft, vec2 topRight) {\n    vec2 step1 = step(bottomLeft, uv);\n    vec2 step2 = step(1.0-topRight, 1.0-uv);\n    return step1.x*step1.y*step2.x*step2.y;\n}\n\nvec3 chooseColor(float r) {\n    if (r > 0.75) {\n     \treturn blueYonder;\n    } else if (r > 0.50) {\n        return laurelGreen;\n    } else if (r > 0.25) {\n        return paleSpringBud;\n    } else {\n        return romanSilver;\n    }\n}\n\nvec3 drawTile(vec2 uv, float frot, vec4 colr) {\n    uv = rotate(uv, frot*M_PI/2.);\n    \n    float rtopleft = Rect(uv, vec2(-0.5, -0.2), vec2(-0.2, 0.5));\n    float rbottomleft = Rect(uv, vec2(-0.5, -0.5), vec2(-0.2, -0.2));\n    float rtopright = Rect(uv, vec2(-0.2, -0.2), vec2(0.5, 0.5));\n    float rbottomright = Rect(uv, vec2(-0.2, -0.5), vec2(0.5, -0.2));\n\n    vec3 col = vec3(0.3);\n    vec3 square1 = chooseColor(colr.x);\n    vec3 square2 = chooseColor(colr.y);\n    vec3 square3 = chooseColor(colr.z);\n    vec3 square4 = chooseColor(colr.t);\n    col = mix(col, square1, rtopleft);\n    col = mix(col, square2, rbottomleft);\n    col = mix(col, square3, rtopright);\n    col = mix(col, square4, rbottomright);\n    \n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    // Move to the right\n    uv.x += iTime/32.;\n    \n    // Scale for more tiles\n    uv *= 30.0;\n    \n    // Tiling\n    vec2 gv = fract(uv)-0.5;\n    vec2 id = floor(uv);\n    \n    // Scale grid uv in order to add more chaos\n    gv.x /= sin(4.*iTime)+2.0;\n    gv.y /= cos(8.*iTime)+2.0;\n    \n    // Rotate the tile randomly\n    // choose 4 random colors for the rectangles in the tile\n    float frot = floor(hash21(id)*10.);//*iTime/5.;\n    vec4 colr = hash24(id+3.);\n            \n   \t// finaly draw the tile.\n    vec3 col = drawTile(gv, frot, colr);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstcWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 311, 334, 334, 407], [409, 409, 431, 431, 737], [739, 739, 770, 770, 855], [857, 857, 910, 910, 1040], [1042, 1042, 1069, 1069, 1275], [1277, 1277, 1324, 1324, 2010], [2012, 2012, 2067, 2117, 2802]]}
{"id": "wstyWf", "name": "CoNoise", "author": "Swax97", "description": "Inspired by the noise pattern in https://www.shadertoy.com/view/wtXfRH", "tags": ["noise", "fbm", "cosine"], "likes": 17, "viewed": 229, "published": "Public", "date": "1601913350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Based on https://www.shadertoy.com/view/wtXfRH\n\nvec3 fcos( vec3 x )\n{\n    vec3 w = fwidth(x);\n    #if 0\n    return cos(x) * sin(0.5*w)/(0.5*w);     // filtered-exact\n\t#else\n    return cos(x) * smoothstep(6.28,0.0,w); // filtered-approx\n\t#endif  \n}\n\nvec2 fcos(vec2 x)\n{\n\tvec2 w = fwidth(x);\n    return cos(x) * sin(0.5*w)/(0.5*w);\n}\n\nvec3 getColor( in vec2 p )\n{\n    vec3 col = vec3(0.4,0.4,0.4);\n\t\n    col += 0.12*fcos(6.28318*p.x*  1.1+vec3(+1.0,1.0,0.0));\n    col += 0.11*fcos(6.28318*p.y*  3.1+vec3(-1.0,0.0,1.0));\n    col += 0.10*fcos(6.28318*p.x*  5.1+vec3(+1.0,1.0,0.0));\n    col += 0.09*fcos(6.28318*p.y*  9.1+vec3(-1.0,0.0,1.0));\n    col += 0.08*fcos(6.28318*p.x* 17.1+vec3(+1.0,1.0,0.0));\n    col += 0.07*fcos(6.28318*p.y* 33.1+vec3(-1.0,0.0,1.0));\n    col += 0.06*fcos(6.28318*p.x* 65.1+vec3(+1.0,1.0,0.0));\n    col += 0.05*fcos(6.28318*p.y*129.1+vec3(-1.0,0.0,1.0));\n    col += 0.04*fcos(6.28318*p.x*257.1+vec3(+1.0,1.0,0.0));\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordinates\n\tvec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    p *= 2.0;\n    //p += 100.0;\n    vec2 q = p;\n    \n    // deform\n    float a = 1.5;\n    float b = 0.5;\n    float c = 0.0;\n    \n    vec2 o1 = vec2(1.0, 1.0);\n    vec2 o2 = vec2(1.0, 2.0);\n    for (int i = 0; i < 16; i++){\n        p += clamp(1.0, 0.0, a)*cos(b*p.yx + c*iTime + o1);\n        a *= 0.502357;\n        b *= 2.02357;\n        c += 0.05;\n        \n        vec2 ot = o1;\n        o1 += o2;\n        o2 = ot;\n    }\n\n    // base color pattern\n    vec3 col = getColor(p*0.1);\n    \n    \n    //b = dot(p-q,p-q);\n    //col *= clamp(1.0, 0.0, 1.0-b*8.0);\n \n   fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstyWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 51, 72, 72, 250], [252, 252, 271, 271, 334], [336, 336, 364, 364, 958], [960, 960, 1016, 1035, 1680]]}
{"id": "WstyWj", "name": "YellowFun", "author": "Del", "description": "Yellow Fun - Hold mouse button for something completely different!", "tags": ["yellow", "mirror", "xrepeat"], "likes": 2, "viewed": 162, "published": "Public API", "date": "1601750834", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Yellow Fun - Del 03/10/2020\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv = (iResolution.xy - 2.0*fragCoord.xy)/iResolution.y;\n\tfloat t = iTime+1.0;\n\tvec3 color1 = vec3( 1.0, 1.0, 0.0 );\n\tvec3 color2 = vec3( 0.4, 0.4, 0.1 );\n    \n\tuv.x *= 2.0+sin(t*0.4);\n    if (iMouse.z<0.5)\n    \tuv.x = dot(uv,uv)*0.1;\n\tfloat c = floor((uv.x + 0.25)/0.5);\n\tuv.x = mod(uv.x + 0.25,0.5) - 0.25;\n\tuv.x *= -(mod(c, 2.0)*2. - 1.);\n\tfloat v1 = sin(fract(t*.05)*6.28);\n\tfloat v2 =sin(fract(t*.027)*6.28) *24.4; \n\tuv.x += sin(fract(uv.x*4.0+t*.6)*6.28+(uv.x*v2+uv.y*35.0)*v1)*0.09;\n\tfloat curve = 0.1;\n   \tvec3 col = mix( color1, color2, smoothstep( 0.5-curve,0.5+curve,uv.x+0.5) );\t\n\tfragColor = vec4(col, 1.0);    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstyWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 31, 88, 88, 723]]}
{"id": "wstyWl", "name": "dust02", "author": "Del", "description": "A simple nebula rendered using some volumetric noise and a hacky voronoi starfield - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]", "tags": ["voronoi", "volumetric", "nebula", "starfield", "wavelet"], "likes": 10, "viewed": 584, "published": "Public API", "date": "1602017968", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// simple nebula rendered using some volumetric noise and a hacky voronoi starfield - Del 06/10/2020\n// this shader is purely used for baking a procedural cubemap texture, please ignore the hackery & lack of speed - a realtime version would require some baked noise textures.\n// WaveletNoise by BigWigs, Voronoi by IQ.\n\nvec3 erot(vec3 p, vec3 ax, float ro)\n{\n    return mix(dot(p,ax)*ax,p,cos(ro))+sin(ro)*cross(ax,p);\n}\n\nfloat WaveletNoise(vec3 p, float z, float k) {\n    // https://www.shadertoy.com/view/wsBfzK\n    float d=0.,s=1.,m=0., a;\n    for(float i=0.; i<3.; i++) {\n        vec3 q = p*s, g=fract(floor(q)*vec3(123.34,233.53,314.15));\n    \tg += dot(g, g+23.234);\n\t\ta = fract(g.x*g.y)*1e3 +z*(mod(g.x+g.y, 2.)-1.); // add vorticity\n        q = (fract(q)-.5);\n        q = erot(q, normalize(tan(g+.1)), a);\n        d += sin(q.x*10.+z)*smoothstep(.25, .0, dot(q,q))/s;\n        p = erot(p,normalize(vec3(-1,1,0)),atan(sqrt(2.)))+i; //rotate along the magic angle\n        m += 1./s;\n        s *= k; \n    }\n    return d/m;\n}\n\nvec3 hash( vec3 x )\n{\n\tx = vec3( dot(x,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(x,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(x,vec3(113.5,271.9,124.6)));\n\treturn fract(sin(x)*43758.5453123);\n}\n\n// returns closest, second closest, and cell id\nvec3 voronoi( in vec3 x )\n{\n    vec3 p = floor( x );\n    vec3 f = fract( x );\n\n\tfloat id = 0.0;\n    vec2 res = vec2( 100.0 );\n    for( int k=-1; k<=1; k++ )\n    for( int j=-1; j<=1; j++ )\n    for( int i=-1; i<=1; i++ )\n    {\n        vec3 b = vec3( float(i), float(j), float(k) );\n        vec3 r = vec3( b ) - f + hash( p + b );\n        float d = dot( r, r );\n\n        if( d < res.x )\n        {\n\t\t\tid = dot( p+b, vec3(1.0,57.0,113.0 ) );\n            res = vec2( d, res.x );\t\t\t\n        }\n        else if( d < res.y )\n        {\n            res.y = d;\n        }\n    }\n\n    return vec3( sqrt( res ), abs(id) );\n}\n\n// starfield hack :)\nfloat stars(vec3 pp1)\n{\n    float f;\n    vec3 vv = voronoi(pp1);\n    f = vv.x;\n    float size = abs(sin((vv.z*32.3215))*9.0);\n    f = 1.0-(f*(19.0+size));\n  \tfloat twink = 0.5+sin(f+iTime*1.3+vv.z)*0.5;\n    f = clamp(f+(twink*0.2),0.0,1.0);\n   \treturn f;\n}\n\n#define brightness -7.\n#define saturation 0.95\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv=fragCoord.xy/iResolution.xy-.5;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 dir=vec3(uv*0.8,1.);\n\tfloat time=iTime*0.04;\n\n\t//rotation\n    vec2  mm = iMouse.xy/iResolution.xy;\n\tfloat a1=0.5+(mm.x*0.5);\n\tfloat a2=0.8+(mm.y*0.8);\n    \n\tmat2 rot1=mat2(cos(a1),sin(a1),-sin(a1),cos(a1));\n\tmat2 rot2=mat2(cos(a2),sin(a2),-sin(a2),cos(a2));\n\tdir.xz*=rot1;\n\tdir.xy*=rot2;\n\tvec3 from=vec3(1.,.5,.75);\n\tfrom+=vec3(time*1.8,time,-5.);\n\tfrom.xz*=rot1;\n\tfrom.xy*=rot2;\n\t\n\t// volumetric\n\tfloat s=0.1;\n    float fade=1.;\n\tvec3 v=vec3(0.);\n\tfor (int r=0; r<25; r++)\n    {\n\t\tvec3 p=from+s*dir*.5;\n\t\tvec3 p2 = p*2.9;\n\t\tfloat a = WaveletNoise(p2, 0.0, 1.9)*2.0 - 1.0;\n\t\ta *= a * a;\n\t\tv += vec3(s, s*s, s*s*s*s)* a * brightness * fade;\n\t\tfade *= 0.905;\n\t\ts += 0.032*1.55;\n\t}\n\n    // Star hack\n    float f = 1.0;\n    vec3 pp1=from+dir*1.1;\n\tf = stars(pp1*20.0);\n    pp1=from+dir*1.35;\n\tf = max(f,stars(pp1*20.0));\n    pp1=from+dir*1.7;\n\tf = max(f,stars(pp1*20.0));\n    \n\tv=mix(vec3(length(v)),v,saturation);\n    v = clamp(v.gbr*0.01,vec3(0.0),vec3(1.0));\n    v+=v*f;\t// dirty starblend\n\tfragColor = vec4(v,1.);\t\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstyWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 320, 358, 358, 420], [422, 422, 468, 513, 1026], [1028, 1028, 1049, 1049, 1206], [1208, 1256, 1283, 1283, 1863], [1865, 1886, 1909, 1909, 2142], [2192, 2192, 2249, 2249, 3349]]}
{"id": "wstyWX", "name": "Dodecahedron chain", "author": "gaz", "description": "inspired https://twitter.com/Yugemaku/status/1312150562851364864", "tags": ["bokeh", "dodecahedron"], "likes": 16, "viewed": 173, "published": "Public", "date": "1601903608", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.)\n#define pmod(p,n) (length(p)*sin(vec2(0,PI*.5)+mod(atan(p.x,p.y),PI*2./n)-PI/n))\n\nmat3 lookat(vec3 eye, vec3 target, vec3 up){\n    vec3 w=normalize(target-eye), u=normalize(cross(w,up));\n    return mat3(u,cross(u,w),w);\n}\n\nvoid rot3(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(u,a);\n\tp=u*cos(t)+v*sin(t)+a*dot(p,a);   \n}\n\nfloat map(vec3 p){\n    rot3(p,vec3(1,2,3),iTime*.7);\n\trot3(p,vec3(5,2,3),iTime*.5);\n    float d=1e3;\n    for(int i=0;i<6;i++){\n        vec3 w=normalize(vec3(sqrt(5.)*.5+.5,(i&1)*2-1,0)); \n        w=vec3[](w,w.yzx,w.zxy)[i%3];\n        vec3 up=-sign(w.x+w.y+w.z)*sign(w)*w.zxy;\n        vec3 u=normalize(cross(w,up));\n    \tvec3 q=vec3(dot(p,u),dot(p,cross(u,w)),dot(p,w));\n    \trot3(q,vec3(0,0,1),PI/5.);\n    \tq.xy=pmod(q.xy,5.);\n    \tq.x=abs(q.x);\n    \tvec3 q0=q;\n    \tfloat r=1.;\n    \tq0.y-=r;\n    \td=min(d,length(vec2(length(q0.xy)-.15,q0.z))-.05);\n    \tq.xy=vec2(atan(q.x,abs(q.y))*r, length(q.xy)-r);\n\t    q.x-=clamp(q.x,.2,2.);\n\t    d= min(d,length(q)-.05);\n    }\n    return d;\n}\n\nvec3 calcNormal(vec3 p){\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(2.*fragCoord-iResolution.xy)/iResolution.y;\n    vec3 bg=vec3(1);\n    vec3 ro0=vec3(0,0,2.5);\n    vec3 ta=vec3(.1,.05,0);\n    vec3 rd0=normalize(vec3(p,2.));\n    vec3 sv=normalize(cross(ta-ro0,vec3(0,1,0)))*.04;\n    float b=6.;  \n\tfor (float j=0.; j<b; j++){\n        vec3 ro = ro0+sv;\n        vec3 rd = lookat(ro,ta,vec3(0,1,0)) * rd0;\n\t\tfloat z = 0., d, i, ITR=70.;\n \t\tfor( i = 0.; i < ITR; i++){\n    \t\tz += d = map(ro + rd * z);\n    \t\tif(d < .001 || z > 30.) break;\n  \t\t}\n    \tif(d < .001){\n\t  \t\tvec3 p = ro + rd * z;\n\t \t\tvec3 nor = calcNormal(p);\n    \t\tvec3 li = normalize(vec3(1));\n        \tvec3 col = vec3(1.,.9,.8)*.7;\n        \tcol *= pow(1.-i/ITR,2.); \n       \t \tcol *= clamp(dot(nor,li),.3,.8);\n        \tcol *= max(.5+.5*nor.y,0.);\n            float rimd = pow(clamp(1.-dot(reflect(-li,nor),-rd),0.,1.),2.5);\n\t\t    float frn = rimd+2.2*(1.0-rimd);\n    \t    col *= frn*.8;\n        \tcol += pow(clamp(dot(reflect(normalize(p-ro),nor),li),0.,1.),30.);\n        \tcol *= exp(-z*z*0.05);\n         \tcol = min(vec3(1),col*2.);\n        \tbg += col;\n    \t}\n        rot3(sv, normalize(ta-ro0), PI*2./b);\n\t}\n    bg = clamp(bg/b,0.,1.);\n    fragColor.xyz = pow(bg,vec3(1.8));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstyWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 147, 147, 242], [244, 244, 283, 283, 371], [373, 373, 391, 391, 1055], [1057, 1057, 1081, 1081, 1224], [1226, 1226, 1283, 1283, 2461]]}
{"id": "wsVcDd", "name": "Pretty Pumpkin'", "author": "Dombass", "description": "A raymarched pumpkin for halloween, hacked together like a frankenstein monster.", "tags": ["halloween"], "likes": 6, "viewed": 159, "published": "Public", "date": "1604108192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(vec3 a, vec3 b, float r) {\n    return length(max(abs(a)-b, 0.)) - r;\n}\n\nfloat torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p, vec3 cone)\n{\n\tfloat d = sphere(p*cone, vec4(.0,-1.,.0,1.));\n\tfloat fl = abs(d + (noise(p+vec3(1.,iTime*.75,1.0)) + noise(p*3.)*.5)*.25*(p.y)) ;\n    return min(20.-d , fl );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nconst float MAX = 200.;\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat scene(in vec3 pos) {\n\tfloat box = boxSDF(pos,vec3(3.5,0.25,3.5), .2);\n    \n    mat4 r = rotationX(3.14/2.0);\n    vec4 rotated = vec4(pos, 1.0)*r;\n    float limit = 3.14;\n    const float step = 0.04;\n    float thicc = .65;\n    float final = torus(rotated.xyz, vec2(1.2, thicc));\n    for(float i = step; i < .63; i += step)\n    {\n        vec4 new = rotated*rotationZ(3.14/i);\n    \t//final = opSmoothUnion(final, torus(new.xyz, vec2(1.2f, thicc)), 0.07);\n        final = min(final, torus(new.xyz, vec2(1.2, thicc)) );\n    }\n    \n    {\n    \tvec3 toTheLeft = pos;\n    \ttoTheLeft.x -= .8;\n    \ttoTheLeft.z -= 2.;\n    \tfloat sphere = sphereSDF(toTheLeft, .4);\n    \tfinal = opSmoothSubtraction(sphere, final, 0.01);\n    }\n    \n    {\n    \tvec3 toTheLeft = pos;\n    \ttoTheLeft.x += .85;\n    \ttoTheLeft.z -= 2.0;\n    \tfloat sphere = sphereSDF(toTheLeft, .4);\n    \tfinal = opSmoothSubtraction(sphere, final, 0.01);\n    }\n    \n     {\n    \tvec3 toTheLeft = (vec4(pos, 1.)*rotationZ(3.14)).xyz;\n    \ttoTheLeft.y += .1;\n    \ttoTheLeft.z -= 1.7;\n    \tfloat sphere = sdCappedTorus(toTheLeft, vec2(0.2, 0.1),1., .2);\n    \tfinal = opSmoothSubtraction(sphere, final, 0.01);\n    }\n\n    {\n        vec3 toTheLeft = (vec4(pos, 1.)*rotationZ(3.14)).xyz;\n        final = opSmoothUnion(final, flame(toTheLeft, vec3(1., .4, 1.)), .07);\n    }\n    {\n        vec3 toTheLeft = (vec4(pos, 1.)*rotationZ(3.14)).xyz;\n        final = opSmoothUnion(final, flame(toTheLeft, vec3(1.75, .4, 1.75)), .07);\n    }\n    \n    \n    return final;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*scene( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*scene( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*scene( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*scene( pos + e.xxx ) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.01;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(scene(p) < 0.)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 eye = (vec4(0, 2.1, 10., 1)).xyz;//*rotationZ(iTime)).xyz;\n    vec3 rayDir = rayDirection(90., iResolution.xy, fragCoord);\n    vec4 p = raymarch(eye, rayDir);\n\tfloat glow = p.w;\n\t\n    vec3  lig = normalize( vec3(-0.0, -5., 0.) );\n    vec3  lig2 = normalize( vec3(-0.0, 5., 4.) );\n    vec3 hal = lig - rayDir;\n    \n    vec3 normal = calcNormal(p.xyz);\n    \n    float dif = clamp( dot( normal, lig ), 0.0, 1. );\n    float dif2 = clamp( dot( normal, lig2 ), 0.0, 1. );\n    vec3 mate = vec3(0.3);\n    vec3 col = mate*dif*4.*vec3(.9,0.4,0.1);\n    vec3 col2 = mate*dif2*4.*vec3(.9,0.1,0.1);\n    \n    vec4 blah =  vec4(1.,.5,.1, 1.);//mix(vec3(0.), vec3(0.7,0.0,0.0), p.y*.04);\n    fragColor = mix(vec4(col, 1.), blah, pow(glow*2.,4.));\n    fragColor = mix(fragColor, vec4(col2, 1.), 0.5);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVcDd.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 36, 36, 175], [177, 177, 211, 211, 347], [349, 349, 383, 383, 516], [518, 518, 552, 552, 580], [582, 582, 621, 621, 665], [667, 667, 698, 698, 763], [765, 765, 807, 807, 1044], [1046, 1046, 1078, 1078, 1115], [1117, 1117, 1149, 1149, 1311], [1313, 1313, 1378, 1378, 1510], [1512, 1512, 1582, 1582, 1716], [1743, 1743, 1795, 1795, 1894], [1896, 1896, 1954, 1954, 2054], [2056, 2056, 2082, 2082, 3561], [3563, 3563, 3595, 3595, 3803], [3805, 3805, 3840, 3840, 4118], [4120, 4120, 4177, 4177, 4972]]}
{"id": "WsVcRd", "name": "big chungus", "author": "pikmin2010", "description": "chungus", "tags": ["bigchungus"], "likes": 4, "viewed": 268, "published": "Public API", "date": "1603590541", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The MIT License\n// Copyright © 2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n//\n// More info here:\n//\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n//------------------------------------------------------------------\n#define March_Quality 32\n#define Shadow_Quality 4\n#define AO_Quality 8\n#define Lighting 1\n#define Epsilon 0.00001\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\n\n\n/**\n * Rotation matrix around the X axis.\n */\nmat3 rotateX(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(1, 0, 0),\n        vec3(0, c, -s),\n        vec3(0, s, c)\n    );\n}\n\n/**\n * Rotation matrix around the Y axis.\n */\nmat3 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, 0, s),\n        vec3(0, 1, 0),\n        vec3(-s, 0, c)\n    );\n}\n\n/**\n * Rotation matrix around the Z axis.\n */\nmat3 rotateZ(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n    return mat3(\n        vec3(c, -s, 0),\n        vec3(s, c, 0),\n        vec3(0, 0, 1)\n    );\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n    return length(p)-s;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n\n\n//------------------------------------------------------------------\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 opB( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x>d2.x) ? d1 : d2;\n}\n\nvec3 opRepLim(  vec3 p,  float c, vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return ( q );\n}\n//------------------------------------------------------------------\n\n#define ZERO (min(iFrame,0))\n\n//------------------------------------------------------------------\n\nvec2 map( in vec3 pos )\n{\n    pos = opRepLim(pos,3.,vec3(1,1,1));\n    pos.y +=0.2;\n    pos.y *=0.9;\n    vec2 belly = vec2( sdSphere(    pos-vec3(.0,0., 0.2), 0.5 ), 11  );\n\n    vec2 brownBelly = vec2(sdSphere(    pos-vec3(.0,0., 0.0), 0.6), 12  );\n    vec2 brownHead = vec2(sdSphere(    pos-vec3(.0,0.6, 0.0), 0.4), 12  );\n    vec3 eyePos = pos;\n    eyePos.x *=1.3;\n    vec2 whiteEyeL = vec2(sdSphere(    eyePos-vec3(.15,0.65, 0.25),0.15), 11  );\n    vec2 whiteEyeR = vec2(sdSphere(    eyePos-vec3(-.15,0.65, 0.25), 0.15), 11  );\n    vec2 brownEyeL = vec2(sdSphere(    eyePos-vec3(.15,0.73, 0.22),0.15), 12  );\n    vec2 brownEyeR = vec2(sdSphere(    eyePos-vec3(-.15,0.73, 0.22), 0.15), 12  );\n\tvec2 pupilEyeL = vec2(sdSphere(    eyePos-vec3(.15,0.65, 0.37),0.05), 13  );\n    vec2 pupilEyeR = vec2(sdSphere(    eyePos-vec3(-.15,0.65, 0.37), 0.05), 13  );\n\t\n    vec3 furPos = pos;\n    furPos.x *=0.5;\n    \n    vec2 mouthFur = vec2(sdSphere( furPos-vec3(0.,0.44,0.35),0.11),11);\n    vec2 mouthFur2 = vec2(sdSphere( furPos-vec3(0.,0.5,0.35),0.09),11);\n    vec2 mouthFur3 = vec2(sdSphere( furPos-vec3(0.,0.56,0.42),0.04),11);\n    vec3 earPos = pos;\n    earPos.z *=1.6;\n    earPos.x *=1.7;\n    earPos.y *=0.5;\n    vec2 brownEarL = vec2(sdSphere(earPos-vec3(0.27,0.5,0.),0.25),12);\n\tvec2 brownEarR = vec2(sdSphere(earPos-vec3(-0.27,0.5,0.),0.25),12);\n    vec2 redEarL = vec2(sdSphere(earPos-vec3(0.27,0.5,0.1),0.18),14);\n\tvec2 redEarR = vec2(sdSphere(earPos-vec3(-0.27,0.5,0.1),0.18),14);\n    vec3 mouthPos = pos;\n\tmouthPos.y -= 0.5;\n    mouthPos.z +=0.14;\n    vec2 mouthSub = vec2(sdBox(mouthPos-vec3(0,-0.05,.5),vec3(0.1,0.1,0.1)),15);\n    vec2 redMouth = vec2(sdSphere(mouthPos-vec3(0.,0.,.5),0.1),15);\n\tredMouth = opB(redMouth,mouthSub);\n    \n    vec2 teeth = opU(vec2(sdBox(mouthPos-vec3(0.035,0.031,0.59),vec3(0.025,0.03,0.005)),11),vec2(sdBox(mouthPos-vec3(-0.035,0.031,0.59),vec3(0.025,0.03,0.005)),11));\n    \n    vec3 feetPos =pos;\n    feetPos.y += 0.4;\n    feetPos.x *=0.7;\n    \n    vec2 leftFoot = vec2(sdSphere(feetPos-vec3(-0.30,0,0),0.25),12);\n    vec2 rightFoot = vec2(sdSphere(feetPos-vec3(0.30,0,0),0.25),12);\n    \n    feetPos.y *=1.1;\n    vec2 leftFootWhite = vec2(sdSphere(feetPos-vec3(-0.40,-0.05,0),0.25),11);\n    vec2 rightFootWhite = vec2(sdSphere(feetPos-vec3(0.40,-0.05,0),0.25),11);\n    vec2 feetWhite = opU(leftFootWhite,rightFootWhite);\n    vec2 feet = opU(leftFoot,rightFoot);\n    feet = opU(feetWhite,feet);\n    \n    \n    vec2 rightArm = vec2(sdCylinder(pos-vec3(0.5,0.25,0.),vec3(0,0,0),vec3(0.5,0,0),0.1),12);      \n    vec2 leftArm = vec2(sdCylinder(pos-vec3(-0.5,0.25,0.),vec3(0,0,0),vec3(-0.5,0,0),0.1),12);\n\tvec2 leftHand = vec2(sdSphere(pos-vec3(-1.0,0.25,0),0.15),11);\n    vec2 rightHand = vec2(sdSphere(pos-vec3(1.0,0.25,0),0.15),11);\n    \n    vec2 res =opU(brownBelly,belly);\n    res = opU(res,brownHead);\n    res = opU(res,whiteEyeL);\n    res = opU(res,whiteEyeR);\n    res = opU(res,brownEyeR);\n\tres = opU(res,brownEyeL);\n    res = opU(res,pupilEyeR);\n\tres = opU(res,pupilEyeL);\n    res = opU(res,mouthFur);\n    res = opU(res,mouthFur2);\n    res = opU(res,mouthFur3);\n    res = opU(res,brownEarL);\n    res = opU(res,brownEarR);\n    res = opU(res,redEarL);\n    res = opU(res,redEarR);\n    res = opU(res,redMouth);\n    res = opU(res,teeth);\n\tres = opU(res,feet);\n    res = opU(res,rightArm);\n    res = opU(res,leftArm);\n    res = opU(res,leftHand);\n    res = opU(res,rightHand);\n\n    return res;\n}\n\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n   \n    //else return res;\n    \n    // raymarch primitives   \n\n        float t = tmin;\n        for( int i=0; i<March_Quality && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(Epsilon*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x;\n        }\n    \n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<Shadow_Quality; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<AO_Quality; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\n\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    \n    if( m>-0.5 )\n    {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if(m>=10.){\n        if(m<=11.){\n         col = vec3(1,1,1);   \n        }else if(m<=12.){\n         col = vec3(0.45,0.4,0.4);   \n        }else if(m<=13.){\n            col = vec3(0.,0.,0.);\n        }else if(m<=14.){\n            col = vec3(0.85,0.54,0.50);\n        \n        }else if(m<=15.){\n            col = vec3(0.75,0.47,0.63);\n        }\n    \n  \n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n        \n        \n            ks = 0.4;\n        }\n        if(Lighting ==1){\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(1.5, 0.8, 0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n        }\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0., -0., -0. );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.1);\n\n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.45) );\n\n        tot += col;\n\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVcRd.jpg", "access": "shaders20k", "license": "mit", "functions": [[1439, 1622, 1647, 1647, 1666], [1667, 1667, 1692, 1692, 1711], [1712, 1712, 1748, 1748, 1776], [1780, 1826, 1853, 1853, 2000], [2002, 2048, 2075, 2075, 2222], [2224, 2270, 2297, 2297, 2444], [2446, 2446, 2481, 2481, 2507], [2509, 2509, 2540, 2540, 2631], [2634, 2634, 2686, 2686, 2800], [2803, 2815, 2851, 2851, 2954], [2956, 2981, 3032, 3032, 3387], [3391, 3461, 3491, 3491, 3524], [3526, 3526, 3556, 3556, 3589], [3591, 3591, 3634, 3634, 3695], [3796, 3866, 3891, 3891, 7296], [7298, 7298, 7349, 7349, 7554], [7556, 7556, 7596, 7596, 8051], [8053, 8115, 8193, 8216, 8615], [8617, 8681, 8713, 8713, 9283], [9285, 9285, 9327, 9327, 9645], [9647, 9725, 9790, 9809, 12550], [12552, 12552, 12604, 12604, 12781], [12783, 12783, 12840, 12840, 13853]]}
{"id": "WsVczh", "name": "Example 18 - light cone", "author": "jt", "description": "How to iimplement a flashlight or view-cone.", "tags": ["example", "light", "flashlight", "cone"], "likes": 0, "viewed": 58, "published": "Public", "date": "1602233825", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define angle radians(22.5)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = 2.0 * fragCoord/iResolution.xy - 1.0;\n\n    //vec2 dir = vec2(1.0, 0.0);\n    vec2 dir = vec2(cos(iTime), sin(iTime));\n    \n    //fragColor = vec4(step(sqrt(0.5), dot(uv, dir) / (length(uv) * length(dir))));\n    fragColor = vec4(step(cos(angle),\n                          dot(normalize(uv), normalize(dir))));\n        \n    //fragColor = vec4(uv, 0.0, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVczh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[29, 29, 86, 86, 457]]}
{"id": "WsVczw", "name": "Psuedoinverse point in triangle", "author": "copperbotte", "description": "Simple point-in-triangle test. Probably more complex than it needs to be.\n\nBased on a post from blackpawn:\nhttps://blackpawn.com/texts/pointinpoly/", "tags": ["simple", "math", "triangle"], "likes": 1, "viewed": 70, "published": "Public", "date": "1602490552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//point in tri\n//projects point onto a plane defined by tri,\n//then reprojects it onto a new coordinate system defined by said triangle as bases.\n//if the point lies within a right triangle of lengths 1,1, its in the triangle.\n//this is equivelant to the barycentric technique.\n//\n//based on this post from blackpawn, re-derived to find underlying psuedoinverse.\n//https://blackpawn.com/texts/pointinpoly/\n\nbool inTri(in vec3 point, in mat3 tri)\n{\n    //move space toward first vertex\n    //maybe use a mul?\n    point -= tri[0];\n    tri -= mat3(tri[0],tri[0],tri[0]);\n    //v1 -= v0;\n    //v2 -= v0;\n    //vt -= v0;\n    \n    //using v1 and v2 as a basis, find a vector normal to both to build a plane\n    vec3 norm = normalize(cross(tri[1], tri[2]));\n    \n    //find the projection of vt onto the normal\n    float proj = dot(point, norm);\n    \n    //if(proj * proj < 0.01) // point is not on plane of triangle\n    //    return false;\n    \n    //move point onto plane of triangle\n    point -= norm * proj;\n    \n    //v1 and v2 form a basis space, whose linear combination is vt. vt = a*v1 + b*v2.\n    //Since vt is guaranteed to be on the plane between the two, its psuedoinverse is its inverse.\n    //moore-penrose psuedoinverse: (MT*M)^-1 * MT = M+\n    \n    mat2x3 space = mat2x3(tri[1], tri[2]); // can this be truncated from tri?\n    mat3x2 st = transpose(space);\n    mat2x2 inv = st * space;\n    \n    //if the inverse's inputs has no determinant, it covers no area, and has no inverse.\n    if(determinant(inv) == 0.0)\n        return false;\n    \n    mat3x2 mpi = inverse(inv) * st;\n    vec2 mpipt = mpi * point; // move into basis space\n    \n    //if the point does not lie within the unit triangle, it misses.\n    if(mpipt.x < 0.0)\n        return false;\n    if(mpipt.y < 0.0)\n        return false;\n    if(1.0 < dot(mpipt, vec2(1,1)))\n       return false;\n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec2 xy = uv * 2.0 - 1.0;\n    xy.y *= iResolution.y / iResolution.x;\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos((iTime+uv.xyx+vec3(0,2,4))*1.0);\n\n    vec3 vb[3] = vec3[3](\n    \tvec3(-0.5,-0.5,0.0),\n        vec3(0.5,-0.5,0.0),\n        vec3(0.0,0.5,0.0)\n    );\n    \n    if(inTri(vec3(xy,0.0), mat3(vb[0], vb[1], vb[2])))\n       col = vec3(1,1,1);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVczw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 408, 448, 508, 1878], [1880, 1880, 1937, 1987, 2462]]}
{"id": "WsVczz", "name": "Snowing - Snowflake", "author": "shadermonkey", "description": "It is snowing!", "tags": ["snowflake", "snow", "winter", "cold", "crystal", "shadermonkey"], "likes": 7, "viewed": 213, "published": "Public", "date": "1602149330", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a,b,t) smoothstep(a,b,t)\n#define N 80\n\nfloat pi = 3.141592653589793238462643383;\nvec3 snowBlue = vec3(.4);\nvec2 XY = vec2(8./9.,.5);\n\n\n//Coordinate Transformation\nvec2 RectToPolar(vec2 uv){\n    vec2 pol_uv = vec2(length(uv), atan(uv.x/uv.y));\n    float st_a = fract(pol_uv.y/(pi/3.))/(pi/3.) -.5;\n    return vec2(pol_uv.x, st_a);\n}\nvec2 PolarToRect(vec2 st){\n    float ratio = pi/6./.5;\n    return st.x*vec2(cos(st.y*ratio), sin(st.y*ratio));\n}\n\n//Map v to Range(i,f)\nfloat Map(float i, float f, float v){\n    if(v > f){\n        float a = ceil((v-f)/(f-i));\n        return v - a*(f-i);\n    } else if (v < i){\n        float a = ceil((i-v)/(f-i));\n        return v + a*(f-i);\n    } else return v;\n}\nvec2 Rotate(vec2 st, float angle){\n    float ratio = pi/6./.5;\n    st.y += angle/ratio;\n    st.y = Map(-.5,.5,st.y);\n    return st;\n}\nfloat Line(vec2 pi, vec2 pf, float d, vec2 st){\n    vec2 pi_rect = PolarToRect(pi);\n    vec2 pf_rect = PolarToRect(pf);\n    vec2 st_rect = PolarToRect(st);\n    \n    vec2 v1 = pf_rect - pi_rect; \n    float l = length(v1);\n    vec2 v2 = st_rect - pi_rect;\n    vec2 v3 = st_rect - pf_rect;\n    float d1 = length(v2);\n    float d2 = length(v3);\n    float perpD = d1*sqrt(1.-pow((dot(v1,v2)/l/length(v2)),2.));\n    \n    float x1 = abs(dot(v2,v1)/l);\n    float x2 = abs(dot(v3,v1)/l);\n    if(x1 < l){\n        if(x2 < l){\n            if(perpD < d) {\n                return S(d,0.,perpD);\n            }\n        } else if(d1 < d) {\n            return 0.;\n        }\n    } else {\n        if (d2 < d) {\n            return S(d,0.,d2);\n        }\n    }\n\n    return 0.;\n}\n    \n//Random with iMouse.x as parameter\nfloat Random(float s){ //[-1,1]\n    return fract(cos((iMouse.x +.2)*s)*73.17) * 2. - 1.;\n}\n\nfloat SnowFlake(vec2 st, float size, float seed){\n    st.x /= size;\n    vec2 st_rect = PolarToRect(st);\n    \n    float ringR = XY.y;\n    float ringW = abs(Random(.232*seed)) * .015 + .02;\n    float result = 0.;\n    result += Line(vec2(0.,0.), vec2(ringR,0.), ringW/2., st);\n    float ratio = pi/6./.5;\n    float angle = pi/3.;\n    float dx = .05;\n    \n    //Each line\n    for(float x = 0.02; x < ringR; x+= .05){\n        float r = x;\n        float l = (ringR-r)*r*2.5*abs(Random(r*seed));\n        float c = pow(pow(l,2.) + pow(r,2.) - 2.*l*r*cos(pi -angle),.5);\n        float angle2 = asin(sin(pi -angle)/c*l);\n        result += Line(vec2(r,.0), vec2(c,angle2/ratio), ringW, vec2(st.x,abs(st.y)));\n    }\n    return result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= vec2(.5);\n \tuv.x *= iResolution.x/iResolution.y;\n    float t = iTime*.2;\n    \n\tfloat ratio = pi/6./.5;\n    \n    vec3 col = vec3(.0,.0,.1);\n    for(int i = 0; i < N; i++){\n        //speed\n        float vy = abs(Random(float(i)*3.))*.5 + .1;\n        float vx = sin((float(i)+t)/2.)*.5;\n        float va = Random(float(i)*7.)*.5 + .2;\n        \n        //size\n        float size = abs(Random(float(i)*12.));\n        if(float(i) < float(N)* .1) {\n            size *= .4;\n        } else if(float(i) < float(N) * .7){\n            size *= .3;\n        } else size *= .25;\n        \n        //position\n\t\tvec2 XY_ = XY + XY*size;\n        vec2 orgOffset = vec2(Random(float(i))*.8, Random(float(i)*2.)*.5);\n        vec2 moveOffset = vec2(vx,vy*t);\n        vec2 offset = orgOffset + moveOffset;\n        offset.y = Map(-XY_.y,XY_.y, offset.y);\n        offset.x = Map(-XY_.x,XY_.x, offset.x);\n        vec2 pos = uv + offset;\n        \n        vec2 st = RectToPolar(pos);\n        st = Rotate(st, pi * va*t);\n        col += SnowFlake(st, size, float(i))*snowBlue*pow((size)/.4,2.);\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVczz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[145, 173, 199, 199, 341], [342, 342, 368, 368, 454], [456, 478, 515, 515, 706], [707, 707, 741, 741, 840], [841, 841, 888, 888, 1596], [1602, 1638, 1660, 1669, 1728], [1730, 1730, 1779, 1779, 2454], [2455, 2455, 2512, 2512, 3669]]}
{"id": "WsVyR1", "name": "KiraShapes", "author": "nanase", "description": "Simple shapes.", "tags": ["simple", "shapes"], "likes": 4, "viewed": 70, "published": "Public", "date": "1602235861", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 hsv2rgb(float h, float s, float v) {\n\tvec3 a = fract(h + vec3(0.0, 2.0, 1.0)/3.0) * 6.0 - 3.0;\n\ta = clamp(abs(a) - 1.0, 0.0, 1.0) - 1.0;\n\ta = a*s + 1.0;\n\treturn a*v;\n}\n\nfloat rand(vec2 co) {\n    return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 resolution = iResolution.xy;\n    float time = iTime;\n    float m = 0.5 * abs(sin(time));\n    vec2 uv = (fragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    uv *= 5.;\n\n    float xp = -uv.x + time;\n    float yp = uv.y + time;\n\n    vec2 pos = vec2(floor(xp), floor(yp));\n\n    uv = vec2(fract(xp) * 2.0 - 1.0, fract(yp) * 2.0 - 1.0);\n\n    float theta = atan(uv.y, uv.x) - time;\n    float threshold = (1.0 - 0.5) * sin(floor(rand(pos) * 15.) * theta) + 0.5;\n\n    vec4 col = vec4(hsv2rgb(sin(time * .5 * rand(pos)), 1.0, 1.0), 1.0);\n    \n    if(step(length(uv), threshold) == 1.0) {\n        fragColor = col;\n    } else {\n        fragColor = vec4(0.7,0.7,0.7,1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVyR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 41, 41, 172], [174, 174, 195, 195, 267], [269, 269, 326, 326, 1023]]}
{"id": "WsVyRy", "name": "Attractor Space", "author": "workingclasshacker", "description": "Using the Lorenz Attractor in a SDF, still need to figure out how to make it translucent...", "tags": ["3d", "raymarching", "attractor"], "likes": 4, "viewed": 197, "published": "Public API", "date": "1603139169", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define SURFACE_DIST 0.001\n#define MAX_DIST 100.0\n\n\nfloat t;\n\nmat2 Rot2d(float a) {\n  float s = sin(a);\n  float c = cos(a);\n  return mat2(c, - s, s, c);\n}\nfloat differenceSdf(float a, float b){\n  return max(a,-b);\n}\nfloat sdLorrenz(vec3 p, float sigma, float rho, float beta, float scale){\n  float dx = sigma * (p.y-p.x);\n  float dy = p.x * (rho - p.z) - p.y;\n  float dz = p.x * p.y - beta * p.z;\n  return length(vec3(dx*scale, dy*scale, dz*scale));\n  //return length(vec3(dx, dy, dz));\n}\nfloat GetDist(vec3 p){\n  // replace with your scene\n  float d = sdLorrenz(p, 10., 28., 8./4.,.004);\n  float d2 = sdLorrenz(vec3(p.x-.01, p.y+.01, p.z), 10., 28., 8./4., .005);\n  //float d = sdBox(p, vec3(.5,.5,.5));\n  //float d2 = sdBox(p, vec3(.2,.2,1.5));\n  //return d2;\n  return differenceSdf(d*1.4, d2*.4);\n}\n\nvec3 GetNormal(vec3 p) {\n  vec2 e = vec2(0.02, 0);\n  float d = GetDist(p);\n  vec3 n = d-vec3(GetDist(p - e.xyy), GetDist(p - e.yxy), GetDist(p - e.yyx));\n  return normalize(n);\n}\nvec3 Bg(vec3 rd){\n  float k = rd.y*.5+.5;\n  float d = sin(t)*.5+.5;\n  float s = cos(t)*.5+.5;\n  float dark = .2;\n  vec3 col = mix(vec3(d,s,0.),vec3(s,d,1.),k);\n  return col*dark;\n}\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n  vec3 f = normalize(l - p),\n  r = normalize(cross(vec3(0, 1, 0), f)),\n  u = cross(f, r),\n  c = p+f * z,\n  i = c+uv.x * r+uv.y * u,\n  d = normalize(i - p);\n  return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd) {\n  float dO = 0.0;\n  for(int i = 0; i < MAX_STEPS; i ++ ) {\n    vec3 p = ro + dO * rd;\n    float ds = GetDist(p);\n    dO += ds;\n    if (dO < SURFACE_DIST||dO > MAX_DIST) {\n      break;\n    }\n  }\n  return dO;\n}\nvec3 render(vec2 uv){\n  vec3 color = vec3(0);\n  \n  // camera\n  \n  vec3 camO = vec3(0, 0, -50.);\n  camO.yx *= Rot2d(t);\n  camO.xz *= Rot2d(t);\n  vec3 lookAt = vec3(0, 0, 0);\n  vec3 rd = GetRayDir(uv, camO, lookAt, 1.0);\n  color += Bg(rd);\n  // trace scene\n  float d = RayMarch(camO, rd);\n\n  // material\n  if (d < MAX_DIST) {\n    vec3 p = camO + rd * d;\n    vec3 n = GetNormal(p);\n    vec3 reflect = reflect(rd, n);\n    float height = p.y;\n    float dif = dot(n, normalize(vec3(1.,.5,.0)))*.5+.5;\n    float spec = pow(reflect.y*.5+.5, 10.);\n    color = n*.5+.5;\n    color *= pow(1./d,0.3);\n    color += mix(Bg(reflect),vec3(dif),.4);\n    color += vec3(spec);\n  }\n  return color;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tt = iTime/5.0;\n\tvec3 color = render(uv);\n  \tcolor = pow(color, vec3(.4545)); //correct gamma\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVyRy.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 105, 105, 176], [177, 177, 215, 215, 237], [238, 238, 311, 311, 510], [511, 511, 533, 562, 823], [825, 825, 849, 849, 1003], [1004, 1004, 1021, 1021, 1184], [1185, 1185, 1235, 1235, 1405], [1407, 1407, 1441, 1441, 1650], [1651, 1651, 1672, 1672, 2329], [2330, 2330, 2387, 2437, 2649]]}
{"id": "wsVyRz", "name": "SDF Blending Circle", "author": "ElliotPadfield", "description": "An SDF circle for testing purposes", "tags": ["sdfcircle"], "likes": 2, "viewed": 94, "published": "Public", "date": "1602165690", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\n\nfloat Circle(vec2 position, float scale)\n{\n    return length(position) - scale;\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opOnion(float shape, in float r )\n{\n  return abs(shape) - r;\n}\n\n//Awesome function that uses uses how much a value changes between one \n//pixel and the next to determine how sharp the edge should be\nfloat SDF_HardShape(float shape, float _AntialiasingValue)\n{\n\tfloat distanceChange = fwidth(shape) * _AntialiasingValue;\n\tfloat antialiasedCutoff = smoothstep(distanceChange, -distanceChange, shape);\n\tantialiasedCutoff;\n\treturn antialiasedCutoff;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    //Offset the UV so that it sits in the middle of the screen\n    uv -= 0.5;\n    //Adjust the X value of the UV based on the resolution of the screen\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    //Make the first SDF Circle\n\tfloat circle1 = Circle(uv, .4);\n    \n    //Make an offset that will be used on the second circle\n    vec2 offset = vec2(.7 * sin(iTime), 0.);\n    \n    //Make the second SDF Circle\n    float circle2 = Circle(uv + offset, .15);\n    //circle2 = opOnion(circle2, .005);\n    \n    //Blend the circles together\n    float dist = opSmoothUnion(circle1, circle2, .1);\n    \n    //Sample the SDF to generate a hard edge\n    float hardEdge = SDF_HardShape(dist, 1.);\n    \n    //Color\n\tvec4 blue = vec4(0.1, 0.8, 1, 1);\n    \n    // Output to screen\n    fragColor = vec4(blue.xyz,1.0) * hardEdge;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVyRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 79, 121, 121, 160], [162, 162, 214, 214, 313], [315, 315, 356, 356, 383], [385, 520, 580, 580, 768], [770, 770, 827, 877, 1829]]}
{"id": "wsVyzh", "name": "Main menu screen (music)", "author": "artyom", "description": "hotline", "tags": ["music", "menu"], "likes": 0, "viewed": 62, "published": "Public", "date": "1602249174", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float a = 0.0;\nfloat b = 150.;\nfloat c = 84446.0227;\n\nfloat rand(vec2 co) \n{\n  return fract(sin(dot(co.xy, vec2(a, b))) * c);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n\n    float fft  = texture( iChannel0, vec2(uv.x, 0.2) ).x;\n\n    float r = abs(sin(iTime+fft));\n    float g = abs(cos(iTime+fft));\n    float b = 1.0;\n    vec3 color = vec3(r, g, b); \n\n    vec2 pos = uv + vec2(cos(iTime), sin(iTime));\n    float x = clamp(rand(pos), 0.49, .5) * clamp(uv.y, .1, 1.);\n    fragColor = vec4(color * x, 1.);\n}", "image_inputs": [{"id": "XlBGWc", "previewfilepath": "https://soundcloud.com/devolverdigital/m-o-o-n-paris-1?in=devolverdigital/sets/hotline-miami-official", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/devolverdigital/m-o-o-n-paris-1?in=devolverdigital/sets/hotline-miami-official", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVyzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[54, 54, 76, 76, 127], [129, 129, 186, 186, 570]]}
{"id": "wsVyzw", "name": "Star Amplitude Modulation", "author": "104", "description": "parameterized simple effect", "tags": ["scifi"], "likes": 5, "viewed": 165, "published": "Public", "date": "1602517793", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float zoom = 3.;\nconst float lineWeight = 4.3;\nconst bool invertColors = true;\nconst float sharpness = 0.2;\n\nconst float StarRotationSpeed = -.5;\nconst float StarSize = 1.8;\nconst int StarPoints = 3;\nconst float StarWeight = 3.4;\n\nconst float waveSpacing = .3;\nconst float waveAmp = .4;\nconst float waveFreq = 25.;\nconst float phaseSpeed = .33;\n\n\nconst float waveAmpOffset = .01; // just a little tweaky correction\n\nmat2 rot2D(float r){\n    return mat2(cos(r), sin(r), -sin(r), cos(r));\n}\n\n// signed distance to a n-star polygon with external angle en\nfloat sdStar(in vec2 p, in float r, in int n, in float m) // m=[2,n]\n{\n    // these 4 lines can be precomputed for a given shape\n    float an = 3.141593/float(n);\n    float en = 3.141593/m;\n    vec2  acs = vec2(cos(an),sin(an));\n    vec2  ecs = vec2(cos(en),sin(en)); // ecs=vec2(0,1) and simplify, for regular polygon,\n\n    // reduce to first sector\n    float bn = mod(atan(p.x,p.y),2.0*an) - an;\n    p = length(p)*vec2(cos(bn),abs(sin(bn)));\n\n    // line sdf\n    p -= r*acs;\n    p += ecs*clamp( -dot(p,ecs), 0.0, r*acs.y/ecs.y);\n    return length(p)*sign(p.x);\n}\nfloat sdShape(vec2 uv) {\n    uv *= rot2D(-iTime*StarRotationSpeed);\n    return sdStar(uv, StarSize, StarPoints, StarWeight);\n}\n\n// https://www.shadertoy.com/view/3t23WG\n// Distance to y(x) = a + b*cos(cx+d)\nfloat udCos( in vec2 p, in float a, in float b, in float c, in float d )\n{\n    // convert all data to a primitive cosine wave\n    p = c*(p-vec2(d,a));\n    \n    // reduce to principal half cycle\n    const float TPI = 6.28318530718;\n    p.x = mod( p.x, TPI); if( p.x>(0.5*TPI) ) p.x = TPI - p.x;\n\n    // find zero of derivative (minimize distance)\n    float xa = 0.0, xb = TPI;\n    for( int i=0; i<7; i++ ) // bisection, 7 bits more or less\n    {\n        float x = 0.5*(xa+xb);\n        float si = sin(x);\n        float co = cos(x);\n        float y = x-p.x+b*c*si*(p.y-b*c*co);\n        if( y<0.0 ) xa = x; else xb = x;\n    }\n    float x = 0.5*(xa+xb);\n    for( int i=0; i<4; i++ ) // newtown-raphson, 28 bits more or less\n    {\n        float si = sin(x);\n        float co = cos(x);\n        float  f = x - p.x + b*c*(p.y*si - b*c*si*co);\n        float df = 1.0     + b*c*(p.y*co - b*c*(2.0*co*co-1.0));\n        x = x - f/df;\n    }\n    \n    // compute distance    \n    vec2 q = vec2(x,b*c*cos(x));\n    return length(p-q)/c;\n}\n\nvec3 dtoa(float d, in vec3 amount){\n    return 1. / clamp(d*amount, amount/amount, amount);\n}\n\n// 4 out, 1 in...\nvec4 hash41(float p)\n{\n\tvec4 p4 = fract(vec4(p) * vec4(.1031, .1030, .0973, .1099));\n    p4 += dot(p4, p4.wzxy+33.33);\n    return fract((p4.xxyz+p4.yzzw)*p4.zywx);\n}\nvoid mainImage( out vec4 o, vec2 C)\n{\n    vec2 R = iResolution.xy;\n    vec2 N2 = C/R;\n    vec2 N = C/R-.5;\n    vec2 uv = N;\n    uv.x *= R.x/R.y;\n    float t = iTime * phaseSpeed;\n    \n    uv *= zoom;\n\n    float a2 = 1e5;\n    vec2 uvsq = uv;\n    float a = sdShape(uvsq);\n    vec2 uv2 = uv;\n\n    uv.y = mod(uv.y, waveSpacing) - waveSpacing*.5;\n    \n    for (float i = -3.; i <= 3.; ++ i) { // necessary to handle overlapping lines. if your lines don't overlap, may not be necessary.\n    \tvec2 uvwave = vec2(uv2.x, uv.y + i * waveSpacing);\n        float b = (smoothstep(1., -1.,a)*waveAmp)+ waveAmpOffset;\n        float c = waveFreq;\n    \ta2 = min(a2, udCos(uvwave, 0., b, c, t));// a + b*cos(cx+d)\n    }\n    \n\tvec3 tint = vec3(1.,.5,.4);\n    float sh = mix(100., 1000., sharpness);\n    o.rgb = dtoa(mix(a2, a-lineWeight + 4., .03), sh*tint);\n    if (!invertColors)\n\t    o = 1.-o;\n    o *= 1.-dot(N,N*2.);\n    o = clamp(o,vec4(0),vec4(1));\n}\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsVyzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[386, 422, 442, 442, 494], [496, 558, 628, 686, 1122], [1123, 1123, 1147, 1147, 1249], [1251, 1330, 1404, 1455, 2350], [2352, 2352, 2387, 2387, 2445], [2447, 2465, 2487, 2487, 2630], [2631, 2631, 2668, 2668, 3569]]}
{"id": "wsycRG", "name": "Spherical and Geodesic line", "author": "lzjseed", "description": "Try to drag the mouse on the surface and draw the geodesic line.\n", "tags": ["3d", "raymarch", "lighting", "drawline", "sphericalcoordinatesystem", "surfaceuv"], "likes": 19, "viewed": 237, "published": "Public", "date": "1603119224", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define max_distance (100.0)\n#define sphere_info vec4(0.0,0.0,0.0,0.7)\n#define rot(d) rotY(d)*rotX(-0.46)*rotZ(-0.3)\n#define invRot(d) rotZ(0.3)*rotX(0.46)*rotY(-d)\n\n#if 1\n#define AA (1)\n#else\n#define AA (0)\n#endif\n\nmat3 rotZ(float d)\n{\n    float s = sin(d);\n    float c = cos(d);\n    \n    return mat3(c,-s,0,\n                s,c,0,\n                0,0,1);\n}\n\nmat3 rotY(float d)\n{\n    float s = sin(d);\n    float c = cos(d);\n    \n    return mat3(c,0,-s,\n                0,1,0,\n                s,0,c);\n}\n\nmat3 rotX(float d)\n{\n    float s = sin(d);\n    float c = cos(d);\n    \n    return mat3(1,0,0,\n                0,c,-s,\n                0,s,c);\n}\n\nmat3 cameraSetup(vec3 forward,vec3 up)\n{\n    vec3 right = normalize(cross(up,forward));\n    up = normalize(cross(forward,right));\n    \n    return mat3(right,up,forward);\n}\n\nfloat drawSphere(vec3 p,vec3 o,float r)\n{\n    return length(p-o) - r;\n}\n\nfloat drawCapsule(vec3 p,vec3 a,vec3 b,float r)\n{\n    vec3 ap = p - a;\n    vec3 ab = b - a;\n    \n    vec3 c = a + ab * clamp(dot(ap,ab) / dot(ab,ab),0.0,1.0);\n    return length(c - p) - r;\n}\n\nvec2 opU(vec2 a,vec2 b)\n{\n    return a.x < b.x ? a : b; \n}\n\nvec2 map(vec3 pos)\n{\n    vec4 sphere = sphere_info;\n    \n    pos = rot(iTime) * pos;\n    \n    vec2 d1 = vec2(drawSphere(pos,sphere.xyz,sphere.w),0.1);\n    \n    vec3 posA = vec3(0.0,0.9,0.0);\n    vec3 posB = vec3(0.0,-0.9,0.0);\n    \n    vec2 d2 = vec2(drawCapsule(pos,posA,posB,0.05),1.1);\n    \n    return opU(d1,d2);\n}\n\nfloat geodesic(vec3 p1,vec3 p2,vec3 wp)\n{\n    if(length(p1-p2) < 0.0001) return 0.0;\n    \n    //world to object\n    vec3 op1 = rot(iTime) * p1;\n    vec3 op2 = rot(iTime) * p2;\n    \n    vec3 op = vec3(0.0, (dot(op1,op1) - dot(op2,op2)) / (2.0 * (op1.y - op2.y)) ,0.0);\n    \n    vec3 p = invRot(iTime) * op;\n    \n    vec3 up = normalize(cross(p-p1,p-p2));\n    \n    up = length(up) < 0.5 ? invRot(iTime) * vec3(0.0,1.0,0.0) : up;\n    \n    vec3 wpd = normalize(wp - p);\n    \n    float x = abs(dot(up,wpd));\n    \n    vec3 forward = normalize((p1 + p2) * 0.5 - p);\n    \n    forward = length(forward) < 0.5 ? invRot(iTime) * vec3(0.0,0.0,-1.0) : forward;\n    \n    float y = dot(forward,wpd);\n    float y0 = dot(forward,normalize(p1 - p));\n    \n    if(x < 0.01 && y > y0) return 1.0;\n    \n    return 0.0;\n}\n\nfloat softShadow(vec3 pos,vec3 nor,vec3 dir)\n{\n    float minValue = 0.0001;\n    float maxValue = 10.0;\n    float t = 0.0;\n   \n    pos = pos + nor * 0.1;\n    \n    for(int i = 0; i < 10; ++ i)\n    {\n        vec2 hit = map(pos + dir * t);\n        if(hit.x < minValue) break;\n        \n        t += hit.x;\n        if(t > maxValue) break;\n    }\n    \n    return clamp(t / maxValue,0.0,1.0);\n}\n\nvec3 calNormal(vec3 p)\n{\n    float h = 0.000001;\n    vec2 k = vec2(1.0,-1.0);\n    \n    return normalize(k.xxx * map(p + k.xxx * h).x \n                   + k.xyy * map(p + k.xyy * h).x\n                   + k.yxy * map(p + k.yxy * h).x\n                   + k.yyx * map(p + k.yyx * h).x);\n}\n\nvec2 raymarching(vec3 pos,vec3 dir)\n{\n    float near = 0.001;\n    float minValue = 0.0001;\n    float maxValue = 100.0;\n    float t = near;\n    float material = -1.0;\n    \n    for(int i = 0; i < 100; ++ i)\n    {\n        vec2 hit = map(pos + dir * t);\n        material = hit.y;\n        if(hit.x < minValue) break;\n        \n        t += hit.x;\n        if(t > maxValue) break;\n    }\n    \n    if(t > maxValue) return vec2(-1.0,-1.0);\n    return vec2(t,material);\n}\n\nvec2 calSphereUV(vec3 pos)\n{\n    pos = rot(iTime) * pos;\n    \n    vec4 sph = sphere_info;\n    \n    vec3 dir = normalize(pos - sph.xyz);\n    vec2 dir2 = normalize(dir.xz); \n    \n    return acos(vec2(dir2.y,dir.y)) / 3.1415926;\n}\n\nfloat calCapsuleUV(vec3 pos)\n{\n    pos = rot(iTime) * pos;\n    \n    vec4 sph = sphere_info;\n    \n    vec3 dir = normalize(pos - sph.xyz);\n    vec2 dir2 = normalize(dir.xz); \n    \n    float d = acos(dir2.y) / 3.1415926;\n    \n    if(dir2.x < 0.0)\n    {\n        d = 2.0 - d;\n    }\n    \n    return d * 0.5;\n}\n\nfloat renderTouchPoint(bool isHit,vec2 hit2,vec3 hitPos,vec3 pos,vec3 dir,out vec3 touchPos)\n{\n    if(isHit)\n    {\n        float dist = hit2.x;\n        float materialId = hit2.y;\n        if(dist >= 0.0 && materialId < 1.0)\n        {\n            vec3 objPos = pos + dir * dist;\n            \n            float t = 1.0 - smoothstep(0.03,0.031,length(objPos - hitPos));\n            \n            float t2 = 1.0 - smoothstep(0.0,0.01,abs(length(objPos - hitPos) - 0.06));\n            \n            touchPos = objPos;\n            \n            return max(t,t2);\n        }\n    }\n    \n    touchPos = vec3(0.0,0.0,0.0);\n    return 0.0;\n}\n\nvec3 render(vec3 pos,vec3 dir, out vec2 hit)\n{\n    hit = raymarching(pos,dir);\n    \n    float dist = hit.x;\n    vec3 skyCol = vec3(0.1,0.5,1.8);\n    \n    if(dist < 0.0)\n    {\n        //not hit anything\n        \n        return skyCol;\n    }\n    \n    float materialId = hit.y;\n    vec3 objPos = pos + dir * dist;\n    \n    vec3 baseCol = vec3(1.0);\n    if(materialId < 1.0)\n    {\n        baseCol = vec3(1.0,1.0,1.0);\n        \n        vec2 uv = calSphereUV(objPos);\n        \n        float u = smoothstep(0.07,0.12,abs(fract(uv.x * 10.0) * 2.0 - 1.0));\n        float v = smoothstep(0.07,0.12,abs(fract(uv.y * 10.0) * 2.0 - 1.0));\n        \n        baseCol *= u;\n        baseCol *= v;\n    }\n    else if(materialId < 2.0)\n    {\n        float u = calCapsuleUV(objPos);\n        \n        if(u < 1.0 / 3.0)\n        {\n            baseCol = vec3(1.0,0.0,0.0);\n        }\n        else if(u < 2.0 / 3.0)\n        {\n            baseCol = vec3(0.0,1.0,0.0);\n        }\n        else\n        {\n            baseCol = vec3(0.0,0.0,1.0);\n        }\n    }\n    \n    \n    vec3 litCol = vec3(1.0,1.0,1.0);\n    vec3 lit = normalize(vec3(-0.5,1.0,-0.1));\n   \n    vec3 nor = calNormal(objPos);\n   \n    float shadow = softShadow(objPos,nor,lit);\n    \n    float ndl = max(0.0,dot(lit,nor));\n    \n    return baseCol * litCol * ndl * shadow + skyCol * baseCol * 0.3;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2  mouseCoord = (iMouse.xy * 2.0 - iResolution.xy) / iResolution.y;\n    vec2  mouseCoord2 = (vec2(iMouse.z,abs(iMouse.w)) * 2.0 - iResolution.xy) / iResolution.y;\n    \n    \n    float z = -10.0;\n    vec3  cameraPos = vec3(0.0,0.0,z);\n    vec3  mousePos = vec3(mouseCoord.xy,0.0);\n    vec3  mousePos2 = vec3(mouseCoord2.xy,0.0);\n    \n    vec3  finalColor = vec3(0.0);\n    float n = 0.0;\n        \n    vec3  cameraViewDir = vec3(0.0,0.0,1.0);\n    mat3  viewToWorld = cameraSetup(cameraViewDir,vec3(0.0,1.0,0.0));\n\t\n    vec3 mouseDir1 = viewToWorld * normalize(mousePos - cameraPos);\n    vec3 mouseDir2 = viewToWorld * normalize(mousePos2 - cameraPos);\n        \n        \n    vec2 mouseHit1 = raymarching(cameraPos,mouseDir1);\n    vec2 mouseHit2 = raymarching(cameraPos,mouseDir2);\n    \n    for(int y = -AA; y <= AA; ++ y)\n    {\n    \tfor(int x = -AA; x <= AA; ++ x)\n        {\n            vec2  screenCoord = ((fragCoord + vec2(x,y)*0.25) * 2.0 - iResolution.xy) / iResolution.y;\n            \n            vec3  screenPos = vec3(screenCoord.xy,0.0);\n    \n            vec3  cameraRay = normalize(screenPos - cameraPos);\n            \n            vec3  dir = viewToWorld * cameraRay;\n            \n            vec2  hit;\n            \n            vec3  sceneColor = render(cameraPos,dir,hit);\n            \n            bool  isHit = hit.x >= 0.0 ? true : false;\n            \n            vec3  tarPos = isHit ? cameraPos + dir * hit.x : vec3(0.0);\n            \n            vec3  touchPos1;\n            vec3  touchPos2;\n\n            float alpha = renderTouchPoint(isHit,mouseHit1,tarPos,cameraPos,mouseDir1,touchPos1);\n            float alpha2 = renderTouchPoint(isHit,mouseHit2,tarPos,cameraPos,mouseDir2,touchPos2);\n\n            sceneColor = mix(sceneColor,vec3(1.0,0.0,0.0),alpha);\n            sceneColor = mix(sceneColor,vec3(1.0,0.0,0.0),alpha2);\n\t\t\t\n            if(mouseHit1.x > 0.0 && mouseHit1.y < 1.0 && mouseHit2.x > 0.0 && mouseHit2.y < 1.0 && iMouse.z > 0.0)\n            {\n                float alpha3 = geodesic(touchPos1,touchPos2,tarPos);\n            \tsceneColor = mix(sceneColor,vec3(1.0,0.0,0.0),alpha3);\n            }\n            \n            //gamma correct\n            sceneColor = pow(sceneColor,vec3(0.4545));\n            \n            finalColor += sceneColor;\n            n += 1.0;\n        }\n    }\n    \n    finalColor = finalColor / n;\n    \n    // Output to screen\n    fragColor = vec4(finalColor,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycRG.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[216, 216, 236, 236, 358], [360, 360, 380, 380, 502], [504, 504, 524, 524, 646], [648, 648, 688, 688, 819], [821, 821, 862, 862, 892], [894, 894, 943, 943, 1084], [1086, 1086, 1111, 1111, 1144], [1146, 1146, 1166, 1166, 1464], [1466, 1466, 1507, 1507, 2264], [2266, 2266, 2312, 2312, 2651], [2653, 2653, 2677, 2677, 2940], [2942, 2942, 2979, 2979, 3401], [3403, 3403, 3431, 3431, 3630], [3632, 3632, 3662, 3662, 3936], [3938, 3938, 4032, 4032, 4563], [4565, 4565, 4611, 4611, 5895], [5898, 5898, 5955, 5955, 8374]]}
{"id": "WsycRh", "name": "Technical collapse", "author": "evvvvil", "description": "Technical Collapse - Result of live shader coding performance at NODE - Forum for digital arts in Frankfurt.\nLive coded on stage in 30 minutes while chatting shit. Designed in about 4 hours.\nVideo of performance: https://youtu.be/ebF2oK1yvO8?t=23274\n", "tags": ["demoscene", "particles", "glow", "transition", "wormhole", "tech", "technology", "exp", "vortex", "scifi", "techno", "bend", "industrial", "techy"], "likes": 39, "viewed": 675, "published": "Public API", "date": "1602176667", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Technical Collapse - Result of live shader coding performance at NODE - Forum for digital arts in Frankfurt.\n//Live coded on stage in 30 minutes while chatting shit. Designed in about 4 hours.\n//Video of the live performance: https://youtu.be/ebF2oK1yvO8?t=23274\n\nvec2 z,v,e=vec2(.00035,-.00035);float t,tt,b,bb,g,gg;vec3 np,bp,pp,po,no,al,ld;\nfloat bo(vec3 p,vec3 r){p=abs(p)-r;return max(max(p.x,p.y),p.z);}\nmat2 r2(float r){ return mat2(cos(r),sin(r),-sin(r),cos(r));}\nvec2 mp( vec3 p,float ga )\n{\n    float ta=smoothstep(0.,1.,(clamp(sin(p.y*.01+tt*.5),-.25,.25)*2.+.5));\n    p=mix(p,p.xzy,ta);\n    pp=p;\n    pp=vec3(atan(pp.x,pp.z)*8.,abs(abs(pp.y)-25.)-7.,length(pp.xz)-5.-bb);\n    pp.yz-=.5*exp(pp.y*.1);\n    pp.yz*=r2(.3*exp(pp.y*.1));\n    pp.xy=mod(pp.xy+vec2(0,tt*5.),2.)-1.;\n    vec2 h,t=vec2(length(pp*vec3(1,.6,1))-.75,5); //PROJECTED SPHERES\n    t.x=min(t.x,length(pp.xz+vec2(0,2))-.5*sin(p.y*.2+tt*2.)); //TENTACLES\n    h=vec2(length(pp.yz)-1.,3);    //PROJECTED BLACK LINES\n    h.x=max(h.x,abs(abs(pp.y)-.3)-.15);\n    t=t.x<h.x?t:h; t.x*=0.7;\n    bp=p+vec3(0,sin(tt)*5.,0); ////////TOWER\n    bp.xz*=r2(tt-ta*3.1);\n    h=vec2(bo(bp,vec3(2.+bb,100,2)),8);  //MAIN GREY TOWER\n    vec2 d=vec2(bo(bp,vec3(1.8+bb,100,2.2)),6);   //YELLOW BIT\n    np=bp;\n    np.xy*=r2(.785*ta);\n    for(int i=0;i<5;i++){\n        np=abs(np)-2.;\n        np.yz*=r2(.785);\n        if(mod(float(i),2.)>0.)np.xz*=r2(.785*(bb+1.));\n        h.x=max(h.x,-(bo(np,vec3(.5,200,2.5))));\n        d.x=max(d.x,-(bo(np+vec3(2.,0,0),vec3(.7,200,2.5))));\n    }\n    t=t.x<h.x?t:h;\n    t=t.x<d.x?t:d;\n    h=vec2(bo(bp,vec3(1.+bb,100,1.)),3);\n    h.x=max(h.x,abs(np.y)-1.7);\n    t=t.x<h.x?t:h;\n    h=vec2(bo(bp,vec3(1.25+bb,100,.1)),7);   //GLOWY BIT\n    pp=p;\n    pp.xz*=r2(-ta*5.+tt-sin(p.y*.1)*.5);\n    pp.xz=abs(pp.xz)-2.-bb-cos(p.y*.1)*2.;\n    pp.y=mod(pp.y+tt*5.,3.)-1.5;\n    h.x=min(h.x,.8*length(pp));\n    g+=(0.1/(0.1+h.x*h.x*(100.-99.*sin(p.y*.1+tt+bb*6.))))*ga;\n    t=t.x<h.x?t:h;\n    return t;\n}\nvec2 tr( vec3 ro,vec3 rd )\n{\n    vec2 h,t=vec2(.1);\n    for(int i=0;i<128;i++){\n        h=mp(ro+rd*t.x,1.);\n        if(h.x<.0001||t.x>50.) break;\n        t.x+=h.x;t.y=h.y;\n    }\n    if(t.x>50.) t.y=0.;\n    return t;\n}\n#define a(d) clamp(mp(po+no*d,0.).x/d,0.,1.)\n#define s(d) smoothstep(0.,1.,mp(po+ld*d,0.).x/d)\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv=(fragCoord.xy/iResolution.xy-0.5)/vec2(iResolution.y/iResolution.x,1);\n    tt=mod(iTime,40.);\n    bb=max(0.,-3.+floor(tt*.25)+smoothstep(0.,1.,min(fract(tt*.25),.25)*4.));\n    b=smoothstep(0.,1.,clamp(sin(tt*.5),-.25,.25)*2.+.5);\n    vec3 ro=mix(vec3(sin(tt*.4)*5.,3,-15.-bb),vec3(sin(tt*.4)*15.-bb,10,-4),b);\n    vec3 cw=normalize(vec3(0)-ro),cu=normalize(cross(cw,vec3(0,1,0))),\n        cv=normalize(cross(cu,cw)),rd=mat3(cu,cv,cw)*normalize(vec3(uv,.5)),co,fo;\n    co=fo=vec3(.1,.12,.17)-length(uv)*.1-rd.y*.1;\n    ld=normalize(vec3(0.0,.3,-0.2));\n    z=tr(ro,rd);t=z.x;\n    if(z.y>0.){\n        po=ro+rd*t;\n        no=normalize(e.xyy*mp(po+e.xyy,0.).x+e.yyx*mp(po+e.yyx,0.).x+e.yxy*mp(po+e.yxy,0.).x+e.xxx*mp(po+e.xxx,0.).x);\n        al=vec3(.5);\n        if(z.y<5.)al=vec3(0.);\n        if(z.y>5.)al=vec3(1.,.5,0)*(2.-ceil(abs(sin(np.z-np.y))-.05)),no+=.5*ceil(sin(np.z-np.y)),no=normalize(no);\n        if(z.y>6.)al=vec3(1);\n        if(z.y>7.)al=vec3(.5)*(2.-ceil(abs(sin(np.z-np.y))-.05));\n        float dif=max(0.,dot(no,ld)),\n            fr=pow(1.+dot(no,rd),4.),\n            sp=pow(max(dot(reflect(-ld,no),-rd),0.),40.);\n        co=mix(sp+al*(a(.05)*a(.3)+.2)*(dif+s(5.)*.5),fo,min(fr,.5));\n        co=mix(fo,co,exp(-.00005*t*t*t));\n    }\n    co=mix(co,co.zyx,b);\n    co=mix(co,co.xzy,length(uv));\n    fragColor = vec4(pow(co+g*.2,vec3(.55)),1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsycRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 346, 370, 370, 411], [412, 412, 429, 429, 473], [474, 474, 502, 502, 1979], [1980, 1980, 2008, 2008, 2197], [2293, 2293, 2350, 2350, 3716]]}
{"id": "wsycRR", "name": "Why I get the wrong(?) rotation ", "author": "GCScholar", "description": "I two groups of points whit the same coordinates are rotated, but in one of them on Firefox Windows I got a differert rotation why? Stranger thing, if I uncomment row 47 (jumping one point in the wrong plot) I get the right plot...", "tags": ["why"], "likes": 0, "viewed": 93, "published": "Public", "date": "1602085691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define drawPoint(P, r) step( length(U - P), r)\n\n// Rotate a vector of an angle around the Y-axis for right handed coordinate system\nmat4 RotateY(float angle) \n{\n    float c = cos(angle);\n    float s = sin(angle);\n    \n    return mat4(\n         c, 0., -s, 0.,\n        0., 1., 0., 0.,\n        s, 0.,  c, 0.,\n        0., 0., 0., 1.\n    );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{       \n    // Screen coordinates\n    vec2 U = (2.0*fragCoord - iResolution.xy)/iResolution.y;\n    \n\tfragColor = vec4(0.0);\n    mat4 M = RotateY(iTime);\n    \n    // Alternate the two scenario, in both I print rotating poins with coordinates from 0.0 to 1.0. \n    if(sin(iTime) > 0.0)\n    {\n        \n        // If i generate d point and print them this way it works fine ...\n        for(int i=0; i<10; i+=1) \n        {\n            float d = float(i)/10.0; // d is from 0. to 1.0\n            \n            vec3 rP = vec3(-d,0.0,d); \t  // Red point\n            vec3 gP = vec3(d,0.0,d); \t  // Green point\n\n            rP = (M*vec4(rP,1.0)).xyz;\n            gP = (M*vec4(gP,1.0)).xyz;\n\n            fragColor += vec4(drawPoint(rP.xz,0.01),0.0,0.0,1.0);\n            fragColor += vec4(0.0,drawPoint(gP.xz,0.01),0.0,1.0);\n        }\n    }\n\telse \n    {\n        // ... otherwise if i generate d point this OTHER way i get strange rotation.\n        \n        for(float d=0.0; d<1.0; d += 0.1)  // d is from 0. to 1.0\n        {\n            //if(d == 0.1) continue; // If I uncommet this row it works fine ...\n            vec3 rP = vec3(-d,0.0,d); \t  // Red point\n            vec3 gP = vec3(d,0.0,d); \t  // Green point\n\n            rP = (M*vec4(rP,1.0)).xyz;\n            gP = (M*vec4(gP,1.0)).xyz;\n\n            fragColor += vec4(drawPoint(rP.xz,0.01),0.0,0.0,1.0);\n            fragColor += vec4(0.0,drawPoint(gP.xz,0.01),0.0,1.0);\n        }\n    }\n    \n    // But I think the d values are the same\n    // WHY ?\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 133, 161, 161, 338], [340, 340, 397, 430, 1891]]}
{"id": "wsycWD", "name": "Shader Submit", "author": "eltounyomar", "description": "axaxxa", "tags": ["shader"], "likes": 10, "viewed": 264, "published": "Public API", "date": "1603440425", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define SKEW_GRID\n#define FAR 20.\n#define QUANTIZE_HEIGHTS\n#define FLAT_GRID\n#define PTH_INDPNT_GRD\n#define GRAYSCALE\n#define REVERSE_PALETTE\nfloat objID;\n\nmat2 rot2(in float a){float c=cos(a), s=sin(a); return mat2(c,-s,s,c);}\n\nfloat hash21(vec2 p){  return fract(sin(dot(p, vec2(27.609, 57.583)))*43758.5453); }\n\nfloat hash31(vec3 p){\n    return fract(sin(dot(p, vec3(12.989, 78.233, 57.263)))*43758.5453);\n}\n\nvec2 path(in float z){ \n    \n    //return vec2(0);\n    return vec2(3.*sin(z*.1) + .5*cos(z*.4), 0);\n}\n\nvec3 getTex(in vec2 p){\n    \n    // Stretching things out so that the image fills up the window.\n    //p *= vec2(iResolution.y/iResolution.x, 1);\n    vec3 tx = texture(iChannel0, p/8.).xyz;\n    //vec3 tx = textureLod(iChannel0, p, 0.).xyz;\n    return tx*tx; // Rough sRGB to linear conversion.\n}\n\n// Height map value, which is just the pixel's greyscale value.\nfloat hm(in vec2 p){ return dot(getTex(p), vec3(.299, .587, .114)); }\n\nfloat sBoxS(in vec2 p, in vec2 b, in float sf){\n\n  p = abs(p) - b + sf;\n  return length(max(p, 0.)) + min(max(p.x, p.y), 0.) - sf;\n}\n\nvec2 skewXY(vec2 p, vec2 s){\n    \n    return mat2(1, -s.y, -s.x, 1)*p;\n}\n\nvec2 unskewXY(vec2 p, vec2 s){\n\n\treturn inverse(mat2(1, -s.y, -s.x, 1))*p;\n\n}\n\nvec2 gp;\n\nfloat opExtrusion(in float sdf, in float pz, in float h, in float sf){\n\tvec2 w=vec2(sdf,abs(pz)-h-sf/2.);\n    return min(max(w.x,w.y),0.) + length(max(w + sf, 0.)) - sf;\n}\n\nvec2 gP;\n\n\nvec4 blocks(vec3 q){\n\n    \n    // Scale... Kind of redundant here, but sometimes there's a distinction\n    // between scale and dimension.\n\tconst vec2 scale = vec2(1./5.);\n\n    // Block dimension: Length to height ratio with additional scaling.\n\tconst vec2 dim = scale;\n    // A helper vector, but basically, it's the size of the repeat cell.\n\tconst vec2 s = dim*2.;\n    \n    \n    #ifdef SKEW_GRID\n    // Skewing half way along X, and Y.\n    const vec2 sk = vec2(-.5, .5);\n    #else\n    const vec2 sk = vec2(0);\n    #endif\n    \n    // Distance.\n    float d = 1e5;\n    // Cell center, local coordinates and overall cell ID.\n    vec2 p, ip;\n    \n    // Individual brick ID.\n    vec2 id = vec2(0);\n    vec2 cntr = vec2(0);\n    \n    // Four block corner postions.\n    const vec2[4] ps4 = vec2[4](vec2(-.5, .5), vec2(.5), vec2(.5, -.5), vec2(-.5)); \n    \n    // Height scale.\n    #ifdef FLAT_GRID\n    const float hs = 0.; // Zero height pylons for the flat grid.\n    #else\n    const float hs = .4;\n    #endif\n    \n    float height = 0.; // Pylon height.\n\n\n    // Local cell coordinate copy.\n    gP = vec2(0);\n    \n    for(int i = 0; i<4; i++){\n\n        // Block center.\n        cntr = ps4[i]/2. -  ps4[0]/2.;\n        \n        // Skewed local coordinates.\n        p = skewXY(q.xz, sk);\n        ip = floor(p/s - cntr) + .5; // Local tile ID.\n        p -= (ip + cntr)*s; // New local position.\n        \n        // Unskew the local coordinates.\n        p = unskewXY(p, sk);\n        \n        // Correct positional individual tile ID.\n        vec2 idi = ip + cntr;\n \n        \n        // Unskewing the rectangular cell ID.\n\t    idi = unskewXY(idi*s, sk); \n        \n \n        // The larger grid cell face.\n        //\n        vec2 idi1 = idi; // Block's central position, and ID.\n        float h1 = hm(idi1);\n        #ifdef QUANTIZE_HEIGHTS\n        h1 = floor(h1*20.999)/20.; // Discreet height units.\n        #endif\n        h1 *= hs; // Scale the height.\n        \n        // Larger face and height extrusion.\n        float face1 = sBoxS(p, 2./5.*dim - .02*scale.x, .015);\n        //float face1 = length(p) - 2./5.*dim.x;\n        float face1Ext = opExtrusion(face1, q.y + h1, h1, .006); \n    \n        \n        // The second, smaller face.\n        //\n        //vec2 offs = vec2(3./5., -1./5.)*dim;\n        vec2 offs = unskewXY(dim*.5, sk);\n        vec2 idi2 = idi + offs;  // Block's central position, and ID.\n        float h2 = hm(idi2);\n        #ifdef QUANTIZE_HEIGHTS\n        h2 = floor(h2*20.999)/20.; // Discreet height units.\n        #endif\n        h2 *= hs; // Scale the height.\n     \n        // Smaller face and height extrusion.\n        float face2 = sBoxS(p - offs, 1./5.*dim - .02*scale.x, .015);\n        //float face2 = length(p - offs) - 1./5.*dim.x;\n        float face2Ext = opExtrusion(face2, q.y + h2, h2, .006);\n         \n        // Pointed face tips, for an obelisque look, but I wasn't feeling it. :)\n        //face1Ext += face1*.25;\n        //face2Ext += face2*.25;\n        \n        vec4 di = face1Ext<face2Ext? vec4(face1Ext, idi1, h1) : vec4(face2Ext, idi2, h2);\n   \n        \n        \n        // If applicable, update the overall minimum distance value,\n        // ID, and box ID. \n        if(di.x<d){\n            d = di.x;\n            id = di.yz;\n            height = di.w;\n            \n            // Setting the local coordinates: This is hacky, but I needed a \n            // copy for the rendering portion, so put this in at the last minute.\n            gP = p;\n     \n        }\n        \n    }\n    \n    // Return the distance, position-based ID and pylong height.\n    return vec4(d, id, height);\n}\n\nfloat getTwist(float z){ return z*.08; }\n\n\n\n// Block ID -- It's a bit lazy putting it here, but it works. :)\nvec3 gID;\n\n// Speaking of lazy, here's some global glow variables. :D\n// Glow: XYZ is for color (unused), and W is for individual \n// blocks.\nvec4 gGlow = vec4(0);\n\n// The extruded image.\nfloat map(vec3 p){\n    \n    // Wrap the scene around the path. This mutates the geometry,\n    // but it's easier to implement. By the way, it's possible to\n    // snap the geometry around the path, and I've done that in\n    // other examples.\n    p.xy -= path(p.z);\n    \n    // Twist the geometry along Z. It's cheap and visually effective.\n    // Demosceners having been doing this for as long as I can remember.\n    p.xy *= rot2(getTwist(p.z));\n\n    \n    // Turning one plane into two. It's an old trick.\n    p.y = abs(p.y) - 1.25;\n  \n    // There are gaps between the pylons, so a floor needs to go in\n    // to stop light from getting though.\n    float fl = -p.y + .01;\n    \n    #ifdef PTH_INDPNT_GRD\n    // Keep the blocks independent of the camera movement, but still \n    // twisting with warped space.\n    p.xy += path(p.z);\n    #endif\n    \n    // The extruded blocks.\n    vec4 d4 = blocks(p);\n    gID = d4.yzw; // Individual block ID.\n    \n    // Only alowing certain blocks to glow. We're including some \n    // animation in there as well.\n    float rnd = hash21(gID.xy);\n    //\n    // Standard blinking lights animation.\n    gGlow.w = smoothstep(.992, .997, sin(rnd*6.2831 + iTime/4.)*.5 + .5);\n    //gGlow.w = rnd>.05? 0. : 1.; // Static version.\n \n \n    // Overall object ID.\n    objID = fl<d4.x? 1. : 0.;\n    \n    // Combining the floor with the extruded blocks.\n    return min(fl, d4.x);\n \n}\nfloat trace(in vec3 ro, in vec3 rd){\n\n    // Overall ray distance and scene distance.\n    float t = 0., d;\n     \n    // Zero out the glow.\n    gGlow = vec4(0);\n    t = hash31(ro.zxy + rd.yzx)*.25;\n    \n    for(int i = 0; i<128; i++){\n    \n        d = map(ro + rd*t); // Distance function.\n        \n        // Adding in the glow. There'd be better and worse ways to do it.\n        float ad = abs(d + (hash31(ro + rd) - .5)*.05);\n        const float dst = .25;\n        if(ad<dst){\n            gGlow.xyz += gGlow.w*(dst - ad)*(dst - ad)/(1. + t);\n        }\n        if(abs(d)<.001*(1. + t*.05) || t>FAR) break; \n        \n        t += i<32? d*.4 : d*.7; \n    }\n\n    return min(t, FAR);\n}\n\nvec3 getNormal(in vec3 p){\n\t\n    const vec2 e = vec2(.001, 0);\n    \n    //vec3 n = normalize(vec3(map(p + e.xyy) - map(p - e.xyy),\n    //map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n    \n    // This mess is an attempt to speed up compiler time by contriving a break... It's \n    // based on a suggestion by IQ. I think it works, but I really couldn't say for sure.\n    float sgn = 1.;\n    float mp[6];\n    vec3[3] e6 = vec3[3](e.xyy, e.yxy, e.yyx);\n    for(int i = 0; i<6; i++){\n\t\tmp[i] = map(p + sgn*e6[i/2]);\n        sgn = -sgn;\n        if(sgn>2.) break; // Fake conditional break;\n    }\n    \n    return normalize(vec3(mp[0] - mp[1], mp[2] - mp[3], mp[4] - mp[5]));\n}\n\n\n\n// Cheap shadows are hard. In fact, I'd almost say, shadowing particular scenes with limited \n// iterations is impossible... However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, vec3 n, float k){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int iter = 24; \n    \n    ro += n*.0015;\n    vec3 rd = lp - ro; // Unnormalized direction ray.\n    \n\n    float shade = 1.;\n    float t = 0.;//.0015; // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0001);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i = 0; i<iter; i++){\n\n        float d = map(ro + rd*t);\n        shade = min(shade, k*d/t);\n        //shade = min(shade, smoothstep(0., 1., k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        t += clamp(d, .01, .25); \n        \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (d<0. || t>end) break; \n    }\n\n    // Sometimes, I'll add a constant to the final shade value, which lightens the shadow a bit --\n    // It's a preference thing. Really dark shadows look too brutal to me. Sometimes, I'll add \n    // AO also just for kicks. :)\n    return max(shade, 0.); \n}\n\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 p, in vec3 n)\n{\n\tfloat sca = 3., occ = 0.;\n    for( int i = 0; i<5; i++ ){\n    \n        float hr = float(i + 1)*.15/5.;        \n        float d = map(p + n*hr);\n        occ += (hr - d)*sca;\n        sca *= .7;\n    }\n    \n    return clamp(1. - occ, 0., 1.);  \n}\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    \n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.25)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*2.0); // Camera position, doubling as the ray origin.\n    ro.xy += path(ro.z); \n    vec2 roTwist = vec2(0, 0);\n    roTwist *= rot2(-getTwist(ro.z));\n    ro.xy += roTwist;\n    \n\tvec3 lk = vec3(0, 0, ro.z + .45); // \"Look At\" position.\n    lk.xy += path(lk.z); \n    vec2 lkTwist = vec2(0, -.1); // Only twist horizontal and vertcal.\n    lkTwist *= rot2(-getTwist(lk.z));\n    lk.xy += lkTwist;\n    \n\tvec3 lp = vec3(0, 0, ro.z + 5.); // Light.\n    lp.xy += path(lp.z);\n    vec2 lpTwist = vec2(0, -.3); // Only twist horizontal and vertcal.\n    lpTwist *= rot2(-getTwist(lp.z));\n    lp.xy += lpTwist;\n    \n\n    \n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 1.; // FOV - Field of view.\n    float a = getTwist(ro.z);\n    // Swiveling the camera about the XY-plane.\n    a += (path(ro.z).x - path(lk.z).x)/(ro.z - lk.z)/4.;\n\tvec3 fw = normalize(lk - ro);\n\t//vec3 up = normalize(vec3(-fw.x, 0, -fw.z));\n\tvec3 up = vec3(sin(a), cos(a), 0);\n\t//vec3 up = vec3(0, 1, 0);\n    vec3 cu = normalize(cross(up, fw));\n\tvec3 cv = cross(fw, cu);   \n    \n    // Unit direction ray.\n    vec3 rd = normalize(uv.x*cu + uv.y*cv + fw/FOV);\t\n\t \n    \n    // Raymarch to the scene.\n    float t = trace(ro, rd);\n    \n    // Save the block ID, object ID and local coordinates.\n    vec3 svGID = gID;\n    float svObjID = objID;\n    vec2 svP = gP; \n    \n    vec3 svGlow = gGlow.xyz;\n   \n\t\n    // Initiate the scene color to black.\n\tvec3 col = vec3(0);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t < FAR){\n        \n  \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = ro + rd*t;\n\t    //vec3 sn = getNormal(sp, edge, crv, ef, t);\n        vec3 sn = getNormal(sp);\n        \n          \n        // Texel color. \n\t    vec3 texCol;   \n        \n        // Transforming the texture coordinates according to the camera path\n        // and Z warping.\n        vec3 txP = sp;\n        txP.xy -= path(txP.z);\n        txP.xy *= rot2(getTwist(txP.z));\n        #ifdef PTH_INDPNT_GRD\n        txP.xy += path(txP.z);\n        #endif\n\n        // The extruded grid.\n        if(svObjID<.8){\n            \n            // Coloring the individual blocks with the saved ID.\n            vec3 tx = getTex(svGID.xy);\n            \n            // Ramping the shade up a bit.\n            texCol = smoothstep(-.3, 1., tx)*vec3(1, .4, 2.6);\n            \n            \n            // Very fake, but very cheap, bump mapping. Render some equispaced horizontal\n            // dark lines, and some light adjacent ones. As you can see, it gives the\n            // impression of horizontally segmented grooves on the pylons.\n            const float lvls = 9.;\n            \n            // Vertical lines... A bit too much for this example, but useful for a fake\n            // voxel setup.\n            //float vLn = min(abs(txP.x - svGID.x), abs(txP.z - svGID.y));\n            \n            // Horizontal lines (planes, technically) around the pylons.\n            float yDist = (1.25 + abs(txP.y) + svGID.z*2.);\n            float hLn = abs(mod(yDist  + .8/lvls, 1./lvls) - .5/lvls);\n            float hLn2 = abs(mod(yDist + .75/lvls - .018, 1./lvls) - .7/lvls);\n            \n            // Omitting the top and bottom planes... I was in a hurry, and it seems to\n            // work, but there'd be better ways to do this. \n            if(yDist - 2.5<.45/lvls) hLn = 1e5;\n            if(yDist - 2.5<.45/lvls) hLn2 = 1e5;\n            \n            // Rendering the dark and light lines using 2D layering techniques.\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .006, hLn2 - .0055));\n       \t\ttexCol = mix(texCol, texCol/2.5, 1. - smoothstep(0., .006, hLn - .0055));\n       \t\t \n            \n            // Render a dot on the face center of each extruded block for whatever reason...\n            // They were there as markers to begin with, so I got used to them. :)\n            float fDot = length(txP.xz - svGID.xy) - .0096;\n            texCol = mix(texCol, texCol*2., 1. - smoothstep(0., .002, fDot - .0065));\n            texCol = mix(texCol, vec3(0), 1. - smoothstep(0., .002, fDot));\n  \n\n \n        }\n        else {\n            \n            // The dark floor in the background. Hidden behind the pylons, but\n            // there are very slight gaps, so it's still necessary.\n            texCol = vec3(0);\n        }\n       \n    \t\n    \t// Light direction vector.\n\t    vec3 ld = lp - sp;\n\n        // Distance from respective light to the surface point.\n\t    float lDist = max(length(ld), .003);\n    \t\n    \t// Normalize the light direction vector.\n\t    ld /= lDist;\n        \n        \n        // Shadows and ambient self shadowing.\n    \tfloat sh = softShadow(sp, lp, sn, 16.);\n    \tfloat ao = calcAO(sp, sn); // Ambient occlusion.\n        sh = min(sh + ao*.45, 1.);\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 3./(1. + lDist*lDist*.5);\n\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.);\n        diff *= diff*1.55; // Ramping up the diffuse.\n    \t\n    \t// Specular lighting.\n\t    float spec = pow(max(dot(reflect(ld, sn), rd ), 0.), 32.); \n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow(clamp(1. - abs(dot(sn, rd))*.5, 0., 1.), 4.);\n        col = texCol*(diff + ao*.25 + vec3(1, .4, .2)*fre*.25 + vec3(1, .4, .2)*spec*4.);\n        \n        col *= ao*sh*atten;\n\t\n\t}\n\n    svGlow.xyz *= mix(vec3(4, 1, 2), vec3(4, 2, 1), min(svGlow.xyz*3.5, 1.25));\n    col *= .25 + svGlow.xyz*8.;\n   \n    vec3 fog =  mix(vec3(4, 1, 2), vec3(4, 2, 1), rd.y*.5 + .5);\n    fog = mix(fog, fog.zyx, smoothstep(0., .55, uv.y - .35));\n    col = mix(col, fog/1.5, smoothstep(0., .99, t*t/FAR/FAR));\n    \n    \n    #ifdef GRAYSCALE\n    // Grayscale... or almost grayscale. :)\n    col = mix(col, vec3(1)*dot(col, vec3(.320, .650, .174)), .75);\n    #endif \n \n    \n    #ifdef REVERSE_PALETTE\n    col = col.zyx; // A more calming blue, for those who don't like fiery things.\n    #endif\n\n    \n\tfragColor = vec4(sqrt(max(col, 0.)), 1);\n\t\n}", "image_inputs": [{"id": "Xdf3zn", "previewfilepath": "/media/ap/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/85a6d68622b36995ccb98a89bbb119edf167c914660e4450d313de049320005c.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 178, 178, 227], [229, 229, 250, 250, 313], [315, 315, 336, 336, 410], [412, 412, 434, 462, 513], [515, 515, 538, 660, 810], [812, 876, 896, 896, 945], [947, 947, 994, 994, 1079], [1081, 1081, 1109, 1109, 1153], [1155, 1155, 1185, 1185, 1232], [1244, 1244, 1314, 1314, 1415], [1428, 1428, 1448, 1566, 5036], [5038, 5038, 5062, 5062, 5078], [5312, 5335, 5353, 5577, 6741], [6742, 6742, 6778, 6827, 7424], [7426, 7426, 7452, 7452, 8118], [8122, 8313, 8365, 8482, 9763], [9766, 9918, 9954, 9954, 10198], [10203, 10203, 10259, 10292, 16424]]}
{"id": "wsycz1", "name": "MM - Raymarching mickey", "author": "MatMercer", "description": "Plis Disney don't sue me :(\nI wanted to rotate the mickey in xz axis but I was unable to do it. If you uncomment the 27 line and comment the 26 I try to transform the p.xz (axis I want to rotate) with a rotation transformation matrix, but doesn't works.", "tags": ["raymarching"], "likes": 2, "viewed": 171, "published": "Public API", "date": "1602218467", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 1024\n#define MIN_DIST 0.01\n#define MAX_DIST 100.0\n\n#define SHADOW_OUT_DIST 0.02\n\nmat2 rotateMat(float deg) {\n    float s = sin(deg);\n    float c = cos(deg);\n   \n    return mat2(c, -s, s, c);\n}\n\n// raymarch distance formulas for primitives\nfloat sphere(vec4 s, vec3 view) {\n    return length(view - s.xyz) - s.w;\n}\n\nfloat plane(float y, vec3 view) {\n    return view.y - y;\n}\n\nfloat getDist(vec3 p) {\n    float plane = plane(0.0, p);\n    \n    p.xy *= rotateMat(sin(iTime) * .5);\n    //p.xz *= rotateMat(sin(iTime) * .5); \n    \n    float head = sphere(vec4(0, 1, 6, 1), p);\n    float ear1 = sphere(vec4(-1.0, 2, 6, 0.8), p);\n    float ear2 = sphere(vec4(1.0, 2, 6, 0.8), p);\n    float eye1 = sphere(vec4(-0.3, 1.3, 5.05, 0.1), p);\n    float eye2 = sphere(vec4(0.3, 1.3, 5.05, 0.1), p);\n    float nose = sphere(vec4(0, 1, 5, 0.1), p);\n\n    \n    return min(head,\n               min(ear1, \n                   min(ear2, \n                       min(eye1, \n                           min(eye2,\n                               min(nose, \n                                   plane))))));\n}\n\n// raymarch main loop\nfloat rayMarch(vec3 orig, vec3 dir) {\n   \tvec3 curPoint;\n    \n    float dist = 0.0;\n    \n    for(int i = 0; i < MAX_STEPS; i++) {\n        curPoint = orig + dir * dist;\n        \n        float minDist = getDist(curPoint);\n                \n        dist += minDist;\n        \n        if (minDist < MIN_DIST || minDist > MAX_DIST) break;\n    }\n    \n    return dist;\n}\n\n// normal calculation function\nvec3 getNormal(vec3 p) {\n    float d = getDist(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        getDist(p - e.xyy),\n        getDist(p - e.yxy),\n        getDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\nfloat light(vec3 p, vec3 view) {\n    //lightPos.xz += vec2(sin(iTime), cos(iTime))*2.;\n    vec3 l = normalize(p - view);\n    vec3 n = getNormal(view);\n    \n    float dif = clamp(dot(n, l), 0., 1.);\n    \n    float d = rayMarch(view + n * SHADOW_OUT_DIST, l);\n    if (d < length(p - view)) dif *= .5;\n    \n    return dif;\n}\n\n// shader light function\nfloat getLight(vec3 p) {\n    return (light(vec3(-6, 6, 4), p) * 0.5) + (light(vec3(3, 4, 3), p) * 0.5);\n}\n\n// main img\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // center coords\n    vec2 uv = (fragCoord - .5 * iResolution.xy)/iResolution.y;\n\n    vec3 camera = vec3(0, 1.3, 1);\n    vec3 dir = normalize(vec3(uv.x, uv.y, 1));\n    float d = rayMarch(camera, dir);\n    //d /= 10.;\n\n    vec3 p = camera + dir * d;\n    \n    float dif = getLight(p);\n\tvec3 col = vec3(dif);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsycz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[99, 99, 126, 126, 210], [212, 257, 290, 290, 331], [333, 333, 366, 366, 391], [393, 393, 416, 416, 1094], [1096, 1118, 1155, 1155, 1479], [1481, 1512, 1536, 1536, 1734], [1736, 1736, 1768, 1822, 2057], [2059, 2084, 2108, 2108, 2189], [2191, 2203, 2260, 2281, 2631]]}
{"id": "wsyczh", "name": "Purple Fog", "author": "Ezra_Szanton", "description": "Playing with perlin noise to try and get a blob effect, but I got more of a fog :)", "tags": ["noise", "perlin", "fog"], "likes": 0, "viewed": 74, "published": "Public", "date": "1602195497", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//hash function taken from https://www.shadertoy.com/view/4djSRW\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\nfloat smoothNoise(vec2 uv)\n{\n    vec2 lv = fract(uv);\n    vec2 id = floor(uv);\n    \n    lv = lv * lv * (3. - 2.*lv);\n    \n    float bl = hash12(id);\n    float br = hash12(id + vec2(1., 0.));\n    \n    float b = mix(bl, br, lv.x);\n    \n    \n    float tl = hash12(id + vec2(0., 1.));\n    float tr = hash12(id + vec2(1., 1.));\n    \n    float t = mix(tl, tr, lv.x);\n    \n    float c = mix(b,t, lv.y);\n    return c;\n}\n\nfloat perlin(vec2 uv)\n{\n    \n    float c = smoothNoise(uv * 4.* sin(iTime * 0.01 + .113));\n    c += smoothNoise(uv * 8. * sin(iTime * 0.12)) * 0.5;\n    c += smoothNoise(uv * 16. * sin(iTime * 0.1 + 1.213)) * 0.25;\n    c += smoothNoise(uv * 32.* sin(iTime * 0.042 + .213)) * 0.125;\n    c += smoothNoise(uv * 64. * sin(iTime * 0.0037 + .113)) * 0.0625;\n    c /= 2.;\n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv *= 2.;\n    uv += vec2(10., -9.);\n    \n    float c = perlin(uv * 0.1);\n    \n    vec3 color1 = vec3(0.4, 0.8, 0.5);\n    vec3 color2 = vec3(0.2, 0.1, 0.2);\n    vec3 color3 = vec3(0.5, 0.5, 0.95);\n    \n    // Time varying pixel color\n    vec3 col = vec3(mix( mix(color1, color2, c * 1.2) * 0.5, color3, fract(c * 12.321) ));\n\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyczh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 66, 88, 88, 205], [206, 206, 234, 234, 617], [619, 619, 642, 642, 998], [1000, 1000, 1057, 1107, 1539]]}
{"id": "wsyyRD", "name": "Rolling Sushi Boze", "author": "kaiware007", "description": "Conveyor belt sushi is a common Japanese food culture.", "tags": ["raymarching", "spline", "catmulrom"], "likes": 6, "viewed": 143, "published": "Public", "date": "1602328163", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ------------------------------------------------------------------------------------\n// Original \"thinking...\" created by kaneta : https://www.shadertoy.com/view/wslSRr\n// Original Character By MikkaBouzu : https://twitter.com/mikkabouzu777\n// ------------------------------------------------------------------------------------\n\n// Rendering Option\n#define ENABLE_REFLECTION\n//#define ENABLE_GRID_BOUNDARY\n#define SMOOTH_HSV\n#define USE_BRDF_1\n//#define USE_RAYCAST\n#define ENABLE_FOG\n//#if HW_PERFORMANCE==0\n#define AA 1\n//#else\n//#define AA 2\n//#endif\n\n\n#define COURCE_CAMERA\n\n#define saturate(x) clamp(x, 0.0, 1.0)\n#define MAX_MARCH 200\n#define MAX_RAYCAST 100\n#define MAX_RAYCAST_L 6\n#define MAX_DIST 100.\n\n#define M_PI 3.1415926\n#define M_PI2 M_PI*2.0\n\n#define RAD90 (M_PI * 0.5)\n#define RAD45 (M_PI * 0.25)\n\n#define M_PI03 1.04719\n#define M_PI06 2.09439\n\nconst float EPS = 1e-3;\nconst float EPS_N = 1e-4;\nconst float OFFSET = EPS * 10.0;\n\nconst float CAMERA_SPEED = 0.1;\n\n//const vec3 sunDir = normalize(vec3(-1,1,-0.25));\nconst vec3 lightPos = vec3(0.50, 0.8, -0.5);\nconst vec3 lightColor = vec3(0.98, 0.92, 0.89) * 4.0;\n//const vec3 lightColor = vec3(0.3, 0.6, 0.9) * 2.0;\n\nstruct surface {\n\tfloat dist;\n    vec4 albedo;\n    vec3 emission;\n    float roughness;\n    float metalness;\n    int count;\n    bool isTransparent;\n    float refractPower;\n    bool isHit;\n};\n\nvec3 sinebow(float h) {\n    vec3 r = sin((.5-h)*M_PI + vec3(0,M_PI03,M_PI06));\n    return r*r;\n}\n\n#define COLOR_SEA (vec3(0,0.05,0.1))\n    \n// Surface Data Define\n#define SURF_NOHIT(d)   (surface(d, vec4(0), \t\t \tvec3(0), 0.0, 0.0, 0, false, 0.0, false))\n#define SURF_BLACK(d) \t(surface(d, vec4(0,0,0,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_FACE(d) \t(surface(d, vec4(1,0.7,0.6,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_MOUSE(d) \t(surface(d, vec4(1,0,0.1,1),   \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n#define SURF_CHEEP(d) \t(surface(d, vec4(1,0.3,0.4,1), \tvec3(0), 0.3, 0.0, 0, false, 0.0, true))\n/*\nsurface SURF_PLANETEX(float d, vec3 pos)\n{\n    vec4 col = vec4(texture(iChannel0, vec2(pos.xz)).rgb, 1.);\n        \n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n*/\n#define SURF_CS(d) \t\t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.1, 0.8, 0, false, 0., true))\n\n#define SURF_SPHERE(d) \t(surface(d, vec4(0,0,0,1), \t\t vec3(0), 0.1, 0.8, 0, false, 2.2, true))\n#define SURF_CUBE(d) \t(surface(d, vec4(0,1,0,1), \t\t vec3(0), 0.5, 0.0, 0, false, 2.2, true))\n#define SURF_SPHERE2(d) (surface(d, vec4(0,0,1,1), \t\t vec3(0), 0.1, 0.2, 0, false, 2.2, true))\n#define SURF_LEG(d) \t(surface(d, vec4(0.5,0.2,0.1,1), vec3(0), 0.3, 0.0, 0, false, 0.0, true))\n\n#define SURF_MIRROR(d) \t(surface(d, vec4(0.5,0.5,0.5,1), \t\t vec3(0), 0.3, 0.8, 0, false, 2.2, true))\n#define SURF_SEA(d) \t(surface(d, vec4(COLOR_SEA,0), vec3(0), 0.2, 0.5, 0, true, 1.53, true))\n/*\nsurface SURF_WATERMELON(float d, vec3 pos, vec3 center)\n{\n    pos = center - pos;\n    vec2 uv = vec2(atan(pos.z,pos.x), pos.y);\n    uv.x = abs(uv.x)-M_PI/5.;\n    vec2 guv = fract(uv*1.5)-0.5;\n    vec2 id = floor(uv*1.5)-0.5;\n    float mask = step(abs(guv.x),0.25+sin((uv.y+id.x)*200.)*0.05);\n    \n    vec4 col = vec4(mix (vec3(0.05,0.3,0.025),vec3(0.025, 0.05, 0.025), mask), 1);\n    return surface(d, col, vec3(0), 0.2, 0.001, 0, false, 2.2, true);\n}\n*/\n\n//#define SURF_LOAD(d) \t(surface(d, vec4(0.2,0.2,0.2,1), \tvec3(0), 0.0001, 0.01, 0, false, 0.0, true))\nsurface SURF_LOAD(float d, vec3 p, vec3 cp)\n{\n\tfloat len = length(cp - p);\n        \n    vec3 col = mix(vec3(0), vec3(0,0.4,1), smoothstep(0.4, 0.41, len));\n    \n    return surface(d, vec4(0.2,0.2,0.2,1), \tcol, 0.01, 0.5, 0, false, 0.5, true);\n}\n\n//#define SURF_DESERT(d) \t(surface(d, vec4(0.8,0.5,0.4,1), \tvec3(0), 0.0001, 0.01, 0, false, 0.0, true))\n\n#define SURF_SHARI(d) \t(surface(d, vec4(0.9,0.9,0.9,1), vec3(0), 0.3, 0.1, 0, false, 1.1, true))\n#define SURF_NETA(d, col) \t(surface(d, vec4(col,1), vec3(0), 0.01, 0.2, 0, false, 1.1, true))\n\n//==================================================================\n// Catmull-Rom Spline\n// https://www.shadertoy.com/view/ls3SRr\n//==================================================================\nconst int POINT_COUNT = 8;\nstruct CtrlPts\n{\n    vec3 p[POINT_COUNT];\n};\n\nvec3 PointArray(int i, CtrlPts ctrlPts)\n{\n    i = int(mod(float(i), float(POINT_COUNT)));\n    return ctrlPts.p[i];\n    /*\n    if(i==0 || i==POINT_COUNT  ) return ctrlPts.p[0];\n    if(i==1 || i==POINT_COUNT+1) return ctrlPts.p[1];\n    if(i==2 || i==POINT_COUNT+2) return ctrlPts.p[2];\n    if(i==3) return ctrlPts.p[3];\n    if(i==4) return ctrlPts.p[4];\n    if(i==5) return ctrlPts.p[5];\n    if(i==6) return ctrlPts.p[6];\n    if(i==7) return ctrlPts.p[7];\n    return vec3(0);\n*/\n}\n\nvec3 catmullRom(float fTime, CtrlPts ctrlPts)\n{\n    float t = fTime;\n    const float n = float(POINT_COUNT);\n    \n    int idxOffset = int(t*n);\n    vec3 p1 = PointArray(idxOffset,ctrlPts);\n    vec3 p2 = PointArray(idxOffset+1,ctrlPts);\n    vec3 p3 = PointArray(idxOffset+2,ctrlPts);\n    vec3 p4 = PointArray(idxOffset+3,ctrlPts);\n    \n    //For some reason, fract(t*n) returns garbage on my machine with small values of t.\n    //return fract(n*t);\n    //Using this below yields the same results, minus the glitches.\n    t *= n;\n    t = (t-float(int(t)));\n    \n    //A classic catmull-rom\n    //e.g.\n    //http://steve.hollasch.net/cgindex/curves/catmull-rom.html\n    //http://www.lighthouse3d.com/tutorials/maths/catmull-rom-spline/\n    vec3 val = 0.5 * ((-p1 + 3.*p2 -3.*p3 + p4)*t*t*t\n               + (2.*p1 -5.*p2 + 4.*p3 - p4)*t*t\n               + (-p1+p3)*t\n               + 2.*p2);\n    return val;\n}\n\nfloat distanceToLineSeg(vec3 p, vec3 a, vec3 b, out vec3 e, out vec3 forward)\n{\n    //e = capped [0,1] orthogonal projection of ap on ab\n    //       p\n    //      /\n    //     /\n    //    a--e-------b\n    vec3 ap = p-a;\n    vec3 ab = b-a;\n    e = a+clamp(dot(ap,ab)/dot(ab,ab),0.0,1.0)*ab;\n    forward = normalize(a-b);\n    return length(p-e);\n}\n\nfloat sdCatmullRomSpline(vec3 p, CtrlPts ctrlPts, out vec3 cp)\n{\n\tconst float maxDist = 10000.0;\n    float bestX = 0.0;\n    \n    //Primary (rough) estimate : decent results with 2 lines per control point (faint blue lines)\n    const int iter = POINT_COUNT*2+1;\n    //const int iter = POINT_COUNT*1+1; //<-Faster\n    //const int iter = POINT_COUNT*3+1; //<-Nicer\n    float primarySegLength = 1.0/float(iter-1);\n    vec3 pA = catmullRom(0., ctrlPts);\n    float minRoughDist = maxDist;\n    float x = 0.0;\n    vec3 e, fwd;\n    for(int i=0; i < iter; ++i)\n    {\n        vec3 pB = catmullRom(x, ctrlPts);\n        \n        float d = distanceToLineSeg(p, pA, pB, e, fwd);\n        pA = pB;\n        if(d<minRoughDist)\n        {\n            bestX = x;\n            minRoughDist = d;\n        }\n         \n        x += primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    //Secondary (smooth) estimate : refine (red curve)\n    const int iter2 = 8;\n    x = max(bestX-1.25*primarySegLength,0.0); //Starting 25% back on previous seg (50% overlap total)\n    float minDist = maxDist;\n    pA = catmullRom(x, ctrlPts);\n    for(int i=0; i < iter2; ++i)\n    {\n        vec3 pB = catmullRom(x, ctrlPts);\n        float d = distanceToLineSeg(p, pA, pB, e, fwd);\n        pA = pB;\n        \n        if(d<minDist)\n        {\n            bestX = x;\n            minDist = d;\n            cp = e;\n        }\n         \n        //Covering 1.5x primarySegLength (50% overlap with prev, next seg)\n        x += 1.5/float(iter2-1)*primarySegLength;\n        x = min(x,0.99999); //<1 To prevent artifacts at the end.\n    }\n    \n    return minDist;\n}\n\n//==================================================================\n\n//-----------------HSV-----------------\n\n//HSV functions from iq (https://www.shadertoy.com/view/MsS3Wc)\n#ifdef SMOOTH_HSV\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\trgb = rgb*rgb*(3.0-2.0*rgb); // cubic smoothing\t\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#else\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n#endif\n\n//From Sam Hocevar: http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\nvec3 rgb2hsv(vec3 c)\n{\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n    vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n\n// Hash without Sine by Dave_Hoskins\n// https://www.shadertoy.com/view/4djSRW\n//----------------------------------------------------------------------------------------\n//  1 out, 1 in...\nfloat hash11(float p)\n{\n    p = fract(p * .1031);\n    p *= p + 33.33;\n    p *= p + p;\n    return fract(p);\n}\n\n//  1 out, 2 in...\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n//  1 out, 3 in...\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n///  2 out, 2 in...\nvec2 hash22(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n\n}\n\n//  3 out, 1 in...\nvec3 hash31(float p)\n{\n   vec3 p3 = fract(vec3(p) * vec3(.1031, .1030, .0973));\n   p3 += dot(p3, p3.yzx+33.33);\n   return fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\n///  3 out, 3 in...\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * vec3(.1031, .1030, .0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy + p3.yxx)*p3.zyx);\n\n}\n\nsurface SURF_BG1(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    vec4 col = vec4(vec3(0.25) + vec3(0.75) * mod(mod(index.x + index.y, 2.0) + index.z + index.y, 2.0), 1);\n    return surface(d, col, vec3(0), 0.5, 0.3, 0, false, 0., true);\n}\n\nsurface SURF_BG_COLORFULL(float d, vec3 pos)\n{\n    //vec3 index = floor((pos +vec3(0,0,iTime*3.0) )* 2. + 0.5);\n    vec3 index = floor(pos * 2. + 0.5);\n    float flg = mod(mod(index.x + index.y, 2.0) + index.z, 2.0);\n    //vec4 col = vec4(vec3(0.25) + vec3(0.5,0,0.5) * flg, 1);\n    //vec4 col = vec4(vec3(0.25) + sinebow((hash13(index) + iTime*0.5) * M_PI) * flg, 1);\n    return surface(d, vec4(vec3(0.25)*(1.-flg), 1), sinebow(hash13(index*3165.5) * M_PI + iTime*0.5) * flg, 0.5, 0.1 + 0.7 * (1.-flg), 0, false, 0., true);\n\t//return SURF_MIRROR(d);\n}\n\nfloat rand(vec2 st)\n{\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 10000.0);\n}\n\nfloat rand3d(vec3 st)\n{\n    return fract(sin(dot(st.xyz, vec3(12.9898, 78.233, 56.787))) * 10000.0);\n}\n\n\nfloat noise(vec3 st)\n{\n\tvec3 ip = floor(st);\n    vec3 fp = smoothstep(vec3(0.), vec3(1.), fract(st));\n    \n\tvec4 a = vec4(rand3d(ip+vec3(0.)),rand3d(ip+vec3(1.,0.,0.)),rand3d(ip+vec3(0.,1.,0.)),rand3d(ip+vec3(1.,1.,0.)));\n    vec4 b = vec4(rand3d(ip+vec3(0.,0.,1.)),rand3d(ip+vec3(1.,0.,1.)),rand3d(ip+vec3(0.,1.,1.)),rand3d(ip+vec3(1.,1.,1.)));\n    \n\ta = mix(a, b, fp.z);\n\ta.xy = mix(a.xy, a.zw, fp.y);\n    \n\treturn mix(a.x, a.y, fp.x);\n}\n\n\nmat3 m = mat3( 0.00,  0.80,  0.60,\n              -0.80,  0.36, -0.48,\n              -0.60, -0.48,  0.64 );\n\nfloat fbm( vec3 p )\n{\n    float f;\n    f  = 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p );\n    return f;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\nvec2 hash( in vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash12( i + vec2(0.0,0.0) ), \n                     hash12( i + vec2(1.0,0.0) ), u.x),\n                mix( hash12( i + vec2(0.0,1.0) ), \n                     hash12( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n#if 1\n    // quintic interpolation\n    vec2 u = f*f*f*(f*(f*6.0-15.0)+10.0);\n    vec2 du = 30.0*f*f*(f*(f-2.0)+1.0);\n#else\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n#endif    \n    \n    vec2 ga = hash( i + vec2(0.0,0.0) );\n    vec2 gb = hash( i + vec2(1.0,0.0) );\n    vec2 gc = hash( i + vec2(0.0,1.0) );\n    vec2 gd = hash( i + vec2(1.0,1.0) );\n    \n    float va = dot( ga, f - vec2(0.0,0.0) );\n    float vb = dot( gb, f - vec2(1.0,0.0) );\n    float vc = dot( gc, f - vec2(0.0,1.0) );\n    float vd = dot( gd, f - vec2(1.0,1.0) );\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                 ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                 du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\n// original sea octave function by TDM\n// https://www.shadertoy.com/view/Ms2SD1\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nvec3 spline(vec3 p0, vec3 p1, vec3 p2, vec3 p3, float t){\n\n    return ((-p0 + p1*3. - p2*3. + p3)*t*t*t +\n            (p0*2. - p1*5. + p2*4. - p3)*t*t +\n            (-p0 + p2)*t + p1*2.)*.5;\n}\n\n// Distance functions by iq\n// https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdSphere(in vec3 p, float s) {\n    return length(p) - s;\n}\n\nfloat sdRoundBox(vec3 p, vec3 size, float r)\n{\n    return length(max(abs(p) - size * 0.5, 0.0)) - r;\n}\n\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - r;\n}\n\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba*h) - mix(r1, r2, h);\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdCappedCylinder( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  // n must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n// Distance Function 2D\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n// SdJoint3DSphere & joint3DMatrix & matrix utility\n// by PixelPhil \n// https://www.shadertoy.com/view/3tKGDW\nmat4 scaleMatrix( in vec3 sc ) {\n\treturn mat4(sc.x, 0,\t0,\t0,\n\t\t\t \t0, \t sc.y,\t0,\t0,\n\t\t\t\t0, \t 0,\t sc.z,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationX( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(1.0, 0,\t 0,\t0,\n\t\t\t \t0, \t c,\t-s,\t0,\n\t\t\t\t0, \t s,\t c,\t0,\n\t\t\t\t0, \t 0,  0,\t1);\n}\n\nmat4 rotationY( in float angle ) {\n    \n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4( c, 0,\t s,\t0,\n\t\t\t \t 0,\t1.0, 0,\t0,\n\t\t\t\t-s,\t0,\t c,\t0,\n\t\t\t\t 0, 0,\t 0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n    float c = cos(angle);\n    float s = sin(angle);\n    \n\treturn mat4(c, -s,\t0,\t0,\n\t\t\t \ts,\tc,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\t0,\t0,\t0,\t1);\n}\n\nmat4 translate( in vec3 p) {\n\n\treturn mat4(1,  0,\t0,\t0,\n\t\t\t \t0,\t1,\t0,\t0,\n\t\t\t\t0,\t0,\t1,\t0,\n\t\t\t\tp.x, p.y, p.z, 1);\n}\n// returns distance in .x and UVW parametrization in .yzw\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-w;\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-w;\n}\n\nfloat sdJoint3DSphere( in vec3 p, in float l, in float a, in float w1, float w2)\n{\n  if( abs(a)<0.001 )\n  {\n      return length(p-vec3(0,clamp(p.y,0.0,l),0))-mix(w2, w1, p.y / l);\n  }\n    \n  vec2  sc = vec2(sin(a),cos(a));\n  float ra = 0.5 * l / a;\n  p.x -= ra;\n  vec2 q = p.xy - 2.0*sc*max(0.0,dot(sc,p.xy));\n  float u = abs(ra)-length(q);\n  float d2 = (q.y<0.0) ? dot2( q + vec2(ra,0.0) ) : u*u;\n\n  return sqrt(d2+p.z*p.z)-mix(w2, w1, (p.y / l));\n}\n\n// A matrix to the tip of a sdJoint3DSphere\n// Could probably use some optimisations\nmat4 joint3DMatrix(in float l, in float a)\n{\n  if( abs(a)<0.001 )\n  {\n      return translate(vec3(0, -l, 0));\n  }\n    \n  float ra = 0.5 * l / a;\n  float ara = abs(ra);\n  return  rotationZ(-a * 2.0) * translate(vec3(-ra + cos(2.0 * a) * ra, -sin(2.0 * a) * ra, 0.0));\n}\n\n// Union, Subtraction, SmoothUnion (distance, Material) \nsurface opU(surface d1, surface d2)\n{\n\t//return (d1.dist < d2.dist) ? d1 : d2;\n    if(d1.dist < d2.dist){\n        return d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opS( surface d1, surface d2 )\n{ \n    //return (-d1.dist > d2.dist) ? vec2(-d1.x, d1.y): d2;\n    //return (-d1.dist > d2.dist) ? surface(-d1.dist, d1.albedo, d1.emission, d1.roughness, d1.metalness) : d2;\n    if(-d1.dist > d2.dist){\n        d1.dist = -d1.dist;\n    \treturn d1;\n    } else {\n    \treturn d2;\n    }\n}\n\nsurface opSU( surface d1, surface d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2.dist - d1.dist)/k, 0.0, 1.0 );\n    float d = mix( d2.dist, d1.dist, h ) - k*h*(1.0-h);\n    vec4 albedo = mix( d2.albedo, d1.albedo, h );\n    vec3 emission = mix( d2.emission, d1.emission, h );\n    float roughness = mix( d2.roughness, d1.roughness, h );\n    float metalness = mix( d2.metalness, d1.metalness, h );\n    float refractPower = mix( d2.refractPower, d1.refractPower, h );\n    return surface(d, albedo, emission, roughness, metalness, d1.count, h > 0.5 ? d1.isTransparent : d2.isTransparent, refractPower, true);\n}\n\nsurface opI( surface d1, surface d2 )\n{ \n    //return (d1.dist > d2.dist) ? d1 : d2;]\n    if(d1.dist > d2.dist) {\n        return d1;\n    }else{\n        return d2;\n    }\n}\n\nsurface opPaint(surface d1, surface d2)\n{\n    //return (d1.dist < d2.dist) ? d1 : surface(d1.dist, d2.albedo, d2.emission, d2.roughness, d2.metalness);\n    if(d1.dist < d2.dist) {\n        return d1;\n    } else {\n        d2.dist = d1.dist;\n        return d2;\n    }\n}\n             \n// Union, Subtraction, SmoothUnion (distance only)\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\n\nvec3 rotate(vec3 p, float angle, vec3 axis)\n{\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    mat3 m = mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n    return m * p;\n}\n\nmat2 rot( float th ){ vec2 a = sin(vec2(RAD90, 0) + th); return mat2(a, -a.y, a.x); }\n\nvec4 quat_from_axis_angle(vec3 axis, float angle)\n{ \n  vec4 qr;\n  //float half_angle = (angle * 0.5) * 3.14159 / 180.0;\n    float half_angle = (angle * 0.5);\n  qr.x = axis.x * sin(half_angle);\n  qr.y = axis.y * sin(half_angle);\n  qr.z = axis.z * sin(half_angle);\n  qr.w = cos(half_angle);\n  return qr;\n}\n\nvec4 quat_conj(vec4 q)\n{ \n  return vec4(-q.x, -q.y, -q.z, q.w); \n}\n  \nvec4 quat_mult(vec4 q1, vec4 q2)\n{ \n  vec4 qr;\n  qr.x = (q1.w * q2.x) + (q1.x * q2.w) + (q1.y * q2.z) - (q1.z * q2.y);\n  qr.y = (q1.w * q2.y) - (q1.x * q2.z) + (q1.y * q2.w) + (q1.z * q2.x);\n  qr.z = (q1.w * q2.z) + (q1.x * q2.y) - (q1.y * q2.x) + (q1.z * q2.w);\n  qr.w = (q1.w * q2.w) - (q1.x * q2.x) - (q1.y * q2.y) - (q1.z * q2.z);\n  return qr;\n}\n\nvec3 rotate_vertex_position(vec3 position, vec3 axis, float angle)\n{ \n  vec4 qr = quat_from_axis_angle(axis, angle);\n  vec4 qr_conj = quat_conj(qr);\n  vec4 q_pos = vec4(position.x, position.y, position.z, 0);\n  \n  vec4 q_tmp = quat_mult(qr, q_pos);\n  qr = quat_mult(q_tmp, qr_conj);\n  \n  return vec3(qr.x, qr.y, qr.z);\n}\n\nvec2 foldRotate(in vec2 p, in float s) {\n    float a = M_PI / s - atan(p.x, p.y);\n    float n = M_PI2 / s;\n    a = floor(a / n) * n;\n    p *= rot(a);\n    return p;\n}\n\n\nvec3 opTwist(in vec3 p, float k )\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return vec3(q.x, q.y, q.z);\n}\n\nvec3 TwistY(vec3 p, float power)\n{\n    float s = sin(power * p.y);\n    float c = cos(power * p.y);\n    mat3 m = mat3(\n          c, 0.0,  -s,\n        0.0, 1.0, 0.0,\n          s, 0.0,   c\n    );\n    return m*p;\n}\n\nvec3 opRep( in vec3 p, in vec3 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\nvec2 opRep2D( in vec2 p, in vec2 c)\n{\n    return mod(p+0.5*c,c)-0.5*c;\n}\n\n// 線分と無限平面の衝突位置算出\n// rayPos : レイの開始地点\n// rayDir : レイの向き\n// planePos : 平面の座標\n// planeNormal : 平面の法線\nfloat GetIntersectLength(vec3 rayPos, vec3 rayDir, vec3 planePos, vec3 planeNormal)\n{\n    return dot(planePos - rayPos, planeNormal) / dot(rayDir, planeNormal);\n}\n\n// 直方体とレイの衝突位置算出\nvec2 GetIntersectBox(vec3 rayPos, vec3 rayDir, vec3 boxPos, vec3 boxSize)\n{\n    vec3 diff = rayPos - boxPos;\n\tvec3 m = 1.0 / rayDir;\n    vec3 n = m * diff;\n    vec3 k = abs(m) * boxSize;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    \n    float tN = max(max(t1.x, t1.y), t1.z);\n    float tF = min(min(t2.x, t2.y), t2.z);\n    \n    return vec2(tN, tF);\n    //return vec2(tF, tN);\n/*    \n    if(tN > tF || tF < 0.0)\n        return vec2(-1.0);\t// no intersection\n    \n    return vec2(tN, tF);\n*/\n}\n\n/*\n// 球とレイの衝突位置算出\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 spherePos, float radius)\n{\n    float rsq = radius * radius;\n    vec3 xc = rayPos - spherePos;\n    float xc2 = dot(xc, xc);\n    float vxc = dot(rayDir, xc);\n    float d = vxc * vxc - xc2 + rsq;\n    \n    //if(d < 0.0) return vec2(d,d);\n    \n    float sqrtd = sqrt(d);\n    float tn = -vxc - sqrtd;\n    float tp = -vxc + sqrtd;\n    \n    return vec2(min(tn, tp), max(tn, tp));\n                \n    //if(tn >= 0.0 && tp >= 0.0) return vec2(min(tn, tp), max(tn, tp);\n\n    //return tn;\n}\n*/\nvec2 GetIntersectSphere(vec3 rayPos, vec3 rayDir, vec3 sphereCenter, float radius) {\n    float a = length(rayDir);\n    float a2 = a * a;\n    vec3 diff = rayPos - sphereCenter;\n    float b = dot(diff, rayDir);\n    float c = length(diff);\n    float c2 = c * c - radius * radius;\n    float b2ac = sqrt(b * b - a2 * c2);\n    float t1 = (-b + b2ac) / a2;\n    float t2 = (-b - b2ac) / a2;\n    return vec2(min(t1, t2), max(t1, t2));\n}\n\n// IK\nvec3 solve( vec3 p, float l1, float l2, vec3 dir )\n{\n\tvec3 q = p*( 0.5 + 0.5*(l1*l1-l2*l2)/dot(p,p) );\n\t\n\tfloat s = l1*l1 - dot(q,q);\n\ts = max( s, 0.0 );\n\tq += sqrt(s)*normalize(cross(p,dir));\n\t\n\treturn q;\n\n}\n\nvec3 solve( vec3 a, vec3 b, float l1, float l2, vec3 dir )\n{\n\treturn a + solve( b-a, l1, l2, dir );\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// easing function\n/////////////////////////////////////////////////////////////////////////////////////////////////\nfloat ease_cubic_out(float p)\n{\n\tfloat f = (p - 1.0);\n\treturn f * f * f + 1.0;\n}\n\nfloat easeInCirc(float x)\n{\n\treturn 1. - sqrt(1. - pow(x, 2.));\n}\n\nfloat easeOutCirc(float x) \n{\n\treturn sqrt(1. - pow(x - 1., 2.));\n}\n\nfloat easeInExpo(float x)\n{\n\treturn x == 0. ? 0. : pow(2., 10. * x - 10.);\n}\n\n\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// Mikka Boze Distance Function\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nfloat sdEar(vec3 p)\n{\n    p = rotate(p, RAD90+0.25, vec3(0,0,1));    \n    return sdCappedTorus(p + vec3(0.05, 0.175, 0), vec2(sin(0.7),cos(0.7)), 0.03, 0.01);\n}\n\n#define EYE_SPACE 0.04\n\nvec3 opBendXY(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    return vec3(m*p.xy,p.z);\n}\n\nvec3 opBendXZ(vec3 p, float k)\n{\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec2 xz = m*p.xz;\n    return vec3(xz.x, p.y, xz.y);\n}\n\nfloat sdMouse(vec3 p, float ms)\n{\n    vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(q - vec3(0,0,0.2), vec3(0.035, 0.01 * ms,0.05 * ms));\n}\nfloat sdMouseTunnel(vec3 p, float ms)\n{\n    //vec3 q = opBendXY(p, 2.0);\n    ms += 0.00001;\n    //return sdEllipsoid(q - vec3(0,0,0.2) * sc, vec3(0.05,0.015 + sin(iTime * 1.) * 0.05,0.05) * sc);\n    return sdEllipsoid(p - vec3(0,0,0.2), vec3(0.08, 0.01 * ms,2));\n}\n\nfloat sdCheep(vec3 p)\n{    \n    const float x = 0.05;\n    const float z = -0.175;\n    const float r = 0.0045;\n    const float rb1 = 100.;\n    \n    p = rotate(p, M_PI * -0.6 * (p.x - x), vec3(-0.2,0.8,0));\n\t\n    float d = sdCapsule(opBendXY(p + vec3(x, -0.01, z), rb1), vec3(-0.005,0.0,0.0), vec3(0.005, 0., 0.001), r);\n    float d1 = sdCapsule(opBendXY(p + vec3(x+0.01, -0.01, z), 200.0), vec3(-0.0026,0.0,0), vec3(0.0026, 0., 0), r);\n    float d2 = sdCapsule(opBendXY(p + vec3(x+0.019, -0.015, z), -rb1), vec3(-0.01,0.0,-0.01), vec3(0.0045, 0., 0.0), r);\n    \n    return opUnion(opUnion(d, d1), d2);\n}\n\nfloat sdEyeBrow(vec3 p)\n{\n    const float x = 0.05;\n    p = opBendXZ(p + vec3(0.02,0,-0.02), -6.5);\n    return sdRoundBox(p + vec3(0.005, -0.14,-0.11), vec3(0.003,0.0025,0.05), 0.001);\n}\n\nsurface sdBoze(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/*\nsurface sdCapsuleBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n\treturn sdBoze(pa - ba*h, sc, ms);\n}\n\nsurface sdUFBoze(vec3 p, vec3 sc, float ms)\n{\n    float sl = length(sc);\n    surface cone = SURF_CS(sdCappedCone(p + vec3(0, 0.08 * sl, 0), 0.06 * sl, 0.5 * sl, 0.25 * sl));\n    return opU(sdBoze(p, sc, ms), cone);\n}\n\nsurface sdCapsuleUFBoze(vec3 p, vec3 a, vec3 b, vec3 sc, float ms)\n{\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return sdUFBoze(pa - ba*h, sc, ms);\n    //vec3 q = rotate(pa - ba*h, h * M_PI2, normalize(ba));\n\t//return sdUFBoze(q, sc, ms);\n}\n*/\nsurface sdColorBoze(vec3 p, vec3 sc, float ms, vec3 color)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\thead.albedo.rgb = color;\n    \n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n#define LEG_X 0.05\n#define LEG_WIDTH1 0.05\n#define LEG_WIDTH2 0.025\n#define LEG_WIDTH3 0.045\n\n#define ARM_X1 0.18\n#define ARM_X2 0.2\n#define ARM_WIDTH1 0.05\n#define ARM_WIDTH2 0.025\n#define ARM_WIDTH3 0.03\n/*\nvoid calcArm(out vec3 a0, out vec3 a1, out vec3 a2, float spd, float flip, float h)\n{\n\t//vec3 n = noised(vec2(330. + spd * 0.97 + 578.4516 * flip, spd * flip));\n    vec3 n = vec3(sin(spd * 0.97+ 578.4516 * flip), cos(spd * 0.75* flip), sin(spd * flip + RAD90));\n    float r = n.z * 0.15 + 0.15;\n    float theta = (n.x * 0.5 + 0.5) * RAD90;\n    float phi = (n.y * 0.5 + 0.5) * RAD90;\n    a0 = vec3(ARM_X1 * flip, 0.9-h, 0.);\n    a2 = vec3(ARM_X2 * flip + sin(theta) * cos(phi) * r * flip, 0.75 + cos(n.y * M_PI2) * r-h, -sin(theta) * sin(phi) * r);\n    a1 = solve(a0, a2, 0.25, 0.15, vec3(0.5,0,0.5 * flip));\n}\n\nsurface sdBozeFullBody(vec3 p)\n{\n    surface result = SURF_NOHIT(0.);\n    \n    float spd = iTime * 2.5;\n    \n    // leg\n    //vec3 n1 = noised(vec2(spd, spd * 0.75));\n    vec3 n1 = vec3(sin(spd), cos(spd * 0.75), sin(spd + M_PI));\n    float r1 = n1.z * 0.25 + 0.25;\n    vec3 ll2 = vec3(LEG_X + sin(n1.y * M_PI) * cos(n1.x * M_PI) * r1, cos(n1.y * M_PI) * 0.3, sin(n1.y * M_PI) * sin(n1.x * M_PI) * r1);\n        \n    //vec3 n2 = noised(vec2(-spd * 0.75, spd));\n    vec3 n2 = vec3(cos(spd), sin(spd * 0.75), cos(spd + RAD90));\n    float r2 = n2.z * 0.25 + 0.25;\n    vec3 rl2 = vec3(-LEG_X + sin(n2.y * M_PI) * cos(n2.x * M_PI) * r2, cos(n2.y * M_PI) * 0.3, sin(n2.y * M_PI) * sin(n2.x * M_PI) * r2);\n\n    float h = min(ll2.y, rl2.y);\n\n    vec3 ll0 = vec3(LEG_X, 0.5-h, 0.);\n    vec3 ll1 = solve(ll0, ll2, 0.25, 0.25, vec3(-1,0,0));\n    \n    vec3 rl0 = vec3(-LEG_X, 0.5-h, 0.);\n    vec3 rl1 = solve(rl0, rl2, 0.25, 0.25, vec3(-1,0,0));\n    \n    //result = SURF_MIRROR(sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    float body = sdCapsule(p, ll0, ll1, LEG_WIDTH1, LEG_WIDTH2);\n    //body = smin(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ll1, ll2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    //result = opU(result, SURF_MIRROR(sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2)));\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3)), 0.01);\n    body = min(body, sdCapsule(p, rl0, rl1, LEG_WIDTH1, LEG_WIDTH2));\n    //body = smin(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, rl1, rl2, LEG_WIDTH2, LEG_WIDTH3));\n    \n    // body\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05)), 0.05);\n    //result = opSU(result, SURF_MIRROR(sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075)), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05), 0.05);\n    //body = smin(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075), 0.05);\n    body = min(body, sdRoundBox(p - vec3(0,0.6 - h,0), vec3(0.125,0.2,0.0),0.05));\n    body = min(body, sdRoundBox(p - vec3(0,0.8 - h,-0.0125), vec3(0.15,0.1,0.0),0.075));\n    \n    // left arm\n    vec3 la0, la1, la2;\n    calcArm(la0, la1, la2, spd, 1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n\tbody = min(body, sdCapsule(p, la0, la1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, la1, la2, ARM_WIDTH2, ARM_WIDTH3));\n\n    // right arm\n    vec3 ra0, ra1, ra2;\n    calcArm(ra0, ra1, ra2, spd, -1., h);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2)), 0.025);\n    //result = opSU(result, SURF_MIRROR(sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3)), 0.01);\n    //body = smin(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2), 0.025);\n    //body = smin(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3), 0.01);\n    body = min(body, sdCapsule(p, ra0, ra1, ARM_WIDTH1, ARM_WIDTH2));\n    body = min(body, sdCapsule(p, ra1, ra2, ARM_WIDTH2, ARM_WIDTH3));\n    \n    result = SURF_MIRROR(body);\n    \n    // head\n    vec3 b = p;\n    \n    b = rotate(b, M_PI, vec3(0,1,0));\n    b.y -= 1.01-h;\n\n    result = opSU(result, sdBoze(b, vec3(1), 1.), 0.02);\n\t\n    return result;\n}\n\nsurface sdWatermelonBoze(vec3 p, vec3 sc, float ms)\n{\n    //surface result = sdBoze(p, vec3(1), 1.);\n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n    // outer skin\n\tsurface head = SURF_WATERMELON(d, p, vec3(0));\n\n    if(head.dist < 0.){\n        if(head.dist > -0.01){\n\t    \t// inner skin\n        \thead.albedo = mix(head.albedo, vec4(1,1,0.5,1), smoothstep(0., 0.01, abs(head.dist)));\n    \t}else{\n            // flesh meat\n            float n = fbm(p * 25.);\n            head.albedo = mix(vec4(1,1,0.5,1), vec4(1,0,0,1) + n * 0.2, smoothstep(0.01, 0.015, abs(head.dist)));\n            // seed\n            const float mb = M_PI2 / 32.;\n            vec3 ps = p;\n            ps.y -= 0.025;\n    \t\tfloat b = mod(atan(ps.y, ps.z), mb) - 0.5 * mb;\n    \t\tfloat c = smoothstep(.15, .18, length(vec2(b*12.,abs(head.dist)*15.0 - 0.5)));\n            head.roughness = mix(0.01, 0.1, c);\n            head.albedo = mix(vec4(0.02), head.albedo, c);\n    \t}\n    }\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    //surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouse(p, ms);\n    //surface mouse = SURF_MOUSE(d6);\n    d4 = min(d4, d6);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    //eye.dist = opUnion(eye.dist, d9);\n    d4 = min(d4, d9);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n\t//surface cheep = SURF_BLACK(d7); \n    \n    head.dist = min(head.dist, d7);\n    head.dist = max(-d4, head.dist);\n    \n    // integration\n    //mouse = opU(eye, mouse);\n    //result = opS(mouse, head);\n    //result = opU(cheep, result);\n    result = head;\n    result.dist *= minsc;\n    \n    return result;\n}\n*/\n\nsurface sdBozeGate(vec3 p, vec3 sc, float ms)\n{    \n    surface result = SURF_NOHIT(1e5);\n    \n    float minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // head\n\tfloat d = sdCapsule(p, vec3(0,0.05,0), vec3(0, 0.11, 0), 0.125);\n    \n    float d1 = sdRoundedCylinder(p + vec3(0,0.025,0), 0.095, 0.05, 0.0);\n    \n    d = smin(d, d1, 0.1);\n    \n    vec3 mxp = vec3(-abs(p.x), p.yz);\n    \n    // ear\n    float d2 = sdEar(mxp);\n    d = opUnion(d, d2);\n\n\tsurface head = SURF_FACE(d);\n\n\t// eye\n    float d4 = sdCapsule(mxp, vec3(-EYE_SPACE, 0.06, 0.13), vec3(-EYE_SPACE, 0.08, 0.125), 0.0175);\n    surface eye = SURF_BLACK(d4);\n    \n    // mouse\n    float d6 = sdMouseTunnel(p, ms);\n    surface mouse = SURF_MOUSE(d6);\n    \n    // cheep\n    float d7 = sdCheep(mxp);\n    surface cheep = SURF_CHEEP(d7);\n    \n    // eyebrows\n    float d9 = sdEyeBrow(mxp);\n    eye.dist = opUnion(eye.dist, d9);\n    \n    // integration\n    mouse = opU(eye, mouse);\n    result = opS(mouse, head);\n    result = opU(cheep, result);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n/////////////////////////////////////////////////////////////////////////////////////////////////\n// End of Mikka Boze\n/////////////////////////////////////////////////////////////////////////////////////////////////\n\nsurface sdSushi(vec3 p, vec3 sc, vec3 col) {\n    surface result = SURF_NOHIT(1e5);\n    \n\tfloat minsc = min(sc.x, min(sc.y, sc.z));\n    p /= sc;\n    \n    // shari\n    float shari = sdRoundBox(p, vec3(0.75,0.5,1.75), 0.125);\n    \n    result = SURF_SHARI(shari);\n    \n    //float neta = sdRoundBox(p-vec3(0,0.5625,0), vec3(1,0.25,2), 0.05);\n    \n    surface neta = SURF_NETA(sdRoundBox(p-vec3(0,0.5625,0), vec3(1,0.25,2), 0.05), col);\n    \n    result = opU(result, neta);\n    \n    result.dist *= minsc;\n    \n    return result;\n}\n\nCtrlPts ctrlPts;\n\nsurface map(vec3 p)\n{\n\tsurface result = SURF_NOHIT(1e5);\n    \n    // cource\n    vec3 cp;\n    float d = sdCatmullRomSpline(p, ctrlPts, cp);\n    \n    //d = sdRoundBox(p-cp, vec3(0.05), 0.01);\n    d = sdBox(p-cp, vec3(0.5, 0.05, 0.5));\n    \n    result = opU(result, SURF_LOAD(d, p, cp));\n\n    /*\n    // boze\n    vec3 q = rotate(p, iTime * 0.2, vec3(0,1,0));\n    surface boze = sdBoze(q-vec3(0,0.5,0), vec3(5), abs(sin(iTime *0.5)));\n    \n    result = opU(result, boze);\n    */\n    \n    // boze gate\n    vec3 q = rotate(p+vec3(0,-0.15,1.35), -RAD90, vec3(0,1,0));\n    surface gate = sdBozeGate(q, vec3(8), 3.);\n    result = opU(result, gate);\n    \n    // sushi\n    vec3 offset = vec3(0, 0.125, 0);\n    for(int i = 0; i < 3; i++)\n    {\n        float t = iTime * CAMERA_SPEED + 0.075 + sin(iTime * (1.+hash11(float(i+6396))))*0.05;\n        vec3 sp = catmullRom(fract(t), ctrlPts);\n        vec3 fwd = normalize(catmullRom(fract(t+0.02), ctrlPts)- sp);\n        vec3 right = cross(fwd, vec3(0,1,0));\n\n        //sp += offset + right * (-0.2 * (float(i-1)+sin(iTime * hash11(float(i+158)))*0.05));\n        sp += offset + right * -0.2 * (float(i-1));\n        \n        vec3 sq = rotate(p-sp, atan(fwd.z, fwd.x)+RAD90, vec3(0,1,0));\n        //vec3 sq = rotate_vertex_position(p-sp, vec3(0,1,0), atan(fwd.z, fwd.x)+RAD90);\n        sq = rotate(sq, acos(fwd.y)-RAD90, vec3(1,0,0));\n\n        // maguro\n        vec3 col1 = mix(vec3(1,0.8,0.9), vec3(0.95,0,0.01), smoothstep(0.0, 0.2, fract(abs(sq.x + sq.y + sq.z)*10.)));\n        // tamago\n\t\tvec3 col2 = vec3(0.9,0.87,0.05);\n        // sake\n        vec3 col3 = mix(vec3(1,0.8,0.7), vec3(0.95,0.3,0.01), smoothstep(0.0, 0.2, fract(abs(sq.x + sq.y + sq.z+2.3)*22.)));\n        vec3 col = (i == 0) ? col1 : (i == 1) ? col2 : col3;\n        surface sushi = sdSushi(sq, vec3(0.1), col);\n\n        result = opU(result, sushi);\n    }\n    \n    return result;\n}\n/*\nfloat mapNormal(vec3 p)\n{\n\tsurface result;\n    \n    // background\n    float h = sea_octave(p.xz * 0.75, 5.5) * 0.2;\n    //h += sea_octave(p.xz * 100., 0.1) * 0.01;\n    //float gl = noise(p*500.);\n    //h += noise(p*500.) * 0.00075;\n    h += hash12(p.xz*100.) * 0.0002;\n    float sand = abs(p.y - h * length(p.xz*0.5) + 0.2);\n    \n    float dist = sand * 0.5;\n    //result = SURF_DESERT(sand * 0.5);\n    //result.roughness = 0.0001;\n    //result.metalness = 0.1;\n    //result.metalness = saturate(gl*10.);\n    //result.roughness = 0.1;\n    \n    // boze\n    p = rotate(p, M_PI, vec3(0,1,0));\n    \n    float a = 1. - smoothstep(0., 5., cos(iTime*1.) * 5. + 2.5);\n    vec3 b = p;\n    b.y += (1.-a)*0.1;\n    b.x += 0.15 * a;\n    b = rotate(b, (-RAD90-RAD90*0.25)*a, vec3(0,0,1));\n    \n    float boze = sdBoze(b, vec3(1), 2.).dist;\n    //surface boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    b = p;\n    b.y += (1.-a)*0.1;\n    b.x -= 0.15 * a;\n    b = rotate(b, (RAD90+RAD90*0.25)*a, vec3(0,0,1));\n    boze = sdBoze(b, vec3(1), 2.).dist;\n    //boze = sdBoze(b, vec3(1), 2.);\n    boze = max(boze, sdBox(b + vec3(-0.5, 0.5, 0), vec3(0.5,1,1)));\n    dist = min(boze, dist);\n    \n    //result = opU(result, boze);\n    \n    //return result;\n    return dist;\n}\n*/\n#if 0\nvec3 norm(vec3 p)\n{\n    /*\n    vec2 e=vec2(.00001,.0);\n    return normalize(.000001+map(p).dist-vec3(map(p-e.xyy).dist,map(p-e.yxy).dist,map(p-e.yyx).dist));\n*/\n\tfloat c=mapNormal(p).dist;\n\tfloat e=1e-3;\n\treturn normalize(vec3(mapNormal(p+vec3(e,0,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,e,0)).dist-c,\n\t\t\t\t\t\t  mapNormal(p+vec3(0,0,e)).dist-c));\n}\n#else\n\nvec3 norm(in vec3 position) {\n    /*\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          map(position + epsilon.xyy).dist - map(position - epsilon.xyy).dist,\n          map(position + epsilon.yxy).dist - map(position - epsilon.yxy).dist,\n          map(position + epsilon.yyx).dist - map(position - epsilon.yyx).dist);\n    return normalize(n);\n\t*/\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    // https://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(position+0.0005*e).dist;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n    /*\n    // https://www.shadertoy.com/view/XltyRf\n    vec4 n = vec4(0);\n    for (int i = 0 ; i < 4 ; i++) {\n        vec4 s = vec4(position, 0);\n        s[i] += 0.001;\n        n[i] = map(s.xyz).dist;\n    }\n    return normalize(n.xyz-n.w);\n\t*/\n}\n#endif\n\n/*\nfloat shadow(in vec3 origin, in vec3 direction) {\n    float hit = 1.0;\n    float t = 0.02;\n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        float h = map(origin + direction * t).dist;\n        if (h < EPS) return 0.0;\n        t += h;\n        hit = min(hit, 10.0 * h / t);\n        if (t >= 2.5) break;\n    }\n\n    return clamp(hit, 0.0, 1.0);\n}\n*/\nfloat shadow(in vec3 p, in vec3 l)\n{\n    float t = 0.15;\n    float t_max = 20.0;\n    \n    float res = 1.0;\n    for (int i = 0; i < 16; ++i)\n    {\n        if (t > t_max) break;\n        \n        float d = map(p + t*l).dist;\n        if (d < 0.01)\n        {\n            return 0.0;\n        }\n        t += d;\n        res = min(res, 1.0 * d / t);\n    }\n    \n    return res;\n}\n\n// ---------------------------------------------------\n// Starfield01 by xaot88\n// https://www.shadertoy.com/view/Md2SR3\n// ---------------------------------------------------\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Return random noise in the range [0.0, 1.0], as a function of x.\nfloat Noise2d( in vec2 x )\n{\n    float xhash = cos( x.x * 37.0 );\n    float yhash = cos( x.y * 57.0 );\n    return fract( 415.92653 * ( xhash + yhash ) );\n}\n\n// Convert Noise2d() into a \"star field\" by stomping everthing below fThreshhold to zero.\nfloat NoisyStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    float StarVal = Noise2d( vSamplePos );\n    if ( StarVal >= fThreshhold )\n        StarVal = pow( (StarVal - fThreshhold)/(1.0 - fThreshhold), 6.0 );\n    else\n        StarVal = 0.0;\n    return StarVal;\n}\n\n// Stabilize NoisyStarField() by only sampling at integer values.\nfloat StableStarField( in vec2 vSamplePos, float fThreshhold )\n{\n    // Linear interpolation between four samples.\n    // Note: This approach has some visual artifacts.\n    // There must be a better way to \"anti alias\" the star field.\n    float fractX = fract( vSamplePos.x );\n    float fractY = fract( vSamplePos.y );\n    vec2 floorSample = floor( vSamplePos );    \n    float v1 = NoisyStarField( floorSample, fThreshhold );\n    float v2 = NoisyStarField( floorSample + vec2( 0.0, 1.0 ), fThreshhold );\n    float v3 = NoisyStarField( floorSample + vec2( 1.0, 0.0 ), fThreshhold );\n    float v4 = NoisyStarField( floorSample + vec2( 1.0, 1.0 ), fThreshhold );\n\n    float StarVal =   v1 * ( 1.0 - fractX ) * ( 1.0 - fractY )\n        \t\t\t+ v2 * ( 1.0 - fractX ) * fractY\n        \t\t\t+ v3 * fractX * ( 1.0 - fractY )\n        \t\t\t+ v4 * fractX * fractY;\n\treturn StarVal;\n}\n/*\nvec2 getPoint(vec2 id, vec2 offset)\n{\n    return sin(hash22(id + offset) * iTime * 1.5 + hash22(id + offset)) * 0.4 + offset;\n}\n*/\nvec3 SkyColor( vec3 rd )\n{\n#if 0\n    // Cube Map\n\t// hide cracks in cube map\n\trd -= sign(abs(rd.xyz)-abs(rd.yzx))*.01;\n\n\tvec3 ldr = texture( iChannel0, rd ).rgb;\n    \n\t// fake hdr\n\tvec3 hdr = 1.0/(1.2-ldr) - 1.0/1.2;\n\t\n\treturn hdr;\n#else\n    // Black\n    //return vec3(0);\n    \n    // test 1 UV\n    //return rd * 0.5 + 0.5;\n    \n    // sinebow\n    //return sinebow(iTime*0.5) * 0.1;\n    \n    //return vec3(0,0.5,0);\n    \n    /*\n    // plexus\n    vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    uv += vec2(10.);\n    uv = abs(uv);\n    vec2 suv = uv * 10.;\n    \n    vec2 id = floor(suv) - 0.5;\n    vec2 fuv = fract(suv) - 0.5;\n\tvec2 pp =  getPoint(id, vec2(0));\n    vec3 col = vec3(0);\n    \n    for(int x = -1; x <= 1; x++){\n    \tfor(int y = -1; y <= 1; y++){\n            vec2 pos = getPoint(id, vec2(x,y)); //sin(hash22(id + vec2(x,y)) * iTime * 1.5) * 0.4 + vec2(x,y);\n            float d = 1.0 / pow(length(fuv - pos), 1.75) * 0.001;\n            col += d;\n\n            float len = smoothstep(1.0,0.5,length(pp - pos));\n            col += smoothstep(0.025,0.001,sdSegment(fuv, pos, pp)) * len;\n        }\n    }\n\t\n    return col * sinebow(uv.x);\n\t*/\n    /*\n    // fake unity default sky-box\n\tvec3 ground = mix(vec3(0.25,0.4,0.8), vec3(0.2,0.15,0.15), saturate(abs(rd.y) * 25.0));\n    //vec3 ground = mix(vec3(0.25,0.4,0.8), COLOR_SEA, saturate(abs(rd.y) * 25.0));\n    //vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.001, 0.15, 1.), saturate(abs(rd.y) * 10.0));\n    vec3 sky = mix(vec3(0.25,0.4,0.8), vec3(0.5, 0.8, 1.), saturate(abs(rd.y) * 10.0));\n    return rd.y < 0. ? ground :sky;\n    */\n    \n\t// Starfield\n    float x = atan(rd.z / rd.x);\n    float y = acos(rd.y);\n    return vec3(StableStarField(vec2(x,y) * 500., 0.99 ));\n    \n    // wave z\n    //vec2 uv = vec2(atan(rd.z/rd.x), atan(length(rd.xz)/rd.y)) / M_PI;\n    //return vec3(saturate(uv),0);\n    //return vec3(1,0,0) * saturate(sin(rd.z *100.- iTime * 10.));\n    //return sinebow(rd.z * 5.- iTime * 3.) * 0.25;\n    //return smoothstep(0.01,0.,mod(rd.z - iTime * 0.1, 0.1))*vec3(0.05,0.2,0.5);\n#endif\n}\n\n\n\n#ifdef USE_BRDF_1\n//------------------------------------------------------------------------------\n// BRDF 1\n//------------------------------------------------------------------------------\n\nfloat pow5(float x) {\n    float x2 = x * x;\n    return x2 * x2 * x;\n}\n\nfloat D_GGX(float linearRoughness, float NoH, const vec3 h) {\n    // Walter et al. 2007, \"Microfacet Models for Refraction through Rough Surfaces\"\n    float oneMinusNoHSquared = 1.0 - NoH * NoH;\n    float a = NoH * linearRoughness;\n    float k = linearRoughness / (oneMinusNoHSquared + a * a);\n    float d = k * k * (1.0 / M_PI);\n    return d;\n}\n\nfloat V_SmithGGXCorrelated(float linearRoughness, float NoV, float NoL) {\n    // Heitz 2014, \"Understanding the Masking-Shadowing Function in Microfacet-Based BRDFs\"\n    float a2 = linearRoughness * linearRoughness;\n    float GGXV = NoL * sqrt((NoV - a2 * NoV) * NoV + a2);\n    float GGXL = NoV * sqrt((NoL - a2 * NoL) * NoL + a2);\n    return 0.5 / (GGXV + GGXL);\n}\n\nvec3 F_Schlick(const vec3 f0, float VoH) {\n    // Schlick 1994, \"An Inexpensive BRDF Model for Physically-Based Rendering\"\n    return f0 + (vec3(1.0) - f0) * pow5(1.0 - VoH);\n}\n\nfloat F_Schlick(float f0, float f90, float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat Fd_Burley(float linearRoughness, float NoV, float NoL, float LoH) {\n    // Burley 2012, \"Physically-Based Shading at Disney\"\n    float f90 = 0.5 + 2.0 * linearRoughness * LoH * LoH;\n    float lightScatter = F_Schlick(1.0, f90, NoL);\n    float viewScatter  = F_Schlick(1.0, f90, NoV);\n    return lightScatter * viewScatter * (1.0 / M_PI);\n}\n\nfloat Fd_Lambert() {\n    return 1.0 / M_PI;\n}\n\n\n//------------------------------------------------------------------------------\n// Indirect lighting\n//------------------------------------------------------------------------------\n\nvec3 Irradiance_SphericalHarmonics(const vec3 n) {\n    // Irradiance from \"Ditch River\" IBL (http://www.hdrlabs.com/sibl/archive.html)\n    return max(\n          vec3( 0.754554516862612,  0.748542953903366,  0.790921515418539)\n        + vec3(-0.083856548007422,  0.092533500963210,  0.322764661032516) * (n.y)\n        + vec3( 0.308152705331738,  0.366796330467391,  0.466698181299906) * (n.z)\n        + vec3(-0.188884931542396, -0.277402551592231, -0.377844212327557) * (n.x)\n        , 0.0);\n}\n\nvec2 PrefilteredDFG_Karis(float roughness, float NoV) {\n    // Karis 2014, \"Physically Based Material on Mobile\"\n    const vec4 c0 = vec4(-1.0, -0.0275, -0.572,  0.022);\n    const vec4 c1 = vec4( 1.0,  0.0425,  1.040, -0.040);\n\n    vec4 r = roughness * c0 + c1;\n    float a004 = min(r.x * r.x, exp2(-9.28 * NoV)) * r.x + r.y;\n\n    return vec2(-1.04, 1.04) * a004 + r.zw;\n}\n\nvec3 calcAmb(vec3 pos, vec3 rayDir, vec3 normal, vec3 lightPos, vec3 lightColor, surface surf) {\n    vec3 color = vec3(0);\n    vec3 lightDir = normalize(lightPos);\n    vec3 viewDir = normalize(-rayDir);\n    vec3 halfV = normalize(viewDir + lightDir);\n    //vec3 r = normalize(reflect(rayDir, normal));\n\t\n    float NoV = abs(dot(normal, viewDir)) + 1e-5;\n    float NoL = saturate(dot(normal, lightDir));\n    float NoH = saturate(dot(normal, halfV));\n    float LoH = saturate(dot(lightDir, halfV));\n    \n    float indirectIntensity = 0.64;\n    \n    vec3 albedo = surf.albedo.rgb;\n    float roughness = surf.roughness;\n    float metallic = surf.metalness;\n    float linearRoughness = roughness * roughness;\n    vec3 diffuseColor = (1.0 - metallic) * albedo.rgb;\n    vec3 f0 = 0.04 * (1.0 - metallic) + albedo.rgb * metallic;\n    \n    float attenuation = shadow(pos, lightDir);\n    \n    // specular BRDF\n    float D = D_GGX(linearRoughness, NoH, halfV);\n    float V = V_SmithGGXCorrelated(linearRoughness, NoV, NoL);\n    vec3  F = F_Schlick(f0, LoH);\n    vec3 Fr = (D * V) * F;\n\n    // diffuse BRDF\n    vec3 Fd = diffuseColor * Fd_Burley(linearRoughness, NoV, NoL, LoH);\n    color = Fd + Fr;\n    color *= (attenuation * NoL) * lightColor;\n    \n \t// diffuse indirect\n    vec3 indirectDiffuse = Irradiance_SphericalHarmonics(normal) * Fd_Lambert();\n    \n    vec3 ibl = diffuseColor * indirectDiffuse;\n    \n    color += ibl * indirectIntensity;\n\tcolor += surf.emission.rgb;\n    \n    return color;\n}\n#else\n//------------------------------------------------------------------------------\n// BRDF 2\n//------------------------------------------------------------------------------\nfloat ndfGGX(float NdotH, float roughness)\n{\n\tfloat alpha   = roughness * roughness;\n\tfloat alphaSq = alpha * alpha;\n\n\tfloat denom = (NdotH * NdotH) * (alphaSq - 1.0) + 1.0;\n\treturn alphaSq / (M_PI * denom * denom);\n}\n\nfloat gaSchlickG1(float theta, float k)\n{\n\treturn theta / (theta * (1.0 - k) + k);\n}\n\nfloat gaSchlickGGX(float NdotL, float NdotV, float roughness)\n{\n\tfloat r = roughness + 1.0;\n\tfloat k = (r * r) / 8.0;\n\treturn gaSchlickG1(NdotL, k) * gaSchlickG1(NdotV, k);\n}\n\nvec3 fresnelSchlick_roughness(vec3 F0, float cosTheta, float roughness) {\n    return F0 + (max(vec3(1.0 - roughness), F0) - F0) * pow(1.0 - cosTheta, 5.0);\n}\n\n//surface surf\n//vec3 shade(vec3 pos, vec3 albedo, float metalness, float roughness, vec3 N, vec3 V, vec3 L, vec3 Lradiance)\nvec3 shade(vec3 pos, vec3 N, vec3 V, vec3 L, vec3 Lradiance, surface surf)\n{\n\tvec3 H = normalize(L + V);\n\tfloat NdotV = max(0.0, dot(N, V));\n\tfloat NdotL = max(0.0, dot(N, L));\n\tfloat NdotH = max(0.0, dot(N, H));\n\t\t\n\tvec3 F0 = mix(vec3(0.04), surf.albedo.rgb, surf.metalness);\n\n\tvec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(H, L)), surf.roughness);\n\tfloat D = ndfGGX(NdotH, surf.roughness);\n\tfloat G = gaSchlickGGX(NdotL, NdotV, surf.roughness);\n\n\tvec3 kd = mix(vec3(1.0) - F, vec3(0.0), surf.metalness);\n\n    float shadow = shadow(pos, L);\n\tvec3 diffuseBRDF = kd * surf.albedo.rgb / M_PI;\n\tvec3 specularBRDF = (F * D * G) / max(0.0001, 4.0 * NdotL * NdotV);\n\n\treturn (diffuseBRDF + specularBRDF) * Lradiance * NdotL * shadow;\n}\n\n// Unreal Engine Ambient BRDF Approx\n// https://www.unrealengine.com/en-US/blog/physically-based-shading-on-mobile?lang=en-US\nvec3 EnvBRDFApprox( vec3 SpecularColor, float Roughness, float NoV )\n{\n\tconst vec4 c0 = vec4( -1, -0.0275, -0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, -0.04 );\n\tvec4 r = Roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( -9.28 * NoV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn SpecularColor * AB.x + AB.y;\n}\n\n// Specular Occlusion\n// https://media.contentapi.ea.com/content/dam/eacom/frostbite/files/course-notes-moving-frostbite-to-pbr-v2.pdf\nfloat so(float NoV, float ao, float roughness) {\n    return clamp(pow(NoV + ao, exp2(-16.0 * roughness - 1.0)) - 1.0 + ao, 0.0, 1.0);\n}\n\nvec3 calcAmbient(vec3 pos, vec3 N, vec3 V, float t, vec3 ambientColor, surface surf)\n{\n\tvec3 F0 = mix(vec3(0.04), surf.albedo.rgb, surf.metalness);\n    vec3 F  = fresnelSchlick_roughness(F0, max(0.0, dot(N, V)), surf.roughness);\n    vec3 kd = mix(vec3(1.0) - F, vec3(0.0), surf.metalness);\n    \n\tfloat aoRange = t/40.0;\n\tfloat occlusion = max( 0.0, 1.0 - map( pos + N*aoRange ).dist/aoRange );\n\tocclusion = min(exp2( -.8 * pow(occlusion, 2.0) ), 1.0);\n    \n    //vec3 ambientColor = mix(vec3(0.2,0.5,0.85)*0.5, vec3(0.2,0.25,0.8) * 0.75, 0.5+0.5*N.y);\n    //ambientColor = mix(vec3(0.3, 0.15, 0.05), ambientColor, 1.0 - smoothstep(0.2, -0.5, sunDir.y));\n    //ambientColor = mix(vec3(0.03), ambientColor,  1.0 - smoothstep(-0.2, -0.5, sunDir.y));\n    \n    vec3 diffuseAmbient = kd * surf.albedo.rgb * ambientColor * min(1.0, 0.75+0.5*N.y) * 3.0;\n    vec3 R = reflect(-V, N);\n    \n    //vec3 col = mix(fakeSky(R) * pow( 1.0-max(-R.y,0.0), 4.0), ambientColor, pow(roughness, 0.5));\n    vec3 col = ambientColor;\n    vec3 ref = EnvBRDFApprox(F0, surf.roughness, max(dot(N, V), 0.0));\n    vec3 specularAmbient = col * ref;\n\n    diffuseAmbient *= occlusion;\n    specularAmbient *= so(max(0.0, dot(N, V)), occlusion, surf.roughness);\n\n    return vec3(diffuseAmbient + specularAmbient);\n}\n#endif\n\n//------------------------------------------------------------------------------\n// Tone mapping and transfer functions\n//------------------------------------------------------------------------------\n\nvec3 Tonemap_ACES(const vec3 x) {\n    // Narkowicz 2015, \"ACES Filmic Tone Mapping Curve\"\n    const float a = 2.51;\n    const float b = 0.03;\n    const float c = 2.43;\n    const float d = 0.59;\n    const float e = 0.14;\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec3 OECF_sRGBFast(const vec3 linear) {\n    return pow(linear, vec3(1.0 / 2.2));\n}\n\n#ifdef USE_RAYCAST\n///////////////\n/*\nfloat sdAirLine(vec3 p)\n{\n\tconst float w = 0.0125;\n    float angle = -radians(30.);\n    p.y += 0.4;\n    float air = sdCapsule(p, vec3(0), vec3(0., -1.0, 0), w);\n    air = min(air, sdJoint3DSphere(p, 0.3, angle, w));\n    mat4 mat = joint3DMatrix(0.3, angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    air = min(air, sdJoint3DSphere(p, 0.25, radians(30.), w));\n    mat = joint3DMatrix(0.25, -angle);\n\tp = (mat * vec4(p, 1.0)).xyz;\n    return min(air, sdCapsule(p, vec3(0, 0, 0), vec3(0., 1.0, 0), w));\n}\n\nfloat densitycalc(vec3 p){\n    float air = MAX_DIST;\n    float ad = M_PI / 5.0;\n    for(int i = 0; i < 6; i++){\n    \tvec3 q = p;\n    \n    \tq = rotate(q, -RAD90, vec3(1,0,0));\n        q = rotate(q, ad * float(i), vec3(0,1,0));\n    \tq.x += 0.1;\n    \n    \tair = min(air, sdAirLine(q));\n    }\n    \n    return fbm(p * (50,50,15.) *vec3(1,1,1)+ vec3(0, 0, iTime * -15.)) - min(air, 1.) * (20.);\n}\n*/\nfloat densitycalc(vec3 p){\n    //p = rotate(p, 0.45, vec3(0,0,1));\n    //p = rotate(p, M_PI, vec3(0,1,0));\n    p = opRep(p, vec3(0.5,100,100.0));\n    p = rotate(p + vec3(0,0.04,0.2), RAD90, vec3(1,0,0));\n    float d = 10000.;\n    for(int i = 0; i < 5; i++)\n    {\n        float k = fract(float(i) / 5. + iTime * 0.25);\n        vec3 q = p + vec3(0, -2.8*k, -0.1*k);\n        //surface r = sdBoze(p, vec3(1), (sin(iTime * 2.0) * 0.5 + 0.5)*1.5);\n        //surface r = sdBoze(p, vec3(1.2), 1.);\n        //float d = sdCapsule(p, vec3(0,0.01,0.2), vec3(0,0.1,1.0), 0.01, 0.1);\n        //float d = sdTorus(p, vec2(0.2 + sin(iTime) * 0.1, 0.05));\n        float d2 = sdTorus(q, vec2(0.2*k, 0.05*k));\n        //return fbm(p * 25. + iTime * 2.2) - min(d, 1.) * 25.;\n        //return fbm(p * (25. + p.y * 25.) *vec3(1,0.5,1)+ vec3(0, iTime * -5.2, 0)) - min(d, 1.) * (20. - p.y * 20.);\n        //return fbm(p * (25. + p.y * 25.) *vec3(1,0.5,1)+ vec3(0, iTime * -5.2, 0)) - min(d, 1.) * (20. - p.x * 20.);\n        d = min(d, d2);\n    }\n    return fbm(p * (25. + p.z * 25.) * vec3(1,1,0.5)+ vec3(0, 0, iTime * -5.2)) - min(d, 1.) * 25.;\n}\n\n\nsurface rayCast(vec3 pos, vec3 dir, float dist)\n{\n    const vec3 boxPos = vec3(0,0,0);\n    const vec3 boxSize = vec3(100., 0.5, 10.);\n    vec2 sd = GetIntersectBox(pos, dir, boxPos, boxSize);\n    surface result = SURF_NOHIT(MAX_DIST);\n    \n    if((sd.y >= 0.) && (dist > sd.x) && (sd.x < sd.y)) \n    {        \n        const float step = 4.0 / float(MAX_RAYCAST);\n\t\t//const float lightStep = 2.0 / float(MAX_RAYCAST_L);\n        float start = max(0., sd.x) - step;\n        pos = pos + dir * start;\n\n        float t = hash13(pos * 5.5) * 0.001;\n        float alpha = 0.;\n        float transmittance = 1.0;\n        float absorption   = 20.;\n        for(int i = 0; i < MAX_RAYCAST; i++){\n            t += step;\n            \n            vec3 pp = pos + dir * t;\n            if((t >= sd.y)||(start + t >= dist))\n                break;\n            \n            vec3 q = pp - boxPos;\n            \n            float density = densitycalc(q);\n            \n            if(density > 0.0){\n                float dd = density * step;\n                transmittance *= 2. - dd * absorption;\n                if(transmittance < 0.001)\n                    break;\n                alpha += 20. * dd * transmittance;\n\t\t\t\t\n                //result.albedo.rgb += vec3(0.5,0.65,0.85) * (150. * dd * transmittance);\n                //result.emission.rgb += vec3(1,0.3,0.05) * (150. * dd * transmittance);\n                result.emission.rgb += vec3(0.1,0.3,1.0) * (150. * dd * transmittance);\n            }\n        }\n        result.emission.rgb *= max(0., alpha);\n        //result.albedo.a = saturate(alpha);\n        result.dist = alpha > 0. ? t : dist;\n        result.isHit = alpha > 0. ? true : false;\n    }\n\n    return result;\n}\n#endif\n\n#define fog_density(x) (1.0 - saturate(exp2(100.5 - (x) * 3.5)))\n\nsurface traceRay(in vec3 origin, in vec3 direction, float dist, out vec3 pos) {\n    float t = 0.0;\n    \n    pos = origin;\n\n    int count = 0;\n    surface hit;\n    float d;\n    //surface volume = SURF_NOHIT(MAX_DIST); \n    \n    for (int i = 0; i < MAX_MARCH; i++) {\n        hit = map(pos);\n        d = hit.dist;\n        \n        if (d <= EPS || d >= MAX_DIST) {\n        \tbreak;\n        }\n        \n#ifdef ENABLE_GRID_BOUNDARY\n        // grid overshoot check\n        vec2 iBox = GetIntersectBox(pos, direction, floor(pos + 0.5), vec3(0.5));\n        if(iBox.x < iBox.y && iBox.y > 0.0 && iBox.y < d) {\n            d = iBox.y + EPS; \n        }\n#endif        \n\n        t += d;\n                \n        pos = origin + direction * t;\n\n        count++;        \n    }\n\n    hit.dist = t;\n\thit.count = count;\n\n    pos = origin + direction * t;\n    vec3 sky = SkyColor(direction);\n        \n    if(hit.isHit)\n    {\n        vec3 nor = norm(pos);\n\n        //vec3 lightPos;\n\t\t//vec3 lightColor;\n        //fireworkLight(lightPos, lightColor);\n\n#ifdef USE_BRDF_1\n        // BRDF 1\n        // Calc Ambient\n        hit.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, hit);\n#else\n        // BRDF 2\n        //Shade \n        hit.albedo.rgb = shade(pos, nor, -direction, normalize(lightPos), lightColor, hit);\n        // Calc Ambient\n        hit.albedo.rgb += calcAmbient(pos, nor, -direction, hit.dist, vec3(0.5), hit);\n#endif\n        \n#ifdef ENABLE_FOG\n        // Exponential distance fog\n        hit.albedo.rgb = mix(hit.albedo.rgb, sky, fog_density(hit.dist + dist));\n#endif\n    }\n    \n#ifdef USE_RAYCAST\n    // raycast\n    surface volume = rayCast(origin, direction, t);\n\n    if(volume.isHit)\n    {\n        // Calc Ambient\n        //volume.albedo.rgb = calcAmb(pos, direction, nor, lightPos, lightColor, volume);\n        \n        // Exponential distance fog\n        volume.albedo.rgb = mix(volume.albedo.rgb, sky, fog_density(volume.dist + dist));\n        \n        hit.albedo.rgb = mix(hit.albedo.rgb, volume.albedo.rgb, volume.albedo.a);\n\t\thit.albedo.a = max(hit.albedo.a, volume.albedo.a);\n        hit.albedo.rgb = mix(sky, hit.albedo.rgb, hit.albedo.a);\n        \n        // Exponential distance fog\n        volume.emission.rgb = mix(volume.emission.rgb, sky, fog_density(volume.dist + dist));\n        hit.albedo.rgb += volume.emission;\n        //hit.albedo.rgb += volume.albedo.rgb;\n        hit.isHit = volume.isHit;\n    }\n    \n    if(d <= EPS || volume.isHit){\n#else\n    if(d <= EPS){\n#endif\n        hit.isHit = true;\n        return hit;\n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, true);\n    }else{\n\t\t\n        hit.isHit = false;\n        return hit;\n        \n    \t//return surface(hit.dist, hit.albedo, hit.emission, hit.roughness, hit.metalness, count, hit.isTransparent, hit.refractPower, false);\n    }\n}\n\nvec3 render(vec3 p, vec3 ray, vec2 uv)\n{\n    vec3 pos;\n    surface mat = traceRay(p, ray, 0., pos);\n    \n    //pos = p + mat.dist * ray;\n    //return materialize(pos, ray, mat, uv);\n    \n    vec3 col = vec3(0,0,0);\n    vec3 sky = SkyColor(ray);\n    \n    //if (!mat.isHit && mat.albedo.a <= EPS) {\n    if (!mat.isHit) {\n        col = sky;\n    } else \n    {\n        \n        col = mat.albedo.rgb;\n\n#ifdef ENABLE_REFLECTION\n        float metalness = mat.metalness;\n        float dist = mat.dist;\n\n        if(mat.isHit){\n            // reflection\n            for(int i = 0; i < 1; i++)\n            {\n                vec3 nor = norm(pos);\n                nor = normalize(nor + hash33(ray*3823.) * mat.roughness);\n                bool isIncoming = dot(ray, nor) < 0.0;\n                vec3 orientingNormal = isIncoming ? nor : -nor;\n                //orientingNormal = normalize(orientingNormal + hash33(pos) * mat.roughness * 0.05);\n                bool isTotalReflection = false;\n\n                if(mat.isTransparent){\n                    // refract\n                  \t//float nnt = isIncoming ? 1.0 / mat.refractPower : mat.refractPower;\n                    //float nnt = 1.0 / mat.refractPower;\n                    float nnt = isIncoming ? 1.0 / mat.refractPower : 1.0;\n                    ray = refract(ray, orientingNormal, nnt);\n                    pos = pos - orientingNormal * OFFSET;\n                    isTotalReflection = (length(ray) <= 0.9);\n                }\n\n                if(isTotalReflection || !mat.isTransparent)\n                {\n                    // reflect\n                    ray = reflect(ray, orientingNormal);\n                    //ray = normalize(ray + hash33(ray) * mat.roughness * 0.05);\n                    pos = pos + orientingNormal * OFFSET;\n                }\n\n                mat = traceRay(pos, ray, dist, pos);\n\n                dist += mat.dist;\n                \n                pos = pos + mat.dist * ray;\n                \n                col += mat.albedo.rgb * metalness;\n                //col += result;\n                metalness *= mat.metalness;\n\t\t\t\t\n\t\t\t\tif(!mat.isHit || metalness < 0.0001)\n                    break;\n            }\n        }\n#endif\n    }\n    \n    // Glow\n\t//col += (sinebow(iTime * 10.) +vec3(0.1))* pow((mat.z + 10.) / float(MAX_MARCH), 3.5); \n    \n    // Tone mapping\n    col = Tonemap_ACES(col);\n\n\n    // Gamma compression\n    col = OECF_sRGBFast(col);\n    return col;\n    \n}\n/*\nvec3 postEffect(vec3 col, vec2 index)\n{\n    //float shift = rand(index * 82.345);\n    float shift = (index.x + index.y * 3.0) / 9.0;\n    vec3 hsv = rgb2hsv(col);\n    hsv.x += shift + iTime * 0.1;\n    hsv.y = 0.75;\n    //hsv.y *= 2.5;\n    //hsv.y = hsv.y < 0.25 ? 0.25 : hsv.y;\n    //hsv.y = floor(hsv.y * 8.0) / 8.0;\n    //hsv.z = 1.0;\n    //hsv.z = hsv.z < 0.7 ? hsv.z < 0.5 ? 0.0 : 0.5 : hsv.z;\n    hsv.z = floor(hsv.z * 8.0) / 8.0;\n    hsv.z = hsv.z < 0.6 ? 0.0 : hsv.z;\n    \n    hsv.x += hsv.z * 3.0;\n\tcol = hsv2rgb(hsv);\n    //col = floor(col * 8.0) / 8.0;\n\n\treturn col;\n}\n*/\nmat3 camera(vec3 ro, vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    #define ZERO (min(iFrame,0))\n    \n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord+o))/iResolution.y;\n#else\n        vec2 p = (-iResolution.xy + 2.0*fragCoord)/iResolution.y;\n#endif\n        //vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n        //vec2 mouseUV = iMouse.xy / iResolution.xy;\n\n        // init ctrl points\n        ctrlPts.p[0] = vec3(0.5, 0, 0.5)*5.;\n        ctrlPts.p[1] = vec3(0.75, 0.025, 0.1)*5.;\n        ctrlPts.p[2] = vec3(0.75, 0.05, -0.1)*5.;\n        ctrlPts.p[3] = vec3(0.5, 0.025, -0.25)*5.;\n        ctrlPts.p[4] = vec3(-0.5, 0, -0.25)*5.;\n        ctrlPts.p[5] = vec3(-0.75, 0.1, -0.1)*5.;\n        ctrlPts.p[6] = vec3(-0.75, 0.05, 0.1)*5.;\n        ctrlPts.p[7] = vec3(-0.5, 0., 0.25)*5.;\n\n        //vec2 p = (fragCoord.xy) / min(iResolution.x, iResolution.y);\n        //vec2 p = (fragCoord.xy) / iResolution.xy;\n\n        //vec2 idx = floor(p*3.0);\n        //p = fract(p*3.0) - 0.5;\n        //p.x *= max(iResolution.x, iResolution.y)/min(iResolution.x, iResolution.y);\n\n        float t = iTime * M_PI2 * -0.05;\n        //float t = iTime * -1.0;\n        //float t = 0.;\n        //float y = sin(t * 2.5) * 0.125-0.0;\n        //float y = sin(t * 5.) * 0.1 + 0.5;\n        float y = 1.5;\n        //float r = 1.5 + sin(t * 2.5);\n        float r = 5.0;\n        //float distortionPower = sin(iTime * 0.2 * M_PI2) * 0.5 + 0.5;\n        //float distortionPower = sin(iTime * 0.05 * M_PI2);\n        float theta = t + RAD90 + RAD90*0.25;\n        //float theta = RAD90 + RAD90*0.25;\n        //float theta = 0.;\n        //float theta = M_PI - RAD90*0.25;\n        //float theta = t + RAD90;\n        //float theta = RAD90 + noise(vec2(p.x * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n        //float theta = RAD90;\n        //float theta = t + RAD90 + (mouseUV.x) * M_PI2;\n        //float theta = M_PI + RAD90 + (mouseUV.x) * M_PI2;\n        //float phi   = noise(vec2(p.y * 3., iTime * 0.1 * M_PI)) * RAD90 * distortionPower;\n        float phi   = sin(t*3.);\n        //float phi   = 0.;\n        //float phi   = RAD90*0.5;\n        //float phi   = (mouseUV.y) * RAD90;\n        //float phi   = (mouseUV.y) * RAD90;\n        //vec3 ro = vec3( 0., 0.05, -0.75 );\n#ifdef COURCE_CAMERA\n        t = iTime * CAMERA_SPEED;\n        vec3 ro = catmullRom(fract(t), ctrlPts) + vec3(0,0.2,0);\n        vec3 ta = catmullRom(fract(t+0.05), ctrlPts) + vec3(0,0.1,0);\n#else\n        vec3 ro = vec3(cos(theta) * r, y + sin(phi)*0.5, -sin(theta) * r);\n        //vec3 ro = vec3(cos(theta) * r + t, y, -sin(theta) * r);\n        vec3 ta = vec3(0., 0., 0);\n        //vec3 ta = vec3(0. + t, -0.5, 0.);\n#endif\n\n        mat3 c = camera(ro, ta, 0.0);\n        vec3 ray = c * normalize(vec3(p, 1.5));\n        vec3 col = render(ro, ray, fragCoord.xy);\n    \n         tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    //col = postEffect(col, idx);\n    \n    fragColor = vec4(tot,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyyRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1132, 1377, 1400, 1400, 1473], [3329, 3432, 3477, 3477, 3676], [3976, 4250, 4291, 4291, 4728], [4730, 4730, 4777, 4777, 5636], [5638, 5638, 5717, 5839, 5984], [5986, 5986, 6050, 6050, 7635], [8205, 8281, 8303, 8303, 8634], [8637, 8825, 8848, 8848, 8933], [8935, 8954, 8976, 8976, 9093], [9095, 9114, 9137, 9137, 9240], [9242, 9262, 9283, 9283, 9417], [9419, 9438, 9460, 9460, 9593], [9595, 9615, 9637, 9637, 9762], [9764, 9764, 9801, 9866, 10084], [10086, 10086, 10132, 10197, 10638], [10640, 10640, 10661, 10661, 10731], [10733, 10733, 10756, 10756, 10835], [10838, 10838, 10860, 10860, 11277], [11388, 11388, 11409, 11409, 11550], [11552, 11552, 11582, 11582, 11712], [11714, 11714, 11775, 11775, 11913], [11915, 11915, 11941, 11941, 12250], [12252, 12312, 12338, 12338, 13204], [13206, 13286, 13327, 13327, 13498], [13500, 13500, 13557, 13557, 13692], [13694, 13794, 13830, 13830, 13858], [13860, 13860, 13906, 13906, 13962], [13964, 13964, 13995, 13995, 14086], [14088, 14088, 14138, 14138, 14256], [14258, 14258, 14319, 14319, 14450], [14452, 14452, 14489, 14489, 14578], [14580, 14580, 14650, 14650, 14784], [14786, 14786, 14850, 14850, 14967], [14969, 14969, 15021, 15021, 15128], [15130, 15130, 15163, 15189, 15220], [15222, 15222, 15247, 15247, 15266], [15267, 15267, 15292, 15292, 15311], [15312, 15312, 15348, 15348, 15376], [15378, 15378, 15437, 15437, 15750], [15752, 15752, 15785, 15785, 15850], [15852, 15876, 15928, 15928, 16047], [16049, 16159, 16191, 16191, 16285], [16287, 16287, 16321, 16321, 16472], [16474, 16474, 16508, 16508, 16656], [16658, 16658, 16692, 16692, 16827], [16829, 16829, 16857, 16857, 16942], [16943, 17001, 17072, 17072, 17400], [17402, 17402, 17484, 17484, 17852], [17854, 17939, 17983, 17983, 18207], [18209, 18266, 18303, 18344, 18427], [18429, 18429, 18468, 18640, 18749], [18751, 18751, 18800, 18800, 19359], [19361, 19361, 19400, 19446, 19531], [19533, 19533, 19574, 19684, 19798], [19813, 19864, 19901, 19901, 19923], [19925, 19925, 19968, 19968, 19990], [19992, 19992, 20036, 20036, 20057], [20059, 20059, 20102, 20102, 20201], [20204, 20204, 20249, 20249, 20678], [20680, 20680, 20701, 20701, 20765], [20767, 20767, 20818, 20818, 21070], [21072, 21072, 21096, 21096, 21138], [21142, 21142, 21176, 21176, 21491], [21493, 21493, 21561, 21561, 21813], [21815, 21815, 21855, 21855, 21980], [21983, 21983, 22018, 22018, 22166], [22168, 22168, 22202, 22202, 22378], [22380, 22380, 22415, 22415, 22450], [22452, 22452, 22489, 22489, 22524], [22526, 22697, 22782, 22782, 22859], [22861, 22904, 22979, 22979, 23398], [23400, 23978, 24062, 24062, 24405], [24407, 24413, 24465, 24465, 24621], [24623, 24623, 24683, 24683, 24724], [24726, 24941, 24972, 24972, 25021], [25023, 25023, 25050, 25050, 25088], [25090, 25090, 25119, 25119, 25157], [25159, 25159, 25186, 25186, 25235], [25238, 25467, 25488, 25488, 25627], [25653, 25653, 25685, 25685, 25798], [25800, 25800, 25832, 25832, 25972], [25974, 25974, 26007, 26007, 26239], [26240, 26240, 26279, 26312, 26504], [26506, 26506, 26529, 26529, 27108], [27110, 27110, 27135, 27135, 27296], [27298, 27298, 27341, 27341, 28355], [28356, 29057, 29117, 29117, 30161], [30368, 36713, 36760, 36760, 37780], [37781, 37999, 38043, 38043, 38524], [38544, 38544, 38565, 38565, 40424], [43198, 43552, 43588, 43588, 43921], [44187, 44255, 44283, 44283, 44410], [44412, 44502, 44565, 44565, 44771], [44773, 44839, 44903, 45073, 45704], [45705, 45839, 45865, 45865, 47918], [55836, 56038, 56071, 56127, 56313], [56315, 56315, 56354, 56354, 56397]]}
{"id": "WsyyRV", "name": "Shader#1 dark liquid", "author": "chepuha", "description": "shader#1", "tags": ["dark"], "likes": 3, "viewed": 67, "published": "Public", "date": "1603577312", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat l;\n    vec2 uv;\n    vec2 p = fragCoord.xy/iResolution.xy;\n    uv=p;\n    p+=5.;\n    l=length(uv);\n    uv+=p*(sin(iTime/5.0))*abs(sin(l * 20.));\n    vec3 color=vec3(0.02/length(mod(uv,1.)-.5));\n\t\n\tfragColor=vec4(color,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyyRV.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 287]]}
{"id": "wsyyRw", "name": "Fab12 #inktober2020 \"slippery\"", "author": "FabriceNeyret2", "description": "[url]https://inktober.com/[/url]\n#inktober2020 themes: [img]https://i.imgur.com/b3gMiu0.png[/img]", "tags": ["short", "golf", "inktober2020"], "likes": 16, "viewed": 262, "published": "Public API", "date": "1602442432", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define rot(a)     mat2( cos(a+vec4(0,11,33,0)) )                    // rotation                  \n#define S(v)       smoothstep( 2.,-2., R.y*(v) )                     // AA\n#define B(U,L,l)   t = min( t, max( abs((U).x)-L , abs((U).y)-l ) ), // box\n\nvoid mainImage(out vec4 O, vec2 u) {   \n    vec2  R = iResolution.xy,\n          U = .9*( u+u - R ) / R.y;\n    U.y += .3;\n    float t = 6.283/6., T = 8.*iTime,\n          d = length(U)*cos( mod( atan(U.x,U.y),  t+t ) -t );  // --- red triangle\n    O = mix( vec4(d<.5), vec4(1,0,0,1), S( abs(d-.5) - .1 ) );\n    \n    if ( abs(U.y+.2) < .2)                                     // --- S\n        d = U.x -.15*cos(18.*U.y+T) -.15-.5*U.y,\n        O -=   S(  abs(d+.3 ) +.3*U.y )\n             + S(  abs(d+U.y) +.3*U.y );\n    \n    U -= vec2( .15*cos(T), .1 );                              // --- car\n    U *= rot(.2*sin(T) );\n    U.x = abs(U.x);\n    B(U,.18,.06)                                              // body\n    B(U - vec2(.13,-.06), .02,.05 )                           // wheels\n    B(U - vec2(  0 ,.15), .12,.015)                           // roof\n    U *= rot(.3); B(U - vec2(.15,.06), .015,.06 )             // window sides\n    O -= S(t);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyyRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[251, 251, 287, 287, 1193]]}
{"id": "wsyyWw", "name": "Rounded Box - intersection (Fix)", "author": "xjorma", "description": "Modified https://www.shadertoy.com/view/WlSXRW to support bigger radius.\nI will use it in an upcoming shader.\nI wanted to have a cube to morph in a sphere in raytracing, I wasn't able to it with the unmodified code :(\nYou can use the mouse to compare.", "tags": ["3d", "intersection", "fixed", "roundedcube"], "likes": 9, "viewed": 246, "published": "Public API", "date": "1602954440", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Little Modification by David Gallardo / Xjorma 2020   (MIT License)\n\n\n// The MIT License\n// Copyright © 2019 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// Intersection of a ray with a rounded box, testing a single\n// corner (sphere) instead of 8, and only 3 edges (cylinders)\n// instead of 12. There might be a more compact and efficient\n// way to do it, but this is where I landed. However the code\n// to compute the surface normal is particularly elegant.\n//\n// It only works if the corner spheres don't overlap, ie, if\n// the raius is smaller than half the size of the base box.\n\n// Other intersectors: http://iquilezles.org/www/articles/intersectors/intersectors.htm\n//\n// Box:             https://www.shadertoy.com/view/ld23DV\n// Triangle:        https://www.shadertoy.com/view/MlGcDz\n// Capsule:         https://www.shadertoy.com/view/Xt3SzX\n// Ellipsoid:       https://www.shadertoy.com/view/MlsSzn\n// Sphere:          https://www.shadertoy.com/view/4d2XWV\n// Capped Cylinder: https://www.shadertoy.com/view/4lcSRn\n// Disk:            https://www.shadertoy.com/view/lsfGDB\n// Capped Cone:     https://www.shadertoy.com/view/llcfRf\n// Rounded Box:     https://www.shadertoy.com/view/WlSXRW\n// Rounded Cone:    https://www.shadertoy.com/view/MlKfzm\n// Torus:           https://www.shadertoy.com/view/4sBGDy\n// Sphere4:         https://www.shadertoy.com/view/3tj3DW\n// Goursat:         https://www.shadertoy.com/view/3lj3DW\n// Hexagonal Prism: https://www.shadertoy.com/view/tljBWy\n\n\n#define AA 2  // reduce this to 1 if you have a slow machine\n\n// intersect capsule : http://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat capIntersect( in vec3 ro, in vec3 rd, in vec3 pa, in vec3 pb, in float r )\n{\n    vec3  ba = pb - pa;\n    vec3  oa = ro - pa;\n\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n\n    float a = baba      - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - r*r*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b-sqrt(h))/a;\n\n        float y = baoa + t*bard;\n        \n        // body\n        if( y>0.0 && y<baba ) return t;\n\n        // caps\n        vec3 oc = (y<=0.0) ? oa : ro - pb;\n        b = dot(rd,oc);\n        c = dot(oc,oc) - r*r;\n        h = b*b - c;\n        if( h>0.0 )\n        {\n            return -b - sqrt(h);\n        }\n    }\n    return -1.;\n}\n\n// intersect a ray with a rounded box\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\n// Modified to support bigger radius, probably more optimal solution, but was too lazy nor as good as IQ :(\n// I kept the -1 for no collision paradigm even if I hate it (Make the code more complex), but I prefered to stay compatible with IQ interface.\nfloat roundedboxIntersect2( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n    \n\t// bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    float t = tN;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;\n  \n  \t// fat edges\n    float d;\n    d = capIntersect(ro, rd, size * vec3(-1, 1, 1), size, rad);\n    t = d > 0. ? d : 1e20;\n    d = capIntersect(ro, rd, size * vec3( 1,-1, 1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n    d = capIntersect(ro, rd, size * vec3( 1, 1,-1), size, rad);\n    t = min(d > 0. ? d : 1e20, t);    \n\n    if( t>1e19 ) t=-1.0;\n    \n\treturn t;\n}\n\n\n\n// intersect a ray with a rounded box\n// http://iquilezles.org/www/articles/intersectors/intersectors.htm\nfloat roundedboxIntersect( in vec3 ro, in vec3 rd, in vec3 size, in float rad )\n{\n\t// bounding box\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*(size+rad);\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0) return -1.0;\n    float t = tN;\n\n    // convert to first octant\n    vec3 pos = ro+t*rd;\n    vec3 s = sign(pos);\n    ro  *= s;\n    rd  *= s;\n    pos *= s;\n        \n    // faces\n    pos -= size;\n    pos = max( pos.xyz, pos.yzx );\n    if( min(min(pos.x,pos.y),pos.z)<0.0 ) return t;\n\n    // some precomputation\n    vec3 oc = ro - size;\n    vec3 dd = rd*rd;\n\tvec3 oo = oc*oc;\n    vec3 od = oc*rd;\n    float ra2 = rad*rad;\n\n    t = 1e20;        \n\n    // corner\n    {\n    float b = od.x + od.y + od.z;\n\tfloat c = oo.x + oo.y + oo.z - ra2;\n\tfloat h = b*b - c;\n\tif( h>0.0 ) t = -b-sqrt(h);\n    }\n\n    // edge X\n    {\n\tfloat a = dd.y + dd.z;\n\tfloat b = od.y + od.z;\n\tfloat c = oo.y + oo.z - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.x+rd.x*h)<size.x ) t = h;\n    }\n\t}\n    // edge Y\n    {\n\tfloat a = dd.z + dd.x;\n\tfloat b = od.z + od.x;\n\tfloat c = oo.z + oo.x - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.y+rd.y*h)<size.y ) t = h;\n    }\n\t}\n    // edge Z\n    {\n\tfloat a = dd.x + dd.y;\n\tfloat b = od.x + od.y;\n\tfloat c = oo.x + oo.y - ra2;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n    {\n\t  h = (-b-sqrt(h))/a;\n      if( h>0.0 && h<t && abs(ro.z+rd.z*h)<size.z ) t = h;\n    }\n\t}\n\n    if( t>1e19 ) t=-1.0;\n    \n\treturn t;\n}\n\n// normal of a rounded box\nvec3 roundedboxNormal( in vec3 pos, in vec3 siz, in float rad )\n{\n    return sign(pos)*normalize(max(abs(pos)-siz,0.0));\n}\n\n\n//======================================================\n\n\n\n\n// rotation matrix\nmat4 rotate( vec3 v, float angle )\n{\n    float s = sin( angle );\n    float c = cos( angle );\n    float ic = 1.0 - c;\n\n    return mat4( v.x*v.x*ic + c,     v.y*v.x*ic - s*v.z, v.z*v.x*ic + s*v.y, 0.0,\n                 v.x*v.y*ic + s*v.z, v.y*v.y*ic + c,     v.z*v.y*ic - s*v.x, 0.0,\n                 v.x*v.z*ic - s*v.y, v.y*v.z*ic + s*v.x, v.z*v.z*ic + c,     0.0,\n\t\t\t     0.0,                0.0,                0.0,                1.0 );\n}\n\n// transform points and vectors\nvec3 ptransform( in mat4 mat, in vec3 v ) { return (mat*vec4(v,1.0)).xyz; }\nvec3 ntransform( in mat4 mat, in vec3 v ) { return (mat*vec4(v,0.0)).xyz; }\n\n// texture sampling\nvec4 boxmap( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = n*n; m=m*m; m=m*m;\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn (x*m.x + y*m.y + z*m.z)/(m.x+m.y+m.z);\n}\n\n//======================================================\n\n// putting these in a \"box\" struct leads to precision problems\n// on Android... :(\nmat4  box_world_to_obj;\nmat4  box_obj_to_world;\nvec3  box_size;\nfloat box_radius;\nbool  side;\n\nvec2 intersect( in vec3 ro, in vec3 rd )\n{\n    vec2 res = vec2(1e20,-1.0);\n    \n    // plane\n    {\n        float t = (-1.0-ro.y)/rd.y;\n        if( t>0.0 ) res = vec2(t,1.0);\n    }\n\n    // rounded box\n    {\n        // convert ray from world to box space\n        vec3 rdd = ntransform(box_world_to_obj, rd );\n        vec3 roo = ptransform(box_world_to_obj, ro );\n        // intersect in box space\n        float t;\n        if(side)\n        {\n        \tt = roundedboxIntersect(roo,rdd,box_size,box_radius);\n        }\n        else\n        {\n        \tt = roundedboxIntersect2(roo,rdd,box_size,box_radius);\n        }\n        if( t>0.0 && t<res.x ) res = vec2(t,2.0);\n    }\n    \n    return res;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // camera movement\t\n    float an = 0.15*(iTime-10.0);\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ro = ta + vec3( 2.0*cos(an), 0.2, 2.0*sin(an) );\n    // camera matrix\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.6,8.0,0.0) ) );\n    vec3 vv =          ( cross(uu,ww));\n\n    // rounded box animation\n    box_obj_to_world = \n                       rotate( normalize(vec3(1.0,1.0,0.1)), iTime ); \n    box_world_to_obj = inverse( box_obj_to_world );\n    box_size = vec3((-cos(iTime) + 1.) * 0.5) * 0.75;\n    box_radius = (cos(iTime) + 1.) * 0.5 *.75;\n    side = fragCoord.x < iMouse.x;\n\n    // render\n    vec3 tot = vec3(0.0);\n    \n    #if AA>1\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n        #else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n        #endif\n    \n\t    // create view ray\n        vec3 rd = normalize( p.x*uu + p.y*vv + 1.6*ww );\n\n        // sky\n        vec3 col = vec3(0.6,0.75,0.85) - 0.97*rd.y;\n\n        // raymarch geometry\n        vec2 tm = intersect( ro, rd );\n        if( tm.y>0.0 )\n        {\n            // shading\n            vec3 pos = ro + tm.x*rd;\n            vec3 nor;\n            vec3 mate;\n            \n            if( tm.y<1.5 ) // floor\n            {\n                nor = vec3(0.0,1.0,0.0);\n                mate = 0.35*texture( iChannel0, 0.2*pos.xz ).xyz;\n            }\n            else // rounded box\n            {\n                // convert position from world to box space\n                vec3 bpos = ptransform(box_world_to_obj,pos);\n                // compute normal in box space\n                vec3 bnor = roundedboxNormal(bpos,box_size,box_radius);\n                // convert normal from box to world space\n                nor = ntransform(box_obj_to_world,bnor);\n                // sample texture\n                mate = 0.35*boxmap( iChannel0, bpos, bnor ).xyz;\n            }\n            \n            // lighting\n            vec3  lig = normalize(vec3(0.8,0.4,-0.6));\n            float dif = clamp( dot(nor,lig), 0.0, 1.0 );\n            vec3  hal = normalize(lig-rd);\n            float sha = step( intersect( pos+0.01*nor, lig ).y, 0.0 );\n            float amb = 0.6 + 0.4*nor.y;\n            float bou = clamp(0.3-0.7*nor.y,0.0,1.0);\n            float spe = clamp(dot(nor,hal),0.0,1.0);\n            col  = 4.0*vec3(1.00,0.80,0.60)*dif*sha;\n            col += 2.0*vec3(0.20,0.30,0.40)*amb;\n            col += 2.0*vec3(0.30,0.20,0.10)*bou;\n\t\t\tcol *= mate;            \n            col += 0.3*pow(spe,8.0)*dif*sha*(0.04+0.96*pow(clamp(dot(lig,hal),0.0,1.0),5.0));\n            col = mix( col, vec3(0.6,0.7,0.8), 1.0-exp(-0.001*tm.x*tm.x) );           \n        }\n        \n        // vignetting        \n        col *= 1.0 - 0.1*dot(p,p);\n\n\t    tot += col;\n    #if AA>1\n    }\n    tot /= float(AA*AA);\n    #endif\n\n    // gamma\n    tot = pow( tot, vec3(0.45) );\n    \n\t// grading\n    tot = clamp(tot,0.0,1.0);\n    tot = tot*tot*(3.0-2.0*tot);\n    \n    tot = mix(tot, vec3(1,0,0),max(0.,1. - abs(iMouse.x - fragCoord.x) / 2.));\n\n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [{"id": "4df3Rr", "previewfilepath": "/media/ap/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3871e838723dd6b166e490664eead8ec60aedd6b8d95bc8e2fe3f882f0fd90f0.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyyWw.jpg", "access": "shaders20k", "license": "mit", "functions": [[2548, 2640, 2722, 2722, 3452], [3454, 3812, 3894, 3916, 4798], [4802, 4908, 4989, 5006, 6558], [6560, 6587, 6652, 6652, 6709], [6773, 6792, 6828, 6828, 7232], [7234, 7266, 7309, 7309, 7341], [7342, 7342, 7385, 7385, 7417], [7419, 7439, 7491, 7491, 7668], [7728, 7906, 7948, 7948, 8593], [8595, 8595, 8652, 8676, 11886]]}
{"id": "wtlfR7", "name": "sky_model", "author": "myrkott", "description": "Basic sky shader that simulates atmospheric scattering with raymarching.", "tags": ["procedural", "sky"], "likes": 10, "viewed": 169, "published": "Public", "date": "1603659222", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Basic procedural sky shader that simulates atmospheric scattering (Mie and Rayleigh) with\n// raymarching. The implementation largely follows the approach of the Scratchapixel tutorial\n// https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/\n// simulating-colors-of-the-sky and was written with accuracy in mind, not speed. Multiple\n// scattering is not taken into account.\n//\n// SPP can be increased to, e.g, 4 or 8 to produce anti-aliasing. Increasing the\n// NUM_PRIMARY_STEPS and/or NUM_SECONDARY_STEPS of the raymarcher will make the rendering more\n// accurate but also slower. There are some other options and parameters that can be tweaked as\n// well :)\n//\n// Author: Johan Nysjö\n\n#define SPP 1\n#define NUM_PRIMARY_STEPS 30\n#define NUM_SECONDARY_STEPS 10\n#define RAYLEIGH_SCATTERING_ENABLED 1\n#define MIE_SCATTERING_ENABLED 1\n#define EQUIRECTANGULAR_VIEW_ENABLED 0\n#define ANIMATION_ENABLED 1\n#define EXPOSURE 1.0\n#define SUN_DIRECTION vec3(0.0, -1.0, 10.0)\n#define SUN_INTENSITY 2.0\n#define DISPLAY_SUN 0\n\n#define PI 3.141592\n\nstruct Ray {\n\tvec3 origin;\n    vec3 direction;\n    float t_min;\n    float t_max;\n};\n\nstruct HitInfo {\n\tfloat t_min;\n    float t_max;\n};\n\nstruct Camera {\n\tvec3 eye;\n    vec3 center;\n    vec3 up;\n    float fovy;\n    float aspect;\n};\n\nvoid generate_ray(Camera camera, vec2 uv, out Ray ray)\n{\n\tvec3 f = normalize(camera.center - camera.eye);\n    vec3 s = cross(f, normalize(camera.up));\n    vec3 u = cross(s, f);\n    \n    float half_width = tan(0.5 * camera.fovy);\n    float half_height = camera.aspect * half_width;\n    float x = 2.0 * uv.x - 1.0;\n    float y = 2.0 * uv.y - 1.0;\n    \n    ray.origin = camera.eye;\n    ray.direction = normalize(f + x * half_width * s + y * half_height * u);\n}\n\n// Converts a 2D equirectangular texture coordinate to a 3D ray direction, which is stored in\n// the output ray along with the origin.\nvoid generate_ray_equirect(vec3 origin, vec2 uv, out Ray ray)\n{\n    uv = clamp(uv, 0.0, 1.0);\n\n    float theta = PI * (2.0 * uv.s - 1.0);\n    float phi = PI * (uv.t - 0.5);\n    float x = cos(phi) * sin(theta);\n    float y = sin(phi);\n    float z = cos(phi) * cos(theta);\n\n    ray.origin = origin;\n    ray.direction = normalize(vec3(x, y, z));\n}\n\n// R2 low-discrepancy sequence\n// Reference: http://extremelearning.com.au/unreasonable-effectiveness-of-quasirandom-sequences/\nvec2 ldseq_r2(float index)\n{\n    float phi = 1.324717957;\n    return fract(vec2(index / phi, index / (phi * phi)));\n}\n\nfloat hash2d(vec2 x)\n{\n    return fract(sin(dot(x, vec2(12.9898, 78.2331))) * 43758.5453);\n}\n\nstruct SkyParams {\n    vec3 earth_center;\n\tfloat earth_radius_km;\n    float atmosphere_radius_km;\n    vec3 mie_scattering;\n    vec3 rayleigh_scattering;\n    float mie_scale_height_km;\n    float rayleigh_scale_height_km;\n    float mie_phase_g;\n    vec3 sun_direction;\n    vec3 sun_intensity;\n    float sun_size_rad;\n};\n\n// Ray-sphere intersection test that finds the distance to the closest (t_min) and farthest\n// (t_max) intersection points between a ray and a solid sphere. Returns true if the ray hits\n// the sphere and false otherwise.\nbool sphere_hit(vec3 sphere_center, float sphere_radius, Ray ray, out HitInfo hit_info)\n{\n    vec3 oc = ray.origin - sphere_center;\n    float a = dot(ray.direction, ray.direction);\n    float b = dot(oc, ray.direction);\n    float c = dot(oc, oc) - sphere_radius * sphere_radius;\n    \n    float discriminant = b * b - a * c;\n    if (discriminant > 0.0) {\n\t\thit_info.t_min = max(ray.t_min, (-b - sqrt(discriminant)) / a);\n        hit_info.t_max = (-b + sqrt(discriminant)) / a;\n        return hit_info.t_max > ray.t_min && hit_info.t_max < ray.t_max;\n    }\n\n    return false;\n}\n\nfloat rayleigh_phase_function(float cos_theta)\n{\n\treturn 0.75 * (1.0 + cos_theta * cos_theta);\n}\n\nfloat mie_phase_function(float cos_theta, float g)\n{\n    float g2 = g * g;\n\treturn 1.5 * ((1.0 - g2) * (1.0 + cos_theta * cos_theta)) /\n        ((2.0 + g2) * pow(1.0 + g2 - 2.0 * g * cos_theta, 1.5));\n}\n\nvec3 beer_lambert(vec3 sigma_t, float path_length_km)\n{\n    return exp(-sigma_t * path_length_km);\n}\n\n// NOTE: visibility is the same as transmittance in this case\nvec3 raymarch_visibility(vec3 world_pos, int num_steps, SkyParams sky_params)\n{\n\tRay world_ray;\n    world_ray.origin = world_pos;\n    world_ray.direction = -sky_params.sun_direction;\n    world_ray.t_min = 1e-3;\n    world_ray.t_max = 1e6;\n    \n    vec3 visibility = vec3(1.0, 1.0, 1.0);\n    HitInfo hit_info;\n    if (sphere_hit(sky_params.earth_center, sky_params.earth_radius_km, world_ray, hit_info)) {\n        visibility = vec3(0.0, 0.0, 0.0);\n    }\n    else if (sphere_hit(sky_params.earth_center, sky_params.atmosphere_radius_km, world_ray,\n                        hit_info)) {\n        world_ray.t_min = hit_info.t_min;\n        world_ray.t_max = hit_info.t_max;\n\n        float path_length_km = world_ray.t_max - world_ray.t_min;\n        float step_length_km = path_length_km / float(num_steps);\n\n        float t = world_ray.t_min;\n        while (t < world_ray.t_max) {\n            vec3 sample_pos = world_ray.origin + (t + 0.5 * step_length_km) * world_ray.direction;\n            float height_km = max(0.0, length(sample_pos - sky_params.earth_center) -\n                                  sky_params.earth_radius_km);\n\n#if RAYLEIGH_SCATTERING_ENABLED\n            float rayleigh_scaling = exp(-height_km / sky_params.rayleigh_scale_height_km);\n            visibility *= beer_lambert(sky_params.rayleigh_scattering * rayleigh_scaling,\n                                       step_length_km);\n#endif\n\n#if MIE_SCATTERING_ENABLED            \n            float mie_scaling = exp(-height_km / sky_params.mie_scale_height_km);\n            visibility *= beer_lambert(sky_params.mie_scattering * mie_scaling,\n                                       step_length_km);\n#endif\n\n            t += step_length_km;\n        }\n    }\n    \n    return visibility;\n}\n\nvoid raymarch(Ray world_ray, int num_primary_steps, int num_secondary_steps, SkyParams sky_params,\n              out vec3 transmittance, out vec3 luminance)\n{\n    float path_length_km = world_ray.t_max - world_ray.t_min;\n    float step_length_km = path_length_km / float(num_primary_steps);\n\n    transmittance = vec3(1.0, 1.0, 1.0);\n    luminance = vec3(0.0, 0.0, 0.0);\n    float t = world_ray.t_min;\n    while (t < world_ray.t_max) {\n        vec3 sample_pos = world_ray.origin + (t + 0.5 * step_length_km) * world_ray.direction;\n        float height_km = max(0.0, length(sample_pos - sky_params.earth_center) -\n                              sky_params.earth_radius_km);\n\n        vec3 visibility = raymarch_visibility(sample_pos, num_secondary_steps, sky_params);\n        float cos_theta = dot(sky_params.sun_direction, -world_ray.direction);\n\n#if RAYLEIGH_SCATTERING_ENABLED\n        float rayleigh_scaling = exp(-height_km / sky_params.rayleigh_scale_height_km);        \n        transmittance *= beer_lambert(sky_params.rayleigh_scattering * rayleigh_scaling,\n                                      step_length_km);\n#endif\n\n#if MIE_SCATTERING_ENABLED\n        float mie_scaling = exp(-height_km / sky_params.mie_scale_height_km);        \n        transmittance *= beer_lambert(sky_params.mie_scattering * mie_scaling,\n                                      step_length_km);\n#endif\n\n#if RAYLEIGH_SCATTERING_ENABLED\n        luminance += transmittance * sky_params.rayleigh_scattering * rayleigh_scaling *\n            visibility * rayleigh_phase_function(cos_theta) * sky_params.sun_intensity *\n            step_length_km;\n#endif        \n\n#if MIE_SCATTERING_ENABLED        \n        luminance += transmittance * sky_params.mie_scattering * mie_scaling *\n            visibility * mie_phase_function(cos_theta, sky_params.mie_phase_g) *\n            sky_params.sun_intensity * step_length_km;\n#endif\n\n        t += step_length_km;\n    }\n}\n\nvec3 tonemap_aces(vec3 x)\n{\n    float a = 2.51;\n    float b = 0.03;\n    float c = 2.43;\n    float d = 0.59;\n    float e = 0.14;\n\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);   \n}\n\nvec3 lin2srgb(vec3 color)\n{\n \treturn pow(color, vec3(0.454));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // NOTE: the Mie and Rayleigh scattering parameter values used here are based on the values\n    // used by Bruneton and Neyret in the paper Precomputed Atmospheric Scattering, EGSR, 2008\n    SkyParams sky_params;\n    sky_params.earth_center = vec3(0.0, 0.0, 0.0);\n    sky_params.earth_radius_km = 6360.0;\n    sky_params.atmosphere_radius_km = 6420.0;\n    sky_params.mie_scattering = vec3(3.0e-3);\n    sky_params.rayleigh_scattering = vec3(4.8e-3, 1.35e-2, 3.31e-2);\n    sky_params.mie_scale_height_km = 1.2;\n    sky_params.rayleigh_scale_height_km = 8.0;\n    sky_params.mie_phase_g = 0.76;\n    sky_params.sun_direction = normalize(SUN_DIRECTION);\n    sky_params.sun_intensity = vec3(SUN_INTENSITY);\n    sky_params.sun_size_rad = radians(0.5334);\n\n    Camera camera;\n#if 1 // view the atmosphere from earth\n    float height = ANIMATION_ENABLED != 0 ? mod(2.0 * iTime, 20.0) + 0.1 : 0.1;\n    camera.eye = vec3(0.0, sky_params.earth_radius_km + height, 0.0);\n    camera.center = vec3(0.0, sky_params.earth_radius_km + height, -1.0);\n    camera.up = vec3(0.0, 1.0, 0.0);\n    camera.fovy = radians(125.0);\n#else // view the atmosphere from outer space!\n    camera.eye = vec3(0.0, 0.0, 4.0 * sky_params.earth_radius_km);\n    camera.center = vec3(0.0, 0.0, 0.0);\n    camera.up = vec3(0.0, 1.0, 0.0);\n    camera.fovy = radians(60.0);\n#endif\n    camera.aspect = iResolution.y / iResolution.x;\n\n    vec2 rnd = vec2(hash2d(uv), hash2d(uv + 0.1));\n\n   \tvec3 output_color = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < SPP; ++i) {\n        int sample_idx = (SPP * iFrame + i) % 1000;\n        vec2 aa_offset = fract(ldseq_r2(float(sample_idx)) + rnd) / iResolution.xy;\n        \n    \tRay world_ray;\n#if EQUIRECTANGULAR_VIEW_ENABLED\n        generate_ray_equirect(camera.eye, uv + aa_offset, world_ray);\n#else\n        generate_ray(camera, uv + aa_offset, world_ray);\n#endif\n    \tworld_ray.t_min = 1e-3;\n    \tworld_ray.t_max = 1e6;\n\n    \tHitInfo hit_info;\n    \tif (sphere_hit(sky_params.earth_center, sky_params.atmosphere_radius_km, world_ray,\n                       hit_info)) {\n        \tworld_ray.t_min = hit_info.t_min;\n        \tworld_ray.t_max = hit_info.t_max;\n \n            // Check if the ray intersects the earth surface and clamp t_max to the intersection\n            // point if that is the case (no need to raymarch beneath the surface, won't reach\n            // any sunlight there...)\n            bool earth_hit = sphere_hit(sky_params.earth_center, sky_params.earth_radius_km,\n                                        world_ray, hit_info);\n            world_ray.t_max = earth_hit ? max(hit_info.t_min, world_ray.t_min) : world_ray.t_max;\n\n            // Calculate athmospheric scattering with raymarching\n            vec3 transmittance = vec3(1.0, 1.0, 1.0);\n            vec3 luminance = vec3(0.0, 0.0, 0.0);\n        \traymarch(world_ray, NUM_PRIMARY_STEPS, NUM_SECONDARY_STEPS, sky_params,\n                     transmittance, luminance);\n            output_color += luminance;\n            \n#if DISPLAY_SUN\n            // Display the sun as a disk with the specified angular diameter (radians), taking\n            // occlusion from the earth into account. Here we don't need to perform an actual\n            // disk intersection test but can just check the angle between the primary ray\n            // direction and the outgoing sun direction, which is cheaper and simpler :)\n            float sun_cos_theta = dot(sky_params.sun_direction, -world_ray.direction);\n    \t\tif (!earth_hit && sun_cos_theta >= cos(0.5 * sky_params.sun_size_rad)) {\n    \t\t\toutput_color += transmittance * sky_params.sun_intensity;   \n    \t\t}\n#endif\n    \t}\n    }\n    output_color /= float(SPP);\n    \n    output_color *= EXPOSURE;\n    output_color = tonemap_aces(output_color);\n    output_color = lin2srgb(output_color);\n\n    fragColor = vec4(output_color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wtlfR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 1306, 1362, 1362, 1763], [1765, 1900, 1963, 1963, 2244], [2246, 2374, 2402, 2402, 2491], [2493, 2493, 2515, 2515, 2585], [2906, 3127, 3216, 3216, 3701], [3703, 3703, 3751, 3751, 3799], [3801, 3801, 3853, 3853, 4003], [4005, 4005, 4060, 4060, 4105], [4107, 4169, 4248, 4248, 5912], [5914, 5914, 6072, 6072, 7841], [7843, 7843, 7870, 7870, 8047], [8049, 8049, 8076, 8076, 8112], [8114, 8114, 8169, 8169, 12053]]}
