{"id": "4d2XWR", "name": "pipe maybe", "author": "yonatan", "description": "asdasd", "tags": ["asdasd"], "likes": 5, "viewed": 201, "published": "Public", "date": "1410897038", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// raymarcher from https://www.shadertoy.com/view/XsB3Rm\n\n// ray marching\nconst int max_iterations = 30;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.001;\nconst float clip_far = 300.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\nvec2 sdSegment( vec3 a, vec3 b, vec3 p ) {\n\tvec3 pa = p - a;\n\tvec3 ba = b - a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\n\nfloat smin( float a, float b )\n{\n\t\n\t\n    float k = 0.6;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\n// get distance in the world\nfloat dist_field(vec3 p) {\n    float l = length(floor(p*.33));\n    vec3 u = vec3(0,.5,1.);\n    float s = sin(iTime*2.);\n    float t = 0.04 * length(p);\n    u*=s*2.;\n    p = mod(p, 3.0) - 1.5;\n    p = p * rotationXY(vec2(l*iTime*1.1));\n    vec2 h;\n    h = sdSegment(u.xxy, -u.xxy, p);\n    float d1 = h.x - t;// + h.y * .0;\n    //u*=s;\n    h = sdSegment(u.xyx, -u.xyx, p);\n    float d2 = h.x - t;// + h.y * .0;\n    //u*=s;\n    h = sdSegment(u.yxx, -u.yxx, p);\n    float d3 = h.x - t;// + h.y * .0;\n    return smin(d3, smin(d1, d2));\n}\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\tvec3 light_pos   = vec3( 100.0 * cos(iTime*0.2), 200.0 * sin(iTime*0.4), 20.0 );\n    float l = length(floor(v*.33));\n\tvec3 light_color = vec3( abs(sin(l * .5 + vec3(1.,3.,5.))) * vec3(1.,.5,1.25) );\n\tvec3 vl = normalize( light_pos - v );\n\tfloat diffuse  = dot( vl, n );\n\tlight_color *= 2.0+diffuse;\n    /*\n    light_color.rgb += 1.1;\n    light_color.b *= length(v) * .015;\n    light_color.rg *= 1.75 - length(v) * .15;\n    light_color.rgb = max(light_color.rgb * length(v) * 0.15, 0.0);\n*/\n    return light_color;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 35.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 0.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( iTime * 0.13, iTime * 0.19 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0., clip_far );\n\tif ( depth >= clip_far ) {\n\t\tfragColor = vec4(0.0);\n    } else {\n\t\t// shading\n\t\tvec3 pos = eye + dir * depth;\n\t\tvec3 n = gradient( pos );\n\t\tfragColor = vec4( shading( pos, n, eye ) , 1.0 );\n        fragColor *= 1.0-depth/clip_far * 16.0;\n        //fragColor = vec4(n,1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4d2XWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[281, 281, 323, 323, 456], [459, 459, 491, 491, 603], [606, 638, 669, 669, 825], [827, 856, 882, 882, 1388], [1389, 1406, 1448, 1448, 1965], [1967, 1996, 2023, 2023, 2357], [2359, 2375, 2444, 2444, 2694], [2696, 2717, 2765, 2765, 2941], [2944, 2944, 3001, 3021, 3612]], "test": "valid"}
{"id": "4dBXDW", "name": "Ray Marching learning", "author": "dgoemans", "description": "Teaching myself basics of ray marching. Set FANCY to turn on the lighting ( really slow ). Reflection color is weird ( probably wrong ). Any comments/crits/help welcome :)", "tags": ["raymarch"], "likes": 1, "viewed": 145, "published": "Public", "date": "1411922587", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Many thanks to iq, learnt so much from his tutorials & site.\n\n// TURN THIS ON TO DO PRETTY REFLECTIONS N STUFF\n#define FANCY 0\n\n\n#define STEPS 128\n#define EPSILON 0.001\n#define PI 3.145\nconst vec3 lightPosition = vec3(-10.0, 10.0, -6.0);\nconst vec3 lightColor = vec3(1.0,1.0,1.0);\n\n\nfloat opS( float d1, float d2 )\n{\n    return max(-d1,d2);\n}\n\nfloat udRoundBox( vec3 p, vec3 b, float r )\n{\n  return length(max(abs(p)-b,0.0))-r;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\n\n\nfloat sphereBox(vec3 p)\n{\n    return opS(sdSphere(p,0.5),udRoundBox(p,vec3(0.35,0.35,0.35),0.05));\n}\n\n\nfloat spherePos(vec3 p, float r, vec3 pos)\n{\n    vec3 q = p;\n    q -= pos;\n    return sdSphere(q,r);\n}\n\n\nvec4 distance(vec3 p) \n{\n    const int numObjects = 5;\n    vec4 d[numObjects];\n    \n    d[0] = vec4(0.5,0.5,1.0,sdPlane(p,vec4(0.0,1.0,0.0,0.4)));\n    d[1] = vec4(0.5,1.0,0.5,sphereBox(p));\n    d[2] = vec4(1.0,0.5,0.5,spherePos(p,0.2,vec3(0.0)));\n    \n    float r = 0.3;\n    float theta = PI*0.5;//iTime*1.5;\n    float st = sin(theta);\n    float ct = sin(theta);\n    float phi = iTime*1.0;\n    float sp = sin(phi);\n    float cp = cos(phi);\n    \n    d[3] = vec4(1.0,1.0,1.0,spherePos(p,0.05,vec3(ct*sp*r,st*sp*r,cp*r))); \n    \n    theta = -PI*0.5;\n    st = sin(theta);\n    ct = sin(theta);    \n    \n    d[4] = vec4(1.0,1.0,1.0,spherePos(p,0.05,vec3(ct*sp*r,st*sp*r,cp*r))); \n    \n    vec4 min = vec4(0,0,0,99999.0);\n    for(int i=0; i<numObjects; i++)\n    {\n        if(d[i].w < min.w)\n            min = d[i];\n    }\n    \n    return min;\n    \n}\n\n\nvec3 normal(vec3 p) \n{\n    float h = 0.0001;\n\n\treturn normalize(vec3(\n\t\tdistance(p + vec3(h, 0, 0)).w - distance(p - vec3(h, 0, 0)).w,\n\t\tdistance(p + vec3(0, h, 0)).w - distance(p - vec3(0, h, 0)).w,\n\t\tdistance(p + vec3(0, 0, h)).w - distance(p - vec3(0, 0, h)).w));\n}\n\n#if FANCY\n\nfloat getShadow(vec3 p, float k)\n{\n\n    float maxt = length(lightPosition - p);\n\tvec3 rd = (lightPosition- p)/maxt;\n\t\n\tfloat t = 5.0*EPSILON;\n    vec4 d = vec4(0.0);\n    float f = 1.0;\n    \n\tfor(int i = 0; i < STEPS; ++i)\n\t{\n\t\td = distance(p + rd * t);\n\n\t\tif(d.w < EPSILON)\n\t\t\treturn 0.0;\n        \n\t\tf = min(f, k * d.w / t);\n        \n        t+=d.w;\n        if(t>maxt)\n            break;\n\t}\n\n\treturn f;\n}\n\n\nvec4 getShade(vec3 p, vec3 n)\n{\n    float shadow = getShadow(p,32.0);\n    float lightIntensity = 0.0;\n    if(shadow > 0.0)\n    {\n        vec3 lightDir = normalize(lightPosition - p);\n        lightIntensity = shadow * clamp(dot(n, lightDir),0.0,1.0);\n    }\n    vec3 ambient = vec3(0.3,0.3,0.3);\n    \n    vec3 result = lightIntensity*lightColor + ambient*(1.0-lightIntensity);\n    return vec4(result,1.0);\n}\n\nvec4 getReflection(vec3 p, vec3 n, vec3 origin)\n{\n    vec3 r = normalize(reflect(p-origin,n));\n    float maxt = 400.0;\n    \n    float t = 5.0*EPSILON;\n    \n    vec4 d = vec4(0.0);\n    vec3 q = p;\n    \n    for(int i = 0; i < STEPS; ++i)\n\t{\n        q = p + r * t;\n        d = distance(q);\n        \n\t\tif(d.w < EPSILON)\n        {\n            vec4 s1 = getShade(q, normal(q));\n            return vec4(d.rgb,1.0)*s1;\n        }\n        \n        t+=d.w;\n        if(t>maxt)\n            break;\n    }\n    \n    return vec4(0.1);\n}\n\n#endif\n\n\nfloat getOcclusion(vec3 p, vec3 n)\n{\n\tfloat stepSize = 0.01;\n\tfloat t = stepSize;\n\tfloat oc = 0.0;\n\tfor(int i = 0; i < 10; ++i)\n\t{\n\t\tvec4 d = distance(p + n * t);\n\t\toc += t - d.w; // Actual distance to surface - distance field value\n\t\tt += stepSize;\n\t}\n\n\treturn clamp(oc, 0.0, 1.0);\n}\n\n\nvec4 march(vec3 origin, vec3 dir)\n{\n    float t = 0.0;\n    vec4 d = vec4(0.0);\n\tvec3 p = origin;\n    \n    for(int i = 0; i < STEPS; ++i)\n    {\n        p = origin + dir * t;\n        d = distance(p);\n        \n        if( abs(d.w) < EPSILON )\n        {\n            vec3 n = normal(p);            \n            vec4 color = vec4(d.rgb,1.0);\n            \n            #if FANCY\n            vec4 s1 = getShade(p, n);\n            \n            vec4 reflection = getReflection(p,n, origin);\n            \n            color = (reflection*0.5 + color*0.5) * s1; \n            color = color * (1.0-getOcclusion(p,n));\n            #endif\n            \n            return color;\n            break;\n        }\n\n        t += d.w;\n    }\n    \n    return vec4(0.1);\n}\n\n \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0.0,0.0,1.0);\n\n    //eye.y = 0.2 +  0.2 * sin(iTime*0.2);\n    eye.x = cos(iTime*0.4);\n    eye.z = sin(iTime*0.4);\n\n    vec3 forward = eye * -1.0; //vec3(0,0,1);\n    vec3 up = vec3(0, 1, 0);\n    vec3 right = cross(forward,up); //vec3(1, 0, 0);\n    \n    float aspect = iResolution.x/iResolution.y;\n    \n    float u = fragCoord.x * 2.0 / iResolution.x - 1.0;\n    float v = fragCoord.y * 2.0 / iResolution.y - 1.0;\n\n    vec3 ro = eye;\n\tvec3 rd = normalize(forward + right * u * aspect + up * v);\n    \n    vec4 color = vec4(0.0); // Sky color\n\n    color = march(ro,rd);\n    fragColor = color;// * 2.0;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dBXDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[286, 286, 319, 319, 345], [347, 347, 392, 392, 432], [434, 434, 467, 467, 495], [497, 497, 530, 530, 561], [564, 564, 589, 589, 664], [667, 667, 711, 711, 769], [772, 772, 796, 796, 1613], [1616, 1616, 1638, 1638, 1884], [3240, 3240, 3276, 3276, 3524], [3527, 3527, 3562, 3562, 4269], [4274, 4274, 4331, 4331, 4950]], "test": "error"}
{"id": "4dBXWD", "name": "Spherical polyhedra", "author": "nimitz", "description": "Follow up to my \"Sphere mappings\" shader (https://www.shadertoy.com/view/4sjXW1).  Projecting the regular convex polyhedra onto a sphere, perhaps dodecaheral spheremaps could be better than cubemaps for some applications.  Drag to rotate.", "tags": ["3d", "sphere", "tilings", "polyhedra"], "likes": 133, "viewed": 5538, "published": "Public", "date": "1411926898", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Spherical polyhedra by nimitz (twitter: @stormoid)\n// https://www.shadertoy.com/view/4dBXWD\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n// Contact the author for other licensing options\n\n/*\n\tFollow up to my \"Sphere mappings\" shader (https://www.shadertoy.com/view/4sjXW1)\n\t\n\tI was thinking about a cheap way to do icosahedral mapping and realized\n\tI could just project on an axis and rotate the sphere for each projected\n\t\"facet\".\n\t\n\tHere I am showing only tilings of the regular polyhedra but this technique can\n\tbe used for any tilings of the sphere, regular or not. (or even arbitrary projections)\n\n\tI omitted the tetraedron since the small number of projections\n\tresults in heavy deformation.\n\n\tPerhaps there is a way to make that process cheaper? Let me know.\n*/\n\n#define time iTime\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nvec3 rotx(vec3 p, float a){ float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z); }\nvec3 roty(vec3 p, float a){ float s = sin(a), c = cos(a);\n    return vec3(c*p.x + s*p.z, p.y, -s*p.x + c*p.z); }\nvec3 rotz(vec3 p, float a){ float s = sin(a), c = cos(a);\n    return vec3(c*p.x - s*p.y, s*p.x + c*p.y, p.z); }\n\n//---------------------------Textures--------------------------------\n//-------------------------------------------------------------------\nvec3 texpent(in vec2 p, in float idx)\n{   \n    float siz = iResolution.x *.007;\n    vec2 q = abs(p);\n    float rz = sin(clamp(max(max(q.x*1.176-p.y*0.385, q.x*0.727+p.y),\n                             -p.y*1.237)*33.,0.,25.))*siz+siz;\n    vec3 col = (sin(vec3(1,1.5,5)*idx)+2.)*(rz+0.25);\n    col -= sin(dot(p,p)*10.+time*5.)*0.4;\n\treturn col;\n}\n\nvec3 textri2(in vec2 p, in float idx)\n{   \n    float siz = iResolution.x *.007;\n    vec2 q = abs(p);\n    float rz = sin(clamp(max(q.x*1.73205+p.y, -p.y*2.)*32.,0.,25.))*siz+siz;\n    vec3 col = (sin(vec3(1,1.7,5)*idx)+2.)*(rz+0.25);\n    col -= sin(p.x*20.+time*5.)*0.2;\n    return col;\n}\n\nvec3 texcub(in vec2 p, in float idx)\n{   \n    float siz = iResolution.x *.007;\n    float rz = sin(clamp(max(abs(p.x),abs(p.y))*24.,0.,25.))*siz+siz;\n    vec3 col = (sin(vec3(4,3.,5)*idx*.9)+2.)*(rz+0.25);\n    float a= atan(p.y,p.x);\n    col -= sin(a*15.+time*11.)*0.15-0.15;\n    return col;\n}\n\nvec3 textri(in vec2 p, in float idx)\n{\t\n    float siz = iResolution.x *.001;\n    p*=1.31;\n    vec2 bp = p;\n    p.x *= 1.732;\n\tvec2 f = fract(p)-0.5;\n    float d = abs(f.x-f.y);\n    d = min(abs(f.x+f.y),d);\n    \n    float f1 = fract((p.y-0.25)*2.);\n    d = min(d,abs(f1-0.5));\n    d = 1.-smoothstep(0.,.1/(siz+.7),d);\n    \n    vec2 q = abs(bp);\n    p = bp;\n    d -= smoothstep(1.,1.3,(max(q.x*1.73205+p.y, -p.y*2.)));\n    vec3 col = (sin(vec3(1.,1.5,5)*idx)+2.)*((1.-d)+0.25);\n    col -= sin(p.x*10.+time*8.)*0.15-0.1;\n    return col;\n}\n\n//----------------------------------------------------------------------------\n//----------------------------------Sphere Tilings----------------------------\n//----------------------------------------------------------------------------\n\n//All the rotation matrices can be precomputed for better performance.\n\n//5 mirrored pentagons for the dodecahedron\nvec3 dod(in vec3 p)\n{\n    vec3 col = vec3(1);\n    vec2 uv = vec2(0);\n    for (float i = 0.;i<=4.;i++)\n    {\n        p = roty(p,0.81);\n        p = rotx(p,0.759);\n        p = rotz(p,0.3915);\n    \tuv = vec2(p.z,p.y)/((p.x));\n    \tcol = min(texpent(uv,i+1.),col);\n    }\n    p = roty(p,0.577);\n    p = rotx(p,-0.266);\n    p = rotz(p,-0.848);\n    uv = vec2(p.z,-p.y)/((p.x));\n   \tcol = min(texpent(uv,6.),col);\n    \n    return 1.-col;\n}\n\n//10 mirrored triangles for the icosahedron\nvec3 ico(in vec3 p)\n{\n    vec3 col = vec3(1);\n    vec2 uv = vec2(0);\n    \n    //center band\n    const float n1 = .7297;\n    const float n2 = 1.0472;\n    for (float i = 0.;i<5.;i++)\n    {\n        if(mod(i,2.)==0.)\n        {\n            p = rotz(p,n1);\n        \tp = rotx(p,n2);\n        }\n\t\telse\n        {\n            p = rotz(p,n1);\n        \tp = rotx(p,-n2);\n        }\n        uv = vec2(p.z,p.y)/((p.x));\n    \tcol = min(textri(uv,i+1.),col);\n    }\n    p = roty(p,1.048);\n    p = rotz(p,.8416);\n    p = rotx(p,.7772);\n    //top caps\n    for (float i = 0.;i<5.;i++)\n    {\n        p = rotz(p,n1);\n        p = rotx(p,n2);\n\n    \tuv = vec2(p.z,p.y)/((p.x));\n    \tcol = min(textri(uv,i+6.),col);\n    }\n    \n    return 1.-col;\n}\n\n//4 mirrored triangles for octahedron\nvec3 octa(in vec3 p)\n{\n    vec3 col = vec3(1);\n    vec2 uv = vec2(0);\n    const float n1 = 1.231;\n    const float n2 = 1.047;\n    for (float i = 0.;i<4.;i++)\n    {\n       \tp = rotz(p,n1);\n       \tp = rotx(p,n2);\n    \tuv = vec2(p.z,p.y)/((p.x));\n    \tcol = min(textri2(uv*.54,i+1.),col);\n    }\n    \n    return 1.-col;\n}\n\n//cube using the same technique for completeness\nvec3 cub(in vec3 p)\n{\n    vec3 col = vec3(1);\n    vec2 uv = vec2(p.z,p.y)/((p.x));\n   \tcol = min(texcub(uv*1.01,15.),col);\n    p = rotz(p,1.5708);\n    uv = vec2(p.z,p.y)/((p.x));\n   \tcol = min(texcub(uv*1.01,4.),col);\n    p = roty(p,1.5708);\n    uv = vec2(p.z,p.y)/((p.x));\n    col = min(texcub(uv*1.01,5.),col);\n    \n    return 1.-col;\n}\n\n//----------------------------------------------------------------------------\n//----------------------------------------------------------------------------\n\nvec2 iSphere2(in vec3 ro, in vec3 rd)\n{\n    vec3 oc = ro;\n    float b = dot(oc, rd);\n    float c = dot(oc,oc) - 1.;\n    float h = b*b - c;\n    if(h <0.0) return vec2(-1.);\n    else return vec2((-b - sqrt(h)), (-b + sqrt(h)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n\tvec2 p = fragCoord.xy/iResolution.xy-0.5;\n    vec2 bp = p+0.5;\n\tp.x*=iResolution.x/iResolution.y;\n\tvec2 um = iMouse.xy / iResolution.xy-.5;\n\tum.x *= iResolution.x/iResolution.y;\n\t\n    //camera\n\tvec3 ro = vec3(0.,0.,3.5);\n    vec3 rd = normalize(vec3(p,-1.4));\n    mat2 mx = mm2(time*0.25+um.x*6.);\n    mat2 my = mm2(time*0.27+um.y*6.); \n    ro.xz *= mx;rd.xz *= mx;\n    ro.xy *= my;rd.xy *= my;\n    \n    float sel = mod(floor((time+10.)*0.2),4.);\n    //sel=0.;\n    vec2 t = iSphere2(ro,rd);\n    vec3 col = vec3(0.);\n    float bg = clamp(dot(-rd,vec3(0.577))*0.3+.6,0.,1.);\n    if (sel == 0.) col = dod(rd)*1.2;\n    else if (sel == 1.) col = ico(rd)*1.2;\n    else if (sel == 2.) col = cub(rd)*1.2;\n    else if (sel == 3.) col = octa(rd)*1.2;\n    \n    if (t.x > 0.)\n    {\n    \tvec3 pos = ro+rd*t.x;\n        vec3 pos2 = ro+rd*t.y;\n        vec3 rf = reflect(rd,pos);\n        if (sel == 0.)\n        {\n            vec3 col2 = max(dod(pos)*2.,dod(pos2)*.6);\n            col = mix(max(col,col2),col2,0.6);\n        }\n        else if (sel == 1.)\n        {\n            vec3 col2  = max(ico(pos2)*0.6,ico(pos)*2.);\n            col = mix(max(col,col2),col2,0.6);\n        }\n        else if (sel == 2.)\n        {\n            vec3 col2  = max(cub(pos2)*0.6,cub(pos)*2.);\n            col = mix(max(col,col2),col2,0.6);\n        }\n        else if (sel == 3.) \n        {\n            vec3 col2  = max(octa(pos2)*0.6,octa(pos)*2.);\n            col = mix(max(col,col2),col2,0.6);\n        }\n    }\n    \n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dBXWD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[834, 834, 855, 855, 907], [908, 908, 935, 935, 1019], [1020, 1020, 1047, 1047, 1132], [1133, 1133, 1160, 1160, 1244], [1246, 1386, 1425, 1425, 1730], [1732, 1732, 1771, 1771, 2018], [2020, 2020, 2058, 2058, 2312], [2314, 2314, 2352, 2352, 2849], [3161, 3205, 3226, 3226, 3635], [3637, 3681, 3702, 3702, 4399], [4401, 4439, 4461, 4461, 4757], [4759, 4808, 4829, 4829, 5146], [5307, 5307, 5346, 5346, 5534], [5536, 5536, 5593, 5593, 7104]], "test": "valid"}
{"id": "4dBXzw", "name": "Holographic", "author": "TDM", "description": "Inspired by Johnny Lee VR work. 3D effect on flat surface.", "tags": ["projection", "table", "holographic", "kinect"], "likes": 63, "viewed": 2859, "published": "Public", "date": "1410357276", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Holographic\" by Alexander Alekseev aka TDM - 2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n//#define PIXELIZE\n#define CAMERA_CHANGE\n\nconst int NUM_STEPS = 64;\nconst int AO_SAMPLES = 4;\nconst float AO_RADIUS = 1.3;\nconst float AO_DARKNESS = 3.5;\nconst float INV_AO_SAMPLES = 1.0 / float(AO_SAMPLES);\nconst float TRESHOLD \t= 0.001;\nconst float EPSILON \t= 1e-5;\nconst float PI \t\t\t= 3.1415;\nconst float HPI \t\t= PI * 0.5;\nconst float LIGHT_INTENSITY = 0.37;\nconst vec3 RED \t\t= vec3(1.0,0.7,0.7) * LIGHT_INTENSITY;\nconst vec3 ORANGE \t= vec3(1.0,0.67,0.43) * LIGHT_INTENSITY;\nconst vec3 BLUE \t= vec3(0.54,0.77,1.0) * LIGHT_INTENSITY;\nconst vec3 WHITE \t= vec3(1.0,0.99,0.98) * LIGHT_INTENSITY;\n#define WEIGHT (2.0 / iResolution.x)\n\n// holo\nconst vec2 HOLO_SIZE \t= vec2(0.79,0.49);\nconst float HOLO_ASPECT = HOLO_SIZE.x / HOLO_SIZE.y;\nconst int HOLO_LINES \t= 8;\nconst vec2 dxdy \t\t= HOLO_SIZE / float(HOLO_LINES/2);\nconst float HOLO_DEPTH \t= 5.0;\nconst float HOLO_DDEPTH = HOLO_DEPTH / float(HOLO_LINES-1);\n\n#ifdef PIXELIZE\nconst vec2 HOLO_RESOLUTION = vec2(20.0,16.0);\n#endif\n\n// math\nmat4 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat4 m;\n    m[0] = vec4(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x,0.0);\n\tm[1] = vec4(-a2.y*a1.x,a1.y*a2.y,a2.x,0.0);\n\tm[2] = vec4(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y,0.0);\n\tm[3] = vec4(0.0,0.0,0.0,1.0);\n\treturn m;\n}\nmat4 getPosMatrix(vec3 p) {   \n    mat4 ret;\n    ret[0] = vec4(1.0,0.0,0.0,p.x);\n    ret[1] = vec4(0.0,1.0,0.0,p.y);\n    ret[2] = vec4(0.0,0.0,1.0,p.z);   \n    ret[3] = vec4(0.0,0.0,0.0,1.0);\n    return ret;\n}\nvec3 rotate(vec3 v, mat4 m) {\n    return vec3(dot(v,m[0].xyz),dot(v,m[1].xyz),dot(v,m[2].xyz));\n}\nvec3 intersectPlane(vec3 o,vec3 d,vec4 p) {\n    float t = (dot(p.xyz,o)-p.w) / dot(p.xyz,d);\n    return o - d * t;    \n}\n\n// rasterize\nfloat line(vec2 p, vec2 p0, vec2 p1) {\n    vec2 d = p1 - p0;\n    float t = clamp(dot(d,p-p0) / dot(d,d), 0.0,1.0);\n    vec2 proj = p0 + d * t;\n    float dist = length(p - proj);\n    dist = 1.0/dist*WEIGHT;\n    return min(dist*dist,1.0);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) { return pow(dot(n,l) * 0.4 + 0.6,p); }\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (3.1415 * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// distance functions\nfloat plane(vec3 gp, vec4 p) {\n\treturn dot(p.xyz,gp+p.xyz*p.w);\n}\nfloat sphere(vec3 p,float r) {\n\treturn length(p)-r;\n}\nfloat capsule(vec3 p,float r,float h) {\n    p.y -= clamp(p.y,-h,h);\n\treturn length(p)-r;\n}\nfloat cylinder(vec3 p,float r,float h) {\n\treturn max(abs(p.y/h),capsule(p,r,h));\n}\nfloat box(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return max(max(p.x,p.y),p.z);\n}\nfloat rbox(vec3 p,vec3 s) {\n\tp = abs(p)-s;\n    return length(p-min(p,0.0));\n}\nfloat quad(vec3 p,vec2 s) {\n\tp = abs(p) - vec3(s.x,0.0,s.y);\n    return max(max(p.x,p.y),p.z);\n}\n\n// boolean operations\nfloat boolUnion(float a,float b) { return min(a,b); }\nfloat boolIntersect(float a,float b) { return max(a,b); }\n\n// world\nfloat map(vec3 p) {\n    float d = plane(p,vec4(0.0,1.0,0.0,1.0));\n    d = boolUnion(d,plane(p,vec4(0.0,-1.0,0.0,4.0))); \n    d = boolUnion(d,plane(p,vec4(0.0,0.0,1.0,5.0)));\n    d = boolUnion(d,plane(p,vec4(0.0,0.0,-1.0,5.0)));  \n    d = boolUnion(d,plane(p,vec4(1.0,0.0,0.0,8.0)));\n    d = boolUnion(d,plane(p,vec4(-1.0,0.0,0.0,8.0)));  \n    \n    d = boolUnion(d,rbox(vec3(0.75,-0.51,0.45)-p,vec3(0.1,0.5,0.1)));    \n    d = boolUnion(d,rbox(vec3(0.75,-0.51,-0.45)-p,vec3(0.1,0.5,0.1)));\n    d = boolUnion(d,rbox(vec3(-0.75,-0.51,0.45)-p,vec3(0.1,0.5,0.1)));    \n    d = boolUnion(d,rbox(vec3(-0.75,-0.51,-0.45)-p,vec3(0.1,0.5,0.1)));\n    d = boolUnion(d,rbox(vec3(0.0,-0.06,0.0)-p,vec3(0.85,0.05,0.55)));\n    \n    d = boolUnion(d,quad(vec3(0.0,0.0,0.0)-p,HOLO_SIZE));\n    return d;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float dens) {\n    vec3 n;\n    n.x = map(vec3(p.x+EPSILON,p.y,p.z));\n    n.y = map(vec3(p.x,p.y+EPSILON,p.z));\n    n.z = map(vec3(p.x,p.y,p.z+EPSILON));\n    return normalize(n-dens);\n}\nfloat getAO(vec3 p,vec3 n) {\n    float r = 0.0;\n    for(int i = 0; i < AO_SAMPLES; i++) {\n        float f = float(i)*INV_AO_SAMPLES;\n        float h = 0.01+f*AO_RADIUS;\n        float d = map(p + n * h) - TRESHOLD;\n        r += clamp(h-d,0.0,1.0) * (1.0-f);\n    }    \n    return pow(clamp(1.0-r*INV_AO_SAMPLES*AO_DARKNESS,0.0,1.0),0.5);\n}\nfloat spheretracing(vec3 ori, vec3 dir, out vec3 p) {\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        p = ori + dir * t;\n        d = map(p);\n        if(d < TRESHOLD) break;\n        t += max(d-TRESHOLD,EPSILON);\n    } \n    return d;\n}\n\n// holo\nfloat projectLine(vec3 o, vec2 uv, vec3 v0,vec3 v1) {\n    v0 = intersectPlane(o,v0-o,vec4(0.0,1.0,0.0,0.0));\n    v1 = intersectPlane(o,v1-o,vec4(0.0,1.0,0.0,0.0));\n    v0.xy = v0.xz / HOLO_SIZE; v1.xy = v1.xz / HOLO_SIZE;\n    v0.x *= HOLO_ASPECT; v1.x *= HOLO_ASPECT;\n    return line(uv,v0.xy,v1.xy);\n}\n\nvoid projectCircle(vec3 o,vec2 uv,vec3 v,inout vec3 c){\n    vec3 d = v-o;\n    v = intersectPlane(o,d,vec4(0.0,1.0,0.0,0.0));\n    v.xz /= HOLO_SIZE; v.x *= HOLO_ASPECT;\n    \n    float r = length(uv-v.xz) * length(d) * 0.75;\n    float circle = clamp(sin(r*40.0) * 5.0 * 0.5 + 0.5, 0.0,1.0);\n    c = mix(c, vec3(1.0,circle,circle), smoothstep(0.50,0.48,r));\n}\n\nvec3 holoGetColor(mat4 head, vec2 p) {\n    float time = iTime * 0.3;\n    vec2 uv = p; uv.x *= HOLO_ASPECT;    \n    vec3 pos = vec3(head[0][3],head[1][3],head[2][3]);\n    \n#ifdef PIXELIZE\n    uv = floor(uv*HOLO_RESOLUTION) / HOLO_RESOLUTION;\n#endif\n    \n    float i = 0.0;    \n    for(int it = 0; it < HOLO_LINES; it++) {\n        // vertical\n        vec3 v0 = vec3(-HOLO_SIZE.x + dxdy.x * float(it+1),0.0,-HOLO_SIZE.y);\n        vec3 v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(-HOLO_SIZE.x + dxdy.x * float(it),0.0, HOLO_SIZE.y);\n        v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);      \n        \n        v0 = vec3(-HOLO_SIZE.x, 0.0, -HOLO_SIZE.y + dxdy.y * float(it));\n        v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);  \n        \n        v0 = vec3(HOLO_SIZE.x, 0.0, -HOLO_SIZE.y + dxdy.y * float(it+1));\n        v1 = vec3(v0.x,-HOLO_DEPTH,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        // horizontal\n        float h = -float(it)*HOLO_DDEPTH;\n        v0 = vec3(-HOLO_SIZE.x,h,-HOLO_SIZE.y);\n        v1 = vec3(-v0.x,v0.y,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(-HOLO_SIZE.x,h,HOLO_SIZE.y);\n        v1 = vec3(-v0.x,v0.y,v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(-HOLO_SIZE.x,h,-HOLO_SIZE.y);\n        v1 = vec3(v0.x,v0.y,-v0.z);\n    \ti += projectLine(pos,uv,v0,v1);\n        \n        v0 = vec3(HOLO_SIZE.x,h,-HOLO_SIZE.y);\n        v1 = vec3(v0.x,v0.y,-v0.z);\n    \ti += projectLine(pos,uv,v0,v1);       \n    }\n    \n    vec3 color = vec3(min(i,1.0));    \n    projectCircle(pos,uv,vec3(-0.5,-3.0,0.0),color);\n    projectCircle(pos,uv,vec3( 0.5,-1.0,0.0),color);\n    projectCircle(pos,uv,vec3( 0.0, 1.0,0.0),color);\n    color += texture(iChannel0,uv*0.5).z * 0.3;\n    return color;\n}\n\nvec3 holoGetColor(mat4 head, vec3 p) {\n    return holoGetColor(head,p.xz / HOLO_SIZE);\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n    float time = iTime * 0.3;\n        \n    // ray\n    vec3 ang = vec3(0.0,0.7,time);\n    if(iMouse.z > 0.0) ang = vec3(0.0,clamp(2.0-iMouse.y*0.01,-0.3,PI),iMouse.x*0.01);\n\tmat4 rot = fromEuler(ang);\n    \n    vec3 ori = vec3(0.0,0.0,2.0+sin(time)*0.5);\n    vec3 dir = normalize(vec3(uv.xy,-2.0));    \n    ori = rotate(ori,rot);\n    dir = rotate(dir,rot);\n    mat4 head = rot * getPosMatrix(ori);\n    \n    // change camera\n#ifdef CAMERA_CHANGE\n    rot = fromEuler(vec3(0.0,1.0,0.0));\n    vec3 ori2 = vec3(0.0,0.0,2.0);\n    vec3 dir2 = normalize(vec3(uv.xy,-2.0));    \n    ori2 = rotate(ori2,rot);\n    dir2 = rotate(dir2,rot);\n    \n    float camera_change_factor = clamp((sin(time)-0.8)*10.0,-1.0,1.0) * 0.5 + 0.5;\n    ori = mix(ori,ori2,camera_change_factor);\n    dir = normalize(mix(dir,dir2,camera_change_factor));\n#endif\n    \n    // tracing\n    vec3 p;\n    float dens = spheretracing(ori,dir,p);\n    vec3 n = getNormal(p,dens);\n    float ao = getAO(p,n);\n         \n    // color\n    vec3 color = vec3(0.6+texture(iChannel0,(p.xz+p.y*0.2)*0.1).x * 0.05);\n    if(p.y >= -EPSILON && dot(p.xz,p.xz) < 1.0) color = holoGetColor(head,p);\n    color *= 1.0-pow(dot(p,p)*0.01,0.4);\n    \n    // lighting\n    vec3 l0 = normalize(vec3(0.0,0.5,0.7));\n    vec3 l1 = normalize(vec3(0.5,0.5,-0.7));    \n    color += vec3((diffuse(n,l0,3.0) + specular(n,l0,dir,20.0)) * RED);\n    color += vec3((diffuse(n,l1,3.0) + specular(n,l1,dir,20.0)) * BLUE);    \n    color = clamp(color*ao*0.9,0.0,1.0);\n    color = mix(vec3(0.3),color,step(dens,1.0));\n        \n    //color = vec3(ao);\n    //color = n * 0.5 + 0.5;\n\t\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dBXzw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1119, 1127, 1153, 1153, 1542], [1543, 1543, 1570, 1570, 1752], [1753, 1753, 1782, 1782, 1850], [1851, 1851, 1894, 1894, 1971], [1973, 1986, 2024, 2024, 2224], [2226, 2238, 2276, 2276, 2314], [2315, 2315, 2361, 2361, 2465], [2467, 2489, 2519, 2519, 2554], [2555, 2555, 2585, 2585, 2608], [2609, 2609, 2648, 2648, 2699], [2700, 2700, 2740, 2740, 2782], [2783, 2783, 2809, 2809, 2860], [2861, 2861, 2888, 2888, 2938], [2939, 2939, 2966, 2966, 3035], [3037, 3059, 3093, 3093, 3112], [3113, 3113, 3151, 3151, 3170], [3172, 3181, 3200, 3200, 3966], [3968, 3979, 4015, 4015, 4185], [4186, 4186, 4214, 4214, 4523], [4524, 4524, 4577, 4577, 4796], [4798, 4806, 4859, 4859, 5108], [5110, 5110, 5165, 5165, 5466], [5468, 5468, 5506, 5506, 7326], [7328, 7328, 7366, 7366, 7416], [7418, 7426, 7483, 7483, 9220]], "test": "error"}
{"id": "4dSSW1", "name": "Worley noise 4", "author": "FabriceNeyret2", "description": "variant from https://www.shadertoy.com/view/Md2SDz", "tags": ["voronoi", "worley"], "likes": 9, "viewed": 1519, "published": "Public API", "date": "1411204120", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rnd(float x) { return fract(1000.*sin(234.56*x)); }\nvec3 rnd3(float x) { return vec3(rnd(x),rnd(x+.1),rnd(x+.2)); }\nfloat hash(float x,float y,float z) { return (x+432.432*y-1178.65*z); }\nfloat hash(vec3 v) { return dot(v,vec3(1., 32.432, -1178.65)); }\n    \nvec4 Worley(vec3 uvw) {\n    \n   vec3 uvwi = floor(uvw);\t\t\t\t\t\t\t// cell coords\n   float dmin = 1e9, d2min=1e9, nmin=-1.;\n    \n    for (int i=-1; i<=1; i++)\t\t\t\t\t\t// visit neighborhood\n      for (int j=-1; j<=1; j++)\t\t\t\t\t\t// to find the closest point\n          for (int k=-1; k<=1; k++) \n          {\n              vec3 c = uvwi + vec3(float(i),float(j),float(k)); // neighbor cells\n              float n = hash(c);\t \t\t\t\t\t\t\t// cell ID\n              vec3 p = c + rnd3(n+.1);\t\t\t\t\t\t\t// random point in cell\n              float d = length(p-uvw);\t\t\t\t\t\t\t// dist to point\n              if (d<dmin) { d2min=dmin; dmin=d; nmin=n; }\t\t// 2 closest dists\n              else if (d<d2min) { d2min=d; }\n          }\n\treturn vec4(dmin,d2min,d2min-dmin, nmin);\t\t\t// 2 closest dists + closest ID\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 uvw = vec3(2.*(fragCoord.xy / iResolution.y-vec2(.9,.5)), .2*iTime);\n    float a = .2*iTime,c=cos(a),s=sin(a); uvw.xy *= mat2(c,-s,s,c);\t// rotate\n    uvw *= 4.*(.7+.6*vec3(vec2(cos(.5*iTime)),0.));\t\t\t\t\t// zoom\n\n    vec3 col = vec3(1.);\n    vec3 uvw0 = uvw; \n    for (int i=0; i<4; i++) {\n    \tuvw = uvw0+ .2*texture(iChannel0,.1*uvw.xy).rgb;\t\t\t\t// jitter pos\n        vec4 wor = Worley(uvw);    \n   \t\t vec3 ccol = mix(vec3(1.), rnd3(wor.a+.4), .4);\n   \t\t float v = wor.z;\n  \t\t int mode =  int(mod(.25*iTime,4.));\t\t\t\t\t\t// demo mode\n   \t\t if      (mode==0) v *= 4.;\n  \t\t else if (mode==1) v = pow(v,.025);\n  \t\t else if (mode==2) { v -= .3*sin(30.*uvw0.x)*sin(30.*uvw0.y); v = pow(v,.025); }\n  \t\t else              { v -= .02; v = pow(v,.025); }\n\t\tcol *= v*ccol;\n        uvw0 *= 2.;\n    }   \n\n\tfragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSSW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 57], [58, 58, 78, 78, 121], [122, 122, 159, 159, 193], [194, 194, 214, 214, 258], [264, 264, 287, 287, 1038], [1040, 1040, 1097, 1097, 1923]], "test": "error"}
{"id": "4dSSWW", "name": "gasket thing", "author": "yonatan", "description": "gasket thing", "tags": ["raymarching"], "likes": 1, "viewed": 126, "published": "Public", "date": "1411913547", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float s = 2.;\nfloat t = 1.;\nfloat gt = iTime*0.5 + 9.1;\n\nmat4 a = mat4(s,0.0,0.0,-t,\n              0.0,s,0.0,-t,\n              0.0,0.0,s,t,\n              0.0,0.0,0.0,1.0);\nmat4 b = mat4(s,0.0,0.0,t,\n              0.0,s,0.0,t,\n              0.0,0.0,s,t,\n              0.0,0.0,0.0,1.0);\nmat4 c = mat4(s,0.0,0.0,-t,\n              0.0,s,0.0,t,\n              0.0,0.0,s,-t,\n              0.0,0.0,0.0,1.0);\nmat4 d = mat4(s,0.0,0.0,t,\n              0.0,s,0.0,-t,\n              0.0,0.0,s,-t,\n              0.0,0.0,0.0,1.0);\n\nfloat df(vec3 p3) {\n    //p3 = mod(p3, 4.0)-2.0;\n    float mind;\n    vec4 p = vec4(p3, 1.0);\n    float m=1.0;\n    for(int i=0; i<8; i++) {\n        vec4 pa = p * a;\n        vec4 pb = p * b;\n        vec4 pc = p * c;\n        vec4 pd = p * d;\n        float la = dot(pa,pa);\n        float lb = dot(pb,pb);\n        float lc = dot(pc,pc);\n        float ld = dot(pd,pd);\n        p = pa;\n        mind = la;\n        if(lb < mind) { p = pb; mind = lb; }\n        if(lc < mind) { p = pc; mind = lc; }\n        if(ld < mind) { p = pd; mind = ld; }\n        mind=sqrt(mind);\n        m *= s;\n        if(mind > 1.8 + 0.2*cos(gt)) break;\n    }\n    return mind/m-1.0/m*(1.5 + 0.5 * sin(gt));\n    return (mind-1.0)/m*0.618;\n}\n\n// camera rotation : pitch, yaw\nmat4 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat4(\n\t\tc.y      ,  0.0, -s.y      , 0.0,\n\t\ts.y * s.x,  c.x,  c.y * s.x, 0.0,\n\t\ts.y * c.x, -s.x,  c.y * c.x, 0.0,\n        0.0      ,  0.0,        0.0, 1.0\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\t{\n    float mink = 0.001;\n\tvec2 p2=(fragCoord.xy/iResolution.xy)*2.0-1.0;\n\tvec3 dir=normalize(vec3(p2*vec2(1.77,1.0),1.0));\t\t// screen ratio (x,y) fov (z)\n    mat4 rot = rotationXY(vec2(.1*gt,-.3*gt));\n\tvec3 o=vec3(0.0, 0.0, -1. + .3*sin(gt))* mat3(rot);\n    dir *= mat3(rot);\n    a *= rot;\n    c *= rot * rot;\n\tvec3 hit;\n\tfloat t=.3, k;\n\tfor(int i=0;i<12;i++) {\n        hit=o+dir*t;\n\t\tk=df(hit);\n\t\tt+=k;\n        if(k<mink) break;\n\t}\n    vec2 e=vec2(-0.001, 0.0);\n    vec3 n = normalize(vec3(k-df(hit+e.xyy), k-df(hit+e.yxy), k-df(hit+e.yyx)));\n    n = n*0.5+0.5;\n    vec3 c = mix(n.yyy/length(o-hit), n, sin(gt)*.5+.5);\n    c = clamp(c,0.0,1.0);\n    //c *= 1.0-max(0.0,(k-mink));\n    \n    fragColor = vec4(c, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[516, 516, 535, 564, 1219], [1221, 1253, 1284, 1284, 1503], [1505, 1505, 1562, 1562, 2278]], "test": "valid"}
{"id": "4dSXWR", "name": "canvas2", "author": "FabriceNeyret2", "description": "tune with mouse x and y.  \nSpace to show tiles.", "tags": ["canvas", "short"], "likes": 54, "viewed": 2096, "published": "Public API", "date": "1410615723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "bool keyToggle(int ascii) {\n\treturn texture(iChannel3,vec2((.5+float(ascii))/256.,.75)).x > 0.;\n}\n\nvoid mainImage( out vec4 fragColor, vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv0 = fragCoord / iResolution.y;\n    vec2 m = iMouse.xy/iResolution.xy;\n    if (iMouse.z<=0.) { // autodemo \n\t\t    uv0 += vec2( 1.8*cos(.15*t)+.5*sin(.4*t) , sin(.22*t)-.5*cos(.3*t) );\n\t\t\tm = .5+.5*vec2(cos(t),sin(.6*t)); m.y*=m.x;\n    }\n\n    vec2 uv = uv0*8., iuv=floor(uv);\n    float d = mod(iuv.x+iuv.y,2.), s = mod(iuv.y,2.);\n    uv = fract (uv); if (d==1.) uv.x = 1.-uv.x; // checkered tile coordinates\n    uv = uv + vec2(-uv.y,uv.x); // rotate 45deg\n \n    float q = sign(s-.5)*sign(d-.5),\n      size0 = m.x+m.y*cos(.5*3.1415927*uv.y) *q,\n          l = abs(uv.x)-size0,\n          v = smoothstep(0.,.1,abs(l)),\n         v0 = step(0.,l);\n    \n    float size = m.x+m.y*cos(.5*3.1415927*uv.x), \n           ofs = (1.-size)*q; // corner distance\n             l = (uv.y-1.)-ofs;\n    float   v1 = step(0.,l),\n            d0 =  mod(s+v1,2.),\n            d1 =  mod(s+d+v1,2.); // corner area\n    v0 = d1<1. ? v0 : 0.; // background\n    v = (d1<1. ? v : 1.)*smoothstep(0.,.1,abs(l)); // contour\n\n    float col = v0 *(cos(8.*31.4*uv0.x)*cos(8.*31.4*uv0.y))\n          + (1.-v0)*( d1==1. ? cos(2.*31.4*( q>0. ? 2.-uv.y : uv.y )*m.x/size)  \n                             : cos(2.*31.4*(uv.x*m.x/size0)) );\n    if (keyToggle(32)) v/= 1.+.5*d;\n\tfragColor = vec4(col*v);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4dSXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 97], [99, 99, 153, 153, 1442]], "test": "error"}
{"id": "4s2XDz", "name": "Julia Explorer 1", "author": "glitchg", "description": "Shows the Julia Set as the c-value moves in a spiral over a radius 2 circle centered on the origin of the complex plane.\nThe HSV to RGB function is from http://lolengine.net.\nMade for a tutorial at http://demosceneacademy.wordpress.com. ", "tags": ["2d", "fractal"], "likes": 2, "viewed": 149, "published": "Public", "date": "1411046190", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CENTER vec2(0.5,0.5)\n#define ITER 50\n#define SCALE 2.0\n\n#define PI 3.14159\n\nfloat radius(float t) \n{\n    return abs(2.0-mod(t,4.0));\n}\n\nvec2 complexSquare(vec2 c) \n{\n    vec2 result;\n    result.x = c.x * c.x - c.y * c.y;\n    result.y = 2.0 * c.x * c.y;\n    return result;\n}\n\nvec2 seed(float t,float factor)\n{\n    float r = radius(t/(2.0*PI*factor));\n    return r*vec2(cos(t),sin(t));\n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec4 color(float n)\n{\n    float h = fract(n/float(ITER));\n    float v = 1.0 - sqrt(n/float(ITER));\n    float s = 1.0 - v;\n    \n    vec3 rgb = (hsv2rgb(vec3(h,s,v)));\n    \n    return vec4(rgb,1.0);\n}\n    \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float proportion = iResolution.x/iResolution.y;\n\t\n    vec2 coords = uv - CENTER;\n    vec2 z = SCALE * vec2(proportion*coords.x, coords.y);\n    \n    int iteration;\n    \n    for(int i = 0; i < ITER; i++) {\n        z = complexSquare(z) + seed(iTime,3.0);\n        iteration = i;\n    \tif(length(z) > 4.0) break;\n    }\n    \n    fragColor = color(float(iteration));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4s2XDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[84, 84, 108, 108, 142], [144, 144, 173, 173, 281], [283, 283, 316, 316, 393], [395, 395, 417, 417, 586], [588, 588, 609, 609, 786], [793, 793, 850, 850, 1257]], "test": "valid"}
{"id": "4sBSDW", "name": "TemporalDithering", "author": "TimothyLottes", "description": "Nice way to do temporal dithering using a high frequency color dither pattern and dithering more than just the LSB.", "tags": ["temporaldithering", "removingbanding"], "likes": 37, "viewed": 3532, "published": "Public", "date": "1411862097", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// TEMPORAL DITHERING TEST\n//\n\n//\n// This is biased (saturates + adds contrast) because dithering done in non-linear space.\n//\n\n// Shows proper dithering of a signal (overlapping of dither between bands).\n// Results in about a 1-stop improvement in dynamic range over conventional dither\n//   which does not overlap dither across bands\n//   (try \"#define WIDE 0.5\" to see the difference below). \n//\n// This would work a lot better with a proper random number generator (flicker etc is bad).\n// Sorry there is a limit to what can be done easily in shadertoy.\n//\n// Proper dithering algorithm,\n//\n//   color = floor(color * steps + noise) * (1.0/(steps-1.0))\n//\n// Where,\n//   \n//   color ... output color {0 to 1}\n//   noise ... random number between {-1 to 1}\n//   steps ... quantization steps, ie 8-bit = 256\n//\n// The noise in this case is shaped by a high pass filter.\n// This is to produce a better quality temporal dither.\n\n// Scale the width of the dither\n#define STEPS 8.0\n#define WIDE 1.0\n\n//-----------------------------------------------------------------------\n\n#define F1 float\n#define F2 vec2\n#define F3 vec3\n#define F4 vec4\n\nF1 Noise(F2 n,F1 x){n+=x;return fract(sin(dot(n.xy,F2(12.9898, 78.233)))*43758.5453)*2.0-1.0;}\n\n// Step 1 in generation of the dither source texture.\nF1 Step1(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-12.0,t=1.0;   \n return (1.0/(a*4.0+b*4.0-c))*(\n  Noise(uv+F2(-1.0,-1.0)*t,n)*a+\n  Noise(uv+F2( 0.0,-1.0)*t,n)*b+\n  Noise(uv+F2( 1.0,-1.0)*t,n)*a+\n  Noise(uv+F2(-1.0, 0.0)*t,n)*b+\n  Noise(uv+F2( 0.0, 0.0)*t,n)*c+\n  Noise(uv+F2( 1.0, 0.0)*t,n)*b+\n  Noise(uv+F2(-1.0, 1.0)*t,n)*a+\n  Noise(uv+F2( 0.0, 1.0)*t,n)*b+\n  Noise(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Step 2 in generation of the dither source texture.\nF1 Step2(F2 uv,F1 n){\n F1 a=1.0,b=2.0,c=-2.0,t=1.0;   \n return (4.0/(a*4.0+b*4.0-c))*(\n  Step1(uv+F2(-1.0,-1.0)*t,n)*a+\n  Step1(uv+F2( 0.0,-1.0)*t,n)*b+\n  Step1(uv+F2( 1.0,-1.0)*t,n)*a+\n  Step1(uv+F2(-1.0, 0.0)*t,n)*b+\n  Step1(uv+F2( 0.0, 0.0)*t,n)*c+\n  Step1(uv+F2( 1.0, 0.0)*t,n)*b+\n  Step1(uv+F2(-1.0, 1.0)*t,n)*a+\n  Step1(uv+F2( 0.0, 1.0)*t,n)*b+\n  Step1(uv+F2( 1.0, 1.0)*t,n)*a+\n 0.0);}\n    \n// Used for stills.\nF3 Step3(F2 uv){\n F1 a=Step2(uv,0.07);    \n F1 b=Step2(uv,0.11);    \n F1 c=Step2(uv,0.13);\n #if 1\n  // Monochrome can look better on stills.\n  return F3(a);\n #else\n  return F3(a,b,c);\n #endif\n}\n\n// Used for temporal dither.\nF3 Step3T(F2 uv){\n F1 a=Step2(uv,0.07*(fract(iTime)+1.0));    \n F1 b=Step2(uv,0.11*(fract(iTime)+1.0));    \n F1 c=Step2(uv,0.13*(fract(iTime)+1.0));\n return F3(a,b,c);}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n F2 uv=fragCoord.xy;\n F2 uv2=fragCoord.xy/iResolution.xy;F2 uv3=F2(uv2.x,1.0-uv2.y); \n F3 color=texture(iChannel0,uv2).rgb;\n F3 color2=texture(iChannel1,uv3*2.0).rgb;\n // BOTTOM: Show bands.\n if(uv2.y<0.1){color=F3(uv2.x);color=floor(0.5+color*(STEPS+WIDE-1.0)+(-WIDE*0.5)+Step3(uv)*WIDE)*(1.0/(STEPS-1.0));}   \n else if(uv2.y<0.2){color=F3(uv2.x);color=floor(0.5+color*(STEPS-1.0))*(1.0/(STEPS-1.0));}   \n else if(uv2.y<0.3){color=F3(uv2.x);color=floor(0.5+color*(STEPS+WIDE-1.0)+(-WIDE*0.5)+Step3T(uv)*WIDE)*(1.0/(STEPS-1.0));}   \n // Show video and texture.\n else if(uv2.y<0.9){\n  if(uv2.x<0.3)color=color2;\n  color=floor(0.5+color*(STEPS+WIDE-1.0)+(-WIDE*0.5)+Step3T(uv)*(WIDE))*(1.0/(STEPS-1.0));}\n // TOP: Show dither texture.\n else{color=Step3(uv)*0.25+0.5;}    \n fragColor=F4(color,1.0);}\n\n\n", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sBSDW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1142, 1142, 1162, 1162, 1236], [1238, 1292, 1313, 1313, 1684], [1690, 1744, 1765, 1765, 2135], [2141, 2161, 2177, 2177, 2354], [2356, 2385, 2402, 2402, 2553], [2555, 2555, 2611, 2611, 3412]], "test": "error"}
{"id": "4sBSWW", "name": "Smaller Numbers", "author": "P_Malin", "description": "Utility code to print numbers. \nExample display shader time, date, time, mouse co-ordinates and value on sin wave.\nIt can be useful to print values when tweaking shaders.\nNote - the values are not always accurate :)", "tags": ["utility", "numbers", "font", "digits"], "likes": 79, "viewed": 4642, "published": "Public", "date": "1411850728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Smaller Number Printing - @P_Malin\n// Creative Commons CC0 1.0 Universal (CC-0)\n\n// Feel free to modify, distribute or use in commercial code, just don't hold me liable for anything bad that happens!\n// If you use this code and want to give credit, that would be nice but you don't have to.\n\n// I first made this number printing code in https://www.shadertoy.com/view/4sf3RN\n// It started as a silly way of representing digits with rectangles.\n// As people started actually using this in a number of places I thought I would try to condense the \n// useful function a little so that it can be dropped into other shaders more easily,\n// just snip between the perforations below.\n// Also, the licence on the previous shader was a bit restrictive for utility code.\n//\n// Disclaimer: The values printed may not be accurate!\n// Accuracy improvement for fractional values taken from TimoKinnunen https://www.shadertoy.com/view/lt3GRj\n\n// ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n// Creative Commons CC0 1.0 Universal (CC-0) \n// https://www.shadertoy.com/view/4sBSWW\n\nfloat DigitBin( const int x )\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue( vec2 vStringCoords, float fValue, float fMaxDigits, float fDecimalPlaces )\n{       \n    if ((vStringCoords.y < 0.0) || (vStringCoords.y >= 1.0)) return 0.0;\n    \n    bool bNeg = ( fValue < 0.0 );\n\tfValue = abs(fValue);\n    \n\tfloat fLog10Value = log2(abs(fValue)) / log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringCoords.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((bNeg) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n                float fReducedRangeValue = fValue;\n                if(fDigitIndex < 0.0) { fReducedRangeValue = fract( fValue ); fDigitIndex += 1.0; }\n\t\t\t\tfloat fDigitValue = (abs(fReducedRangeValue / (pow(10.0, fDigitIndex))));\n                fCharBin = DigitBin(int(floor(mod(fDigitValue, 10.0))));\n\t\t\t}\n        }\n\t}\n    return floor(mod((fCharBin / pow(2.0, floor(fract(vStringCoords.x) * 4.0) + (floor(vStringCoords.y * 5.0) * 4.0))), 2.0));\n}\n\n// ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n\n\n// Original interface\n\nfloat PrintValue(const in vec2 fragCoord, const in vec2 vPixelCoords, const in vec2 vFontSize, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    vec2 vStringCharCoords = (fragCoord.xy - vPixelCoords) / vFontSize;\n    \n    return PrintValue( vStringCharCoords, fValue, fMaxDigits, fDecimalPlaces );\n}\n\nfloat GetCurve(float x)\n{\n\treturn sin( x * 3.14159 * 4.0 );\n}\n\nfloat GetCurveDeriv(float x) \n{ \n\treturn 3.14159 * 4.0 * cos( x * 3.14159 * 4.0 ); \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 vColour = vec3(0.0);\n\n\t// Multiples of 4x5 work best\n\tvec2 vFontSize = vec2(8.0, 15.0);\n\n\t// Draw Horizontal Line\n\tif(abs(fragCoord.y - iResolution.y * 0.5) < 1.0)\n\t{\n\t\tvColour = vec3(0.25);\n\t}\n\t\n\t// Draw Sin Wave\n\t// See the comment from iq or this page\n\t// http://www.iquilezles.org/www/articles/distance/distance.htm\n\tfloat fCurveX = fragCoord.x / iResolution.x;\n\tfloat fSinY = (GetCurve(fCurveX) * 0.25 + 0.5) * iResolution.y;\n\tfloat fSinYdX = (GetCurveDeriv(fCurveX) * 0.25) * iResolution.y / iResolution.x;\n\tfloat fDistanceToCurve = abs(fSinY - fragCoord.y) / sqrt(1.0+fSinYdX*fSinYdX);\n\tfloat fSetPixel = fDistanceToCurve - 1.0; // Add more thickness\n\tvColour = mix(vec3(1.0, 0.0, 0.0), vColour, clamp(fSetPixel, 0.0, 1.0));\t\n\n\t// Draw Sin Value\t\n\tfloat fValue4 = GetCurve(iMouse.x / iResolution.x);\n\tfloat fPixelYCoord = (fValue4 * 0.25 + 0.5) * iResolution.y;\n\t\n\t// Plot Point on Sin Wave\n\tfloat fDistToPointA = length( vec2(iMouse.x, fPixelYCoord) - fragCoord.xy) - 4.0;\n\tvColour = mix(vColour, vec3(0.0, 0.0, 1.0), (1.0 - clamp(fDistToPointA, 0.0, 1.0)));\n\t\n\t// Plot Mouse Pos\n\tfloat fDistToPointB = length( vec2(iMouse.x, iMouse.y) - fragCoord.xy) - 4.0;\n\tvColour = mix(vColour, vec3(0.0, 1.0, 0.0), (1.0 - clamp(fDistToPointB, 0.0, 1.0)));\n\t\n\t// Print Sin Value\n\tvec2 vPixelCoord4 = vec2(iMouse.x, fPixelYCoord) + vec2(4.0, 4.0);\n\tfloat fDigits = 1.0;\n\tfloat fDecimalPlaces = 2.0;\n\tfloat fIsDigit4 = PrintValue( (fragCoord - vPixelCoord4) / vFontSize, fValue4, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.0, 0.0, 1.0), fIsDigit4);\n\t\n\t// Print Shader Time\n\tvec2 vPixelCoord1 = vec2(96.0, 5.0);\n\tfloat fValue1 = iTime;\n\tfDigits = 6.0;\n\tfloat fIsDigit1 = PrintValue( (fragCoord - vPixelCoord1) / vFontSize, fValue1, fDigits, fDecimalPlaces);\n\tvColour = mix( vColour, vec3(0.0, 1.0, 1.0), fIsDigit1);\n\n\t// Print Date\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue( (fragCoord - vec2(0.0, 5.0)) / vFontSize, iDate.x, 4.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue( (fragCoord - vec2(0.0 + 48.0, 5.0)) / vFontSize, iDate.y + 1.0, 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 1.0, 0.0), PrintValue( (fragCoord - vec2(0.0 + 72.0, 5.0)) / vFontSize, iDate.z, 2.0, 0.0));\n\n\t// Draw Time\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue( (fragCoord - vec2(184.0, 5.0)) / vFontSize, mod(iDate.w / (60.0 * 60.0), 12.0), 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue( (fragCoord - vec2(184.0 + 24.0, 5.0)) / vFontSize, mod(iDate.w / 60.0, 60.0), 2.0, 0.0));\n\tvColour = mix( vColour, vec3(1.0, 0.0, 1.0), PrintValue( (fragCoord - vec2(184.0 + 48.0, 5.0)) / vFontSize, mod(iDate.w, 60.0), 2.0, 0.0));\n\t\n\tif(iMouse.x > 0.0)\n\t{\n\t\t// Print Mouse X\n\t\tvec2 vPixelCoord2 = iMouse.xy + vec2(-52.0, 6.0);\n\t\tfloat fValue2 = iMouse.x / iResolution.x;\n\t\tfDigits = 1.0;\n\t\tfDecimalPlaces = 3.0;\n\t\tfloat fIsDigit2 = PrintValue( (fragCoord - vPixelCoord2) / vFontSize, fValue2, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit2);\n\t\t\n\t\t// Print Mouse Y\n\t\tvec2 vPixelCoord3 = iMouse.xy + vec2(0.0, 6.0);\n\t\tfloat fValue3 = iMouse.y / iResolution.y;\n\t\tfDigits = 1.0;\n\t\tfloat fIsDigit3 = PrintValue( (fragCoord - vPixelCoord3) / vFontSize, fValue3, fDigits, fDecimalPlaces);\n\t\tvColour = mix( vColour, vec3(0.0, 1.0, 0.0), fIsDigit3);\n\t}\n\t\n\tfragColor = vec4(vColour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sBSWW.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[1080, 1080, 1111, 1111, 1269], [1271, 1271, 1365, 1365, 2401], [2819, 2819, 2844, 2844, 2880], [2882, 2882, 2913, 2913, 2967], [2969, 2969, 3026, 3026, 6394]], "test": "error"}
{"id": "4sBXDh", "name": "This Wants Colors - Coder Colors", "author": "VJSpackOMat", "description": "This is a coloring of the \"This Wants Colors\" Shader\nhttps://www.shadertoy.com/view/lsjXzW\n\nWARNING: CODER COLORS USED!", "tags": ["kalifractalcolors"], "likes": 7, "viewed": 374, "published": "Public", "date": "1411205034", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://www.fractalforums.com/movies-showcase-%28rate-my-movie%29/very-rare-deep-sea-fractal-creature/\n//kali gl code rmxed\n// Colored version of https://www.shadertoy.com/view/lsjXzW\n// Edited by c.Kleinhuis for coloring, the coloring method from fragmentarium default de shader using\n// min(abs(p) as orbittrap is used, it keeps record of the closest distances to each axis, which is\n// then used to color the object, CODER COLORS used, red green and blue\n\nconst int Iterations=24;\nconst float Scale=1.27;\nconst vec3 Julia=vec3(-1.2,-1.95,-.6);\nconst vec3 RotVector=vec3(0.15,-0.75,-0.5);\nconst float RotAngle=99.;\nconst float Speed=1.3;\nconst float Amplitude=0.45;\nconst float detail=.0125;\nconst vec3 lightdir=-vec3(0.5,1.,0.5);\n\n\nvec3 orbitTrap;\n\n// EDIT: Alpha is used as Factor\nvec4 colorBase=vec4(1.0,1.0,1.0,0.5);\nvec4 colorX=vec4(1.0,.0,.0,2.0);\nvec4 colorY=vec4(0.0,1.0,0.0,2.0);\nvec4 colorZ=vec4(0.0,0.0,1.0,2.0);\n\nmat3 rot;\nfloat de(vec3 p); \n\nvec3 normal(vec3 p) {\n\tvec3 e = vec3(0.0,detail,0.0);\n\t\n\treturn normalize(vec3(\n\t\t\tde(p+e.yxx)-de(p-e.yxx),\n\t\t\tde(p+e.xyx)-de(p-e.xyx),\n\t\t\tde(p+e.xxy)-de(p-e.xxy)\n\t\t\t)\n\t\t);\t\n}\n\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float k )\n{\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<48; i++ )\n    {\n        float h = de(ro + rd*t);\n\t\th = max( h, 0.0 );\n        res = min( res, k*h/t );\n        t += clamp( h, 0.01, 0.5 );\n    }\n    return clamp(res,0.0,1.0);\n}\n\nfloat light(in vec3 p, in vec3 dir) {\n\tvec3 ldir=normalize(lightdir);\n\tvec3 n=normal(p);\n\tfloat sh=softshadow(p,-ldir,1.,20.);\n\tfloat diff=max(0.,dot(ldir,-n));\n\tvec3 r = reflect(ldir,n);\n\tfloat spec=max(0.,dot(dir,-r));\n\treturn diff*sh+pow(spec,30.)*.5*sh+.15*max(0.,dot(normalize(dir),-n));\t\n\t\t}\n\n\n// EDIT: RETURN COLORS FROM ORBITTRAP\n// ORBITTRAP IS CLOSEST DISTANCE TO EACH AXIS\nvec3 getColor(){\n\n\tvec3 result=vec3(0.0,0.0,0.0);\n      \n    result=colorBase.xyz*colorBase.w+\n        \tcolorX.xyz*colorX.w*orbitTrap.x+\n        \tcolorY.xyz*colorY.w*orbitTrap.y+\n        \tcolorZ.xyz*colorZ.w*orbitTrap.z;\n    \n    \n    return result;\n    \n}\n\nvec4 raymarch(in vec3 from, in vec3 dir)\n{\n\tfloat st,d=1.0,col,totdist=st=0.;\n\tvec3 p;\n\tfor (int i=0; i<70; i++) {\n\tif (d>detail && totdist<50.)\n\t{\n\t\tp=from+totdist*dir;\n        // EDIT: Reset OrbitTrap for Every Call to DE\n        orbitTrap=vec3(1000.0,1000.0,1000.0);\n\t\td=de(p);\n\t\ttotdist+=d;\n\t}\n\t}\n   vec3 color;\n\tfloat backg=0.5;\n\tif (d<detail) {\n\t  \t // EDIT: a call to \"light\" would destroy our orbittrap, store it here, could be optimized ;)\n   \t\t vec3 orbitSave=orbitTrap;\n  \t\tcol=light(p-detail*dir, dir); \n\t\tcol = mix(col, backg, 1.0-exp(-.000025*pow(totdist,3.5)));\n        // EDIT: Use Light Value as factor, include light color if you wish\n\t    //EDIT restore orbittrap, and call getColor\n \t   orbitTrap=orbitSave;       \n        color=col*getColor();\n\t} else { \n\t\tcol=backg;\n\t}\n    \n    // Return Color\n    \n\treturn vec4(color,1);\n}\n\nmat3  rotationMatrix3(vec3 v, float angle)\n{\n\tfloat c = cos(radians(angle));\n\tfloat s = sin(radians(angle));\n\t\n\treturn mat3(c + (1.0 - c) * v.x * v.x, (1.0 - c) * v.x * v.y - s * v.z, (1.0 - c) * v.x * v.z + s * v.y,\n\t\t(1.0 - c) * v.x * v.y + s * v.z, c + (1.0 - c) * v.y * v.y, (1.0 - c) * v.y * v.z - s * v.x,\n\t\t(1.0 - c) * v.x * v.z - s * v.y, (1.0 - c) * v.y * v.z + s * v.x, c + (1.0 - c) * v.z * v.z\n\t\t);\n}\n\n// EDIIT: Initialise Rot Matrices Once for every pixel\nvoid initialiseMatrices(){\n\tvec3 ani;\n    float time=iTime*Speed;\n\tani=vec3(sin(1.),sin(time*.133),cos(time*.2))*Amplitude;\n\trot = rotationMatrix3(normalize(RotVector+ani), RotAngle+sin(time)*10.);\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // EDIT: CALL init once\n    initialiseMatrices();\n\tfloat t=iTime*.3;\n\tvec2 uv = fragCoord.xy / iResolution.xy*2.-1.;\n\tuv.y*=iResolution.y/iResolution.x;\n\tvec3 from=vec3(0.,-.7,-20.);\n\tvec3 dir=normalize(vec3(uv*.7,1.));\n\t\n    // EDIT: Use 2d Matrice locally\n\tmat2 roti=mat2(cos(-.5),sin(-.5),-sin(-.5),cos(-.5));\n\tdir.yz=dir.yz*roti;\n\tfrom.yz=from.yz*roti;\n\n    fragColor = raymarch(from,dir);\n\n    \n    \n}\n\n\n\n\nfloat de(vec3 p) {\n\tp=p.zxy;\n\tfloat a=1.5+sin(iTime*.5)*.5;\n     \n\tp.xy=p.xy*mat2(cos(a),sin(a),-sin(a),cos(a));\n\tp.x*=.75;\n\t\n\tvec3 pp=p;\n\tfloat l;\n\tfor (int i=0; i<Iterations; i++) {\n\t\tp.xy=abs(p.xy);\n\t\tp=p*Scale+Julia;\n\t\tp*=rot;\n\t\tl=length(p);\n        // EDIT: Update Orbittrap in Every Iteration,\n        //here simple orbittrap of \"min\" is implemented, spherical orbittrap around sphere located at zero\n\t\t//orbitTrap=min(orbitTrap,abs(p));\n    \n        // EDIT: add an offset, spherical orbittrap around point \n\t\torbitTrap=min(orbitTrap,abs(p+(vec3(1.0,1.0,1.0))));\n        \n        //M Playing around, sinus of orbittrap makes interesting results ;)\n        //orbitTrap=min(orbitTrap,abs(sin(p)+1.0));\n\t}\n\treturn l*pow(Scale, -float(Iterations))*.9;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sBXDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[959, 959, 980, 980, 1134], [1136, 1136, 1201, 1201, 1440], [1442, 1442, 1479, 1479, 1739], [1742, 1826, 1842, 1842, 2082], [2084, 2084, 2126, 2126, 2930], [2932, 2932, 2976, 2976, 3344], [3346, 3401, 3427, 3427, 3602], [3604, 3604, 3661, 3689, 4072], [4077, 4077, 4095, 4095, 4833]], "test": "valid"}
{"id": "4sjXDR", "name": "Loading Icon", "author": "theknoppix", "description": "Loading icon try. Learning shadertoy at the moment and having a lot of fun.", "tags": ["loading"], "likes": 3, "viewed": 192, "published": "Public", "date": "1410919077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ratio = iResolution.x / iResolution.y;\n    uv.x *= ratio;\n    \n    float movementAnimationSpeed = 1.0;\n    float circleSize = 0.2;\n    float blendAnimationSpeed = 1.0;\n    float pi = 3.14159;\n    float sharpness = 60.0;\n    \n    vec2 centerOfCircle = vec2(sin(iTime * movementAnimationSpeed)/ 10.0 + 0.5 * ratio,\n                                 cos(iTime * movementAnimationSpeed) / 10.0 + 0.5);\n    \n    vec2 centerOfCircle2 = vec2(sin((iTime + ((2.0 * pi)/3.0)) * movementAnimationSpeed)/ 10.0 + 0.5 * ratio,\n                                 cos((iTime + ((2.0 * pi)/3.0)) * movementAnimationSpeed) / 10.0 + 0.5);\n    \n    vec2 centerOfCircle3 = vec2(sin((iTime + ((2.0 * pi)* 2.0 /3.0)) * movementAnimationSpeed)/ 10.0 + 0.5 * ratio,\n                                 cos((iTime + ((2.0 * pi)* 2.0/3.0)) * movementAnimationSpeed) / 10.0 + 0.5);\n    \n    float distance1 = distance(centerOfCircle, uv) / circleSize;\n    float distance2 = distance(centerOfCircle2, uv) / circleSize;\n    float distance3 = distance(centerOfCircle3, uv) / circleSize;\n    \n    float finalSharpness = sharpness * sin(blendAnimationSpeed * iTime);\n    \n    float colR = 1.0 - pow(distance1 * 5.0, finalSharpness);\n    float colB = 1.0 - pow(distance2 * 5.0, finalSharpness);\n    float colG = 1.0 - pow(distance3 * 5.0, finalSharpness);\n    \n    //return color\n    fragColor = vec4(colR, colB, colG, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sjXDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1499]], "test": "valid"}
{"id": "4sjXzW", "name": "HypnoWorm", "author": "Luther", "description": "On the way to making something else, I ended up with this thing.", "tags": ["spinninghappyaccident"], "likes": 7, "viewed": 1408, "published": "Public", "date": "1409664269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define TWO_PI 6.2831853\n\nvec2 rotate( const in vec2 vPos, const in float fAngle )\n{\n    float s = sin(fAngle);\n    float c = cos(fAngle);\n\n    vec2 vResult = vec2( c * vPos.x + s * vPos.y, -s * vPos.x + c * vPos.y);\n\n    return vResult;\n}\n\nvec3 orangegrad(float d)\n{\n    return mix(mix(vec3(0.3, 0.0, 0.1), vec3(2.0, 0.7, 0.1), d), vec3(5.0, 5.0, 0.0), d * 0.1);\n}\n\nvec2 RadialDistort(vec2 uv ,vec2 centre, float radius, float amount, float r)\n{\n    vec2 lpos = uv - centre;\n    float dist = length(lpos);\n    float dx = dist / radius;\n    vec2 ret = rotate(lpos, r + (dx * amount));\n    return ret + centre;\n}\n\nfloat CircularGradient(vec2 pos, vec2 centre, float radius)\n{\n    float dist = length(pos - centre);\n    float dx = dist / radius;\n  \n    return dx;\n}\n\nfloat easeInOutCubic(float t) \n{\n\tif ((t/=0.5) < 1.0) return 0.5*t*t*t;\n\treturn 0.5*((t-=2.0)*t*t + 2.0);\n}\n\n\nfloat CircularGradientSineSeg(vec2 pos, vec2 centre, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    vec2 norm = vec / dist;\n    float segment = max(0.0, sin(atan(-norm.y, norm.x) * segments));\n    float dx = 1.0 - (dist / radius);\n  \n    return dx * segment;\n}\n\n\nfloat SelectSegment(const in vec2 vPos, const in float segcount)\n{\n\t\n\tvec2 vNorm = normalize(vPos);\n\tfloat atn = (atan(vNorm.y, vNorm.x) + PI)/  TWO_PI;\n\tfloat segment = floor(atn * segcount);\n\tfloat half_segment = 0.5 / segcount;\n\tfloat seg_norm = mod((segment / segcount) + 0.25 + half_segment, 1.0);\n\t\n\treturn seg_norm * TWO_PI;//turn it back in to rotation\n}\n\nfloat fade2(float t)\n{\n\treturn t*t*(3.0-2.0*t);\n}\n \n\n\nfloat StarShape(vec2 pos, vec2 centre, float centrerad, float radius, float segments)\n{\n    vec2 vec = (pos - centre);\n    float dist = length(vec);\n    float angle = atan(-vec.y, vec.x);\n    float seg_angle_size = TWO_PI / segments;\n    float half_seg_seg_angle_size = seg_angle_size * 0.5;\n    float seg_arc_length = seg_angle_size * centrerad;\n    \n    float r =  SelectSegment(vec, segments);\t\t\n\tvec2 dpos = rotate(vec, r );        \n    float ld = 1.0 - (dist - centrerad) / (radius - centrerad);\n    float w = mod(angle, seg_angle_size);\n    float d = abs(dpos.x * 1.1);\n   \n    float width_at = (seg_arc_length * ld);\n    return cos((width_at-d) / seg_arc_length) * ld ;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    float ar = iResolution.x / iResolution.y;\n    uv.x = (uv.x * ar) - 0.5;\n    vec2 centre  = vec2(0.4, 0.5);\n    float radius = 0.5;\n    float amount = sin(iTime)*5.0;\n    float r = iTime * 0.5;\n    uv = RadialDistort(uv, centre, radius, amount, r);\n    \n    \n    float p = StarShape(uv, centre, 0.325, 0.9, 4.0);\n  \n    fragColor = vec4(orangegrad(p), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sjXzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[263, 263, 289, 289, 387], [389, 389, 468, 468, 633], [635, 635, 696, 696, 785], [787, 787, 819, 819, 894], [897, 897, 981, 981, 1207], [1574, 1574, 1596, 1596, 1623], [1628, 1628, 1715, 1715, 2311], [2315, 2315, 2372, 2372, 2780]], "test": "error"}
{"id": "4sSSDD", "name": "lostincolormesh", "author": "artech", "description": "first try to draw something with a few lines of code.\nfirst I created a grid and moved it around the centre.\nthen distorted the grid value using sin function over xy coordinates and global time\nI did the color variation using power function.", "tags": ["2d"], "likes": 1, "viewed": 135, "published": "Public", "date": "1411946506", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#ifdef GL_ES\nprecision highp float;\n#endif\n\n\n#define time iTime\n#define resolution iResolution\n\n\n\n\n#define cx 0.0\n#define cy 0.0\n\n#define gtime iTime\n\n#define pi 3.14159\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 v = fragCoord.xy / iResolution.xy;\n    v.x -= 100.0*(cos(gtime*0.005));;\n    v.y -= 150.0*sin(gtime*0.01);\n    vec3 color = vec3(0.0,0.0,0.0);\n        \n\n    float x = 0.1*abs(sin(gtime));\n    float grid = abs(cos(0.5 - v.x)*sin(0.5 - v.y))*sin(gtime*0.2)*0.4;\n    \n    \n    float psy = abs(sin(v.y*pi*grid));\n    float psx = abs(sin(v.x*pi*grid));\n\n    float pr = psx*psy*(sin(gtime));\n    float pg = psx*psy*(sin(gtime));\n    float pb = psx*psy;\n     \n    float r = pow(x,pr)*sin(v.y);\n    float b = pow(x,pg)*sin(v.x);\n    float g = pow(x,pb);\n               \n    \n    color = vec3(r,g,b);\n    \n    fragColor = vec4(color,1.0);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sSSDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[173, 173, 230, 230, 869]], "test": "valid"}
{"id": "4sXSD8", "name": "Dancing Particles", "author": "4rknova", "description": "Pretty random", "tags": ["metaballs", "motionblur", "particles"], "likes": 30, "viewed": 2011, "published": "Public API", "date": "1409967699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// by Nikos Papadopoulos, 4rknova / 2014\n// Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#define EPS .001\n\n#define TM iTime * 1.75\n#define FT 2.5 * EPS * hash(TM)\n#define SM 45\n#define CI vec3(1) \n#define CO vec3(r, 0, 0)\n\nfloat hash(in float n) { return fract(sin(n)*43758.5453123); }\n\nfloat hash(vec2 p)\n{\n    return fract(sin(dot(p,vec2(127.1,311.7))) * 43758.5453123);\n}\n\nfloat noise(vec2 p)\n{\n    vec2 i = floor(p), f = fract(p); \n\tf *= f*f*(3.-2.*f);\n    return mix(mix(hash(i + vec2(0.,0.)), \n                   hash(i + vec2(1.,0.)), f.x),\n               mix(hash(i + vec2(0.,1.)), \n                   hash(i + vec2(1.,1.)), f.x), f.y);\n}\n\nfloat fbm(in vec2 p)\n{\n\treturn\t.5000 * noise(p)\n\t\t   +.2500 * noise(p * 2.)\n\t\t   +.1250 * noise(p * 4.)\n\t\t   +.0625 * noise(p * 8.);\n}\n\nfloat metaball(vec2 p, float r)\n{\n\treturn vec2(noise(vec2(FT,1)/r)).x / dot(p, p);\n}\n\nvec3 blob(vec2 p, float t)\n{\n\tfloat t0 = sin(t * 1.9) * .46;\n\tfloat t1 = sin(t * 2.4) * .39;\n\tfloat t2 = cos(t * 1.4) * .57;\n\n\tfloat r = metaball(p - vec2(t1 * .9, t2 * .3), noise(vec2(TM) *.1))\n\t\t\t+ metaball(p + vec2(t2 * .5, t0 * .4), noise(vec2(TM) *.2))\n\t\t\t+ metaball(p - vec2(t0 * .3, t1 * .5), noise(vec2(TM) *.4));\n\t\n\tr = max(r, .2);\n\t\n\tr *= FT;\n\n\treturn (r > .5)\n\t\t? (vec3(step(.1, r*r*r)) * CI)\n\t\t: (r < 1000.9 ? CO : CI);\n}\n\nvec3 texsample(vec2 uv, in vec2 fragCoord)\n{\n\tif (abs(EPS + uv.y) >= .4 ) { \n\t\treturn vec3(0);\n\t}\n\t\t\n\tvec3  c = vec3(0);\n\t\n\tfor (int i = 0; i < SM; ++i) {\n\t\tfloat dt = TM - 4. * fbm(vec2(uv * 10.)) / float(i);\n\t\tc += blob(uv - noise(vec2(uv) * 0.1), dt) / float(SM);\n\t}\n\t\n\tvec3 fx = vec3(smoothstep(0., 3.5, iTime) * c) + vec3(.01);\n\n\tfloat noise = hash((hash(uv.x) + uv.y) * iTime) * .055;\n\tfloat fade  = smoothstep(EPS, 2.5, iTime);\n\t\n\treturn fade * (noise + fx);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy / iResolution.xy * 2. - 1.)\n\t\t\t* vec2(iResolution.x / iResolution.y, 1);\n\tfragColor = vec4(texsample(uv, fragCoord), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/4sXSD8.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[255, 255, 279, 279, 317], [319, 319, 339, 339, 406], [408, 408, 429, 429, 678], [680, 680, 702, 702, 814], [816, 816, 849, 849, 900], [902, 902, 930, 930, 1335], [1337, 1337, 1381, 1381, 1804], [1806, 1806, 1863, 1863, 2011]], "test": "valid"}
{"id": "ld2SRw", "name": "my first ray tracer :)", "author": "Spaceoff", "description": "Just slowly trying to figure this shit out.\nWriting my working out as I go, just in case it's ever helpful to someone (or me, after I forget it all again).", "tags": ["3d", "test", "ray", "casting", "noobish"], "likes": 1, "viewed": 195, "published": "Public", "date": "1410543198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.14159, two_pi = pi*2.0, half_pi = pi/2.0;\n\nconst vec4 black = vec4(0.0, 0.0, 0.0, 1.0), white = vec4(1.0),\n\tred   =  vec4(1.0, 0.0, 0.0, 1.0),\n    green =  vec4(0.0, 1.0, 0.0, 1.0),\n    blue  =  vec4(0.0, 0.0, 1.0, 1.0);\n\n\nstruct Ray { vec3 o, d; };\nstruct Sphere { vec3 o; float r; vec4 col; };\nstruct YPlane { float y; vec4 col; };\nstruct Collision { Ray r; float t; vec3 o; vec4 col; };\nstruct Light { vec3 o; float str; vec4 col; };\n\n\nCollision iSphere(in Ray r, in Sphere s)\n{\n/*\nRo = ray origin, Rd = ray direction\nt = arbitrary scalar multiplier for ray\nray, Ro + tRd\n\nSo = sphere origin, r = sphere radius\nP = arbitrary point on sphere\n|P-So| = r\n(P-So)^2 = r^2\nP.P - 2P.So +So.So = r^2\nP.P = r^2 + 2P.So -So.So\n|P|^2 = P.P\n\nFor simplicity, So = 0, Rso = Ro - So\nP.P = r^2\n\nIntersection:\nRso + tRd = P\n(Rso + tRd)^2 = P^2 = |P|^2 = P.P = r^2\nRso(Rso + tRd) + tRd(Rso + tRd) = r^2\nRso.Rso + tRso.Rd + tRso.Rd + (t^2)Rd.Rd - r^2 = 0\nRd.Rd(t^2) + (2Rso.Rd)t + (Rso.Rso - r^2) = 0\nin quadratic form, ax^2 +bx +c = 0\n\ta = Rd.Rd, Rd is a unit vector thus |Rd|=1 thus |Rd|^2=1\n\ta = 1\n\tb = 2Rso.Rd\n\tc = Rso.Rso -r^2\n\nt = (-b +/- sqrt(b^2 -4ac))/2a\nroot = b^2 -4ac\nif root < 0, no real roots thus no intersection\nif root = 0, one intersection.\notherwise 2.\nThe closest intersection (smallest t value) is what's needed (duh).\nAs the root is always positive for 2 intersections, can choose always-smaller root:\n\t(-b -sqrt(root))/2a\n\n*/\n    vec3 Rso = r.o - s.o;\n    \n    const float a = 1.0;\n    float b = 2.0*dot(Rso, r.d);\n    float c = dot(Rso, Rso) -s.r*s.r;\n    float root = b*b - 4.0*a*c;\n    if (root < 0.0)\n    {\n        return Collision(r, -1.0, r.o, black);;\n    }\n    else\n    {\n        return Collision(r, (-b -sqrt(root))/(2.0*a), s.o, s.col);\n        // return Collision(1.0, s.col);\n    }\n}\n\nCollision iYPlane(in Ray r, in YPlane p)\n{\n/*\nplane: y = p.y\nray: Ro + tRd\n\nintersect:\nRo.y + tRd.y = p.y\n\ntRd.y = p.y -Ro.y\nt = (p.y -Ro.y)/Rd.y\n*/\n    float t = (p.y - r.o.y)/r.d.y;\n    vec3 off = vec3(r.o + t*r.d);\n    return Collision(r, t, off, p.col);\n}\n\n// Collision castShadowRay(in Ray r)\n\nCollision castRay(in Ray r)\n{\n    float xs = sin(-0.5*4.0), ys = cos(-1.0*4.0);\n    Sphere s1 = Sphere(vec3(0.0, 1.5, 0.0), 1.5, red),\n        s2 = Sphere(vec3(5.0, 3.5, -7.0), 2.5, blue),\n        s3 = Sphere(vec3(-4.0*xs, 0.5, -3.0*ys), 0.5, red+green);\n    const YPlane p = YPlane(0.0, green);\n    Collision colmin = iSphere(r, s1);\n    \n    Collision colcur = iSphere(r, s2);\n    if ((colcur.t >= 0.0) && (colcur.t < colmin.t || colmin.t < 0.0))\n        colmin = colcur;\n   \t\n    colcur = iSphere(r, s3);\n    if ((colcur.t >= 0.0) && (colcur.t < colmin.t || colmin.t < 0.0))\n        colmin = colcur;\n    \n    colcur = iYPlane(r, p);\n    if ((colcur.t >= 0.0) && (colcur.t < colmin.t || colmin.t < 0.0))\n        colmin = colcur;\n\t\n    return colmin;\n}\n\nvec4 castShadowRay(in Collision c, in float ambiance)\n{\n    float xs = sin(iTime), ys = -cos(iTime);\n    \n    Light l = Light(vec3(-8.0*xs, 6.0, -5.0*ys), 5.0, white);\n    float rel_ambiance = 1.0/c.t;\n        \n    vec3 ray_orig = c.r.o + c.t*c.r.d;\n    \n    vec3 ray_dif = l.o - ray_orig;\n    vec3 ray_dir = normalize(ray_dif);\n    Ray r = Ray(ray_orig + (ray_dir*0.001), ray_dir);\n    Collision lc = castRay(r);\n    \n    float ang_f = ambiance + (1.0-ambiance)*dot(normalize(ray_orig-c.o), r.d); // 90' away from src = darker\n    float str = ((l.str+rel_ambiance)/length(ray_dif))*ang_f;\n    \n    vec4 col_v = (l.col*(ang_f)*0.5 + c.col*(1.5-ang_f))*str;\n    if (lc.t < 0.0)\n    {\n        return col_v;\n\t}\n    else\n    {\n        float blur = min(lc.t, 1.0);\n        return (col_v)*blur + (white*ambiance)*(rel_ambiance)*(1.0-blur);\n    }\n}\n\nvec4 trace(in Ray r, in float ambiance)\n{\n    return castShadowRay(castRay(r), ambiance);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 res_distort = normalize(iResolution.xy);   // To adjust distortion caused by width/height ratio\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) * 2.0 - 1.0) * res_distort;\n    \n\tfragColor = black;\n    \n    vec3 camera_orig = vec3(2.0, 1.5, 6.0);\n    vec3 camera_dir = vec3(-.05, -0.1, -1.0);\n    \n    // vec2 mouse_dir = (2.0*(iMouse.xy/iResolution.xy) - 1.0)*res_distort;\n    // vec3 mouse_3dir = vec3(-mouse_dir.x, 0.0, mouse_dir.y);\n    vec3 mouse_3dir = vec3(0.0, 0.0, 0.0);\n    \n    vec3 ray_orig = vec3(0.0, 0.0, 0.0) + camera_orig;\n    vec3 ray_dir = vec3(uv, 0.0) + camera_dir + mouse_3dir;\n    \n    vec3 dir_off = vec3(0.5/iResolution.xy, 0.0);\n    \n    float a = 0.3; //ambiance\n    \n    \n    // Cheap hacky 2xMSAA\n    Ray r1 = Ray(ray_orig, normalize(ray_dir)),\n    \tr2 = Ray(ray_orig, normalize(vec3(ray_dir.x+dir_off.x, ray_dir.yz))),\n        r3 = Ray(ray_orig, normalize(vec3(ray_dir.x-dir_off.x, ray_dir.yz))),\n        r4 = Ray(ray_orig, normalize(vec3(ray_dir.x, ray_dir.y+dir_off.y, ray_dir.z))),\n        r5 = Ray(ray_orig, normalize(vec3(ray_dir.x, ray_dir.y-dir_off.y, ray_dir.z))),\n        r6 = Ray(ray_orig, normalize(vec3(ray_dir.x+dir_off.x, ray_dir.y+dir_off.y, ray_dir.z))),\n        r7 = Ray(ray_orig, normalize(vec3(ray_dir.x+dir_off.y, ray_dir.y-dir_off.y, ray_dir.z))),\n        r8 = Ray(ray_orig, normalize(vec3(ray_dir.x-dir_off.x, ray_dir.y+dir_off.y, ray_dir.z))),\n        r9 = Ray(ray_orig, normalize(vec3(ray_dir.x-dir_off.y, ray_dir.y-dir_off.y, ray_dir.z)));\n\n\tfragColor = (trace(r1,a)*2.0\n                   + trace(r2,a) + trace(r3,a) + trace(r4,a) + trace(r5,a)\n                   + trace(r6,a) + trace(r7,a) + trace(r8,a) + trace(r9,a))/10.0;\n\t\n    /*\n    Ray r = Ray(ray_orig, normalize(ray_dir));\n    fragColor = trace(r, 0.1);\n\t*/\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld2SRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[458, 458, 500, 1451, 1821], [1823, 1823, 1865, 1971, 2082], [2122, 2122, 2151, 2151, 2875], [2877, 2877, 2932, 2932, 3718], [3720, 3720, 3761, 3761, 3811], [3813, 3813, 3870, 3870, 5655]], "test": "valid"}
{"id": "ld2SzD", "name": "Spinning planet", "author": "axelduch", "description": "not there yet", "tags": ["2d"], "likes": 2, "viewed": 177, "published": "Public", "date": "1409932614", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+ 0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv * 2.2 - 1.0;\n    \n\tvec2 rotationXY = vec2(0.6 * cos(iTime), 0.6 * sin(iTime));\n    // resize width so that it's not an ellipse but a circle\n    p.x *= iResolution.x / iResolution.y;\n    //p.xy += rotationXY;\n    \n    float brightness = 0.8;\n    float sphereScale = 0.7;\n    float radius = sqrt(dot(p, p));\n    vec3 diff = vec3(0.1, 0.1, 0.2);\n    vec3 spec = vec3(1.0);\n    vec2 lightPos = vec2(0.5, -0.5) * vec2(cos(iTime * 0.5) * -0.95, sin(iTime * 0.5));\n    \n    vec3 color = diff * 0.3;\n    vec3 bg = color;\n    \n    if (radius < sphereScale) {\n    \tcolor = diff + smoothstep(1.0, -0.3, noise(200.0 * mix(vec3(uv, 1.0), diff, 0.1 + 0.5 *sin(mod(iTime * 0.4 , 0.5)) * 0.5 + 0.5)));\n        \n    \tfloat f = 1.0 - smoothstep(-0.2, 0.6, length(p - lightPos));\n        color += f * spec * brightness;\n        \n        f = smoothstep(sphereScale * 0.98, sphereScale, radius);\n        color = mix(color, bg, f);\n    }\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld2SzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 237], [239, 239, 296, 296, 1311]], "test": "error"}
{"id": "ld2Szm", "name": "Floor with Starbox", "author": "xilconic", "description": "Continuation from https://www.shadertoy.com/view/lsSSRz by adding bumpmapped star in a box. Color shader from https://www.shadertoy.com/view/4sBSzw and normalmap shader from https://www.shadertoy.com/view/Ms2XDh.", "tags": ["procedural", "3d", "raymarching"], "likes": 1, "viewed": 191, "published": "Public", "date": "1411913983", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float PI=3.14159265;\n\n// ==== Brick flooring parameters ==============================\n// The width and height of a brick/mortar in [0,1] image space\n#define BRICKWIDTH 2.0\n#define BRICKHEIGHT 1.28\n#define MORTARTHICKNESS 0.16\n\n// Describes the width and height of a single brick 'feature' in image space.\n// A 'brick feature' is define as rectangle following:\n//    - Horizontally: mortar: [0, 0.5 * MORTARTHICKNESS]\n//                    brick : [0.5 * MORTARTHICKNESS, BRICKWIDTH + 0.5 * MORTARTHICKNESS]\n//                    mortar: [BRICKWIDTH + 0.5 * MORTARTHICKNESS, BRICKWIDTH + MORTARTHICKNESS]\n//    - Vertically  : mortar: [0, 0.5 * MORTARTHICKNESS]\n//                    brick : [0.5 * MORTARTHICKNESS, BRICKHEIGHT + 0.5 * MORTARTHICKNESS]\n//                    mortar: [BRICKHEIGHT + 0.5 * MORTARTHICKNESS, BRICKHEIGHT + MORTARTHICKNESS]\n#define BMWIDTH (BRICKWIDTH + MORTARTHICKNESS)\n#define BMHEIGHT (BRICKHEIGHT + MORTARTHICKNESS)\n\n// Describes the relative mortar boundary in normalized 'break feature' space [0,1]\n#define MWF (MORTARTHICKNESS * 0.5 / BMWIDTH)\n#define MHF (MORTARTHICKNESS * 0.5 / BMHEIGHT)\n// ============================================================\n\n// ==== Star on box parameters ================================\nconst vec3 starColor = vec3(1.0, 0.78, 0.05);\nconst vec3 starBG = vec3(0.0, 0.0, 1.0);\n\nconst float RMIN = 0.2; // Inner radius of the star, in uv space.\nconst float RMAX = 0.4; // Outer radius of the star, in uv space.\nconst float NUMBER_OF_STARTPOINTS = 5.0; // Number of star points; Should be integer!\n\n// Angle between 2 star points, in [rad]:\nconst float STAR_ANGLE = 2.0*PI / NUMBER_OF_STARTPOINTS; \nconst float HALF_STAR_ANGLE = 0.5 * STAR_ANGLE;\n\nconst vec2 starCentre = vec2(0.5,0.5); // @middle of the screen\nconst vec3 starCentre3D = vec3(starCentre, 0.0);\n\n// Real world size, dimensions and location of the box with the procedurally\n// generated star texture:\nconst float starImageSize = 2.0; \nconst vec3 boxDimensions = vec3(starImageSize, starImageSize, starImageSize);\nconst vec3 boxLocation = vec3(-25.0, -3.0, 0.0);\n// =============================================================\n\n/**\n * Distance function for a box.\n * @param p: worldspace position vector [x,y,z]\n * @param dimensions: worldspace dimensions of the box from its centre.\n * @return: The worldspace distance from the box\n * REMARKS: This function does not properly deal with distance inside a box!\n */\nfloat udBox(vec3 p, vec3 dimensions )\n{\n  return length(max(abs(p)-dimensions,0.0));\n}\n\n/**\n * Distance function for the star-box.\n * @param p: worldspace position vector [x,y,z]\n * @return: [distance, material definition index]\n */\nvec2 obj_box(in vec3 p){\n    vec3 displacedP = p - boxLocation;\n    return vec2(udBox(displacedP, boxDimensions), 1);\n}\n\n/**\n * Distance function for the floor at y == -5 (World space).\n * @param p: worldspace position vector [x,y,z]\n * @return: [distance, material definition index]\n */\nvec2 obj_floor(in vec3 p)\n{\n  return vec2(p.y+5.0,0);\n}\n\n/**\n * Performs a union of two distance functions with material index information.\n * @param obj0: Return result of some distance function that follows the pattern\n *              [distance, material definition index]\n * @param obj1: Return results of a different distance function that also follows\n *              the pattern [distance, material definition index]\n * @return: The union of these two results (basically returning the nearest result)\n * REMARK: This method does not properly deal with transparent objects!\n */\nvec2 obj_union(in vec2 obj0, in vec2 obj1)\n{\n  if (obj0.x < obj1.x)\n  \treturn obj0;\n  else\n  \treturn obj1;\n}\n\n/**\n * General distance function used in the shader.\n * @param p: worldspace position vector [x,y,z]\n * @return: [distance, material definition index]\n */\nvec2 distance_to_obj(in vec3 p)\n{\n    return obj_union(obj_floor(p), obj_box(p));\n}\n\n/**\n * Map the given location to the 'brick feature' space of the floor.\n * @param p: worldspace position vector [x,y,z]\n * @return: Return the feature space coordinates, range [0,1].\n */\nvec2 getBrickFeatureCoordinate(in vec3 p){\n    vec2 textureCoordinates = p.xz / vec2(BMWIDTH, BMHEIGHT);\n    \n    if (mod(textureCoordinates.y * 0.5, 1.0) > 0.5)\n    {\n        textureCoordinates.x += 0.5;\n    }\n    \n    float xBrick = floor(textureCoordinates.x);\n    textureCoordinates.x -= xBrick;\n    float yBrick = floor(textureCoordinates.y);\n    textureCoordinates.y -= yBrick;\n    \n    return textureCoordinates;\n}\n\n/**\n * Determine the color of the brick floor.\n * @param p: worldspace position vector [x,y,z]\n * @return The base RGB color at the given location.\n */\nvec3 floor_color(in vec3 p)\n{\n    // Material color information:\n    vec4 brickColor = vec4(0.5, 0.15, 0.14, 1.0); // RGBA\n    vec4 mortarColor = vec4(0.5, 0.5, 0.5, 1.0); // RGBA\n    \n    vec2 textureCoordinates = getBrickFeatureCoordinate(p);\n    \n    // Step functions describing when inside brick and when inside mortar:\n    float widthIndex = step(MWF, textureCoordinates.x) - step(1.0-MWF, textureCoordinates.x);\n    float heightIndex = step(MHF, textureCoordinates.y) - step(1.0-MHF, textureCoordinates.y);\n    \n    // Decide color for mortar or brick.\n    // widthIndex * heightIndex is basically AND-ing if inside width/height of a brick.\n    return mix(mortarColor.rgb, brickColor.rgb, widthIndex*heightIndex);\n}\n\n/**\n * Creates a 3D texture coordinate with respect to the centre of the star\n * in the XY plane z==0.0\n * @param r: Radius in texture coordinate space\n * @param angle: Angle in [rad], with respect to the top of the star.\n * @return: A 3D texture coordinate point\n */\nvec3 Get3DStarPointFromAngular(float r, float angle){\n    return starCentre3D + r * vec3(sin(angle), \n\t                               cos(angle), \n\t\t\t\t\t\t\t\t   0.0);\n}\n\n/**\n * Returns the color for the given location for the Cure with a star.\n * @param p: worldspace position vector [x,y,z]\n * @return: RGB color at that point\n */\nvec3 cube_color(in vec3 p)\n{\n    // Cube plane in YZ plane in range [boxLocation.ZY - starImageSize, boxLocation.ZY + starImageSize].\n    // Z is horizontal axis, Y is vertical axis.\n    // Map this range to [0, 1]:\n    vec2 uv = clamp((p.zy - boxLocation.zy + starImageSize)/ (2.0 * starImageSize), 0.0, 1.0);\n\n    // p0: Top of the star.\n    // p1: First clockwise notch of the star.\n    vec3 p0 = Get3DStarPointFromAngular(RMAX, 0.0);\n    vec3 p1 = Get3DStarPointFromAngular(RMIN, HALF_STAR_ANGLE);\n\t\n    vec3 edgeP0P1 = p1-p0; // Vector p0->p1\n    \n\t// Because the star is a rotational symmetric shape, mapping the uv \n\t// texture coordinates to polar coordinate system makes it easier\n\t// to define a feature space that makes up a star point.\n\t// \n    // Get angle and radius of uv point:\n    // Note: Angle is w.r.t edge starCentre->p0\n    vec2 uvWithRespectTostarCentre = uv - starCentre;\n\t// Angle w.r.t. edge starCentre->p0, in [rad: -PI, PI]\n    float angle = atan(uvWithRespectTostarCentre.x, uvWithRespectTostarCentre.y);\n    float r = length(uvWithRespectTostarCentre);\n    \n    // Map angle to feature space of 0 to STAR_ANGLE * 0.5, using mirroring \n\t// as it's a symmetric triangle around HALF_STAR_ANGLE.\n    float a = mod(angle, STAR_ANGLE);\n    if(a >= HALF_STAR_ANGLE){\n        a = STAR_ANGLE - a; // mirror\n    }\n    // a now in range [0, 0.5] * STAR_ANGLE\n    \n\t// uv mapped into the feature space as pUV\n\tvec3 pUV = Get3DStarPointFromAngular(r, a);\n    vec3 edgep0pUV = pUV - p0; // Vector p0->pUV\n    \n    // Determine if puv is inside the star or not, using corss product.\n    // Cross product yields negative z when inside star and positive z when outside star.\n    float in_out = step(0.0, cross(edgeP0P1, edgep0pUV).z);\n    return mix(starColor, starBG, in_out);\n}\n\n/**\n * Determine the base surface color for the given location and material id.\n * @param materialIndex: The material identifier.\n * @param position: worldspace position vector [x,y,z]\n * @return The base RGB color at the given location.\n */\nvec3 GetMaterialColor(float materialIndex, in vec3 position){\n\tif (materialIndex == 0.0){\n\t\treturn floor_color(position);\n\t}\n    else if (materialIndex == 1.0){\n        return cube_color(position);\n    }\n\treturn vec3(0,0,0);\n}\n\n/**\n * Calculated the bump height at the given location for the brick surface.\n * @param p: worldspace position vector [x,y,z], peturbed with bumpmapping.\n * @return The bump height at the given location, in range [0,1]\n */\nfloat calculateBumpHeight(in vec3 p){\n    vec2 textureCoordinates = getBrickFeatureCoordinate(p);\n    \n    float hu, hv;\n    \n    hu = smoothstep(0.0, MWF, textureCoordinates.x) - smoothstep(1.0-MWF, 1.0, textureCoordinates.x);\n    hv = smoothstep(0.0, MWF, textureCoordinates.y) - smoothstep(1.0-MWF, 1.0, textureCoordinates.y);\n    \n    return hu*hv;\n}\n\n/**\n * Determine normal using dFdx and dFdy, as presented in \"Texturing & Modelling: A Procedural Approach 3rd ed.\"\n * @param p: worldspace position vector [x,y,z], peturbed with bumpmapping.\n * @return The new surface normal for the floor, taking the mortar grooves into account.\n */\nvec3 calculateNormal(in vec3 p){\n    // Note: You could use facefoward instead of having to multiply dFdy with -1.0.\n    //       This however does increase the required parameters for this method.\n    \n    // Accuracy note: Estimate derivative by comparing to value calculated in a neighboring pixel.\n    //                This can lead to a more coarse estimation than doing a custom derivative instead.\n \treturn cross(dFdx(p), -1.0*dFdy(p));   \n}\n\n/**\n * Performs bump mapping for the floor (Material index == 0).\n * @param p: worldspace position vector [x,y,z]\n * @param globalNormalVector: Surface normal vector at @paramref(p)\n * @param useCustomDerivative: True if custom derivative code should be used; False if dFdx and dFdy should be used instead.\n * @return The new surface normal for the floor, taking the mortar grooves into account.\n */\nvec3 floor_bumpmap(in vec3 p, in vec3 globalNormalVector, bool useCustomDerivative){\n    float heightScaling = 0.01;\n    float heightIncrement = calculateBumpHeight(p);\n    \n    if(useCustomDerivative)\n    {\n        float dhdx = heightScaling * (calculateBumpHeight(vec3(p.x + 0.02, p.y, p.z)) - heightIncrement);\n        float dhdz = heightScaling * (calculateBumpHeight(vec3(p.x, p.y, p.z + 0.02)) - heightIncrement);\n\n        vec3 vector_dhdx = vec3(0.02, dhdx, 0.0);\n        vec3 vector_dhdz = vec3(0.0, dhdz, -0.02);\n    \n    \treturn normalize(cross(vector_dhdx, vector_dhdz));\n    }\n    else\n    {\n        return normalize(calculateNormal(p + globalNormalVector * (heightIncrement*heightScaling)));\n    }\n}\n\n/**\n * Calculate the surface normal for the Box with the Star.\n * @param p: worldspace position vector [x,y,z]\n * @param globalNormalVector: Estimated normal vector prior bumpmapping\n * @return: The normal vector at the given location taking bumpmapping into account.\n */\nvec3 starBox_bumpmap(in vec3 p, in vec3 globalNormalVector){\n    // Cube plane in YZ plane in range [boxLocation.ZY - starImageSize, boxLocation.ZY + starImageSize].\n    // Z is horizontal axis, Y is vertical axis.\n    // Map this range to [0, 1]:\n    vec2 uv = clamp((p.zy - boxLocation.zy + starImageSize)/ (2.0 * starImageSize), 0.0, 1.0);\n\n    // p0: Top of the star.\n    // p1: First clockwise notch of the star.\n    vec3 p0 = Get3DStarPointFromAngular(RMAX, 0.0);\n    vec3 p1 = Get3DStarPointFromAngular(RMIN, HALF_STAR_ANGLE);\n\t\n    vec3 edgeP0P1 = p1-p0; // Vector p0->p1\n    \n\t// Because the star is a rotational symmetric shape, mapping the uv \n\t// texture coordinates to polar coordinate system makes it easier\n\t// to define a feature space that makes up a star point.\n\t// \n    // Get angle and radius of uv point:\n    // Note: Angle is w.r.t edge starCentre->p0\n    vec2 uvWithRespectTostarCentre = uv - starCentre;\n\t// Angle w.r.t. edge starCentre->p0, in [rad: -PI, PI]\n    float angle = atan(uvWithRespectTostarCentre.x, uvWithRespectTostarCentre.y);\n    float r = length(uvWithRespectTostarCentre);\n    \n    // Map angle to feature space of 0 to STAR_ANGLE * 0.5, using mirroring \n\t// as it's a symmetric triangle around HALF_STAR_ANGLE.\n    float a = mod(angle, STAR_ANGLE);\n    if(a >= HALF_STAR_ANGLE){\n        a = STAR_ANGLE - a; // mirror\n    }\n    // a now in range [0, 0.5] * STAR_ANGLE\n    \n\t// uv mapped into the feature space as pUV\n\tvec3 pUV = Get3DStarPointFromAngular(r, a);\n    vec3 edgep0pUV = pUV - p0; // Vector p0->pUV\n    \n    // Determine if puv is inside the star or not, using corss product.\n    // Cross product yields negative z when inside star and positive z when outside star.\n    float in_out = step(0.0, cross(edgeP0P1, edgep0pUV).z);\n    \n    // Bump normal map:\n    float orientationAngle = angle;\n    if(orientationAngle < 0.0){\n        orientationAngle += 2.0*PI;\n    }\n    float starSectionIndex = floor(orientationAngle / HALF_STAR_ANGLE);\n\t\n    float rPn1, rPn2;\n    if (1.0 == mod(starSectionIndex, 2.0)){\n        // odd section (first clockwise is odd)\n        rPn1 = RMIN;\n        rPn2 = RMAX;\n    }\n    else {\n        // even section (second clockwise is even)\n        rPn1 = RMAX;\n        rPn2 = RMIN;\n    }\n\t\n\t// The section's face is described by the following three vertices in order:\n\tvec3 pnsc = vec3(starCentre, 0.8);\n\tvec3 pn1 = Get3DStarPointFromAngular(rPn1, (starSectionIndex + 1.0) * HALF_STAR_ANGLE);\n\tvec3 pn2 = Get3DStarPointFromAngular(rPn2, starSectionIndex * HALF_STAR_ANGLE);\n    \n\t// Find the normal using the normalized cross-product of the edge vectors.\n\t// See: http://www.opengl.org/wiki/Calculating_a_Surface_Normal\n    // Swizzle coordinates to map them back into real world:\n    vec3 vPnscPn1 = pn1.zyx - pnsc.zyx;\n    vec3 vPnscPn2 = pn2.zyx - pnsc.zyx;\n    \n    vec3 normalVector = normalize(globalNormalVector + cross(vPnscPn1, vPnscPn2));\n    \n    return mix(normalVector, globalNormalVector, in_out);\n}\n\n/**\n * Checks for bump map modifications to the given normal vector at the given location.\n * @param materialIndex: Index of the material (Produced by distance_to_obj)\n * @param position: worldspace position vector [x,y,z]\n * @param globalNormalVector: Surface normal vector at @paramref(position)\n * @param useCustomDerivative: True if custom derivative code should be used; False if dFdx and dFdy should be used instead.\n * @return The new surface normal, taking bump mapping into account.\n */\nvec3 EvaluateBumpMap(float materialIndex, in vec3 position, in vec3 globalNormalVector, bool useCustomDerivative){\n    if (materialIndex == 0.0){\n        return floor_bumpmap(position, globalNormalVector, useCustomDerivative);\n    }\n    if (materialIndex == 1.0){\n        return starBox_bumpmap(position, globalNormalVector);\n    }\n    return globalNormalVector;\n}\n\n/**\n * Estimates the surface normal of the distance field at a given position.\n * @param position: Final raymarched position.\n * @param originalDistance: distance from 'position' to the nearest object.\n * @return The unit normal vector.\n */\nvec3 EsitmateDistanceFieldNormal(in vec3 position, float originalDistance){\n\t// Note: Parameter 'originalDistance' can be removed be calling internally at loss of performance:\n\t//       float originalDistance = distance_to_obj(position);\n\t\n\t// Quick trick for generating small permutation of 'position'\n\tconst float derivativeDelta = 0.02;\n\tconst vec2 e = vec2(derivativeDelta,0); \n\t\n\t// Perform a discrete forward derivative:\n\tvec3 n = vec3(originalDistance - distance_to_obj(position - e.xyy).x,\n\t\t\t\t  originalDistance - distance_to_obj(position - e.yxy).x,\n\t\t\t\t  originalDistance - distance_to_obj(position - e.yyx).x);\n\t// Note: discrete central derivative could be used instead for more accuracy at cost of performace.\n\t\n\treturn normalize(n); // Normalization helps saving 3 divisions by 'derivativeDelta'\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized fragment coordinate in range [-0.5, 0.5]\n    vec2 vPos = fragCoord.xy/iResolution.xy - 0.5;\n    \n    if(abs(vPos.x) < 0.001){\n        fragColor = vec4(1.0,1.0,1.0,1.0);\n        return;\n    }\n\n\t// See the following URL for naming definitions:\n\t//   http://uploads.gamedev.net/monthly_03_2013/ccs-191720-0-04862100-1363766190.png\n    // Camera up vector, using positive y as 'up':\n    vec3 cameraUpVector = vec3(0,1,0);\n  \n    // Point where the camera is looking at:\n    vec3 cameraTarget = vec3(0,0,0);\n\n    // Map current clicked mouse position on radians [0, 2*PI] horizontally and [0, 0.5*PI) vertically:\n    // Note: 0.5 gives rendering problems if iMouse.Y == iResolution.y\n\t//       This is due to cameraViewDirection and cameraUpVector align perfectly, which causes the\n\t//       cross-product to yield 0. This prevents spanning the horizontal and vertical axis of the\n\t//       camera.\n    float mx = iMouse.x/iResolution.x * 2.0*PI;\n    float my = iMouse.y/iResolution.y * 0.49*PI; \n    \n    vec3 eyeWorldPosition = vec3(cos(my)*cos(mx),\n\t\t\t\t\t\t\t\t sin(my),\n\t\t\t\t\t\t\t\t cos(my)*sin(mx)) * 6.0;\n\n    // Camera setup.\n\t// 1. Get the unit vector for the central viewing direction of the camera:\n    vec3 cameraViewDirection = normalize(cameraTarget - eyeWorldPosition);\n\t\n\t// 2. Spanning the horizontal (u) and veritcal (v) unit vectors describing the camera view-plane axis:\n    vec3 u = normalize(cross(cameraUpVector, cameraViewDirection));\n    vec3 v = normalize(cross(cameraViewDirection, u));\n\t\n\t// 3. Determine the 'projection window' coordinate\n\t// 3.1 Determine the 'project window' center / the camera position:\n    vec3 cameraPosition = eyeWorldPosition + cameraViewDirection;\n\t// 3.2 Map vPos onto the 'project window', taking aspect ratio into account:\n    vec3 evaluatedCoordinate = cameraPosition +\n\t\t\t\t\t\t\t   vPos.x * u * iResolution.x/iResolution.y + // horizontal component\n\t\t\t\t\t\t\t   vPos.y * v; // vertical component\n    vec3 rayCastDirection = normalize(evaluatedCoordinate-eyeWorldPosition);\n\n    // Distance-aided ray marching\n    const float maxd = 100.0; //Max drawing distance from camera center\n    const float inverseMax = 1.0 / maxd;\n    \n    vec2 d = vec2(0.0, 0.0);\n    vec3 colorRGB, rayPosition, normal;\n\n    float rayDistanceTraveled = 1.0;\n    for(int i = 0; i < 256; i++) // maximum value affects horizon mapping/warping\n    {\n    \trayDistanceTraveled += d.x;\n    \trayPosition = eyeWorldPosition + rayCastDirection * rayDistanceTraveled;\n    \td = distance_to_obj(rayPosition);\n        \n        if ((abs(d.x) < .001) || (rayDistanceTraveled > maxd)) \n    \t\tbreak;\n  \t}\n  \n  \tif (rayDistanceTraveled < maxd)\n  \t{\n    \t// y is used to manage materials.\n\t\tcolorRGB = GetMaterialColor(d.y, rayPosition);\n    \n    \tnormal = EsitmateDistanceFieldNormal(rayPosition, d.x);\n      \n    \tnormal = EvaluateBumpMap(d.y, rayPosition, normal, vPos.x > 0.0);\n      \n\t\t// Rotating point light around [0,10,0]:\n\t\tconst float lightRadius = 20.0;\n\t\tvec3 lightPosition = vec3(sin(iTime)*lightRadius, 10.0, cos(iTime)*lightRadius);\n\t\t\n\t\t// Do simple phong lighting:\n    \tfloat b = clamp(dot(normal, normalize(eyeWorldPosition - rayPosition + lightPosition)),0.0,1.0);    \t\n    \tfragColor=vec4((b*colorRGB + pow(b,16.0)) * (1.0 - rayDistanceTraveled * inverseMax), 1.0);\n  \t}\n  \telse \n    \tfragColor=vec4(0,0,0,1); //background color\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ld2Szm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2162, 2448, 2487, 2487, 2534], [2536, 2681, 2705, 2705, 2800], [2802, 2969, 2996, 2996, 3024], [3026, 3552, 3596, 3596, 3660], [3662, 3817, 3850, 3850, 3900], [3902, 4090, 4132, 4132, 4511], [4513, 4665, 4694, 4729, 5387], [5389, 5657, 5710, 5710, 5822], [5824, 5986, 6014, 6201, 7778], [7780, 8022, 8083, 8083, 8248], [8250, 8474, 8511, 8511, 8828], [8830, 9115, 9147, 9520, 9564], [9566, 9966, 10050, 10050, 10678], [10680, 10952, 11012, 11199, 13942], [13944, 14440, 14554, 14554, 14804], [14806, 15047, 15122, 15349, 15859], [15861, 15861, 15918, 15974, 19281]], "test": "valid"}
{"id": "ldBSDh", "name": "Throbbing circle", "author": "s1mn", "description": "A simple circle. Click with the mouse to set the position. \n\nBased on https://www.shadertoy.com/view/XsjGDt by @jonobr1", "tags": ["2d", "simple", "circle", "geometry"], "likes": 1, "viewed": 231, "published": "Public", "date": "1411333843", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.1415926535897932384626433832795\n\n/**\n * Draw a circle at vec2 `pos` with radius `rad` and\n * color `color`.\n */\nvec4 circle(vec2 pos, float rad, vec3 color) {\n    // Get the distance of the current pixel from pos\n\tfloat distance = length(pos);\n    \n    // Get the difference between the distance and the radius\n    float drad = distance - rad;\n    \n\t// Constrain the difference to the range 0.0 - 1.0.\n\t// Pixels > rad away will end up with a value of 1.0, whereas\n\t// pixels < rad away will get 0.0.\n\tfloat t = clamp(drad, 0.0, 1.0);\n        \n    // Get the alpha for the pixel. Pixels > rad away get\n    // an alpha of 0.0, those within the radius get an\n    // alpha of 1.0.\n    float alpha = 1.0 - t;\n    \n\treturn vec4(color, alpha);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 center = iMouse.xy - fragCoord.xy;\n    \n    float radius = 0.1 * iResolution.y;\n    \n    // Make the circle \"pulse\"\n    float pulse_frequency = 2.0; // Hz\n    float pulse_factor = sin(iTime * M_PI * 2.0 * pulse_frequency);\n    radius = radius + radius * 0.05 * pulse_factor;\n    \n    // Background layer\n    vec3 gray = vec3(0.75, 0.75, 0.75);\n\tvec4 background = vec4(gray, 1.0);\n\t\n\t// Circle\n\tvec3 red = vec3(1.0, 0.0, 0.0);\n\tvec4 c = circle(center, radius, red);\n\t\n\t// Blend the two\n\tfragColor = mix(background, c, c.a);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldBSDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[48, 127, 173, 227, 754], [756, 756, 813, 813, 1348]], "test": "valid"}
{"id": "ldBSWW", "name": "colourmap play", "author": "foxiepaws", "description": "crap playing with the colour map till i find a cooler one,<br/>apparently trippy and awesome now according to IRC.", "tags": ["2d", "crap"], "likes": 10, "viewed": 330, "published": "Public", "date": "1411966443", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979323846\nvec3 colormap(float v,float t) {\n    if (t > 160.0) {\n        t = mod(t,160.0);\n    }\n    if (t < 15.0) {\n        t = 15.0;\n    }\n    float tt = (t * 10.0);\n    float r = ( .5 + .5 * sin(M_PI * v + tt/(v+3.0)));\n    float g = ( .5 + .5 * sin(M_PI * v + M_PI*2.0/(3.0+v)));\n    float b = ( .5 + .5 * sin(M_PI * v + M_PI*4.0/(3.0+v)));\n    return vec3(r,g,b);\n}\n\n\nfloat calc (float x, float y, float t) {\n    float v = 0.0;\n    \n    float ar = iResolution.x / iResolution.y;\n    float xx = ar* x / (iResolution.x)-ar/2.0;\n\tfloat yy = y / iResolution.y - .5;\n    float tt = t / 1.0;\n    \n    \n    float cx = xx + 0.5 * sin(tt / 5.0);\n    float cy = yy + 0.5 * cos(tt / 3.0);\n    \n    float v0 = sin((xx * 10.0) + tt);\n    float v1 = sin(10.0 * ( xx * sin(tt / 2.0) + yy * cos(tt / 3.0)));\n    float v2 = sin(sqrt(100.0*((cx*cx)+(cy*cy)))+1.0+tt);\n    \n    v = ((v0 + v1 + v2) + cos(v2 + yy + tt)) / 2.0;\n    \n    \n    return v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float v = calc(fragCoord.x,fragCoord.y,iTime);\n    \n\tfragColor = vec4(colormap(v,iTime),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldBSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[36, 36, 68, 68, 395], [398, 398, 438, 438, 962], [964, 964, 1021, 1021, 1121]], "test": "valid"}
{"id": "ldBXRw", "name": "Pool with water", "author": "predatiti", "description": "Incerc sa fac un bazin cu apa.\nDeformation of plane for simulation of water steal 10 fps. Why ?!?!?!?!?!?!?!?", "tags": ["pathtracing"], "likes": 16, "viewed": 835, "published": "Public", "date": "1410301194", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//use or not object raymarch in raytrace\n\nbool useRaymarch = false;\nconst float t = 16.0;//nr. sample per pixel\n\n\n#define pi acos(-1.0)\n#define pi2 pi/2.0\n\n//for transparency change, change first number in mref() to -1\nstruct Material\n{\n    vec4 color;\n    vec2 brdf;\n};\n\nstruct Sphere\n{\n\tvec4 center_radius;\n\tint idmaterial;\n};\n\nstruct Box\n{\n    vec3 min, max;\n   int idmaterial;\n};\n    \nstruct Cylinder \n{\n    vec3 c;\n    float r,h;\n    int idmaterial;\n};\n\nBox box0;\nSphere sfere[7];\nBox boxe[4];\nCylinder cylinder[4];\nMaterial material[6];\n\nvec3 light = vec3(0.0, 0.0, 0.0);\nvec3 pq, cub, lcub, nrm, crm;\nvec4 plane;\nvec2 planeStart = vec2(-10.0, 1.0);\nvec2 planeWidthHeight = vec2(20.0, 15.0);\nvec2 uvCoord;\nvec2 p,rv2;\nvec2 randv2;\nfloat side = 1.0;\nfloat time ;\nfloat f0, f1,f2,f3;\n\n\nvec2 rand2(){// implementation derived from one found at: lumina.sourceforge.net/Tutorials/Noise.html\n   randv2+=vec2(1.0,1.0);\n   return vec2(fract(sin(dot(randv2.xy ,vec2(12.9898,78.233))) * 43758.5453),\n      \t\t   fract(cos(dot(randv2.xy ,vec2(4.898,7.23))) * 23421.631));\n}\n\nvec3 CosineWeightedSampleHemisphere ( vec3 normal, vec2 rnd )\n{\n   //rnd = vec2(rand(vec3(12.9898, 78.233, 151.7182), seed),rand(vec3(63.7264, 10.873, 623.6736), seed));\n   float phi = acos( sqrt(1.0 - rnd.x)) ;\n   float theta = 2.0 * 3.14 * rnd.y ;\n\n   vec3 sdir = cross(normal, (abs(normal.x) < 0.5001) ? vec3(1.0, 0.0, 0.0) : vec3(0.0, 1.0, 0.0));\n   vec3 tdir = cross(normal, sdir);\n\n   return normalize(phi * cos(theta) * sdir + phi * sin(theta) * tdir + sqrt(1.0 - rnd.x) * normal);\n}\n\nvec3 cosPowDir(vec3  dir, float power) \n{//creates a biased random sample\n   vec2 r=rand2()*vec2(6.2831853,1.0);\n   vec3 sdir=cross(dir,((abs(dir.x)<0.5)?vec3(1.0,0.0,0.0):vec3(0.0,1.0,0.0)));\n   vec3 tdir=cross(dir,sdir); \n   r.y=pow(r.y,0.01/power);\n   float oneminus = sqrt(1.0-r.y*r.y);\n   return cos(r.x)*oneminus*sdir + sin(r.x)*oneminus*tdir + r.y*dir;\n}\n\nvec2 intersectCube(vec3 origin, vec3 ray, Box cube) {      \n   vec3   tMin = (cube.min - origin) / ray;      \n   vec3   tMax = (cube.max - origin) / ray;      \n   vec3     t1 = min(tMin, tMax);      \n   vec3     t2 = max(tMin, tMax);\n   float tNear = max(max(t1.x, t1.y), t1.z);\n   float  tFar = min(min(t2.x, t2.y), t2.z);\n   return vec2(tNear, tFar);   \n}\n\nvec3 normalForCube(vec3 hit, Box cube)\n{  \n   if(hit.x < cube.min.x + 0.0001) return vec3(-1.0, 0.0, 0.0);   \n   else if(hit.x > cube.max.x - 0.0001) return vec3( 1.0, 0.0, 0.0);   \n   else if(hit.y < cube.min.y + 0.0001) return vec3(0.0, -1.0, 0.0);   \n   else if(hit.y > cube.max.y - 0.0001) return vec3(0.0, 1.0, 0.0);      \n   else if(hit.z < cube.min.z + 0.0001) return vec3(0.0, 0.0, -1.0);   \n   else return vec3(0.0, 0.0, 1.0);   \n}\n\nfloat intersectSphere(vec3 origin, vec3 ray, Sphere s) {   \n   vec3 toSphere = origin - s.center_radius.xyz;      \n   float sphereRadius = s.center_radius.w;\n   float a = dot(ray, ray);      \n   float b = dot(toSphere, ray);   \n   float c = dot(toSphere, toSphere) - sphereRadius*sphereRadius;   \n   float discriminant = b*b - a*c;      \n   if(discriminant > 0.0) {      \n      float t = (-b - sqrt(discriminant)) ;   \n      if(t > 0.0) return t;      \n   }   \n   return 10000.0;   \n}  \n\nvec3 normalForSphere(vec3 hit, Sphere s) {   \n   return (hit - s.center_radius.xyz+pq) / s.center_radius.w;   \n} \n\nfloat iCylinder(vec3 ro, vec3 rd, Cylinder cylinder)\n{\n\tvec3  rc = ro - cylinder.c;\n    float a = dot( rd.xz, rd.xz );\n\tfloat b = dot( rc.xz, rd.xz );\n\tfloat c = dot( rc.xz, rc.xz ) - cylinder.r*cylinder.r;//0.249;\n\tfloat d = b*b - a*c;\n\tif( d>=0.0 )\n\t{\n\t\t// cylinder\t\t\t\n\t\tfloat s = (-b - sqrt( d ))/a;\n        float hy = ro.y+s*rd.y;\n\t\tif( s>0.0 && hy<cylinder.h && hy>-cylinder.h )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t\t// cap\t\t\t\n\t\ts = (cylinder.h - ro.y)/rd.y;\n\t\tif( s>0.0 && (s*s*a+2.0*s*b+c)<0.0 )\n\t\t{\n\t\t\treturn s;\n\t\t}\n\t}\n    return 100000.0;\n}\n\nvec3 normalforCylinder(vec3 hit,Cylinder cylinder)\n{\n    vec3 nor;\n\tnor.xz = hit.xz - cylinder.c.xz;\n    nor.y = 0.0;\n    nor = nor/cylinder.r;\n    return nor;\n}\n\nfloat iPlane1(vec3 ro, vec3 rd, in vec4 plane) {\n   return -(dot(ro, plane.xyz) + plane.w) / dot(rd, plane.xyz);\n}\n\nfloat iRectangle(vec3 ro, vec3 rd, in vec4 plane, in vec2 constraintsXY, in vec2 widthHeight, out vec2 uvCoord) {\n   float planeIntersection = iPlane1(ro,rd, plane);\n   vec3 hitPoint = ro + rd * planeIntersection;\n   if (hitPoint.z < constraintsXY.x || hitPoint.z > constraintsXY.x+widthHeight.x) {\n      planeIntersection = -1.0;\n   }\n   else if (hitPoint.x < constraintsXY.y || hitPoint.x > constraintsXY.y+widthHeight.y) {\n      planeIntersection = -1.0;\n   }\n   \n   if (planeIntersection >= 0.0) {\n      uvCoord = vec2(hitPoint.z - constraintsXY.x, hitPoint.y - constraintsXY.y);\n   }\n   else {\n      uvCoord = vec2(-1.0);\n   }\n   return planeIntersection;\n}\n\n//raymarch stuff\nfloat rmPlane(vec3 p, vec3 c, float d)\n{\n    vec4 n = vec4(0,1,0,d);\n   \treturn dot(p,n.xyz) + n.w;\n    vec3 pc = p-c;\n    if(pc.x>0.1 || pc.z>0.1) return 1000.0;\n    float f = dot((p-c),vec3(0.0,1.0,0.0));\n    return f;\n}\n\nfloat scene(vec3 p)\n{\n   float f = 1000.0;\n   time = iTime;\n    \n    float d = length(p.xz-vec2( 0.0, 0.0))*0.5;\n\tfloat h = 1.4 * cos( d*50.-time*4. ) * (1. - smoothstep( 0., 1.0, d) );\n    d = length(p.xz-vec2( 0.7, 0.7))*0.3;\n\th += 0.9 * cos( d*50.-time*4. ) * (1. - smoothstep( 0., 1.0, d) );\n    d = length(p.xz-vec2(-0.7, 0.7))*0.3;\n\th += 0.9 * cos( d*50.-time*4. ) * (1. - smoothstep( 0., 1.0, d) );\n    d = length(p.xz-vec2( 0.7,-0.7))*0.3;\n\th += 0.9 * cos( d*50.-time*4. ) * (1. - smoothstep( 0., 1.0, d) );\n    d = length(p.xz-vec2(-0.7,-0.7))*0.3;\n\th += 0.9 * cos( d*50.-time*4. ) * (1. - smoothstep( 0., 1.0, d) );\n    //p.y += h;\n    \n    float f1 = rmPlane(p, vec3(0.0,-0.2,0.0), h+0.2);\n    if(f1<f) f=f1;\n   return f;\n}\n\n//end raymarch stuff\n\nvoid initscene()\n{\n   light = vec3(cos(time *0.5)*1.65, sin(time*0.0)*0.65+0.7,   sin(time*0.5)*1.65);\ntime = 15.0 + iTime;\n    \n    float h = sin(time*3.0)*0.03;\n    float sinr = sin(time)*0.5; float cosr = cos(time)*0.5;\n    sfere[0].center_radius = vec4( 0.0, h-0.3, 0.0,    0.523);//rosu\n   \tsfere[1].center_radius = vec4( 0.0, h-0.29, 0.0,    0.520);//verde\n   \tsfere[2].center_radius = vec4(sinr, h+0.1,cosr,    0.123);//albastru\n   \tsfere[3].center_radius = vec4(-sinr, h+0.1,-cosr,    0.123);//rosu\n    sfere[4].center_radius = vec4(cosr, h+0.1,-sinr,    0.123);//verde\n    sfere[5].center_radius = vec4(-cosr, h+0.1,sinr,    0.123);//albastru\n    sfere[6].center_radius = vec4( light,               0.223);//light\n    \n    cylinder[0].c = vec3(-0.7,0.0,-0.7);\n    cylinder[0].r = 0.1;\n    cylinder[0].h = 1.0;\n    \n    cylinder[1].c = vec3(-0.7,0.0, 0.7);\n    cylinder[1].r = 0.1;\n    cylinder[1].h = 1.0;\n    \n    cylinder[2].c = vec3( 0.7,0.0,-0.7);\n    cylinder[2].r = 0.1;\n    cylinder[2].h = 1.0;\n    \n    cylinder[3].c = vec3( 0.7,0.0, 0.7);\n    cylinder[3].r = 0.1;\n    cylinder[3].h = 1.0;\n\n   \tbox0.min = vec3(-2.0, -1.0, -2.0);//room\n   \tbox0.max = vec3( 2.0,  1.5,  2.0);\n    \n    cub = vec3(0.0, 0.0, 0.0);\n   \tlcub = vec3(0.8, 1.1, 0.8);\n\n   \tboxe[2].min = cub - lcub;\n   \tboxe[2].max = cub + lcub;\n    \n    cub = vec3(0.0,- 0.3, 0.0);\n   \tlcub = vec3(1.5, 0.55, 0.5);\n\n   \tboxe[3].min = cub - lcub;\n   \tboxe[3].max = cub + lcub;\n    \n    plane = vec4(0.0, 1.0, 0.0, 0.2);\n   \tplaneStart = vec2(-2.0, -2.0);\n   \tplaneWidthHeight = vec2(4.0, 4.0);\n    \n    //vec4 mat[7];//vec3 color and float power of emisive\n\tmaterial[0].color = vec4(vec3(0.9 ,0.3 , 0.3), 0.0); //0 - rosu                    \n\tmaterial[1].color = vec4(vec3(0.3 ,1.9 , 0.3), 0.0); //1 - verde\n\tmaterial[2].color = vec4(vec3(0.3 ,0.3 , 1.9), 0.0); //2 - albastru\n\tmaterial[3].color = vec4(vec3(0.9 ,0.9 , 0.9), 0.0); //3 - cilinder\n    material[4].color = vec4(vec3(1.0 ,1.0 , 1.0), 0.0); //4 - box on wall\n    material[5].color = vec4(vec3(1.0 ,1.0 , 1.0), 1.0); //5 - light\n\n\t//reflect/refract(-1 <> 1) and difusse refl/refr (0 <> 1)\n\tmaterial[0].brdf = vec2( 0.0 ,10000.0 ); //0 - rosu               \n\tmaterial[1].brdf = vec2( 1.0 ,1.0 ); //1 - verde\n\tmaterial[2].brdf = vec2( 1.0 ,10000.0 ); //2 - albastru\n\tmaterial[3].brdf = vec2( 0.0 ,10.0 ); //3 - cilinder\n    material[4].brdf = vec2( 1.0 ,10000.0 ); //4 - box on wall\n    material[5].brdf = vec2( 0.0 ,0.0 ); //5 - light\n\n}\n\nvoid intersectscene(vec3 ro, vec3 rd, inout float t, inout int i)\n{\n    float tSphere6 = intersectSphere(ro, rd, sfere[6]);\n    if(tSphere6 < t) { t = tSphere6;i=6;}\n    \n    /*bool b = boxe[2].min.x <= ro.x && boxe[2].max.x >= ro.x &&\n              boxe[2].min.y <= ro.y && boxe[2].max.y >= ro.y &&\n              boxe[2].min.z <= ro.z && boxe[2].max.z >= ro.z;*/\n    bool b = ( all(lessThanEqual(boxe[2].min,ro)) && all(greaterThanEqual(boxe[2].max,ro)));\n    vec2 tbox = intersectCube(ro, rd, boxe[2]); \n    if(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t || b)\n    {    \n    \t/*bool b = boxe[3].min.x <= ro.x && boxe[3].max.x >= ro.x &&\n              \tboxe[3].min.y <= ro.y && boxe[3].max.y >= ro.y &&\n              \tboxe[3].min.z <= ro.z && boxe[3].max.z >= ro.z;*/\n        bool b = ( all(lessThanEqual(boxe[3].min,ro)) && all(greaterThanEqual(boxe[3].max,ro)));\n    \ttbox = intersectCube(ro, rd, boxe[3]); \n    \tif(tbox.x>0.0 && tbox.x<tbox.y && tbox.x < t || b)\n    \t{\n   \t\t\tfloat tSphere0 = intersectSphere(ro, rd, sfere[0]);\n   \t\t\tfloat tSphere1 = intersectSphere(ro, rd, sfere[1]);\n   \t\t\tfloat tSphere2 = intersectSphere(ro, rd, sfere[2]);\n   \t\t\tfloat tSphere3 = intersectSphere(ro, rd, sfere[3]);\n   \t\t\tfloat tSphere4 = intersectSphere(ro, rd, sfere[4]);\n   \t\t\tfloat tSphere5 = intersectSphere(ro, rd, sfere[5]);\n    \n   \t\t\tif(tSphere0 < t) { t = tSphere0;i=0;}\n   \t\t\tif(tSphere1 < t) { t = tSphere1;i=1;}   \n   \t\t\tif(tSphere2 < t) { t = tSphere2;i=2;}\n   \t\t\tif(tSphere3 < t) { t = tSphere3;i=3;} \n   \t\t\tif(tSphere4 < t) { t = tSphere4;i=4;} \n   \t\t\tif(tSphere5 < t) { t = tSphere5;i=5;} \n    \t}\n   \n\t\tfloat tcyl = iCylinder(ro, rd, cylinder[0]);\n    \tif(tcyl<t) {t = tcyl; i = 10;}\n    \ttcyl = iCylinder(ro, rd, cylinder[1]);\n    \tif(tcyl<t) {t = tcyl; i = 11;}\n    \ttcyl = iCylinder(ro, rd, cylinder[2]);\n    \tif(tcyl<t) {t = tcyl; i = 12;}\n    \ttcyl = iCylinder(ro, rd, cylinder[3]);\n    \tif(tcyl<t) {t = tcyl; i = 13;}\n    }\n    \n    float p = iRectangle(ro, rd, plane, planeStart, planeWidthHeight,uvCoord);\n   \tif(p>0.0 && p<t)\n   \t{\n      \tt = p; \n      \ti = 30;\n   \t}\n}\n\nvoid ColorAndNormal(vec3 hit, inout vec4 mcol, inout vec3 normal, vec2 tRoom, inout vec2 mref, inout float t, const int id)\n{\n\tif(t == tRoom.y)\n\t{            \n        mref = vec2(0.0,0.0);\n        normal =-normalForCube(hit, box0);   \n        if(abs(normal.x)>0.0)\n        {\n            mcol.xyz = vec3(0.3,0.3,0.3);\n            float gr = 2.0; float rost = 0.04;\n            float v0 = dot(vec3(gr, gr, 0),hit);\n            float v1 = dot(vec3(gr, 0, gr),hit);\n            v0 -= floor(v0);\n            v1 -= floor(v1);\n\t\t\tif(v0>rost && v1> rost)  mcol.xyz = vec3(0.99,0.99,0.99);\n            \n            vec3 tcol = texture(iChannel0,1.0-(hit.zy-vec2(1.5,1.5))/3.5).xyz;\n            float s = tcol.y+0.1;//-d\n            s = pow(1.0-s,3.0)*0.75+0.01;\n            mref = vec2(s,pow(1.0,1.0-s));\n        } \n         else if(abs(normal.y)>0.0)\n        {\n            mcol.xyz = vec3(0.3,0.3,0.3);\n            float gr = 2.0; float rost = 0.04;\n            float v0 = dot(vec3(0, gr, gr),hit);\n            float v1 = dot(vec3(gr, gr, 0),hit);\n            v0 -= floor(v0);\n            v1 -= floor(v1);\n\t\t\tif(v0>rost && v1> rost)  mcol.xyz = vec3(0.99,0.99,0.99);\n            \n            vec3 tcol = texture(iChannel0,1.0-(hit.xz-vec2(1.5,1.5))/3.5).xyz;\n            float s = tcol.y+0.1;//-d\n            s = pow(1.0-s,3.0)*0.75+0.01;\n            mref = vec2(s,pow(1.0,1.0-s));\n        } \n        else if(abs(normal.z)>0.0)\n        {\n            mcol.xyz = vec3(0.3,0.3,0.3);\n            float gr = 2.0; float rost = 0.04;\n            float v0 = dot(vec3(0, gr, gr),hit);\n            float v1 = dot(vec3(gr, 0, gr),hit);\n            v0 -= floor(v0);\n            v1 -= floor(v1);\n\t\t\tif(v0>rost && v1> rost)  mcol.xyz = vec3(0.99,0.99,0.99);\n            \n            //float d = mcol.x+mcol.y; \n\t\t\t//d = pow(d-1.0,2.0)*0.4;\n            vec3 tcol = texture(iChannel0,1.0-(hit.xy-vec2(1.5,1.5))/3.5).xyz;\n            float s = 1.0-tcol.y+0.1;//-d\n            s = pow(s,3.0)*0.75+0.01;\n            mref = vec2(s,pow(1.0,1.0-s));\n        }\n\t}     \n\telse   \n\t{\n\t\t     if(id==0) {normal = normalForSphere(hit, sfere[0]); mcol = material[0].color;mref = material[0].brdf;}\n        else if(id==1) {normal = normalForSphere(hit, sfere[1]); mcol = material[1].color;mref = material[1].brdf;}\n        else if(id==2) {normal = normalForSphere(hit, sfere[2]); mcol = material[2].color;mref = material[2].brdf;}\n        else if(id==3) {normal = normalForSphere(hit, sfere[3]); mcol = material[2].color;mref = material[2].brdf;}\n    \telse if(id==4) {normal = normalForSphere(hit, sfere[4]); mcol = material[2].color;mref = material[2].brdf;}\n        else if(id==5) {normal = normalForSphere(hit, sfere[5]); mcol = material[2].color;mref = material[2].brdf;}\n        else if(id==6) {normal = normalForSphere(hit, sfere[6]); mcol = material[5].color;mref = material[5].brdf;}\n    \telse if(id==10) {normal = normalforCylinder(hit, cylinder[0]); mcol = material[3].color;mref = material[3].brdf;}\n        else if(id==11) {normal = normalforCylinder(hit, cylinder[1]); mcol = material[3].color;mref = material[3].brdf;}\n        else if(id==12) {normal = normalforCylinder(hit, cylinder[2]); mcol = material[3].color;mref = material[3].brdf;}\n        else if(id==13) {normal = normalforCylinder(hit, cylinder[3]); mcol = material[3].color;mref = material[3].brdf;}\n\t\telse if(id==20) {normal = normalForCube(hit, boxe[0]); mcol = material[4].color;mref = material[4].brdf;}\n\t\telse if(id==21) {normal = normalForCube(hit, boxe[1]); mcol = material[4].color;mref = material[4].brdf;}\n        \n        if(id==30)//material for water\n        {\n            float e = 0.007;\n            normal = vec3((scene(hit + vec3(e, 0.0, 0.0)) - scene(hit - vec3(e, 0.0, 0.0)))/0.002*0.01, \n                        0.9,//scene(hit + vec3(0.0, e, 0.0)) - scene(hit - vec3(0.0, e, 0.0))/0.002*0.05, \n                      (scene(hit + vec3(0.0, 0.0, e)) - scene(hit - vec3(0.0, 0.0, e)))/0.002*0.01);\n\t\t\tnormal = normalize( normal);\n\n            mref = vec2(-1.0, 10000.0);// transparent, glossines\n            mcol.xyz = vec3(0.3,0.7,0.9);// color\n        }\n        \n        if(id>9 && id<20)// material for column\n        {\n            float u = atan(normal.z, normal.x) / 3.1415*2.0 ;\n            float v = hit.y;//asin(normal.y) / 3.1415*2.0 + 0.5;\n            vec3 tcol = vec3(mix(vec3(1.0),texture(iChannel2,vec2(u*1.55,1.-v*1.55)*0.75).rgb,0.8));\n            float s = pow(max(0.0,tcol.y+0.5),6.0);\n            s = 1.0-s+0.1;\n            s = pow(1.0-tcol.y+0.1,3.0)*0.75+0.01;\n            mref = vec2(max(0.0,s+0.3),100.0);\n            mcol.xyz = mix(vec3(1.0),tcol,0.9);\n            normal.xyz = normal.xyz + (tcol.xyz*2.0-1.0)*0.3;\n            if(dot(tcol,tcol)<0.25) {mcol.xyz = vec3(0.2,0.7,0.2); mref.x = 0.0;}\n            normal = normalize(normal);\n        }\n    }  \n}\n\nvec3 getColor(vec3 ro, vec3 rd)\n{\n    vec3 color = vec3(0.0);\n    vec3 col = vec3(1.0);\n    int id=-1;\n    int tm = -1;\n    \n    for(int i=0; i<5; i++)\n    {\n    \tfloat t = 10000.0; //seed++;\n\t\t\n   \t\tvec2 tRoom = intersectCube(ro, rd, box0);          \n   \t\tif(tRoom.x < tRoom.y)   t = tRoom.y; \n    \n    \tintersectscene(ro, rd, t, id);\n    \n    \tvec3 hit = ro + rd * t;        \n\t\tvec4 mcol = vec4(vec3(0.9),0.0);\n    \tvec3 normal; \n    \tvec2 mref = vec2(0);\n      \n    \tColorAndNormal(hit, mcol, normal, tRoom, mref, t, id);\n    \thit = hit + normal * 0.00001;\n         \n        vec2 rnd = rand2();\n        col *= mcol.xyz;\n        if(mcol.w>0.0) \n        {\n            if(i==0) {color = mcol.xyz; break;}\n            float df=max(dot(rd,-normal),0.0)*1.0; //if(tm==1) df *= 19.0;\n            color += col*mcol.xyz*mcol.w * df ;\n            if(tm==2) color += col * 1.0;;\n            break;\n        }\n\t\ttm = -1;\n        if(rnd.x>abs(mref.x))//diffuse\n        {\n        \trd = CosineWeightedSampleHemisphere ( normal, rnd);      \n        \ttm = 0;     \n        \tvec3 rl = sfere[6].center_radius.xyz;\n            if(rand2().x<0.0) rl = sfere[1].center_radius.xyz;\n        \trl = normalize(rl-hit);\n        \tfloat p =20.0; \n        \tp = max(0.0,dot(rd,rl))*p;\n        \trd = normalize(rd + rl*p);\n        \n        \tcol *= clamp(dot(normal,rd),0.0,1.0)*0.62;\n        }       \n        else \n        {\n            vec3 nrd = reflect(rd,normal); tm = 1;//reflect\n       \t\tif(mref.x<0.0)//refract\n            {\n                if(id==30)\n                    if(dot(rd,normal)>0.0) normal = -normal;\n            \tvec3 ior=vec3(1.0,1.52,1.0/1.12); tm = 2;\n           \t \tvec3 refr=refract(rd,normal,(side>=0.0)?ior.z:ior.y);//calc the probabilty of reflecting instead\n           \t \tvec2 ca=vec2(dot(normal,rd),dot(normal,refr)),n=(side>=0.0)?ior.xy:ior.yx,nn=vec2(n.x,-n.y);\n            \tif(rand2().y>0.5*(pow(dot(nn,ca)/dot(n,ca),2.0)+pow(dot(nn,ca.yx)/dot(n,ca.yx),2.0)))\n               \t\tnrd=refr;\n            }\n            rd = cosPowDir(nrd, mref.y);\n            col *= 1.2;\n        }\n        \n        ro = hit + rd * 0.0001; \n        \n        if(dot(col,col) < 0.1 && i>3) break;\n    }\n    \n \treturn color;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 q = fragCoord.xy/iResolution.xy;\n    p = -1.0+2.0*q;\n\tp.x *= iResolution.x/iResolution.y;\n    vec2 mo = iMouse.xy/iResolution.xy;\n\t\t \n\tfloat time = 15.0 + iTime;\n    float seed = iTime + iResolution.y *(p.x+1.0) + p.y;\n\t\n\trandv2=fract(cos((fragCoord.xy+fragCoord.yx*vec2(1000.0,1000.0))+vec2(iTime))*10000.0);\n\t\n    //move camera with mouse\n\tvec3 ro = vec3( 0.0+3.0*cos(8.0*mo.x), -0.9 + 2.5*(mo.y), 0.0 + 3.0*sin(8.0*mo.x) );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\t\n    //camera path\n    time = 0.2 * iTime;\n    vec3 path = vec3(sin(time*0.5)*2.0, sin(time)*0.7, cos(time*0.5)*2.0);    \n    ro = path; ta = path + vec3(-sin(time*0.5)*0.5+0.0, -cos(time)*0.2, -cos(time*0.5)*0.5+0.0);\n    \n    //view of raymarch\n    //ro = vec3(0.8,0.5, 1.5); ta = vec3(0.0,0.5, -1.0);\n\t// camera tx\n\tvec3 cw = normalize( ta-ro );\n\tvec3 cp = vec3( 0.0, 1.0, 0.0 );\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \n    f0 = texture( iChannel1, vec2( 0.01, 0.0 ) ).x;\n    f1 = texture( iChannel1, vec2( 0.56, 0.0 ) ).x;\n    f2 = texture( iChannel1, vec2( 0.96, 0.0 ) ).x;\n    \n    f0 = pow(f0*1.0,5.0);\n    \n    initscene();\n\t\n\tvec3 col = vec3(0.0);\n\n    for(float i=0.0; i<t; i++)\n    {\n        p += (rand2() * 2.0 - 1.0) * 0.5 / iResolution.x;\n        rd = normalize( p.x*cu + p.y*cv + 2.5*cw );\n    \tcol += getColor( ro, rd );\n    }\n\n    col = pow( clamp( col/t, 0.0, 1.0 ), vec3(0.65) );\n    //col.g += tc;\n    fragColor=vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "XsXGRr", "previewfilepath": "/media/ap/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/d96b229eeb7a08d53adfcf1ff89e54c9ffeebed193d317d1a01cc8125c0f5cca.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldBXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[790, 790, 803, 891, 1067], [1069, 1069, 1132, 1238, 1559], [1561, 1561, 1602, 1634, 1922], [1924, 1924, 1977, 1977, 2281], [2283, 2283, 2323, 2323, 2723], [2725, 2725, 2781, 2781, 3209], [3213, 3213, 3255, 3255, 3325], [3328, 3328, 3382, 3382, 3862], [3864, 3864, 3916, 3916, 4025], [4027, 4027, 4075, 4075, 4141], [4143, 4143, 4256, 4256, 4805], [4807, 4824, 4864, 4864, 5046], [5048, 5048, 5069, 5069, 5782], [5806, 5806, 5824, 5824, 8278], [8280, 8280, 8347, 8347, 10363], [10365, 10365, 10490, 10490, 15200], [15202, 15202, 15235, 15235, 17403], [17405, 17405, 17462, 17462, 18973]], "test": "error"}
{"id": "ldjSDR", "name": "Phantom Sea", "author": "glitchg", "description": "Sine wave experiment.", "tags": ["2d"], "likes": 1, "viewed": 154, "published": "Public", "date": "1411163792", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//based on code originally by bonniem: https://www.shadertoy.com/view/4dsGzH\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 wave_color = vec3(0.0);\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\tfloat wave_width;\n    \n    for(int i = 0; i < 10; i++) {\n\t\tuv  = -1.0 + 2.3 * uv;\n\t\tuv.y += (sin(iTime/2.0 + float(i))*sin(uv.x + iTime ));\n    \twave_width = 1.0 / (15.0 * uv.y);\n    \twave_color += vec3(wave_width, wave_width * 2.0, wave_width * 1.5);\n    }\n\t\n\t\n\tfragColor = vec4(wave_color, 1.0);\n\t\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldjSDR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[78, 78, 135, 135, 513]], "test": "valid"}
{"id": "ldSSD1", "name": "Wave Ripples", "author": "Xytor", "description": "Circular ripples extend from the mouse click position.", "tags": ["waves", "ripples", "distortion"], "likes": 30, "viewed": 2225, "published": "Public", "date": "1411421075", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    //Tweakable parameters\n    float waveStrength = 0.02;\n    float frequency = 30.0;\n    float waveSpeed = 5.0;\n    vec4 sunlightColor = vec4(1.0,0.91,0.75, 1.0);\n    float sunlightStrength = 5.0;\n    //\n    \n    vec2 tapPoint = vec2(iMouse.x/iResolution.x,iMouse.y/iResolution.y);\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float modifiedTime = iTime * waveSpeed;\n    float aspectRatio = iResolution.x/iResolution.y;\n    vec2 distVec = uv - tapPoint;\n    distVec.x *= aspectRatio;\n    float distance = length(distVec);\n    vec2 newTexCoord = uv;\n    \n    float multiplier = (distance < 1.0) ? ((distance-1.0)*(distance-1.0)) : 0.0;\n    float addend = (sin(frequency*distance-modifiedTime)+1.0) * waveStrength * multiplier;\n    newTexCoord += addend;    \n    \n    vec4 colorToAdd = sunlightColor * sunlightStrength * addend;\n    \n\tfragColor = texture(iChannel0, newTexCoord) + colorToAdd;\n}", "image_inputs": [{"id": "4sXGRn", "previewfilepath": "/media/ap/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/95b90082f799f48677b4f206d856ad572f1d178c676269eac6347631d4447258.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldSSD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 89, 957]], "test": "error"}
{"id": "ldSSRm", "name": "Grass close-up", "author": "Dave_Hoskins", "description": "Another attempt at rendering grass.", "tags": ["3d", "raymarching", "grass"], "likes": 13, "viewed": 1854, "published": "Public API", "date": "1410188124", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Grass close-up\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by David Hoskins.\n\n#define PRECISION 0.05\n#define MOD2 vec2(.16632,.17369)\n#define MOD3 vec3(.16532,.17369,.15787)\nvec3 sunDir = normalize(vec3(.2, 0.6, -1.3));\n\n//--------------------------------------------------------------------------------------------------\nvec3 TexCube(in vec3 p, in vec3 n )\n{\n    p *= vec3(.5, .1, .5);\n\tvec3 x = texture( iChannel0, p.yz, -100.0 ).xyz;\n\tvec3 y = texture( iChannel1, p.zx, -100.0 ).xyz;\n\tvec3 z = texture( iChannel2, p.xy, -100.0 ).xyz;\n\treturn x*abs(n.x) + y*abs(n.y) + z*abs(n.z);\n}\n\n//--------------------------------------------------------------------------------------------------\nvec2 Hash2(vec2 p)\n{\n\tvec3 p3 = fract(vec3(p.xyx) * MOD3);\n    p3 += dot(p3, p3.yzx+19.19);\n    return fract(vec2((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y));\n}\n\n\n//--------------------------------------------------------------------------------------------------\nvec2 Noise( in vec2 x )\n{\n    return mix(Hash2(floor(x)), Hash2(floor(x+1.0)), fract(x));\n}\n\n//--------------------------------------------------------------------------------------------------\nvec4 HashMove2(vec2 p)\n{\n    return vec4(Noise(p), Noise(p + iTime*.08));\n}\n\n//--------------------------------------------------------------------------------------------------\nvec4 Voronoi( vec3 p, out float which)\n{\n    \n    vec2 f = fract(p.xz);\n    p.xz = floor(p.xz);\n\tfloat d = 1.0e10;\n    vec3 id = vec3(0.0);\n    \n\tfor (int xo = -1; xo <= 1; xo++)\n\t{\n\t\tfor (int yo = -1; yo <= 1; yo++)\n\t\t{\n            vec2 g = vec2(xo, yo);\n            vec4 n = HashMove2(p.xz + g);\n\t\t\tvec2 tp = g + .5 + sin(p.y + 6.2831 * n.zw) - f;\n            float d2 = dot(tp, tp);\n\t\t\tif (d2 < d)\n            {\n                // 'which' is the colour code for each stem...\n                d = d2;\n                which = n.x*7.0+n.y*7.0;\n                id = vec3(tp.x, p.y, tp.y);\n            }\n\t\t}\n\t}\n    return vec4(id, 1.35-pow(d, .17));\n}\n\n\n//--------------------------------------------------------------------------------------------------\nfloat MapGrass( in vec3 pos)\n{\n    float which = 0.0;\n    vec4 ret = Voronoi(pos, which);\n    ret.w /= clamp(pos.y*.2, 0.0, 1.2);\n\treturn  .9-fract(which*382.321)*.15 + pos.y * .2 * smoothstep(6.5, 10.0, pos.y)-ret.w;\n}\n\n//--------------------------------------------------------------------------------------------------\nvec4 MapGrassID( in vec3 pos, out float which)\n{\n    vec4 ret = Voronoi(pos, which);\n    ret.w /= clamp(pos.y*.2, 0.0, 1.);\n\treturn vec4(ret.xyz, .9-fract(which*2.321)*.15 + pos.y * .2 * smoothstep(6.5, 10.0, pos.y) - ret.w);//+sin(floor(which)*5431.3)*1.2);\n}\n\n//--------------------------------------------------------------------------------------------------\nfloat Hash12(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\n\n//--------------------------------------------------------------------------------------------------\nvec4 Raymarch( in vec3 ro, in vec3 rd, in vec2 uv, out float which)\n{\n    const float grassTop = 7.5;\n\tfloat maxd = 400.0;\n\t\n    vec4 h = vec4(1.0);\n    float t = Hash12(uv*1.15231)*.2;\n    // Cast the ray down to the top of the grass\n    // Because we're not interested in anything else...\n    if (ro.y > grassTop && rd.y < 0.0)\n    {\n        float d = (ro.y-grassTop)/ -rd.y;\n        t += d;\n    }\n    vec3 po = vec3(20.0);\n    bool hit = false;\n    for (int i = 0; i < 75; i++)\n    {\n        po = ro + rd * t;    \n        h = MapGrassID(po, which);\t \n        if(h.w < PRECISION || t > maxd) break;\n        t += h.w *.65 + t * .001;\n    }\n\n    if (t > maxd || po.y > grassTop)t = -1.0;\n    \n    return vec4(h.xyz, t);\n}\n\n//--------------------------------------------------------------------------------------------------\nvec3 Normal( in vec3 pos, in float which)\n{\n    which *= 20.0;\n    vec2 eps = vec2(PRECISION, 0.0);\n\tvec3 norm = normalize( vec3(\n           MapGrass(pos+eps.xyy) - MapGrass(pos-eps.xyy),\n           MapGrass(pos+eps.yxy) - MapGrass(pos-eps.yxy),\n           MapGrass(pos+eps.yyx) - MapGrass(pos-eps.yyx) ) );\n    \n    // This squashes the Normal on a random x/z plane.\n\t// It fakes a flattened grass stem...\n\tmat2 angle = mat2(cos(which), sin(which), -sin(which), cos(which));\n\tnorm.xz *= angle * vec2(1.0, .01);\n\treturn normalize(norm);\n}\n\n//--------------------------------------------------------------------------\nfloat FractalNoise(in vec2 xy)\n{\n\tfloat w = 1.5;\n\tfloat f = 0.0;\n    xy *= .01;\n\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tf += texture(iChannel2, xy / w, -99.0).x * w;\n\t\tw *= 0.5;\n\t}\n\treturn f;\n}\n\n//--------------------------------------------------------------------------\nvec3 GetSky(in vec3 rd)\n{\n\tvec3 col = vec3(.65, .85, 1.0);\n\tcol \t\t= mix(col, vec3(.5), pow(abs(rd.y), .5));\n    return col;\n}\n//--------------------------------------------------------------------------\nvec3 GetClouds(in vec3 sky, in vec3 cameraPos, in vec3 rd)\n{\n\t//if (rd.y < 0.0) return sky;\n\t// Uses the ray's y component for horizon fade of fixed colour clouds...\n\tfloat v = (370.0-cameraPos.y)/rd.y;\n\trd.xz = (rd.xz * v + cameraPos.xz+vec2(0.0,0.0)) * 0.004;\n\tfloat f = (FractalNoise(rd.xz) -.5);\n\tvec3 cloud = mix(sky, vec3(1.0), max(f, 0.0));\n\treturn cloud;\n}\n\n//--------------------------------------------------------------------------------------------------\nvec3 Path( float time )\n{\n\treturn vec3(1.0+ 28.6*cos(0.2-0.5*.33*time*.75), 4.7, 5.7 - 27.0*sin(0.5*0.11*time*.75) );\n}\n\n//--------------------------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 q = fragCoord.xy / iResolution.xy;\n\tvec2 p = (-1.0 + 2.0*q)*vec2(iResolution.x / iResolution.y, 1.0);\n\t\n    // Camera...\n\tfloat off = iMouse.x*1.0*iMouse.x/iResolution.x;\n\tfloat time = 113.5+iTime + off;\n\tvec3 ro = Path( time+0.0 );\n    ro.y += 21.0-cos(time*.25+.54)*19.0;\n\tvec3 ta = Path( time+37.0 );\n\tta.y *= 1.0+sin(3.0+0.12*time) * .5;\n\tfloat roll = 0.3*sin(0.07*time);\n\t\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(roll), cos(roll), 0.0);\n\tvec3 cu = normalize(cross(cw,cp));\n\tvec3 cv = cross(cu,cw);\n\t\n\tfloat r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n\n\tvec3 rd = normalize( p.x*cu + p.y*cv + 2.1*cw );\n\tvec3 col;\n\n    vec3 background = GetSky(rd);\n    col \t\t= mix(vec3(.65, .85, 1.0), GetClouds(vec3(.5), ro, rd),\tpow(abs(rd.y), .5));\n\n\tfloat sun = clamp( dot(rd, sunDir), 0.0, 1.0 );\n\tfloat which;\n\tvec4 ret = Raymarch(ro, rd, q, which);\n    \n    if(ret.w > 0.0)\n\t{\n\t\tvec3 pos = ro + ret.w * rd;\n\t\tvec3 nor = Normal(pos, which);\n\t\tvec3 ref = reflect(rd, nor);\n\t\t\n\t\tfloat sun = clamp( dot( nor, sunDir ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, -sunDir ), 0.0, 1.0 );\n\t    float sha = clamp((pos.y*.85)-4.0, 0.0, 1.0);\n        \n\t\tvec3 lin = sun*vec3(.6) * sha;\n\t\tlin += vec3(bac*1.1, bac*.1, bac*3.7);\n        lin += vec3(clamp(pos.y - 5.0, 0.2, 1.0)) * .4;\n\n\t\tcol = TexCube(ret.xyz, nor);\n        vec3 grassCol =  vec3(.1+sin(which*2.2392)*.1, .7+abs(sin(which*2.2392)*.3), .0);\n        grassCol= mix(grassCol, vec3(.3, .3, .0), min(FractalNoise(pos.xz)*.7, 1.0)); \n        \n        \n\t\tcol = lin * col * grassCol * .9;\n        col += vec3(.7, 1.0, .5)*pow(clamp( dot( ref, sunDir ), 0.0, 1.0 ), .25) * .15 * sha;\n\t\t\n\t\tcol = mix(background, col, exp(-0.00002*max(ret.w*ret.w-1240.0, 0.0)) );\n\t}\n\n    col += vec3(.4, .4, .2)*pow( sun, 15.0 )*2.0*clamp( (rd.y+0.4) / .2,0.0,1.0);\n\n\tcol = clamp(sqrt(col), 0.0, 1.0);\n    //col *= 0.5 + 0.5*pow( 60.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.3 );\n\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldSSRm.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[278, 379, 416, 416, 641], [643, 744, 764, 764, 899], [902, 1003, 1028, 1028, 1094], [1096, 1197, 1221, 1221, 1272], [1274, 1375, 1415, 1415, 2023], [2026, 2127, 2157, 2157, 2346], [2348, 2449, 2497, 2497, 2709], [2711, 2812, 2834, 2834, 2962], [2965, 3066, 3135, 3135, 3787], [3789, 3890, 3933, 3933, 4428], [4430, 4507, 4539, 4539, 4695], [4697, 4774, 4799, 4799, 4899], [4900, 4977, 5037, 5142, 5341], [5343, 5444, 5469, 5469, 5563], [5565, 5666, 5723, 5723, 7702]], "test": "error"}
{"id": "ldSSzw", "name": "strobey", "author": "notoriousKnave", "description": "My first simple little thing... Not really sure what it's meant to be.", "tags": ["simple"], "likes": 2, "viewed": 158, "published": "Public", "date": "1410198201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate( vec2 inVec, float angle )\n{\n \tmat4 rotMatrix = mat4\n    (\n    \tcos( angle ),\t-sin( angle ),\t0,\t0,\n        sin( angle ), \tcos( angle ),\t0,\t0,\n        0,\t\t\t\t0,\t\t\t\t1,\t0,\n        0,\t\t\t\t0,\t\t\t\t0,\t1    );\n    \n    return ( vec4( inVec, 0.0, 1.0 ) * rotMatrix ).xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    \n    float offsetVal = iTime;\n    \n    vec2 uvR = uv;\n    uvR.y /= uvR.x;\n    uvR = rotate( uvR, offsetVal );\n    \n    vec2 uvG = uv;\n    uvG.x /= uvG.y;\n    uvG = rotate( uvG, -offsetVal );\n    \n    vec2 uvB = uv;\n    uvB.xy -= sin( offsetVal );\n    \n    fragColor = vec4( uvR.y * 0.5 + 0.5, uvG.y * 0.5 + 0.5, uvB.y * 0.5 + 0.5, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldSSzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 272], [274, 274, 331, 331, 717]], "test": "valid"}
{"id": "ldSXD1", "name": "TorusFan", "author": "gaz", "description": "3d", "tags": ["3d", "polygon"], "likes": 4, "viewed": 236, "published": "Public", "date": "1411481733", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t3.14159265359\n#define PI2\t( PI * 2.0 )\n\nvec2 rotate( in vec2 p, in float t )\n{\n\treturn p * cos( -t ) + vec2( p.y, -p.x ) * sin( -t );\n}   \n\nvec3 rotateX( in vec3 p, in float t )\n{\n    p.yz = rotate( p.yz, t );\n    return p;\n}\n\nvec3 rotateY( in vec3 p, in float t )\n{\n    p.zx = rotate( p.zx, t );\n    return p;\n}\n\nvec3 rotateZ( in vec3 p, in float t )\n{\n\tp.xy = rotate( p.xy, t );\n    return p;\n}\n\nstruct Mesh\n{\n    vec3 a;\n    vec3 b;\n    vec3 c;\n};\n\nconst float sepT = 8.0;\nconst float sepR = 10.0;\nconst float radT = 0.2;\nconst float radR = 0.5;\nconst float thetaT = PI2 / sepT;\nconst float thetaR = PI2 / sepR;\n\nMesh genTorus( in int idx )\n{\n    float i = float( idx );\n    float iT0 = mod( i, sepT );\n    float iR0 = floor( i / sepT );\n    float iT1 = iT0 + 1.0;\n    float iR1 = iR0 + 1.0;\n    float rad0 = radR + radT * cos( iT0 * thetaT );\n    float rad1 = radR + radT * cos( iT1 * thetaT );\n    float sin0 = sin( iR0 * thetaR );\n    float sin1 = sin( iR1 * thetaR );\n    float cos0 = cos( iR0 * thetaR );\n    float cos1 = cos( iR1 * thetaR );    \n    float h0 = radT * sin( iT0 * thetaT );\n    float h1 = radT * sin( iT1 * thetaT );    \n    //vec3 v0 = vec3( rad0 * sin0, h0, rad0 * cos0 );\n    vec3 v1 = vec3( rad1 * sin0, h1, rad1 * cos0 );\n    vec3 v2 = vec3( rad0 * sin1, h0, rad0 * cos1 );\n    vec3 v3 = vec3( rad1 * sin1, h1, rad1 * cos1 );\n    //if (idx < int( sepT * sepR ) ) return Mesh( v0, v1, v2 );\n    return Mesh( v3, v2, v1 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = ( 2.0 * fragCoord.xy - iResolution.xy ) / iResolution.y;\n    vec3 rd = normalize( vec3( p, -1.5 ) );\n\tvec3 ro = vec3( 0.0, -0.15, 0.8 + 0.1 * sin( iTime * 0.5 ) );\n    vec3 light = normalize( vec3( 0.5, 0.8, 3.0 ) );\n    float theta;\n\ttheta = -0.7;\n\tro = rotateX( ro, theta );\n\trd = rotateX( rd, theta );       \n    light = rotateX( light, theta );    \n\ttheta = 0.2 * sin( iTime * 0.3 );\n\tro = rotateZ( ro, theta );\n\trd = rotateZ( rd, theta );       \n    light = rotateZ( light, theta );    \n\ttheta = -iTime * 0.8;\n\tro = rotateY( ro, theta );\n\trd = rotateY( rd, theta );       \n    light = rotateY( light, theta );    \n        \n    vec3 col = vec3( 0.2, 0.2, 1.0 ) * ( 0.5 + 0.3 * p.y );\n\n    vec3 far =  ro + rd * 10.0;\n    vec3 nor;\n    float z = 2.0;\n    for (int i = 0; i <int( sepT * sepR ); i++ )\n   \t{\n\t\tMesh m = genTorus( i );\n        vec3 n = cross( m.c - m.a, m.b - m.a );\n\t    float a = dot( ro - m.a, n );\n   \t\tfloat b = dot( far - m.a, n );\n        if ( a * b < 0.0 )\n        {\n    \t\tfloat t = abs( a ) / ( abs( a ) + abs( b ) );\n\t\t\tvec3 p = ro + ( far - ro ) * t;\n            if ( dot( cross( m.b - m.a, n ), p - m.a ) > 0.0 ) \n            if ( dot( cross( m.c - m.b, n ), p - m.b ) > 0.0 ) \n            if ( dot( cross( m.a - m.c, n ), p - m.c ) > 0.0 )\n        \t{\n            \tif ( z > t )\n                {\n                  \tz = t;\n                    nor = normalize( n );\n                }\n            }                                \n        }            \n    }\n    if (z < 2.0)\n    {     \n    \tcol = vec3( 1.0, 0.5 + 0.2 * sin( iTime * 1.5 ), 0.2 );\n        if ( dot( nor, -rd ) < 0.0 )\n            col = vec3( 0.5 + 0.5 * sin( iTime ), 1.0, 0.5 + 0.5 * sin( iTime ) );\n        float br = abs( dot( nor, light ) );\n       \tbr = clamp( ( br + 0.5 ) * 0.7, 0.3, 1.0 );        \n        float fog = min( 1.0, 0.01 / z / z );       \n       \tcol *= br * fog;\n    }\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldSXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[51, 51, 89, 89, 146], [151, 151, 190, 190, 236], [238, 238, 277, 277, 323], [325, 325, 364, 364, 407], [627, 627, 656, 656, 1462], [1464, 1464, 1521, 1521, 3449]], "test": "valid"}
{"id": "ldSXRm", "name": "Hammer grid", "author": "rougier", "description": "Hammer projection (see http://en.wikipedia.org/wiki/Hammer_projection)\nBetter in full screen.\n", "tags": ["grid", "antialias", "projection", "distance", "polar", "hammer", "mercator", "cartesian"], "likes": 11, "viewed": 378, "published": "Public", "date": "1410253389", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Constants\nconst float M_PI    = 3.14159265358979323846;\nconst float M_SQRT2 = 1.41421356237309504880;\n\n\n\n// -------------------------------------------------\n// Hammer forward transform\n// ------------------------\nvec2 transform_forward(vec2 P)\n{\n    const float B = 2.0;\n    float longitude = P.x;\n    float latitude  = P.y;\n    float cos_lat = cos(latitude);\n    float sin_lat = sin(latitude);\n    float cos_lon = cos(longitude/B);\n    float sin_lon = sin(longitude/B);\n    float d = sqrt(1.0 + cos_lat * cos_lon);\n    float x = (B * M_SQRT2 * cos_lat * sin_lon) / d;\n    float y =     (M_SQRT2 * sin_lat) / d;\n    return vec2(x,y);\n}\n\n// Hammer Inverse transform\n// ------------------------\nvec2 transform_inverse(vec2 P)\n{\n    const float B = 2.0;\n    float x = P.x;\n    float y = P.y;\n    float z = 1.0 - (x*x/16.0) - (y*y/4.0);\n    if (z < 0.0)\n        discard;\n    z = sqrt(z);\n    float lon = 2.0*atan( (z*x),(2.0*(2.0*z*z - 1.0)));\n    float lat = asin(z*y);\n    return vec2(lon,lat);\n}\n// -------------------------------------------------\n\n\n\n\n// [-0.5,-0.5]x[0.5,0.5] -> [xmin,xmax]x[ymin,ymax]\n// ------------------------------------------------\nvec2 scale_forward(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P += vec2(.5,.5);\n    P *= vec2(limits[1] - limits[0], limits[3]-limits[2]);\n    P += vec2(limits[0], limits[2]);\n    return P;\n}\n\n// [xmin,xmax]x[ymin,ymax] -> [-0.5,-0.5]x[0.5,0.5]\n// ------------------------------------------------\nvec2 scale_inverse(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P -= vec2(limits[0], limits[2]);\n    P /= vec2(limits[1]-limits[0], limits[3]-limits[2]);\n    return P - vec2(.5,.5);\n}\n\n// Antialias stroke alpha coeff\nfloat stroke_alpha(float distance, float linewidth, float antialias)\n{\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n    if( border_distance > (linewidth/2.0 + antialias) )\n        return 0.0;\n    else if( border_distance < 0.0 )\n        return 1.0;\n    else\n        return alpha;\n}\n\n// Compute the nearest tick from a (normalized) t value\nfloat get_tick(float t, float vmin, float vmax, float step)\n{\n    float first_tick = floor((vmin + step/2.0)/step) * step;\n    float last_tick = floor((vmax + step/2.0)/step) * step;\n    float tick = vmin + t*(vmax-vmin);\n    if (tick < (vmin + (first_tick-vmin)/2.0))\n        return vmin;\n    if (tick > (last_tick + (vmax-last_tick)/2.0))\n        return vmax;\n    tick += step/2.0;\n    tick = floor(tick/step)*step;\n    return min(max(vmin,tick),vmax);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t// Cartesian limits\n\tvec4 u_limits1 = vec4(-3., +3., -1.5, +1.5);\n\n\t// Projected limits\n\tvec4 u_limits2 = vec4(-M_PI, M_PI- M_PI*(1.+cos(iTime))/2.0,\n                           -M_PI/2. + (1.+cos(iTime))/2.*M_PI/4.,\n                           +M_PI/2. - (1.+cos(iTime/2.))/2.*M_PI/4.);\n\n                          \n    const float u_antialias = 1.0;\n\tvec2 u_major_grid_step = vec2(M_PI/4.0,  M_PI/6.0);\n\tvec2 u_minor_grid_step = vec2(M_PI/40.0, M_PI/60.0);\n\tfloat u_major_grid_width = 2.00;\n\tfloat u_minor_grid_width = 1.00;\n\tvec4  u_major_grid_color = vec4(0,0,0,1);\n\tvec4  u_minor_grid_color = vec4(0,0,0,1);\n\n    \n    \n    \n    vec2 v_texcoord = fragCoord.xy / iResolution.xy - 0.5;\n    vec2 v_size = iResolution.xy;    \n\n    \n    vec2 NP1 = v_texcoord;\n    vec2 P1 = scale_forward(NP1, u_limits1);\n    vec2 P2 = transform_inverse(P1);\n\n    // Test if we are within limits but we do not discard yet because we want\n    // to draw border. Discarding would mean half of the exterior not drawn.\n    bvec2 outside = bvec2(false);\n    if( P2.x < u_limits2[0] ) outside.x = true;\n    if( P2.x > u_limits2[1] ) outside.x = true;\n    if( P2.y < u_limits2[2] ) outside.y = true;\n    if( P2.y > u_limits2[3] ) outside.y = true;\n\n    vec2 NP2 = scale_inverse(P2,u_limits2);\n    vec2 P;\n    float tick;\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_major_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float Mx = length(v_size * (NP1 - P));\n    // float Mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_minor_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float mx = length(v_size * (NP1 - P));\n    // float mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_major_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float My = length(v_size * (NP1 - P));\n    // float My = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_minor_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float my = length(v_size * (NP1 - P));\n    // float my = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    float M = min(Mx,My);\n    float m = min(mx,my);\n\n    // Here we take care of \"finishing\" the border lines\n    if( outside.x && outside.y ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = max(Mx,My);\n        }\n    } else if( outside.x ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = Mx;\n        }\n    } else if( outside.y ) {\n        if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = My;\n        }\n    }\n\n    // Mix major/minor colors to get dominant color\n    vec4 color = u_major_grid_color;\n    float alpha1 = stroke_alpha( M, u_major_grid_width, u_antialias);\n    float alpha2 = stroke_alpha( m, u_minor_grid_width, u_antialias);\n    float alpha  = alpha1;\n    if( alpha2 > alpha1*1.5 )\n    {\n        alpha = alpha2;\n        color = u_minor_grid_color;\n    }\n\n    // At no extra cost we can also project a texture\n    if( outside.x || outside.y ) {\n        fragColor = mix(vec4(1,1,1,1), color, alpha);\n    } else {\n        vec4 texcolor = texture(iChannel0, vec2(NP2.x+0.5, NP2.y+0.5));\n        fragColor = mix(texcolor, color, color.a*alpha);\n    }\n    // fragColor = mix(vec4(1,1,1,1), color, alpha);\n}\n\n", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ldSXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 217, 249, 249, 639], [641, 697, 729, 729, 998], [1056, 1160, 1201, 1237, 1371], [1373, 1477, 1518, 1554, 1678], [1680, 1712, 1782, 1782, 2157], [2159, 2215, 2276, 2276, 2671], [2675, 2675, 2732, 2754, 6584]], "test": "error"}
{"id": "lsBSDz", "name": "Polygons & Patterns", "author": "vgs", "description": "Simple patterns in a circle. The period of the animation is approximately 135s.", "tags": ["2d", "simple", "patterns", "geometric"], "likes": 58, "viewed": 1636, "published": "Public", "date": "1410919202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Vinicius Graciano Santos - vgs/2014\n// https://www.shadertoy.com/view/lsBSDz\n\n#define TAU 6.28318530718\n\nfloat segment(vec2 p, vec2 a, vec2 b) {\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float k = clamp(dot(ap, ab)/dot(ab, ab), 0.0, 1.0);\n    return smoothstep(0.0, 5.0/iResolution.y, length(ap - k*ab) - 0.001);\n}\n\nfloat shape(vec2 p, float angle) {\n    float d = 100.0;\n    vec2 a = vec2(1.0, 0.0), b;\n    vec2 rot = vec2(cos(angle), sin(angle));\n    \n    for (int i = 0; i < 6; ++i) {\n        b = a;\n        for (int j = 0; j < 18; ++j) {\n        \tb = vec2(b.x*rot.x - b.y*rot.y, b.x*rot.y + b.y*rot.x);\n        \td = min(d, segment(p,  a, b));\n        }\n        a = vec2(a.x*rot.x - a.y*rot.y, a.x*rot.y + a.y*rot.x);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 cc = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n        \n    float col = shape(abs(cc), cos(0.01*(iTime+22.0))*TAU);\n    col *= 0.5 + 1.5*pow(uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.3);\n    \n    \n\tfragColor = vec4(vec3(pow(col, 0.45)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsBSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 158, 158, 332], [334, 334, 368, 368, 760], [762, 762, 819, 819, 1119]], "test": "valid"}
{"id": "lsjSzw", "name": "sound-input-one", "author": "cybero", "description": "soundinputone, experimental rework of iq's sound input example https://www.shadertoy.com/view/Xds3Rr#", "tags": ["soundinputone"], "likes": 1, "viewed": 175, "published": "Public", "date": "1410466273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by inigo quilez - iq/2013\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nvec2 Distort(vec2 p)\n{\n    float theta  = atan(p.y, p.x);\n    float radius = length(p);\n    radius = pow(radius, 1.3);\n    p.x = radius * cos(theta);\n    p.y = radius * sin(theta);\n    return 0.5 * (p + 1.0);\n}\nvec4 pattern(vec2 p)\n{\n\tvec2 m=mod(p.xy+p.x+p.y,2.)-1.;\n\treturn vec4(length(m+p*0.1));\n}\n\nfloat hash(const float n)\n{\n\treturn fract(sin(n)*43758.5453);\n}\n\nfloat noise(const vec3 x)\n{\n\tvec3 p=floor(x);\n\tvec3 f=fract(x);\n\n    \tf=f*f*(3.0-2.0*f);\n\n    \tfloat n=p.x+p.y*57.0+p.z*43.0;\n\n    \tfloat r1=mix(mix(hash(n+0.0),hash(n+1.0),f.x),mix(hash(n+57.0),hash(n+57.0+1.0),f.x),f.y);\n    \tfloat r2=mix(mix(hash(n+43.0),hash(n+43.0+1.0),f.x),mix(hash(n+43.0+57.0),hash(n+43.0+57.0+1.0),f.x),f.y);\n\n\treturn mix(r1,r2,f.z);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // create pixel coordinates\n\tvec2 uv = (fragCoord.xy / (iResolution.xy / 0.4));\n\t//added by cybero\n\tfloat off = noise(uv.xyx + iTime);\n    vec4 c = pattern(Distort(uv*off));\n    c.xy = Distort(c.xy);\n\t// first texture row is frequency data\n\tfloat fft  = texture( iChannel0, vec2(uv.x,0.25) ).x; \n\t\n    // second texture row is the sound wave\n\tfloat wave = texture( iChannel0, vec2(uv.x,0.75) ).x;\n\t\n\t// convert frequency to colors\n\tvec3 col = vec3( fft, 4.0*fft*(1.0-fft), 1.0-fft ) * fft;\n\n    // add wave form on top\t\n\tcol += 1.0 -  smoothstep( 0.0, 0.15, abs(wave - uv.y) );\n\t\n\t// output final color\n\tfragColor = vec4(col.x * off, pow(sin(c.y) - off, 0.5), pow(cos(c.z), 3.0), 1.0);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsjSzw.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[0, 124, 146, 146, 334], [335, 335, 357, 357, 423], [425, 425, 452, 452, 488], [490, 490, 517, 517, 851], [852, 852, 909, 941, 1601]], "test": "error"}
{"id": "lsjXWh", "name": "Photo_Reproduction", "author": "Polytopes", "description": "I tried to reproduce a photo from a friend, I did a first pass on performances and optimisations, the framerate is still low for a medium end graphic c.\nOriginal picture from Roland Levesque: http://instagram.com/p/tQ9EaizRIC\nSee comments for more infos", "tags": ["architecture"], "likes": 24, "viewed": 989, "published": "Public", "date": "1411654203", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//-------------------------------------------------------------\n// Thanks to Beautypi (Iq and Pol Jeremias) for this wonderful sharing environment\n//-------------------------------------------------------------\n// Raymarching techniques by Iq\n//\t\thttp://www.iquilezles.org/www/articles\n//\t\tThanks a lot for all your papers and the clear explanations :)\n//-------------------------------------------------------------\n// Distance functions\n//\t\thttp://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n//\t\thttps://www.shadertoy.com/view/Xds3zN\n//-------------------------------------------------------------\n// CookTorrance shader:\n// \t\t- Background physics and math of shading (SIGGRAPH2013 papers)\n//      - Physically Based Shading at Pixar (SIGGRAPH2013 papers)\n//\t\t- Fresnel value set to 1.0 for all materials, I've played with\n//\t\t  roughness and reflectivity to achieve the needed result\n//-------------------------------------------------------------\n// Music only for atmosphere:\n//\t\tMost geometric person by Noby\n//-------------------------------------------------------------\n// Photo inspiration: \n//\t\thttp://instagram.com/p/tQ9EaizRIC by Roland Levesque\n//-------------------------------------------------------------\n\n//STRUCTS -----------------------------------------------------\n//Materials----------------------------------------------------\nstruct material \n{\n\tvec3\t\talbedo;\t\t\t\t// Albedo color\n\tfloat\t\troughness;\t\t\t// Roughness\n\tfloat\t\treflectivity;\t\t// Fraction of diffuse reflection\n};\n\n//RayIntersect-------------------------------------------------\nstruct rayIntersect \n{\n\tvec3\t\tmPos;\t\t\t\t//Pos\n\tvec3\t\tnor; \t\t\t\t//Normal\n\tfloat\t\tdist;\t\t\t\t//Distance\n\tmaterial\tmat; \t\t\t\t//Object material\n};\n//-------------------------------------------------------------\n\n//Lights ------------------------------------------------------\nstruct lightTube\n{\n\tvec3 tubeStart;\n    vec3 tubeEnd;\n\tvec3 color;\n};\n//-------------------------------------------------------------\n//END STRUCTS -------------------------------------------------\n\n//DEFINE VALUES -----------------------------------------------\n#define PI 3.14159\n\n#define EPSILON\t\t0.000001\t//min dist distance\n#define FARCLIP \t35.0\t\t//Far clip distance\n\n#define AMBIENT_COLOR vec3(1.0, 0.94510, 0.89412)\n\n#define BOXROOM_SIZE vec3(4.1, 2.6, 14.5)\n#define BOXROOM_POS vec3(0.0, 2.9, -9.5)\n\n#define ELEVATOR_SIZE vec3(0.3, 2.15, 1.0)\n#define ELEVATOR_POS vec3(1.4, -2.85, 2.0)\n\n#define TOP_ELEVATORBOX_SIZE vec3(0.02, 0.05, 1.0)\n#define TOP_ELEVATORBOX_POS vec3(1.4, -0.65, 2.0)\n    \n#define EXITDOOR_SIZE vec3(1.1, 2.95, 0.2)\n#define EXITDOOR_POS vec3(3.2, 2.95, -24.0)\n\n#define EXITDOOR_HSTROKE_SIZE vec3(1.1, 0.05, 0.05)\n#define EXITDOOR_HSTROKE_POS vec3(3.4, 4.3, -24.0)\n#define EXITDOOR_VSTROKE_SIZE vec3(0.07, 2.95, 0.05)\n#define EXITDOOR_VSTROKE_POS vec3(2.2, 2.95, -24.0)\n\n#define EXITDOOR_WINDOW_SIZE vec3(0.1, 0.5, 0.1)\n#define EXITDOOR_WINDOW_POS vec3(2.75, 3.25, -24.2)\n    \n#define PLINTHE_SIZE vec3(4.15, 0.095, 14.5)\n#define PLINTHE_POS vec3(0.0, 0.41, -9.5)\n\n#define Square_SIZE vec3(0.55, 0.55, 0.2)\n#define SquareL1_Front1 vec3(0.675, 4.6, -23.3)\n#define SquareL1_Front2 vec3(-0.475, 4.6, -23.3)\n#define SquareL1_Front3 vec3(-1.625, 4.6, -23.3)\n#define SquareL1_Front4 vec3(-2.775, 4.6, -23.3)\n\n#define SquareL2_Front1 vec3(0.675, 3.45,  -23.3)\n#define SquareL2_Front2 vec3(-0.475, 3.45, -23.3)\n#define SquareL2_Front3 vec3(-1.625, 3.45, -23.3)\n#define SquareL2_Front4 vec3(-2.775, 3.45, -23.3)\n\n#define SquareL3_Front1 vec3(0.675, 2.3,  -23.3)\n#define SquareL3_Front2 vec3(-0.475, 2.3, -23.3)\n#define SquareL3_Front3 vec3(-1.625, 2.3, -23.3)\n#define SquareL3_Front4 vec3(-2.775, 2.3, -23.3)\n\n#define SquareL4_Front1 vec3(0.675, 1.15,  -23.3)\n#define SquareL4_Front2 vec3(-0.475, 1.15, -23.3)\n#define SquareL4_Front3 vec3(-1.625, 1.15, -23.3)\n#define SquareL4_Front4 vec3(-2.775, 1.15, -23.3)\n\n//TOP squares\n#define SquareTOP_SIZE vec3(0.6, 0.1, 0.6)    \n#define SquareTOPL1_POS vec3(2.5, 0.01, 0.125)\n\n//Materials\n#define MarbleMatID 1.0\n#define MarbleMatAlbedo vec3(0.78431, 0.78431, 0.82353)\n#define MarbleMatRoughness 0.4\n#define MarbleMatReflectivity 0.35\n    \n#define BlackMarbleMatID 2.0\n#define BlackMarbleMatAlbedo vec3(0.35294, 0.34118, 0.40177)\n#define BlackMarbleMatRoughness 0.35\n#define BlackMarbleMatReflectivity 0.7\n    \n#define TopWhiteMatID 3.0\n#define TopWhiteMatAlbedo vec3(0.9)\n#define TopWhiteMatRoughness 0.175\n#define TopWhiteMatReflectivity 0.5\n\n#define BlackRoughMatID 4.0\n#define BlackRoughMatAlbedo vec3(0.055, 0.06, 0.065)\n#define BlackRoughMatRoughness 0.7\n#define BlackRoughMatReflectivity 0.95\n\n#define SquareOrangeMatID 5.0\n#define SquareOrangeMatAlbedo vec3(1.0, 0.32549, 0.10196)\n\n#define ElevBlackMatID 6.0\n#define ElevBlackMatAlbedo vec3(0.025)\n#define ElevBlackMatRoughness 0.9\n#define ElevBlackMatReflectivity 0.45\n    \n#define MetalMatID 7.0\n#define MetalMatAlbedo vec3(0.05)\n#define MetalMatRoughness 0.9\n#define MetalMatReflectivity 0.3\n\n#define SquareWhiteMatID 8.0\n#define SquareWhiteMatAlbedo vec3(1.0)\n\n#define CeilMatAlbedo vec3(0.1)\n#define CeilMatReflectivity 0.75\n\n//Map scene-----------------------------------------------------\n//Distance functions by Iq -------------------------------------\n// http://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// https://www.shadertoy.com/view/Xds3zN\n//--------------------------------------------------------------\n//Union\nvec2 OperationUnion(vec2 dist1, vec2 dist2)\n{\n    return (dist1.x < dist2.x) ? dist1 : dist2;\n}\n\nfloat OpU(float dist1, float dist2)\n{\n\treturn min(dist1, dist2);\n}\n\nvec2 OperationSoustraction(vec2 dist1, vec2 dist2)\n{\n    if (-dist2.x > dist1.x)\n        return vec2(-dist2.x, dist2.y);\n\n    return dist1;\n}\n\nfloat OpS(float dist1, float dist2)\n{\n\treturn max(-dist2, dist1);\n}\n\nfloat OpI(float dist1, float dist2)\n{\n\treturn max(dist1, dist2);\n}\n\nvec3 OperationRepetition(vec3 mPos, vec3 rep)\n{\n    return mod(mPos, rep) - 0.5 * rep;\n}\n\nfloat UnsignedDistBox(vec3 mPos, vec3 boxSize)\n{\n  return length(max(abs(mPos) - boxSize, 0.0));\n}\n\nfloat SignedDistBox(vec3 mPos, vec3 boxSize)\n{\n  vec3 d = abs(mPos) - boxSize;\n  return min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n}\n\nfloat SignedDistSphere(vec3 mPos, float rad)\n{\n    return length(mPos)- rad;\n}\n\n//--------------------------------------------------------------\n\nvec2 SceneDistance(vec3 mPos)\n{\n    vec2 room = vec2(-SignedDistBox(mPos - BOXROOM_POS, BOXROOM_SIZE), MarbleMatID);\n    \n\t// Plinthe\n    vec2 plinthe = vec2(SignedDistBox(mPos - PLINTHE_POS, PLINTHE_SIZE), BlackRoughMatID);\n    vec2 res = OperationSoustraction(room, plinthe);\n\n    // ************************************************ //\n    // Kind of \"plane tree\" in order to avoid calculate //\n    //          the useless parts of the scene          //\n    // ************************************************ //\n    // Right wall\n    if(mPos.x < -3.9)\n    {\n        float exclusionBox = SignedDistBox(mPos - vec3(0.0, 2.9, -15.0), vec3(4.5, 2.6, 6.0));\n        // Elevator box above\n        float elevatorStuff = OpI(exclusionBox, SignedDistBox(OperationRepetition(mPos - TOP_ELEVATORBOX_POS,\n                                                                                  vec3(11.0, 10.0, 3.5)),\n                                                              TOP_ELEVATORBOX_SIZE));\n        // Elevator call button\n        elevatorStuff = OpU(elevatorStuff, OpI(exclusionBox, \n                                               SignedDistBox(OperationRepetition(mPos - vec3(1.4, -3.0, 4.0),\n                                                                                 vec3(11.0, 11.0, 3.5)),\n                                                             vec3(0.05, 0.5, 0.125))));\n\n        res = OperationUnion(res, vec2(elevatorStuff, MetalMatID));\n\n        // Elevator floors\n        float elevatorFloor = OpI(exclusionBox, SignedDistBox(OperationRepetition(mPos - vec3(1.4, -0.75, 2.0),\n                                                                                  vec3(11.0, 11.0, 3.5)),\n                                                              vec3(0.01, 0.15, 0.3)));\n        res = OperationUnion(res, vec2(elevatorFloor, ElevBlackMatID));\n\n        float elev = OpI(exclusionBox, SignedDistBox(OperationRepetition(mPos - ELEVATOR_POS,\n                                                                         vec3(11.5, 10.0, 3.5)),\n                                                     ELEVATOR_SIZE));\n        res = OperationSoustraction(res, vec2(elev, ElevBlackMatID));\n    }\n    // Ground\n   \telse if(mPos.y < 0.4)\n    {\n        // Squares on ground\n        float exclusionBoxGround = SignedDistBox(mPos - vec3(0.0, 0.2, -9.5), vec3(3.65, 0.4, 14.5));\n        float squareGround = OpI(exclusionBoxGround, \n                              UnsignedDistBox(OperationRepetition(mPos - vec3(0.0, 5.21, 0.25), \n                                                                  vec3(5.0, 10.0, 1.5)),\n                                              vec3(3.9, 0.1, 0.5)));\n        res = OperationUnion(res, vec2(squareGround, BlackMarbleMatID));\n    }\n    // Top\n    else if(mPos.y > 5.1)\n    {\n        // Squares top\n        float exclusionBoxCeil = SignedDistBox(mPos - vec3(0.0, 5.5, -9.5), vec3(3.65, 0.4, 14.5));\n        float squareTop = OpI(exclusionBoxCeil, \n                              UnsignedDistBox(OperationRepetition(mPos - SquareTOPL1_POS, \n                                                                  vec3(1.25, 11.15, 1.3)),\n                                              SquareTOP_SIZE));\n\n        //Adding small bump distortion with Sin and Cos\n        res = OperationUnion(res, vec2(squareTop + ((sin(mPos.x * 12.5) + cos(mPos.z * 7.5))* 0.0005), TopWhiteMatID));\n\n\n        // Black spheres\n        float blackCylinder = OpI(exclusionBoxCeil, \n                                  SignedDistSphere(OperationRepetition(mPos - vec3(7.1, 1.575, 1.3),\n                                                                         vec3(8.0, 8.0, 3.8)),\n                                                     0.15));\n\n        res = OperationUnion(res, vec2(blackCylinder, BlackRoughMatID));\n    }\n    // Front\n    else if(mPos.z < -19.0)\n    {\n        // Exit door\n        float exitDoor = SignedDistBox(mPos - EXITDOOR_POS, EXITDOOR_SIZE);\n        res = OperationSoustraction(res, vec2(exitDoor, BlackRoughMatID));\n\n        float exitDoorStroke = SignedDistBox(mPos - EXITDOOR_HSTROKE_POS, EXITDOOR_HSTROKE_SIZE);\n        exitDoorStroke = OpU(exitDoorStroke, SignedDistBox(mPos - EXITDOOR_VSTROKE_POS, \n                                                           EXITDOOR_VSTROKE_SIZE));\n\n        res = OperationUnion(res, vec2(exitDoorStroke, BlackRoughMatID));\n\n        // Window\n        res = OperationSoustraction(res, vec2(SignedDistBox(mPos - EXITDOOR_WINDOW_POS, \n                                                              EXITDOOR_WINDOW_SIZE), SquareWhiteMatID));\n\n        // Door handle SignedDistSphere\n        res = OperationUnion(res, vec2(SignedDistSphere(mPos - vec3(2.45, 2.2, -24.2), 0.125)\n                                         , MetalMatID));\n\n        // Squares front\n        float frontWhiteSquares = UnsignedDistBox(mPos - SquareL1_Front1, Square_SIZE);\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL1_Front2, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL1_Front4, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL2_Front2, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL2_Front3, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL2_Front4, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL3_Front1, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL3_Front2, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL3_Front4, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL4_Front2, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL4_Front3, Square_SIZE));\n        frontWhiteSquares = min(frontWhiteSquares, UnsignedDistBox(mPos - SquareL4_Front4, Square_SIZE));\n\n        res = OperationUnion(res, vec2(frontWhiteSquares, SquareWhiteMatID));\n\n        float fOrSqr = UnsignedDistBox(mPos - SquareL1_Front3, Square_SIZE);\n        fOrSqr = OpU(fOrSqr, UnsignedDistBox(mPos - SquareL2_Front1, Square_SIZE));\n        fOrSqr = OpU(fOrSqr, UnsignedDistBox(mPos - SquareL4_Front1, Square_SIZE));\n\n        res = OperationUnion(res, vec2(fOrSqr, SquareOrangeMatID));\n\n        res = OperationUnion(res, vec2(UnsignedDistBox(mPos - SquareL3_Front3, \n                                                                     Square_SIZE), BlackRoughMatID));\n    }\n    \n    return res;\n}\n//--------------------------------------------------------------\n\n//Calculate normals--------------------------------------------\nvec3 CalcNormal(vec3 mPos)\n{\n\tvec3 eps = vec3(0.025, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t    SceneDistance(mPos + eps.xyy).x - SceneDistance(mPos - eps.xyy).x,\n\t    SceneDistance(mPos + eps.yxy).x - SceneDistance(mPos - eps.yxy).x,\n\t    SceneDistance(mPos + eps.yyx).x - SceneDistance(mPos - eps.yyx).x);\n\t\t\n\treturn normalize(nor);\n}\n//-------------------------------------------------------------\n\n//Calculate AO-------------------------------------------------\nfloat CalcAO(vec3 mPos, vec3 nor)\n{\n\tfloat totAO = 0.0;\n    float sca = 1.0;\n    for(int aoi = 0; aoi < 3; aoi++)\n    {\n        float hr = 0.01 + 0.025 * float(aoi + 2);\n        vec3 aoPos =  nor * hr + mPos;\n        float dd = SceneDistance(aoPos).x;\n        totAO += -(dd-hr)*sca;\n        sca *= 0.75;\n    }\n    return clamp(1.0 - 4.0 * totAO, 0.0, 1.0);\n}\n//-------------------------------------------------------------\n\n//-------------------------------------------------------------\n// Shading ----------------------------------------------------\n//-------------------------------------------------------------\nvec3 Shading(vec3 rayOrigin, vec3 rayDirection,\n               rayIntersect mIntersection, lightTube lig)\n{\n\tvec3 L0 = lig.tubeStart - mIntersection.mPos;\n\tvec3 L1 = lig.tubeEnd - mIntersection.mPos;\n\tvec3 r = reflect(-rayDirection, mIntersection.nor);\n    \n\tvec3 Ld\t= L1 - L0;\n\tfloat RoL0 = dot(vec3(r), L0);\n\tfloat RoLd = dot(vec3(r), Ld);\n\tfloat L0oLd = dot(L0, Ld);\n\tfloat distLd = length(Ld);\n\tfloat t = (RoL0 * RoLd - L0oLd) / (distLd * distLd - RoLd * RoLd);\n\tvec3 closestPoint = L0 + Ld * clamp(t, 0.0, 1.0);\n    \n\tvec3 LightDir = normalize(closestPoint);\n\t\n    float NdotV = clamp(dot(mIntersection.nor, -rayDirection), 0.0, 1.0);\n\tfloat NdotL = clamp(dot(mIntersection.nor, LightDir), 0.0, 1.0);\n    \n\t//ambient, AO, BRDF\n    float ao = CalcAO(mIntersection.mPos, mIntersection.nor);\n\tvec3 amb = 0.3 * clamp(0.5 + 0.5 * mIntersection.nor.y, 0.0, 1.0) * AMBIENT_COLOR * ao;\n\n\t//Diffuse\n\tvec3 diff = amb + mIntersection.mat.albedo - mIntersection.mat.reflectivity / (2.0 * PI);\n\tvec3 colorResult = diff * NdotL;\n\t\n\tif (NdotV * NdotL > 0.0)\n\t{\n\t\t//Half angle Vector\n\t\tvec3 HalfAngleV = normalize(-rayDirection + LightDir);\n\t\tfloat NdotH = clamp(dot(mIntersection.nor, HalfAngleV), 0.0, 1.0);\n\t\tfloat VdotH = clamp(dot(-rayDirection, HalfAngleV), 0.0, 1.0);\n        \n\t\t// R0 good air-dielectric interface for 1.4 < Nt < 2.2\n        // Variances in micro-surfaces will result in a brighter or dimmer fresnel\n        // Fresnel Schlick's approximation\n\t\tfloat F = pow(1.0 - VdotH, 5.0);\n        \n\t\t// Cook-Torrance Geometry function\n\t\tfloat NH2 = 2.0 * NdotH / VdotH;\n\t\tfloat G = min(1.0, min(NdotV, NdotL) * NH2);\n \n\t\t// Roughness Beckmann Distribution\n\t\tfloat sq_NdotH   = NdotH * NdotH;\n\t\tfloat sq_NdotH_M = sq_NdotH * (mIntersection.mat.roughness * mIntersection.mat.roughness);\n\t\tfloat D = exp((sq_NdotH - 1.0) / sq_NdotH_M) / (PI * sq_NdotH * sq_NdotH_M);\n\n\t\t//float brdf_spec = (F * D * G) / (NdotV * NdotL * 4.0);\n        float brdf_spec = (F * D * G) / 4.0;\n\t\tcolorResult += (1.0 - mIntersection.mat.reflectivity) * brdf_spec;\n    }\n\treturn colorResult * lig.color * ao;\n}\n//-------------------------------------------------------------\n\n//RaymarchScene-------------------------------------------------\nvec3 RayMarchScene(vec3 rayOrigin, vec3 rayDirection,\n                   inout rayIntersect mIntersection)\n{\n    float dist = EPSILON * 2.0;\n    float t = 0.5;\n    float m = -1.0;\n    \n    for(int i = 0; i < 45; i++)\n    {\n        if(abs(dist) < EPSILON || t > FARCLIP) \n            break;\n\n        t += dist;\n        vec2 res = SceneDistance(rayOrigin + rayDirection * t);\n        dist = res.x;\n\t    m = res.y;\n    }\n    \n    if(t > FARCLIP)\n        m = -1.0;\n    \n    vec3 pos = rayOrigin + t * rayDirection;\n    mIntersection.mPos = pos;\n    mIntersection.nor = CalcNormal(pos);\n    mIntersection.dist = t;\n    \n\tvec3 colorResult = vec3(0.0);\n\tif (t > EPSILON)\n\t{\n\t\tmaterial mat;\n\t\tmat.albedo = SquareWhiteMatAlbedo;\n\t\tmat.roughness = 0.5;\n\t\tmat.reflectivity = 0.7;\n\t\t\n        if(m - 0.5 <= MarbleMatID)\n        {\n            if(mIntersection.nor.z > 0.0)\n            {\n                mat.albedo = texture(iChannel0, (pos.xy)/5.0, -100.0).xxx * BlackMarbleMatAlbedo - 0.25;\n                mat.roughness = BlackMarbleMatRoughness;\n                mat.reflectivity = BlackMarbleMatReflectivity;\n            }\n            else if(mIntersection.nor.y < 0.0)\n            {\n                mat.albedo = CeilMatAlbedo;\n                mat.reflectivity = CeilMatReflectivity;\n            }\n            else\n            {\n                float r = texture(iChannel0, (pos.zy - pos.yx)/7.0, -100.0).x;\n                mat.albedo = r * MarbleMatAlbedo;\n                mat.roughness = MarbleMatRoughness;\n                mat.reflectivity = MarbleMatReflectivity + min(r * r, 0.3);\n            }\n        }\n        else if(m - 0.5 <= BlackMarbleMatID)\n        {\n            mat.albedo = texture(iChannel0, (pos.xz)/4.0, -100.0).xxx * BlackMarbleMatAlbedo - 0.15;\n\t\t\tmat.roughness = BlackMarbleMatRoughness;\n\t\t\tmat.reflectivity = BlackMarbleMatReflectivity;\n        }\n        else if(m - 0.5 <= TopWhiteMatID)\n        {\n            mat.albedo = TopWhiteMatAlbedo;\n\t\t\tmat.roughness = TopWhiteMatRoughness;\n\t\t\tmat.reflectivity = TopWhiteMatReflectivity;\n        }\n        else if(m - 0.5 <= BlackRoughMatID)\n        {\n            mat.albedo = BlackRoughMatAlbedo;\n\t\t\tmat.roughness = BlackRoughMatRoughness;\n\t\t\tmat.reflectivity = BlackRoughMatReflectivity;\n        }\n\t\telse if(m - 0.5 <= SquareOrangeMatID)\n\t\t{\n\t\t\tmat.albedo = SquareOrangeMatAlbedo;\n\t\t}\n        else if(m - 0.5 <= ElevBlackMatID)\n\t\t{\n\t\t\tmat.albedo = ElevBlackMatAlbedo;\n\t\t\tmat.roughness = ElevBlackMatRoughness;\n\t\t\tmat.reflectivity = ElevBlackMatReflectivity;\n\t\t}\n        else if(m - 0.5 <= MetalMatID)\n        {\n            mat.albedo = MetalMatAlbedo;\n\t\t\tmat.roughness = MetalMatRoughness;\n\t\t\tmat.reflectivity = MetalMatReflectivity;\n        }\n\n\n\t\t\n\t\tmIntersection.mat = mat;\n\t\t\n\t\t//Shading / lighting\n        lightTube lig;\n\t\tlig.tubeStart = vec3(0.675, 4.7, -22.8);\n        lig.tubeEnd = vec3(0.675, 1.25, -22.8);\n        lig.color = vec3(1.0, 0.9451, 0.92157);\n        \n        for (int i = 0; i < 4; i++)\n        {\n\t\t\tcolorResult += 0.5 * Shading(rayOrigin, rayDirection, mIntersection, lig);\n            lig.tubeStart.x -= 1.15;\n            lig.tubeEnd.x -= 1.15;\n        }\n\t}\n    return colorResult;\n}\n//--------------------------------------------------------------\n\n//Render the scene----------------------------------------------\nvec3 RenderScene(vec3 rayOrigin, vec3 rayDirection)\n{ \n\trayIntersect mIntersection;\n\tmIntersection.mPos = vec3(0.0);\n\tmIntersection.nor = vec3(0.0);\n\tmIntersection.dist = 0.0;\n\t\n\t// Opaque\n    vec3 accum = RayMarchScene(rayOrigin, rayDirection, mIntersection);\n    \n    //reflection\n\trayIntersect mIntersecReflect = mIntersection;\n\tvec3 rayDirReflect = reflect(rayDirection, mIntersecReflect.nor);\n\tvec3 rayOriginReflect = mIntersecReflect.mPos + EPSILON * rayDirReflect;\n\tfloat refl = 1.0;\n\n\tfor (float k = 1.0; k < 3.0; ++k)\n\t{\n\t\tmIntersecReflect.dist = -1.0;\n\t\trefl *= max(0.75 - mIntersection.mat.reflectivity, 0.0);\n\t\taccum += RayMarchScene(rayOriginReflect, rayDirReflect, mIntersecReflect) * refl;\n\n\t\tif ((mIntersecReflect.dist < EPSILON)) \n\t\t\tbreak;\n\t\t\n\t\trayOriginReflect = mIntersecReflect.mPos;\n\t\trayDirReflect = reflect(rayDirReflect, mIntersecReflect.nor);\n\t\trayOriginReflect += EPSILON * rayDirReflect;\n\t}\n    \n\treturn clamp(accum, 0.0, 1.0);\n}\n//--------------------------------------------------------------\n//END THE SCENE-------------------------------------------------\n\n//Post Process ------------------------------------------------\nvec3 GammaCorrection(vec3 colorResult)\n{\n\treturn pow(colorResult, vec3(0.45455));\n}\n\nvec3 Contrast(vec3 colorResult)\n{\n    return colorResult * 0.6 + 0.4 * colorResult * colorResult * (3.0 - 2.0 * colorResult);\n}\n\nvec3 Tint(vec3 colorResult)\n{\n    return colorResult * vec3(1.025, 1.02, 1.0);\n}\n\nvec3 Vigneting(vec3 colorResult, vec2 fragCoord)\n{\n\tvec2 inXYPos = (fragCoord.xy / iResolution.xy);\n\treturn colorResult * (0.55 + 0.45 * pow(70.0 * inXYPos.x * inXYPos.y * (1.0 - inXYPos.x) * (1.0 - inXYPos.y), 0.15));\n}\n\nvoid ApplyPostProcess(inout vec3 colorResult, vec2 fragCoord)\n{\n    colorResult = GammaCorrection(colorResult);\n    colorResult = Contrast(colorResult);\n    colorResult = Tint(colorResult);\n    colorResult = Vigneting(colorResult,fragCoord);\n}\n//-------------------------------------------------------------\n\n//Post CameraDirection -----------------------------------------\nvec3 GetCameraRayDir(vec2 mUV, in vec3 camPosition, vec3 camTarget)\n{\n\tvec3 forwardVector = normalize(camTarget - camPosition);\n\tvec3 rightVector = normalize(cross(vec3(0.0, 1.0, 0.0), forwardVector));\n\tvec3 upVector = normalize(cross(forwardVector, rightVector));\n    \n\tvec3 camDirection = normalize(\tmUV.x * rightVector \n                                  +\tmUV.y * upVector\n                                  +\t5.0 * forwardVector);\n    \n\treturn camDirection;\n}\n//--------------------------------------------------------------\n\n//Screen coordinates ------------------------------------------\nvec2 GetScreenSpaceCoord(vec2 fragCoord)\n{\n\tvec2 mUV = (fragCoord.xy/iResolution.xy) * 2.0 - 1.0;\n\tmUV.x *= iResolution.x / iResolution.y;\n\n\treturn mUV;\t\n}\n//-------------------------------------------------------------\n\n//Main loop-----------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mUV = GetScreenSpaceCoord(fragCoord);\n\n    //Camera --------------------------------------------------------\n    float mTime = sin(iTime / 10.0) * 0.1;\n    vec3 rayOrigin = vec3(-mTime, 3.0, 5.0);\n    vec3 camTarget = vec3(mTime, 2.95, 0.0);\n    \n    vec3 rayDirection = GetCameraRayDir(mUV, rayOrigin, camTarget);\n    //END CAMERA ----------------------------------------------------\n\n    vec3 mColor = RenderScene(rayOrigin, rayDirection);\n    \n    ApplyPostProcess(mColor,fragCoord);\n\n    fragColor = vec4(mColor, 1.0);\n}\n//--------------------------------------------------------------\n", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsjXWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[5101, 5419, 5464, 5464, 5514], [5516, 5516, 5553, 5553, 5582], [5584, 5584, 5636, 5636, 5725], [5727, 5727, 5764, 5764, 5794], [5796, 5796, 5833, 5833, 5862], [5864, 5864, 5911, 5911, 5952], [5954, 5954, 6002, 6002, 6052], [6054, 6054, 6100, 6100, 6200], [6202, 6202, 6248, 6248, 6280], [6348, 6348, 6379, 6379, 13021], [13088, 13152, 13180, 13180, 13479], [13545, 13609, 13644, 13644, 13967], [14033, 14225, 14332, 14332, 16310], [16376, 16441, 16549, 16549, 19605], [19672, 19737, 19790, 19790, 20694], [20826, 20890, 20930, 20930, 20973], [20975, 20975, 21008, 21008, 21102], [21104, 21104, 21133, 21133, 21184], [21186, 21186, 21236, 21236, 21406], [21408, 21408, 21471, 21471, 21651], [21717, 21782, 21851, 21851, 22244], [22311, 22375, 22417, 22417, 22530], [22596, 22661, 22718, 22718, 23252]], "test": "error"}
{"id": "lsjXWz", "name": "By mistake", "author": "giacomo", "description": "Nice effect when I was experimenting with Shadertoy", "tags": ["2d", "moire", "pattern"], "likes": 3, "viewed": 399, "published": "Public", "date": "1411088077", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    float xCirculo = fragCoord.x - iResolution.x * 0.5;\n    float yCirculo = fragCoord.y - iResolution.y * 0.5;\n    float funcionCirculo = xCirculo * xCirculo + yCirculo * yCirculo;\n    float intensidad1 = sin(funcionCirculo * iTime * 0.003) * 1.0;\n   \tfloat intensidad2 = sin(funcionCirculo * iTime * 0.005 + 0.5) * 1.2;\n    float intensidad3 = sin(funcionCirculo * iTime * 0.007 + 0.7) * 1.3;\n\n    float r = sin(fragCoord.x / iResolution.x) * intensidad1;\n    float g = sin(iTime + 0.2) * intensidad2;\n    float b = sin(iTime + 0.5) * intensidad3;\n\tfragColor = vec4(\n\n        r, \n        g, \n        b, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsjXWz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 672]], "test": "valid"}
{"id": "lsSSW1", "name": "GpuTechConf example", "author": "ga2arch", "description": "taken from gpu conf video", "tags": ["3d", "mix", "blend", "gputechconf", "conf"], "likes": 1, "viewed": 192, "published": "Public", "date": "1411410876", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float map(in vec3 p) {\n    \n    vec3 q = mod(p+2.0, 4.0)-2.0;\n    \n \tfloat d1 = length(q) - 1.0;\n    \n    d1 += 0.1*sin(10.0*p.x)*sin(10.0*p.y + iTime )*sin(10.0*p.z);\n    \n \tfloat d2 = p.y + 1.0;\n    \n    float k = 1.0;\n    float h = clamp(0.5 + 0.5 *(d1-d2)/k, 0.0, 1.0);\n        \n    return mix(d1, d2, h) - k*h*(1.0-h);\n}\n\nvec3 calcNormal(in vec3 p) {\n    vec2 e = vec2(0.0001, 0.0);\n     \n    return normalize(vec3( map(p+e.xyy) - map(p-e.xyy),\n                           map(p+e.yxy) - map(p-e.yxy),\n                           map(p+e.yyx) - map(p-e.yyx)));\n\t\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    \n    p.x *= iResolution.x / iResolution.y;\n    \n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    vec3 rd = normalize(vec3(p, -1.0));\n    \n    vec3 col = vec3(0.0);\n    \n    float tmax = 20.0;\n\tfloat h = 1.0;\n    float t = 0.0;\n    for (int i=0; i<100; i++) {\n    \t\n        if (h < 0.0001 || t > tmax) break;\n        \n        h = map(ro + t*rd);   \n        t += h;\n    }\n    \n    vec3 lig = vec3(0.5773);\n    \n    if (t<tmax) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n    \tcol = vec3(1.0);\n        col = vec3(1.0, 0.8, 0.5)*clamp(dot(nor, lig), 0.0, 1.0);\n        col += vec3(0.2, 0.3, 0.4)*clamp(nor.y, 0.0, 1.0);\n        col += 0.1;\n        col *= exp(-0.1*t);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsSSW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 325], [327, 327, 355, 355, 567], [569, 569, 626, 626, 1425]], "test": "valid"}
{"id": "lsSSzm", "name": "Schleimbold", "author": "jonaskoehler", "description": "slimy slimy slimy - you can move around it per drag & drop", "tags": ["raymarching"], "likes": 0, "viewed": 192, "published": "Public", "date": "1410227569", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Really messy, silly hacked and slimy\n\n// The ray\nstruct Ray {\n    vec3 p;\n    vec3 d;\n};\n\n// A Light\nstruct Light {\n\tvec3 p;\n    vec4 df;\n    vec4 sp;\n};\n    \n// A Sphere\nstruct Sphere {\n\tvec3 c;\n    float r;\n    int i;\n};\n    \n// Constants\nconst float EPSILON = 2.0;\nconst int MAX_ITERATIONS = 50;\n\n// Colors\nconst vec4 WHITE = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 BLACK = vec4(0.0, 0.0, 0.0, 1.0);\nconst vec4 COLOR1 = vec4(0.65, 0.65, 0.55, 1.0);\n\nvec4 lightColor0 = vec4(normalize(vec3(1.0,0.95,0.9)), 1.0);\nvec4 lightColor1 = vec4(normalize(vec3(1.0) - lightColor0.rgb), 1.0);\n\n// Lights\nconst int numLights = 2;\nLight lights[2];\n\n// Spheres\nconst int numSpheres = 4;\nSphere spheres[numSpheres];\n\n// taken from Neil Mendosa's awesome website http://www.neilmendoza.com/\n// to be honest: i was too lazy to write that on my own...\nmat4 rotationMatrix(vec3 axis, float angle)\n{\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,\n                0.0,                                0.0,                                0.0,                                1.0);\n}\n\n// taken from IQ's awesome website http://www.iquilezles.org/\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )/k;\n}\n\n// Sphere distance function\nfloat sphere (vec3 point, Sphere sphere) {\n    //if (point.z > sphere.c.z) { return 99999.9; }\n\treturn abs(distance(point, sphere.c) - sphere.r);\n}\n\n// Define some displacement\nvec3 getDisplacement (vec3 p, vec3 n, float o) {\n\tfloat f = -1.2 - 1.1*sin(0.6*iTime + o)*sin(5.0*n.x + 0.9*iTime + o) * sin(5.0*n.y + 0.85*iTime + o) * sin(5.0*n.z + iTime + o);\n\tfloat g = 0.4 + 0.3*sin(0.2*iTime + o)*sin(30.0*n.x + 0.9*iTime + o) * sin(30.0*n.y + 0.85*iTime + o) * sin(20.0*n.z + iTime + o);\n    return vec3(p.x + (g+f) * n.x, \n                p.y + (g+f) * n.y, \n                p.z + (g+f) * n.z);\n}\n\nfloat displacedSphere (vec3 point, Sphere s) {\n    vec3 p = getDisplacement(point, normalize(point - s.c), float(s.i));    \n\tfloat d1 = sphere(p, s);\n    return d1;\n}\n\nvoid setupLights () {\n    lights[0] = Light(vec3(-200,0,0), lightColor0, lightColor0);\n    lights[1] = Light(vec3(200,0,0), lightColor1, lightColor1);\n}\n\nvoid animateLights () {\n\tfloat a = cos(0.1*iTime);\n    float b = sin(0.1*iTime);\n    lights[0].p.x = a * 100.0;\n    lights[0].p.z = b * 100.0;\n    lights[1].p.x = -a * 100.0;\n    lights[1].p.z = -b * 100.0;\n}\n\n// Define some spheres\nvoid setupSpheres () {\n    for (int i=0; i<numSpheres; ++i) {        \n    \tspheres[i] = Sphere(vec3(0.0, 0.0, 100.0), 10.0, i);\n    }\n}\n\n// Animate the spheres\nvoid animateSpheres () {\n    for (int i=0; i<numSpheres; ++i) {\n        float f = 0.5 + 0.5*float(i+1) / float(numSpheres);\n    \tspheres[i].c.x += f * cos(float(i) + 0.5*float(i+1)*iTime + spheres[i].c.x) * 12.0;\n        spheres[i].c.z += f * sin(float(i) + 0.7*float(i+1)*iTime + spheres[i].c.z) * 12.0;\n        spheres[i].c.y += f * sin(float(i) + 0.6*float(i+1)*iTime + spheres[i].c.y) * cos(float(i) * 0.06*iTime + spheres[i].c.y) * 12.0;;\n    }\n}\n\n\n\n// Scene distance function\nfloat getDistance (vec3 point) {    \n    float minDistance = displacedSphere(point, spheres[0]);\n    for (int i=1; i<numSpheres; ++i) {\n    \tminDistance = smin(minDistance, displacedSphere(point, spheres[i]), 0.4);\n    }\n    \n\treturn minDistance; \n}\n\n\nfloat dx (vec3 point) {\n\treturn getDistance(vec3(point.x + 0.5 * EPSILON, point.yz))\n        - getDistance(vec3(point.x - 0.5 * EPSILON, point.yz));\n}\n\nfloat dy (vec3 point) {\n\treturn getDistance(vec3(point.x, point.y + 0.5 * EPSILON, point.z))\n        - getDistance(vec3(point.x, point.y - 0.5 * EPSILON, point.z));\n}\n\nfloat dz (vec3 point) {\n\treturn getDistance(vec3(point.xy, point.z + 0.5 * EPSILON))\n        - getDistance(vec3(point.xy, point.z - 0.5 * EPSILON));\n}\n\nvec3 getNormal (vec3 point) {\n\treturn normalize(vec3(dx(point), dy(point), dz(point)));\n}\n\nvec3 transform (mat4 m, vec3 p) {\n    p.y += 2.0;\n    p.z -= 105.0;\n    p = (m * vec4(p, 1.0)).xyz;\n    p.z += 105.0;\n    p.y -= 2.0;\n    return p;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    float aspectRatio = iResolution.y / iResolution.x;\n    \n    // Setup a camera\n    float depth = 1.0;\n    vec3 pos = vec3(uv - vec2(0.5), 0.0);\n    pos.y *= aspectRatio;\n    vec3 dir = normalize(pos - vec3(0,0,-depth));\n    Ray ray = Ray(pos, dir);\n    \n    float alpha = 3.14*(-(iMouse.x / iResolution.x));\n    float beta = 3.14*((-iMouse.y / iResolution.y));\n    mat4 t = mat4(1.0, 0.0, 0.0, 0.0, \n                  0.0, 1.0, 0.0, 0.0,\n                  0.0, 0.0, 1.0, 100.0,\n                  0.0, 0.0, 0.0, 1.0);\n    mat4 t_inv = mat4(1.0, 0.0, 0.0, 0.0, \n                  \t  0.0, 1.0, 0.0, 0.0,\n                      0.0, 0.0, 1.0, -100.0,\n                      0.0, 0.0, 0.0, 1.0);\n    mat4 rotx = rotationMatrix(vec3(0.0, 1.0, 0.0), alpha);\n    mat4 roty = rotationMatrix(vec3(0.0, 0.0, 1.0), beta);\n    \n    mat4 m = roty * rotx;\n    //ray.p = (m * vec4(ray.p, 1.0)).xyz;\n    //ray.d = (m * vec4(ray.d, 0.0)).xyz;\n\n    //ray.p = (m * vec4(ray.p, 1.0)).xyz;\n    //ray.d = (m * vec4(ray.d, 0.0)).xyz;\n\n    \n    setupLights();\n    \n    // Setup geometry\n    setupSpheres();\n    \n\n    \n    // Animate spheres\n    animateSpheres();\n    \n    //animateLights();\n    \n    float a = clamp(dot(normalize(lights[0].p), vec3(0.0, 0.0, -1.0)), 0.2 , 1.0); \n    float b = clamp(dot(normalize(lights[1].p), vec3(0.0, 0.0, -1.0)), 0.2 , 1.0); \n    \n    // Rendering loop\n    float currentDistance;\n\tvec4 resultColor = vec4(a * lights[0].df.rgb + b * lights[1].df.rgb, 1.0);\n    resultColor.rgb *= 0.1;\n    \n    float numHits = 0.0;\n    float normalFlip = 1.0;\n    bool blockHit = false;\n\n    for (int i=0; i < MAX_ITERATIONS; ++i) {\n        vec3 point = transform(m, ray.p);\n        \n        \n        currentDistance = getDistance(point);\n        \n        if (currentDistance < EPSILON ) {\n            resultColor = BLACK;\n            numHits += 1.0;\n            \n        \tvec3 normal = getNormal(point);\n        \tfor (int i=0; i<numLights; ++i) {       \n                vec3 lightp = transform(m, lights[i].p);\n                vec3 lightDir = normalize(lightp - point);\n                float diffuse = dot(normal, lightDir);\n                vec3 reflectedLightDir = reflect(lightDir, normal);\n                float specular = clamp(dot(reflectedLightDir, ray.d), 0.0, 1.0);                \n                specular = pow(specular, 800.1);            \n                resultColor += vec4(vec3(0.1*diffuse * lights[1-i].df + diffuse * lights[i].df + 0.5*specular * lights[i].sp), 1.0);\n                \n            }\n            break;\n        } \n        ray.p += 0.5 * currentDistance * ray.d;\n    }\n    \n    resultColor.rgb /= float(numLights);\n    \n\tfragColor = vec4(resultColor);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsSSzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[704, 836, 881, 881, 1509], [1511, 1609, 1650, 1650, 1721], [1723, 1751, 1793, 1845, 1898], [1900, 1928, 1976, 1976, 2348], [2350, 2350, 2396, 2396, 2516], [2518, 2518, 2539, 2539, 2670], [2672, 2672, 2695, 2695, 2880], [2882, 2905, 2927, 2927, 3040], [3042, 3065, 3089, 3089, 3516], [3520, 3547, 3579, 3579, 3796], [3799, 3799, 3822, 3822, 3949], [3951, 3951, 3974, 3974, 4117], [4119, 4119, 4142, 4142, 4269], [4271, 4271, 4300, 4300, 4360], [4362, 4362, 4395, 4395, 4511], [4513, 4513, 4570, 4570, 7293]], "test": "valid"}
{"id": "lsSXDD", "name": "ConcentricCirclesAnimation", "author": "abhi_bansal", "description": "Overlapping concentric circles with animated position and radius", "tags": ["2d", "circles", "animation", "cocentric"], "likes": 2, "viewed": 223, "published": "Public", "date": "1412076162", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Ref: http://adrianboeing.blogspot.in/2011/01/xor-demoeffect-in-webgl.html\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = sin(iTime);\n    float offset = 0.3 * time;\n    \n    // The first step is to calculate the position of the pixel on the screen \n    // (or canvas in case of WebGL) normalised from -1 to 1\n\tvec2 p = -1.0 + 2.0 * fragCoord.xy / iResolution.xy;\n    \n    // 0,0 is origin we calculate distance from origin and set is as color \n    // r = x^2 + y^2\n    vec2 p1 = p - offset;\n\tfloat radius = sqrt(dot(p1, p1)) * time;\n    \n    // get a second circle radius\n    vec2 p2 = p + offset;\n    float radius2 = sqrt(dot(p2, p2)) * time;\n    \n    /*\n\t* If we want to generate concentric circles we could set a boolean value on or off\n\t* depending on a modulo operation. If we take the modulo of a value and then test \n\t* whether it is above half-way then we can generate an on-off pulse. For example, \n\t* if we get a value ranging from 0 to 1, module 0.1, we can generate a on/off pulse \n\t* by testing if it is greater than 0.05.\n\t*/\n    \n    bool toggle = mod(radius,0.1) > 0.05;\n    bool toggle2 = mod(radius2,0.1) > 0.05;\n    \n    //XOR truth table:\n\n\t//xor via if statements\n\tfloat col = 0.0;\n\tif (toggle) col = 1.0; \n\tif (toggle2) col = 1.0;\n\tif ((toggle) && (toggle2)) col = 0.0;\n    \n    // just some tweaking here to make animation more appealing\n    // clamp time in [0,1]\n    time = 0.5* (time + 1.0);\n    \n\tfragColor = vec4(col, time, col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsSXDD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 77, 134, 134, 1494]], "test": "valid"}
{"id": "lsSXzm", "name": "Transverse Mercator grid", "author": "rougier", "description": "Pixel perfect Transverse Mercator regular grid.\nBetter in full screen.", "tags": ["grid", "antialias", "projection", "distance", "polar", "hammer", "mercator", "cartesian"], "likes": 15, "viewed": 598, "published": "Public", "date": "1410264407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ----------------------------------------------------------------------------\n// Copyright (c) 2014, Nicolas P. Rougier. All Rights Reserved.\n// Distributed under the (new) BSD License.\n// ----------------------------------------------------------------------------\n\n\n// Constants\nconst float M_PI    = 3.14159265358979323846;\nconst float M_SQRT2 = 1.41421356237309504880;\n\n\n\n// -------------------------------------------------\nconst float k0 = 0.75;\nconst float a  = 1.00;\n\n// Helper functions\n// ------------------------------------\nfloat _cosh(float x) { return 0.5 * (exp(x)+exp(-x)); }\nfloat _sinh(float x) { return 0.5 * (exp(x)-exp(-x)); }\n\n// Forward transform\n// ------------------------------------\nvec2 transform_forward(vec2 P)\n{\n    float lambda = P.x;\n    float phi = P.y;\n    float x = 0.5*k0*log((1.0+sin(lambda)*cos(phi))\n            / (1.0 - sin(lambda)*cos(phi)));\n    float y = k0*a*atan(tan(phi), cos(lambda));\n    return vec2(x,y);\n}\n\n// Inverse transform\n// ------------------------------------\nvec2 transform_inverse(vec2 P)\n{\n    float x = P.x;\n    float y = P.y;\n    float lambda = atan(_sinh(x/(k0*a)),cos(y/(k0*a)));\n    float phi    = asin(sin(y/(k0*a))/_cosh(x/(k0*a)));\n    return vec2(lambda,phi);\n}\n// -------------------------------------------------\n\n\n\n\n// [-0.5,-0.5]x[0.5,0.5] -> [xmin,xmax]x[ymin,ymax]\n// ------------------------------------------------\nvec2 scale_forward(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P += vec2(.5,.5);\n    P *= vec2(limits[1] - limits[0], limits[3]-limits[2]);\n    P += vec2(limits[0], limits[2]);\n    return P;\n}\n\n// [xmin,xmax]x[ymin,ymax] -> [-0.5,-0.5]x[0.5,0.5]\n// ------------------------------------------------\nvec2 scale_inverse(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P -= vec2(limits[0], limits[2]);\n    P /= vec2(limits[1]-limits[0], limits[3]-limits[2]);\n    return P - vec2(.5,.5);\n}\n\n// Antialias stroke alpha coeff\nfloat stroke_alpha(float distance, float linewidth, float antialias)\n{\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n    if( border_distance > (linewidth/2.0 + antialias) )\n        return 0.0;\n    else if( border_distance < 0.0 )\n        return 1.0;\n    else\n        return alpha;\n}\n\n// Compute the nearest tick from a (normalized) t value\nfloat get_tick(float t, float vmin, float vmax, float step)\n{\n    float first_tick = floor((vmin + step/2.0)/step) * step;\n    float last_tick = floor((vmax + step/2.0)/step) * step;\n    float tick = vmin + t*(vmax-vmin);\n    if (tick < (vmin + (first_tick-vmin)/2.0))\n        return vmin;\n    if (tick > (last_tick + (vmax-last_tick)/2.0))\n        return vmax;\n    tick += step/2.0;\n    tick = floor(tick/step)*step;\n    return min(max(vmin,tick),vmax);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t// Cartesian limits\n\tvec4 u_limits1 = vec4(-3., +3., -1.5, +1.5);\n\n\t// Projected limits\n\tvec4 u_limits2 = vec4(-M_PI + M_PI*(1.+cos(iTime/3.))/2.5,\n                           M_PI - M_PI*(1.+cos(iTime/4.))/2.5,\n                          -M_PI/2. + (1.+cos(iTime))/2.*M_PI/4.,\n                           M_PI/2. - (1.+cos(iTime/2.))/2.*M_PI/4.);\n\n\n    const float u_antialias = 1.0;\n\tvec2 u_major_grid_step = vec2(M_PI/4.0,  M_PI/6.0);\n\tvec2 u_minor_grid_step = vec2(M_PI/40.0, M_PI/60.0);\n\tfloat u_major_grid_width = 2.00;\n\tfloat u_minor_grid_width = 1.00;\n\tvec4  u_major_grid_color = vec4(0,0,0,1);\n\tvec4  u_minor_grid_color = vec4(0,0,0,1);\n\n\n\n\n    vec2 v_texcoord = fragCoord.xy / iResolution.xy - 0.5;\n    vec2 v_size = iResolution.xy;\n\n\n    vec2 NP1 = v_texcoord;\n    vec2 P1 = scale_forward(NP1, u_limits1);\n    vec2 P2 = transform_inverse(P1);\n\n    // Test if we are within limits but we do not discard yet because we want\n    // to draw border. Discarding would mean half of the exterior not drawn.\n    bvec2 outside = bvec2(false);\n    if( P2.x < u_limits2[0] ) outside.x = true;\n    if( P2.x > u_limits2[1] ) outside.x = true;\n    if( P2.y < u_limits2[2] ) outside.y = true;\n    if( P2.y > u_limits2[3] ) outside.y = true;\n\n    vec2 NP2 = scale_inverse(P2,u_limits2);\n    vec2 P;\n    float tick;\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_major_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float Mx = length(v_size * (NP1 - P));\n    // float Mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_minor_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float mx = length(v_size * (NP1 - P));\n    // float mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_major_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float My = length(v_size * (NP1 - P));\n    // float My = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_minor_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float my = length(v_size * (NP1 - P));\n    // float my = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    float M = min(Mx,My);\n    float m = min(mx,my);\n\n    // Here we take care of \"finishing\" the border lines\n    if( outside.x && outside.y ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = max(Mx,My);\n        }\n    } else if( outside.x ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = Mx;\n        }\n    } else if( outside.y ) {\n        if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = My;\n        }\n    }\n\n    // Mix major/minor colors to get dominant color\n    vec4 color = u_major_grid_color;\n    float alpha1 = stroke_alpha( M, u_major_grid_width, u_antialias);\n    float alpha2 = stroke_alpha( m, u_minor_grid_width, u_antialias);\n    float alpha  = alpha1;\n    if( alpha2 > alpha1*1.5 )\n    {\n        alpha = alpha2;\n        color = u_minor_grid_color;\n    }\n\n    // At no extra cost we can also project a texture\n    if( outside.x || outside.y ) {\n        fragColor = mix(vec4(1,1,1,1), color, alpha);\n    } else {\n        vec4 texcolor = texture(iChannel0, vec2(NP2.x+0.5, NP2.y+0.5));\n        fragColor = mix(texcolor, color, color.a*alpha);\n    }\n    // fragColor = mix(vec4(1,1,1,1), color, alpha);\n}\n", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/lsSXzm.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[478, 538, 560, 560, 593], [594, 594, 616, 616, 649], [651, 712, 744, 744, 958], [960, 1021, 1053, 1053, 1234], [1292, 1396, 1437, 1473, 1607], [1609, 1713, 1754, 1790, 1914], [1916, 1948, 2018, 2018, 2393], [2395, 2451, 2512, 2512, 2907], [2911, 2911, 2968, 2990, 6833]], "test": "error"}
{"id": "Md2XDh", "name": "beaded mat / stainedglass", "author": "wgoldie", "description": "rev2 mat, mouse to zoom and modify speed.\nuncomment SS to enable supersampling and GRID to change pattern.\nmusic should vibrate the pattern.", "tags": ["2d"], "likes": 1, "viewed": 212, "published": "Public", "date": "1411690158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define SS\n#define GRID\n\nconst float sqrt2 = 1.414213;\nconst float rads = 2. * 3.14159;\nconst float sinB = 3.14159 * 2.;\nconst float waveScale = 8.0;\n\nfloat lineCount;\nfloat timeA;\nfloat timeB;\nvec2 s;\nvec3 target;\n\nfloat circ(float d) {\n    return sin(d * sinB * lineCount - timeA) + 1.;\n}\n\nfloat circMod(float d) {\n    return mod(d * lineCount - timeA, 1.);\n}\n\nconst vec4 K = vec4(1., 2. / 3., 1. / 3., 3.);\n\nvec3 hsv2rgb(vec3 c)\n{\n\t// from http://lolengine.net/blog/2013/07/27/rgb-to-hsv-in-glsl\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6. - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0., 1.), c.y);\n}\n\n\n\nvec4 point(vec3 pos) {\n    float d = dot(target, pos);\n    \n    float circles = sin((d + s.y) * sinB - timeB) * 0.5 + 0.5;\n            \n    float w = pos.y + sin((d * d + s.x) * sinB * waveScale + timeB) / lineCount;\n    float waves = circ(w);\n    \n    #ifdef GRID\n    float lines = circ(d);\n    vec3 hsv = vec3(circles,waves + lines,waves - lines);\n    #else\n    vec3 hsv = vec3(circles,waves,waves);\n    #endif\n    return vec4(hsv2rgb(hsv),1.);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 m = vec2(1., 1.) + iMouse.xy / iResolution.xy;\n    s = vec2(1., 1.) + texture(iChannel1, fragCoord.xy).xy * 0.2;\n\n    lineCount = m.y * m.y * 15.;\n    timeA =  m.x * m.x * 40. * iTime;\n    timeB = timeA * 0.005;\n    float t = mod(timeB, rads);\n    target = vec3(cos(t), sin(t), 0);\n\n    \n    // ss based on https://www.shadertoy.com/view/XslSW7\n\tvec3 p = vec3(fragCoord.xy / iResolution.x, 0.);    \n\t#ifdef SS\n    float delta = 1.0 / iResolution.x;\n    vec4 color = (point(p+delta*vec3(0.25,0.00,1.)) +\n\t\t\t      point(p+delta*vec3(0.75,0.25,1.)) +\n                  point(p+delta*vec3(0.00,0.50,1.)) +\n                  point(p+delta*vec3(0.50,0.75,1.))) / 4.0;\n    #else\n    vec4 color = point(p);\n    #endif\n    fragColor = color;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md2XDh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 239, 239, 292], [294, 294, 318, 318, 363], [413, 413, 435, 500, 615], [619, 619, 641, 641, 1067], [1068, 1068, 1125, 1125, 1869]], "test": "error"}
{"id": "Md2XWh", "name": "Duper Hexagon", "author": "vug", "description": "A simple imitation of the insanely hard game Super Hexagon http://superhexagon.com/ Press the mouse button and use the mouse to rotate the circle around the hexagon. Try not to hit the obstacles.", "tags": ["2d", "game"], "likes": 6, "viewed": 518, "published": "Public", "date": "1411628386", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n#define TWO_PI 6.28318530718\n#define TPIS 1.0471975512\n\nfloat hash(float seed) { return fract(sin(seed) * 43758.5453); }\nmat2 rot(float th) { return mat2(cos(th), -sin(th), sin(th), cos(th)); }\nfloat angle(vec2 uv) { return mod(atan(uv.y, uv.x)+TWO_PI, TWO_PI); }\n\nfloat line(vec2 r, float dist, float thickness) {\n    float ret = 0.;\n    float a = angle(r);\n    if( a > TWO_PI - TPIS*0.5 || a < TPIS*0.5 ) {\n\t    ret = smoothstep(dist, dist+0.002, r.x)*(1.0-smoothstep(dist+thickness, dist+thickness+0.002, r.x));   \n    }\n\treturn ret;\n}\n\nfloat hexagonRadius = 0.1;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\n    vec2 uv3 = uv;\n    \n    float t = pow(iTime*0.1 + 10.,1.5) + 0.04*sin(10.*iTime);\n    uv /= dot(uv, vec2(sin(t * 0.34), sin(t * 0.53))) * 0.6 + 1.0; // perpective distorion code stolen from xTibor's shader ^_^\n    uv *= 0.1*sin(iTime*4.13)+1.0;\n    float r = length(uv);\n\tfloat theta = angle(uv) + t;\n    \n    int region = int(6.*theta/TWO_PI); // assign integers 0..5 to each region\n    \n    vec3 color = vec3(0.,0.,0.);\n    \n    // background\n    float col1 = mod(float(region+int(iTime*0.9)),2.0); // 0,1,0,1... alternate\n    color += vec3(col1*0.2+0.2,col1*0.2+0.2,0.); // alternate colors for each region\n    \n    // hexagon\n    vec2 uv2;\n    for(int i=0; i<6; i++) {\n\t    uv2 = rot(float(i)*TPIS + TPIS*0.5 - t)*uv;\n    \tcolor += line(uv2, hexagonRadius, 0.015)*vec3(1.,1.,0.); // draw 6 sides\n        color -= line(uv2, 0., hexagonRadius)*vec3(col1*0.2+0.2,col1*0.2+0.2,0.); // erase the inside of hexagon\n    }\n    \n    // cursor\n    vec2 m = (iMouse.xy - 0.5*iResolution.xy) / iResolution.y;\n    vec2 cursorPosition = 0.16*normalize(m);\n    //color += vec3(1., 1., 0.)*(1.0-smoothstep(0.02, 0.022, distance(uv, cursorPosition)));\n    float triangleSize = 0.02;\n    float triangleDist = 0.14;\n    float aT = angle(m);\n    vec2 uvT = uv; // start with original coordinate system\n    uvT = rot(aT)*uvT; // rotate it to the direction of cursor\n    uvT = uvT - vec2(triangleDist, 0.0); // translate it away from the coordinate center\n\tif(abs(uvT.y)<triangleSize-uvT.x && uvT.x>0.) color = vec3(1.,1.,0.); // draw a triangle: y<abs(side-x)\n    \n    \n    // obstacles\n    float seed2 = floor(t*0.5)+1424.0;\n    float missingSegment = hash(seed2);\n    float dist = mod(2.0 - t, 2.0); // distance of the obstacle from the origin\n    if(hexagonRadius<dist+0.01) {\n        for(int i=0; i<5; i++) {\n            uv2 = rot(float(i+int(missingSegment*6.))*TPIS + TPIS*0.5 - t)*uv;\n            float obs = line(uv2, dist, 0.05);\n            color += obs*vec3(1.,1.,0.);\n            // hit\n            if( obs > 0.5 && distance(uv, 0.17*normalize(m)) < 0.02  ) {\n                color = vec3(1.,0.,0.);\n            }\n        }\n    }\n    \n    color *= smoothstep(1.8, 0.5, length(uv3));\n\tfragColor = vec4(color,1.0);\n}", "image_inputs": [{"id": "XdfGzn", "previewfilepath": "/media/ap/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/894a09f482fb9b2822c093630fc37f0ce6cfec02b652e4e341323e4b6e4a4543.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Md2XWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 105, 105, 145], [146, 146, 166, 166, 218], [219, 219, 241, 241, 288], [290, 290, 339, 339, 563], [593, 593, 650, 650, 2929]], "test": "valid"}
{"id": "MdSSWR", "name": "T-Cube backwards", "author": "gleurop", "description": "Raymarching the T-Cube fractal backwards, aka reverse perspective.", "tags": ["raymarching", "fractal"], "likes": 5, "viewed": 212, "published": "Public", "date": "1410728576", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Public domain\n\nconst int   MAX_ITER = 50;\nconst float MAX_DIST = 3.0;\nconst float MIN_DIST = 0.001;\n\t\nfloat dist_box(vec3 p, vec3 b)\n{\n\treturn length(max(abs(p) - b, 0.0));\n}\n\nvec2 dist(vec3 p) // returns (distance, hue)\n{\n\tp += 1.0;\n\tfloat h = 0.0;\n\tfloat d = 1.0;\n\tfloat s = 1.0;\n\tfor (int i = 0; i < 4; i++)\n    {\n\t\tp = abs(p - s);\n\t\ts *= 0.4;\n\t\tfloat di = dist_box(p, vec3(s));\n\t\tif (di < d)\n        {\n\t\t\td = di;\n\t\t\th = float(i) / 4.0 + 0.4;\n\t\t}\n\t}\n\treturn vec2(d, h);\n}\n\n// Backwards marching: raymarch from the view distance to the camera.\nvec4 intersect(vec3 ray_origin, vec3 ray_dir)\n{\n\tvec3 p = ray_origin + MAX_DIST*ray_dir; \n    vec2 d = vec2(1);\n    float td = 0.0;\n\tfor (int i = 0; i < MAX_ITER; i++)\n\t{\n        if (d.x < MIN_DIST || td > MAX_DIST)\n\t\t\tbreak;\n        \n        d = dist(p - td*ray_dir);\n        td += d.x;\n\t}\n    \n\treturn vec4(p - td*ray_dir, d.y);\n}\n\nvec3 hsv(in float h, in float s, in float v)\n{\n\treturn mix(vec3(1.0), clamp((abs(fract(h + vec3(3, 2, 1) / 3.0) * 6.0 - 3.0) - 1.0), 0.0 , 1.0), s) * v;\n}\n\nvec3 get_normal(in vec3 p)\n{\n\tvec2 e = vec2(0.0, 0.001);\n\t\n\treturn normalize(vec3(\n\t\tdist(p + e.yxx).x - dist(p - e.yxx).x,\n\t\tdist(p + e.xyx).x - dist(p - e.xyx).x,\n\t\tdist(p + e.xxy).x - dist(p - e.xxy).x));\n}\n\nvec3 get_lighting(in vec3 pos, in vec3 normal, in vec3 light, in vec3 color)\n{\n\tfloat b = max(0.0, dot(normal, light));\n\treturn b * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tconst vec3 up_dir = vec3(0, 1, 0);\n\tconst vec3 cam_eye = vec3(0, 0, 0);\n\tvec3 cam_pos = vec3(sin(iTime*0.25), 0.0, cos(iTime*0.25))*1.5;\n\tvec3 cam_dir = normalize(cam_eye - cam_pos);\n\tvec3 u = normalize(cross(up_dir, cam_dir));\n\tvec3 v = cross(cam_dir, u);\n\tvec2 scr_pos = -1.0 + 2.0*fragCoord.xy / iResolution.xy;\n\tscr_pos.x *= iResolution.x / iResolution.y;\n\tvec3 ray_dir = normalize(u * scr_pos.x + v * scr_pos.y + cam_dir);\n\t\n\tvec4 h = intersect(cam_pos, ray_dir);\n    float d = dist(h.xyz).x;\n\tvec3 material = hsv(h.w, 1.0, 1.0);\n\tvec3 normal = get_normal(h.xyz);\n\tvec3 color = get_lighting(h.xyz, normal, ray_dir, material);\n\t\n\tfragColor = mix(vec4(color, 1.0), vec4(0), d);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdSSWR.jpg", "access": "shaders20k", "license": "public-domain", "functions": [[105, 105, 137, 137, 177], [179, 179, 225, 225, 477], [479, 549, 596, 596, 881], [883, 883, 929, 929, 1037], [1039, 1039, 1067, 1067, 1248], [1250, 1250, 1328, 1328, 1390], [1392, 1392, 1449, 1449, 2133]], "test": "valid"}
{"id": "MdSSWW", "name": "my first Plasma", "author": "foxiepaws", "description": "port of my software renderer (https://gist.github.com/79b4aca5e4fe06ce75d0) to GLSL\n\nFirst GLSL shader ever by me!", "tags": ["plasma", "demoscene", "coolstuff"], "likes": 4, "viewed": 229, "published": "Public", "date": "1411963493", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979323846\n\nvec3 colormap(float v) {\n   float r = (.5+.5*sin(M_PI * v));\n   float g = ( .5 + .5 * sin(M_PI * v + 2.0 * M_PI / 3.0));\n   float b = ( .5 + .5 * sin(M_PI * v + 4.0 * M_PI / 3.0));\n   return vec3(r,g,b);\n}\n\nfloat calc (float x, float y, float t,float cost3,float sint5,float sint2) {\n    float ar = iResolution.x / iResolution.y;\n \tfloat v = 0.0;\n    float xx = ar* x / (iResolution.x)-ar/2.0;\n\tfloat yy = y / iResolution.y - .5;\n    float cx = xx + 0.5 * sint5;\n    float cy = yy + 0.5 * cost3;\n    float v0 = sin((xx * 10.0) + t);\n    float v1 = sin(10.0 * ( xx * sint2 + yy * cost3));\n    float v2 = sin(sqrt(100.0*((cx*cx)+(cy*cy)))+1.0+t);\n   \n    v = ((v0 + v1 + v2) + cos(v2 + yy + t)) / 2.0;\n    \n    return v;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    float tt=t / 1.0;\n    float cost3 = cos(tt/3.0);\n    float sint5 = sin(tt/5.0);\n    float sint2 = sin(tt/2.0);\n    float v = calc(fragCoord.x,fragCoord.y,tt,cost3,sint5,sint2);\n\tfragColor = vec4(colormap(v),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdSSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 61, 61, 242], [244, 244, 320, 320, 757], [760, 760, 817, 817, 1057]], "test": "valid"}
{"id": "MdSXRm", "name": "Cartesian grid", "author": "rougier", "description": "Pixel perfect regular grid. Better in full screen. Works for any invertible projection (see other shaders)", "tags": ["grid", "antialias", "projection", "distance", "polar", "hammer", "mercator", "cartesian"], "likes": 23, "viewed": 1335, "published": "Public", "date": "1410253374", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Constants\nconst float M_PI    = 3.14159265358979323846;\nconst float M_SQRT2 = 1.41421356237309504880;\n\n\n\n// -------------------------------------------------\n// Forward cartesian projection\nvec2 transform_forward(vec2 P)\n{\n    return P;\n}\n\n// Inverse cartesian projection\nvec2 transform_inverse(vec2 P)\n{\n    return P;\n}\n// -------------------------------------------------\n\n\n\n\n// [-0.5,-0.5]x[0.5,0.5] -> [xmin,xmax]x[ymin,ymax]\n// ------------------------------------------------\nvec2 scale_forward(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P += vec2(.5,.5);\n    P *= vec2(limits[1] - limits[0], limits[3]-limits[2]);\n    P += vec2(limits[0], limits[2]);\n    return P;\n}\n\n// [xmin,xmax]x[ymin,ymax] -> [-0.5,-0.5]x[0.5,0.5]\n// ------------------------------------------------\nvec2 scale_inverse(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P -= vec2(limits[0], limits[2]);\n    P /= vec2(limits[1]-limits[0], limits[3]-limits[2]);\n    return P - vec2(.5,.5);\n}\n\n// Antialias stroke alpha coeff\nfloat stroke_alpha(float distance, float linewidth, float antialias)\n{\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n    if( border_distance > (linewidth/2.0 + antialias) )\n        return 0.0;\n    else if( border_distance < 0.0 )\n        return 1.0;\n    else\n        return alpha;\n}\n\n// Compute the nearest tick from a (normalized) t value\nfloat get_tick(float t, float vmin, float vmax, float step)\n{\n    float first_tick = floor((vmin + step/2.0)/step) * step;\n    float last_tick = floor((vmax + step/2.0)/step) * step;\n    float tick = vmin + t*(vmax-vmin);\n    if (tick < (vmin + (first_tick-vmin)/2.0))\n        return vmin;\n    if (tick > (last_tick + (vmax-last_tick)/2.0))\n        return vmax;\n    tick += step/2.0;\n    tick = floor(tick/step)*step;\n    return min(max(vmin,tick),vmax);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t// Cartesian limits\n\tvec4 u_limits1 = vec4(-10.1, +10.1, -10.1, +10.1)  * .5*(1.+sin(iTime/2.))/2.;\n\n\t// Projected limits\n\tvec4 u_limits2 = vec4(-10.,10.,-10.,10.); ;\n\n    const float u_antialias = 1.0;\n\tvec2 u_major_grid_step = vec2(1.0, 1.0);\n\tvec2 u_minor_grid_step = vec2(.1, .1);\n\tfloat u_major_grid_width = 2.00;\n\tfloat u_minor_grid_width = 1.00;\n\tvec4  u_major_grid_color = vec4(0,0,0,1);\n\tvec4  u_minor_grid_color = vec4(.5,.5,.5,1);\n\n    \n    vec2 v_texcoord;\n    if (iResolution.x > iResolution.y) {\n        v_texcoord.x = fragCoord.x/iResolution.y - 0.5\n                     - 0.5*(iResolution.x-iResolution.y)/iResolution.y;\n        v_texcoord.y = fragCoord.y/iResolution.y - 0.5;\n\t} else {\t\n        v_texcoord.x = fragCoord.x/iResolution.x - 0.5;\n        v_texcoord.y = fragCoord.y/iResolution.x - 0.5\n                     - 0.5*(iResolution.y-iResolution.x)/iResolution.x;\n    }\n    vec2 v_size = iResolution.xy;    \n\n    \n    \n    vec2 NP1 = v_texcoord;\n    vec2 P1 = scale_forward(NP1, u_limits1);\n    vec2 P2 = transform_inverse(P1);\n\n    // Test if we are within limits but we do not discard yet because we want\n    // to draw border. Discarding would mean half of the exterior not drawn.\n    bvec2 outside = bvec2(false);\n    if( P2.x < u_limits2[0] ) outside.x = true;\n    if( P2.x > u_limits2[1] ) outside.x = true;\n    if( P2.y < u_limits2[2] ) outside.y = true;\n    if( P2.y > u_limits2[3] ) outside.y = true;\n\n    vec2 NP2 = scale_inverse(P2,u_limits2);\n    vec2 P;\n    float tick;\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_major_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float Mx = length(v_size * (NP1 - P));\n    // float Mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_minor_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float mx = length(v_size * (NP1 - P));\n    // float mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_major_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float My = length(v_size * (NP1 - P));\n    // float My = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_minor_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float my = length(v_size * (NP1 - P));\n    // float my = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    float M = min(Mx,My);\n    float m = min(mx,my);\n\n    // Here we take care of \"finishing\" the border lines\n    if( outside.x && outside.y ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = max(Mx,My);\n        }\n    } else if( outside.x ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = Mx;\n        }\n    } else if( outside.y ) {\n        if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = My;\n        }\n    }\n\n    // Mix major/minor colors to get dominant color\n    vec4 color = u_major_grid_color;\n    float alpha1 = stroke_alpha( M, u_major_grid_width, u_antialias);\n    float alpha2 = stroke_alpha( m, u_minor_grid_width, u_antialias);\n    float alpha  = alpha1;\n    if( alpha2 > alpha1*1.5 )\n    {\n        alpha = alpha2;\n        color = u_minor_grid_color;\n    }\n\n    fragColor = mix(vec4(1,1,1,1), color, alpha);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MdSXRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 194, 226, 226, 242], [244, 276, 308, 308, 324], [382, 486, 527, 563, 697], [699, 803, 844, 880, 1004], [1006, 1038, 1108, 1108, 1483], [1485, 1541, 1602, 1602, 1997], [2001, 2001, 2058, 2080, 5829]], "test": "valid"}
{"id": "Ms2SD1", "name": "Seascape", "author": "TDM", "description": "fully-procedural sea surface computing. without textures.\n\nAndroid version: https://play.google.com/store/apps/details?id=com.nature.seascape\nInsta: https://www.instagram.com/seascapebenchmark/\t", "tags": ["procedural", "noise", "waves", "sea", "water", "subsurface"], "likes": 2147, "viewed": 540511, "published": "Public API", "date": "1411752810", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * \"Seascape\" by Alexander Alekseev aka TDM - 2014\n * License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n * Contact: tdmaav@gmail.com\n */\n\nconst int NUM_STEPS = 8;\nconst float PI\t \t= 3.141592;\nconst float EPSILON\t= 1e-3;\n#define EPSILON_NRM (0.1 / iResolution.x)\n#define AA\n\n// sea\nconst int ITER_GEOMETRY = 3;\nconst int ITER_FRAGMENT = 5;\nconst float SEA_HEIGHT = 0.6;\nconst float SEA_CHOPPY = 4.0;\nconst float SEA_SPEED = 0.8;\nconst float SEA_FREQ = 0.16;\nconst vec3 SEA_BASE = vec3(0.0,0.09,0.18);\nconst vec3 SEA_WATER_COLOR = vec3(0.8,0.9,0.6)*0.6;\n#define SEA_TIME (1.0 + iTime * SEA_SPEED)\nconst mat2 octave_m = mat2(1.6,1.2,-1.2,1.6);\n\n// math\nmat3 fromEuler(vec3 ang) {\n\tvec2 a1 = vec2(sin(ang.x),cos(ang.x));\n    vec2 a2 = vec2(sin(ang.y),cos(ang.y));\n    vec2 a3 = vec2(sin(ang.z),cos(ang.z));\n    mat3 m;\n    m[0] = vec3(a1.y*a3.y+a1.x*a2.x*a3.x,a1.y*a2.x*a3.x+a3.y*a1.x,-a2.y*a3.x);\n\tm[1] = vec3(-a2.y*a1.x,a1.y*a2.y,a2.x);\n\tm[2] = vec3(a3.y*a1.x*a2.x+a1.y*a3.x,a1.x*a3.x-a1.y*a3.y*a2.x,a2.y*a3.y);\n\treturn m;\n}\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(127.1,311.7));\t\n    return fract(sin(h)*43758.5453123);\n}\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(3.0-2.0*f);\n    return -1.0+2.0*mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\n\n// lighting\nfloat diffuse(vec3 n,vec3 l,float p) {\n    return pow(dot(n,l) * 0.4 + 0.6,p);\n}\nfloat specular(vec3 n,vec3 l,vec3 e,float s) {    \n    float nrm = (s + 8.0) / (PI * 8.0);\n    return pow(max(dot(reflect(e,n),l),0.0),s) * nrm;\n}\n\n// sky\nvec3 getSkyColor(vec3 e) {\n    e.y = (max(e.y,0.0)*0.8+0.2)*0.8;\n    return vec3(pow(1.0-e.y,2.0), 1.0-e.y, 0.6+(1.0-e.y)*0.4) * 1.1;\n}\n\n// sea\nfloat sea_octave(vec2 uv, float choppy) {\n    uv += noise(uv);        \n    vec2 wv = 1.0-abs(sin(uv));\n    vec2 swv = abs(cos(uv));    \n    wv = mix(wv,swv,wv);\n    return pow(1.0-pow(wv.x * wv.y,0.65),choppy);\n}\n\nfloat map(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_GEOMETRY; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nfloat map_detailed(vec3 p) {\n    float freq = SEA_FREQ;\n    float amp = SEA_HEIGHT;\n    float choppy = SEA_CHOPPY;\n    vec2 uv = p.xz; uv.x *= 0.75;\n    \n    float d, h = 0.0;    \n    for(int i = 0; i < ITER_FRAGMENT; i++) {        \n    \td = sea_octave((uv+SEA_TIME)*freq,choppy);\n    \td += sea_octave((uv-SEA_TIME)*freq,choppy);\n        h += d * amp;        \n    \tuv *= octave_m; freq *= 1.9; amp *= 0.22;\n        choppy = mix(choppy,1.0,0.2);\n    }\n    return p.y - h;\n}\n\nvec3 getSeaColor(vec3 p, vec3 n, vec3 l, vec3 eye, vec3 dist) {  \n    float fresnel = clamp(1.0 - dot(n,-eye), 0.0, 1.0);\n    fresnel = pow(fresnel,3.0) * 0.5;\n        \n    vec3 reflected = getSkyColor(reflect(eye,n));    \n    vec3 refracted = SEA_BASE + diffuse(n,l,80.0) * SEA_WATER_COLOR * 0.12; \n    \n    vec3 color = mix(refracted,reflected,fresnel);\n    \n    float atten = max(1.0 - dot(dist,dist) * 0.001, 0.0);\n    color += SEA_WATER_COLOR * (p.y - SEA_HEIGHT) * 0.18 * atten;\n    \n    color += vec3(specular(n,l,eye,60.0));\n    \n    return color;\n}\n\n// tracing\nvec3 getNormal(vec3 p, float eps) {\n    vec3 n;\n    n.y = map_detailed(p);    \n    n.x = map_detailed(vec3(p.x+eps,p.y,p.z)) - n.y;\n    n.z = map_detailed(vec3(p.x,p.y,p.z+eps)) - n.y;\n    n.y = eps;\n    return normalize(n);\n}\n\nfloat heightMapTracing(vec3 ori, vec3 dir, out vec3 p) {  \n    float tm = 0.0;\n    float tx = 1000.0;    \n    float hx = map(ori + dir * tx);\n    if(hx > 0.0) {\n        p = ori + dir * tx;\n        return tx;   \n    }\n    float hm = map(ori + dir * tm);    \n    float tmid = 0.0;\n    for(int i = 0; i < NUM_STEPS; i++) {\n        tmid = mix(tm,tx, hm/(hm-hx));                   \n        p = ori + dir * tmid;                   \n    \tfloat hmid = map(p);\n\t\tif(hmid < 0.0) {\n        \ttx = tmid;\n            hx = hmid;\n        } else {\n            tm = tmid;\n            hm = hmid;\n        }\n    }\n    return tmid;\n}\n\nvec3 getPixel(in vec2 coord, float time) {    \n    vec2 uv = coord / iResolution.xy;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;    \n        \n    // ray\n    vec3 ang = vec3(sin(time*3.0)*0.1,sin(time)*0.2+0.3,time);    \n    vec3 ori = vec3(0.0,3.5,time*5.0);\n    vec3 dir = normalize(vec3(uv.xy,-2.0)); dir.z += length(uv) * 0.14;\n    dir = normalize(dir) * fromEuler(ang);\n    \n    // tracing\n    vec3 p;\n    heightMapTracing(ori,dir,p);\n    vec3 dist = p - ori;\n    vec3 n = getNormal(p, dot(dist,dist) * EPSILON_NRM);\n    vec3 light = normalize(vec3(0.0,1.0,0.8)); \n             \n    // color\n    return mix(\n        getSkyColor(dir),\n        getSeaColor(p,n,light,dir,dist),\n    \tpow(smoothstep(0.0,-0.02,dir.y),0.2));\n}\n\n// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float time = iTime * 0.3 + iMouse.x*0.01;\n\t\n#ifdef AA\n    vec3 color = vec3(0.0);\n    for(int i = -1; i <= 1; i++) {\n        for(int j = -1; j <= 1; j++) {\n        \tvec2 uv = fragCoord+vec2(i,j)/3.0;\n    \t\tcolor += getPixel(uv, time);\n        }\n    }\n    color /= 9.0;\n#else\n    vec3 color = getPixel(fragCoord, time);\n#endif\n    \n    // post\n\tfragColor = vec4(pow(color,vec3(0.65)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ms2SD1.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[679, 687, 713, 713, 1059], [1060, 1060, 1082, 1082, 1162], [1163, 1163, 1189, 1189, 1490], [1492, 1504, 1542, 1542, 1584], [1585, 1585, 1631, 1631, 1731], [1733, 1740, 1766, 1766, 1875], [1877, 1884, 1925, 1925, 2096], [2098, 2098, 2117, 2117, 2561], [2563, 2563, 2591, 2591, 3035], [3037, 3037, 3100, 3100, 3594], [3596, 3607, 3642, 3642, 3833], [3835, 3835, 3891, 3891, 4447], [4449, 4449, 4491, 4491, 5197], [5199, 5207, 5264, 5264, 5660]], "test": "valid"}
{"id": "MsBSDz", "name": "So Snaked", "author": "Passion", "description": "leaf snake :p", "tags": ["2d", "formulanimations"], "likes": 5, "viewed": 305, "published": "Public", "date": "1410830975", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(1.0,1.0,1.0);\n    float time = iTime;\n\n\tfor(int i = 20; i>0; i--)\n    {     \n        vec2 shape = uv - vec2(.5,.45);  \n        shape.x+=cos(float(i)/3.5-time*1.3)/2.5;\n        shape.y+=sin(float(i)/2.5-time*1.7)/2.5;\n\n        float r = .1+.1*cos(atan(shape.y,shape.x)*12.);\n        float g = .5+.5*cos(atan(shape.x,shape.y));   \n        r=r*g-.02;    \n        col *= smoothstep(r, r+0.05, length(shape));\n        col.y+=.06;\n    }\n    fragColor = vec4(col,1.0);\n}\n//2014 - Passion\n//References -  www.youtube.com/watch?v=ONN3jBly364\n//           -  www.youtube.com/watch?v=0ifChJ0nJfM\n//   ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsBSDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 583]], "test": "valid"}
{"id": "MsBSRm", "name": "Polar grid", "author": "rougier", "description": "Pixel perfect projected grid using any kind of transformation as long as it conserves topology.", "tags": ["antialias", "projection", "distance", "polar", "grids", "hammer", "mercator", "cartesian"], "likes": 22, "viewed": 1137, "published": "Public", "date": "1410253406", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Constants\nconst float M_PI    = 3.14159265358979323846;\nconst float M_SQRT2 = 1.41421356237309504880;\n\n\n\n// -------------------------------------------------\n// Forward polar projection\nvec2 transform_forward(vec2 P)\n{\n    float x = P.x * cos(P.y);\n    float y = P.x * sin(P.y);\n    return vec2(x,y);\n}\n\n// Inverse polar projection\nvec2 transform_inverse(vec2 P)\n{\n    float rho = length(P);\n    float theta = atan(P.y,P.x);\n    if( theta < 0.0 )\n        theta = 2.0*M_PI+theta;\n    return vec2(rho,theta);\n}\n// -------------------------------------------------\n\n\n\n\n// [-0.5,-0.5]x[0.5,0.5] -> [xmin,xmax]x[ymin,ymax]\n// ------------------------------------------------\nvec2 scale_forward(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P += vec2(.5,.5);\n    P *= vec2(limits[1] - limits[0], limits[3]-limits[2]);\n    P += vec2(limits[0], limits[2]);\n    return P;\n}\n\n// [xmin,xmax]x[ymin,ymax] -> [-0.5,-0.5]x[0.5,0.5]\n// ------------------------------------------------\nvec2 scale_inverse(vec2 P, vec4 limits)\n{\n    // limits = xmin,xmax,ymin,ymax\n    P -= vec2(limits[0], limits[2]);\n    P /= vec2(limits[1]-limits[0], limits[3]-limits[2]);\n    return P - vec2(.5,.5);\n}\n\n// Antialias stroke alpha coeff\nfloat stroke_alpha(float distance, float linewidth, float antialias)\n{\n    float t = linewidth/2.0 - antialias;\n    float signed_distance = distance;\n    float border_distance = abs(signed_distance) - t;\n    float alpha = border_distance/antialias;\n    alpha = exp(-alpha*alpha);\n    if( border_distance > (linewidth/2.0 + antialias) )\n        return 0.0;\n    else if( border_distance < 0.0 )\n        return 1.0;\n    else\n        return alpha;\n}\n\n// Compute the nearest tick from a (normalized) t value\nfloat get_tick(float t, float vmin, float vmax, float step)\n{\n    float first_tick = floor((vmin + step/2.0)/step) * step;\n    float last_tick = floor((vmax + step/2.0)/step) * step;\n    float tick = vmin + t*(vmax-vmin);\n    if (tick < (vmin + (first_tick-vmin)/2.0))\n        return vmin;\n    if (tick > (last_tick + (vmax-last_tick)/2.0))\n        return vmax;\n    tick += step/2.0;\n    tick = floor(tick/step)*step;\n    return min(max(vmin,tick),vmax);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \t// Cartesian limits\n\tvec4 u_limits1 = vec4(-5.1, +5.1, -5.1, +5.1);\n\n\t// Projected limits\n\tvec4 u_limits2 = vec4(2.0 + cos(iTime), 5.0,\n                          M_PI/6., 5.*M_PI/6.+ 4.*sin(iTime/2.)*M_PI/6.);\n\n    const float u_antialias = 1.0;\n\tvec2 u_major_grid_step = vec2(1.0, M_PI/6.0);\n\tvec2 u_minor_grid_step = vec2(0.25, M_PI/60.0);\n\tfloat u_major_grid_width = 2.00;\n\tfloat u_minor_grid_width = 1.00;\n\tvec4  u_major_grid_color = vec4(0,0,0,1);\n\tvec4  u_minor_grid_color = vec4(.5,.5,.5,1);\n\n    \n    vec2 v_texcoord;\n    if (iResolution.x > iResolution.y) {\n        v_texcoord.x = fragCoord.x/iResolution.y - 0.5\n                     - 0.5*(iResolution.x-iResolution.y)/iResolution.y;\n        v_texcoord.y = fragCoord.y/iResolution.y - 0.5;\n\t} else {\t\n        v_texcoord.x = fragCoord.x/iResolution.x - 0.5;\n        v_texcoord.y = fragCoord.y/iResolution.x - 0.5\n                     - 0.5*(iResolution.y-iResolution.x)/iResolution.x;\n    }\n    vec2 v_size = iResolution.xy;    \n\n    \n    \n    vec2 NP1 = v_texcoord;\n    vec2 P1 = scale_forward(NP1, u_limits1);\n    vec2 P2 = transform_inverse(P1);\n\n    // Test if we are within limits but we do not discard yet because we want\n    // to draw border. Discarding would mean half of the exterior not drawn.\n    bvec2 outside = bvec2(false);\n    if( P2.x < u_limits2[0] ) outside.x = true;\n    if( P2.x > u_limits2[1] ) outside.x = true;\n    if( P2.y < u_limits2[2] ) outside.y = true;\n    if( P2.y > u_limits2[3] ) outside.y = true;\n\n    vec2 NP2 = scale_inverse(P2,u_limits2);\n    vec2 P;\n    float tick;\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_major_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float Mx = length(v_size * (NP1 - P));\n    // float Mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n\n    tick = get_tick(NP2.x+.5, u_limits2[0], u_limits2[1], u_minor_grid_step[0]);\n    P = transform_forward(vec2(tick,P2.y));\n    P = scale_inverse(P, u_limits1);\n    float mx = length(v_size * (NP1 - P));\n    // float mx = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_major_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float My = length(v_size * (NP1 - P));\n    // float My = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    tick = get_tick(NP2.y+.5, u_limits2[2], u_limits2[3], u_minor_grid_step[1]);\n    P = transform_forward(vec2(P2.x,tick));\n    P = scale_inverse(P, u_limits1);\n    float my = length(v_size * (NP1 - P));\n    // float my = screen_distance(vec4(NP1,0,1), vec4(P,0,1));\n\n    float M = min(Mx,My);\n    float m = min(mx,my);\n\n    // Here we take care of \"finishing\" the border lines\n    if( outside.x && outside.y ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = max(Mx,My);\n        }\n    } else if( outside.x ) {\n        if (Mx > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = Mx;\n        }\n    } else if( outside.y ) {\n        if (My > 0.5*(u_major_grid_width + u_antialias)) {\n            fragColor = vec4(1); return;\n        } else {\n            M = m = My;\n        }\n    }\n\n    // Mix major/minor colors to get dominant color\n    vec4 color = u_major_grid_color;\n    float alpha1 = stroke_alpha( M, u_major_grid_width, u_antialias);\n    float alpha2 = stroke_alpha( m, u_minor_grid_width, u_antialias);\n    float alpha  = alpha1;\n    if( alpha2 > alpha1*1.5 )\n    {\n        alpha = alpha2;\n        color = u_minor_grid_color;\n    }\n\n    \n    // At no extra cost we can also project a texture\n    if( outside.x || outside.y ) {\n        fragColor = mix(vec4(1,1,1,1), color, alpha);\n    } else {\n        vec4 texcolor = texture(iChannel0, vec2(NP2.x+0.5, 0.5-NP2.y));\n        fragColor = mix(texcolor, color, color.a*alpha);\n    }\n//    fragColor = mix(vec4(1,1,1,1), color, alpha);\n}\n\n", "image_inputs": [{"id": "4sX3Rn", "previewfilepath": "/media/ap/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/c3a071ecf273428bc72fc72b2dd972671de8da420a2d4f917b75d20e1c24b34c.ogv", "ctype": "video"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsBSRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[108, 189, 221, 221, 305], [307, 335, 367, 367, 511], [569, 673, 714, 750, 884], [886, 990, 1031, 1067, 1191], [1193, 1225, 1295, 1295, 1670], [1672, 1728, 1789, 1789, 2184], [2188, 2188, 2245, 2267, 6371]], "test": "error"}
{"id": "MsBSW1", "name": "I love kaleido", "author": "darkhus", "description": "simple kaleidoscope solution", "tags": ["2d", "image", "kaleido"], "likes": 2, "viewed": 199, "published": "Public", "date": "1411413212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  \n  vec2 uv = fragCoord.xy / iResolution.xy;\n  vec2 p = uv - 0.5;\n  \n  vec4 c = vec4(uv,0.5+0.5*sin(iTime),1.0);\n    \n  float tt = iTime;\n    \n  float f = 1.2;\n  p += vec2(sin(tt)*f, cos(tt)*f) * (sin(tt*0.6)*0.9);;\n\n  float a = atan(p.y, p.x);\n  float r = length(p);\n    \n  float s = 7.0;\n  float tau = 2. * 3.1416;\n  a = mod(a, tau/s);\n  a = abs(a - tau/s/2.);\n    \n  c = c*a;\n  a+=tt;\n  \n  p = r * vec2(cos(a),sin(a));\n  \n  vec4 color = texture(iChannel0, p + 0.5);\n  fragColor = color + c;\n}\n", "image_inputs": [{"id": "4dfGRn", "previewfilepath": "/media/ap/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8de3a3924cb95bd0e95a443fff0326c869f9d4979cd1d5b6e94e2a01f5be53e9.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsBSW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 555]], "test": "error"}
{"id": "MsBSWW", "name": "MistyMt.Scroll", "author": "Passion", "description": "My attempt at a 2D sidescroll background. References https://www.shadertoy.com/view/Xsl3zN and http://thndl.com/?14", "tags": ["2d", "noise", "fbm", "scroll"], "likes": 12, "viewed": 391, "published": "Public", "date": "1411987087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 c1 = vec3(0.4);\nconst vec3 c2 = vec3(0.7);\nconst vec3 c3 = vec3(0.2);\nconst vec3 c4 = vec3(0.1);\nconst vec3 c5 = vec3(0.3);\nconst vec3 c6 = vec3(0.1);\nfloat rand(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat noise(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(rand(b), rand(b + d.yx), f.x), mix(rand(b + d.xy), rand(b + d.yy), f.x), f.y);\n}\nfloat fbm(vec2 n) {\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < 7; i++) {\n\t\ttotal += noise(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= 0.5;\n\t}\n\treturn total;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy; \n\tvec2 p = fragCoord.xy * 8.0 / iResolution.xx;\n    p.x-=iTime*.3;\n\tfloat q = fbm(p - iTime * 0.1);\n\tvec2 r2 = vec2(fbm(p + q + iTime * 0.7 - p.x - p.y), fbm(p + q - iTime * 0.4));\n\tvec3 c = mix(c1, c2, fbm(p + r2)) + mix(c3, c4, r2.x) - mix(c5, c6, r2.y);\n\tvec4 smoke = vec4(c * cos(1.57 * fragCoord.y / iResolution.y+.2),1.0);\n    float m=uv.x*.5+.5;\n    float r=.5+m*(fbm(5.*m*uv.xy)-.5);\n    float rr=.5+m*(fbm(.1*m*uv.xy-iTime*.2)-.5);\n    float h=.5+m*(fbm(5.*m+.001*vec2(uv.x,.5)+iTime*.3)-.9);\n    h*=.8;\n    vec4 sky=mix(vec4(0.,.5,.7,1.),vec4(.8,.7,.8,1.),rr);\n    vec4 ground=mix(vec4(.2,.9,0.,1.),vec4(.4,.2,0.,1.),r);\n    ground-=.05;\n    fragColor=vec4(mix(ground,sky,smoothstep(h,h+.01,uv.y))+smoke);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsBSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[162, 162, 182, 182, 249], [250, 250, 271, 271, 468], [469, 469, 488, 488, 639], [640, 640, 697, 697, 1457]], "test": "valid"}
{"id": "MsjXDz", "name": "Taichi", "author": "EvilRyu", "description": "Yin yang fish.", "tags": ["2d"], "likes": 15, "viewed": 687, "published": "Public API", "date": "1411206285", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 q = uv - vec2(0.5);\n    q.y *= iResolution.y/iResolution.x;\n    float r = 0.2;\n    vec2 p;\n    p.x = cos(-iTime*0.5)*q.x + sin(-iTime*0.5)*q.y;\n    p.y = -sin(-iTime*0.5)*q.x + cos(-iTime*0.5)*q.y;\n    q=p;\n    \n    float c1,c2;\n   \n   \tc1 = smoothstep(r, r+0.05, length(q))+(1.0-step(0.0, q.x));\n    r = 0.1;\n\n    c1 += 1.0-smoothstep(r, r+0.05, length(q-vec2(0.0,0.1)));\n    c1=min(c1, 1.0);\n    \n    r-=0.003;\n    c1 *= smoothstep(r, r+0.05, length(q+vec2(0.0, 0.105)));\n    \n    r=0.005;\n    c1 += 1.0-smoothstep(r, r+0.05, length(q+vec2(0.0,0.1)));\n    c1 *= smoothstep(r, r+0.05, length(q-vec2(0.0,0.1)));\n    \n    r=0.2;\n    c2 = smoothstep(r, r+0.05, length(q));\n    \n    r = 0.185;\n    c2 += 1.0-smoothstep(r, r+0.05, length(q));\n    c2=min(c2, 1.0);\n    \n    c1 *= c2;\n    c1 += texture(iChannel0, p.yx).x;\n    c1 = min(c1, 1.0);\n    \n    c1 *=pow(16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.6);\n\n\tfragColor = vec4(c1, c1, c1, 1.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsjXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1049]], "test": "error"}
{"id": "MsSXDz", "name": "marcher", "author": "rickiters", "description": "first pass at a ray marcher", "tags": ["raymarching"], "likes": 1, "viewed": 166, "published": "Public", "date": "1411154754", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//// input\n// keys\nint kA=65,kB=66,kC=67,kD=68,kE=69,kF=70,kG=71,kH=72,kI=73,kJ=74,kK=75,kL=76,kM=77,kN=78,kO=79,kP=80,kQ=81,kR=82,kS=83,kT=84,kU=85,kV=86,kW=87,kX=88,kY=89,kZ=90;\nint k0=48,k1=49,k2=50,k3=51,k4=52,k5=53,k6=54,k7=55,k8=56,k9=57;\nint kSpace=32,kLeft=37,kUp=38,kRight=39,kDown=40;\n\n\n// TOGGLES:\n#define kRed k1\n#define kGreen k2\n#define kBlue k3\n\n// key is javascript keycode: http://www.webonweboff.com/tips/js/event_key_codes.aspx\nbool ReadKeyBool( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn (keyVal>.5)?true:false;\n}\n\nfloat ReadKeyFloat( int key, bool toggle )\n{\n\tfloat keyVal = texture( iChannel3, vec2( (float(key)+.5)/256.0, toggle?.75:.25 ) ).x;\n\treturn step(.5,keyVal);\n}\n\n\n//// convert screen coords to -asp to +asp for x, -1 to +1 for y, asp = aspect ratio\n// normalized device coords\nvec2 ndc(vec2 p)\n{\n    p *= 2.0/iResolution.y;\n    p += vec2(-iResolution.x/iResolution.y,-1.0);\n\treturn p;\n}\n\n// generate a 2d rotation matrix\nmat2 rot(float a) {\n\treturn mat2(cos(a),sin(a),-sin(a),cos(a));\t\n}\n\n\n\n//// raytrace plane\n// return color of plane at xyz, this plane is at y = 0\nvec3 planeColor(vec3 loc,bool pc)\n{\n    float lodBias = -.2;\n    vec3 ret3 = texture(iChannel2,vec2(loc.x,-loc.z),lodBias).xyz;\n    if (pc) {\n        if (loc.x >= 0.0)\n        \tret3.r += .25;\n    \tif (loc.z >= 0.0)\n        \tret3.g += .25;\n        if (fract(loc.x*.05) >= .5)\n            ret3.r -= .15;\n        if (fract(loc.z*.05) >= .5)\n            ret3.g -= .15;\n    }\n\treturn ret3;\n}\n\n\n//// sky and plane\nvec3 skyPlane(vec3 rs,vec3 rd,bool planeaxis) // unnormalized direction\n{\n// sky color\n    vec3 skycolor = vec3(0.0,0.0,1.0) - vec3(0.0,0.0,rd.y);\n    \n    // plane color\n    float t = -rs.y/rd.y;\n    vec3 isect = rs + rd*t;\n    vec3 planecolor = planeColor(isect,planeaxis);\n    \n    vec3 skyplanecolor;\n    if (rd.y >= 0.0)\n        skyplanecolor = skycolor;\n    else\n        skyplanecolor = planecolor;\n    return skyplanecolor;\n}\n\n\n//// raymarch\nfloat sdSphere(vec3 p,float r)\n{\n\treturn length(p)-r;\n}\n\nfloat sdBox(vec3 p,vec3 b)\n{\n\tvec3 d = abs(p) - b;\n  \treturn min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdTorus(vec3 p,vec2 t)\n{\n\tvec2 q = vec2(length(p.xz)-t.x,p.y);\n\treturn length(q)-t.y;\n}\n\n// h.x = radius h.y = height\nfloat sdCappedCylinder(vec3 p,vec2 h)\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// n.w is the distance from origin to the plane P*N = D\nfloat sdPlane(vec3 p,vec4 n)\n{\n  // n.xyz must be normalized\n  return dot(p,n.xyz) + n.w;\n}\n\n// CSG Union d1 U d2\nfloat opU(float d1,float d2)\n{\n    return min(d1,d2);\n}\n\n// CSG Intersection d1 ^ d2\nfloat opI(float d1,float d2)\n{\n    return max(d1,d2);\n}\n\n// CSG Subtract d1 - d2\nfloat opS(float d1,float d2)\n{\n    return max(d1,-d2);\n}\n\nfloat scene1(vec3 p)\n{\n    vec3 pr = p;\n    //pr.x += 4.0;\n    pr.xy *= rot(iTime*.5);\n    pr.xz *= rot(iTime*.25);\n    float d1 = sdBox(pr,vec3(.5,1.0,1.5));\n    //float d1 = sdBox(pr,vec3(.25,.5,.75));\n    float d2 = sdSphere(p,1.0); // p or pr, it's a sphere\n    //float d3 = sdTorus(pr,vec2(1.0,.25));\n    //float d4 = sdCappedCylinder(pr,vec2(.25,1.0));\n    //return opU(d1,d2);\n    //return opI(d1,d2);\n    return opS(d1,d2);\n    //return opS(d2,d1);\n    //return d1;\n    //return d2;\n    //return d3;\n    //return d4;\n}\n\nfloat opRep_scene1(vec3 p,vec3 c)\n{\n    vec3 q;\n\tq = mod(p+.5*c,c)-.5*c;\n    return scene1(q);\n}\n\nfloat opRepLimit_scene1(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return scene1(q);\n}\n\nfloat opRepLimitCenter_scene1(vec3 p,vec3 c,vec3 lim)\n{\n    vec3 lm1 = lim-vec3(1.0);\n    p += c*.5*lm1;\n    vec3 q;\n\tq = min(p,mod(p+.5*c,c)-.5*c); // less than 0\n    q = max(q,p-(lim-vec3(1.0))*c); // more than limit\n    return scene1(q);\n}\n\nfloat scene2(vec3 p)\n{\n\treturn opRep_scene1(p,vec3(10.0));\n}\n\nfloat scene3(vec3 p)\n{\n\treturn opRepLimit_scene1(p,vec3(10.0),vec3(2.0,3.0,4.0));\n}\n\nfloat scene4(vec3 p)\n{\n\tfloat rs1 = opRepLimitCenter_scene1(p,vec3(10.0),vec3(9.0));\n    //float pn = sdPlane(p,vec4(0.0,0.0,-1.0,10.0));\n    //float pn = sdPlane(p,vec4(.7071,0.,-.7071,7.071));\n    //return opU(rs1,pn);\n    return rs1;\n}\n\nvec3 march(vec3 rs,vec3 rd,out bool hit)\n{\n    vec3 col = vec3(1.0,0.0,0.0);\n    float compensate = .87;\n    const int steps = 180;\n    float eps = .001;\n    float toobig = 1000.0;\n    //hit = false;\n    for (int i=0;i<steps;++i) {\n        //float d = scene1(rs);\n        //float d = scene2(rs);\n        //float d = scene3(rs);\n        float d = scene4(rs);\n  //        float d = .091;\n //       if (false) {\n //       //if (d > toobig) { // bail early if clearly can't hit anything\n //           hit = false;\n //          break;\n //       }\n        if (d < eps) {\n        //if (true) {\n    \t\tcol.g = float(i)*(10.0/256.0); \n            if (rs.y >= 0.0)\n                hit = true;\n            //break;\n            return col;\n        }\n        rs += rd*d*compensate;\n    }\n    //hit = true;\n\n    return col;\n}\n\n\n//// main\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool roll = ReadKeyBool(k1,true);\n    bool planeaxis = !ReadKeyBool(k2,true);\n    bool movexy = ReadKeyBool(k3,true);\n\n    // ndc\n    vec2 pos = ndc(fragCoord.xy);\n    vec2 mouse = vec2(0.0,0.0);\n    \n    //if (iMouse.z > 0.0)\n    \tmouse = ndc(iMouse.xy);\n    \n    // keyboard color, for circle (press 1,2,3)\n    vec3 keycolor = vec3(ReadKeyFloat(kRed,true),\n             ReadKeyFloat(kGreen,true),\n             ReadKeyFloat(kBlue,true));\n    \n    //// camera\n    const float zoom = 2.0;\n    // make a ray, left handed coords\n    vec3 rs;\n    if (movexy) {\n\t    rs = vec3(0.0,60.0,-60.0) + vec3(mouse*59.99,0.0); // ray start\n    } else {\n\t    rs = vec3(0.0,12.0,-3.0); // ray start\n    }\n    vec3 rd = vec3(pos,1.0); // ray direction\n    // zoom factor\n    rd.xy /= zoom;\n    if (!movexy) {\n        rd.yz *= rot(mouse.y*3.14 ); // pitch\n        if (roll)\n            rd.xy *= rot(mouse.x*3.14 ); // roll\n        else\n            rd.xz *= rot(mouse.x*3.14 ); // yaw\n    }\n    vec3 nrd = normalize(rd); // normalized for the marching, unnormalized for the sky gradient\n\n    \n    // cursor color\n    vec3 circlecolor = keycolor;\n    // is inside circle\n    vec2 del =  pos - mouse;\n    float d2 = dot(del,del);\n    float rad = 1.0/30.0;\n    bool iscursor = d2<rad*rad;\n    \n    // sky plane color\n    vec3 skyplanecolor = skyPlane(rs,rd,planeaxis); // do this with an unnormalized ray\n   \n    // march color\n    bool hit = false; // did hit something\n    vec3 marchcol = march(rs,nrd,hit);\n    \n    \n    // put it all together\n    vec3 comp;\n    if (iscursor)\n        comp = circlecolor;\n    else if (hit)\n\t\tcomp = marchcol;\n\telse\n        comp = skyplanecolor;\n\tfragColor = vec4(comp,1.0);\n}\n", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 3, "sampler": {"filter": "nearest", "wrap": "clamp", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/MsSXDz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[773, 886, 904, 904, 995], [997, 1030, 1049, 1049, 1096], [1100, 1176, 1211, 1211, 1562], [1565, 1584, 1657, 1670, 2016], [2019, 2033, 2065, 2065, 2088], [2090, 2090, 2118, 2118, 2205], [2207, 2207, 2237, 2237, 2300], [2302, 2331, 2370, 2370, 2469], [2471, 2527, 2557, 2587, 2618], [2620, 2641, 2671, 2671, 2696], [2698, 2726, 2756, 2756, 2781], [2783, 2807, 2837, 2837, 2863], [2865, 2865, 2887, 2887, 3391], [3393, 3393, 3428, 3428, 3489], [3491, 3491, 3540, 3540, 3678], [3680, 3680, 3735, 3735, 3922], [3924, 3924, 3946, 3946, 3984], [3986, 3986, 4008, 4008, 4069], [4071, 4071, 4093, 4093, 4309], [4311, 4311, 4353, 4353, 5121], [5124, 5134, 5191, 5191, 6885]], "test": "error"}
{"id": "Xd2SzW", "name": "A first time  for everything...", "author": "axelduch", "description": "Couldn't really tell what this is", "tags": ["2d"], "likes": 2, "viewed": 147, "published": "Public", "date": "1409615655", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float iteration = 400.0 + iTime;\n    float x, y;\n    float ratio = iResolution.x / iResolution.y;\n    \n    vec2 coord = vec2(fragCoord.xy / iResolution.xy);\n    vec2 center = vec2(0.5, 0.5);\n    \n    x = length(coord - center) * 2.0 + 1.6 * sin(iteration * 0.5);\n    \n\tfragColor = vec4(\n        vec3(\n            x,\n            sin(x * iteration * (pow(x, cos(iteration * 0.2 + 0.2 * abs(sin(x)))))),\n            1.0 - x + 0.5 * cos(iteration * 0.5)\n        ),\n        1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2SzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 58, 58, 539]], "test": "valid"}
{"id": "Xd2XWh", "name": "Centaurs", "author": "erucipe", "description": "random phase animation", "tags": ["3d", "animation", "centaur"], "likes": 15, "viewed": 1960, "published": "Public", "date": "1411483305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi = 3.141592653589793;\n\nfloat hash(in vec3 p) {\n\treturn fract(sin(dot(p, vec3(15.64, 35.78, 75.42))) * 43758.23);\t\n}\n\nfloat shash(in vec3 p) {\n\treturn hash(p) * 2.0 - 1.0;\t\n}\n\nfloat sdPlane(in vec3 p) {\n\treturn p.y + 0.45;\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n\treturn length(p) - r;\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r ) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp( dot(pa, ba) / dot(ba , ba), 0.0, 1.0 );\n    \treturn length( pa - ba * h ) - r;\n}\n\nfloat motor(float _min, float _max, float time) {\n\tfloat t = 0.5 + 0.5 * sin(time);\n\treturn mix(_min, _max, t);\n}\n\nvec3 rotate_from_origin(vec3 origin, vec3 target, float r, float angle) {\n\treturn vec3(\n\t\torigin.x + r * cos(angle),\n\t\torigin.y + r * sin(angle),\n\t\ttarget.z\n\t);\n}\n\nvec3 preserve(vec3 p0, vec3 p1, float len) {\n\tvec3 v = p1 - p0;\n\tvec3 u = normalize(v);\n\treturn p0 + len * u;\n}\n\nfloat smin( float a, float b, float k ) {\n\tfloat h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec2 map(in vec3 p) {\n\tvec3 q = p;\n\tvec3 c = vec3(2.5, 0.0, 1.5);\n    p.xz = mod(p.xz, c.xz) - 0.5 * c.xz;\n\t\n\tfloat k = hash(floor( q * vec3(1.0 / 2.5, 1.0, 1.0 / 1.5) - vec3(0.0, 0.5, 0.0) ));\n\tfloat phase = k * pi;\n\tfloat t = iTime * (1.0 + k * 4.0);\n\t\n\tfloat cx = 0.2;\n\tfloat cz = 0.1;\n\tvec3 p0 = vec3(-cx, 0.0, 0.0);\n\tvec3 p1 = vec3(-cx, -0.2, -cz);\n\tvec3 p2 = vec3(-cx, -0.4, -cz);\n\tvec3 p3 = vec3(-cx, 0.2, cz);\n\tvec3 p4 = vec3(-cx, -0.4, cz);\n\t\n\tvec3 p5 = vec3(cx, 0.0, 0.0);\n\tvec3 p6 = vec3(cx, -0.2, -cz);\n\tvec3 p7 = vec3(cx, -0.4, -cz);\n\tvec3 p8 = vec3(cx, 0.2, cz);\n\tvec3 p9 = vec3(cx, -0.4, cz);\n\t\n\tvec3 p10 = vec3(0.0, 0.0, 0.0);\n\tvec3 p11 = vec3(cx, -0.2, 0.0);\n\t\n\tfloat angle0 = 0.0;\n\tfloat angle1 = 0.0;\n\tp0.y = -motor(-0.05, 0.05, t * 4.0 + phase);\n\tangle0 = -motor(pi * 0.35, pi * 0.55, t * 2.0 - pi * 0.5 + phase);\n\tangle1 = -motor(pi * 0.35, pi * 0.55, t * 2.0 + pi * 0.5 + phase);\n\tp1 = rotate_from_origin(p0, p1, 0.2, angle0); \n\tp3 = rotate_from_origin(p0, p3, 0.2, angle1); \n\tangle0 += -motor(0.0, pi * 0.15, t * 2.0 + pi + phase);\n\tangle1 += -motor(0.0, pi * 0.15, t * 2.0 + pi + pi + phase);\n\tp2 = rotate_from_origin(p1, p2, 0.2, angle0);\n\tp4 = rotate_from_origin(p3, p4, 0.2, angle1);\n\t\n\tt += pi * 0.5;\n\t\n\tp5.y = -motor(-0.05, 0.05, t * 4.0 + phase);\n\tangle0 = -motor(pi * 0.35, pi * 0.55, t * 2.0 - pi * 0.5 + phase);\n\tangle1 = -motor(pi * 0.35, pi * 0.55, t * 2.0 + pi * 0.5 + phase);\n\tp6 = rotate_from_origin(p5, p6, 0.2, angle0); \n\tp8 = rotate_from_origin(p5, p8, 0.2, angle1); \n\tangle0 += -motor(0.0, pi * 0.15, t * 2.0 + pi + phase);\n\tangle1 += -motor(0.0, pi * 0.15, t * 2.0 + pi + pi + phase);\n\tp7 = rotate_from_origin(p6, p7, 0.2, angle0);\n\tp9 = rotate_from_origin(p8, p9, 0.2, angle1);\n\t\n\tp10.y = -motor(-0.02, 0.02, t * 4.0 - pi * 0.5 + phase);\n\tp11 = preserve(p5, p11, -0.25);\n\tfloat w = 0.015;\n\t\n\tfloat d = sdPlane(p);\n\t\n\td = min(d, sdCapsule(p, p0, p1, w));\n\td = min(d, sdCapsule(p, p1, p2, w));\n\td = min(d, sdCapsule(p, p0, p3, w));\n\td = min(d, sdCapsule(p, p3, p4, w));\n\t\n\td = min(d, sdCapsule(p, p5, p6, w));\n\td = min(d, sdCapsule(p, p6, p7, w));\n\td = min(d, sdCapsule(p, p5, p8, w));\n\td = min(d, sdCapsule(p, p8, p9, w));\n\t\n\td = min(d, sdCapsule(p, p0, p10, w));\n\td = min(d, sdCapsule(p, p10, p5, w));\n\t\n\td = smin(d, sdCapsule(p, p5, p11, w), 0.1);\n\n    \treturn vec2(d, k);\n}\n\nvec3 calcNormal(in vec3 p) {\n\tvec3 e = vec3(0.001, 0.0, 0.0);\n\tvec3 nor = vec3(\n\t\tmap(p + e.xyy).x - map(p - e.xyy).x,\n\t\tmap(p + e.yxy).x - map(p - e.yxy).x,\n\t\tmap(p + e.yyx).x - map(p - e.yyx).x\n\t);\n\treturn normalize(nor);\n}\n\nvec2 castRay(in vec3 ro, in vec3 rd, in float maxt) {\n\tfloat precis = 0.001;\n\tfloat h = precis * 2.0;\n\tfloat t = 0.0;\n\tvec2 m = vec2(0.0);\n\tfor(int i = 0; i < 60; i++) {\n\tif(abs(h) < precis || t > maxt) continue;\n\t\tm = map(ro + rd * t);\n\t\th = m.x;\n\t\tt += h;\n\t}\n\treturn vec2(t, m.y);\n}\n\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float maxt, in float k) {\n\tfloat sh = 1.0;\n\tfloat t = mint;\n\tfloat h = 0.0;\n\tfor(int i = 0; i < 30; i++) {\n\tif(t > maxt) continue;\n\t\th = map(ro + rd * t).x;\n\t\tsh = min(sh, k * h / t);\n\t\tt += h;\n\t}\n\treturn sh;\n}\n\nvec3 render(in vec3 ro, in vec3 rd, out vec3 p) {\n\tvec3 col = vec3(1.0);\n\tvec2 m = castRay(ro, rd, 20.0);\n\tfloat t = m.x;\n\tvec3 pos = ro + rd * t;\n\tp = pos;\n\tvec3 nor = calcNormal(pos);\n\tvec3 lig = normalize(vec3(-0.4, 0.7, 0.5));\n\tfloat dif = clamp(dot(lig, nor), 0.0, 1.0);\n\tfloat spec = pow(clamp(dot(reflect(rd, nor), lig), 0.0, 1.0), 16.0);\n\tfloat sh = softshadow(pos, lig, 0.02, 20.0, 7.0);\n\tcol = col * (dif * (0.9 + 0.5 * m.y) + spec) * (0.5 + sh * 0.5) * (1.0 - pow(t, 0.8) * 0.1);\n\treturn col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 ms = 2.0 * iMouse.xy / iResolution.xy - 1.0;\n\tvec2 p = uv * 2.0 - 1.0;\n\tp.x *= iResolution.x / iResolution.y;\n\tvec3 ro = vec3(ms.x * 10.0, 1.0 - ms.y, 10.0);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 cw = normalize(ta - ro);\n\tvec3 cp = vec3(0.0, 1.0, 0.0);\n\tvec3 cu = normalize(cross(cw, cp));\n\tvec3 cv = normalize(cross(cu, cw));\n\tvec3 rd = normalize(p.x * cu + p.y * cv + 2.5 * cw);\n\tvec3 q = vec3(0.0);\n\tvec3 col = render(ro, rd, q);\n\t\n\tfragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2XWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 60, 60, 129], [131, 131, 155, 155, 187], [189, 189, 215, 215, 237], [239, 239, 278, 278, 303], [305, 305, 357, 357, 486], [488, 488, 537, 537, 601], [603, 603, 676, 676, 765], [767, 767, 811, 811, 878], [880, 880, 921, 921, 1008], [1010, 1010, 1031, 1031, 3329], [3331, 3331, 3359, 3359, 3556], [3558, 3558, 3611, 3611, 3842], [3844, 3844, 3928, 3928, 4113], [4115, 4115, 4164, 4164, 4620], [4622, 4622, 4679, 4679, 5193]], "test": "valid"}
{"id": "Xd2XWR", "name": "Time Coordinates", "author": "burito", "description": "An experiment on smooth lines, and making things tick.\n\nI completed this offline, so the functions have \"interesting\" quirks. That line drawing function in particular is... special. But it works, and I figured it out in my head.", "tags": ["drwho", "timecoordinates"], "likes": 142, "viewed": 4671, "published": "Public", "date": "1410882954", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Created by Daniel Burke - burito/2014\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// Inspiration from Dr Who (2005) S7E13 - The Name of the Doctor\n\nvec2 rot(vec2 p, float a)\n{\n    float c = cos(a);\n    float s = sin(a);\n    return vec2(p.x*c + p.y*s,\n                -p.x*s + p.y*c);\n}\n\nfloat circle(vec2 pos, float radius)\n{\n    return clamp(((1.0-abs(length(pos)-radius))-0.99)*100.0, 0.0, 1.0);\n    \n}\n\nfloat circleFill(vec2 pos, float radius)\n{\n    return clamp(((1.0-(length(pos)-radius))-0.99)*100.0, 0.0, 1.0);   \n}\n\n// Thanks Iigo Quilez!\nfloat line( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = -p - a;\n    vec2 ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    float d = length( pa - ba*h );\n    \n    return clamp(((1.0 - d)-0.99)*100.0, 0.0, 1.0);\n}\n\n// for posterity, the original evil function\nfloat EvilLine(vec2 pos, vec2 start, vec2 finish)\n{\n    vec2 delta = finish - start;\n    vec2 n = normalize(delta);\n    float l = length(delta);\n    float d = sign(n.x);\n    \n    float angle = atan(n.y / n.x);\n    vec2 t = rot(-pos - start, angle);\n    \n    float s = d < 0.0 ? 0.0: d*l;\n    float f = d < 0.0 ? d*l : 0.0;\n    if(t.x > s || t.x < f)return 0.0;\n\n    return clamp(((1.0 - abs(t.y))-0.99)*100.0, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n \n    vec3 colour = vec3(0);\n    vec3 white = vec3(1);\n    \n    \n    \n    float c = circle(p, 0.2);\n    c += circle(p, 0.1);\n    c += circle(p, 0.18);\n    c += circleFill(p, 0.005);\n\n//    c += circle(p, 1.3);\n    c += circle(p, 1.0);\n    if(p.x > 0.0)c += circle(p, 0.4);\n    if(p.x > 0.0)c += circle(p, 0.42);\n    if(p.x < 0.0)c += circle(p, 0.47);\n    c += circleFill(p+vec2(0.47, 0.0), 0.02);\n    c += circleFill(p+vec2(0.84147*0.47, 0.54030*0.47), 0.02);\n    c += circleFill(p+vec2(0.84147*0.47, -0.54030*0.47), 0.02);\n    c += circleFill(p+vec2(0.41614*0.47, 0.90929*0.47), 0.02);\n    c += circleFill(p+vec2(0.41614*0.47, -0.90929*0.47), 0.02);\n    \n    float t = iTime;\n    float t2 = t * -0.01;\n    float t3 = t * 0.03;\n    \n    vec2 angle1 = vec2(sin(t), cos(t));\n    vec2 a = angle1 * 0.7;\n    \n    t *= 0.5;\n    vec2 angle2 = vec2(sin(t), cos(t));\n    vec2 b = angle2 * 0.8;\n    \n    vec2 angle3 = vec2(sin(t2), cos(t2));\n    vec2 d = b + angle3* 0.4;\n\n    vec2 angle4 = vec2(sin(t3), cos(t3));\n    vec2 e = angle4 * 0.9;\n\n    vec2 angle5 = vec2(sin(t3+4.0), cos(t3+4.0));\n    vec2 f = angle5 * 0.8;\n    \n    vec2 angle6 = vec2(sin(t*-0.1+5.0), cos(t*-0.1+5.0));\n    vec2 h = angle6 * 0.8;\n    \n    \n\n    \n    \n    float tt = t * 1.4;\n    \n    float tm = mod(tt, 0.5);\n    float tmt = tt - tm;\n    if( tm > 0.4) tmt += (tm-0.4)*5.0;\n    vec2 tangle1 = vec2(sin(tmt), cos(tmt));\n\n\ttt *= 0.8;\n    tm = mod(tt, 0.6);\n    float tmt2 = tt - tm;\n    if( tm > 0.2) tmt2 += (tm-0.2)*1.5;\n    \n    vec2 tangle2 = vec2(sin(tmt2*-4.0), cos(tmt2*-4.0));\n   \n    vec2 tangle3 = vec2(sin(tmt2), cos(tmt2));\n    \n    tt = t+3.0;\n    tm = mod(tt, 0.2);\n    tmt = tt - tm;\n    if( tm > 0.1) tmt += (tm-0.1)*2.0;\n    vec2 tangle4 = vec2(sin(-tmt), cos(-tmt)); tmt += 0.9;\n    vec2 tangle41 = vec2(sin(-tmt), cos(-tmt)); tmt += 0.5;\n    vec2 tangle42 = vec2(sin(-tmt), cos(-tmt)); tmt += 0.5;\n    vec2 tangle43 = vec2(sin(-tmt), cos(-tmt)); tmt += 0.5;\n    vec2 tangle44 = vec2(sin(-tmt), cos(-tmt)); tmt += 0.5;\n    vec2 tangle45 = vec2(sin(-tmt), cos(-tmt));\n\n    tt = iTime+0.001;\n    tm = mod(tt, 1.0);\n    tmt = tt - tm;\n    if( tm > 0.9) tmt += (tm-0.9)*10.0;\n\n    vec2 tangle51 = 0.17*vec2(sin(-tmt), cos(-tmt)); tmt += 1.0471975511965976;\n    vec2 tangle52 = 0.17*vec2(sin(-tmt), cos(-tmt)); tmt += 1.0471975511965976;\n    vec2 tangle53 = 0.17*vec2(sin(-tmt), cos(-tmt));\n    \n    c += line(p, tangle51, -tangle53);\n    c += line(p, tangle52, tangle51);\n    c += line(p, tangle53, tangle52);\n    c += line(p, -tangle51, tangle53);\n    c += line(p, -tangle52, -tangle51);\n    c += line(p, -tangle53, -tangle52);\n\n    c += circleFill(p+tangle51, 0.01);\n    c += circleFill(p+tangle52, 0.01);\n    c += circleFill(p+tangle53, 0.01);\n    c += circleFill(p-tangle51, 0.01);\n    c += circleFill(p-tangle52, 0.01);\n    c += circleFill(p-tangle53, 0.01);\n    \n    \n    \n    c += circle(p+a, 0.2);\n    c += circle(p+a, 0.14);\n    c += circle(p+a, 0.1);\n    c += circleFill(p+a, 0.04);\n    c += circleFill(p+a+tangle3*0.2, 0.025);   \n    \n    \n    c += circle(p+a, 0.14);\n\n\n    c += circle(p+b, 0.2);\n    c += circle(p+b, 0.03);\n    c += circle(p+b, 0.15);\n    c += circle(p+b, 0.45);\n    c += circleFill(p+b+tangle1*0.05, 0.01);\n    c += circleFill(p+b+tangle1*0.09, 0.02);\n    c += circleFill(p+b+tangle1*0.15, 0.03);\n    c += circle(p+b+tangle1*-0.15, 0.03);\n    c += circle(p+b+tangle1*-0.07, 0.015);\n\n    c += circle(p+d, 0.08);\n\n\n    c += circle(p+e, 0.08);\n    \n\n    c += circle(p+f, 0.12);\n    c += circle(p+f, 0.10);\n    c += circleFill(p+f+tangle2*0.05, 0.01);\n    c += circleFill(p+f+tangle2*0.10, 0.01);\n    c += circle(p+f-tangle2*0.03, 0.01);\n    c += circleFill(p+f+vec2(0.085), 0.005);\n    c += circleFill(p+f, 0.005);\n\n    \n    vec2 g = tangle4 * 0.16;\n    c += circle(p+h, 0.05);\n    c += circle(p+h, 0.1);\n    c += circle(p+h, 0.17);\n    c += circle(p+h, 0.2);\n    c += circleFill(p+h+tangle41 *0.16, 0.01);\n    c += circleFill(p+h+tangle42 *0.16, 0.01);\n    c += circleFill(p+h+tangle43 *0.16, 0.01);\n    c += circleFill(p+h+tangle44 *0.16, 0.01);\n    c += circleFill(p+h+tangle45 *0.16, 0.01);\n    c += circleFill(p+h+angle1 *0.06, 0.02);\n    c += circleFill(p+h+tangle43*-0.16, 0.01);\n    \n    \n    c += line(p, vec2(0.0), a);\n    c += circleFill(p+b, 0.005);\n    c += circleFill(p+d, 0.005);\n    c += circleFill(p+e, 0.005);\n\n    c += line(p, b, a);\n    c += line(p, d, e);\n    c += line(p, b+tangle1*0.15, e);\n    c += line(p, e, f+vec2(0.085));\n\n    c += line(p, h+angle1*0.06, f);\n    c += line(p, h+tangle43*-0.16, d);\n    c += line(p, h+tangle42*0.16, e);\n    \n    \n    // of course I'd write a line function that\n    // doesn't handle perfectly vertical lines\n    c += line(p, vec2(0.001, -0.5), vec2(0.0001, 0.5));\n    c += circleFill(p+vec2(0.001, -0.5), 0.005);\n    c += circleFill(p+vec2(0.001, 0.5), 0.005);\n    \n    c = clamp(c, 0.0, 1.0);\n    colour = white * c;\n    \n\n    fragColor = vec4(colour, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xd2XWR.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[195, 195, 222, 222, 332], [334, 334, 372, 372, 451], [453, 453, 495, 495, 569], [571, 598, 645, 645, 838], [840, 885, 936, 936, 1307], [1309, 1309, 1366, 1366, 6411]], "test": "valid"}
{"id": "XdBSW1", "name": "StunnFx", "author": "kow", "description": "Forked from https://www.shadertoy.com/view/XdXGRB", "tags": ["text"], "likes": 8, "viewed": 231, "published": "Public", "date": "1411209615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Source edited by David Hoskins - 2013.\n\n// I took and completed this http://glsl.heroku.com/e#9743.20 - just for fun! 8|\n// Locations in 3x7 font grid, inspired by http://www.claudiocc.com/the-1k-notebook-part-i/\n// Had to edit it to remove line doubling.\n// ABC  a:GIOMJL b:AMOIG c:IGMO d:COMGI e:OMGILJ f:CBN g:OMGIUS h:AMGIO i:EEHN j:GHTS k:AMIKO l:BN m:MGHNHIO n:MGIO\n// DEF  o:GIOMG p:SGIOM q:UIGMO r:MGI s:IGJLOM t:BNO u:GMOI v:GJNLI w:GMNHNOI x:GOKMI y:GMOIUS z:GIMO\n// GHI\n// JKL \n// MNO\n// PQR\n// STU\n\n#define font_size 20. \n#define font_spacing .05\n#define STROKEWIDTH 0.05\n#define PI 3.14159265359\n\n#define A_ vec2(0.,0.)\n#define B_ vec2(1.,0.)\n#define C_ vec2(2.,0.)\n\n//#define D_ vec2(0.,1.)\n#define E_ vec2(1.,1.)\n//#define F_ vec2(2.,1.)\n\n#define G_ vec2(0.,2.)\n#define H_ vec2(1.,2.)\n#define I_ vec2(2.,2.)\n\n#define J_ vec2(0.,3.)\n#define K_ vec2(1.,3.)\n#define L_ vec2(2.,3.)\n\n#define M_ vec2(0.,4.)\n#define N_ vec2(1.,4.)\n#define O_ vec2(2.,4.)\n\n//#define P_ vec2(0.,5.)\n//#define Q_ vec2(1.,5.)\n//#define R_ vec2(1.,5.)\n\n#define S_ vec2(0.,6.)\n#define T_ vec2(1.,6.)\n#define U_ vec2(2.0,6.)\n\n#define A(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,J_,p) + t(J_,L_,p)\n#define B(p) t(A_,M_,p) + t(M_,O_,p) + t(O_,I_, p) + t(I_,G_,p)\n#define C(p) t(I_,G_,p) + t(G_,M_,p) + t(M_,O_,p) \n#define D(p) t(C_,O_,p) + t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p)\n#define E(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,L_,p) + t(L_,J_,p)\n#define F(p) t(C_,B_,p) + t(B_,N_,p) + t(G_,I_,p)\n#define G(p) t(O_,M_,p) + t(M_,G_,p) + t(G_,I_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define H(p) t(A_,M_,p) + t(G_,I_,p) + t(I_,O_,p) \n#define I(p) t(E_,E_,p) + t(H_,N_,p) \n#define J(p) t(E_,E_,p) + t(H_,T_,p) + t(T_,S_,p)\n#define K(p) t(A_,M_,p) + t(M_,I_,p) + t(K_,O_,p)\n#define L(p) t(B_,N_,p)\n#define M(p) t(M_,G_,p) + t(G_,I_,p) + t(H_,N_,p) + t(I_,O_,p)\n#define N(p) t(M_,G_,p) + t(G_,I_,p) + t(I_,O_,p)\n#define O(p) t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p) + t(M_,G_,p)\n#define P(p) t(S_,G_,p) + t(G_,I_,p) + t(I_,O_,p) + t(O_,M_, p)\n#define Q(p) t(U_,I_,p) + t(I_,G_,p) + t(G_,M_,p) + t(M_,O_, p)\n#define R(p) t(M_,G_,p) + t(G_,I_,p)\n#define S(p) t(I_,G_,p) + t(G_,J_,p) + t(J_,L_,p) + t(L_,O_,p) + t(O_,M_,p)\n#define T(p) t(B_,N_,p) + t(N_,O_,p) + t(G_,I_,p)\n#define U(p) t(G_,M_,p) + t(M_,O_,p) + t(O_,I_,p)\n#define V(p) t(G_,J_,p) + t(J_,N_,p) + t(N_,L_,p) + t(L_,I_,p)\n#define W(p) t(G_,M_,p) + t(M_,O_,p) + t(N_,H_,p) + t(O_,I_,p)\n#define X(p) t(G_,O_,p) + t(I_,M_,p)\n#define Y(p) t(G_,M_,p) + t(M_,O_,p) + t(I_,U_,p) + t(U_,S_,p)\n#define Z(p) t(G_,I_,p) + t(I_,M_,p) + t(M_,O_,p)\n#define STOP(p) t(N_,N_,p)\n\t\nvec2 caret_origin = vec2(3.0, .7);\nvec2 caret;\n\n//-----------------------------------------------------------------------------------\nfloat minimum_distance(vec2 v, vec2 w, vec2 p)\n{\t// Return minimum distance between line segment vw and point p\n  \tfloat l2 = (v.x - w.x)*(v.x - w.x) + (v.y - w.y)*(v.y - w.y); //length_squared(v, w);  // i.e. |w-v|^2 -  avoid a sqrt\n  \tif (l2 == 0.0) {\n\t\treturn distance(p, v);   // v == w case\n\t}\n\t\n\t// Consider the line extending the segment, parameterized as v + t (w - v).\n  \t// We find projection of point p onto the line.  It falls where t = [(p-v) . (w-v)] / |w-v|^2\n  \tfloat t = dot(p - v, w - v) / l2;\n  \tif(t < 0.0) {\n\t\t// Beyond the 'v' end of the segment\n\t\treturn distance(p, v);\n\t} else if (t > 1.0) {\n\t\treturn distance(p, w);  // Beyond the 'w' end of the segment\n\t}\n  \tvec2 projection = v + t * (w - v);  // Projection falls on the segment\n\treturn distance(p, projection);\n}\n\n//-----------------------------------------------------------------------------------\nfloat textColor(vec2 from, vec2 to, vec2 p)\n{\n\tp *= font_size;\n\tfloat inkNess = 0., nearLine, corner;\n\tnearLine = minimum_distance(from,to,p); // basic distance from segment, thanks http://glsl.heroku.com/e#6140.0\n\tinkNess += smoothstep(0., 1., 1.- 14.*(nearLine - STROKEWIDTH)); // ugly still\n\tinkNess += smoothstep(0., 2.5, 1.- (nearLine  + 5. * STROKEWIDTH)); // glow\n\treturn inkNess;\n}\n\n//-----------------------------------------------------------------------------------\nvec2 grid(vec2 letterspace) \n{\n\treturn ( vec2( (letterspace.x / 2.) * .65 , 1.0-((letterspace.y / 2.) * .95) ));\n}\n\n//-----------------------------------------------------------------------------------\nfloat count = 0.0;\nfloat t(vec2 from, vec2 to, vec2 p) \n{\n\tcount++;\n\tif (count > iTime*20.0) return 0.0;\n\treturn textColor(grid(from), grid(to), p);\n}\n\n//-----------------------------------------------------------------------------------\nvec2 r(vec2 fragCoord)\n{\n\tvec2 pos = fragCoord.xy/iResolution.xy;\n\tpos.y -= caret.y;\n\tpos.x -= font_spacing*caret.x;\n\treturn pos;\n}\n\n//-----------------------------------------------------------------------------------\nvoid add()\n{\n\tcaret.x += 1.0;\n}\n\n//-----------------------------------------------------------------------------------\nvoid space()\n{\n\tcaret.x += 1.5;\n}\n\n//-----------------------------------------------------------------------------------\nvoid newline()\n{\n\tcaret.x = caret_origin.x;\n\tcaret.y -= .18;\n}\n\n//-----------------------------------------------------------------------------------\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat d = 0.;\n\tvec3 col = vec3(0.1, .07+0.07*(.5+sin(fragCoord.y*3.14159*1.1+iTime*2.0)) + sin(fragCoord.y*.01+iTime+2.5)*0.05, 0.1);\n\t\n\tcaret = caret_origin;\n\n\t// the quick brown fox jumps over the lazy dog...\n\td += H(r(fragCoord)); add(); d += E(r(fragCoord)); add(); d += L(r(fragCoord)); add(); d += L(r(fragCoord)); add(); d += O(r(fragCoord)); add();\n    newline(); \n    d += T(r(fragCoord)); add(); d += H(r(fragCoord)); add(); d += I(r(fragCoord)); add(); d += S(r(fragCoord)); space();d += I(r(fragCoord)); add(); d += S(r(fragCoord)); space();\n\td += S(r(fragCoord)); add(); d += T(r(fragCoord)); add(); d += U(r(fragCoord)); add(); d += N(r(fragCoord)); add(); d += N(r(fragCoord)); space();\n\tnewline(); \n\td = clamp(d* (.75+sin(fragCoord.x*PI*.5-iTime*4.3)*.5), 0.0, 1.0);\n      \n    col += vec3(d*.5, d, d*.85);\n\tvec2 xy = fragCoord.xy / iResolution.xy;\n\tcol *= vec3(.4, .4, .3) + 0.5*pow(100.0*xy.x*xy.y*(1.0-xy.x)*(1.0-xy.y), .4 );\t\n    fragColor = vec4( col, 1.0 );\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdBSW1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2655, 2741, 2789, 2852, 3531], [3533, 3619, 3664, 3664, 4008], [4010, 4096, 4126, 4126, 4210], [4317, 4317, 4355, 4355, 4448], [4450, 4536, 4560, 4560, 4667], [4669, 4755, 4767, 4767, 4786], [4788, 4874, 4888, 4888, 4907], [4909, 4995, 5011, 5011, 5057], [5059, 5145, 5202, 5202, 6185]], "test": "valid"}
{"id": "XdBSWD", "name": "Breadth first traversal", "author": "Zavie", "description": "A breadth first traversal proof of concept. This seems to work, but is offensively slow due to the O(n) fetches. Anyone has a clever idea to make it better?", "tags": ["stack", "recursion", "breadthfirst"], "likes": 0, "viewed": 198, "published": "Public", "date": "1411905342", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_DEPTH 32\n\n// ---8<----------------------------------------------------------------------\n// Tools for tree traversal\n\nstruct Item\n{\n    vec2 v;\n    float f;\n};\n    \nint stackPointer = 0;\nItem fifoStack[MAX_DEPTH];\n\nvoid push(Item item)\n{\n    stackPointer++;\n    for (int i = 0; i < MAX_DEPTH; ++i)\n    {\n        if (i == stackPointer)\n        {\n            fifoStack[i] = item;\n        }\n    }\n}\n\n// ---8<----------------------------------------------------------------------\n\nvec3 computeSomething(Item item)\n{\n    return vec3(item.v.x > 0. ? item.f : 0.,\n                item.v.y > 0. ? item.f : 0.,\n                0.);\n}\n\nvec3 recComputeSomething(vec2 uv)\n{\n    vec3 acc = vec3(0.);\n    fifoStack[0] = Item(uv, 0.1);\n\n    for (int i = 0; i < MAX_DEPTH; ++i)\n    {\n        if (i > stackPointer) break;\n        Item item = fifoStack[i];\n\n        acc += computeSomething(item);\n        float scale = 1.+0.1*sin(iTime);\n        push(Item(item.v * vec2(2.) + scale * vec2(-1., -1.), item.f * 0.5));\n        push(Item(item.v * vec2(2.) + scale * vec2(-1.,  1.), item.f * 0.5));\n        push(Item(item.v * vec2(2.) + scale * vec2( 1., -1.), item.f * 0.5));\n        push(Item(item.v * vec2(2.) + scale * vec2( 1.,  1.), item.f * 0.5));\n    }\n    \n    return acc;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * fragCoord.xy / iResolution.xy - 1.;\n\tfragColor = vec4(recComputeSomething(uv),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdBSWD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[227, 227, 249, 249, 407], [489, 489, 523, 523, 636], [638, 638, 673, 673, 1272], [1274, 1274, 1331, 1331, 1433]], "test": "valid"}
{"id": "XdjSRD", "name": "Forked from gltracy Raymarching", "author": "axelduch", "description": "I just modified a bit the code to change the shape of the cube", "tags": ["raymarching", "light"], "likes": 0, "viewed": 186, "published": "Public", "date": "1409674328", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// ray marching\nconst int max_iterations = 255;\nconst float stop_threshold = 0.001;\nconst float grad_step = 0.1;\nconst float clip_far = 1000.0;\n\n// math\nconst float PI = 3.14159265359;\nconst float DEG_TO_RAD = PI / 180.0;\n\n// distance function\nfloat dist_sphere( vec3 pos, float r ) {\n\treturn length( pos ) - r;\n}\n\nfloat dist_box( vec3 pos, vec3 size ) {\n\treturn length( max( abs( pos ) - size, 0.0 ) );\n}\n\n// get distance in the world\nfloat dist_field( vec3 pos ) {\n\t// ...add objects here...\n\t\n\t// object 0 : sphere\n\tfloat d0 = dist_sphere( pos, 1.7 + 1.3 * cos(pow(iTime * 0.1, pos[2] - (pos[1] + pos[2]) / 2.0)) );\n\t\n\t// object 1 : cube\n\tfloat d1 = dist_box( pos, vec3( 2.0 ) );\n\t\t\n\t// union     : min( d0,  d1 )\n\t// intersect : max( d0,  d1 )\n\t// subtract  : max( d1, -d0 )\n\treturn max( d1, -d0 );\n}\n\n// phong shading\nvec3 shading( vec3 v, vec3 n, vec3 eye ) {\n\t// ...add lights here...\n\t\n\tfloat shininess = 16.0;\n\t\n\tvec3 final = vec3( 0.0 );\n\t\n\tvec3 ev = normalize( v - eye );\n\tvec3 ref_ev = reflect( ev, n );\n\t\n\t// light 0\n\t{\n\t\tvec3 light_pos   = vec3( 20.0, 20.0, 20.0 );\n\t\tvec3 light_color = vec3( 0.5, 0.5, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\t\n\t// light 1\n\t{\n\t\tvec3 light_pos   = vec3( -20.0, -20.0, -20.0 );\n\t\tvec3 light_color = vec3( 0.0, 0.5, 1.0 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\n    // light 2\n\t{\n\t\tvec3 light_pos   = vec3( 0.0, 0.0, 0.0 );\n\t\tvec3 light_color = vec3( 0.5, 0.5, 0.5 );\n\t\n\t\tvec3 vl = normalize( light_pos - v );\n\t\n\t\tfloat diffuse  = max( 0.0, dot( vl, n ) );\n\t\tfloat specular = max( 0.0, dot( vl, ref_ev ) );\n\t\tspecular = pow( specular, shininess );\n\t\t\n\t\tfinal += light_color * ( diffuse + specular ); \n\t}\n\treturn final;\n}\n\n// get gradient in the world\nvec3 gradient( vec3 pos ) {\n\tconst vec3 dx = vec3( grad_step, 0.0, 0.0 );\n\tconst vec3 dy = vec3( 0.0, grad_step, 0.0 );\n\tconst vec3 dz = vec3( 0.0, 0.0, grad_step );\n\treturn normalize (\n\t\tvec3(\n\t\t\tdist_field( pos + dx ) - dist_field( pos - dx ),\n\t\t\tdist_field( pos + dy ) - dist_field( pos - dy ),\n\t\t\tdist_field( pos + dz ) - dist_field( pos - dz )\t\t\t\n\t\t)\n\t);\n}\n\n// ray marching\nfloat ray_marching( vec3 origin, vec3 dir, float start, float end ) {\n\tfloat depth = start;\n\tfor ( int i = 0; i < max_iterations; i++ ) {\n\t\tfloat dist = dist_field( origin + dir * depth );\n\t\tif ( dist < stop_threshold ) {\n\t\t\treturn depth;\n\t\t}\n\t\tdepth += dist;\n\t\tif ( depth >= end) {\n\t\t\treturn end;\n\t\t}\n\t}\n\treturn end;\n}\n\n// get ray direction\nvec3 ray_dir( float fov, vec2 size, vec2 pos ) {\n\tvec2 xy = pos - size * 0.5;\n\n\tfloat cot_half_fov = tan( ( 90.0 - fov * 0.5 ) * DEG_TO_RAD );\t\n\tfloat z = size.y * 0.5 * cot_half_fov;\n\t\n\treturn normalize( vec3( xy, -z ) );\n}\n\n// camera rotation : pitch, yaw\nmat3 rotationXY( vec2 angle ) {\n\tvec2 c = cos( angle );\n\tvec2 s = sin( angle );\n\t\n\treturn mat3(\n\t\tc.y      ,  0.0, -s.y,\n\t\ts.y * s.x,  c.x,  c.y * s.x,\n\t\ts.y * c.x, -s.x,  c.y * c.x\n\t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// default ray dir\n\tvec3 dir = ray_dir( 45.0, iResolution.xy, fragCoord.xy );\n\t\n\t// default ray origin\n\tvec3 eye = vec3( 0.0, 0.0, 7.0 );\n\n\t// rotate camera\n\tmat3 rot = rotationXY( vec2( iTime * 0.3 ) );\n\tdir = rot * dir;\n\teye = rot * eye;\n\t\n\t// ray marching\n\tfloat depth = ray_marching( eye, dir, 0.0, clip_far );\n\tif ( depth >= clip_far ) {\n\t\tdiscard;\n\t}\n\t\n\t// shading\n\tvec3 pos = eye + dir * depth;\n\tvec3 n = gradient( pos );\n\tfragColor = vec4( shading( pos, n, eye ), 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdjSRD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[223, 244, 284, 284, 313], [315, 315, 354, 354, 405], [407, 436, 466, 517, 804], [806, 823, 865, 891, 2066], [2068, 2097, 2124, 2124, 2458], [2460, 2476, 2545, 2545, 2795], [2797, 2818, 2866, 2866, 3042], [3044, 3076, 3107, 3107, 3263], [3265, 3265, 3322, 3342, 3804]], "test": "valid"}
{"id": "XdjSzD", "name": "Apollonian Fractures", "author": "otaviogood", "description": "I was trying to understand the math behind the \"apollonian\" fractal. I still don't intuitively get it, but I got caught up making tweaks to the algorithm and ended up with this.", "tags": ["fractal", "apollonian"], "likes": 56, "viewed": 3527, "published": "Public API", "date": "1410158200", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*--------------------------------------------------------------------------------------\nLicense CC0 - http://creativecommons.org/publicdomain/zero/1.0/\nTo the extent possible under law, the author(s) have dedicated all copyright and related and neighboring rights to this software to the public domain worldwide. This software is distributed without any warranty.\n----------------------------------------------------------------------------------------\n^ This means do ANYTHING YOU WANT with this code. Because we are programmers, not lawyers.\n-Otavio Good\n*/\n\n// noise functions\nfloat Hash2d(vec2 uv)\n{\n    float f = uv.x + uv.y * 37.0;\n    return fract(sin(f)*104003.9);\n}\nfloat mixP(float f0, float f1, float a)\n{\n    return mix(f0, f1, a*a*(3.0-2.0*a));\n}\nvec2 noise2dTex2(vec2 uv)\n{\n    vec2 fr = fract(uv);\n    vec2 smoothv = fr*fr*(3.0-2.0*fr);\n    vec2 fl = floor(uv);\n    uv = smoothv + fl;\n    return textureLod(iChannel0, (uv + 0.5)/iChannelResolution[0].xy, 0.0).xy;\t// use constant here instead?\n}\nconst vec2 zeroOne = vec2(0.0, 1.0);\nfloat noise2d(vec2 uv)\n{\n    vec2 fr = fract(uv.xy);\n    vec2 fl = floor(uv.xy);\n    float h00 = Hash2d(fl);\n    float h10 = Hash2d(fl + zeroOne.yx);\n    float h01 = Hash2d(fl + zeroOne);\n    float h11 = Hash2d(fl + zeroOne.yy);\n    return mixP(mixP(h00, h10, fr.x), mixP(h01, h11, fr.x), fr.y);\n}\n\n\nfloat Fractal(vec2 p)\n{\n    vec2 pr = p;\n    float scale = 1.0;\n    float iter = 1.0;\n    for (int i = 0; i < 12; i++)\n    {\n        vec2 n2 = noise2dTex2(p*0.15*iter+iTime*1.925);\n        float nx = n2.x - 0.5;\n        float ny = n2.y;\n        pr += vec2(nx, ny)*0.0002*iter*iter*iter;\n        pr = fract(pr*0.5+0.5)*2.0 - 1.0;\n        float len = pow(dot(pr, pr), 1.0+nx*0.5);\n        float inv = 1.1/len;\n        pr *= inv;\n        scale *= inv;\n        iter += 1.0;\n    }\n    float b = abs(pr.x)*abs(pr.y)/scale;\n    return pow(b, 0.125)*0.95;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // center and scale the UV coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 0.94;\n\n    // do the magic\n    vec2 warp = normalize(uv) * (1.0-pow(length(uv), 0.45));\n    vec3 finalColor = vec3(Fractal(uv*2.0+1.0),\n                           Fractal(uv*2.0+37.0),\n                           Fractal((warp+0.5)*2.0+15.0));\n    finalColor = 1.0 - finalColor;\n    float circle = 1.0-length(uv*2.2);\n    float at = atan(uv.x, uv.y);\n    float aNoise = noise2d(vec2(at * 30.0, iTime));\n    aNoise = aNoise * 0.5 + 0.5;\n    finalColor *= pow(max(0.0, circle), 0.1)*2.0;\t// comment out this line to see the whole fractal.\n    finalColor *= 1.0 + pow(1.0 - abs(circle), 30.0);\t// colorful outer glow\n    finalColor += vec3(1.0, 0.3, 0.03)*3.0 * pow(1.0 - abs(circle), 100.0) * aNoise;\t// outer circle\n    float outer = (1.0 - pow(max(0.0, circle), 0.1)*2.0);\n    finalColor += vec3(1.,0.2,0.03)*0.4* max(0.0, outer*(1.0-length(uv)));\n    fragColor = vec4(finalColor, 1.0);\n}\n", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XdjSzD.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[562, 581, 604, 604, 675], [676, 676, 717, 717, 760], [761, 761, 788, 788, 1011], [1049, 1049, 1073, 1073, 1346], [1349, 1349, 1372, 1372, 1898], [1900, 1900, 1957, 2000, 2998]], "test": "error"}
{"id": "Xs2XzD", "name": "circle illusion ", "author": "FabriceNeyret2", "description": "These are concentric circles.\nOur perception on shape is influenced a lot by local gradients.", "tags": ["illusion", "short"], "likes": 3, "viewed": 1506, "published": "Public API", "date": "1409830994", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define A .15*3.*sin(t) // 4.*iMouse.y/iResolution.y\n#define L 2.\n#define t iTime\n\nfloat text(vec2 pos) {\n  // return texture(iChannel0,pos).r;\n  return pow(max(0.,sin(8.*3.1416*pos.x)*sin(8.*3.1416*pos.y)),.8)+.3*(1.-cos(.025*6.28*t));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.*(fragCoord.xy / iResolution.y - vec2(.9,.5));\n    float r = length(uv), a = atan(uv.y,uv.x);\n    \n    // concentric circles\n    float v = pow(max(0.,sin(3.*6.283*log(r)-0.*2.*t)),.8);\n    //float v = pow(max(0.,sin(.5*3.*6.283*log(r)-0.*2.*t)),5.);\n    \n    // pattern\n    vec2 grid = vec2((a+0.*iTime)*4./3.1416,log(r)+ a/3.1416);\n    float t = text(grid+vec2(0.,A/L*sin(L*grid.x)));\n    v *= t;\n    //v = .8*(v-1.) +t;\n    \n\tfragColor = vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Xs2XzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[83, 83, 105, 143, 238], [240, 240, 297, 297, 761]], "test": "valid"}
{"id": "XsBSWW", "name": "Soothing", "author": "pixelzealot", "description": "Just a 2D lightfield visualisation experiment", "tags": ["2d", "raytrace", "experiemnt"], "likes": 8, "viewed": 684, "published": "Public", "date": "1411815623", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define M_PI 3.14159265358979323846\n#define FLT_MAX 1000000.0\n\t\nstruct line\n{\n\tvec4 line;\n\tvec3 emissive;\n};\n\nbool intersect_line(vec2 ro, vec2 rd, vec4 CD, inout float t)\n{\n\tvec2 A = ro;\n\tvec2 B = ro + rd;\n\n\tvec2 AmC = ro - CD.xy;\n\tvec2 DmC = CD.zw - CD.xy;\n\tvec2 BmA = rd;\n\t\n\tfloat denom = (BmA.x*DmC.y)-(BmA.y*DmC.x);\n\t\n\tif (denom != 0.0)\n\t{\n\t\tfloat r = ((AmC.y * DmC.x) - (AmC.x * DmC.y)) / denom;\n\t\tfloat s = ((AmC.y * BmA.x) - (AmC.x * BmA.y)) / denom;\n\t\t\n\t\tif ((r > 0.0 && r < t) && (s > 0.0 && s < 1.0))\n\t\t{\n\t\t\tt = r;\n\t\t\treturn true;\n\t\t}\n\t}\n\t\n\treturn false;\n\t\n}\n\nbool intersect_scene(vec2 ro, vec2 rd, inout float t, out vec3 colour)\n{\n\tfloat angle = (iTime * 0.20) * 2.0 * M_PI;\n\tvec2 dir = vec2(cos(angle), sin(angle));\n    \t\n\tbool intersect = false;\n\tfloat minDist = t;\n\t\n\tvec4 lines[4];\n    vec2 normal[4];\n\t\n\tvec2 extent0 = dir * 0.1;\n    vec2 nrm0 = vec2(dir.y, -dir.x);\n\t\n    vec2 extent1 = vec2(dir.y, -dir.x) * 0.1;\n    vec2 nrm1 = dir;\n        \n\tfloat offset = 0.25;\n\t\n\tlines[0] = vec4(vec2(-offset, 0.0) + extent1, vec2(-offset, 0.0) - extent1);\n    normal[0] = nrm1;\n    \n\tlines[1] = vec4(vec2( offset, 0.0) + extent1, vec2( offset, 0.0) - extent1);\n    normal[1] = -nrm1;\n    \n\tlines[2] = vec4(vec2(0.0, -offset) + extent0, vec2(0.0, -offset) - extent0);\n    normal[2] = nrm0;\n    \n\tlines[3] = vec4(vec2(0.0,  offset) + extent0, vec2(0.0,  offset) - extent0);\n    normal[3] = -nrm0;\n\t\n\tvec3 colours[4];\n\tfloat lightComp = 1.0;\n\tfloat darkComp = 0.3;\n\t\n\tcolours[0] = vec3(lightComp, darkComp, darkComp);\n\tcolours[1] = vec3(darkComp, darkComp, lightComp);\n\t\n    colours[2] = vec3(darkComp, lightComp, darkComp);\n\tcolours[3] = vec3(darkComp, lightComp, darkComp);\n\t\n\tfor (int j = 0; j < 4; j++)\n\t{\n\t\tif (intersect_line(ro, rd, lines[j], minDist))\n\t\t{\n\t\t\tcolour = colours[j] * abs(dot(-rd, normal[j]));\n\t\t\tintersect = true;\n\t\t}\t\n\t}\n\t\n\tt = minDist;\n\treturn intersect;\n}\t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat aspect = iResolution.y / iResolution.x;\n\tvec2 ro = -1.0 + 2.0 * (fragCoord.xy / iResolution.xy);\n\tro.y *= aspect;\n\t\n\tvec3 total = vec3(0.0);\n\t\n\tfor (int i = 0; i < 360; i++)\n\t{\n\t\tfloat angle = 2.0 * M_PI * (float(i) / 360.0);\n\t\tvec2 rd = vec2(cos(angle), sin(angle));\n\t\t\n\t\tfloat t = FLT_MAX;\n\t\tvec3 colour = vec3(0.0);\n\t\t\n\t\tif (intersect_scene(ro, rd, t, colour))\n\t\t{\n\t\t\ttotal += colour;\n\t\t}\n\t}\n\ttotal /= 360.0;\n\t\n\tfloat exposure = 1.0;\n\t\n\tfragColor = vec4(pow(total * exposure, vec3(1.0/2.2)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBSWW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[110, 110, 173, 173, 569], [571, 571, 643, 643, 1885]], "test": "valid"}
{"id": "XsBXRw", "name": "Light Clock", "author": "mplanck", "description": "Testing the iDate variable and came up with this quick sketch.  Thanks to @301z for his sweet fire shader (repurposed here)", "tags": ["clock", "atmosphere", "date"], "likes": 19, "viewed": 956, "published": "Public", "date": "1410062747", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// The atmosphere fog effect is a pretty expensive part of the shader since I'm\n// recomputing the effect once per time feature.  I rescale and shift the atmos\n// effect per time feature to provide the illusion of depth.  Decrease the number\n// of ATMOS_DETAIL_ITERATIONS if your gpu is melting, or to get more detail in the\n// atmosphere, increase it to 8.\n//\n\n#define ATMOS_DETAIL_ITERATIONS 4\n\n#define MONTH_WIDTH .05\n#define DAY_WIDTH .025\n#define HOUR_WIDTH .0125\n#define MINUTE_WIDTH .006\n#define SECOND_WIDTH .0015\n#define TICK_WIDTH .1\n\n// ------------------------------------\n// following grabbed and modified from Fire from @301z - https://www.shadertoy.com/view/Xsl3zN\n// hash grabbed from David Hoskins - https://www.shadertoy.com/view/4djSRW\n\nfloat hash12(vec2 p)\n{\n\tp  = fract(p * vec2(5.3983, 5.4427));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4337);\n}\n\nfloat noise(vec2 n) \n{\n\tconst vec2 d = vec2(0.0, 1.0);\n\tvec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\n    return mix(mix(hash12(b), \n                   hash12(b + d.yx), f.x), \n               mix(hash12(b + d.xy), \n                   hash12(b + d.yy), f.x), \n               f.y);\n}\n\nfloat fbm(vec2 n) \n{\n\tfloat total = 0.0, amplitude = 1.0;\n\tfor (int i = 0; i < ATMOS_DETAIL_ITERATIONS; i++) \n    {\n\t\ttotal += noise(n) * amplitude;\n\t\tn += n;\n\t\tamplitude *= 0.5;\n\t}\n\treturn total;\n}\n\nfloat atmos( vec2 p )\n{\n\tfloat q = fbm(p - iTime * 0.1);\n\tvec2 r = vec2(fbm(p + q + iTime * 0.01 - p.x - p.y), fbm(p + q - iTime * 0.04));\n\treturn mix(.1, .4, fbm(p + r)) + mix(.6, .8, r.x) - mix(.0, .4, r.y);\n}\n\n// ------------------------------------\n\nvec3 draw_grid(vec2 uv) \n{\n    float gridLine = fract(60. * uv.x);\n    float mask = smoothstep(0., .1, uv.y) * smoothstep(1., .9, uv.y) ;\n    \n    mask *= smoothstep( .05, .0, abs(gridLine - .5));\n    return mask * 0.05 * vec3(1., 1., 1.);\n}\n\nvec3 draw_bg_and_tick(vec2 uv)\n{ \n    float tickCenter = (1. + 2. * TICK_WIDTH) * fract(iTime * .1) - TICK_WIDTH;\n    float f = abs(uv.x - tickCenter);\n\n    float beamSpread = .1;\n    float lightBeam = smoothstep( TICK_WIDTH + beamSpread, TICK_WIDTH - beamSpread, f);\n            \n    vec3 lightColor = mix(vec3(1., 0., 0.),  vec3(1.4, .4, .3), lightBeam);\n    \n    lightColor *= atmos( 6. * (uv + vec2(50., 50.)) ); // scale and shift fog to fake depth\n\n    return .3 * mix( lightColor, vec3(.1,.1,.1), uv.y);\n}\n\nvec3 draw_second(vec2 uv) \n{\n    float secondCenter = fract(floor(iDate.w) / 60.);\n    float f = abs(uv.x - secondCenter);\n    \n    float lightBeam = max(smoothstep(0., 1., uv.y), 4. * smoothstep(.001, .0, pow(uv.y, 1.5)));    \n    float beamSpread = .001;    \n    lightBeam *= smoothstep( SECOND_WIDTH + beamSpread, SECOND_WIDTH - beamSpread, f);\n    \n    float lightIntensity = lightBeam * 6.2;\n    lightIntensity += .8 * smoothstep(.1, .0, uv.y) * smoothstep(.05, .0, abs(uv.x - secondCenter)); \n    \n    lightIntensity *= atmos( 5.5 * (uv + vec2(50., 50.)) ); // scale and shift fog to fake depth\n    \n    return vec3(1., .12, .1) * lightIntensity;\n}\n\nvec3 draw_minute(vec2 uv) \n{\n    float minuteCenter = fract(iDate.w / 3600.); \n    float f = abs(uv.x - minuteCenter);\n    \n    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.02, .0, pow(uv.y, 1.6)));\n    float beamSpread = .005 + .05 * max(0., pow((.9 - uv.y), 3.));\n    lightBeam *= smoothstep( MINUTE_WIDTH + beamSpread, MINUTE_WIDTH - beamSpread, abs(uv.x - minuteCenter));\n    \n    float lightIntensity = lightBeam;\n    lightIntensity += .8 * smoothstep(.03, .0, uv.y) * smoothstep(.03, .0, abs(uv.x - minuteCenter)); \n    \n    lightIntensity *= atmos( 4.5 * (uv + vec2(40., 40.)) ); // scale and shift fog to fake depth\n    \n    return vec3(1., .41, .18) * lightIntensity;\n}\n\nvec3 draw_hour(vec2 uv) \n{\n    float hourCenter = fract(iDate.w / 86400.);  \n    float f = abs(uv.x - hourCenter);\n    \n    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.03, .0, pow(uv.y, 1.5)));    \n    float beamSpread = .008 + .05 * max(0., pow((1. - uv.y), 3.));\n    lightBeam *= smoothstep( HOUR_WIDTH + beamSpread, HOUR_WIDTH - beamSpread, f);\n        \n    float lightIntensity = lightBeam * .8;    \n    lightIntensity += smoothstep(.02, -.01, uv.y) * smoothstep(.05, .0, f);     \n    \n    lightIntensity *= atmos( 4. * (uv + vec2(30., 30.)) ); // scale and shift fog to fake depth\n    \n    return vec3(1., .6, .3) * lightIntensity;\n    \n}\n\nvec3 draw_day(vec2 uv) \n{\n    float dayCenter = iDate.z / 31.;\n\tfloat f = abs(uv.x - dayCenter);\n    \n    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.05, .0, pow(uv.y, 1.4)));\n    float beamSpread = .01 + .1 * max(0., pow((1. - uv.y), 3.));\n    lightBeam *= smoothstep( DAY_WIDTH + beamSpread, DAY_WIDTH - beamSpread, f);\n    \n    float lightIntensity = lightBeam * .6;\n    lightIntensity += smoothstep(.02, -.01, uv.y) * smoothstep(.13, .0, f);\n    \n    lightIntensity *= atmos( 3.5 * (uv + vec2(20., 20.)) ); // scale and shift fog to fake depth\n    \n    return vec3(1., 0.7, 0.5) * lightIntensity;\n    \n}\n\nvec3 draw_month(vec2 uv) \n{\n    float monthCenter = iDate.y / 12.;\n    \n    float lightBeam = max(smoothstep(0., 1., uv.y), smoothstep(.15, .0, pow(uv.y, 1.3)));        \n    float f = .03 + .1 * max(0., pow((1.2 - uv.y), 3.));    \n    lightBeam *= smoothstep( MONTH_WIDTH + f, MONTH_WIDTH - f, abs(uv.x - monthCenter));\n    \n    float lightIntensity = lightBeam * .4;\n    lightIntensity += .5 * smoothstep(.012, .0, uv.y) * smoothstep(.18, .0, abs(uv.x - monthCenter)); \n    \n    lightIntensity *= atmos( 3. * (uv + vec2(10., 10.)) ); // scale and shift fog to fake depth\n\n    return vec3(1., 0.8, 0.7) * lightIntensity;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    vec3 scene_color = vec3(0.);\n    scene_color += draw_month(uv);\n    scene_color += draw_day(uv);\n    scene_color += draw_hour(uv);\n    scene_color += draw_minute(uv);\n    scene_color += draw_second(uv);    \n    scene_color += draw_bg_and_tick(uv);\n    scene_color += draw_grid(uv);\n    \n    fragColor.rgb = scene_color;\n    \n    //fragColor.rgb = vec3(atmos(5. * uv));\n}\n                                ", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "false", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBXRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[756, 756, 778, 778, 906], [908, 908, 930, 930, 1211], [1213, 1213, 1233, 1233, 1411], [1413, 1413, 1436, 1436, 1624], [1667, 1667, 1693, 1693, 1908], [1910, 1910, 1942, 1942, 2422], [2424, 2424, 2452, 2452, 3078], [3080, 3080, 3108, 3108, 3773], [3775, 3775, 3801, 3801, 4434], [4436, 4436, 4461, 4461, 5059], [5061, 5061, 5088, 5088, 5683], [5685, 5685, 5742, 5742, 6172]], "test": "valid"}
{"id": "XsBXWR", "name": "tile illusion", "author": "FabriceNeyret2", "description": "inspired from https://pic.twitter.com/MXrb1L8rrv", "tags": ["illusion", "short"], "likes": 15, "viewed": 1727, "published": "Public API", "date": "1410625289", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f(float x) { return x + .2*sin(1.6*x); }\n\nfloat solve(float x0,float x1,float y) {\n    float y0=f(x0), y1=f(x1);\n    if (y1<y0) { float x2=x1;x1=x0;x0=x2; float y2=y1;y1=y0;y0=y2; }\n    float xn, yn;\n    for (int i=0; i<20; i++) {\n\t    xn = x0 + (x1-x0)/(y1-y0)*(y-y0),\n    \tyn=f(xn);\n        if (yn>y) {x1=xn; y1=yn;} else {x0=xn; y0=yn; }\n     }\n    return xn;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    vec2 uv = fragCoord.xy / iResolution.y;\n    uv *= 15.;\n     float y0 = solve(uv.y-3.,uv.y,  floor(f(uv.y))),\n           y1 = solve(uv.y,uv.y+3., floor(f(uv.y))+1.);\n    uv.y = f(uv.y);\n    uv.x /= (y1-y0);\n    float s = mod(floor(uv.y),2.);\n    float v = .55;\n    if (fract(uv.y)>.07) {\n    \tuv.x += t*sign(s-.5);\n    \tfloat c = mod(floor(uv.x)+floor(uv.y),2.);\n    \tv = c;\n    }\n\tfragColor = vec4(v);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsBXWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 46], [48, 48, 88, 88, 370], [372, 372, 429, 429, 858]], "test": "valid"}
{"id": "XsjSDh", "name": "Spiral                         .", "author": "ChuckNorris", "description": "For best effect enable fullscreen mode and look at center for one minute", "tags": ["spiral", "cc0"], "likes": 1, "viewed": 185, "published": "Public", "date": "1411486941", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// LICENSE: CC0\n// *-SA-NC considered to be cancerous and non-free\n\nconst float PI = 3.14159;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy * 2.0 - 1.0;\n    uv.x *= iResolution.x/iResolution.y;\n    \n    float r = length(uv);\n    float a = atan(uv.y, uv.x)*10.0;\n    a += iTime*10.0;\n    a += log(r)*50.0;\n    \n    float g = cos(mod(a, PI)*2.0)*0.5 + 0.5;\n    \n    g *= smoothstep(0.0, 0.7, r);\n    \n    fragColor = vec4(g);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsjSDh.jpg", "access": "shaders20k", "license": "cc0-1.0", "functions": [[95, 95, 151, 151, 481]], "test": "valid"}
{"id": "XsjXWh", "name": "Exploring the crystal lattice", "author": "Devin", "description": "My attempt to create a simple 3D shader, after studying the code of other ones.", "tags": ["3d", "raymarching", "balls"], "likes": 16, "viewed": 1384, "published": "Public", "date": "1411479526", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rand(vec3 n) {\n  n = floor(n);\n  n.z = 100.0*fract(n.z/100.0);\n  return fract(sin((n.x*1e2+n.y*1e4+n.z*1e6)*1e-4)*1e5);\n}\n\nvec3 light( vec3 ray,vec3 lightPos,float cr) {\n    vec3 f = fract( ray ) -0.5;\n    vec3 normf = normalize(f);\n    vec3 light = lightPos-ray;\n    float lighting = normf.x*light.x+normf.y*light.y+normf.z*light.z;\n    lighting=lighting<0.0?0.0:lighting;\n    float l2 = length(light);\n\treturn 3.0*lighting/pow((l2+0.40),2.5)*vec3(0.8*cr,0.5,0.8-cr);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 pos = (fragCoord.xy*2.0 - iResolution.xy) / iResolution.y;\n    float t = iTime+0.2;\n    float tt = iTime+2.0;\n    \n    //camera\n    vec3 camPos = vec3(cos(iTime*0.5), sin(iTime*0.5), -iTime*0.5);\n    vec3 camTarget = vec3(cos(t*0.5), sin(t*0.5), -t*0.5);\n    vec3 camDir = normalize(camTarget-camPos);\n    vec3 camUp  = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 camSide = cross(camDir, camUp);\n    camUp  = cross(camDir, camSide);\n    vec3 rayDir = normalize(camSide*pos.x + camUp*pos.y + camDir*1.5);\n    \n    //light position\n    vec3 lightPos = vec3(cos(tt*0.5), sin(tt*0.5), -tt*0.5);\n    lightPos += vec3(0.1*sin(iTime*5.0),0.1*cos(iTime*3.0),0.1*cos(iTime*4.0));\n    lightPos -=pow(1.0-2.0*abs(fract(iTime/7.0)-0.5),6.)*(-camDir)*5.0;\n    \n    //raymarching\n    vec3 ray = camPos;\n    float l_min = length(cross(lightPos-ray,rayDir));\n\tfloat halo = 0.0005/l_min/l_min;\n    float cr;\n    bool end = true;\n    for(int i=0; i<30; ++i) {\n\t\tcr = 0.3*rand( ray );\n        vec3 bc = floor(ray)+0.5;\n        float d_min = length(cross(rayDir,bc-camPos));\n        if ((d_min<cr)&&(dot(bc-camPos,camDir)>0.0)){\n            \n            //determine closest intersection of ray and sphere\n         \tvec3 d_min_vec = normalize(cross(cross(bc-camPos,rayDir),rayDir));\n            float l1 = sqrt(cr*cr-d_min*d_min);\n            ray = bc + d_min_vec*d_min-rayDir*l1;\n            \n            if (length(ray - camPos)<length(lightPos-camPos)) {halo = 0.0;}\n            end = false;\n            break;\n        }\n        ray+=0.8*rayDir;\n    }\n    vec3 color = end?vec3(0.0,0.0,0.0):light(ray,lightPos,cr/0.3);\n    fragColor = vec4( color+halo*(1.0,1.0,1.0), 1.0 );;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsjXWh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 127], [129, 129, 175, 175, 476], [478, 478, 535, 535, 2200]], "test": "valid"}
{"id": "XsSXD1", "name": "Julia fractal 2", "author": "davidm", "description": "Julia fractal", "tags": ["fractal", "julia"], "likes": 1, "viewed": 249, "published": "Public API", "date": "1411260376", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec3 cd2( vec2 z ){\n\t// iterate\n\tfloat c = 0.75*sin(iTime)-0.25;\n\tfloat m=10000000000000.0;\n\tfloat mx=0.0;\n\tint k;\n    vec2 z2;\n\tfor(int i=0; i<128; i++){\n        if ( length(z)>2.0){\n         \tbreak;   \n        }\n\t\tz2.x=z.x*z.x-z.y*z.y+c;\n\t\tz2.y=2.0*z.x*z.y;\n\t\tz=z2;\n\t\tm=min(m, length(z));\n\t\tmx=max(mx, length(z));\n        k=i;\n\t}\n\tvec3 a=0.3*vec3(pow(float(k)/512.0,0.4));\n\tvec3 b=0.3*vec3(1.0-m)*vec3(1.0,0.4,0.3)*2.0;\n\tvec3 d=0.3*vec3(0);\n\td=vec3(smoothstep(0.8,1.1,mx*0.25))*vec3(0.01,0.01,0.1);\n\treturn a+b+d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = fragCoord.xy / iResolution.xy-vec2(0.5);\n    uv=uv*vec2(1.0,0.5)*4.9;\n\tfragColor = vec4((cd2(uv)),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/XsSXD1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 21, 33, 519], [521, 521, 577, 577, 697]], "test": "valid"}
