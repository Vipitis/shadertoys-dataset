{"id": "3d3BRj", "name": "pulsing circle outline", "author": "Peewi", "description": "pulsing circle outline", "tags": ["test"], "likes": 2, "viewed": 211, "published": "Public API", "date": "1605730009", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // some bs\n    vec3 bg = vec3(0.1, 0.1, 0.1);\n    vec3 white = vec3(0.9);\n    vec3 col = bg;\n    //vec2 center = vec2(200.0, iResolution.y - 150.0);\n    vec2 center = iMouse.xy;\n\n    float l = length(fragCoord-center);\n    float radius = ((cos(iTime*3.0)+1.0) * 40.0);\n    //float radius = 1.0;\n    float am = abs(l - radius)-2.;\n    am = clamp(am, 0.0, 1.0);\n    col = mix(white, bg, am);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3BRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 605]], "test": "valid"}
{"id": "3d3BRl", "name": "dark weirdness", "author": "slackmage", "description": "dark weirdness", "tags": ["tunnel"], "likes": 1, "viewed": 58, "published": "Public", "date": "1605719866", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXSTEPS 100\n#define MAX_DISTANCE 100.0\n#define GLERP 0.01\n\n//Returns the distance to a sphere\n//Pos is the position of the object.\n//Sphere\n//xyz describes the position of the sphere.\n//w describes the radius of the sphere.\nfloat Sphere (vec3 Pos, vec4 Sphere)\n{\n    return distance(Pos, Sphere.xyz) - Sphere.w;\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//Returns the distance from objects in the scene.\nfloat GetDistanceFromScene(vec3 Pos)\n{\n   float modDist = 2.0;\n    \n   vec3 ModPos = vec3(mod(Pos, modDist));\n   \n   float initial = mix (1.125, 0.4, smoothstep(0., 1., sin(ModPos.y * 10.0 + iTime) * 3.5 + 2.9));\n    \n   float SphereRad = initial - sin(Pos.y * 50.0 + iTime * 10.) * .01 + \n                               cos(Pos.x * 70.0 + iTime * 10.) * .01 +\n                               cos(Pos.z * 30.0 + iTime * 10.) * .01;\n    \n   vec3 SpherePos = vec3(1.0, 1.0, 1.0);\n   \n   //SpherePos.xz *= Rot(sin(Pos.y / 10.));\n    \n   //SphereRad += texture(iChannel0, vec2(Pos.x + Pos.z, Pos.y - Pos.z)).x * 0.01;\n    \n   //Sphere 'nuff said.\n   float SP = Sphere(ModPos, \n                     vec4(SpherePos,\n                     SphereRad));\n    \n   //SP = min (SP, mod(3.0, SP));\n    \n   //Ground plane (XZ)\n   float G = Pos.y + sin(Pos.z * 7.) * .3; \n   \n   float minDist = min(SP * .5, SP);\n   minDist = min(minDist, G * .5);\n   return minDist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDistanceFromScene(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDistanceFromScene(p-e.xyy),\n        GetDistanceFromScene(p-e.yxy),\n        GetDistanceFromScene(p-e.yyx));\n    \n    return normalize(n);\n}\n\n//Gets the depsth of the camera in the direction it's facing.\nfloat GetDepth(vec3 Position, vec3 direction)\n{\n   //Total accumulated distance\n   float dist = 0.0;\n    \n   //Raymarching loop.\n   for (int i = 0; i < MAXSTEPS; ++i)\n   {\n       //Finds the current position of ray\n       vec3 p = Position + dist * direction;\n       //Finds the distance from objects in the scene\n       float distScene = GetDistanceFromScene(p);\n       //Adds that distance to the total.\n       dist += distScene;\n       //Check for a break condition\n       if (abs(distScene) < GLERP || distScene > MAX_DISTANCE) break;\n   }\n   //Return the distance\n   return dist;\n}\n\n//Gets the normal of an object\n//Pos is the position of the object.\nfloat GetLight(vec3 p)\n{\n    vec3 LightPos = vec3(0.0, 5.0, iTime);\n    \n    vec3 l = normalize(LightPos - p);\n    \n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    \n    //Look for shadows\n    \n    //Get distance raymarched from surface point to the light\n    float d = GetDepth(p + n * GLERP * 2.0, l);\n    \n    //Check is shorter than the distance to the light\n    if (d < length(LightPos - p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n   \n    \n    //Hey some camera stuff.\n    vec3 Position  = vec3(0.0, 1.0, -5.0 + iTime);\n    vec3 RayDir    = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    // Time varying pixel color\n    float depth = GetDepth(Position, RayDir);\n\n    //Diffuse lighting by finding normal from last position found in depth function\n    float dif = GetLight(Position + RayDir * depth);\n    \n    // Output to screen\n    fragColor = vec4(dif, dif, dif,1.0);\n    //fragColor = vec4(depth/10.0, depth/10.0, depth/10.0,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3BRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 233, 271, 271, 322], [324, 324, 343, 343, 416], [418, 468, 506, 506, 1418], [1420, 1420, 1444, 1444, 1688], [1690, 1752, 1799, 1831, 2338], [2340, 2408, 2432, 2432, 2869], [2871, 2871, 2928, 2978, 3544]], "test": "valid"}
{"id": "3d3BW2", "name": "A Snowman for Christmas", "author": "Dombass", "description": "hacked together a snowman for christmas", "tags": ["christmas", "snow", "winter", "snowman"], "likes": 2, "viewed": 93, "published": "Public", "date": "1606055791", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(vec3 a, vec3 b, float r) {\n    return length(max(abs(a)-b, 0.)) - r;\n}\n\n\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat fl2(vec3 p, float scene)\n{\n    float direction = noise(p+vec3(1.,iTime*0.75,1.0));\n    float height = 0.1; //dont bend! ascend! by going above about 0.3\n    float f = (scene + direction*height);\n \tfloat a = abs(f);\n    return min(10.-f, a);\n}\n\n\nvec3 applyFog( in vec3  rgb,       // original color of the pixel\n               in float distance,\n             in float b, \n             in vec3 fogColor) // camera to point distance\n{\n    float fogAmount = 1.0 - exp( -distance*b );\n    return mix( rgb, fogColor, fogAmount );\n}\n\nfloat r(float n){return fract(sin(n) * 43758.5453123);}\nfloat r(vec2 n) { \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\nfloat ns(float p){\n\tfloat fl = floor(p);\n  float fc = fract(p);\n\treturn mix(r(fl), r(fl + 1.0), fc);\n}\n\t\nfloat ns(vec2 n) {\n\tconst vec2 d = vec2(0.0, 1.0);\n  vec2 b = floor(n), f = smoothstep(vec2(0.0), vec2(1.0), fract(n));\n\treturn mix(mix(r(b), r(b + d.yx), f.x), mix(r(b + d.xy), r(b + d.yy), f.x), f.y);\n}\n\n\n\nfloat sdPlane( vec3 p, vec3 n, float h ) {\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\n\nfloat tree(in vec3 p) {\n\tfloat top = sdCone(p, vec2(1., 0.2), 3.);\n    p.y += 2.;\n    float mid = sdCone(p, vec2(0.9, 0.4), 4.);\n    p.y += 2.;\n    float bottom = sdCone(p, vec2(0.8, 0.5), 6.);\n    p.y += 4.;\n    float trunk = sdCone(p, vec2(0.3), 6.);\n    \n    return min(trunk, min(bottom, min(mid, top)));\n}\n\nvec4 forest(in vec3 p, float snowFactor) {\n\tfloat result = 1.;\n    p.z += 30.;\n    p.x -= 70.;\n    \n    vec3 base = vec3(0.3, 0.5, 0.2);\n    vec3 snow = vec3(0.7, 0.7, 0.9);\n    base = mix(base, snow, snowFactor);\n    \n    float amount = noise(p*4.);\n    vec3 col = mix(base, snow, amount);\n    \n    float c = 5.0;\n    for (int i = 0; i < 4; i++) {       \n    \tfloat q = mod(p.x+0.5*c,c)-0.5*c;\n    \tresult = min(result, tree(vec3(q, p.y, p.z)));\n        p.z += 25.0; \n    }\n    \n    return vec4(col, result);\n}\n\nvec4 snowman(in vec3 pos) {\n\tfloat bottom = sphereSDF(pos, 3.5);\n    pos.y -= 4.;\n    pos.x -= 0.25;\n    float mid = sphereSDF(pos, 2.5);\n    pos.y -= 3.;\n    pos.x += 0.5;\n    float top = sphereSDF(pos, 2.);\n    return vec4(1., 1., 1., min(bottom, min(mid, top)));\n}\n\nfloat sdRoundCone( vec3 p, float r1, float r2, float h )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n    \n  float b = (r1-r2)/h;\n  float a = sqrt(1.0-b*b);\n  float k = dot(q,vec2(-b,a));\n    \n  if( k < 0.0 ) return length(q) - r1;\n  if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n  return dot(q, vec2(a,b) ) - r1;\n}\n\nvec4 carrot(in vec3 pos) {\n\tvec3 col = vec3(1.0, 0.5, 0.2);\n    pos.y -= 7.;\n    pos.z -= 2.;\n    mat4 rot = rotationX(-3.14/2.);\n    vec4 temp = vec4(pos, 1.);\n    temp *= rot;\n    pos = temp.xyz;\n    \n    float shape = sdRoundCone(pos, 0.3, .1, 1.);\n    return vec4(col, shape);\n}\n\nvec4 eyes(in vec3 pos) {\n\tvec3 col = vec3(0.);\n    pos.y -= 8.;\n    pos.z -= 1.4;\n    pos.x -= 0.5;\n    float leftEye = sphereSDF(pos, 0.2);\n    \n    pos.x += 1.2;\n    pos.z -= 0.15;\n    float rightEye = sphereSDF(pos, 0.2);\n    float shape = min(leftEye, rightEye);\n    return vec4(col, shape);\n}\n\nvec4 compose(in vec4 x, in vec4 y) {\n    if (x.w < y.w) return x;\n    return y;\n}\n\nvec4 environment(in vec3 pos) {\n    float snowFactor = 0.5 + sin(iTime*0.1)*0.5;\n    float amount = noise(pos*2.);\n    vec3 base = vec3(.4, 0.4, 0.2);\n    vec3 snow = vec3(0.7, 0.7, 0.9);\n    base = mix(base, snow, snowFactor);\n    vec3 col = mix(base, snow, amount);\n    pos.y -= amount*0.1;\n\tpos.y += 2.;\n    vec4 ground = vec4(col, sdPlane(pos, vec3(0., 1., 0.), 1.));\n    pos.y += amount*0.1;\n    pos.y -= 15.;\n    pos.x -= 10.;\n    vec4 f = forest(pos, snowFactor);\n    return compose(f, ground);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n\nfloat sdCircle( vec2 p, float r )\n{\n    return length(p) - r;\n}\n\nvec4 snowfall(in vec3 p) {\n\tvec3 col = vec3(1.);\n    p.y += iTime;\n    p.x += sin(iTime+p.y+p.z)*0.5;\n    p.z -= 15.;\n    float c = 4.;\n    float shape = 1.;\n    for (int i = 0; i < 1; i++) {\n    \tfloat qx = mod(p.x,c)-c*0.5;\n        float snowrep= mix(0.8, 10., p.y/iResolution.y);//4.+sin(iTime)*0.6;\n        float qz = mod(p.z, snowrep)-(snowrep*0.5);\n        \n        float snowrep2=smoothstep(1., 4., p.y);\n        float qy = mod(p.y, snowrep2)-(snowrep2*0.5);\n    \tshape = min(shape, sphereSDF(vec3(qx, qy, qz), 0.0000001));\n\t\tp.z += 15.;    \n        p.x += sin(iTime+p.y+p.z)*0.5;\n        c -= 0.5;\n    }\n    return vec4(col, shape);\n}\n\nvec4 scene(in vec3 pos) {\n    mat4 rot = rotationY(sin(iTime*0.1)*0.75);\n    vec4 temp = vec4(pos, 1.);\n    temp *= rot;\n    pos = temp.xyz;\n    vec4 snowman = snowman(pos);\n    vec4 environment = environment(pos);\n    vec4 carrot = carrot(pos);\n    vec4 eyes = eyes(pos);\n    vec4 face = compose(eyes, carrot);\n    vec4 snowboi = compose(face, snowman);\n    vec4 finalScene = compose(snowboi, compose(snowfall(pos), environment));\n    //vec4 finalScene = compose(snowboi, environment);\n    return finalScene;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*scene( pos + e.xyy ).w + \n\t\t\t\t\t  e.yyx*scene( pos + e.yyx ).w + \n\t\t\t\t\t  e.yxy*scene( pos + e.yxy ).w + \n\t\t\t\t\t  e.xxx*scene( pos + e.xxx ).w );\n}\n\nconst float MAX = 100.; \n\nvec4 RayMarch(vec3 eye, vec3 dir) {    \n    float depth = 0.0;\n    const int limit = int(MAX);\n    vec4 s;\n    float dist;\n    for (int i = 0; i < limit; i++) {\n        s = scene(eye + depth * dir);\n        dist = s.w;\n        \n        if (dist < 0.01) \n        {\n            return vec4(s.xyz, depth);\n        }\n        //else if (depth > 450.) return vec4(0.1, 0.1, 0.2, MAX);\n            \n        depth += dist;\n        \n    }\n    \n    return vec4(0.1, 0.1, 0.2, MAX);\n}\n\n\n\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n\tfloat res = 1.0;\n    float t = mint;\n    float ph = 1e10; // big, such that y = 0 on the first iteration\n    \n    for( int i=0; i<4; i++ )\n    {\n\t\tfloat h = scene( ro + rd*t ).w;\n        res = min( res, 4.0*h/t );\n        t += h;\n        \n        if( res<0.0001 || t>tmax ) break;\n        \n    }\n    return clamp( res, 0.2, 1.0 );\n}\n\n\nfloat ssao( in vec2 pixel, in vec4 rayHit,in vec3 eye)\n{\n    const int samples = 8;\n    vec3 lights[samples];\n    lights[0] = vec3(1.);\n    lights[1] = vec3(1., 1., 0.);\n    lights[2] = vec3(0., 1., 0.);\n    lights[3] = vec3(0., 1., 1.);\n    lights[4] = vec3(0., 0., 1.);\n    lights[5] = vec3(1., 0., 1.);\n    lights[6] = vec3(1., 0., 0.);\n    lights[7] = vec3(0.);\n    \n    float ao = 0.0;\n    \n    float noiseSample = ns(pixel);\n\tfor( int i=0; i<samples; i++ )\n\t{\n        vec2 off = vec2(noiseSample*float((i+1)*2));\n        vec3 rayDir = rayDirection(90., iResolution.xy, pixel+off); \n        \n    \tvec3 normal = calcNormal(eye + rayHit.w*rayDir);\n    \tfloat occ = clamp( dot( normal, lights[i] ), 0.2, 1. );\n        ao += occ;\n\t}\n    // average down the occlusion\t\n    return ao/float(samples);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0., 10., 30.);\n    vec3 rayDir = rayDirection(90., iResolution.xy, fragCoord);    \n    vec4 dist = RayMarch(eye, rayDir);\n    vec3 lig = vec3(1.);\n    float dif = ssao(fragCoord, dist, eye)*calcSoftshadow(eye + dist.w*rayDir, lig, 0.001, 3.);\n    vec3 mate = dist.xyz;\n    vec3 lig1Colour = vec3(0.8, 0.8, 1.);\n    float falloff = (1.0-dist.w/MAX);\n    vec3 col = mix(vec3(0.1),  mate*dif*lig1Colour, 1.);\n    vec3 fogged = applyFog(col, dist.w, 0.04, vec3(0.0,0.1,0.2));\n    fragColor = vec4(fogged, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3BW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 173], [175, 175, 209, 209, 345], [347, 347, 381, 381, 514], [516, 516, 550, 550, 578], [580, 580, 619, 619, 663], [667, 667, 709, 709, 946], [948, 948, 980, 980, 1196], [1199, 1199, 1385, 1385, 1479], [1481, 1481, 1498, 1498, 1536], [1537, 1537, 1554, 1554, 1621], [1622, 1622, 1640, 1640, 1724], [1727, 1727, 1745, 1745, 1931], [1935, 1935, 1977, 2003, 2028], [2030, 2030, 2071, 2071, 2143], [2145, 2145, 2168, 2168, 2455], [2457, 2457, 2499, 2499, 2968], [2970, 2970, 2997, 2997, 3237], [3239, 3239, 3297, 3297, 3561], [3563, 3563, 3589, 3589, 3845], [3847, 3847, 3871, 3871, 4144], [4146, 4146, 4182, 4182, 4227], [4229, 4229, 4260, 4260, 4732], [4734, 4734, 4799, 4799, 4931], [4934, 4934, 4969, 4969, 4997], [4999, 4999, 5025, 5025, 5641], [5643, 5643, 5668, 5668, 6154], [6156, 6156, 6188, 6188, 6404], [6432, 6432, 6467, 6467, 6905], [6909, 6909, 6987, 6987, 7321], [7324, 7324, 7380, 7380, 8124], [8127, 8127, 8184, 8184, 8712]], "test": "error"}
{"id": "3d3BWH", "name": "Mandelbrot experiment", "author": "Atchafalaya", "description": "playing with fractals for the first time on Shadertoy", "tags": ["fractal"], "likes": 1, "viewed": 49, "published": "Public", "date": "1604933378", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_ITERATION 500\n#define PI 3.1415\n#define PERIOD 15.\n\nconst vec2 CENTERS[5] = vec2[5](vec2(1.155713, -0.27765),\n                                vec2(-0.42884, 0.231345),\n                                vec2(0.761574, 0.0847596),\n                                vec2(1.62917, 0.0203968),\n                                vec2(0.812223315621338, 0.185453926110785));\nmat2 rot(float angle){\n    float c = cos(angle);\n    float s = sin(angle);\n    return mat2(c, s, -s, c);\n}\n\nstruct Complex{\n    float r;\n    float i;\n};\n\nfloat norm(Complex c){\n    return length(vec2(c.r, c.i));\n}\n\nComplex square(Complex c){\n    return Complex(c.r * c.r - c.i * c.i, 2. * c.r * c.i);\n}\n\nComplex sum_complex(Complex a, Complex b){\n    return Complex(a.r + b.r, a.i + b.i);\n}\n\nComplex mul_complex(Complex c, float m){\n\treturn Complex(c.r * m, c.i * m);\n}\n\nfloat getZoom(float time){\n    return pow(abs(cos(PI / PERIOD * iTime)), 2.3) + 0.01; //periodic zoom\n}\n\nvec3 mandelbrot(vec2 uv){\n    int i = 0;\n    float zoom = getZoom(iTime);\n    float maxValue = 4. * (1. / pow(zoom, 2.)) ;\n    float sum = 0.;\n    Complex z = Complex(0., 0.);\n    Complex c = Complex(uv.x, uv.y);\n    while (sum < maxValue && i < MAX_ITERATION){\n        z = sum_complex(square(mul_complex(z, zoom)), c);\n        sum = norm(z);\n        i++;\n    }\n    if (sum < maxValue){\n        return vec3(0.);\n    } else {\n        float r = pow(float(i) / float(MAX_ITERATION), 0.16);\n        float r0 = clamp(0., 1., 4. * r);\n        float r1 = clamp(0., 1., 4. * (r - 0.25));\n        float r2 = clamp(0., 1., 4. * (r - 0.5));\n        float r3 = clamp(0., 1., 4. * (r - 0.75));\n        vec3 col0 = vec3(27., 64., 121.) / 255.;\n        vec3 col1 = vec3(85., 147., 206.) / 255.;\n        vec3 col2 = vec3(134., 110., 216.) / 255.;\n        vec3 col3 = vec3(246., 150., 45.) / 255.;\n        vec3 col4 = vec3(255., 30., 24.) / 255.;\n        vec3 col = mix(col0, col1, r0);\n        col = mix(col, col2, r1);\n        col = mix(col, col3, r2);\n        col = mix(col, col4, r3);\n        return col;\n    }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv = 2. * uv - 1.;\n\tuv.x *= iResolution.x / iResolution.y;\n    uv = rot(0.1 * iTime) * uv;\n    \n    int i = int(floor((iTime + PERIOD / 2.) / PERIOD)) % 5;\n    vec2 center = CENTERS[i];\n    vec2 previousCenter = vec2(0.);\n    float timeOffset = 0.;\n    if (iTime > PERIOD / 2.)\n    {\n        if (i == 0){\n            previousCenter = CENTERS[CENTERS.length() - 1];\n        } else {\n            previousCenter = CENTERS[i - 1];\n        }\n        timeOffset = PERIOD / 2.;\n\t}\n\n    float nTime = iTime / PERIOD; \n    float t = nTime > 0.5 ? fract(nTime + 0.5) : fract(2. * nTime);\n    float u = nTime > 0.5 ? smoothstep(0.3, 0.7, t) : smoothstep(0., 0.4, t);\n    vec2 transitionCenter = mix(previousCenter, center, u);\n    \n    uv -= transitionCenter / pow(getZoom(iTime), 2. ); \n    \n    vec3 col = mandelbrot(uv);\n\n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3BWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[374, 374, 396, 396, 480], [528, 528, 550, 550, 587], [589, 589, 615, 615, 676], [678, 678, 720, 720, 764], [766, 766, 806, 806, 843], [845, 845, 871, 871, 948], [950, 950, 975, 975, 2049], [2051, 2051, 2108, 2108, 3038]], "test": "valid"}
{"id": "3d3fR7", "name": "Quick and dirty tv static noise", "author": "PelicanPolice", "description": "I am learning how shaders work. If a similar effect can be achieved with less function calls, let me know!\nIt should last infinitely as the input gets looped. Also does not require any source.", "tags": ["noise", "tv", "interference", "not", "analog", "in", "signal", "lost", "connection", "plugged"], "likes": 2, "viewed": 122, "published": "Public", "date": "1604591951", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Free for any purpose, commercial or otherwise. \n// But do post here so I can see where it got used!\n// If using on shadertoy, do link to this project on yours :)\n\nfloat noise(vec2 pos, float evolve) {\n    \n    // Loop the evolution (over a very long period of time).\n    float e = fract((evolve*0.01));\n    \n    // Coordinates\n    float cx  = pos.x*e;\n    float cy  = pos.y*e;\n    \n    // Generate a \"random\" black or white value\n    return fract(23.0*fract(2.0/fract(fract(cx*2.4/cy*23.0+pow(abs(cy/22.4),3.3))*fract(cx*evolve/pow(abs(cy),0.050)))));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    // Increase this number to test performance\n    int intensity = 1;\n    \n    vec3 colour;\n    for (int i = 0; i < intensity; i++)\n        {\n        // Generate a black to white pixel\n        colour = vec3(noise(fragCoord,iTime));\n        }\n\t\n    // Output to screen\n    fragColor = vec4(colour,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3fR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[166, 166, 203, 269, 556], [559, 559, 616, 665, 922]], "test": "valid"}
{"id": "3d3fRM", "name": "VLS logo", "author": "algoes", "description": "VLS logo", "tags": ["vlslogo"], "likes": 3, "viewed": 171, "published": "Public API", "date": "1604582271", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat opSmoothUnion( float d1, float d2, float k )\n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h);\n}\n\nfloat hash13(vec3 p3)\n{\n\tp3  = fract(p3 * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 opRep( in vec3 p, in vec3 c, out vec3 idx)\n{\n    p = (p + 0.5 * c) / c;\n    vec3 floorP = floor(p);\n    vec3 fractP = fract(p);\n    idx = floorP;\n    return fractP * c - 0.5 * c;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\nvec2 map(vec3 p)\n{\n    vec3 idx;\n    p = opRep(p, vec3(6.0, 3.0, 5.0), idx);\n    \n    vec2 res = vec2(0.0, 0.0);\n    float thickness = 0.275;\n    float vlsD = 100.0;\n    \n    float r = hash13(idx * 100.0 + floor(iTime * 2.14));\n    \n    if (r > 0.2 + step(dot(idx, idx), 0.5)) {\n        return vec2(0.75, 0.0);\n    }\n    \n\n\n\nvlsD = min(vlsD, sdCapsule(p, vec3(-0.5375011499999998, -0.44249114999999994, 0.0), vec3(-0.9700012499999998, 0.42000885000000004, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(-0.10000124999999968, 0.42000885000000004, 0.0), vec3(-0.5375011499999998, -0.44249114999999994, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(0.3, -0.44, 0.0), vec3(0.29, 0.42, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(.8, -0.44, 0.0), vec3(0.34, -0.44, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(1.77, 0.42, 0.0), vec3(1.10, 0.42, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(1.77, -0.44, 0.0), vec3(1.77, -0.02, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(1.11, -0.45, 0.0), vec3(1.77, -0.45, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(1.1, -0.0, 0.0), vec3(1.1, 0.42, 0.0), thickness));\nvlsD = min(vlsD, sdCapsule(p, vec3(1.77, -0.015, 0.0), vec3(1.12, 0, 0.0), thickness));\n\t\n    res.x = vlsD;\n    res.y = step(0.24, p.z);\n    \n    return res;\n}\n\nvec3 calcNormal( in vec3 p )\n{\n    const float h = 1e-5; // or some other value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*map( p + k.xyy*h ).x + \n                      k.yyx*map( p + k.yyx*h ).x + \n                      k.yxy*map( p + k.yxy*h ).x + \n                      k.xxx*map( p + k.xxx*h ).x );\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, s, -s, c);\n\treturn m * v;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // screen size is 6m x 6m\n    \n    float t = iTime * 0.2;\n    vec3 off0 = fract(vec3(t * 2.516 - 0.642, -t * 0.541 - 0.624, t * 0.532 - 0.74)) - 0.5;\n    vec3 off1 = fract(vec3(-t * 0.512 - 0.3412, t * 2.537 - 0.92, -t * 0.5327 - 0.24)) - 0.5;\n    vec3 off2 = fract(vec3(t * 0.47 - 0.835, t * 0.537 - 0.753, -t * 0.47 - 0.845)) - 0.5;\n    vec3 off3 = fract(vec3(t * 0.324 - 0.23, -t * 0.537 - 0.324, t * 2.5327 - 0.56)) - 0.5;\n    \n\tvec3 rayOri = vec3(0.0, 0.0, 3.0) + off0 * off2 * vec3(12.0, 12.0, 6.0);\n    vec3 target = vec3(rotate((uv - 0.5) * vec2(iResolution.x/iResolution.y, 1.0), dot(off0, off1) * 3.0) * 6.0, 0.0) + off1 * off3 * vec3(12.0, 12.0, 6.0);\n\tvec3 rayDir = normalize(target - rayOri);\n\t\n\tfloat depth = 0.0;\n\tvec3 p;\n    vec2 res;\n\t\n\tfor(int i = 0; i < 64; i++) {\n\t\tp = rayOri + rayDir * depth;\n\t\tres = map(p);\n        depth += res.x;\n\t\tif (res.x < 1e-5) {\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n    depth = min(50.0, depth);\n\tvec3 n = calcNormal(p);\n    float b = max(0.0, dot(n, vec3(0.577)));\n    vec3 col = mix(vec3(0.5), vec3(1.0), b) * 1.75;\n    col *= exp((-depth + 0.5) * 0.15);\n    col *= max(smoothstep(0.1, 0.5, res.x) + 0.075 * b, res.y);\n\t\n    // maximum thickness is 2m in alpha channel\n    fragColor = vec4(col, 1.0 - (depth - 1.0) / 20.0);\n}\n\n/** SHADERDATA\n{\n\t\"title\": \"VLS logo\",\n\t\"description\": \"Trace the VLS logo with capsule sdf.\",\n\t\" model\" : \"person\"\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3fRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 53, 152], [154, 154, 177, 177, 280], [282, 282, 331, 331, 467], [468, 468, 499, 499, 586], [588, 588, 640, 640, 761], [763, 763, 800, 800, 883], [885, 885, 903, 903, 2206], [2208, 2208, 2238, 2238, 2528], [2530, 2530, 2560, 2560, 2644], [2646, 2646, 2703, 2703, 4010]], "test": "valid"}
{"id": "3d3fzS", "name": "Midnight Ocean ", "author": "zproxy", "description": "https://www.shadertoy.com/view/3scfD7", "tags": ["water", "stars"], "likes": 7, "viewed": 224, "published": "Public", "date": "1605363340", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//afl_ext 2017-2019\n\n#define DRAG_MULT 0.048\n#define ITERATIONS_RAYMARCH 13\n#define ITERATIONS_NORMAL 48\n\n#define Mouse (iMouse.xy / iResolution.xy)\n#define Resolution (iResolution.xy)\n#define Time (iTime)\n\nvec2 wavedx(vec2 position, vec2 direction, float speed, float frequency, float timeshift) {\n    float x = dot(direction, position) * frequency + timeshift * speed;\n    float wave = exp(sin(x) - 1.0);\n    float dx = wave * cos(x);\n    return vec2(wave, -dx);\n}\n\nfloat getwaves(vec2 position, int iterations){\n\tfloat iter = 0.0;\n    float phase = 6.0;\n    float speed = 0.7;\n    float weight = 1.0;\n    float w = 0.0;\n    float ws = 0.0;\n    for(int i=0;i<iterations;i++){\n        vec2 p = vec2(sin(iter), cos(iter));\n        vec2 res = wavedx(position, p, speed, phase, Time);\n        position += normalize(p) * res.y * weight * DRAG_MULT;\n        w += res.x * weight;\n        iter += 12.0;\n        ws += weight;\n        weight = mix(weight, 0.0, 0.2);\n        phase *= 1.18;\n        speed *= 1.07;\n    }\n    return w / ws;\n}\n\nfloat raymarchwater(vec3 camera, vec3 start, vec3 end, float depth){\n    vec3 pos = start;\n    float h = 0.0;\n    float hupper = depth;\n    float hlower = 0.0;\n    vec2 zer = vec2(0.0);\n    vec3 dir = normalize(end - start);\n    for(int i=0;i<318;i++){\n        h = getwaves(pos.xz * 0.1, ITERATIONS_RAYMARCH) * depth - depth;\n        float dist_pos = distance(pos, camera);\n        if(h + 0.01*dist_pos > pos.y) {\n            return dist_pos;\n        }\n        pos += dir * (pos.y - h);\n    }\n    return -1.0;\n}\n\nfloat H = 0.0;\nvec3 normal(vec2 pos, float e, float depth){\n    vec2 ex = vec2(e, 0);\n    H = getwaves(pos.xy * 0.1, ITERATIONS_NORMAL) * depth;\n    vec3 a = vec3(pos.x, H, pos.y);\n    return normalize(cross(normalize(a-vec3(pos.x - e, getwaves(pos.xy * 0.1 - ex.xy * 0.1, ITERATIONS_NORMAL) * depth, pos.y)), \n                           normalize(a-vec3(pos.x, getwaves(pos.xy * 0.1 + ex.yx * 0.1, ITERATIONS_NORMAL) * depth, pos.y + e))));\n}\nmat3 rotmat(vec3 axis, float angle)\n{\n\taxis = normalize(axis);\n\tfloat s = sin(angle);\n\tfloat c = cos(angle);\n\tfloat oc = 1.0 - c;\n\treturn mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s, \n\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s, \n\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec3 getRay(vec2 uv){\n    uv = (uv * 2.0 - 1.0) * vec2(Resolution.x / Resolution.y, 1.0);\n\tvec3 proj = normalize(vec3(uv.x, uv.y, 1.0) + vec3(uv.x, uv.y, -1.0) * pow(length(uv), 2.0) * 0.05);\t\n //   if(Resolution.x < 400.0) return proj;\n //   if (Mouse.y< 0.0) return proj;\n    \n\tvec3 ray = rotmat(vec3(0.0, -1.0, 0.0), 3.0 * (Mouse.x * 2.0 - 1.0)) \n        * rotmat(vec3(1.0, 0.0, 0.0), 1.5 * (Mouse.y * 2.0 - 1.0)) \n        * rotmat(vec3(1.0, 0.0, 0.0), 1.5  )  \n        * proj;\n        \n    return ray;\n}\n\nfloat intersectPlane(vec3 origin, vec3 direction, vec3 point, vec3 normal)\n{ \n    return clamp(dot(point - origin, normal) / dot(direction, normal), -1.0, 9991999.0); \n}\n\nvec3 extra_cheap_atmosphere(vec3 raydir, vec3 sundir){\n\tsundir.y = max(sundir.y, -0.07);\n\tfloat special_trick = 1.0 / (raydir.y * 1.0 + 0.1);\n\t//float special_trick2 = 1.0 / (sundir.y * 11.0 + 1.0);\n\t//loat raysundt = pow(abs(dot(sundir, raydir)), 2.0);\n\t//float sundt = pow(max(0.0, dot(sundir, raydir)), 8.0);\n\t//float mymie = sundt * special_trick * 0.2;\n\t//vec3 suncolor = mix(vec3(1.0), max(vec3(0.0), vec3(1.0) - vec3(5.5, 13.0, 22.4) / 22.4), special_trick2);\n\tvec3 bluesky= vec3(5.5, 13.0, 22.4) / 22.4 //* suncolor\n        ;\n\tvec3 bluesky2 = max(vec3(0.0), bluesky - vec3(5.5, 13.0, 22.4) * 0.002 * (special_trick \n                                                                              // + -6.0 * sundir.y * sundir.y\n                                                                             ));\n\tbluesky2 *= special_trick * (0.24 \n                                // + raysundt * 0.24\n                                );\n\treturn bluesky2  * (0.0 + 0.7 * pow(1.0 - raydir.y, 3.0)) //+ mymie //* suncolor\n        ;\n} \nvec3 getatm(vec3 ray){\n \treturn extra_cheap_atmosphere(ray, normalize(vec3(1.0))) * 0.5;\n    \n}\n\nfloat sun(vec3 ray){\n \tvec3 sd = normalize(vec3(1.0));   \n    return pow(max(0.0, dot(ray, sd)), 1728.0) * 250.0;\n}\n\n\n\nvec3 rotx(vec3 p, float a){\n    float s = sin(a), c = cos(a);\n    return vec3(p.x, c*p.y - s*p.z, s*p.y + c*p.z);\n}\n \n\n//From Dave_Hoskins (https://www.shadertoy.com/view/4djSRW)\nvec3 hash33(vec3 p)\n{\n    p = fract(p * vec3(443.8975,397.2973, 491.1871));\n    p += dot(p.zxy, p.yxz+19.27);\n    return fract(vec3(p.x * p.y, p.z*p.x, p.y*p.z));\n}\n\n//Very happy with this star function, cheap and smooth\nvec3 stars(in vec3 p)\n{\n    // 47fps\n    \n    vec3 c = vec3(0.);\n    float res = iResolution.x*1.5; // too small  and they will flicker\n    \n    // more stars?\n\tfor (float i=0.;i<2.;i++)\n    {\n        vec3 q = fract(p*(.15*res))-0.5;\n        vec3 id = floor(p*(.15*res));\n        vec2 rn = hash33(id).xy;\n        float c2 = smoothstep(1.2,0.,length(q)) / 2.;\n        c2 *= step(rn.x,.0005+i*i*0.001);\n        c += c2*(mix(vec3(1.0,0.49,0.1),vec3(0.75,0.9,1.),rn.y)*0.25+0.75);\n        p *= 1.4;\n    }\n    return c*c*.7;\n}\n\nvec4 startrails(in vec3 rd)\n{\n    vec3 col0 = stars( normalize(rotx(rd, iTime * 0.1)));\n\n    vec3 col = col0;\n\n    for (int i = -160; i < 0; i++)\n    {\n    \tvec3 col1 = stars( normalize(rotx(rd, iTime * 0.1 + (float(i) * (1./600.) ))));\n        \n    \tcol += col1;    \n    }\n    \n    return vec4(3.*col,1);\n}\n\n\n#define rot(a)        mat2( cos( a + vec4(0,33,11,0)) )\n#define sfloor(x)   ( floor(x-pix/2.) + max( 0., 1.-fract(-x+pix/2.) / pix ) ) // https://www.shadertoy.com/view/tsyXzV \n#define hash2x3(p)    fract(sin((p)*mat3x2(127.1,311.7,  269.5,183.3,  113.5,271.9))*43758.5453123) // https://www.shadertoy.com/view/llySRh\n#define keyPress(a) ( texelFetch(iChannel3,ivec2(a,0),0).x > 0.) // https://www.shadertoy.com/view/llySRh\n#define T(V)          texture(iChannel1,V/4.)\n\n\nfloat pix, s;                                         // a: material id\n\nfloat map( vec3 p ) {\n    float t,a; vec3 q = p;\n    q.xy = abs(q.xy), a = max(q.x,q.y);               // --- pyramid\n    t = max( (a==q.x?q.y:q.x) -2.,                    // slopes sides\n             a/1.3 + clamp(q.z,0.,9.) -9.25 );        // slopes top \n    t = max( t, q.z-7.);                              // top end\n    t = min( t, a + clamp(sfloor(q.z),0.,7.) - 9.);   // grades \n    t = max( t,-max(min(q.x,q.y)-.5,abs(q.z-7.5)-.5));// doors\n    t = max( t,-max(3.*abs(q.z-7.5),a)+1.5 );         // room\n    t = max( t, q.z-9.);                              // top end\n    s = q.z;                                          // --- forest. floor, then trees\n    q = .03*sin(15.*p); p += q.x+q.y+q.z;             // distortion\n    for (int k=0; k<9; k++) {                         // Worley-like dot structure\n        vec2 d = vec2(k%3-1,k/3-1);                   // seek for closest dot in 9x9 cells around\n        s = min(s, length( hash2x3(floor(p.xy)+d)           // random dot(cell)\n                          - vec3(fract(p.xy)-d,p.z) ) -.5); // raypos rel to cur cell\n    }\n    return min(t,s);\n}\n\n\nvec3 aces_tonemap(vec3 color){\t\n\tmat3 m1 = mat3(\n        0.59719, 0.07600, 0.02840,\n        0.35458, 0.90834, 0.13383,\n        0.04823, 0.01566, 0.83777\n\t);\n\tmat3 m2 = mat3(\n        1.60475, -0.10208, -0.00327,\n        -0.53108,  1.10813, -0.07276,\n        -0.07367, -0.00605,  1.07602\n\t);\n\tvec3 v = m1 * color;    \n\tvec3 a = v * (v + 0.0245786) - 0.000090537;\n\tvec3 b = v * (0.983729 * v + 0.4329510) + 0.238081;\n\treturn pow(clamp(m2 * (a / b), 0.0, 1.0), vec3(1.0 / 2.2));\t\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n \t\n\tfloat waterdepth = 2.1;\n\tvec3 wfloor = vec3(0.0, -waterdepth, 0.0);\n\tvec3 wceil = vec3(0.0, 0.0, 0.0);\n\tvec3 orig = vec3(0.0, 1.0, 0.0);\n\tvec3 ray = getRay(uv);\n\tfloat hihit = intersectPlane(orig, ray, wceil, vec3(0.0, 1.0, 0.0));\n    if(ray.y >= -0.01){\n        vec3 C = getatm(ray) * 2.0 //+ sun(ray)\n            ;\n        //tonemapping\n    \tC = aces_tonemap(C);\n     \t// sky\n        fragColor = vec4( C,1.0)  ;   \n               \n        \n        //fragColor.r *= 0.65;\n\t\t//fragColor.gb *= 0.85;\n\n        //return;\n    }\n    else\n    {\n\tfloat lohit = intersectPlane(orig, ray, wfloor, vec3(0.0, 1.0, 0.0));\n    vec3 hipos = orig + ray * hihit;\n    vec3 lopos = orig + ray * lohit;\n\tfloat dist = raymarchwater(orig, hipos, lopos, waterdepth);\n    vec3 pos = orig + ray * dist;\n\n\tvec3 N = normal(pos.xz, 0.001, waterdepth);\n    vec2 velocity = N.xz * (1.0 - N.y);\n    N = mix(vec3(0.0, 1.0, 0.0), N, 1.0 / (dist * dist * 0.01 + 1.0));\n    vec3 R = reflect(ray, N);\n    float fresnel = (0.04 + (1.0-0.04)*(pow(1.0 - max(0.0, dot(-N, ray)), 5.0)));\n\t\n    vec3 C = fresnel * getatm(R) * 2.0 + fresnel * sun(R);\n    //tonemapping\n    C = aces_tonemap(C);\n    \n\tfragColor = vec4(C,1.0);\n    }\n    \n    fragColor.rgb *= 0.5;\n    \n    fragColor.r *= 0.55;\n\n    \n    \n      if(ray.y >= -0.01)\n     fragColor.rgb += 10.0*stars(ray);   \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3d3fzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[207, 207, 298, 298, 466], [468, 468, 514, 514, 1031], [1033, 1033, 1101, 1101, 1544], [1561, 1561, 1605, 1605, 1989], [1990, 1990, 2027, 2027, 2441], [2443, 2443, 2464, 2464, 2950], [2952, 2952, 3028, 3028, 3121], [3123, 3123, 3177, 3177, 4155], [4157, 4157, 4179, 4179, 4252], [4254, 4254, 4274, 4274, 4369], [4373, 4373, 4400, 4400, 4488], [4492, 4552, 4573, 4573, 4716], [4718, 4773, 4796, 4809, 5294], [6151, 6151, 6172, 6172, 7258], [7261, 7261, 7291, 7291, 7738], [7739, 7739, 7796, 7796, 9172]], "test": "valid"}
{"id": "3dcBD8", "name": "cohomology fractals", "author": "FabriceNeyret2", "description": "WIP.    Porting [url] https://henryseg.github.io/cohomology_fractals/[/url]\n\nDon't assume I understand anything :-)\nCan't recover correct parameters for now to reproduce the nice demo.", "tags": ["fractals", "cohomology"], "likes": 8, "viewed": 238, "published": "Public API", "date": "1604911911", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://henryseg.github.io/cohomology_fractals/\n// https://github.com/henryseg/cohomology_fractals/blob/master/shaders/fragment.glsl\n\n\n// --- trying to translate Uniform data from json presets\n// data entry \"m004\" in https://raw.githubusercontent.com/henryseg/cohomology_fractals/master/data/cohomology_data_SV_cool.json\n// for arrays. chance tuning for other parameters\n\n#define zoomFactor exp2(3.*sin(.3*iTime))\n\nfloat          fov = 1.4, // no effect ?\n    //  zoomFactor = 1.,\n    clippingRadius = 4.,\n    liftsThickness = .1,\n     currentWeight = 13.,\n           maxDist = 100.,\n     edgeThickness = 1e-3,\n          contrast = 2.;\n\nint         tetNum = 0,\n          maxSteps = 100,\n     subpixelCount = 1,  // AA\n   perspectiveType = 1,  // 0,1\n          viewMode = 0,  // 0,1,2\n   multiScreenShot = 0;\n\nmat4  currentBoost = mat4(1); // no effect ?\nbool    normalised = true;\n\n vec2 tile = vec2(1),   // no effect ?\n  numTiles = vec2(10);  // no effect ?\n\n#define N 8  \nvec4 planes[N] =    vec4[N] ( vec4( 0.866025403784438, 0.500000000000001, -0.866025403784438, 0.866025403784438), \n                              vec4( 0.8660254037844386, 0.5000000000000001, 0.8660254037844386, 0.8660254037844386), \n                              vec4( -0.8660254037844394, 0.4999999999999991, 0.0, 0.0), \n                              vec4( 0.0, -1.0, 0.0, 0.0), \n                              vec4( 0.8660254037844387, 0.5, -0.8660254037844387, 0.8660254037844387), \n                              vec4( 0.8660254037844387, 0.5, 0.8660254037844387, 0.8660254037844387), \n                              vec4( -0.8660254037844387, 0.49999999999999994, 0.0, 0.0), \n                              vec4(0.0, -1.0, 0.0, 0.0)\n                            );\nint otherTetNums[N]       = int[N] (1, 1, 1, 1, 0, 0, 0, 0);\nint entering_face_nums[N] = int[N] (0, 2, 1, 3, 0, 2, 1, 3); \nfloat weights[N]        = float[N] (0.0, -0.5, 0.0, -0.5, 0.0, 0.0, 0.5, 0.5); // ???\nmat4 SO31tsfms[N] = mat4[N] ( mat4( -0.9999999999999999, -9.436895709313829e-16, 1.5, 1.5, 9.436895709313829e-16, -0.9999999999999999, 0.8660254037844382, 0.8660254037844382, 1.4999999999999987, 0.8660254037844393, -0.4999999999999994, -1.499999999999999, -1.4999999999999987, -0.8660254037844393, 1.4999999999999998, 2.499999999999999), \n                              mat4( 1.0, 2.2204460492503104e-16, 0.4999999999999995, -0.4999999999999995, 2.2204460492503104e-16, -1.0, -0.8660254037844396, 0.8660254037844396, 0.49999999999999867, 0.8660254037844386, -0.5000000000000001, -0.49999999999999856, -0.49999999999999867, -0.8660254037844386, -0.5000000000000011, 1.4999999999999998), \n                              mat4( 2.1094237467877974e-15, -1.7320508075688767, 0.4999999999999991, 1.4999999999999991, 1.3322676295501878e-15, -0.9999999999999999, -0.866025403784439, 0.866025403784439, 0.9999999999999999, 1.3322676295501878e-15, 1.1102230246251565e-16, -1.1102230246251565e-16, 2.1094237467877974e-15, -1.7320508075688767, -1.3322676295501878e-15, 1.9999999999999996), \n                              mat4( -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5), \n                              mat4( -1.0, 1.0547118733938985e-15, 1.4999999999999987, 1.4999999999999987, -1.0547118733938985e-15, -1.0, 0.866025403784439, 0.866025403784439, 1.5000000000000002, 0.866025403784438, -0.499999999999999, -1.4999999999999996, -1.5000000000000002, -0.866025403784438, 1.4999999999999984, 2.499999999999999), \n                              mat4( 1.8873791418627653e-15, 1.2212453270876718e-15, 0.9999999999999997, -1.8873791418627653e-15, -1.732050807568877, -0.9999999999999997, 1.2212453270876718e-15, 1.732050807568877, 0.4999999999999987, -0.8660254037844392, 1.1102230246251562e-16, 1.4432899320127031e-15, -1.4999999999999998, -0.8660254037844392, 2.2204460492503123e-16, 2.0), \n                              mat4( 1.0, 1.1102230246251559e-16, 0.4999999999999988, 0.4999999999999988, 1.1102230246251559e-16, -1.0, 0.8660254037844388, 0.8660254037844388, 0.4999999999999995, -0.8660254037844398, -0.5, 0.5000000000000013, 0.4999999999999995, -0.8660254037844398, 0.4999999999999989, 1.5000000000000002), \n                              mat4( -1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5)\n                            );\n\n// data entry \"m004\" from https://raw.githubusercontent.com/henryseg/cohomology_fractals/master/data/cohomology_data_SV_cool.json\n/* \"entering_face_nums\": [0, 2, 1, 3, 0, 2, 1, 3], \n\"flat_geometries\": [\n    [\"(0, 0)\", [\n        [0.866025403784438, 0.500000000000001, -0.866025403784438, 0.866025403784438], \n        [0.8660254037844386, 0.5000000000000001, 0.8660254037844386, 0.8660254037844386], \n        [-0.8660254037844394, 0.4999999999999991, 0.0, 0.0], \n        [0.0, -1.0, 0.0, 0.0], \n        [0.8660254037844387, 0.5, -0.8660254037844387, 0.8660254037844387], \n        [0.8660254037844387, 0.5, 0.8660254037844387, 0.8660254037844387], \n        [-0.8660254037844387, 0.49999999999999994, 0.0, 0.0], \n        [0.0, -1.0, 0.0, 0.0]\n    ], [\n        [-0.9999999999999999, -9.436895709313829e-16, 1.5, 1.5, 9.436895709313829e-16, -0.9999999999999999, 0.8660254037844382, 0.8660254037844382, 1.4999999999999987, 0.8660254037844393, -0.4999999999999994, -1.499999999999999, -1.4999999999999987, -0.8660254037844393, 1.4999999999999998, 2.499999999999999], \n        [1.0, 2.2204460492503104e-16, 0.4999999999999995, -0.4999999999999995, 2.2204460492503104e-16, -1.0, -0.8660254037844396, 0.8660254037844396, 0.49999999999999867, 0.8660254037844386, -0.5000000000000001, -0.49999999999999856, -0.49999999999999867, -0.8660254037844386, -0.5000000000000011, 1.4999999999999998], \n        [2.1094237467877974e-15, -1.7320508075688767, 0.4999999999999991, 1.4999999999999991, 1.3322676295501878e-15, -0.9999999999999999, -0.866025403784439, 0.866025403784439, 0.9999999999999999, 1.3322676295501878e-15, 1.1102230246251565e-16, -1.1102230246251565e-16, 2.1094237467877974e-15, -1.7320508075688767, -1.3322676295501878e-15, 1.9999999999999996], \n        [-1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5], \n        [-1.0, 1.0547118733938985e-15, 1.4999999999999987, 1.4999999999999987, -1.0547118733938985e-15, -1.0, 0.866025403784439, 0.866025403784439, 1.5000000000000002, 0.866025403784438, -0.499999999999999, -1.4999999999999996, -1.5000000000000002, -0.866025403784438, 1.4999999999999984, 2.499999999999999], \n        [1.8873791418627653e-15, 1.2212453270876718e-15, 0.9999999999999997, -1.8873791418627653e-15, -1.732050807568877, -0.9999999999999997, 1.2212453270876718e-15, 1.732050807568877, 0.4999999999999987, -0.8660254037844392, 1.1102230246251562e-16, 1.4432899320127031e-15, -1.4999999999999998, -0.8660254037844392, 2.2204460492503123e-16, 2.0], \n        [1.0, 1.1102230246251559e-16, 0.4999999999999988, 0.4999999999999988, 1.1102230246251559e-16, -1.0, 0.8660254037844388, 0.8660254037844388, 0.4999999999999995, -0.8660254037844398, -0.5, 0.5000000000000013, 0.4999999999999995, -0.8660254037844398, 0.4999999999999989, 1.5000000000000002], \n        [-1.0, 0.0, 1.0, 1.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.0, 0.5, -0.5, -1.0, 0.0, 0.5, 1.5]\n]]], \n??? \"flat_cohom_classes\": [[ [-1, 0, -1, 0], \n                             [0.0, -0.5, 0.0, -0.5, 0.0, 0.0, 0.5, 0.5] ]], \n\"other_tet_nums\": [1, 1, 1, 1, 0, 0, 0, 0]\n*/\n\nfloat gradientThreshholds[5] = float[5] ( .1,.3,.6,.8, .9 );\n   const vec3 C = vec3(1,0,0);      // green red  black  blue  white\n   vec3 gradientColours[5] = vec3[5] ( C.yxz, C, C.zzz, C.yzx, C.xxx );\n// #define C(p) pow( .8*vec3(.6,.8,1), vec3(p) )\n// vec3 gradientColours[5] = vec3[5] ( C(0), C(1), C(2), C(3), C(4) );\n\n// --------------------------------------------------------------------\n\n\n\n// inf             1\n//   v0 -------- v2\n//    | `.    .' |\n//    |   `. '   |\n//    |   . `.   |\n//    | .'    `. |\n//   v3 -------- v1\n// z               0\n\nfloat R31_dot(vec4 u, vec4 v){\n  return u.x*v.x + u.y*v.y + u.z*v.z - u.w*v.w; // Lorentz Dot\n}\n\nfloat R31_norm_inv(vec4 v){\n  return inversesqrt(abs(R31_dot(v,v)));\n}\n\nvec4 R31_normalise(vec4 v){\n  return v*R31_norm_inv(v);\n}\n\nfloat geodesicParameterPlanes(vec4 samplePoint, vec4 dualPoint1, vec4 dualPoint2){\n  // \"distance\" from a geodesic defined by two (assumed perpendicular) geodesic planes, this is not quite distance, need to asinh(sqrt( result ))\n  float dot1 = -R31_dot(samplePoint, dualPoint1);\n  vec4 dualPointPerp = R31_normalise(dualPoint2 - R31_dot(dualPoint1, dualPoint2) * dualPoint1); // should be precalculated if this is a main feature\n  float dot2 = -R31_dot(samplePoint, dualPointPerp);\n  // float dot3 = -R31_dot(dualPoint1, dualPoint2);\n  return dot1*dot1 + dot2*dot2;\n  // return dot1*dot1 * (1.0 + dot3*dot3) + dot2*dot2 + 2.0*dot1*dot2*dot3;\n}\n\nfloat triangleBdryParam(vec4 samplePoint, int tetNum, int exit_face){\n  vec4 exit_dual_point = planes[4*tetNum + exit_face];\n  float smallest_p = 100000000.0;\n  for(int face=0; face<4; face++){\n      if(face != exit_face){  // find p when we hit that face\n          int index = 4*tetNum + face;\n          float new_p = geodesicParameterPlanes(samplePoint, exit_dual_point, planes[index]);\n          if(new_p < smallest_p){\n            smallest_p = new_p;\n          }   \n      }\n  }\n  return smallest_p;\n}\n\n/// --- Ray-trace code --- ///\n\n  float hyp_dist(vec4 u, vec4 v){\n    float bUV = -R31_dot(u,v);\n    if (bUV < 1.0) {return 0.0;}\n    else {return acosh(bUV);}  \n  } \n\nfloat param_to_isect_line_with_plane(vec4 line_start, vec4 line_dir, vec4 plane){\n    float denom = R31_dot(plane, line_dir);\n    if(denom == 0.0){ return 200000000.0; }  // bigger than the initial smallest_p value we will accept\n    /// solve: R31_dot(plane, line_start + p * line_dir) = 0\n    ///        R31_dot(plane, line_start) + p * R31_dot(plane, line_dir) = 0\n    return (-R31_dot(plane, line_start)) / denom;\n  }\n\nvec4 ray_trace_through_hyperboloid_tet(vec4 init_pos, vec4 init_dir, int tetNum, int entry_face, out int exit_face){\n    ///Given shape of a tet and a ray, find where the ray exits and through which face\n    float smallest_p = 100000000.0;\n    for(int face=0; face<4; face++){\n        if(face != entry_face){  // find p when we hit that face\n            int index = 4*tetNum + face;\n            if(R31_dot(init_dir, planes[index]) > 0.0){ \n                float p = param_to_isect_line_with_plane(init_pos, init_dir, planes[index]);\n                // if ((-10000.0 <= p) && (p < smallest_p)) {\n                if (p < smallest_p) {  \n                    /// negative values are ok if we have to go backwards a little to get through the face we are a little the wrong side of\n                    /// Although this can apparently get caught in infinite loops in an edge\n\n                    /// if we are on an edge then we don't in fact move as we go through this tet: t = 0.0\n                    /// also allow tiny negative values, which will come up from floating point errors. \n                    /// surface normals check should ensure that even in this case we make progress through \n                    /// the triangles around an edge\n                    smallest_p = p;\n                    exit_face = face;\n                }\n            }\n        }\n    }\n    return R31_normalise( init_pos + smallest_p * init_dir );\n}\n\nfloat ray_trace(vec4 init_pt, vec4 init_dir, float dist_to_go, int tetNum, float inputWeight){\n    int return_type = 0;\n    if(viewMode == 0){ return_type = 0; } // total_face_weight\n    else if(viewMode == 1){ return_type = 1; } // distance\n    else if(viewMode == 2){ return_type = 2; } // tet number\n    int entry_face = -1;   /// starts off with no entry face\n    int exit_face = -1;\n    float total_face_weight = inputWeight;\n    vec4 new_pt;\n    int index;\n    mat4 tsfm;\n    vec4 new_dir;\n    for(int i=0; i<maxSteps; i++){\n      new_pt = ray_trace_through_hyperboloid_tet(init_pt, init_dir, tetNum, entry_face, exit_face);\n      dist_to_go -= hyp_dist(init_pt, new_pt);\n      if (dist_to_go <= 0.0){ dist_to_go = 0.0; break; }\n      if(edgeThickness > 0.00001){\n        if(triangleBdryParam(new_pt, tetNum, exit_face) < edgeThickness){ break; }}\n        // in fact pow(sinh(radius in hyperbolic units),2.0). However, sinh^2 is monotonic for \n        // positive values so we get correct behaviour by comparing without the sinh^2. \n      index = 4*tetNum + exit_face;\n      total_face_weight += weights[ index ]; \n      if(liftsThickness > 0.0){  // here we detect and draw elevations\n        if( ( total_face_weight <= liftsThickness && liftsThickness < inputWeight ) || // see elevations from behind\n                  ( inputWeight < 0.0001          &&         0.0001 < total_face_weight ) ||  // see elevations from in front // cannot make this too close to 0.0 or we get floating point issues from different sums of weights\n            ( 0.0001 < inputWeight && inputWeight <= liftsThickness && inputWeight != total_face_weight) // see elevations from in between\n                  ) { \n          return_type = 1; \n          break; \n        } \n      }             \n      entry_face = entering_face_nums[ index ];\n      tsfm = SO31tsfms[ index ];\n      tetNum = otherTetNums[ index ];\n\n      new_dir = init_dir + R31_dot(init_dir, new_pt) * new_pt; // orthonormal decomp, no normalisation yet\n      init_pt = new_pt * tsfm;  \n      init_dir = R31_normalise( new_dir * tsfm ); \n    }\n    if(return_type == 0){ return total_face_weight; } // Cohomology\n    else if(return_type == 1){ return 0.5*maxDist - dist_to_go; } // Colour by Distance\n    else { return float(tetNum);} // Colour by tetrahedron number\n}\n\n/// --- Graph-trace code --- ///\n\nfloat amountOutsideTetrahedron(vec4 v, int tetNum, out int biggest_face) {\n  float biggest_amount = -100000.0;\n  float amount;\n  for(int i = 0; i < 4; i++){\n    amount = R31_dot( v, planes[4*tetNum + i] );\n    if( amount > biggest_amount ){\n      biggest_amount = amount;\n      biggest_face = i;\n    }\n  }\n  return biggest_amount; \n}\n\nvec4 pointOnGeodesic(vec4 pos, vec4 dir, float dist){\n  return pos*cosh(dist) + dir*sinh(dist);\n}\n\nvec4 tangentOnGeodesic(vec4 pos, vec4 dir, float dist){\n  return pos*sinh(dist) + dir*cosh(dist);\n}\n\nfloat graph_trace(inout vec4 goal_pt, inout int tetNum, out mat4 tsfm){ // tsfm is matrix to send goal_pt to its image in the tetrahedron coordinates it is in\n  // similar function to ray_trace, but different algorithm\n  float total_face_weight = 0.0;\n  int entry_face = -1;\n  int index;\n  int biggest_face;\n  tsfm = mat4(1.0);\n  for(int i=0; i<maxSteps; i++){\n      if ( amountOutsideTetrahedron(goal_pt, tetNum, biggest_face) > 0.0 && biggest_face != entry_face ){ //0.0000001\n        index = 4*tetNum + biggest_face;\n        entry_face = entering_face_nums[ index ];\n        tetNum = otherTetNums[ index ];\n        // if(viewMode == 2) { total_face_weight += abs(weights[ index ]); } // translucent surface: all weights positive\n        // else { \n        total_face_weight += weights[ index ]; \n        goal_pt *= SO31tsfms[ index ];\n        tsfm *= SO31tsfms[ index ];\n        // if (R31_dot(goal_pt, goal_pt) > -0.5){ return -1000.0; } // errors accumulate and we get junk!\n      }\n      else{ break; }\n    }\n    return total_face_weight;\n  }\n\n/// --- Colour gradient code --- ///\n\nint find_band(float t, float threshholds[5]){\n    for(int j=1;j<4;j++){\n        if(t < threshholds[j]){return j;}\n    }\n    return 4;\n}\nvec4 general_gradient(float t, float threshholds[5], vec3 colours[5]){\n    int i = find_band(t, threshholds);\n    return vec4( mix(colours[i-1], colours[i],(t - threshholds[i-1])/(threshholds[i] - threshholds[i-1]) ), 1.0);\n}\n\n/// --- Ray init pt and directions code --- ///\n\nvec4 get_ray_pos_dir_material(vec2 xy, out vec4 ray_dir){ \n    float z = 0.5/tan(radians(fov*0.5));\n    ray_dir = R31_normalise(vec4(xy,-z,0.0));\n    return vec4(0.0,0.0,0.0,1.0);\n}\n\nvec4 get_ray_pos_dir_ideal(vec2 xy, out vec4 ray_dir){ \n    float foo = 0.5*dot(xy, xy);\n    vec4 ray_pt = vec4(xy, foo, foo + 1.0);   // parabolic transformation magic by Saul\n    ray_dir = vec4(xy, foo - 1.0, foo);\n    return ray_pt;\n}\n\nvec4 get_ray_pos_dir_hyperideal(vec2 xy, out vec4 ray_dir, out bool background){ \n    vec4 ray_pt = R31_normalise(vec4(2.0 * xy,0.0,1.0));\n    if (R31_dot(ray_pt, ray_pt) < 0.0){\n      ray_dir = vec4(0.0,0.0,-1.0,0.0);\n      background = false;\n    }\n    else{\n      ray_dir = vec4(0.0,0.0,0.0,0.0);\n      ray_pt = vec4(0.0,0.0,0.0,1.0);  // avoid jank\n      background = true;\n    }\n    return ray_pt;\n}\n\n//new_dir = init_dir + R31_dot(init_dir, new_pt) * new_pt;\n\nfloat get_signed_count(vec2 xy){\n  vec4 init_pt;\n  vec4 init_dir;\n  float weight = 0.0;\n  bool background = false;\n  mat4 tsfm = mat4(1.0);\n  int currentTetNum = tetNum;  // gets modified inside graph_trace\n  if(perspectiveType == 0){ init_pt = get_ray_pos_dir_material(xy, init_dir); }\n  else if(perspectiveType == 1){ init_pt = get_ray_pos_dir_ideal(xy, init_dir); }\n  else{ init_pt = get_ray_pos_dir_hyperideal(xy, init_dir, background); }\n  init_pt *= currentBoost;\n  init_dir *= currentBoost; \n  vec4 new_init_pt = pointOnGeodesic(init_pt, init_dir, clippingRadius);\n  init_dir = tangentOnGeodesic(init_pt, init_dir, clippingRadius);\n  init_pt = new_init_pt;\n  weight = graph_trace(init_pt, currentTetNum, tsfm);  // get us to the tetrahedron containing init_pt. \n  // init_pt *= tsfm;  // the point gets moved back in graph_trace\n  init_dir *= tsfm;  // move the direction back to here\n  if (background){ return 0.0; }\n  else{ return ray_trace(init_pt, init_dir, maxDist, currentTetNum, currentWeight + weight); }\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 xy = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n  xy *= zoomFactor;\n  if(multiScreenShot == 1){  // Return multiple 4096x4096 screenshots that can be combined in, e.g. Photoshop.\n    // Here screenResolution is really tileResolution;\n    xy = (xy + tile - 0.5*(numTiles - vec2(1.0,1.0))) / numTiles.x;\n  }\n\n  float total_weight = 0.0;\n  for(int i=0; i<subpixelCount; i++){\n    for(int j=0; j<subpixelCount; j++){\n      vec2 offset = ( (float(1+2*i), float(1+2*j))/float(2*subpixelCount) - vec2(0.5,0.5) ) / iResolution.x;\n      total_weight += get_signed_count(xy + offset);\n    }\n  }\n  float weight = total_weight/float(subpixelCount*subpixelCount); // average over all subpixels\n\n  if(normalised){ weight /= sqrt(maxDist); }\n\n  weight = contrast * weight;\n\n\n  // linear\n  // float minW = -31.75;\n  // float maxW = 32.25;\n\n  // float minW = -63.75;\n  // float maxW = 64.25;\n\n  // float minW = -127.75;\n  // float maxW = 128.25;\n\n  // weight = (weight - minW)/(maxW - minW);\n\n  // arctan\n  // weight = 0.5 + atan(0.3 * weight)/PI;  // between 0.0 and 1.0\n  \n  // faster than atan, similar\n  weight = 0.5 + 0.5*weight/(abs(weight) + 1.0);  \n  \n  fragColor = general_gradient(weight, gradientThreshholds, gradientColours);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcBD8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[7959, 7959, 7989, 7989, 8054], [8056, 8056, 8083, 8083, 8126], [8128, 8128, 8155, 8155, 8185], [8187, 8187, 8269, 8415, 8830], [8832, 8832, 8901, 8901, 9336], [9372, 9372, 9403, 9403, 9503], [9506, 9506, 9587, 9587, 9927], [9929, 9929, 10045, 10132, 11358], [11360, 11360, 11454, 11454, 13675], [13711, 13711, 13785, 13785, 14044], [14046, 14046, 14099, 14099, 14143], [14145, 14145, 14200, 14200, 14244], [14246, 14246, 14317, 14464, 15294], [15334, 15334, 15379, 15379, 15469], [15470, 15470, 15540, 15540, 15695], [15746, 15746, 15803, 15803, 15927], [15929, 15929, 15983, 15983, 16166], [16168, 16168, 16248, 16248, 16572], [16634, 16634, 16666, 16666, 17655]], "test": "valid"}
{"id": "3dcBW2", "name": "checkerboard animation 4.b", "author": "FabriceNeyret2", "description": "for https://isohedral.ca/swirled-series/", "tags": ["checkerboard", "short"], "likes": 17, "viewed": 266, "published": "Public API", "date": "1605966659", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// variant of https://shadertoy.com/view/3s3BW2\n\nfloat ease( float x ) {                                 // rewritten from https://shadertoy.com/view/3ddBWB\n    x = clamp(x, 0.,1.);                                // stepier than smoothstep or .5-.5*cos\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x\n                  :                4.* x*x*x ;\n}\n\n#define D \\\n    V = abs( ( fract(U/2.)-.5)*mat2( cos(3.14/2.*t + vec4(0,11,33,0))) ); \\\n    O += smoothstep( w, -w, max(V.x,V.y) - .25 ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    O-=O; \n    vec2 R = iResolution.xy,\n         U = u *= 8. / R.y, V;\n    if (U.x > 8.) { O += .5; return; }                  // out of board\n\n    float T = iTime/2.,\n       // t = ease( 1.5*fract(T) - U.x/16. ),\n          t = ease( 1.5*fract(T) - U[int(T)%2]/16. ),\n          n = mod(T,2.), w = 4./R.y;\n\n    if (n > 1.)  U.x++, t = 1.-t;\n    U -= .5; D;\n    U++;     D;\n    if (n < 1.)  O = 1.-O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcBW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[49, 49, 72, 156, 343], [484, 484, 522, 522, 926]], "test": "error"}
{"id": "3dcfDr", "name": "Simple SDF Raycast Scene", "author": "0xAA55", "description": "The GLSL implemention of this: https://github.com/0xAA55/NASMCompileTimeRayTracing", "tags": ["raycast", "sdf"], "likes": 5, "viewed": 213, "published": "Public", "date": "1604762628", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nconst int RayStepCount = 320;\nconst int SampleDepth = 12;\n\nconst vec3 CamPos = vec3(0.0, 2.0, 7.0);\nconst vec4 Sphere1 = vec4(0.0, 2.0, 0.0, 2.0);\nconst vec4 Sphere2 = vec4(1.0, 1.0, 2.0, 1.0);\nconst vec4 Sphere3 = vec4(-3.0, 1.0, 0.0, 1.0);\nconst vec3 LightDir = vec3(1.0, -1.0, 1.0);\nconst float LightPow = 20.0;\nconst vec3 LightColor = vec3(1.0, 0.8, 0.6);\nconst vec3 FogColor = vec3(0.8, 0.9, 1.0);\nconst vec3 SkyColor = vec3(0.2, 0.5, 0.8);\nconst float FogDistance = 100.0;\nconst vec3 BoundBoxNeg = vec3(-5.0, -1.0, -3.0);\nconst vec3 BoundBoxPos = vec3(3.0, 5.0, 4.0);\n\nconst float Epsilon = 0.00001;\nconst float CastEpsilon = 0.005;\nconst float CastEpsilon2 = 0.01;\n\nbool IsAwayFromBB(in vec3 RayOrg, in vec3 RayDir)\n{\n    return\n        (RayOrg.x < BoundBoxNeg.x && RayDir.x <= 0.0) ||\n        (RayOrg.x > BoundBoxPos.x && RayDir.x >= 0.0) ||\n        (RayOrg.y < BoundBoxNeg.y && RayDir.y <= 0.0) ||\n        (RayOrg.y > BoundBoxPos.y && RayDir.y >= 0.0) ||\n        (RayOrg.z < BoundBoxNeg.z && RayDir.z <= 0.0) ||\n        (RayOrg.z > BoundBoxPos.z && RayDir.z >= 0.0);\n}\n\nvec3 GetSkyColor(in vec3 Dir)\n{\n    float SunLum = pow(max(dot(normalize(LightDir), -Dir), 0.0), LightPow);\n    float Foggy = 1.0 - abs(Dir.y);\n    return mix(SkyColor, FogColor, Foggy) + SunLum * LightColor;\n}\n\nvec2 MapDist(in vec3 Pos)\n{\n    float ResultDist = 9999999.0;\n    float ResultIndex = 0.0;\n    float Dist1 = Pos.y;\n    float Dist2 = distance(Pos, Sphere1.xyz) - Sphere1.w;\n    float Dist3 = distance(Pos, Sphere2.xyz) - Sphere2.w;\n    float Dist4 = distance(Pos, Sphere3.xyz) - Sphere3.w;\n    if(Dist1 < ResultDist)\n    {\n        ResultDist = Dist1;\n        ResultIndex = int(mod(Pos.x * 2.0, 2.0)) != int(mod(Pos.z * 2.0, 2.0)) ? 1.0 : 5.0;\n    }\n    if(Dist2 < ResultDist)\n    {\n        ResultDist = Dist2;\n        ResultIndex = 2.0;\n    }\n    if(Dist3 < ResultDist)\n    {\n        ResultDist = Dist3;\n        ResultIndex = 3.0;\n    }\n    if(Dist4 < ResultDist)\n    {\n        ResultDist = Dist4;\n        ResultIndex = 4.0;\n    }\n    return vec2(ResultDist, ResultIndex);\n}\n\nvec3 MapNormal(in vec3 Pos)\n{\n    vec2 Nearest = MapDist(Pos);\n    int Index = int(Nearest.y);\n    if (Index == 1 || Index == 5)\n        return vec3(0, 1, 0);\n    if (Index == 2)\n        return normalize(Pos - Sphere1.xyz);\n    if (Index == 3)\n        return normalize(Pos - Sphere2.xyz);\n    if (Index == 4)\n        return normalize(Pos - Sphere3.xyz);\n}\n\nvec3 MapColor(in vec3 Pos)\n{\n    vec2 Nearest = MapDist(Pos);\n    int Index = int(Nearest.y);\n    if (Index == 1)\n        return vec3(1.0, 1.0, 1.0);\n    if (Index == 2)\n        return vec3(0.7, 0.9, 0.1);\n    if (Index == 3)\n        return vec3(0.1, 0.7, 0.9);\n    if (Index == 4)\n        return vec3(0.9, 0.1, 0.7);\n    if (Index == 5)\n        return vec3(0.5, 0.5, 0.5);\n}\n\nfloat GroundCast(in vec3 RayOrg, in vec3 RayDir)\n{\n    if(abs(RayDir.y) <= Epsilon)\n    {\n        return -1.0;\n    }\n    else\n    {\n        return RayOrg.y / -RayDir.y;\n    }\n}\n\nfloat MapCast(in vec3 RayOrg, in vec3 RayDir)\n{\n    float Dist = 0.0;\n    for(int i = 0; i < RayStepCount; i++)\n    {\n        if(IsAwayFromBB(RayOrg, RayDir))\n        {\n            if(RayDir.y < 0.0)\n            {\n                float GroundDist = GroundCast(RayOrg, RayDir);\n                if(GroundDist >= 0.0)\n                \treturn Dist + GroundDist;\n            }\n            else return -1.0;\n        }\n        else\n        {\n            vec2 Nearest = MapDist(RayOrg + RayDir * Dist);\n            Dist += Nearest.x;\n            if(Nearest.x <= CastEpsilon) return Dist;\n        }\n    }\n    return -1.0;\n}\n\nvec3 RenderScene(in vec3 RayOrg, in vec3 RayDir)\n{\n    vec3 CurRayOrg = RayOrg;\n    vec3 CurRayDir = RayDir;\n    vec3 Mask = vec3(1.0, 1.0, 1.0);\n    for(int i = 0; i < SampleDepth; i++)\n    {\n       \tfloat CastDist = MapCast(CurRayOrg, CurRayDir);\n        if(CastDist < 0.0) break;\n        vec3 CastPos = CurRayOrg + CurRayDir * CastDist;\n        float Foggy = CastDist / FogDistance;\n        vec3 CastNormal = MapNormal(CastPos);\n        Mask *= mix(MapColor(CastPos), FogColor, min(Foggy, 1.0));\n        CurRayOrg = CastPos;\n        CurRayDir = normalize(reflect(CurRayDir, CastNormal));\n        CurRayOrg += CurRayDir * CastEpsilon2;\n    }\n    return GetSkyColor(CurRayDir) * Mask;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 RayOrg = CamPos + vec3(cos(iTime * 0.5), sin(iTime * 0.5), sin(iTime * 0.25) * 4.0) * 0.5;\n    vec3 RayDir = normalize(vec3((fragCoord * 2.0 - iResolution.xy) / iResolution.yy, -1.75));\n    fragColor = vec4(RenderScene(RayOrg, RayDir), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[674, 674, 725, 725, 1078], [1080, 1080, 1111, 1111, 1290], [1292, 1292, 1319, 1319, 2066], [2068, 2068, 2097, 2097, 2423], [2425, 2425, 2453, 2453, 2800], [2802, 2802, 2852, 2852, 2978], [2980, 2980, 3027, 3027, 3594], [3596, 3596, 3646, 3646, 4283], [4285, 4285, 4342, 4342, 4595]], "test": "error"}
{"id": "3dcfzn", "name": "Tau Ceti Spectrum rendering 2", "author": "TomF", "description": "A test of a more advanced TauCeti/Academy rendering technique for a ZX Spectrum\n\nExample of the original by Pete Cooke:\nhttps://www.youtube.com/watch?v=z3p_PoeSLYI&t=14m17s", "tags": ["retro", "rendering", "spectrun"], "likes": 4, "viewed": 155, "published": "Public", "date": "1604186809", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// 0 = three-shade shading.\n// 1 = original TauCeti style two-shade rendering.\n#define TWO_SHADE 0\n\n// 0 = fancy new non-circular rendering (doesn't really work well)\n// 1 = original TauCeti style only-circles rendering.\n#define FORCE_CIRCULAR 0\n\n// 0 = native PC resolution\n// 1 = Spectrum-style monchrome with dither\n#define SPECCY_REZ 1\n\n// 0 = no debug info.\n// 1 = debug info.\n#define DEBUG_MODE 0\n\n// 0 = no lightning\n// 1 = lightning!\n#define LIGHTNING 1\n\n\n\n// Shapes are made of a series of horizontal slices.\n// Each slice has a Y coordinate.\n// Slices are listed top (positive Y) to bottom (negative Y).\n// Adjacent slices may have the same Y but different widths,\n// and this will produce a discontinuity as expected.\n//\n// Each slice has a brightness that is for the section below it.\n// Negative numbers mean self-illuminated.\n// Positive numbers mean lit by the sun. (1.0 = full)\n//\n// Each slice has eight segments, forming a full circle,\n// one for each of the eight directions around a circle.\n// First direction is directly ahead, the rest are clockwise.\n// Each segment is:\n//  - a width at the start of the segment - interpolated to the start of the next segment\n//  - a depth the sgement starts at\n//  - a depth the sgement end at\n// Negative widths are valid! Self-intersection will look strange.\n// Each width also has a start depth and an end depth, which are the\n// start & end depths at which the kissing tangent hits the shape during\n// that segment. These are only used for lighting of course.\n\nconst int ShapeSliceSize = (2+8*3);\n\n#if 0\nfloat[] Shape = \nfloat [](\n    // Round top.\n     3.0,  1.0,\t  5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, 5.0,0.0,0.0, \n     2.0,  -1.0,  6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, \n     1.5,  0.5,\t  6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, 6.0,0.0,0.0, \n     0.0,  0.5,\t  4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, \n    // Circular column biased towards the front.\n     0.0,  0.7,   2.0,0.0,0.7, 1.7,0.7,1.0, 1.0,1.0,0.7, 0.3,0.7,0.0, 0.0,0.0,-0.7, 0.3,-0.7,-1.0, 1.0,-1.0,-0.7, 1.7,-0.7,0.0,\n    -1.0,  0.7,   2.0,0.0,0.7, 1.7,0.7,1.0, 1.0,1.0,0.7, 0.3,0.7,0.0, 0.0,0.0,-0.7, 0.3,-0.7,-1.0, 1.0,-1.0,-0.7, 1.7,-0.7,0.0,\n    // a square-section middle\n    -1.0,  0.7,   3.0,-3.0,0.0, 4.2426,0.0,3.0, 3.0,-3.0,0.0, 4.2426,0.0,3.0, 3.0,-3.0,0.0, 4.2426,0.0,3.0, 3.0,-3.0,0.0, 4.2426,0.0,3.0, \n    -2.0,  0.7,   4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, \n    // Then round off the front\n    -2.0,  1.0,   5.7,0.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,0.0, \n    -4.0,  1.0,   5.7,0.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0, 5.7,0.0,0.0, \n    // And back to a circle.\n    -4.0,  1.0,   5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, \n    -5.0,  1.0,   5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, 5.7,0.0,0.0, \n    -5.0,  0.0,   0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0\n);\nconst int ShapeSlices = 12;\n#else\n// Let's make a tank!\n// TODO: allow turret to rotate independently of the bottom!\n//       Should be pretty simple. Although could just do it with two separate\n//       \"sprites\" drawn on top of each other.\nfloat[] Shape = \nfloat [](\n    // Commander's cupola.\n     3.3,  0.7,   2.0,0.0,0.7, 1.7,0.7,1.0, 1.0,1.0,0.7, 0.3,0.7,0.0, 0.0,0.0,-0.7, 0.3,-0.7,-1.0, 1.0,-1.0,-0.7, 1.7,-0.7,0.0,\n     3.0,  0.7,   2.0,0.0,0.7, 1.7,0.7,1.0, 1.0,1.0,0.7, 0.3,0.7,0.0, 0.0,0.0,-0.7, 0.3,-0.7,-1.0, 1.0,-1.0,-0.7, 1.7,-0.7,0.0,\n    // Round turret top\n     3.0,  1.0,\t 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, 2.8,0.0,0.0, \n     2.5,  1.0,\t 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, 3.6,0.0,0.0, \n     2.0,  1.0,  4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, \n    // Pointy barrel, still with round rear, and sloping back down to round.\n     2.0,  1.0,  10.0,0.0,7.07, 7.07,7.07,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,-7.07, 7.07,-7.07,0.0, \n     1.0,  1.0,  10.0,0.0,7.07, 7.07,7.07,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,-7.07, 7.07,-7.07,0.0, \n     1.0,  1.0,  4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, \n     0.5,  1.0,  4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, 4.0,0.0,0.0, \n    // Narrow neck.   \n     0.5,  0.5,\t  3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, \n     0.0,  0.5,\t  3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, 3.0,0.0,0.0, \n    // The bottom is mainly retangle-shaped in cross-section, but with the tread shape.\n     0.0,  1.0,   4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0,  5.7,0.0,4.0,  4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0,  5.7,0.0,4.0, \n    -0.3,  1.0,   5.0,-4.0,0.7, 6.4,0.7,5.0, 4.0,-5.0,-0.7, 6.4,-0.7,4.0, 5.0,-4.0,0.7, 6.4,0.7,5.0, 4.0,-5.0,-0.7, 6.4,-0.7,4.0, \n    -1.0,  1.0,   6.0,-4.0,1.4, 7.1,1.4,6.0, 4.0,-6.0,-1.4, 7.1,-1.4,4.0, 6.0,-4.0,1.4, 7.1,1.4,6.0, 4.0,-6.0,-1.4, 7.1,-1.4,4.0, \n    -2.0,  1.0,   6.0,-4.0,1.4, 7.1,1.4,6.0, 4.0,-6.0,-1.4, 7.1,-1.4,4.0, 6.0,-4.0,1.4, 7.1,1.4,6.0, 4.0,-6.0,-1.4, 7.1,-1.4,4.0, \n    -3.5,  1.0,   4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0,  5.7,0.0,4.0,  4.0,-4.0,0.0, 5.7,0.0,4.0, 4.0,-4.0,0.0,  5.7,0.0,4.0, \n    \n    -5.0,  0.0,   0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0\n    -5.0,  0.0,   0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0\n    -5.0,  0.0,   0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,0.0\n);\nconst int ShapeSlices = 16;\n#endif\n\n\n\n// Returns the right-hand \"width\" for a viewer at a given heading from the shape,\n// and the depth at which it hits.\nvec2 CalculateSliceHeadingWidth ( int SliceNum, float Heading )\n{\n#if FORCE_CIRCULAR\n    return vec2 ( Shape[SliceNum*ShapeSliceSize+2], 0.0 );\n#else\n    // If the viewer is at heading 0.25, then the\n    // right-hand edge will be determined by the\n    // forward-facing part of the shape.\n    float WidthBlend = 8.0 * (Heading - 0.25);\n    if ( WidthBlend < 0.0 )\n    {\n        WidthBlend += 8.0;\n    }\n    int WidthIndex0 = int(floor(WidthBlend));\n    int WidthIndex1 = (WidthIndex0 + 1) & 7;\n    WidthIndex0 *= 3;\n    WidthIndex1 *= 3;\n    WidthBlend = fract(WidthBlend);\n    \n    // Widths are interpolated from one sgement to the next.\n    float WidthS0 = Shape[SliceNum*ShapeSliceSize+2+WidthIndex0];\n    float WidthS1 = Shape[SliceNum*ShapeSliceSize+2+WidthIndex1];\n    float Width = WidthS0 + WidthBlend * ( WidthS1 - WidthS0 );\n    \n    // Depths are interpolated, but the start and end are internal to each segment\n    float DepthS0 = Shape[SliceNum*ShapeSliceSize+3+WidthIndex0];\n    float DepthS1 = Shape[SliceNum*ShapeSliceSize+4+WidthIndex0];\n    float Depth = DepthS0 + WidthBlend * ( DepthS1 - DepthS0 );\n    \n    return vec2 ( Width, Depth );\n#endif\n}\n\n\nfloat nrand( vec2 n )\n{\n\treturn fract(sin(dot(n.xy, vec2(12.9898, 78.233)))* 43758.5453);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n#if SPECCY_REZ\n    // Real speccy rez is 256*192, but it aliases badly,\n    // and is the wrong aspect ratio, so tweak it a bit.\n    const vec2 SpecRez = vec2 ( 160.0, 90.0 );\n    uv = uv * SpecRez;\n    uv = floor ( uv );\n    int DitherX = (1 & int(uv.x));\n    int DitherY = (1 & int(uv.y));\n    uv = uv / SpecRez;\n#endif    \n    vec2 ndc = 2.0*uv - 1.0;\n    float AspectRatio = iResolution.y / iResolution.x;\n\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+ndc.xyx+vec3(0,2,4));\n#if SPECCY_REZ\n    col = vec3 ( 0.0, 0.0, 0.0 );\n#endif\n   \n    \n    vec3 CamPos = vec3 ( 0.0, 0.0, 0.0 );\n    // I like headings to be from 0.0 to 1.0, clockwise\n    float CamHeading = fract((iMouse.x/iResolution.x)*2.0);\n    CamPos.y = 10.0f * (0.5-fract((iMouse.y/iResolution.y)*2.0+0.5));\n    \n    float SunHeading = fract(iTime*0.01 + 0.125);\n    \n    float SunBrightness = 1.0;\n#if LIGHTNING\n    // Slightly quantise time...\n    float qTime = floor(iTime * 7.0);\n    if ( nrand(vec2(0.0,qTime)) < 0.05 )\n    {\n        SunBrightness = 2.0;\n        col *= 2.0;\n#if SPECCY_REZ\n        if ( DitherX != DitherY )\n        {\n\t    \tcol = vec3 ( 1.0, 1.0, 1.0 );\n        }\n#endif\n    }\n#endif    \n    \n    float ShapeHeading = fract(iTime*0.1);\n    //ShapeHeading = 0.125;\n    \n    vec3 ShapePos = vec3 ( 0.0, 0.0, 20.0 );\n    \n    float tanHFov = 0.5;\n    vec2 tanFov = vec2 ( tanHFov, tanHFov * AspectRatio );\n   \n\n    \n    vec3 CenterPos = ShapePos - CamPos;\n    float TwoPi = 2.0*3.1415927;\n    vec2 sincosH = vec2(sin(CamHeading*TwoPi),cos(CamHeading*TwoPi));\n    vec3 CamCenterPos = vec3(\n        sincosH.y * CenterPos.x - sincosH.x * CenterPos.z,\n        CenterPos.y,\n        sincosH.x * CenterPos.x + sincosH.y * CenterPos.z);\n\n    float CamSunHeading = fract(SunHeading-CamHeading);\n    \n    // Shades are 2 = fully lit, 1 = half lit, 0 = unlit.\n    // The actual colour will be determined by the segment's brightness/characteristics.\n    int ShadeL = 0;\n    int ShadeM = 0;\n    int ShadeR = 0;\n    \n    float ColourBlendL = 0.0;\n    float ColourBlendR = 0.0;\n    \n    // These are the headings of the L and R visible terminator lines\n    // between the lit sections, *in shape space*.\n    float ShapeHeadingSun = SunHeading-ShapeHeading;\n    float ShapeHeadingLightL = 0.0;\n    float ShapeHeadingLightR = 0.0;\n    \n#if TWO_SHADE\n    // 2-shade rendering - shape has two sides -\n    // the lit one facing the sun and the unlit one facing away\n    // Only CamBlendL and ColourLeft/Right are used here.\n    if ( CamSunHeading < 0.5 )\n    {\n        // Sun to the right\n    \tShadeL = 1;\n        ShadeR = 2;\n    \tColourBlendL = 1.0f-((CamSunHeading - 0.0) * 4.0);\n        \n        ShapeHeadingLightL = ShapeHeadingSun + 0.5;\n    }\n    else\n    {\n        // Sun to the left\n    \tShadeL = 2;\n        ShadeR = 1;\n    \tColourBlendL = 1.0f-((CamSunHeading - 0.5) * 4.0);\n        \n        ShapeHeadingLightL = ShapeHeadingSun;\n    }\n#else\n    // 2-shade rendering - shape has four sides -\n    // the lit one facing the sun, the unlit one facing away,\n    // and the half-lit ones in between.\n    float TempHeading = fract(CamSunHeading + 0.125);\n    if ( TempHeading < 0.25 )\n    {\n        // Looking at back side\n    \tShadeL = 1;\n    \tShadeM = 0;\n        ShadeR = 1;\n    \tColourBlendL = 0.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n        \n        ShapeHeadingLightR = ShapeHeadingSun + 0.125 + 0.5;\n        ShapeHeadingLightL = ShapeHeadingLightR + 0.25;        \n    }\n    else if ( TempHeading < 0.5 )\n    {\n        // Sun on the right\n    \tShadeL = 0;\n    \tShadeM = 1;\n        ShadeR = 2;\n    \tColourBlendL = 1.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n\n        ShapeHeadingLightR = ShapeHeadingSun + 0.125 + 0.25;\n        ShapeHeadingLightL = ShapeHeadingLightR + 0.25;        \n    }\n    else if ( TempHeading < 0.75 )\n    {\n        // Looking at lit side\n    \tShadeL = 1;\n    \tShadeM = 2;\n        ShadeR = 1;\n    \tColourBlendL = 2.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n        \n        ShapeHeadingLightR = ShapeHeadingSun + 0.125;\n        ShapeHeadingLightL = ShapeHeadingLightR + 0.25;        \n    }\n    else\n    {\n        // Sun on left\n    \tShadeL = 2;\n    \tShadeM = 1;\n        ShadeR = 0;\n    \tColourBlendL = 3.0f-(TempHeading * 4.0);\n        ColourBlendR = ColourBlendL + 1.0;\n\n        ShapeHeadingLightR = ShapeHeadingSun + 0.125 - 0.25;\n        ShapeHeadingLightL = ShapeHeadingLightR + 0.25;        \n\t}\n#endif\n    \n    // ColourBlend are currently just a linear -1...0...1 ramp\n    // which is not physically correct, so \"sineify\" them\n    float ColourDepthL = cos ( ColourBlendL * 3.1415927 * 0.5 );\n    float ColourDepthR = cos ( ColourBlendR * 3.1415927 * 0.5 );\n    ColourBlendL = sin ( ColourBlendL * 3.1415927 * 0.5 );\n    ColourBlendR = sin ( ColourBlendR * 3.1415927 * 0.5 );\n    \n    // Which widths in each slice are we looking at for each side of the shape?\n    float CamShapeHeading = fract(ShapeHeading-CamHeading);\n    float CamShapeHeadingL = fract(CamShapeHeading - 0.5);\n    float CamShapeHeadingR = fract(CamShapeHeading);\n    \n    ShapeHeadingLightL = fract(ShapeHeadingLightL);\n    ShapeHeadingLightR = fract(ShapeHeadingLightR);\n    \n    \n    \n    // We don't apply any perspective within the shape,\n    // just to its center, so we can immediately calculate the width & height of the ray from the current pixel.\n    // World-space position WorldPos.xyz will map to NDC:\n    // Ndc.xy = CamPos.xy / CamPos.z * tanFov;\n    // So if we assume WorldPos.z, we can reverse that to find the WorldPos.xy\n    float CamZ = CamCenterPos.z;\n    vec2 CamPixelPos = ndc * CamZ * tanFov;\n    vec2 ObjPos = CamPixelPos - CamCenterPos.xy;\n\n    vec3 ColourLeft  = vec3 ( 0.0, 0.0, 0.0 );\n    vec3 ColourMid   = ColourLeft;\n    vec3 ColourRight = ColourLeft;\n    \n    if ( CamZ > 0.0 )\n    {\n        // This would be done by scanline rendering, starting at the top one and scanning down using deltas.\n        // But obviously we have to do it strangely in a pixel shader.\n        float WidthL = 0.0;\n        float WidthR = 0.0;\n        float ColourWidthL = 0.0;\n        float ColourWidthR = 0.0;\n        if ( ObjPos.y > float(Shape[0]) )\n        {\n            // Off the top.\n        }\n        else\n        {\n            for ( int SliceNum = 0; SliceNum < ShapeSlices-1; SliceNum++ )\n            {\n                if ( ObjPos.y > Shape[SliceNum*ShapeSliceSize+ShapeSliceSize] )\n                {\n                    // This is the correct segment\n                    float ShapeY0    = Shape[SliceNum*ShapeSliceSize+0];\n                    float ShapeY1    = Shape[SliceNum*ShapeSliceSize+ShapeSliceSize];\n                    float ShapeShade = Shape[SliceNum*ShapeSliceSize+1];\n                    \n                    vec2 Shape0L = -CalculateSliceHeadingWidth ( SliceNum, CamShapeHeading - 0.5 );\n                    vec2 Shape0R =  CalculateSliceHeadingWidth ( SliceNum, CamShapeHeading );\n                    vec2 Shape1L = -CalculateSliceHeadingWidth ( SliceNum+1, CamShapeHeading - 0.5 );\n                    vec2 Shape1R =  CalculateSliceHeadingWidth ( SliceNum+1, CamShapeHeading );\n                    \n                    vec2 Light0L =  -CalculateSliceHeadingWidth ( SliceNum, ShapeHeadingLightL );\n                    vec2 Light0R =   CalculateSliceHeadingWidth ( SliceNum, ShapeHeadingLightR );\n                    vec2 Light1L =  -CalculateSliceHeadingWidth ( SliceNum+1, ShapeHeadingLightL );\n                    vec2 Light1R =   CalculateSliceHeadingWidth ( SliceNum+1, ShapeHeadingLightR );\n                    \n                    // Transform the (width,depth) pairs we got for\n                    // light intersections into horizontal offsets.\n                    // ColourDepthL is cos(angle), ColourBlendL is sin(angle)\n                    float LightOffset0L = -ColourDepthL * Light0L.y - ColourBlendL * Light0L.x;\n                    float LightOffset0R =  ColourDepthR * Light0R.y + ColourBlendR * Light0R.x;\n                    float LightOffset1L = -ColourDepthL * Light1L.y - ColourBlendL * Light1L.x;\n                    float LightOffset1R =  ColourDepthR * Light1R.y + ColourBlendR * Light1R.x;                   \n                    \n                    // Now lerp vertically.\n                    float HeightLerp = (ObjPos.y - ShapeY0)/(ShapeY1 - ShapeY0);\n                    \n                    WidthL = Shape0L.x + HeightLerp * ( Shape1L.x - Shape0L.x );\n                    WidthR = Shape0R.x + HeightLerp * ( Shape1R.x - Shape0R.x );\n                    ColourWidthL = LightOffset0L + HeightLerp * ( LightOffset1L - LightOffset0L );\n                    ColourWidthR = LightOffset0R + HeightLerp * ( LightOffset1R - LightOffset0R );\n\n                    // Right now the \"shade\" thing isn't implemented, except for \n                    // making stuff fully lit.\n                    if ( ShapeShade < -0.1 )\n                    {\n                        // Self-illuminated.\n                    \tColourLeft  = vec3(1.0,1.0,1.0);\n                        ColourMid   = vec3(1.0,1.0,1.0);\n                        ColourRight = vec3(1.0,1.0,1.0);\n                    }\n                    else\n                    {\n                        //ShapeShade *= SunBrightness;\n                        // This looks nicer...\n                        ShapeShade += 0.25*(SunBrightness-1.0);\n                        \n                        int ShadeShift = int(floor(5.0 * (1.0-ShapeShade)));\n#if SPECCY_REZ\n                        int DitherShade = 0 + DitherX*2;\n                        if ( DitherY == 0 )\n                        {\n                            DitherShade = 3 - DitherX*2;\n                        }\n                        \n                        vec3 ColourOn = vec3 ( 1.0, 1.0, 1.0 );\n                        vec3 ColourOff = vec3 ( 0.0, 0.0, 0.0 );\n\n                        ColourLeft  = ( ShadeL*2-ShadeShift > DitherShade ) ? ColourOn : ColourOff;\n                        ColourMid   = ( ShadeM*2-ShadeShift > DitherShade ) ? ColourOn : ColourOff;\n                        ColourRight = ( ShadeR*2-ShadeShift > DitherShade ) ? ColourOn : ColourOff;\n                        \n#else\n                        vec3 Colours[] = vec3[] (\n                            vec3(0.2,0.2,0.2),\n                            vec3(0.4,0.4,0.15),\n                            vec3(0.6,0.6,0.1),\n                            vec3(0.8,0.8,0.05),\n                            vec3(1.0,1.0,0.0)\n                        );\n                        \n                        ColourLeft  = Colours[max(0,ShadeL*2-ShadeShift)];\n                        ColourMid   = Colours[max(0,ShadeM*2-ShadeShift)];\n                        ColourRight = Colours[max(0,ShadeR*2-ShadeShift)];\n#endif\n                    }\n                    break;\n                }\n            }\n            if (( ObjPos.x>WidthL ) && ( ObjPos.x<WidthR ))\n            {\n#if TWO_SHADE\n                if ( ObjPos.x>(ColourWidthL) )\n                {\n                    col = ColourRight;\n                }\n                else\n                {\n                    col = ColourLeft;\n                }\n#else\n                if ( ObjPos.x>ColourWidthR )\n                {\n                    col = ColourRight;\n                }\n                else if ( ObjPos.x>ColourWidthL )\n                {\n                    col = ColourMid;\n                }\n                else\n                {\n                    col = ColourLeft;\n                }\n#endif               \n            }\n            #if DEBUG_MODE\n            else\n            {\n                if ( ( ObjPos.x > 0.0 ) && ( ObjPos.x<ColourWidthR ) )\n                {\n                    col = vec3(1.0,0.0,0.0);\n                }\n                else if ( ( ObjPos.x < 0.0 ) && ( ObjPos.x>ColourWidthL ) )\n                {\n                    col = col = vec3(0.0,1.0,0.0);\n                }                \n            }\n            #endif\n        }\n    }\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dcfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[6333, 6450, 6515, 6515, 7618], [7621, 7621, 7644, 7644, 7712]], "test": "error"}
{"id": "3ddBRM", "name": "Clubbing Hatifnats", "author": "daltostronic", "description": "just some funky hatifnat-like creatures chillin' to a nice tune in a club", "tags": ["sdf", "spheremarching", "hatifnats"], "likes": 11, "viewed": 322, "published": "Public API", "date": "1604659460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int Iterations = 25;\nfloat Epsilon = 0.01;\nfloat CameraAngle = 1.0;\nfloat HatiScale = 0.2;\n\nstruct Object\n{\n    float Distance;\n    int Iteration;\n    vec3 Color;\n    float MinDistance;\n};\n\nObject map(vec3 p);\n\nObject raytrace(vec3 camera, vec3 ray, int iterations, float threshold)\n{\n    vec3 p = camera;\n    Object obj;\n    float MinDistance = 1000000.0;\n    for (int i = 0; i < iterations; i++) {\n        obj = map(p);\n        obj.Iteration = i;\n        MinDistance = min(MinDistance, obj.Distance);\n        if (obj.Distance < threshold) break;\n        p += ray * obj.Distance;\n    }\n\n    obj.MinDistance = MinDistance;\n\n    return obj;\n}\n\nvec4 extractColor(Object obj, vec3 clearColor)\n{\n    float c = 1.0 - float(obj.Iteration) / 50.0;\n\n    return vec4(mix(clearColor, obj.Color, c), 1.0);\n}\n\nObject ellipsoid(in vec3 p, in vec3 r, vec3 color)\n{\n    Object result;\n    result.Color = color;\n    \n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    result.Distance = k0*(k0-1.0)/k1;\n\n    return result;\n}\n\nObject capsule(vec3 p, float h, float r, vec3 color)\n{\n    Object result;\n    result.Color = color;\n    \n    p.z -= clamp(p.z, 0.0, h);\n    result.Distance = length(p) - r;\n\n    return result;\n}\n\nObject plane(vec3 p, float h, vec3 color)\n{\n    Object result;\n    result.Color = color;\n    result.Distance = p.z - h;\n    return result;\n}\n\nvec3 repeat(vec3 p, vec3 c)\n{\n    return mod(p, c) - 0.5 * c;\n}\n\nfloat smin(float a, float b)\n{\n    float k = 8.;\n    float res = exp(-k*a) + exp(-k*b);\n    return -log(res) / k;\n}\n\nObject sum(Object a, Object b)\n{\n    if (a.Distance < b.Distance)\n        return a;\n    return b;\n}\n\nmat2 r2d(float a) {\n    float c = cos(a), s = sin(a);\n    return mat2(c,  s,\n                -s, c);\n}\n\nvec3 hsv(float H, float S, float V) {\n    vec3 c = vec3(H, S, V);\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nObject hatifnat(vec3 p, float h, vec3 color, float fftL)\n{\n    Object c = capsule(p, 1.0 * h, HatiScale, color);\n\n    p.y = abs(p.y);\n\n    Object e0 = ellipsoid(p - vec3(-0.2, 0.1, 1.0 * h + 0.45), vec3(0.05, 0.05, mix(0.1, 0.01, fftL)), vec3(1.0));\n    \n\tObject result = sum(c, e0);\n\treturn result;\n}\n\nObject map(vec3 p)\n{\n    float fftL = texture(iChannel0, vec2(0.1, 0.0)).r;\n    float fftM = texture(iChannel0, vec2(0.5, 0.0)).r;\n    float fftH = texture(iChannel0, vec2(0.9, 0.0)).r;\n    float pattern = 10.0 * sin(p.x * 0.0001 + fftL * 0.01 + iTime * 0.1);\n    float fftX = texture(iChannel0, vec2(pattern, 0.0) / 100.0).r;\n    \n\tvec3 rep = vec3(2.0, 2.0, 0.0);\n\t\n\tvec3 p0 = p;\n    p0.x += p.z * 0.25 * cos(p.z - iTime * 2.5 + p.x);\n    p0.y += p.z * 0.25 * sin(p.z - iTime * 2.5 + p.y);\n\tvec3 p1 = p;\n    p1.x += p.z * 0.25 * cos(p.z + iTime * 2.5 + p.x + 2.093);\n    p1.y += p.z * 0.25 * sin(p.z + iTime * 2.5 + p.y + 2.093);\n\tvec3 p2 = p;\n    p2.x += p.z * 0.25 * cos(p.z - iTime * 2.5 + p.x + 4.187);\n    p2.y += p.z * 0.25 * sin(p.z - iTime * 2.5 + p.y + 4.187);\n\tvec3 p3 = p;\n    p3.x += p.z * 0.25 * cos(p.z + iTime * 2.5);\n    p3.y += p.z * 0.25 * sin(p.z + iTime * 2.5);\n\n\tfloat h = fftX;\n\tfloat h1 = h + mix(1.0, 0.15, fftL);\n\tfloat h2 = h + mix(1.0, 0.15, fftM);\n\tfloat h3 = h + mix(1.0, 0.15, fftH);\n\t\n\tvec3 color = hsv(pattern, 0.5, 1.0);\n    Object c0 = hatifnat(repeat(p0, rep), h, color, fftL);\n    Object c1 = hatifnat(repeat(p1 - vec3(0.0, 1.0, 0.0), rep), h1, color, fftL);\n    Object c2 = hatifnat(repeat(p2 - vec3(1.0, 1.5, 0.0), rep), h2, color, fftL);\n    Object c3 = hatifnat(repeat(p3 - vec3(1.0, 0.5, 0.0), rep), h3, color, fftL);\n    Object hatifnats = sum(c0, sum(c1, sum(c2, c3)));\n    \n    Object plane = plane(p, 0.0, hsv(pattern, 0.5, 1.0));\n\t\n\tObject result = hatifnats;\n\tresult.Distance = smin(hatifnats.Distance, plane.Distance);\n\t\n    return result;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - .5;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\tvec3 camera = vec3(-5.0, 0.0, 6.0);\n\tcamera.xy *= r2d(sin(iTime * 0.5) * 0.5);\n\tcamera.x += iTime;\n\tvec3 ray = normalize(vec3(1.0, uv.x, uv.y));\n\tray.xz *= r2d(CameraAngle);\n\t\n\tObject result = raytrace(camera, ray, Iterations, Epsilon);\n\n\tfragColor = extractColor(result, vec3(0.0));\n}\n", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddBRM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[211, 211, 284, 284, 641], [643, 643, 691, 691, 796], [798, 798, 850, 850, 1020], [1022, 1022, 1076, 1076, 1216], [1218, 1218, 1261, 1261, 1358], [1360, 1360, 1389, 1389, 1423], [1425, 1425, 1455, 1455, 1540], [1542, 1542, 1574, 1574, 1641], [1643, 1643, 1662, 1662, 1745], [1747, 1747, 1784, 1784, 1981], [1983, 1983, 2041, 2041, 2284], [2286, 2286, 2306, 2306, 3876], [3878, 3878, 3933, 3933, 4308]], "test": "error"}
{"id": "3ddBz8", "name": "Wave Equation + Interferences", "author": "Dutracgi", "description": "Simple demonstration :) ", "tags": ["wave", "array", "physics", "phased"], "likes": 7, "viewed": 113, "published": "Public", "date": "1604352428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t//Coordenadas da tela (-1 a 1) - Screen Coords (-1 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x/iResolution.y;\n\n    //Fundo preto - Black backgound\n    vec3 col = vec3(0);\n    \n    //Comprimento de onda - Wavelength\n    float WL = 64.; \n    \n    //Posio do segundo gerador - Second Generator position\n    float a = 2.0;\n    \n     //Equao da onda - Wave Equation\n    \n    //(0,0) //Amplitude // Onda - Wave //Tempo - Time //Atenuao (quadrado da distancia) - Attenuation (distance squared)\n    float w0 = 1.0 * sin( length(uv*WL) -4.*iTime ) * 1.0-(length(uv)*length(uv));\n    \n    //(a,0) //Amplitude // Onda - Wave //Tempo - Time //Atenuao (quadrado da distancia) - Attenuation (distance squared)\n    float w1 = 1.0 * sin( length(vec2(a,0.)+uv*WL) -4.*iTime ) * 1.0-(length(uv)*length(uv));\n    \n    //(2a,0) //Amplitude // Onda - Wave //Tempo - Time //Atenuao (quadrado da distancia) - Attenuation (distance squared)\n    float w2 = 1.0 * sin( length(vec2(2.*a,0.)+uv*WL) -4.*iTime ) * 1.0-(length(uv)*length(uv));\n    \n    col = vec3(w0,0.0,0.0);  //Onda 0,0 Vermelho - Red Wave 0,0\n    col += vec3(0.0,w1,0.0);//Onda a,0 Verde - Green Wave a,0\n    col += vec3(0.0,0.0,w2);//Onda 2a,0 Azul - Blue Wave 2a,0\n    \n    //Branco = Interferencia - White = Interference\n    \n    //Descomente aqui pra ver a soma - Uncoment Here to see final result\n    //col = vec3((w0+w1+w2)/3.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 115, 1555]], "test": "valid"}
{"id": "3ddfWf", "name": "Wobbly Cloth", "author": "me_123", "description": "This Shader uses raymarching. it has defocus blur and antialiasing. ", "tags": ["raymarching"], "likes": 4, "viewed": 59, "published": "Public", "date": "1606151267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float max_steps = 100.;\nfloat e = 0.001;\nfloat max_dist = 100.;\nfloat sphere(in vec3 p, in float r) {\n    return length(p)-r;\n}\nfloat hash(vec2 p) {\n    p = 50.*fract(p*0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\nfloat cyl( vec3 p, float h, float r ) {\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat box( vec3 p, vec3 b )\n{\n  float br = 0.11;\n  b-=(br*1.);\n  vec3 q = abs(p) - b;\n  float bo = (length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0))-br;\n  bo += length(sin(p*10.))/200.;\n  return bo;\n}\nfloat Amin(float[25] m) {\n    float op = 10000.0;\n    for (int i = 0; i < 25; i += 1) {\n        op = min(op, m[i]);\n    }\n    return op;\n}\nvec3 rep( in vec3 p, in vec3 c)\n{\n    vec3 q = mod(p+0.5*c,c)-0.5*c;\n    float r = length(sin((p/2.)+iTime))+length(sin((p/10.)+(iTime/2.)));\n    float offset = r*((length(p)/10.)+0.1);\n    q.y = p.y+offset-0.5;;\n    return q;\n}\nfloat SDF(in vec3 p) {\n    vec3 sp = vec3(1.0, 2.0, 5.0);\n    float plain = p.y;\n    float objects[25];\n    float c = 1.0;\n    vec3 pp = rep(p, vec3(1.0));\n    objects[0] = box(pp, vec3(0.5, 0.5, 0.5));\n    objects[1] = sphere(p-vec3(0.0, 1.0, -3.0), 0.5);\n    return objects[0];\n}\n\nvec3 getNormal(vec3 p) {\n    float d = SDF(p);\n    vec2 e = vec2(.01, 0.0);\n    vec3 n = d-vec3(\n    \tSDF(p-e.xyy),\n    \tSDF(p-e.yxy),\n    \tSDF(p-e.yyx)\n    );\n    return normalize(n);\n}\nvec3 tex(vec3 p) {\n    vec3 c = vec3(\n    \tfloat(length(sin(p.xz*3.1)) > 0.7*((sin(iTime)+2.)/3.)),\n    \tfloat(length(sin(p.xz*6.2)) > 0.9*((sin(iTime/2.)+2.)/3.)),\n    \tfloat(length(sin(p.xz*9.3)) > 0.4*((sin(iTime/4.)+2.)/3.))\n    )\n        ;\n\treturn vec3(c);\n}\nvec4 ray(vec3 ro, vec3 rd) {\n    float d0 = 0.0;\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    float steps = 0.0; \n    vec3 c = vec3(0);\n    for (float i = 0.0; i < max_steps; i += 1.0) {\n        steps += 1.0;\n        vec3 p = roo + rdd*d0;\n        float ds = SDF(p);\n        d0 += ds;\n        if (ds<e||ds>max_dist) {\n            break;\n        };\n       \tc = p;\n    }\n    \n    return vec4(vec3(c), d0);\n}\nfloat samples = 5.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tfloat size = iResolution.x;\n    vec3 color = vec3(0.0);\n    \n    for (int i = 0; i < int(samples); i += 1) {\n    \tvec2 uv = ((fragCoord-.5*size)/size);\n        vec3 ro = vec3(0.0, 2.0, (sin(iTime/10.)*5.)-10.);\n        vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n     \tvec4 r = ray(ro, rd);\n        float d = r.w;\n        uv.x += (hash(uv+float(i))/(iResolution.x))*(d-10.);\n        uv.y += (hash(uv+float(i))/(iResolution.y))*(d-10.);\n        rd = normalize(vec3(uv.x, uv.y, 1.0));\n     \tr = ray(ro, rd);\n        d = r.w;\n        vec3 p = ro + rd*d;\n        vec3 norm = getNormal(p);\n        vec3 col = ((tex(r.xyz)+(dot(norm, normalize(vec3(-1. , 10., -1)))))/5.)/(length(p)/1.);\n        if (d >= max_dist) {\n            col = vec3(0);\n        }\n        col *= vec3(1.8, 1.8, 1.9);\n        color += clamp(sqrt(col)/1.5, 0.02, 0.9)-0.02;\n    }\n    fragColor = vec4((color/samples), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddfWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[64, 64, 101, 101, 127], [128, 128, 148, 148, 219], [220, 220, 259, 259, 366], [367, 367, 396, 396, 571], [711, 711, 744, 744, 939], [940, 940, 962, 962, 1221], [1223, 1223, 1247, 1247, 1409], [1410, 1410, 1428, 1428, 1673], [1674, 1674, 1702, 1702, 2076], [2098, 2098, 2155, 2155, 3047]], "test": "valid"}
{"id": "3ddfWX", "name": "sharingan_Itachi", "author": "Learner_CC", "description": "", "tags": ["2d", "3d", "noise", "raymarch"], "likes": 4, "viewed": 161, "published": "Public", "date": "1606140854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// sharingan_Itachi - by CC - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n// -------- const parameter -------- //\nconst float PI = 3.1415926;\n\n// -------- Transform -------- //\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\nmat2 scale(vec2 scale){\n    return mat2(scale.x, 0.0,\n                0.0, scale.y);\n}\n// -------- Basic graphic -------- //\nfloat circle( vec2 p, float r ){\n    return 1.0 - smoothstep(0.9* r, r,length(p) - r);\n}\n\nfloat ring( vec2 p, float r ){\n    return circle(p, r) - circle(p, r - 0.03);\n}\n\nfloat semicircle(vec2 p, float r) {\n    float pct = 1.0 - smoothstep(0.9 * r, r,length(p) - r); \n    pct *= step(0.0, p.y);\n    return pct;\n}\n\n// ---------------- //\nfloat gouYu(vec2 p, float progress) {\n    float pct = circle(p, 0.2 - 0.1 * progress);\n    pct += semicircle(p + vec2(-0.2 - 0.2 * progress, 0.0), 0.3);\n    pct -= semicircle(p + vec2(-0.6, 0.0), 0.15 + 0.05 * progress);   \n    return step(1.0, pct);\n}\n\nfloat eye(vec2 p, float gouyuState) {\n    float pct = circle(p, 0.5);   \n    \n    float scale = 3.0 - 2.0 * gouyuState;  // 3.0     1.0\n    float offsetScale = 1.5 - 1.4 * gouyuState; //1.5   0.2\n    \n    vec2 uv = scale * p;\n    \n    // ---- gouyu ---- //\n\n    vec2 offset = - offsetScale * vec2(cos(PI / 3.0), sin(PI / 3.0));\n    vec2 pTemp = rotate2d(PI) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);\n    pTemp = rotate2d(5.0 * PI / 3.0) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);   \n    pTemp = rotate2d(-5.0 * PI / 3.0) * uv + offset;\n    pct -= gouYu(pTemp, gouyuState);   \n    \n    // ---- ring ---- //\n    pct -= (1.0 - 4.0 * gouyuState) * circle(p, 0.06);\n    pct -= ring(p, 0.28) * (1.0 - gouyuState);\n    pct -= ring(p, 0.48);\n    \n    // ---- color ---- // \n    float opacity = 1.0 - length(p) * length(p) * length(p);\n    return pct * opacity;\n}\nfloat eyeSocket(vec2 uv, float height, float bottomPoint) {\n    float x = clamp(0.0, 1.0, 1.0 - uv.x);\n    float y = clamp(0.0, 1.0, uv.y);\n    float pct = 1.0;\n\n    float upborder = -height * (x * x * x - 1.0);\n    float bottomborder = height / (bottomPoint * bottomPoint) * (x - bottomPoint) * (x - bottomPoint);\n    bottomborder *= step(x, bottomPoint);\n    \n    pct *= smoothstep(0.96 * y, y, upborder) * step(0.0, x);\n    pct *= (1.0 - smoothstep(0.9 * y, y, bottomborder));\n    return pct;\n}\n\nvec4 sharingan(vec2 st, float openProcess, float mangekyoSharinganProgress, float t) {\n    \n    vec4 color = vec4(0.0);\n    float height = 0.55 * abs(mod(0.5 * iTime, 1.1) - 0.55);\n    height = 0.55 * openProcess;\n\n    float t1 = (clamp(t, 2.0, 8.0) - 2.0) / 6.0;\n    float x = sin(t1 * PI * 0.5);\n    x = x * x * x;\n    mat2 eyeRotate = rotate2d(-x * x * 16.0) * 1.0;\n    //eyeRotate = mat2(1.0, 0.0, 0.0, 1.0);\n    \n    vec2 eyeoffset = vec2(-1.5, -1.012);\n    float pct = eyeSocket(st, height, 0.28); \n    color += vec4(pct) - circle(3.6 * st  + eyeoffset, 0.5) * pct;  \n\n    pct *= eye((3.6 * st + eyeoffset) * eyeRotate, mangekyoSharinganProgress);\n  \n    color += vec4(pct) * vec4(1.0, 0.0, 0.0, 0.0);\n    //color += circle(3.6 * st  + eyeoffset, 0.08 * mangekyoSharinganProgress);\n\n    // ----  ---- //\n    float opacity = 0.2;\n    float t2 = clamp(t, 0.5, 1.5) - 0.5;\n    //t2 = 1.0;\n    float scale = clamp(.2 / t2, 0.3, 1.0);\n    opacity = (scale - 0.3) * 0.5  * step(1.0, openProcess);\n    pct = eye((3.6 * st + eyeoffset) * scale * eyeRotate, mangekyoSharinganProgress);\n    color += vec4(pct) * vec4(1.0, 0.0, 0.0, 0.0) * opacity;\n    \n    return color;\n}\n\n// -------- Background -------- //\n#define MIN_HEIGHT 2.0\n#define MAX_HEIGHT 4.5\n#define WIND vec2(-0.2, -0.0)\n\nconst vec3 skycolor = vec3(0.55, 0.0, 0.0);\nconst vec3 bgcolor = vec3(0.1, 0.0, 0.0);\n// ---- Noise ---- //\nvec2 random2(vec2 st) {\n    st = vec2(dot(st, vec2(127.1, 311.7)), dot(st, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(st) * 43758.5453123);\n}\n\nfloat perlin_noise(vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n    vec2 u = f * f * (3.0 - 2.0 * f);\n    return mix(\n        mix(\n            dot(random2(i + vec2(0.0)), f - vec2(0.0)),\n            dot(random2(i + vec2(1.0,0.0)), f - vec2(1.0, 0.0)),\n            u.x\n        ),\n        mix(            \n            dot(random2(i + vec2(0.0, 1.0)), f - vec2(0.0, 1.0)),\n            dot(random2(i + vec2(1.0,1.0)), f - vec2(1.0, 1.0)),\n            u.x\n        ),\n        u.y\n    );\n}\n\nfloat noise3D(vec3 x) {\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n    p.z += WIND.x * 10.0 * iTime;\n    vec2 uv = (p.xz + vec2(37.0, 17.0) * p.y) + f.xz;\n    return perlin_noise(uv);\n}\nfloat fbm(vec3 p)\n{\n    float f = 0.0;\n    p = p * 0.4;\n    f += noise3D(p); p = 2.0 * p;\n    f += 0.50000 * noise3D(p); p = 2.0 * p;\n\tf += 0.25000 * noise3D(p); p = 2.0 * p;\n\tf += 0.12500 * noise3D(p); p = 2.0 * p;\n\tf += 0.06250 * noise3D(p); p = 2.0 * p;\n    f += 0.03125 * noise3D(p);\n    \n    return f;\n}\n\nfloat density(vec3 pos) {\n    float den = 3.0 * fbm(pos * 0.3) - 2.0 + (pos.y - MIN_HEIGHT);\n    float edge = 1.0 - smoothstep(MIN_HEIGHT, MAX_HEIGHT, pos.y);\n    edge *= edge;\n    den *= edge;\n    den = clamp(den, 0.0, 1.0);\n    return den;\n}\nfloat planeIntersect( vec3 ro, vec3 rd, float plane)\n{\n    float h = plane - ro.y;\n    return h/rd.y;\n}\nvec3 raymarching(vec3 ro, vec3 rd, float t, vec3 backCol) {\n    vec4 sum = vec4(0.0);\n    vec3 pos = ro + rd * t;\n    for (int i = 0; i < 40; ++i) {\n        if (sum.a > 0.99 ||\n        pos.y < (MIN_HEIGHT - 1.0) ||\n        pos.y > (MAX_HEIGHT + 1.0)) break;\n\n        float den = density(pos);\n        if (den > 0.01) {\n            float dif = clamp((den - density(pos)) / 0.6, 0.0, 1.0);\n            vec3 lin = vec3(0.0);\n            vec4 col = vec4( mix( vec3(1.0,0.95,0.8)*1.1, vec3(0.35,0.4,0.45), den), den);\n            \n            col.rgb *= lin;\n            sum = sum + col*(1.0 - sum.a);    \n        }\n        t += max(0.05, 0.02 * t);\n       pos = ro + rd * t;\n\n       \n    }\n    sum = clamp(sum, 0.0, 1.0);\n    float h = rd.y;\n    sum.rgb = mix(sum.rgb, backCol, exp(-20.*h*h) );\n    return mix(backCol, sum.xyz, sum.a);\n}\nvec3 Tsukuyomi(vec2 uv) {\n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y - 0.1, 1.0));\n\n    float dist = planeIntersect(ro, rd, 3.0);\n\n    \n    vec3 color = mix(bgcolor, skycolor, uv.y * 0.5 + 0.5);\n\n    if (dist > 0.0) {\n        color = raymarching(ro, rd, dist, color);\n    }\n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float time = mod(iTime, 15.0);\n    \n    vec2 st = uv;\n    st.x *= iResolution.x / iResolution.y;\n    st = st * 2.0 - 1.0;\n    st *= 1.5;\n    st.x -= 1.2;\n    \n    float pct = 0.0;\n    vec4 color = vec4(0.0);\n    // -------- eye -------- //\n    float openProcess = clamp(time, 0.0, 0.5) * (12.0 - clamp(time, 11.5, 12.0)) * 4.0;\n    float sharinganProgress = (clamp(time, 4.0, 6.0) - 4.0) * 0.5;\n    color = sharingan(st - vec2(0.4, 0.0), openProcess, sharinganProgress, time);\n    st.x = -st.x;\n    color += sharingan(st - vec2(0.4, 0.0), openProcess, sharinganProgress, time);\n    \n\n    // -------- Bg -------- //\n    st = (2.0 * gl_FragCoord.xy - iResolution.xy) / iResolution.xy;\n    color += vec4(Tsukuyomi(st), 1.0) * ((clamp(2.0 * time, 1.0, 3.0) - 1.0) / 2.0);\n    // Output to screen\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3ddfWX.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[192, 226, 254, 254, 338], [339, 339, 362, 362, 425], [426, 464, 496, 496, 552], [554, 554, 584, 584, 633], [635, 635, 670, 670, 776], [778, 801, 838, 838, 1053], [1055, 1055, 1092, 1092, 1928], [1929, 1929, 1988, 1988, 2426], [2428, 2428, 2514, 2514, 3596], [3796, 3818, 3841, 3841, 3972], [3974, 3974, 4003, 4003, 4470], [4472, 4472, 4495, 4495, 4693], [4694, 4694, 4713, 4713, 5002], [5004, 5004, 5029, 5029, 5247], [5248, 5248, 5302, 5302, 5351], [5352, 5352, 5411, 5411, 6185], [6186, 6186, 6211, 6211, 6512], [6514, 6514, 6571, 6621, 7483]], "test": "valid"}
{"id": "3dGfRw", "name": "Nodevember_2020_day_30", "author": "lopoisaac", "description": "Nodevember 2020\nTheme: illusion\nTwitter >> @lopoisaac", "tags": ["nodevember"], "likes": 2, "viewed": 44, "published": "Public", "date": "1606754851", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Nodevember 2020 challenge\n// Day 30\n// Theme: pattern / illusion\n//\n// Twitter @lopoisaac\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    const float PI = 3.1416;\n    \n    vec2 waves, tiles;\n    float col, lines, slices; \n    \n    // 12 columns, 10 rows\n    tiles = vec2(12., 10.);\n    \n    // displace uvs horizontally\n    slices = floor(uv.y * tiles.y) / tiles.y;\n  \tuv.x += sin(slices * 7. + iTime * 0.2) * 0.03;\n\n    // make wave shapes\n    waves = sin(uv * tiles * PI);\n   \n    // white lines\n    lines = step(0.9, fract(uv.y * tiles.y));\n    \n    // mixing wave shapes and white lines\n    col = max(waves.x, lines);\n\t\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dGfRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[94, 94, 151, 151, 720]], "test": "valid"}
{"id": "3dKBzW", "name": "sphere(sphere,sphere,sphere)", "author": "ollj", "description": "read shader image description", "tags": ["spheres", "union", "hgsdf", "pipe"], "likes": 3, "viewed": 282, "published": "Public API", "date": "1606683182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//self https://www.shadertoy.com/view/3dKBzW\n\n//we distinguish sd-distanceFunctions from op-unionFunctions.\n//but actually, any distanceFunction can also be used as unionFunction\n\n/*\nyou see [a shere] move along the intersection of 3(!) moving spheres.\nIt is a spherical tripple union function.\nIt is just the sdSphere() function, applied recursively.\nwith its inputs being the distance to 3 different sphere output distances.\n, mixed into one [union spere]\nthis has worse lipschitz continuity, due to local (and therfore skewed)\ncoordinates no longer being carthesian, but not by much.\n\nthis oscillates between its last union being a sphere() or a box()\nthe box more easily shows the local coordinate system.\nthe sphere can be defined as the distance to 2 intersecting planes\n, to make one or multiple (by mod repetition of intersecting objects) \nstrands of hair.\nA 3rd distance to a sphere-head (distance scaled to have a lesser impacxt) \nmay set the thichness of the hairs.\n\n\ncommon union functions only take 2 inputs, rarely more.\nbecause most of them are non commutative.\nfOpPipe() is exactly the same as sdSphere(), but used as union.\nThis can extend into 3 or 4 (or more) dimensions easily.\n\nsame for other fOp* functions of hg_sdf:\nsame for any sd* functions\n, its parameters can be the distances to other shapes\n, and the result can look surprisingly useful.\n\nthe concept of hg_sdf functions like fOpPipe() \nand nearby union functions is underrated:\nhttps://mercury.sexy/hg_sdf/\n\nYou can use this to [[ make (rings on) hair without intersections ]]\nand other intersection avoiding CSG hierarchy\n, by intersecting (multiple parallel) orthogonal planes \n (in polar/distorted coordinates)\n\n*/\n\n//based on: https://www.shadertoy.com/view/Xds3zN\n// The MIT License\n// Copyright  2013 Inigo Quilez\n// Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A list of useful distance function to simple primitives. All\n// these functions (except for ellipsoid) return an exact\n// euclidean distance, meaning they produce a better SDF than\n// what you'd get if you were constructing them from boolean\n// operations.\n//\n// More info here:\n//\n// https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\n#if HW_PERFORMANCE==0\n#define AA 1\n#else\n#define AA 2   // make this 2 or 3 for antialiasing\n#endif\n\n//------------------------------------------------------------------\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdPlane( vec3 p ){return p.y;}\n\nfloat sdSphere( vec3 p, float s ){return length(p)-s;}\n\nfloat sdBox( vec3 p, vec3 b ){\n    vec3 d = abs(p) - b;\n    return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));\n}\n\nfloat sdBoundingBox( vec3 p, vec3 b, float e ){\n       p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\nfloat sdEllipsoid( in vec3 p, in vec3 r ) // approximated\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdTorus( vec3 p, vec2 t ){\n    return length( vec2(length(p.xz)-t.x,p.y) )-t.y;\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n    vec3 q = abs(p);\n\n    const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n    p = abs(p);\n    p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n    vec2 d = vec2(\n       length(p.xy - vec2(clamp(p.x, -k.z*h.x, k.z*h.x), h.x))*sign(p.y - h.x),\n       p.z-h.y );\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctogonPrism( in vec3 p, in float r, float h )\n{\n  const vec3 k = vec3(-0.9238795325,   // sqrt(2+sqrt(2))/2 \n                       0.3826834323,   // sqrt(2-sqrt(2))/2\n                       0.4142135623 ); // sqrt(2)-1 \n  // reflections\n  p = abs(p);\n  p.xy -= 2.0*min(dot(vec2( k.x,k.y),p.xy),0.0)*vec2( k.x,k.y);\n  p.xy -= 2.0*min(dot(vec2(-k.x,k.y),p.xy),0.0)*vec2(-k.x,k.y);\n  // polygon side\n  p.xy -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\n  vec2 d = vec2( length(p.xy)*sign(p.y), p.z-h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n\tvec3 pa = p-a, ba = b-a;\n\tfloat h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\treturn length( pa - ba*h ) - r;\n}\n\nfloat sdRoundCone( in vec3 p, in float r1, float r2, float h )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n    \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n        \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdRoundCone(vec3 p, vec3 a, vec3 b, float r1, float r2)\n{\n    // sampling independent computations (only depend on shape)\n    vec3  ba = b - a;\n    float l2 = dot(ba,ba);\n    float rr = r1 - r2;\n    float a2 = l2 - rr*rr;\n    float il2 = 1.0/l2;\n    \n    // sampling dependant computations\n    vec3 pa = p - a;\n    float y = dot(pa,ba);\n    float z = y - l2;\n    float x2 = dot2( pa*l2 - ba*y );\n    float y2 = y*y*l2;\n    float z2 = z*z*l2;\n\n    // single square root!\n    float k = sign(rr)*rr*rr*x2;\n    if( sign(z)*a2*z2 > k ) return  sqrt(x2 + z2)        *il2 - r2;\n    if( sign(y)*a2*y2 < k ) return  sqrt(x2 + y2)        *il2 - r1;\n                            return (sqrt(x2*a2*il2)+y*rr)*il2 - r1;\n}\n\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n    const float k = sqrt(3.0);\n    h.x *= 0.5*k;\n    p.xy /= h.x;\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p.xy=vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    float d1 = length(p.xy)*sign(-p.y)*h.x;\n    float d2 = abs(p.z)-h.y;\n    return length(max(vec2(d1,d2),0.0)) + min(max(d1,d2), 0.);\n}\n\n// vertical\nfloat sdCylinder( vec3 p, vec2 h )\n{\n    vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n// arbitrary orientation\nfloat sdCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 pa = p - a;\n    vec3 ba = b - a;\n    float baba = dot(ba,ba);\n    float paba = dot(pa,ba);\n\n    float x = length(pa*baba-ba*paba) - r*baba;\n    float y = abs(paba-baba*0.5)-baba*0.5;\n    float x2 = x*x;\n    float y2 = y*y*baba;\n    float d = (max(x,y)<0.0)?-min(x2,y2):(((x>0.0)?x2:0.0)+((y>0.0)?y2:0.0));\n    return sign(d)*sqrt(abs(d))/baba;\n}\n\n// vertical\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n    vec2 q = h*vec2(c.x,-c.y)/c.y;\n    vec2 w = vec2( length(p.xz), p.y );\n    \n\tvec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n    vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n    float k = sign( q.y );\n    float d = min(dot( a, a ),dot(b, b));\n    float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n\treturn sqrt(d)*sign(s);\n}\n\nfloat sdCappedCone( in vec3 p, in float h, in float r1, in float r2 )\n{\n    vec2 q = vec2( length(p.xz), p.y );\n    \n    vec2 k1 = vec2(r2,h);\n    vec2 k2 = vec2(r2-r1,2.0*h);\n    vec2 ca = vec2(q.x-min(q.x,(q.y < 0.0)?r1:r2), abs(q.y)-h);\n    vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n    float s = (cb.x < 0.0 && ca.y < 0.0) ? -1.0 : 1.0;\n    return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\n\nfloat sdCappedCone(vec3 p, vec3 a, vec3 b, float ra, float rb)\n{\n    float rba  = rb-ra;\n    float baba = dot(b-a,b-a);\n    float papa = dot(p-a,p-a);\n    float paba = dot(p-a,b-a)/baba;\n\n    float x = sqrt( papa - paba*paba*baba );\n\n    float cax = max(0.0,x-((paba<0.5)?ra:rb));\n    float cay = abs(paba-0.5)-0.5;\n\n    float k = rba*rba + baba;\n    float f = clamp( (rba*(x-ra)+paba*baba)/k, 0.0, 1.0 );\n\n    float cbx = x-ra - f*rba;\n    float cby = paba - f;\n    \n    float s = (cbx < 0.0 && cay < 0.0) ? -1.0 : 1.0;\n    \n    return s*sqrt( min(cax*cax + cay*cay*baba,\n                       cbx*cbx + cby*cby*baba) );\n}\n\n// c is the sin/cos of the desired cone angle\nfloat sdSolidAngle(vec3 pos, vec2 c, float ra)\n{\n    vec2 p = vec2( length(pos.xz), pos.y );\n    float l = length(p) - ra;\n\tfloat m = length(p - c*clamp(dot(p,c),0.0,ra) );\n    return max(l,m*sign(c.y*p.x-c.x*p.y));\n}\n\nfloat sdOctahedron(vec3 p, float s)\n{\n    p = abs(p);\n    float m = p.x + p.y + p.z - s;\n\n    // exact distance\n    #if 0\n    vec3 o = min(3.0*p - m, 0.0);\n    o = max(6.0*p - m*2.0 - o*3.0 + (o.x+o.y+o.z), 0.0);\n    return length(p - s*o/(o.x+o.y+o.z));\n    #endif\n    \n    // exact distance\n    #if 1\n \tvec3 q;\n         if( 3.0*p.x < m ) q = p.xyz;\n    else if( 3.0*p.y < m ) q = p.yzx;\n    else if( 3.0*p.z < m ) q = p.zxy;\n    else return m*0.57735027;\n    float k = clamp(0.5*(q.z-q.y+s),0.0,s); \n    return length(vec3(q.x,q.y-s+k,q.z-k)); \n    #endif\n    \n    // bound, not exact\n    #if 0\n\treturn m*0.57735027;\n    #endif\n}\n\nfloat sdPyramid( in vec3 p, in float h )\n{\n    float m2 = h*h + 0.25;\n    \n    // symmetry\n    p.xz = abs(p.xz);\n    p.xz = (p.z>p.x) ? p.zx : p.xz;\n    p.xz -= 0.5;\n\t\n    // project into face plane (2D)\n    vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n    float s = max(-q.x,0.0);\n    float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n    float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n\tfloat b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n    float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n    // recover 3D and scale, and add sign\n    return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));;\n}\n\n// la,lb=semi axis, h=height, ra=corner\nfloat sdRhombus(vec3 p, float la, float lb, float h, float ra)\n{\n    p = abs(p);\n    vec2 b = vec2(la,lb);\n    float f = clamp( (ndot(b,b-2.0*p.xz))/dot(b,b), -1.0, 1.0 );\n\tvec2 q = vec2(length(p.xz-0.5*b*vec2(1.0-f,1.0+f))*sign(p.x*b.y+p.z*b.x-b.x*b.y)-ra, p.y-h);\n    return min(max(q.x,q.y),0.0) + length(max(q,0.0));\n}\n\n//------------------------------------------------------------------\n\nvec2 opU(vec2 a,vec2 b){return(a.x<b.x)?a:b;}\n\n#define ZERO (min(iFrame,0))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nvec2 map( in vec3 pos\n){vec2 r = vec2( 1e10, 0.0 )\n ;vec3 d=vec3(0);\n ;d.x=sdSphere(pos-vec3(0,1,0)                            ,1.)\n ;d.y=sdSphere(pos-vec3(0,0,1)*cos(iTime                 ),1.)\n ;d.z=sdSphere(pos-vec3(1,0,0)*sin(iTime*(sqrt(5.)*.5+.5)),1.)\n  \n ;float i=\n     \n     mix(\n     sdBox(d,vec3(.2))  \n     ,\n     sdSphere(d,.2)  \n         ,\n         cos(iTime)*.5+.5\n        )\n     \n     //fOpPipe  (has bad lipschitz where normals are not perpendicular)\n    \n     \n ;//r=opU(r,vec2( d.x , 2.  ))\n ;//r=opU(r,vec2( d.y , 3.  ))\n ;//r=opU(r,vec2( d.z , 4.  ))\n ;r=opU(r,vec2( i , 2.  ))\n     \n ;return r\n        ;\n}\n   \n     \n     \n     \n\n\n\n\n\n\n\n// http://iquilezles.org/www/articles/boxfunctions/boxfunctions.htm\nvec2 iBox( in vec3 ro, in vec3 rd, in vec3 rad ) \n{\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n\treturn vec2( max( max( t1.x, t1.y ), t1.z ),\n\t             min( min( t2.x, t2.y ), t2.z ) );\n}\n\nvec2 raycast( in vec3 ro, in vec3 rd\n){\n    vec2 res = vec2(-1.0,-1.0);\n\n    float tmin = 1.0;\n    float tmax = 20.0;\n\n    // raytrace floor plane\n    float tp1 = (0.0-ro.y)/rd.y;\n    if( tp1>0.0 ){\n        tmax = min( tmax, tp1 );\n        res = vec2( tp1, 1.0 );}\n    //else return res;\n    \n    \n    // raymarch primitives   \n    vec2 tb = iBox( ro-vec3(0.0,0.4,-0.5), rd, vec3(2.5,0.41,3.0) );\n    \n    \n    if(true //tb.x<tb.y && tb.y>0.0 && tb.x<tmax\n      \n      )    {\n        //return vec2(tb.x,2.0);\n        //tmin = max(tb.x,tmin);\n        //tmax = min(tb.y,tmax);\n\n        float t = tmin;\n        for( int i=0; i<270 && t<tmax; i++ )\n        {\n            vec2 h = map( ro+rd*t );\n            if( abs(h.x)<(0.001*t) )\n            { \n                res = vec2(t,h.y); \n                break;\n            }\n            t += h.x*.5;\n        }\n    }\n    \n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftshadow( in vec3 ro, in vec3 rd, in float mint, in float tmax )\n{\n    // bounding volume\n    float tp = (0.8-ro.y)/rd.y; if( tp>0.0 ) tmax = min( tmax, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=ZERO; i<24; i++ )\n    {\n\t\tfloat h = map( ro + rd*t ).x;\n        float s = clamp(8.0*h/t,0.0,1.0);\n        res = min( res, s*s*(3.0-2.0*s) );\n        t += clamp( h, 0.02, 0.2 );\n        if( res<0.004 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*map( pos + e.xyy ).x + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ).x + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ).x + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ).x );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.0005*e).x;\n      //if( n.x+n.y+n.z>100.0 ) break;\n    }\n    return normalize(n);\n#endif    \n}\n\nfloat calcAO( in vec3 pos, in vec3 nor )\n{\n\tfloat occ = 0.0;\n    float sca = 1.0;\n    for( int i=ZERO; i<5; i++ )\n    {\n        float h = 0.01 + 0.12*float(i)/4.0;\n        float d = map( pos + h*nor ).x;\n        occ += (h-d)*sca;\n        sca *= 0.95;\n        if( occ>0.35 ) break;\n    }\n    return clamp( 1.0 - 3.0*occ, 0.0, 1.0 ) * (0.5+0.5*nor.y);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat checkersGradBox( in vec2 p, in vec2 dpdx, in vec2 dpdy )\n{\n    // filter kernel\n    vec2 w = abs(dpdx)+abs(dpdy) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;                  \n}\n\nvec3 render( in vec3 ro, in vec3 rd, in vec3 rdx, in vec3 rdy )\n{ \n    // background\n    vec3 col = vec3(0.7, 0.7, 0.9) - max(rd.y,0.0)*0.3;\n    \n    // raycast scene\n    vec2 res = raycast(ro,rd);\n    float t = res.x;\n\tfloat m = res.y;\n    if( m>-0.5 ) {\n        vec3 pos = ro + t*rd;\n        vec3 nor = (m<1.5) ? vec3(0.0,1.0,0.0) : calcNormal( pos );\n        vec3 ref = reflect( rd, nor );\n        \n        // material        \n        col = 0.2 + 0.2*sin( m*2.0 + vec3(0.0,1.0,2.0) );\n        float ks = 1.0;\n        \n        if( m<1.5 )\n        {\n            // project pixel footprint into the plane\n            vec3 dpdx = ro.y*(rd/rd.y-rdx/rdx.y);\n            vec3 dpdy = ro.y*(rd/rd.y-rdy/rdy.y);\n\n            float f = checkersGradBox( 3.0*pos.xz, 3.0*dpdx.xz, 3.0*dpdy.xz );\n            col = 0.15 + f*vec3(0.05);\n            ks = 0.4;\n        }\n\n        // lighting\n        float occ = calcAO( pos, nor );\n        \n\t\tvec3 lin = vec3(0.0);\n\n        // sun\n        {\n            vec3  lig = normalize( vec3(-0.5, 0.4, -0.6) );\n            vec3  hal = normalize( lig-rd );\n            float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n          //if( dif>0.0001 )\n        \t      dif *= calcSoftshadow( pos, lig, 0.02, 2.5 );\n\t\t\tfloat spe = pow( clamp( dot( nor, hal ), 0.0, 1.0 ),16.0);\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0-dot(hal,lig),0.0,1.0),5.0);\n            lin += col*2.20*dif*vec3(1.30,1.00,0.70);\n            lin +=     5.00*spe*vec3(1.30,1.00,0.70)*ks;\n        }\n        // sky\n        {\n            float dif = sqrt(clamp( 0.5+0.5*nor.y, 0.0, 1.0 ));\n                  dif *= occ;\n            float spe = smoothstep( -0.2, 0.2, ref.y );\n                  spe *= dif;\n                  spe *= 0.04+0.96*pow(clamp(1.0+dot(nor,rd),0.0,1.0), 5.0 );\n          //if( spe>0.001 )\n                  spe *= calcSoftshadow( pos, ref, 0.02, 2.5 );\n            lin += col*0.60*dif*vec3(0.40,0.60,1.15);\n            lin +=     2.00*spe*vec3(0.40,0.60,1.30)*ks;\n        }\n        // back\n        {\n        \tfloat dif = clamp( dot( nor, normalize(vec3(0.5,0.0,0.6))), 0.0, 1.0 )*clamp( 1.0-pos.y,0.0,1.0);\n                  dif *= occ;\n        \tlin += col*0.55*dif*vec3(0.25,0.25,0.25);\n        }\n        // sss\n        {\n            float dif = pow(clamp(1.0+dot(nor,rd),0.0,1.0),2.0);\n                  dif *= occ;\n        \tlin += col*0.25*dif*vec3(1.00,1.00,1.00);\n        }\n        \n\t\tcol = lin;\n\n        col = mix( col, vec3(0.7,0.7,0.9), 1.0-exp( -0.0001*t*t*t ) );\n    }\n\n\treturn vec3( clamp(col,0.0,1.0) );\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv =          ( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 mo = iMouse.xy/iResolution.xy;\n\tfloat time = 32.0 + iTime*1.5;\n\n    // camera\t\n    vec3 ta = vec3( 0.5, -0.5, -0.6 );\n    vec3 ro = ta + vec3( 4.5*cos(0.1*time + 7.0*mo.x), 1.3 + 2.0*mo.y, 4.5*sin(0.1*time + 7.0*mo.x) );\n    // camera-to-world transformation\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    vec3 tot = vec3(0.0);\n#if AA>1\n    for( int m=ZERO; m<AA; m++ )\n    for( int n=ZERO; n<AA; n++ )\n    {\n        // pixel coordinates\n        vec2 o = vec2(float(m),float(n)) / float(AA) - 0.5;\n        vec2 p = (2.0*(fragCoord+o)-iResolution.xy)/iResolution.y;\n#else    \n        vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n#endif\n\n        // ray direction\n        vec3 rd = ca * normalize( vec3(p,2.5) );\n\n         // ray differentials\n        vec2 px = (2.0*(fragCoord+vec2(1.0,0.0))-iResolution.xy)/iResolution.y;\n        vec2 py = (2.0*(fragCoord+vec2(0.0,1.0))-iResolution.xy)/iResolution.y;\n        vec3 rdx = ca * normalize( vec3(px,2.5) );\n        vec3 rdy = ca * normalize( vec3(py,2.5) );\n        \n        // render\t\n        vec3 col = render( ro, rd, rdx, rdy );\n\n        // gain\n        // col = col*3.0/(2.5+col);\n        \n\t\t// gamma\n        col = pow( col, vec3(0.4545) );\n\n        tot += col;\n#if AA>1\n    }\n    tot /= float(AA*AA);\n#endif\n    \n    fragColor = vec4( tot, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dKBzW.jpg", "access": "shaders20k", "license": "mit", "functions": [[3290, 3359, 3384, 3384, 3403], [3404, 3404, 3429, 3429, 3448], [3449, 3449, 3485, 3485, 3513], [3515, 3515, 3539, 3539, 3551], [3553, 3553, 3587, 3587, 3607], [3609, 3609, 3639, 3639, 3730], [3732, 3732, 3779, 3779, 4067], [4068, 4068, 4127, 4127, 4216], [4218, 4218, 4250, 4250, 4305], [4307, 4307, 4377, 4377, 4517], [4519, 4519, 4555, 4555, 4866], [4868, 4868, 4924, 4924, 5426], [5428, 5428, 5480, 5480, 5594], [5596, 5596, 5660, 5660, 5938], [5940, 5940, 6003, 6067, 6654], [6656, 6656, 6692, 6692, 7042], [7044, 7056, 7092, 7092, 7195], [7197, 7222, 7273, 7273, 7628], [7630, 7642, 7689, 7689, 8034], [8036, 8036, 8107, 8107, 8445], [8447, 8447, 8511, 8511, 9071], [9073, 9119, 9167, 9167, 9336], [9338, 9338, 9375, 9375, 9969], [9971, 9971, 10013, 10013, 10613], [10615, 10655, 10719, 10719, 10977], [11049, 11049, 11073, 11073, 11094], [11139, 11139, 11163, 11163, 11765], [11795, 11863, 11914, 11914, 12119], [12121, 12121, 12160, 12160, 13001], [13003, 13065, 13143, 13166, 13553], [13555, 13619, 13651, 13651, 14221], [14223, 14223, 14265, 14265, 14574], [14576, 14652, 14716, 14737, 14970], [14972, 14972, 15037, 15056, 17532], [17534, 17534, 17586, 17586, 17763]], "test": "valid"}
{"id": "3dtBDf", "name": "Raymarched trees", "author": "me_123", "description": "In this shader, i am trying to get a nice outdoor lighting and sky. It has specular lighting and colored SDF's.\nsome of the distance functions are from https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm.", "tags": ["raymarching"], "likes": 1, "viewed": 50, "published": "Public", "date": "1606151849", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float max_steps = 1000.;\nfloat max_dist = 1000.;\nfloat e = 1e-3;\nfloat camSize = 40.;\nvec3 lightPos = vec3(10., 20, 10.);\nfloat cyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cc( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );\n}\nfloat mandel(vec3 p) {\n    vec3 z = p;\n    float dr = 1.;\n    float r = 0.0;\n    float power = 3.;\n    for (int i = 0; i < 100; i ++) {\n        r = length(z);\n        if (r > 2.0) {\n            break;\n        }\n        float thata = acos(z.z/r) * power;\n        float phi = atan(z.y, z.x) * power;\n        float zr = pow(r, power);\n        dr = pow(r, power-1.) * power * dr + 1.;\n        z = zr * vec3(sin(thata) * cos(phi), sin(phi) * sin(thata), cos(thata));\n    \tz += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nvec3 rep( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\nvec4 uni(vec4 a, vec4 b) {\n\treturn a.w < b.w? a : b;\n}\nvec4 difr(vec4 a, vec4 b) {\n\treturn a.w > b.w? a : b;\n}\nvec4 suni(vec4 a, vec4 b, float k) {\n\tfloat h = clamp( 0.5 + 0.5*(a.w-b.w)/k, 0.0, 1.0 );\n    vec3 c = mix(a.rgb, b.rgb, h);\n    float d = mix( a.w, b.w, h) - k*h*(1.-h); \n    return vec4(c, d);\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nmat2 rot(float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat hash(vec2 p) {\n    p = 50.*fract(p*0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\n\nvec3 mushromStep(vec3 p) {\n    float val = clamp(abs(dot(sin(p*5.), sin(p*2.1)))/2., 0.3, 0.4);\n    return vec3(val/1., val/2., 0.0);\n}\nfloat nois(vec3 p) {\n    float ou = sin(p.x/3.);\n    ou += sin(p.z/2.);\n\treturn ou/10.;\n}\nvec4 SDF(vec3 p) {\n    p = rep(p, 20., vec3(10., 0.0, 10.));\n    vec3 pp = rep(p, 1., vec3(100));\n    float disp = min(sphere(pp, 1.0), box(pp, vec3(1.)))+length(sin(p*5.)/3.);\n    float shape1 = p.y-nois(p);\n    vec4 shape2 = vec4(mushromStep(p), mix(cyl(p, 0.3, 7.)-0.5, disp, 0.1));\n    float c = cc(rep(p-vec3(0, 4, 0), 2.0, vec3(0, 1.0, 0)), 1.0, 4.0, 2.5);\n    vec4 shape3 = vec4(vec3(0, 1, 0), c);\n    vec4 shape4 = vec4(vec3(0, 1.0, 0.0), cc((p-vec3(0, 9.5, 0)), 2.0, 3.0, 0.0));\n    vec4 o = suni(suni(suni(shape2, shape3, 2.0), shape4, 1.0), vec4(vec3(0.25, 0.125, 0.0), mix(p.y,disp, 0.1)+7.), 1.0);\n    \n    return o;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = SDF(ro + rd*t).w/64.;\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\nvec2 getDist(vec3 ro, vec3 rd, out vec3 color) {\n    float d0 = 0.001;\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    float steps = 0.0; \n    vec3 c = vec3(0);\n    for (float i = 0.0; i < max_steps; i += 1.0) {\n        steps += 1.0;\n        vec3 p = roo + rdd*d0;\n        vec4 r = SDF(p);\n        float ds = r.w;\n        d0 += ds;\n        if (ds<e||ds>max_dist) {\n       \t\tc = r.xyz;\n            break;\n        };\n    }\n    color = c;\n    return vec2(d0, steps);\n}\nvec3 getNormal(vec3 p) {\n    float d = SDF(p).w;\n    vec2 e = vec2(.0001, 0);\n    vec3 n = d-vec3(\n    \tSDF(p-e.xyy).w,\n    \tSDF(p-e.yxy).w,\n    \tSDF(p-e.yyx).w\n    );\n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 lightPos, vec3 rd, vec3 ro, vec2 ray, vec3 color) {\n    vec3 lp = normalize(lightPos-p);\n    vec3 norm = getNormal(p);\n    float sha1 = softshadow( p+0.001*norm, lightPos, 2.0 );\n    float l = length(p-lightPos)-1.0;\n    float dif = dot(norm, lp)/clamp(l/1., 1., 100.0)*6.;\n    float reflected = 0.0;//clamp(float((dot(reflect(rd, norm), lightPos)) - 10.0), 0.0, 1.0);\n    dif = (dif+(reflected/(l/0.5)));\n    if (ray.x < max_dist) {\n        dif += clamp(min(ray.y/255., 0.5), 0.0, 0.25);\n        dif += 0.4;\n    }\n    dif /= 1.;\n    dif += sha1;\n    return (reflected/10. + color+clamp(ray.y/40., 0.0, 0.3))*vec3(clamp(dif, 0.0, 1.0))*vec3(2.0, 2.0, 2.0);\n}\nfloat samples = 1.;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 mouse = ((iMouse.xy-.5*iResolution.xy)/iResolution.xy)*5.;\n    mouse.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(sin(iTime)*camSize, (0.5)*camSize, cos((iTime+5.5)/5.)*camSize);\n    for (int i = 0; i < int(samples); i += 1) {\n        vec2 uv = ((fragCoord-.5*iResolution.xy)/iResolution.xy);\n        uv.x *= iResolution.x/iResolution.y;\n        uv.x += (hash(uv+float(i))-0.5)/(iResolution.y/2.);\n        uv.y += (hash(uv+1.+float(i))-0.5)/(iResolution.x/2.);\n        vec3 at = vec3(0, 10, 0);\n        vec3 c_z = normalize(at-ro);\n        vec3 c_x = normalize(cross(vec3(0,1,0), c_z));\n        vec3 c_y = cross(c_z, c_x);\n        vec3 rd = normalize(uv.x * c_x + uv.y * c_y + 1.73 * c_z);\n        vec3 color = vec3(0);\n        vec2 ray = getDist(ro, rd, color);\n        float dist = ray.x;\n        vec3 p = ro+rd*dist;\n        vec3 light = getLight(p, lightPos, rd, ro, ray, color);\n        vec3 ocol = (light);\n        if (dist < max_dist) {\n        \tocol += sqrt(ocol)/5.;\n            ocol /= 1.25+clamp(ray.y/50., 0.1, 1.0);\n        } else {\n        }\n        float val = abs(clamp(rd.y, 0.1, 1.0)+1.0)*0.9;\n        ocol = mix(ocol, vec3(val/1.5, val/1.5, val), clamp(dist/200., 0.0, 1.0));\n        col += ocol;\n    }\n    fragColor = vec4(col/samples,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtBDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[122, 122, 161, 161, 268], [269, 269, 318, 318, 640], [641, 641, 663, 663, 1157], [1159, 1159, 1204, 1204, 1261], [1263, 1263, 1289, 1289, 1317], [1318, 1318, 1345, 1345, 1373], [1374, 1374, 1410, 1410, 1570], [1572, 1572, 1615, 1615, 1715], [1717, 1717, 1760, 1760, 1860], [1862, 1862, 1881, 1881, 1951], [1952, 1952, 1981, 1981, 2046], [2047, 2047, 2080, 2080, 2104], [2105, 2105, 2134, 2134, 2221], [2222, 2222, 2242, 2242, 2313], [2315, 2315, 2341, 2341, 2450], [2451, 2451, 2471, 2471, 2540], [2541, 2541, 2559, 2559, 3172], [3173, 3173, 3229, 3229, 3505], [3506, 3506, 3554, 3554, 3965], [3966, 3966, 3990, 3990, 4160], [4162, 4162, 4240, 4240, 4847], [4868, 4868, 4925, 4925, 6229]], "test": "valid"}
{"id": "3dtBRj", "name": "hoeled_cube_points_3d", "author": "hoeled", "description": "Cube points and camera in 3d space from https://www.youtube.com/watch?v=PBxuVlp7nuM\n", "tags": ["colors"], "likes": 2, "viewed": 76, "published": "Public", "date": "1605561869", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 ro, vec3 rd, vec3 p) {\n    return length(cross(p-ro, rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p) {\n    float d = DistLine(ro, rd, p);   \n    float t = iTime;\n    d = smoothstep(7., 1., d);\n  \treturn d;\n}\n\nfloat DrawCubes(vec3 ro, vec3 rd) {\n\tfloat d = 0.;\n    \n    for (int i = 1; i < 40; i++) {\n        float pos = .1 * float(i);\n    \td += DrawPoint(ro, rd, vec3(-pos, -pos, -pos));\n    \td += DrawPoint(ro, rd, vec3(-pos, -pos, pos));\n    \td += DrawPoint(ro, rd, vec3(-pos, pos, -pos));\n    \td += DrawPoint(ro, rd, vec3(-pos, pos, pos));\n    \td += DrawPoint(ro, rd, vec3(pos, -pos, -pos));\n    \td += DrawPoint(ro, rd, vec3(pos, -pos, pos));\n    \td += DrawPoint(ro, rd, vec3(pos, pos, -pos));\n    \td += DrawPoint(ro, rd, vec3(pos, pos, pos));\n        \n        //middle\n        d += DrawPoint(ro, rd, vec3(0., 0., 0.));\n    }    \n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    \n    float mouseX = iMouse.x / iResolution.x;\n    float mouseY = iMouse.y / iResolution.y;\n    \n    vec2 uv = fragCoord.xy/iResolution.xy; // 0 -> 1\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n    uv *= 1.7;\n    \n    //camera\n    vec3 ro = vec3(12, 3. * sin(t), 3. * -cos(t));\n    //vec3 ro = vec3(5., 0.5, -3.5);\n    vec3 lookat = vec3(0.);\n    float zoom = .3;\n    \n    vec3 f = normalize(lookat-ro);\n    vec3 r = cross(vec3(0., 1., 0.), f);\n    vec3 u = cross(f, r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c + uv.x*r + uv.y*u;\n    vec3 rd = i-ro;\n        \n    float d = DrawCubes(ro, rd) * cos(t) / 10.;\n    \n    float red = d * t / 10000. + sin(d * 2.) + cos(t);\n    float blue = sin(d) * 30. * cos(t) + cos(t);\n    float green = d / 20. - sin(d);\n    fragColor = vec4(red, green, blue, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 91], [93, 93, 136, 136, 241], [243, 243, 278, 278, 882], [884, 884, 941, 941, 1781]], "test": "valid"}
{"id": "3dtBWB", "name": "simple sin wave", "author": "biboulette59", "description": "simple sin wave ", "tags": ["sinwave"], "likes": 0, "viewed": 59, "published": "Public", "date": "1605893874", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tfloat speed = iTime/-8.;\n    float sinWave = sin((uv.x+speed)*3.14159*5.)/5.+.5;\n    vec2 sinCoordinate = vec2(uv.x,sinWave);\n    float pct = distance(uv,sinCoordinate);\n    pct = smoothstep(0.01,0.,pct);\n    vec3 color = vec3(pct)*vec3(0.006,0.172,0.990);\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtBWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 464]], "test": "valid"}
{"id": "3dtfDr", "name": "Folie Ocean", "author": "liamegan", "description": "Experimenting with 3tap 1-dimensional tiling.", "tags": ["ocean", "tiling", "3tap"], "likes": 6, "viewed": 260, "published": "Public API", "date": "1604860247", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 getScreenSpace(vec2 co, vec2 res) {\n    vec2 uv = (co - 0.5 * res) / min(res.y, res.x);\n\n    return uv;\n}\n\nvec3 randcol(float i) {\n    i = fract(i/4.);\n    if(i < .25) {\n      return vec3(0,0,.5);\n    } else if(i < .5) {\n      return vec3(0,.2,.5);\n    } else if(i < .75) {\n      return vec3(0,.1,.4);\n    } else {\n      return vec3(0,.3,.6);\n    }\n}\n\nvec2 hash12(float i) {\n    return texture(iChannel0, vec2(i/126., 0.), -10.).xy*.6+.01;\n}\n\n#define PI 3.14159265359\n\nfloat t = 0.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = getScreenSpace(fragCoord, iResolution.xy);\n    \n    t = iTime - 1000.;\n    \n    uv.y += sin(t*.2);\n    \n    uv *= 15. + cos(t*.2)*5.;\n    \n    vec2 guv = vec2(uv.x, fract(uv.y));\n    float id = floor(uv.y);\n    \n    vec3 col = vec3(1);\n    \n    for(float i = -2.; i < 1.; i++) {\n      vec2 suv = guv + vec2(0., i);\n      vec2 suv1 = guv + vec2(0., i-1.);\n      \n      float sid = id - i;\n      float sid1 = id - i - 1.;\n      \n      vec2 hash = hash12(sid);\n      vec2 hash1 = hash12(sid1);\n      \n      vec2 p = suv - vec2(t*hash1.x, 0.);\n      \n      suv.x += t*10.*(hash.x*hash.x);\n      suv1.x += t*10.*(hash1.x*hash1.x);\n      \n      float wave = sin(suv.x + sid) + cos(suv.x * hash.y) * (hash.y*10.);\n      float wave1 = sin(suv1.x + sid1) + cos(suv1.x * hash1.y) * (hash1.y*10.);\n      \n      p = vec2(length(p*.02), ((p.y) + wave * .1));\n      \n      float sfield = (suv.y + wave * .1);\n      float sfield1 = (suv.y + wave1 * .1);\n      \n      float mask = smoothstep(.5, -.2, sfield);\n      \n      // vec4 tex = texture(iChannel1, p, -10.);\n      vec4 tex = vec4(abs(sin(p.y*20.*length(hash)) + cos(p.x * 5. * hash1.y))*.3+.5);\n      \n      col = mix(col, (randcol(sid)+.2) * tex.gbr * (suv.y * .5 + .3 + smoothstep(-1., -.3, sfield1)), mask);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}, {"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 110], [112, 112, 135, 135, 355], [357, 357, 379, 379, 446], [489, 489, 546, 546, 1853]], "test": "error"}
{"id": "3dtfRr", "name": "Doodling with Bubblyfish", "author": "Flopine", "description": "Shader made for Bubblyfish's set during an online concert in September: Chipfest Cyberspace 5 \nYou can watch the record here: https://www.twitch.tv/videos/753627520\nCheck out the awesome talent of Bubblyfish here <3 https://bubblyfish.bandcamp.com/", "tags": ["3d", "raymarching", "isometric", "audioreactive", "vj", "twitch"], "likes": 14, "viewed": 201, "published": "Public", "date": "1604233985", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Code by Flopine\n\n// Thanks to wsmind, leon, XT95, lsdlive, lamogui, \n// Coyhot, Alkama,YX, NuSan and slerpy for teaching me\n\n// Thanks LJ for giving me the spark :3\n\n// Thanks to the Cookie Collective, which build a cozy and safe environment for me \n// and other to sprout :)  https://twitter.com/CookieDemoparty\n\n\n// Check out the awesome talent of Bubblyfish here <3 \n// https://bubblyfish.bandcamp.com/\n\n#define PI acos(-1.)\n#define TAU 6.283185\n#define rot(a) mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define time iTime\n#define dt(speed, offset) fract(time*speed+offset)\n#define swa(speed) floor(sin(dt(speed,0.)*TAU)+1.)\n#define bouncy(speed, offset) sqrt(sin(dt(speed,offset)*PI)) \n\n#define od(pos,d) (dot(pos,normalize(sign(pos)))-d)\n#define cyl(pos,r,h) max(length(pos.xy)-r,abs(pos.z)-h)\n\nvoid mo(inout vec2 p, vec2 d)\n{\n    p = abs(p)-d;\n    if(p.y>p.x) p = p.yx;\n}\n\nfloat box (vec3 p, vec3 c)\n{\n    vec3 q = abs(p)-c;\n    return min(0.,max(q.x,max(q.y,q.z)))+length(max(q,0.));\n}\n\nfloat sc (vec3 p, float d)\n{\n    p = abs(p);\n    p = max(p,p.yzx);\n    return min(p.x,min(p.y,p.z))-d;\n}\n\nfloat g1 = 0.;\nfloat SDF (vec3 p)\n{\n    p.yz *= rot(-atan(1./sqrt(2.)));\n    p.xz *= rot(PI/4.);\n    vec3 still = p;\n\n    p.z += time;  \n    vec3 forward = p;\n\n    float perz = 0.5;\n    float id = floor(p.z/perz);\n    p.y = abs(p.y)-2.; p.x = abs(p.x)-5.; p.z = mod(p.z,perz)-perz*0.5;\n    float sy = .5+texture(iChannel0,vec2(id*0.002,0.25)).r;\n    float d = box(p,vec3(0.1,sy,0.1));  \n\n    p.x -= 2.; p.x += sin(id+dt(0.2,0.)*TAU)*0.2;\n    d = min(d,od(p,0.1));\n\n    p = still;\n    p.x = abs(p.x)-(1.+sin(p.z*0.5+dt(.5,0.)*TAU)*0.5); p.y += sin(p.z+dt(0.25,1.)*TAU)*0.2;\n    d = min(d, cyl(p, 0.1,1e10));\n\n    p = still;\n    mo(p.yz, vec2(0.5));\n    p.y -= bouncy(0.2,0.); p.xz *= rot(dt(0.5,0.)*PI);    \n    d = min(d,max(-sc(p,0.22),box(p,vec3(0.3))));\n\n    float obj2 = od(p,0.05);\n    g1 += 0.01/(0.01+obj2*obj2);\n    d = min(d,obj2);\n\n    return d;\n}\n\nvec3 getnorm (vec3 p)\n{\n    vec2 eps = vec2(0.01,0.);\n    return normalize(SDF(p)-vec3(SDF(p-eps.xyy),SDF(p-eps.yxy),SDF(p-eps.yyx)));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy/iResolution.xy;\n    vec2 center_uv = (2.*fragCoord.xy-iResolution.xy)/iResolution.y;\n\n    if(swa(0.1)<0.5) mo(center_uv,vec2(0.5));\n\n    vec3 ro = vec3(center_uv*5.,-30.), rd = vec3(0.,0.,1.);\n\n    vec3 p = ro, col = vec3(0.), l = normalize(vec3(1.,2.,-3.));\n\n    bool hit = false;\n\n    for (float i=0.;i<64.;i++)\n    {\n        float d = SDF(p);\n        if (d<0.001)\n        {\n            hit = true;\n            break;\n        }\n        p += d*rd;\n    }\n\n    if (hit)\n    {\n        vec3 n = getnorm(p);\n        float light = max(dot(n,l),0.);\n        col = mix(vec3(0.3,0.1,0.5),vec3(0.05,0.9,0.5),light);\n    }\n    col += g1*0.1;\n    fragColor = vec4(sqrt(col),1.);\n}", "image_inputs": [{"id": "ltS3Wd", "previewfilepath": "https://soundcloud.com/bubblyfish/excerpt-from-beethoven", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/bubblyfish/excerpt-from-beethoven", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtfRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[796, 796, 827, 827, 873], [875, 875, 903, 903, 988], [990, 990, 1018, 1018, 1094], [1111, 1111, 1131, 1131, 1953], [1955, 1955, 1978, 1978, 2091], [2093, 2093, 2149, 2149, 2846]], "test": "error"}
{"id": "3dtfW7", "name": "iridescent lighting experiment", "author": "Mischawake", "description": "Playing with bi-colors", "tags": ["metaballs"], "likes": 16, "viewed": 133, "published": "Public", "date": "1605281695", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hsv2rgb(h) clamp( abs(mod( h*6.+vec3(0,4,2), 6.)-3.)-1., 0., 1. )\n\nfloat calcInfluence( vec4 ball, vec2 uv)\n{ \n    float d = distance(ball.rg, uv);\n    float inf = pow( ball.b/d, 3.0);\n    return  inf;   \n}\n\nfloat calcHeight( vec4 ball, vec2 uv )\n{\n \n   float d = distance(ball.rg, uv)/ball.b;\n   float h = pow( 1. - pow( d, 2.), 1./3. );\n   return h;\n    \n}\n\nvec3 calcNormal( vec4 ball, vec2 uv )\n{\n   \n    float eps = 0.00001;\n    \n    vec3 xp = vec3( uv.x + eps, uv.y, calcHeight( ball, vec2(uv.x + eps, uv.y) ) \n                   - vec3( uv.x - eps, uv.y, calcHeight( ball, vec2(uv.x - eps, uv.y) )  ) );\n    vec3 yp = vec3( uv.x, uv.y + eps, calcHeight( ball, vec2( uv.x, uv.y + eps) ) \n                   - vec3( uv.x, uv.y - eps, calcHeight( ball, vec2(uv.x, uv.y - eps) ) ) );\n    \n    return cross( xp, yp );\n}\n\n\nvec3 calcOldNormal( vec4 ball, vec2 uv )\n{\n    return vec3( ball.rg - uv, 0.1);      \n}\n\nvec3[] colors = vec3[]\n(   \n\n    hsv2rgb(0.05),\n   \thsv2rgb(0.15),\n    hsv2rgb(0.4),\n    hsv2rgb(0.5)\n);\n\n//for gradient?\nvec3[] colors2 = vec3[]\n(   \n\n\thsv2rgb(0.7),\n   \thsv2rgb(0.7),\n    hsv2rgb(0.7),\n    hsv2rgb(0.7)\n    \n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= 0.333;\n    vec4 mouse = iMouse / iResolution.yyyy;\n    mouse.x -= 0.333;\n    \n    \n    //settings to play with!\n    float threshold = 1.0;\n    float specularIntensity = 0.0;\n    float specularPower = 200.0;\n    float rimIntensity = 3.0; //2\n    float aoIntensity = 0.6;\n    float ambientBrightness =  0.8;\n    float lightBrightness = 0.25;\n    \n    float ire = 1.0;\n    \n    vec3 ambientColor = vec3(1.0);//hsv2rgb( 0.5 + iTime / 20.0 );\n    \n    vec3 lightColor = vec3(1.0);//hsv2rgb( iTime / 10.0 );\n    \n    bool rainbowMode = false;\n    \n\n   \t//balls\n    float rad = 0.1;\n    float rf = 0.;//0.005;\n    float jiggle = 0.;//sin(iTime*(2.0)) * 0.0125;\n    \n    vec4[] balls = vec4[]\n    (\n        \n        vec4(0.0 + jiggle,0.2 + jiggle, rad + sin(iTime * 4.) * rf, 3.),\n        vec4(0.0 - jiggle,0.4,rad + sin(iTime * 4. + 1.) * rf, 3.),\n        vec4(0.0,0.6 + jiggle,rad + sin(iTime * 4. + 2.) * rf, 2.),\n        vec4(0.0 + jiggle,0.8 + jiggle,rad + sin(iTime * 4. + 1.) * rf, 2.),\n        \n        vec4(0.2 + jiggle,0.2 + jiggle, rad + sin(iTime * 4.) * rf, 0.),\n        vec4(0.2 - jiggle,0.4,rad + sin(iTime * 4. + 1.) * rf, 3.),\n        vec4(0.2,0.6 + jiggle,rad + sin(iTime * 4. + 2.) * rf, 3.),\n        vec4(0.2 + jiggle,0.8 + jiggle,rad + sin(iTime * 4. + 1.) * rf, 0.),\n\n        vec4(0.4 + jiggle,0.2 - jiggle,rad + sin(iTime * 4. + 3.) * rf, 0.),\n        vec4(0.4 + jiggle,0.4,rad + sin(iTime * 4. + 4.) * rf, 2.),\n        vec4(0.4,0.6 + jiggle,rad + sin(iTime * 4. + 5.) * rf, 0.),\n        vec4(0.4 - jiggle * 3.,0.8+jiggle,rad + sin(iTime * 4. + 6.) * rf, 0.),\n\n        vec4(0.6,0.2 - jiggle,rad + sin(iTime * 4. + 7.) * rf, 1.),\n        vec4(0.6,0.4 - jiggle,rad + sin(iTime * 4. + 8.) * rf, 2.),\n        vec4(0.6 - jiggle,0.6 - jiggle,rad + sin(iTime * 4. + 9.) * rf, 2.),\n        vec4(0.6,0.8 - jiggle,rad + sin(iTime * 4. + 10.) * rf, 1.),\n\n        vec4(0.8 + jiggle,0.2 + jiggle,rad + sin(iTime * 4. + 11.) * rf, 2.),\n        vec4(0.8 + jiggle,0.4 - jiggle,rad + sin(iTime * 4. + 12.) * rf, 2.),\n        vec4(0.8,0.6 + jiggle,rad + sin(iTime * 4. + 13.) * rf, 1.),    \n        vec4(0.8,0.8 - jiggle,rad + sin(iTime * 4. + 14.) * rf, 1.),\n        \n        vec4(1.0 + jiggle,0.2 + jiggle,rad + sin(iTime * 4. + 11.) * rf, 2.),\n        vec4(1.0 + jiggle,0.4 - jiggle,rad + sin(iTime * 4. + 12.) * rf, 2.),\n        vec4(1.0,0.6 + jiggle,rad + sin(iTime * 4. + 13.) * rf, 1.),    \n        vec4(1.0,0.8 - jiggle,rad + sin(iTime * 4. + 14.) * rf, 0.),\n\n        vec4( mouse.xy,rad, 2.),\n        vec4( 0.95 * abs(vec2(sin(iTime*0.2345), cos(iTime*0.1234))), rad, 1.)\n        \n     );\n    \n    int ballCount = 26;\n    \n    int accumulatorCount = 4;\n    float[] accumulators = float[]\n    (\n    \t0.0,\n        0.0,\n        0.0,\n        0.0\n    );\n    \n    vec3[] normals = vec3[]\n    (\n    \tvec3(0),\n        vec3(0),\n        vec3(0),\n        vec3(0)\n    );\n    \n    vec2[] pos = vec2[]\n    (\n    \tvec2(0),\n        vec2(0),\n        vec2(0),\n        vec2(0)\n    );\n    \n    \n    int i;\n    //determine color with greatest influence\n    for( i = 0; i < ballCount; i++ )\n    {\n        int idx = int( balls[i].a );\n        float inf = calcInfluence( balls[i], uv );\n        accumulators[idx] += inf;\n        normals[idx] += calcOldNormal( balls[i], uv) * min(10.0, inf );\n        pos[idx] += (balls[i].rg - uv) * inf;\n    }\n    \n    float maxInf = 0.0;\n    int maxIdx = 0;\n    vec3 avgColor = vec3(0,0,0);\n    float totalInf = 0.0;\n    \n    for( i = 0; i < accumulatorCount; i++ )\n    {\n        if( accumulators[i] > maxInf )\n        {\n            maxInf = accumulators[i];\n            maxIdx = i;\n        }\n        \n        totalInf += accumulators[i];\n        avgColor += accumulators[i] * colors[i];\n    }\n    \n    avgColor /= totalInf;\n    \n    float influence = accumulators[maxIdx];\n    vec3 baseColor = colors[maxIdx];\n    \n  \tvec3 highlightColor = colors2[maxIdx];\n    \n    vec3 normal = normalize( normals[maxIdx] );\n   \n    \n \t\n    //influence = mix( influence, 1.0, 1.0 - off/0.1 );\n    \n      \n    //point light\n    vec3 light = vec3( 0.5 + sin(iTime/2.0) * 0.65, 0.5 + cos(iTime/2.0) * 0.45, -0.25);\n    float lightRadius = 0.01;\n    float lightIntensity = calcInfluence( vec4(light.x, light.y, lightRadius, 0.), uv ) * lightBrightness;\n\tvec3 lightDir = normalize( light - vec3( uv, 0.0 ) );            \t\n    \n    //basecolor\n    vec3 color = baseColor;\n    \n    //vec3 ambientColor = vec3(ambientBrightness);\n    \n    vec3 ambient = ambientBrightness * ambientColor;\n   \n  \n    \n    //diffuse\n    float diff = max(0.,dot( -normal, lightDir) );\n    vec3 diffuse = diff * lightColor * lightBrightness;\n    //color = mix( color, color * lighting, (1.0 - ambientBrightness) * shadowIntensity );\n    \n    \n    // specular blinn phong\n    vec3 dir = normalize(lightDir + vec3(0,0,-1.0) );\n    float specAngle = max(dot(dir, -normal), 0.0);\n    float spec = pow(specAngle, specularPower);\n    vec3 specular = lightColor * spec * specularIntensity;\n    \n    color = mix( color, highlightColor, clamp( length(diffuse), 0., ire) );\n    \n    //rim light\n    float rim = 1.0 - (dot ( vec3(0.,0.,-1.), -normal));\n    color += vec3(1.0) * rimIntensity * pow (rim, 2.0);\n    \n    color = (ambient + diffuse + specular) * color;\n    \n    //ao\n    float prox = (maxInf/totalInf);\n    prox = pow( smoothstep( 1.0, 0.35, prox), 3.0 );\n    vec3 aoColor = vec3(0.0);\n    color = mix( color , aoColor, prox * aoIntensity);\n    \n\t//shape\n    float aa = min( fwidth( influence ) * 1.5, 1.);\n   \tfloat smo = smoothstep( 0., aa, influence - threshold);\n    color = mix( ambientColor * ambientBrightness * 0.1, color, smo);\n    \n    color += pow(lightIntensity,0.5) * 2.0 * lightColor;               \n    \n    \n    \n   \tcolor = pow( color, vec3(2.2) );\n    \n    \n    fragColor = vec4( color, 1.0 );\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dtfW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 117, 117, 214], [216, 216, 256, 256, 366], [368, 368, 407, 407, 828], [831, 831, 873, 873, 918]], "test": "error"}
{"id": "3dVfz1", "name": "Scrolling Logistic Bifurcation", "author": "THWeaver", "description": "Simple bifurcation diagram for the logistic map.", "tags": ["2d", "chaos", "logistic", "bifurcation"], "likes": 1, "viewed": 27, "published": "Public", "date": "1606601757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Scrolling Logistic Map Bifurcation by Logan Apple (Twitter: @loganapple540)\n// https://www.shadertoy.com/view/3dVfz1\n// MIT License\n\n// More Info: https://en.wikipedia.org/wiki/Logistic_map\n\n#define MAX_ITER 100\n\nfloat logistic_map(in float r, in float x)\n{\n    return r * x * (1.0 - x);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    vec3 col = vec3(0.0);\n    vec2 uv = fragCoord / iResolution.xy;\n    \n    // Initial guess.\n    float current_x = 0.5;\n    int accumulate = 0;\n    for (int i = 0; i < MAX_ITER; ++i)\n    {\n        // Update using logistic map.\n        current_x = logistic_map(uv.x + 0.15 * min(iTime, 20.0), current_x);\n        \n        // Any point exactly on the lines of the bifurcation diagram is included.\n        if (current_x <= uv.y + 1.0 / iResolution.y && current_x > uv.y) {\n            accumulate++;\n        }\n    }\n    \n    col = vec3(1.0 - smoothstep(float(accumulate), 0.0, 0.001));\n    \n    // Output to screen.\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dVfz1.jpg", "access": "shaders20k", "license": "mit", "functions": [[216, 216, 260, 260, 292], [295, 295, 350, 350, 1001]], "test": "valid"}
{"id": "3dyBR1", "name": "Dryengulater (Triangulator fork)", "author": "UrbanClubProfessional", "description": "Remix of nimitz' Triangulator: [url]https://www.shadertoy.com/view/lllGRr[/url]", "tags": ["3d", "raymarching", "triangle", "remix", "abstract", "glitch", "barycentric", "heightmap", "fork", "weird", "error", "japan", "triangulation", "sakura"], "likes": 1, "viewed": 244, "published": "Public API", "date": "1606510695", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Hacked and cracked by Urban Club Professional!\n\n#define ITR 70\n#define FAR 200.\n#define time iTime*0.3\n\nmat2 mm2(in float a){float c = cos(a), s = sin(a);return mat2(c,-s,s,c);}\nmat2 m2 = mat2(1.034, 0.458, -0.458, 1.034);\nfloat tri(in float x){return abs(fract(x)-0.6);}\n\nfloat heightmap(in vec2 p)\n{\n\tp*=.06;\n    float z=3.;\n\tfloat rz = 1.;\n\tfor (float i= 2.;i < 5.;i++ )\n\t{\n        rz+= tri(p.x+tri(p.y*1.5))/z;\n        z = z*-.05;\n\t\tp = p*2.32;\n        p*= m2;\n\t}\n    rz += sin(p.y+sin(p.x*1.0))*.8+.4;\n\treturn rz*0.1;\n}\n\n//from jessifin (https://www.shadertoy.com/view/lslXDf)\nvec3 bary(vec2 a, vec2 b, vec2 c, vec2 p) \n{\n    vec2 v0 = b - a, v1 = c - a, v2 = p - a;\n    float inv_denom = 2.0 / (v0.x * v1.y - v1.x * v0.y)+2e-10;\n    float v = (v2.x * v1.y - v1.x * v2.y) * inv_denom;\n    float w = (v0.x * v2.y - v2.x * v0.y) * inv_denom;\n    float u = 2.0 - v - w;\n    return abs(vec3(u,v,w));\n}\n\n/*\n\tIdea is quite simple, find which (triangular) side of a given tile we're in,\n\tthen get 3 samples and compute height using barycentric coordinates.\n*/\nfloat map(vec3 p)\n{\n    vec3 q = fract(p)-0.6;\n    vec3 iq = floor(p);\n    vec2 p1 = vec2(iq.x-.6, iq.z+.6);\n    vec2 p2 = vec2(iq.x+.6, iq.z-.6);\n    \n    float d1 = heightmap(p1);\n    float d2 = heightmap(p2);\n    \n    float sw = sign(q.x+q.z); \n    vec2 px = vec2(iq.x+.6*sw, iq.z+.6*sw);\n    float dx = heightmap(px);\n    vec3 bar = bary(vec2(.6*sw,.6*sw),vec2(-.6,.6),vec2(.6,-.6), q.xz);\n    return (bar.x*dx + bar.y*d1 + bar.z*d2 + p.y + 4.)*1.0;\n}\n\nfloat march(in vec3 ro, in vec3 rd)\n{\n\tfloat precis = 0.002;\n    float h=precis*3.0;\n    float d = 1.;\n    for( int i=1; i<ITR; i++ )\n    {\n        if( abs(h)<precis*(2.0+d) || d>FAR ) break;\n        d += h;\n\t    float res = map(ro+rd*d)*2.1;\n        h = res;\n    }\n\treturn d;\n}\n\nvec3 normal(const in vec3 p)\n{  \n    vec2 e = vec2(-2., 2.)*0.02;\n\treturn normalize(e.yxx*map(p + e.yxx) + e.xxy*map(p + e.xxy) + \n\t\t\t\t\t e.xyx*map(p + e.xyx) + e.yyy*map(p + e.yyy) );   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\t\n    vec2 bp = fragCoord.xy/iResolution.xy;\n\tvec2 p = bp-0.6;\n\tp.x*=iResolution.x/iResolution.y;\n    vec2 um = vec2(0.55+sin(time*0.8)*3., -.28);\n    \n    vec3 ro = vec3(sin(time*0.8+2.)*30.,4., time*60.);\n    vec3 eye = normalize(vec3(cos(um.x), um.y*6., sin(um.x)));\n    vec3 right = normalize(vec3(cos(um.x+2.5708), 1., sin(um.x+2.5708)));\n    right.xy *= mm2(sin(time*0.8)*0.4);\n    vec3 up = normalize(cross(right, eye));\n\tvec3 rd = normalize((p.x*right+p.y*up)*2.+eye);\n\t\n\tfloat rz = march(ro,rd);\n    vec3 col = vec3(1.);\n    \n    if ( rz < FAR )\n    {\n        vec3 pos = ro+rz*rd;\n        vec3 nor= normal(pos);\n        vec3 ligt = normalize(vec3(-.3, 0.06, -0.3));\n        \n        float dif = clamp(dot( nor, ligt ), 1., 2.);\n        float fre = pow(clamp(1.0+dot(nor,rd),0.1,2.0), 4.);\n        vec3 brdf = 2.*vec3(0.20,0.21,0.2);\n        brdf += 2.9*dif*vec3(.9,2.,.06);\n        col = vec3(0.45,0.08,0.6);\n        col = col*brdf + fre*0.6*vec3(.8,.9,2.);\n    }\n    col = clamp(col,1.,2.);\n\tcol = pow(col,vec3(1.0));\n    col *= pow( 6.0*bp.x*bp.y*(1.0-bp.x)*(1.0-bp.y), 0.2);\n\tfragColor = vec4( col, 2.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyBR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[107, 107, 128, 128, 180], [226, 226, 248, 248, 274], [276, 276, 304, 304, 527], [529, 585, 629, 629, 905], [907, 1061, 1080, 1080, 1516], [1518, 1518, 1555, 1555, 1796], [1988, 1988, 2045, 2045, 3164]], "test": "error"}
{"id": "3dyfz1", "name": "Day 339 - Cookie Collective", "author": "jeyko", "description": "some stuff for cookie collective stream, modified a bit.", "tags": ["mdtmjvm"], "likes": 3, "viewed": 294, "published": "Public API", "date": "1606516318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Improv live coded in 30 minutes\n\n\nvec4 noise(float t){return texture(iChannel0,vec2(floor(t), floor(t))/256.);}\nvec4 valueNoise(vec2 t, float w){\n    vec2 fr = fract(t);\n\treturn \n        mix(\n            mix( \n                texture(iChannel0,vec2(floor(t.x), floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x), floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            mix( \n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y))/256.),\n                texture(iChannel0,vec2(floor(t.x) + 1.,floor(t.y) + 1.)/256.),\n            \tsmoothstep(0.,1.,fr.y)\n            ),\n            smoothstep(0.,1.,pow(fr.x, w)));\n}\nvec4 fbm(vec2 uv){\n\tvec4 n = vec4(0);\n    uv *= iResolution.xy/vec2(800.,450.);\n\tn += valueNoise(uv*60.,0.1);\n    n += valueNoise(uv*1700.,0.1)*0.5;\n    n += valueNoise(uv*10.,1.1)*0.1;\n    n -= valueNoise(uv*10. + 4.,0.1)*1.;\n    n -= valueNoise(uv*20.,0.5)*0.2;\n    \n    \n    //n = valueNoise(uv*3.,19.9)*1.;\n    n = max(n, 0.);\n    return n;\n}\n#define T iTime\n\n#define pi acos(-1.)\n#define rot(j) mat2(cos(j),sin(j),-sin(j),cos(j))\n\nfloat sdLine(vec2 uv,vec2 a, vec2 b){\n  float d = 10e5;\n  vec2 dir = normalize(b - a);\n  float ang = atan(dir.y, dir.x);\n  \n  vec2 uvrota = (uv - a)*rot(ang);\n  vec2 uvrotb = (uv - b)*rot(ang);\n  \n  d = abs( uvrota.y);\n  \n  d = max(d, -(uvrota).x);\n  d = max(d, (uvrotb).x);\n  \n  return d;\n}\n\n#define xor(a,b,c) min(max(a,-b),max(-a+c,b))\n\nfloat r11(float a){ return fract(sin(a*225.12321)*21.45123);}\n\nfloat fbm(float a){ return mix(r11(floor(a)),r11(floor(a) + 1.),fract(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    vec2 oouv = uv;\n  \tvec3 col = vec3(0);\n\tfloat seg = floor(T/4.);\n  \tfor(float i = 0.; i < 3.; i++){\n        uv = oouv + i*.04*pow(length(uv),4. - fbm(T));\n\n        float r = r11(seg);\n        float rb = r11(seg + 2.);\n\n        float d = 10e5;\n\n        float ang = floor(r*4. + 4.)*pi/4.;\n\n        float amt = floor(r*9.);\n\n        #define md(g) fbm(T*(0.1 + rb) + g)\n        vec2 ouv = uv;\n        uv *= rot(ang);\n        for(float ii = 0.; ii < amt + 2.; ii++){\n          float rc = r11(ii + seg);\n          float rd = r11(ii + seg +21421.3213);\n          //float l = sdLine(uv + vec2(0 + md(i*0.02)*0.,0),vec2(0. - rc,0.), vec2(0. + rd,0.)) - 1.;\n          float l = sdLine(uv + vec2(0. + md(ii*0.42)*0.6,0),vec2(0. - rc,0.), vec2(0. + rd,0.)) - 0.01;\n          uv.y += r11(ii + seg + 124.213)*0.1;\n\n\n\n          d = min(d,l);\n\n        }\n\n\n        for(float ii = 0.; ii < amt + 3.; ii++){\n            uv = abs(uv) - 0.2*r;\n            float b = length(uv) - 0.2;\n            b = abs(b) - r11(ii + 12. + seg)*0.04;\n\n            d = xor(d,b,0.2);\n        }\n\n        d = smoothstep(dFdx(ouv.x),0.,d);\n        col[int(i)] += d;\n        \n        \n        //col = mix(col,vec3(1),smoothstep(dFdx(uv.x)*2.,0.,d + dFdx(uv.x)*0.));\n\n\n        vec4 f = smoothstep(0.,1.,fbm(uv*50.));\n        vec4 g = smoothstep(0.,1.,fbm(uv*60. - 0.4));\n\n        f.x = pow(f.x, 5.);\n\n        float n = 0.;\n        n += f.x*.5;\n        n += pow(f.y,7.)*2.5;\n        n += pow(f.z,6.)*2.5;\n        n += pow(f.w,3.)*0.1;\n\n        n += pow(g.x,6.)*3.;\n        n += pow(g.y,4.)*1.;\n        n += pow(g.z,4.)*1.;\n\n\n        n = min(n,0.5);\n\n\n        col = max(col,0.002);\n\n        if(col.x > 0.1){\n            col -= n*1.7;\n            //col -= pow(g,5.)*2.5;\n            //col -= pow(g,2.)*.9;\n        }\n        else{\n            col += pow(n,2.)*0.1;\n            //col += f*4.;\n\n        }    \n\n    \n        \n        \n        \n  \t}\n \n      col *= vec3(1.06,0.98,0.9);\n\n\tcol = pow(max(col,0.),vec3(0.454545));\n\n    \n    if (mod(seg,4.) == 0.){\n        col = 1. - col;\n    }\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[37, 37, 57, 57, 114], [115, 115, 148, 148, 677], [678, 678, 696, 696, 1024], [1114, 1114, 1151, 1151, 1405], [1454, 1454, 1473, 1473, 1515], [1517, 1517, 1536, 1536, 1592], [1594, 1594, 1651, 1651, 3790]], "test": "error"}
{"id": "3dyfzD", "name": "traditional textile animation", "author": "yasuo", "description": "Nothing...", "tags": ["distfunctions2d"], "likes": 6, "viewed": 234, "published": "Public API", "date": "1606655241", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define Rot(a) mat2(cos(a),-sin(a),sin(a),cos(a))\n#define skew(x, y) mat2(1,tan(x),tan(y),1)\n#define antialiasing(n) n/min(iResolution.y,iResolution.x)\n#define S(d,b) smoothstep(antialiasing(1.0),b,d)\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdBox( in vec2 p, in vec2 b )\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    p.x -= clamp( p.x, -2.0, 0.0 );\n    return -length(p)*sign(p.y);\n}\n\n// https://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\nfloat sdTriangle( in vec2 p, in vec2 p0, in vec2 p1, in vec2 p2 )\n{\n    vec2 e0 = p1-p0, e1 = p2-p1, e2 = p0-p2;\n    vec2 v0 = p -p0, v1 = p -p1, v2 = p -p2;\n    vec2 pq0 = v0 - e0*clamp( dot(v0,e0)/dot(e0,e0), 0.0, 1.0 );\n    vec2 pq1 = v1 - e1*clamp( dot(v1,e1)/dot(e1,e1), 0.0, 1.0 );\n    vec2 pq2 = v2 - e2*clamp( dot(v2,e2)/dot(e2,e2), 0.0, 1.0 );\n    float s = sign( e0.x*e2.y - e0.y*e2.x );\n    vec2 d = min(min(vec2(dot(pq0,pq0), s*(v0.x*e0.y-v0.y*e0.x)),\n                     vec2(dot(pq1,pq1), s*(v1.x*e1.y-v1.y*e1.x))),\n                     vec2(dot(pq2,pq2), s*(v2.x*e2.y-v2.y*e2.x)));\n    return -sqrt(d.x)*sign(d.y);\n}\n\n// noise and fbm function from https://www.shadertoy.com/view/Xd3GD4\n//-----------------------------------------------------------------------------\nvec2 hash( vec2 p )\n{\n\tp = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t dot(p,vec2(269.5,183.3)) );\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat noise2d( in vec2 p )\n{\n\tconst float K1 = 0.366025404; // (sqrt(3)-1)/2;\n\tconst float K2 = 0.211324865; // (3-sqrt(3))/6;\n\t\n\tvec2 i = floor( p + (p.x+p.y)*K1 );\n\t\n\tvec2 a = p - i + (i.x+i.y)*K2;\n\tvec2 o = (a.x>a.y) ? vec2(1.0,0.0) : vec2(0.0,1.0);\n\tvec2 b = a - o + K2;\n\tvec2 c = a - 1.0 + 2.0*K2;\n\t\n\tvec3 h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n\t\n\tvec3 n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n\t\n\treturn dot( n, vec3(70.0) );\n}\n\nfloat fbm(vec2 uv)\n{\n\tfloat f;\n\tmat2 m = mat2( 1.6,  1.2, -1.2,  1.6 );\n\tf  = 0.5000*noise2d( uv ); uv = m*uv;\n\tf += 0.2500*noise2d( uv ); uv = m*uv;\n\tf += 0.1250*noise2d( uv ); uv = m*uv;\n\tf += 0.0625*noise2d( uv ); uv = m*uv;\n\tf = 0.5 + 0.5*f;\n\treturn f;\n}\n\nfloat textile1Dist(vec2 p) {\n    vec2 prevUV = p;\n    vec3 col = vec3(0);\n    \n    p.x *=0.8;\n    const float k = -5.5;\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec2  q = p*m;\n    prevUV = q;\n    \n    float smallMaskSize = 0.055;\n    float d = length(q)-0.1;\n    q.x = abs(q.x);\n    q.x *= 0.8;\n    float d2 = length(q-vec2(0.059,0.035))-smallMaskSize;\n    d = max(-d2,d);\n\n    d = max(-(p.y-0.009),d);\n    return d;\n}\n\nvec3 textile1(vec2 uv, vec3 col, float ratio) {\n    vec2 prevUV = uv;\n    float d = length(uv)-0.125;\n    col = mix(col,vec3(0.9,0.3,0.6)*(ratio+0.9),S(d,0.0));\n    \n    d = textile1Dist(uv*Rot(radians(20.0)));\n    uv*=-1.0;\n    float d2 = textile1Dist(uv*Rot(radians(-45.0)));\n    d = min(d,d2);\n    uv = prevUV;\n    d2 = textile1Dist(uv*Rot(radians(-100.0)));\n    d = min(d,d2);\n    \n    uv*=61.0;\n    d2 = sdEquilateralTriangle(uv*Rot(radians(77.0)));\n    d = min(d,d2);\n    col = mix(col,vec3(1.0,0.7,0.8)*(ratio+0.9),S(d,0.0));\n    return col;\n}\n\nvec3 textileLayer1(vec2 uv, vec3 col, float scale, float i) {\n    uv*=scale;\n    uv.x+=0.35;\n    uv = mod(uv,0.8)-0.4;\n    col = textile1(uv*Rot(radians(iTime*-50.0*scale)),col,i);\n    return col;\n}\n\nfloat bgTexDist(vec2 uv) {\n    uv.x = abs(uv.x);\n    uv.x -= 0.02;\n    uv.x*=-1.0;\n    uv*=0.7;\n    vec2 prevUV = uv;\n    uv.y = abs(uv.y);\n    uv.y-=0.053;\n    float d = sdTriangle(uv,vec2(0.005,-0.025),vec2(-0.01,-0.05),vec2(-0.035,-0.05));\n    uv = prevUV;\n    float d2 = sdTriangle(uv,vec2(-0.005,0.0),vec2(0.01,0.025),vec2(0.01,-0.025));\n    d = min(d,d2);\n    return d;\n}\n\nvec3 bg(vec2 uv, vec3 col) {\n    vec2 prevUV = uv;\n    uv.x = mod(uv.x,0.18)-0.09;\n    uv.y = mod(uv.y,0.1)-0.05;\n    float d = bgTexDist(uv);\n    \n    uv = prevUV;\n    uv.x -= 0.09;\n    uv.y -= 0.25;    \n    uv.x = mod(uv.x,0.18)-0.09;\n    uv.y = mod(uv.y,0.1)-0.05;\n    \n    float d2 = bgTexDist(uv);\n    d = min(d,d2);\n    col = mix(col,vec3(0.9),S(d,0.0));\n    return col;\n}\n\nfloat leaf(vec2 uv) {\n    float sc = mix(0.01,2.0,smoothstep(0.3,-0.3,uv.y));\n    uv.x *= 2.0*sc;\n    float d = length(uv)-0.08;\n    return d;\n}\n\nvec3 flower(vec2 uv, vec3 col, vec3 baseCol){\n    float leafNum = 5.0;\n    float deg = 360.0/leafNum;\n    float leafDist = 0.09;\n    float d = 1.0;\n    for(float i = 0.0; i<5.0; i+=1.0) {\n        float rad = radians(i*deg);\n        float x = cos(rad)*leafDist;\n        float y = sin(rad)*leafDist;\n        \n        vec2 pos = uv;\n        pos.x -= x;\n        pos.y -= y;\n        pos*=Rot(-rad-radians(-90.0));\n        float d2 = leaf(pos);\n        d = min(d,d2);\n    }\n    float d3 = length(uv)-0.02;\n    d = min(d,d3);\n    col = mix(col,baseCol,S(d,0.0));\n    return col;\n}\n\nvec3 textile2(vec2 uv, vec3 col, float ratio) {\n    col = flower(uv*Rot(radians(35.0)),col, vec3(0.9,0.5,1.0)*(ratio+0.9));\n    col = flower(uv,col, vec3(0.7)*(ratio+0.9));\n    col = flower(uv*1.1,col, vec3(0.6,0.1,0.8)*(ratio+0.9));\n    return col;\n}\n\nvec3 textileLayer2(vec2 uv, vec3 col, float scale, float i) {\n    uv*=scale;\n    uv.x+=0.35;\n    uv = mod(uv,0.8)-0.4;\n    col = textile2(uv*Rot(radians(iTime*50.0*scale)),col,i);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec2 prevUV = uv;\n    vec3 col = vec3(1);\n    \n    uv.y+=iTime*0.05;\n    col = bg(uv,col);       \n    \n    uv = prevUV;\n    for(float i = 0.; i<1.0; i+=1.0/3.0) {\n        float z = mix(-0.6,-0.1,i);\n        \n        uv.x += (fract(0.3+i*5.0));\n        uv.y+= (i*0.3)-0.1;\n        uv.y+=iTime*(0.08*i+0.15);\n       \n        col = textileLayer2(uv,col,0.4+((1.0-i)*2.2+z),i); \n        \n        uv = prevUV;\n        uv.y+= (i*0.8)-0.1;\n        uv.y+=iTime*(0.1*i+0.1);\n        uv.x += (fract(0.2+i*2.0));\n        uv.x+=sin(iTime*0.5)*0.3;\n       \n        col = textileLayer1(uv,col,0.4+((1.0-i)*2.0+z),i);\n    }\n    \n    uv = prevUV;\n    uv*=2.0;\n    float smokeD = (length(uv)*0.9)*fbm(uv - vec2(cos(iTime*0.3)*2.5,sin(iTime*0.1)*2.5));\n    col *= mix( col, vec3(1.5,1.0,0.7), S(smokeD,1.0) );\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3dyfzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[202, 281, 318, 318, 398], [400, 479, 521, 521, 732], [734, 813, 880, 880, 1445], [1447, 1596, 1617, 1617, 1736], [1738, 1738, 1766, 1766, 2224], [2226, 2226, 2246, 2246, 2484], [2486, 2486, 2514, 2514, 2949], [2951, 2951, 2998, 2998, 3501], [3503, 3503, 3564, 3564, 3701], [3703, 3703, 3729, 3729, 4080], [4082, 4082, 4110, 4110, 4460], [4462, 4462, 4483, 4483, 4606], [4608, 4608, 4653, 4653, 5181], [5183, 5183, 5230, 5230, 5434], [5436, 5436, 5497, 5497, 5633], [5635, 5635, 5692, 5692, 6589]], "test": "valid"}
{"id": "3s3BR7", "name": "Glowing Waves Shader", "author": "Tech_", "description": "A pretty basic shader but I still like it's result! Enjoy!", "tags": ["waves", "simple", "glow", "sine", "cosine"], "likes": 9, "viewed": 327, "published": "Public API", "date": "1604589332", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//////////////////////////////////\n//\n//\t GLOWING WAVES\n//\n//   by Tech_\n//\n//////////////////////////////////\n\n//////////////////////////////////\n\n#define GLOW_AMOUNT 1.3\n#define SPEED 0.8\n\n//////////////////////////////////\n\nvec3 getWave(in vec2 uv, float curve, vec3 color) \n{\n    uv.x += curve * 1.6;\n    float wave = pow(1. - distance(uv.x, 0.5), 38.0 / GLOW_AMOUNT);\n    return wave * color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv /= 2.0;\n    uv.x += 0.25;\n    \n    float speed = iTime * SPEED;\n    \n    vec3 red = vec3(1.0, 0.0, 0.0);\n    vec3 blue = vec3(0.0, 0.0, 1.0);\n    vec3 yellow = vec3(1.0, 0.8, 0.0);\n    vec3 purple = vec3(0.5, 0.0, 1.0);\n    vec3 orange = vec3(1.0, 0.5, 0.0);\n\n    // Time varying pixel color\n    vec3 col;\n    col += getWave(uv, sin((uv.y + speed * 0.05) * 10.) * 0.06, red);\n\tcol += getWave(uv, cos((uv.y + speed * 0.025) * 10.) * 0.12, blue);\n    col += getWave(uv, sin((uv.y + speed * -0.007 + cos(uv.y * 0.2)) * 8.) * 0.1, yellow);\n    col += getWave(uv, cos((uv.y + speed * 0.035 + sin(uv.y * 0.13)) * 8.) * 0.05, purple);\n   \tcol += getWave(uv, sin((uv.y / 2.0 + speed * -0.05) * 10.) * 0.05, orange);\n    \n    col *= 0.8;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[228, 228, 280, 280, 400], [402, 402, 459, 509, 1347]], "test": "valid"}
{"id": "3s3BW2", "name": "checkerboard animation 4", "author": "FabriceNeyret2", "description": "for https://isohedral.ca/swirled-series/", "tags": ["checkerboard", "short"], "likes": 5, "viewed": 191, "published": "Public API", "date": "1605966218", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float ease( float x ) {                                 // rewritten from https://shadertoy.com/view/3ddBWB\n\treturn x > .5 ? x = 1.-x, 1. - 4.* x*x*x            // stepier than smoothstep or .5-.5*cos\n                  :                4.* x*x*x ;\n}\n\n#define D \\\n    V = abs( ( fract(U/2.)-.5)*mat2( cos(3.14/2.*t + vec4(0,11,33,0))) ); \\\n    O += smoothstep( w, -w, max(V.x,V.y) - .25 ) \n\nvoid mainImage( out vec4 O, vec2 u )\n{   \n    O-=O; \n    vec2 R = iResolution.xy,\n         U = u *= 8. / R.y, V;\n    if (U.x > 8.) { O += .5; return; }                  // out of board\n\n    float t = ease( fract(iTime/2.) ), w = 4./R.y,\n          n = mod(iTime/2.,2.);\n\n    if (n > 1.)  U.x++, t = 1.-t;\n    U -= .5; D;\n    U++;     D;\n    if (n < 1.)  O = 1.-O;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 107, 249], [390, 390, 428, 428, 754]], "test": "error"}
{"id": "3s3BW7", "name": "Playing with 2d sdfs.", "author": "henrmota", "description": "Playing with sdf morphing", "tags": ["sdf"], "likes": 2, "viewed": 216, "published": "Public API", "date": "1605193786", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 p, float radius) {\n    return length(p) - radius;\n}\n\nfloat sdBox(vec2 p, vec2 b)\n{\n    vec2 d = abs(p)-b;\n    return length(max(d,0.0)) + min(max(d.x,d.y),0.0);\n}\n\nfloat shade(float d) {\n\treturn clamp(-d * 500., 0., 1.);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5 * iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n\tfloat id = fract(sin(dot(floor(uv * 3.), vec2(145., 123.))) * 12345.) * 5. + 1.;\n    uv = fract(uv * 3.);\n    uv -= 0.5;\n    float dCircle = circle(uv, 0.5);\n    float dSquare = sdBox(uv, vec2(0.3));\n    \n    float t = sin(iTime * id) * 0.5 + 0.5;\n    \n    float ds = mix(dCircle, dSquare, t);\n  \n    \n    col += shade(ds);\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 69], [71, 71, 100, 100, 180], [182, 182, 204, 204, 244], [246, 246, 303, 303, 753]], "test": "valid"}
{"id": "3s3Bz2", "name": "Ray Marching case01", "author": "Fanziwen", "description": "example of raymarching ", "tags": ["test"], "likes": 1, "viewed": 46, "published": "Public", "date": "1605666126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 200.0\n#define SURF_DIST 0.01\n#define TIME_SCALE 0.5\n\nfloat RayMarch(vec3 ro, vec3 rd);\n\nstruct Material{\n    float specular;\n    vec3 diffuse;\n};\n\n// Gemotry\nfloat Sphere(vec3 p, vec3 pos, float radius)\n{\n   return (length(p-pos) - radius);\n}\n\nfloat Capsule(vec3 p, vec3 pos, float len, float radius)\n{\n    vec3 pA = pos + vec3(0.0, 1.0, 0.0) * len/2.0;\n    vec3 pB = pos - vec3(0.0, 1.0, 0.0) * len/2.0;\n   \tvec3 ap = p - pA;\n    vec3 ab = pB - pA;\n    float t = dot(ap, ab)/dot(ab, ab);\n    t = clamp(t, 0.0, 1.0);\n    \n    vec3 c = pA + t*(pB-pA);\n    float d = length(p-c) - radius;\n        \n    return d;\n}\nfloat Cube(vec3 p, vec3 pos, vec3 s)\n{\n \treturn length(max(abs(p-pos)-s, 0.0));   \n}\n\n\n/* ----------------------------------------------------- */\n\nfloat GetDist(vec3 p)\n{\n \t\n    float sphereDist = Sphere(p, vec3(0.0, 1.0, 0.0), 0.8);\n    float planeDist = p.y;\n    float capsDepth = Capsule(p, vec3(2.0, 1.0, 0.0), 1.0, 0.5);\n    float cubeDepth = Cube(p, vec3(-2, 1.0, 0.0), vec3(0.8));\n    \n    float d = min(sphereDist, planeDist);\n    d = min(d, capsDepth);\n    d = min(d, cubeDepth);\n    \n    return d;\n}\n\n\n\nvec3 GetNormal(vec3 p)\n{\n  \n    float offset = 0.01;\n    \n    vec3 n = vec3(\n        GetDist(p) - GetDist(p-vec3(offset, 0, 0)),\n        GetDist(p) - GetDist(p-vec3(0, offset, 0)),\n        GetDist(p) - GetDist(p-vec3(0, 0, offset)));\n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p, vec3 viewDir)\n{\n    Material mat;\n    \n    vec3 lightPos = vec3(0.0, 8.0, 0.0);\n    lightPos.xz += vec2(sin(iTime*TIME_SCALE), cos(iTime*TIME_SCALE))*6.0;\n    \n    vec3 lightDir = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float diff = max(0.0, dot(lightDir, n));\n    float d = RayMarch(p+n* SURF_DIST*2.0, lightDir);\n    \n    vec3 halfVec = normalize(normalize(viewDir) + normalize(lightDir));\n    float spec = dot(halfVec, n);\n    //spec = clamp(spec, 0.0, 1.0);\n    mat.specular = 1.0;\n    spec = max(0.0, pow(spec*mat.specular, 150.0));\n    \n    if(d < length(lightPos-p))\n    {\n        diff *= 0.1;\n        spec *= 0.0;\n    }\n    \n    return diff+spec;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n \tfloat dN = 0.0;\n \tfor(int i=0; i<MAX_STEPS; i++)\n    {\n     \tvec3 p = ro + rd*dN;\n        float d = GetDist(p);\n        dN += d;\n        if(dN>MAX_DIST || d<SURF_DIST)\n            break;\n    }\n    \n    return dN;\n}\n\nmat2 Rot(float a) {\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 R(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(vec3(0,1,0), f)),\n        u = cross(f,r),\n        c = p+f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i-p);\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = iMouse.xy/iResolution.xy;\n    vec3 col = vec3(uv, 0.0);\n    \n    \n    vec3 rOri = vec3(0, 4, -5);\n    rOri.yz *= Rot(-m.y+.4);\n    rOri.xz *= Rot(-m.x*6.2831);\n    vec3 rDir = R(uv, rOri, vec3(0,0,0), .7);\n    \n\tfloat d = RayMarch(rOri, rDir);\n    \n    \n    vec3 p = rOri + rDir * d;\n    \n    float dif = GetLight(p, -rDir);\n    \n    //d /= 1.0;\n    col = vec3(dif);\n    //col = GetNormal(p);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3Bz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[186, 197, 243, 243, 281], [283, 283, 341, 341, 650], [651, 651, 689, 689, 735], [799, 799, 822, 822, 1161], [1165, 1165, 1189, 1189, 1425], [1428, 1428, 1466, 1466, 2128], [2131, 2131, 2165, 2165, 2382], [2384, 2384, 2403, 2403, 2479], [2481, 2481, 2523, 2523, 2718], [2720, 2720, 2777, 2777, 3275]], "test": "error"}
{"id": "3s3Bz7", "name": "Painted Bird", "author": "dr2", "description": "Autonomous flyer leaping", "tags": ["movement", "wing", "kinematics"], "likes": 10, "viewed": 194, "published": "Public API", "date": "1604597551", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Painted Bird\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n// Revisiting the bird used in several earlier shaders (e.g., \"SeaBirds at Sunset\",\n// \"Fractal Bridge\", \"Tempting the Mariner\"); updated internals and paintjob.\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothBump (float lo, float hi, float w, float x);\nmat3 DirVuMat (vec3 vd);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nfloat Fbm1 (float p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 ltDir, qHit;\nfloat dstFar, tCur, wngAng, legAng, bkAng, bUp;\nint idObj;\nconst int nwSeg = 5;\nconst int idBdy = 1, idTail = 2, idEye = 3, idBk = 4, idLeg = 5, idWing = 6,\n   idWTip = idWing + nwSeg - 1, idPrch = idWTip + 1;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float wSeg, wChord, wSpar, fTap, bkLen, lgLen, ftLen, dMin, d, a, wr, wf, ws, ww;\n  dMin = dstFar;\n  wSeg = 0.15;\n  wChord = 0.3;\n  wSpar = 0.02;\n  fTap = 8.;\n  bkLen = 0.2;\n  lgLen = 0.08;\n  ftLen = 0.05;\n  p.y -= 2. * lgLen + 1.16;\n  p.y -= bUp;\n  q = p;\n  q.z -= 0.5;\n  q.x = abs (q.x) - 0.1;\n  a = wngAng;\n  wf = 1.;\n  ws = 0.02 * wChord;\n  for (int k = 0; k < nwSeg; k ++) {\n    q.xy = Rot2D (q.xy, a);\n    q.x -= wSeg;\n    wr = wf * (1. - 0.5 * q.x / (fTap * wSeg));\n    ww = ws - 0.01 * (q.z / wChord) * (q.z / wChord);\n    q.z += 0.4 * wr * wChord;\n    if (k < nwSeg - 1) {\n      d = length (max (abs (vec3 (q.xz, q.y - 0.5 * ww).xzy) - vec3 (wSeg, ww, wr * wChord),\n         0.)) - wr * wSpar;\n      q.x -= wSeg;\n      DMINQ (idWing + k);\n    } else {\n      q.x += wSeg;\n      d = max (length (abs (max (vec2 (length (q.xz) - wr * wChord,\n         abs (q.y - 0.5 * ww) - ww), 0.))) - wr * wSpar, - q.x);\n      DMINQ (idWTip);\n    }\n    q.z -= 0.4 * wr * wChord;\n    a *= 1.03;\n    wf *= (1. - 1. / fTap);\n    ws *= 0.8 * (1. - 1. / fTap);\n  }\n  q = p;\n  wr = q.z - 0.5;\n  if (wr > 0.) {\n    wr = 0.17 - 0.44 * wr * wr;\n  } else {\n    wr = clamp (0.667 * wr, -1., 1.);\n    wr *= wr;\n    wr = 0.17 - wr * (0.34 - 0.18 * wr); \n  }\n  d = PrCapsDf (q, wr, 1.);\n  DMINQ (idBdy);\n  q = p;\n  q.x = abs (q.x);\n  wr = (q.z + 1.) * (q.z + 1.);\n  q -= vec3 (0.3 * wr, 0.1 * wr, -1.2);\n  d = PrCapsDf (q, 0.009, 0.2);\n  DMINQ (idTail);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.07, 0.05, 0.9);\n  d = PrSphDf (q, 0.04);\n  DMINQ (idEye);\n  q = p;\n  q -= vec3 (0., -0.015, 1.15);\n  q.yz = Rot2D (vec2 (abs (q.y), q.z + 0.8 * bkLen), bkAng);\n  q.z -= 0.8 * bkLen;\n  wr = clamp (0.4 - 0.3 * q.z / bkLen, 0., 1.);\n  d = max (abs (length (max (abs (q) - vec3 (0., 0.25 * wr * bkLen, bkLen), 0.)) - 0.25 * wr * bkLen) - 0.002, - q.y);\n  DMINQ (idBk);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.08, -0.12, 0.5);\n  q.yz = Rot2D (q.yz, legAng);\n  q.xz = Rot2D (q.xz, -0.05 * pi);\n  q.z += lgLen;\n  d = PrCapsDf (q, 0.1 * lgLen, lgLen);\n  DMINQ (idLeg);\n  q.z += lgLen;\n  q.xy = vec2 (- q.y, q.x);\n  q.xy = Rot2D (q.xy, floor (3. * atan (q.y, - q.x) / (2. * pi) + 0.5) * (2. * pi / 3.));\n  q.xz = Rot2D (q.xz, - pi + 0.4 * legAng);\n  q.z -= ftLen - 0.02;\n  q.x -= 0.01 * (1. - (q.z / ftLen) * (q.z / ftLen));\n  d = PrCapsDf (q, 0.1 * ftLen, ftLen);\n  DMINQ (idLeg);\n  p.y += bUp;\n  q = p - vec3 (0., - (2. * lgLen + 0.16), 0.5);\n  d = PrCapsDf (q.yzx, 0.02, 0.3);\n  q.x = abs (q.x) - 0.25;\n  q.y -= -0.51;\n  d = min (d, max (PrCapsDf (q.xzy, 0.03, 0.51), -0.5 - q.y));\n  DMINQ (idPrch);\n  return 0.8 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.02;\n  for (int j = VAR_ZERO; j < 20; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (sh < 0.05) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nvec4 ObjCol ()\n{\n  vec4 col4, c1, c2, c3;\n  float spec, a, r, s, t, sx;\n  c1 = vec4 (0.9, 0.8, 0.8, 0.2);\n  c2 = vec4 (0.3, 0.3, 0.8, 0.2);\n  c3 = vec4 (0.1, 0.3, 0.1, 0.2);\n  if (idObj == idEye) {\n    col4 = vec4 (0., 0., 0.6, 0.5);\n  } else if (idObj == idBdy || idObj == idTail) {\n    a = atan (abs (qHit.x), qHit.y) / pi;\n    col4 = mix (c3, mix (c1, c2, smoothstep (0.5, 0.7, a)), smoothstep (0.1, 0.3, a));\n    if (idObj == idBdy && qHit.z > 0. && length (max (abs (vec2 (qHit.x, qHit.y + 0.017)) -\n       vec2 (0., 0.035), 0.)) < 0.025) col4 = vec4 (1., 0.7, 0.2, -1.);\n  } else if (idObj == idBk) {\n    col4 = vec4 (0.9, 0.4, 0.1, 0.1);\n  } else if (idObj == idLeg) {\n    col4 = (0.7 + 0.3 * sin (128. * pi * qHit.z)) * vec4 (0.8, 0.6, 0., 0.1);\n  } else if (idObj >= idWing && idObj <= idWTip) {\n    col4 = (qHit.y > -0.006) ? c3 : c2;\n    t = 0.3 * float (idObj - idWing);\n    sx = 6.66 * qHit.x - 0.52;\n    if (idObj < idWTip || idObj == idWTip && qHit.x < 0.075) col4 = mix (col4, c1, smoothstep (0.,\n       0.01, qHit.z - 0.54 * (abs (cos (pi * sx)) - 0.5) * (1. - 0.4 * t)));\n    r = (length (qHit.xz) - 0.165);\n    a = atan (qHit.z, - qHit.x) / (2. * pi) + 0.5;\n    t = 0.11 * (qHit.x + t) - 0.29;\n    s = (idObj < idWTip) ? step (0., qHit.z + t) * (1. - smoothstep (0.1, 0.2, mod (8. * sx, 1.))) :\n       step (0.021, r) * smoothstep (0.8, 0.9, mod (64. * a, 1.));\n    col4 *= 1. - 0.2 * s;\n    s = (idObj == idWTip) ? smoothstep (0., 0.005, r) * (1. - smoothstep (0.3, 0.4, mod (32. * a, 1.))) :\n       (1. - smoothstep (0.01, 0.016, qHit.z - t)) * smoothstep (0.6, 0.7, mod (4. * sx, 1.));\n    col4 = mix (col4, c1, s);\n  } else if (idObj == idPrch) {\n    col4 = vec4 (0.5, 0.3, 0.1, 0.);\n  }\n  return col4;\n}\n\nvec3 SkyBgCol (vec3 ro, vec3 rd)\n{\n  vec3 col, clCol, skCol;\n  vec2 q;\n  float f, fd, ff, sd;\n  if (rd.y > -0.02 && rd.y < 0.03 * Fbm1 (16. * atan (rd.z, - rd.x))) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else if (rd.y < 0.) {\n    col = vec3 (0.3, 0.41, 0.55);\n  } else {\n    q = 0.02 * (ro.xz + 0.5 * tCur + ((100. - ro.y) / rd.y) * rd.xz);\n    ff = Fbm2 (q);\n    f = smoothstep (0.2, 0.8, ff);\n    fd = smoothstep (0.2, 0.8, Fbm2 (q + 0.01 * ltDir.xz)) - f;\n    clCol = (0.7 + 0.5 * ff) * (vec3 (0.7) - 0.7 * vec3 (0.3, 0.3, 0.2) * sign (fd) *\n       smoothstep (0., 0.05, abs (fd)));\n    sd = max (dot (rd, ltDir), 0.);\n    skCol = vec3 (0.4, 0.5, 0.8) + step (0.1, sd) * vec3 (1., 1., 0.9) *\n       min (0.3 * pow (sd, 64.) + 0.5 * pow (sd, 2048.), 1.);\n    col = mix (skCol, clCol, 0.1 + 0.9 * f * smoothstep (0.01, 0.1, rd.y));\n  }\n  return 0.8 * col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn;\n  vec2 vf;\n  float dstObj, dstGrnd, nDotL, sh, tCyc, phs, nCyc;\n  int idObjT;\n  tCyc = 2.;\n  nCyc = floor (mod (tCur / tCyc, 4.));\n  phs = (nCyc > 0.) ? mod (tCur / tCyc, 1.) : 0.;\n  bUp = 3. * phs * (1. - phs) * smoothstep (0., 0.1, 0.5 - abs (phs - 0.5));\n  legAng = pi * (0.2 + 0.3 * SmoothBump (0.25, 0.75, 0.1, mod (phs + 0.5, 1.)));\n  wngAng = -0.03 * pi * ((nCyc > 0.) ? (1. + 2. * cos (2. * pi * phs)) :\n     (2.9 + 0.1 * cos (2. * pi * mod (8. * tCur / tCyc, 1.))));\n  bkAng = 0.02 * pi * (1. + sin (5. * tCur));\n  dstGrnd = dstFar;\n  dstObj = ObjRay (ro, rd);\n  vf = vec2 (0.);\n  if (dstObj < dstFar) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = ObjCol ();\n    if (idObj == idPrch) vf = vec2 (64., 0.3);\n    idObjT = idObj;\n    if (col4.a < 0.) col = col4.rgb * (0.6 - 0.4 * dot (vn, rd));\n  } else if (rd.y < 0.) {\n    dstGrnd = - ro.y / rd.y;\n    ro += dstGrnd * rd;\n    vn = vec3 (0., 1., 0.);\n    col4 = mix (vec4 (0.4, 0.5, 0.3, 0.), vec4 (0., 0.5, 0.1, 0.),\n       smoothstep (0.2, 0.8, Fbm2 (8. * ro.xz)));\n    col4 = mix (vec4 (0.2, 0.5, 0.2, 0.), col4,  1. - smoothstep (0.5, 0.9, dstGrnd / dstFar));\n    vf = vec2 (8., 2. * (1. - smoothstep (0.2, 0.5, dstGrnd / dstFar)));\n  } else {\n    col = SkyBgCol (ro, rd);\n  }\n  if (dstObj < dstFar && col4.a >= 0. || dstObj >= dstFar && rd.y < 0.) {\n    sh = (min (dstObj, dstGrnd) < dstFar) ? ObjSShadow (ro + 0.01 * vn, ltDir) : 1.;\n    if (vf.x > 0.) vn = VaryNf (vf.x * ro, vn, vf.y);\n    nDotL = max (dot (vn, ltDir), 0.);\n    if (dstObj < dstFar) nDotL *= nDotL;\n    col = col4.rgb * (0.2 + 0.1 * max (vn.y, 0.) + 0.8 * sh * nDotL) +\n       step (0.95, sh) * col4.a * pow (max (dot (normalize (ltDir - rd), vn), 0.), 32.);\n    if (dstObj < dstFar) {\n      if (idObjT == idEye) col.b += 0.2;\n      col = mix (col, 1.3 * SkyBgCol (ro, reflect (rd, vn)), 0.3);\n    } else {\n      col *= 0.7 + 0.3 * smoothstep (0.92, 0.97, dot (normalize (10. * ltDir - ro), ltDir));\n      col = mix (col, 0.8 * vec3 (0.3, 0.41, 0.55), pow (1. + rd.y, 16.));\n    }\n  }\n  return clamp (col, 0., 1.);\n}\n\n#define AA  0   // optional antialiasing\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.2 * pi;\n  el = 0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.5 * pi * mPtr.y;\n  } else {\n    az += 0.01 * pi * tCur;\n    el += 0.1 * pi * sin (0.1 * pi * tCur);\n  }\n  el = clamp (el, 0.01 * pi, 0.4 * pi);\n  ro = 8. * sin (el + vec2 (0.5 * pi, 0.)).xyx * vec3 (sin (az + vec2 (0.5 * pi, 0.)), 1.2).xzy;\n  ro.y += 1.;\n  vuMat = DirVuMat (normalize (vec3 (0., 1.5, 0.) - ro));\n  zmFac = 5.5;\n  dstFar = 80.;\n  ltDir = normalize (vec3 (1., 1.5, 1.));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothBump (float lo, float hi, float w, float x)\n{\n  return (1. - smoothstep (hi - w, hi + w, x)) * smoothstep (lo - w, lo + w, x);\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2f (float p)\n{\n  return fract (sin (p + vec2 (0., 1.)) * cHashM);\n}\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Noiseff (float p)\n{\n  vec2 t;\n  float ip, fp;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = Hashv2f (ip);\n  return mix (t.x, t.y, fp);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm1 (float p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noiseff (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3Bz7.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[941, 941, 963, 963, 3570], [3572, 3572, 3605, 3605, 3789], [3791, 3791, 3812, 3812, 4067], [4069, 4069, 4106, 4106, 4335], [4337, 4337, 4353, 4353, 6064], [6066, 6066, 6100, 6100, 6924], [6926, 6926, 6961, 6961, 9050], [9094, 9094, 9150, 9150, 10339], [10341, 10341, 10374, 10374, 10401], [10403, 10403, 10446, 10446, 10519], [10521, 10521, 10578, 10578, 10661], [10663, 10663, 10688, 10688, 10857], [10859, 10859, 10889, 10889, 11002], [11036, 11036, 11060, 11060, 11113], [11115, 11115, 11139, 11139, 11269], [11271, 11271, 11296, 11296, 11442], [11444, 11444, 11469, 11469, 11655], [11657, 11657, 11679, 11679, 11833], [11835, 11835, 11856, 11856, 12011], [12013, 12013, 12042, 12042, 12254], [12256, 12256, 12295, 12295, 12475]], "test": "error"}
{"id": "3s3Bz8", "name": "It's Saturn", "author": "vtgco", "description": "It's Saturn", "tags": ["raymarching"], "likes": 2, "viewed": 66, "published": "Public", "date": "1604345158", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//from https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand(float n){return fract(sin(n) * 43758.5453123);}\n\nfloat noise(float p){\n\tfloat i = floor( p );\n    float f = fract( p );\n    \n    //from https://www.shadertoy.com/view/3sVczG\n    float u = f*f*(3.0-2.0*f);\n\t\n\treturn mix(rand(i),rand(i+1.),u);\n}\n\n// -----------------------------------------------\n\n\n//SDF functions from https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n\nfloat sdfSphere(vec3 p, float r) { return length(p) - r; }\n\nfloat onion( in float d, in float h ) { return abs(d)-h; }\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\n\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\n\nfloat sdCylinder( vec3 p, vec3 c ) { return length(p.xz-c.xy)-c.z; }\n\nfloat sdCappedCylinder(vec3 p, vec2 h)\n{\n  \tvec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  \treturn min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n//from https://www.shadertoy.com/view/wdKyD3\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\n\n// -----------------------------------------------\n\nconst vec3 SPHERE_DARK = vec3(188., 108., 37.)/255.;\nconst vec3 SPHERE_LIGHT = vec3(221., 161., 94.)/255.;\nconst vec3 RING_COLOR = vec3(128., 108., 80.)/50.;\n\nconst vec3 PLANET_CENTER = vec3(0.,0.,-8.);\n\n\nvec3 spaceship(float t) {\n    const float spaceship_dist = 2.25;\n   \n    vec3 loc = vec3(spaceship_dist*cos(t), 0., spaceship_dist*sin(t));\n    //loc = rotate_x(loc, -3. + t * -0.05);\n    loc += PLANET_CENTER;\n   \n    return loc;\n}\n\nvec4 map_and_color(vec3 q) {\n    vec3 col = vec3(0.);\n    float map_val = 1000.;\n    \n    float spaceship_sphere = sdfSphere(q - spaceship(iTime), 0.1);\n    if (map_val > spaceship_sphere) {\n    \tmap_val = spaceship_sphere;\n        col = vec3(0.5,0.5,0.5);\n    }\n    \n    vec3 p = q;\n    p -= PLANET_CENTER;\n    \n    p = rotate_x(p, -.3 + iTime * -0.05);\n   \n    \n    float sphere = sdfSphere(p, 1.);\n    if (map_val > sphere) {\n        float col_displacement = 0.1*(noise(20.*atan(p.z, p.x)+25.*p.y + iTime) - 0.5);\n        col = mix(SPHERE_DARK, SPHERE_LIGHT, fract(p.y*5. + col_displacement));\n    \tmap_val = sphere;\n        \n        col += (float(sdHexPrism(p.zxy + 0.2*col_displacement, vec2(0.14, 20.)) - 0.06 <= 0.)) * vec3(0.,0.,0.5);\n    }\n  \n    \n    float max_ring_r = 2.;\n\tfloat ring = sdCappedCylinder(p, vec2(max_ring_r,0.001));\n    \n    float ring_r = 1.25;\n    ring = opSubtraction(sdCylinder(p, vec3(0.,0.,ring_r)), ring);\n    \n    //CUT RANDOM GAPS INTO THE RINGS\n    /*float gap = 0.;\n    while(ring_r < max_ring_r) { \n        gap = rand(ring_r+1.) * 0.05;\n        ring = opSubtraction(onion(sdCylinder(p, vec3(0.,0.,ring_r)), gap), ring);\n        ring_r += rand(ring_r+1.) * 0.3;\n        \n    }*/\n    \n    if (map_val > ring) {\n    \tmap_val = ring;\n        col = RING_COLOR;\n        col *= smoothstep(0., 1., noise(length(p)*20.));\n    }\n    \n    \n    return vec4(col, map_val);\n}\n\n\nfloat map(vec3 p) {\n    return map_and_color(p).w;\n}\n\n\n//from https://www.shadertoy.com/view/wdKyD3\nvec3 normalAtPoint(vec3 p) {\n    const float eps = 0.0001; // or some other value\n    const vec2  h   = vec2(eps,0);\n    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n                           map(p+h.yxy) - map(p-h.yxy),\n                           map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\nfloat raymarch(vec3 start, vec3 dir) {\n    float t = 0.;\n    for (int i = 0; i <= 50; i++) {\n        vec3 curr_point = start + t*dir;\n        float map_val = map(curr_point);\n        \n        if (map_val < 0.01) {\n            return t;\n        } else {\n        \tt += map_val;\n        }\n        \n        if (t >= 50.) {\n            return -1.;\n        }\n    }\n    \n    return -1.;\n}\n\nfloat shadow(vec3 start, vec3 dir, float t_min, float t_max) {\n    float t = t_min;\n    while (t < t_max) {\n        vec3 curr_point = start + t*dir;\n        float map_val = map(curr_point);\n        \n        if (map_val < 0.01) {\n            return 0.;\n        } else {\n        \tt += map_val;\n        }\n    }\n    \n    return 1.;\n}\n\n//from https://www.shadertoy.com/view/wdKyD3\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += 0.95*h;//slightly less for not-quite-SDFs\n    }\n    return res;\n}\n\nvec3 CAMERA = vec3(0.,0.,3.);\n const vec3 LIGHT = normalize(vec3(1., 0., 3.));\nconst vec3 LIGHT_COLOR = vec3(1.);\n\nvec3 render(vec3 p) {\n    vec3 col = vec3(0.);\n    vec3 normal = normalAtPoint(p);\n    vec3 diffuse_color = map_and_color(p).xyz;\n \t \n   \t//directional lighting\n    float LdotN = clamp(dot(normal, LIGHT), 0., 1.);\n    float shadow = softshadow(p, LIGHT, 0.02, 20., 17.);\n    col = diffuse_color * LdotN * LIGHT_COLOR * clamp(0.3, 1., shadow);\n    \n    \n    //point light from spaceship\n    vec3 spaceship_light = normalize(spaceship(iTime) - p);\n    float LdotN_spaceship = clamp(dot(normal, spaceship_light), 0., 1.);\n    float shadow_spaceship = softshadow(p, spaceship_light, 1., 50., 17.);\n    col += diffuse_color * LdotN_spaceship * LIGHT_COLOR * clamp(0.3, 1., shadow_spaceship);\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec3 col = vec3(0.);\n    \n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n    vec3 pix = vec3(uv, 0.);\n     \n    \n    vec3 dir = normalize(pix - CAMERA);\n    \n    float t = raymarch(CAMERA, dir);\n    vec3 p = CAMERA + dir*t;\n    \n    if (t > 0.) {\n        col = render(p);    \n        \n    } else { //ADD STARS\n        float randAtPoint = rand((uv.x+rand(uv.y))*(rand(uv.x)+uv.y));\n        col = smoothstep(0., 1., (randAtPoint - 0.99)*100.) * vec3(1.); // * abs(sin(iTime+10.*rand(randAtPoint))); /*TWINKLING*/\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3Bz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 73, 93, 93, 131], [133, 133, 154, 154, 327], [472, 472, 506, 506, 530], [532, 532, 571, 571, 590], [592, 592, 636, 636, 657], [659, 659, 702, 702, 724], [726, 726, 762, 762, 794], [796, 796, 836, 836, 937], [939, 939, 975, 975, 1248], [1250, 1295, 1331, 1331, 1449], [1708, 1708, 1733, 1733, 1939], [3344, 3344, 3363, 3363, 3396], [3399, 3444, 3472, 3472, 3734], [3736, 3736, 3774, 3774, 4117], [4119, 4119, 4181, 4181, 4448], [4450, 4495, 4572, 4572, 4946], [5063, 5063, 5084, 5084, 5772], [5774, 5774, 5831, 5831, 6405]], "test": "error"}
{"id": "3s3BzS", "name": "Lissajous' fish?", "author": "joeypuggy", "description": "boring diwali", "tags": ["newb"], "likes": 1, "viewed": 51, "published": "Public", "date": "1605359147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 l3d(float t, vec3 d, vec3 w) //lissajous curve\n{\n    vec3 pos;\n    pos.x = sin(w.x*t + d.x);\n    pos.y = sin(w.y*t + d.y);\n    pos.z = sin(w.z*t + d.z);\n    return pos;\n}\n\nfloat bg (vec2 uv) //pseudorandom noise, raggedy fractional part of sin(x)\n{\n    return fract(sin(length(uv)*(sin(0.005*iTime)+1.)*1000.));\n}\n\nfloat cheapSigmoid(float start, float end, float x)\n{\n  x = clamp((x - start) / (end - start), 0.0, 1.0); \n  return x * x * (3. - 2. * x);\n}\n\nvec3 blip(vec2 uv, vec3 pos, float r) //fish component? kind of? \n{\n    uv -= .5;\n    uv -= vec2(pos.x, pos.y);\n    uv.x *= iResolution.x/iResolution.y;\n    float d = length(uv);\n    vec3 c = vec3(cheapSigmoid(r, r+0.02, d)) * vec3(1.1,1.1,1.) + vec3(.06,.05,.005)/20.;\n    \n    return c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = fragCoord/iResolution.xy;  \n    \n    vec3 c = vec3(1.);    \n    \n    //fish\n    \n    for(int i =0; i < 9; i++)\n    {\n        vec3 pos = l3d(iTime-float(i)/49.0, vec3(5,2,4-i), vec3(7,9,2)/5.);\n        c*= blip(uv, pos/2.0, ((pos.z+1.0)/2.0)/30.0);\n    }\n     for(int i =0; i < 9; i++)\n    {\n        vec3 pos = l3d(iTime-float(i)/49.0, vec3(5,2,4-i), vec3(5,4,3)/2.);\n        c*= blip(uv, pos/2., ((pos.z+1.0)/2.0)/30.0);\n    }\n      for(int i =0; i < 9; i++)\n    {\n        vec3 pos = l3d(iTime-float(i)/49.0, vec3(5,2,4-i), vec3(3,7,3)/2.);\n        c*= blip(uv, pos/2., ((pos.z+1.0)/2.0)/30.0);\n    }\n      for(int i =0; i < 9; i++)\n    {\n        vec3 pos = l3d(iTime-float(i)/49.0, vec3(5,2,4-i), vec3(9,3,5)/2.8);\n        c*= blip(uv, pos/2., ((pos.z+1.0)/2.0)/30.0);\n    }\n    \n      for(int i =0; i < 10; i++)\n    {\n        vec3 pos = l3d(iTime-float(i)/49.0, vec3(5,2,4-i), vec3(2,3,5)/1.1);\n        c*= blip(uv, pos/2., ((pos.z+1.0)/2.0)/30.0);\n    }\n    \n     \n    \n    uv -= vec2(.5,.5);\n    \n    if(length(c) > 10.)\n    {\n        c = vec3(bg(uv),bg(uv),bg(uv))/4.;\n        \n    }\n    \n    c = 1.-c;\n    \n    fragColor = vec4(c,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3BzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 53, 53, 175], [177, 177, 253, 253, 318], [320, 320, 373, 373, 460], [462, 462, 529, 529, 752], [754, 754, 811, 811, 1974]], "test": "valid"}
{"id": "3s3fR7", "name": "Swirling colors", "author": "RamiSlicer", "description": "with movement", "tags": ["colorful", "swirls"], "likes": 1, "viewed": 49, "published": "Public", "date": "1604592054", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float speed1 = 0.5;\nconst float factor1 = 0.05;\nconst float base1 = 1.0;\n\nconst float speed2 = 0.1;\nconst float factor2 = 0.1;\nconst float base2 = 0.0;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 one = vec2(sin(iTime*speed1+0.2)*factor1+base1, cos(iTime*speed1-0.2)*factor1+base1);\n\tvec2 two = vec2(cos(iTime*speed2)*factor2+base2, sin(iTime*speed2)*factor2+base2);\n    \n    vec2 t = uv + two;\n    for (int i = 0; i < 10; i++) {\n        vec2 temp = t;\n        temp.x = sin(t.x) + t.y * one.x;\n        temp.y = cos(t.y) * t.x * one.y;\n        t = temp;\n        temp.x = cos(t.x) + t.y * one.x / one.y;\n        temp.y = sin(t.y) * t.x * one.y / one.x;\n        t = temp;\n    }\n    t = normalize(t);\n    vec3 color = vec3(t.x, t.y, 0.0);\n    \n    fragColor = vec4(color, 0.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3fR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[159, 159, 216, 266, 901]], "test": "valid"}
{"id": "3s3fRS", "name": "Dragon Tail", "author": "Roninkoi", "description": "It's a dragon rawrr", "tags": ["dragon", "wings", "tail"], "likes": 4, "viewed": 228, "published": "Public API", "date": "1605352103", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265\n#define MAXIT 160\n#define EPSILON 0.005\n \n#define minx4(a, b) ((a.w) < (b.w) ? (a) : (b))\n#define minx2(a, b) ((a.x) < (b.x) ? (a) : (b))\n\n#define TAILCOL 1.0\n#define WINGCOL 2.0\n \nmat3 rotX(float a)\n{\n    return mat3(\n        1., 0., 0.,\n        0., cos(a), -sin(a),\n        0., sin(a), cos(a)\n    );\n}\n \nmat3 rotY(float a)\n{\n    return mat3(\n        cos(a), 0.0, -sin(a),\n        0., 1., 0.,\n        sin(a), 0.0, cos(a)\n    );\n}\n \nmat3 rotZ(float a)\n{\n    return mat3(\n        cos(a), -sin(a), 0.,\n        sin(a), cos(a), 0.,\n        0., 0., 1.\n    );\n}\n\nfloat t;\n\nfloat sphere(vec3 r, float a)\n{\n    return length(r) - a;\n}\n \nfloat torus(vec3 r, vec2 a)\n{\n    vec2 p = vec2(length(r.xz) - a.x, r.y);\n    return length(p) - a.y;\n}\n \nfloat plane(vec3 r, vec3 o, vec3 n) {\n    return dot(r - o, n);\n}\n\nfloat cylinder(vec3 r, vec2 a)\n{\n\tvec2 p = abs(vec2(length(r.xz), r.y)) - a;\n\t\n\treturn min(max(p.x, p.y), 0.0) + length(max(p, 0.));\n}\n\nfloat hash(vec2 r) {\n    return fract(sin(dot(r, vec2(15.5921, 96.654654))) * 23626.3663);\n}\n\nfloat tail(vec3 r, vec3 a)\n{\n\tfloat s = max(1., r.y*0.05);\n\tr.z += 2.1;\n\tr *= rotY(r.y * 0.1 * sqrt(s));\n\tr.x += sin(r.y * 0.5 - t) * 5. / s;\n\tr *= rotY(r.y * 0.1 + t);\n\ta.xz /= s;\n    vec3 p = (abs(r) - a);\n\tp.xz /= max(1., p.y * 0.4);\n\t\n\tfloat u = 4.;\n\tp.y = mod(p.y + u, u*0.78) - u;\n\tp.y *= 0.4;\n\tp += min(sin(length(p.xz+p.y*1.6)*5.), 0.) * length(a.xz) * 0.5;\n\t\n    return length(max(p, 0.));\n}\n\nfloat wing(vec3 r, vec3 a)\n{\n\tr *= rotZ(r.x * 0.006 * cos(t + 0.7));\n\tr.x = abs(r.x);\n\tr.y -= 5.;\n\tr.z -= 15.;\n\tr.y -= sin(r.x * 0.07 + 0.8 - t*1.) * 2.5 + \n        sin(r.x * 1.55 + 0.5) * abs(sin(t * 4.51) * sin(t*2.21)) * 0.3 - 1.5;\n\tr *= rotX(sin(5.5*t)*0.1 + 0.01 * r.x * sin(3.2*t)*0.2 + r.x * 0.01);\n\t\n    vec3 p = (abs(r) - a);\n\tp.z -= p.x * 0.03;\n\tp.z -= 1. / p.x * 14.0;\n\tp.y -= p.x * 0.02;\n\tp.y -= 0.2 / (sin(p.x*0.02));\n\t\n\tp.z -= (0.5-sign(r.z)) * 0.1 / max(0.1, abs(sin(p.x*0.8))) * (sin(p.x*0.25 + 1.8)*0.6+1.0);\n\tp.y += 2.0/max(1.1, abs(p.z));\n\n    return length(max(p, 0.));\n}\n \nfloat shade(vec3 n, vec3 rd)\n{\n    return clamp(max(dot(n, -rd), 0.) + 1., 0., 1.);\n}\n \nvec3 fog(float z, vec3 col, vec3 fogCol)\n{\n    return mix(fogCol, col, exp(-z));\n}\n\nmat3 obj;\n\nvec2 map(vec3 r)\n{    \n\tobj = mat3(1.6)* rotY(t) * rotX(sin(t)*0.1+1.5);\n\tr.y += 2. + sin(t) * 2. + 4.;\n\tvec3 rb1 = obj * r;\n\trb1.y += 12.;\n\t\n\tfloat s = 15.;\n\tvec2 b1 = vec2(\n\t\ttail(rb1, vec3(1., 4., 1.)), TAILCOL\n\t);\n\tvec3 rb2 = r;\n\tvec2 b2 = vec2(\n\t\twing(rb2, vec3(54., 2.4, 6.)), WINGCOL\n\t);\n\n    return minx2(b1, b2);\n}\n\nvec3 matCol(vec2 o)\n{\n    if (o.y == TAILCOL)\n        return vec3(0.1 + o.x * 40., 0.3, 0.);\n    \n    if (o.y == WINGCOL)\n        return vec3(0.05, 0.15, 0.0);\n    \n    return vec3(0.2, 0.4, 0.);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    t = iTime;\n   \n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n   \n    mat3 cam = rotY(-PI) * rotX(0.3);\n       \n    vec3 ro = vec3(0., 2.0, -10.0);\n    vec3 rd = cam * normalize(vec3(uv * 2., -1.));\n    vec3 r = ro;\n   \n    vec3 bcol = vec3(0.2, 0.0, 0.0)*(4.5+sin(t*10.-abs(uv.y*uv.x) * 15.)) / 15.;\n    vec4 col = vec4(0.);\n    col.rgb = bcol;\n   \n    float sh = 1.;\n   \n    float glow = 0.;\n   \n    int ch = 1;\n   \n    for (int i = 0; i < MAXIT; ++i) {\n        vec2 d = map(r);\n        float z = length(r - ro);\n       \n        glow += exp(-d.x);\n    \n        if (d.x < EPSILON) {\n            col.rgb = mix(col.rgb, \n\t\tmatCol(d), \n\t\tshade(normalize(r), rd));\n            col.rgb = fog(z * 0.03, col.rgb, bcol);\n            break;\n        }\n       \n        d.x *= 0.8 - 0.2 * hash(uv);\n\t\tr += rd * d.x * 0.3;\n       \n        sh = (float(i) / float(MAXIT));\n    }\n   \n    if (sh < 0.5)\n\tcol.rgb *= exp(-sh * 2.0 + 1.0);\n   \n    fragColor = vec4(col.rgb, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3fRS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[203, 203, 223, 223, 325], [328, 328, 348, 348, 452], [455, 455, 475, 475, 577], [589, 589, 620, 620, 648], [651, 651, 680, 680, 754], [757, 757, 794, 794, 822], [824, 824, 856, 856, 958], [960, 960, 980, 980, 1052], [1054, 1054, 1082, 1082, 1454], [1456, 1456, 1484, 1484, 2047], [2050, 2050, 2080, 2080, 2135], [2138, 2138, 2180, 2180, 2220], [2233, 2233, 2251, 2251, 2556], [2558, 2558, 2579, 2579, 2755]], "test": "valid"}
{"id": "3s3fWH", "name": "2D triangle texture renderer", "author": "HalbFettKaese", "description": "Mainly useful for rasterization.", "tags": ["triangle", "texture"], "likes": 1, "viewed": 59, "published": "Public", "date": "1604920460", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n/*\nParametric plane equation:\nuv = v1 * t + v2 * s\n I.  uv.x = v1.x * t + v2.x * s\n II. uv.y = v1.y * t + v2.y * s\n \nII. * v1.x; I. * v1.y:\n I.  uv.x * v1.y = v1.x * v1.y * t + v2.x * v1.y * s\n II. uv.y * v1.x = v1.y * v1.x * t + v2.y * v1.x * s\n \nII. * v1.x - I. * v1.y:\n II. uv.y * v1.x - uv.x * v1.y = (v2.y * v1.x - v2.x * v1.y) * s\n II. (uv.y * v1.x - uv.x * v1.y)/(v2.y * v1.x - v2.x * v1.y) = s\n II. s = (uv.y * v1.x - uv.x * v1.y)/(v2.y * v1.x - v2.x * v1.y)\n\nTake initial I. and solve to t\n I.  uv.x = v1.x * t + v2.x * s\n I.  uv.x - v2.x * s = v1.x * t\n I.  (uv.x - v2.x * s)/v1.x = t\n I.  t = (uv.x - v2.x * s)/v1.x\n*/\n\nvec2 solvePlane(vec2 uv, vec2 p1, vec2 p2, vec2 p3) {\n    float eps = 1./max(iResolution.x, iResolution.y);\n    \n\tuv -= p1;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = p3 - p1;\n    if (abs(v1.x) < eps) v1.x = eps; // avoiding division by 0\n    float a = (v2.y * v1.x - v2.x * v1.y);\n    if (abs(a) < eps) a = eps; // avoiding division by 0\n    float s = (uv.y * v1.x - uv.x * v1.y)/a;\n    float t = (uv.x - v2.x * s)/v1.x;\n    return vec2(s, t);\n}\n\nvoid triangle(vec2 uv, inout vec3 col, vec2 p1, vec2 p2, vec2 p3, bool f) {\n    float eps = 1./max(iResolution.x, iResolution.y);\n    // Renders triangle if s > 0, t > 0 and s + t < 1, inputs s and t into the texture\n    vec2 params = solvePlane(uv, p1, p2, p3);\n    vec2 tparams = params;\n    if (f) tparams = 1. - tparams;\n\tcol = mix(col, texture(iChannel0, tparams).rgb, step(0., params.x) * step(0., params.y) * (1. - step(1. + eps, params.y + params.x)));\n}\n\nvoid parallelogram(vec2 uv, inout vec3 col, vec2 p1, vec2 p2, vec2 p3) {\n    // Renders parallelogram if 0 < s < 1 and 0 < s < 1, inputs s and t into the texture\n    vec2 params = solvePlane(uv, p1, p2, p3);\n\tcol = mix(col, texture(iChannel0, params).rgb, step(0., params.x) * step(0., params.y) * (1. - step(1., params.x))* (1. - step(1., params.y)));\n}\n\nvoid normalizeUV(inout vec2 uv) {\n\tuv /= iResolution.yy;\n    \n    uv -= .5;\n    \n    uv *= 3.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord;\n    normalizeUV(uv);\n    \n    vec2 M = iMouse.xy;\n    normalizeUV(M);\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    \n    triangle(uv, col, M, vec2(1, 0), vec2(0, 1), false);\n    \n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRn", "previewfilepath": "/media/ap/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/10eb4fe0ac8a7dc348a2cc282ca5df1759ab8bf680117e4047728100969e7b43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3fWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[632, 632, 685, 685, 1072], [1074, 1074, 1149, 1149, 1536], [1538, 1538, 1610, 1699, 1892], [1894, 1894, 1927, 1927, 1990], [1992, 1992, 2049, 2099, 2418]], "test": "error"}
{"id": "3s3fWX", "name": "Domain warped sludge", "author": "freedmand", "description": "Adapting domain warping from iq in interesting ways with powers and other perturbations", "tags": ["noise", "texture"], "likes": 0, "viewed": 206, "published": "Public API", "date": "1606090463", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Modified from domain warping techniques by iq\n// https://www.iquilezles.org/www/articles/warp/warp.htm\n\nconst mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\nconst mat2 m2 = mat2( 0.13,  0.09, -0.3,  0.19 );\n\nconst vec2 noiseOffset = vec2(0.0, 0.0);\nconst float initialFrequency = 10.0;\n\nfloat noise( in vec2 p )\n{\n\treturn sin(p.x) * sin(p.y);\n}\n\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p*2.02;\n    f += 0.2500*noise( p ); p = m*p*2.03;\n    f += 0.1250*noise( p ); p = m*p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += pow(0.500000*(0.5+0.5*noise( p )), 5.0); p = m*p*2.02;\n    f += pow(0.250000*(0.5+0.5*noise( p )), 0.2); p = m*p*2.03;\n    f += pow(0.125000*(0.5+0.5*noise( p )), 1.0); p = m2*p*2.01;\n    return f/0.96875;\n}\n\nvec2 fbm4_2( vec2 p )\n{\n    return vec2(pow(fbm4(p), 2.0), pow(fbm4(p+vec2(7.8)), 3.0));\n}\n\nvec2 fbm6_2( vec2 p )\n{\n    return vec2(fbm6(p+vec2(16.8)), fbm6(p+vec2(11.5)));\n}\n\nfloat onoise(vec2 v, float t) {\n  v = (v + noiseOffset) * initialFrequency;\n  vec2 o = fbm4_2( sin(t / 10.0)*v + vec2(noise(v), noise(v * 1.2)) ) * m;\n  o += 0.04*sin( vec2(0.12,0.14) + length(o));\n\n  vec2 n = fbm6_2( 3.0*(o + vec2(noise(o), noise(v * 1.2)))) + o * m2 * 5.0;\n\n  return pow(0.5 + 0.5*fbm4( 1.8*v + 6.0*n ), 0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(onoise(uv, iTime));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3fWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[287, 287, 313, 313, 344], [346, 346, 368, 368, 564], [566, 566, 588, 588, 824], [826, 826, 849, 849, 916], [918, 918, 941, 941, 1000], [1002, 1002, 1033, 1033, 1332], [1334, 1334, 1391, 1441, 1612]], "test": "valid"}
{"id": "3s3fz8", "name": "Asymmetric speed of light", "author": "CoolerZ", "description": "Different spatial periods caused by asymmetric speed of light.\nThe speed of light is different in different directions.\nThe direction in which speed of light is faster has larger spatial period.", "tags": ["waves", "physics", "asymmetry"], "likes": 4, "viewed": 84, "published": "Public", "date": "1604302058", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define STEP .2\n#define XLIM 1.\n#define YLIM 1.\n#define LIGHTSPEED .2\n#define TIMEVARYING 0\n\nfloat circ(vec2 p) {\n    const float r = .1;\n    return length(p)-r;\n}\n\nfloat oracle(vec2 p, float t) {\n    float dist = circ(p+vec2(sin(t),0.));\n    return smoothstep(0.1, 0., dist);\n}\n\nfloat electricfield(vec2 p, float t) {\n    float acc = 0.;\n    int count = 0;\n    for(float y = -YLIM; y <= YLIM; y+=STEP) {\n        for(float x = -XLIM; x <= XLIM; x+=STEP) {\n            vec2 q = vec2(x, y);\n            float d = length(p - q);\n            vec2 direction = normalize(p - q);\n            float angle = atan(direction.y, direction.x);\n            #if TIMEVARYING\n            float speed = (.6+.4*sin(angle+.5*t))* LIGHTSPEED;\n            #else\n            float speed = (.6+.4*sin(angle))* LIGHTSPEED;\n            #endif\n            float delay = d/speed;\n            acc += oracle(q, t-delay);\n            count++;\n        }\n    }\n    return acc*10./float(count);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n    float foreground = oracle(uv, iTime);\n    float background = electricfield(uv, iTime);\n\n    vec3 col = vec3(foreground + background);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3s3fz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 113, 113, 163], [165, 165, 196, 196, 278], [280, 280, 318, 318, 962], [964, 964, 1019, 1019, 1249]], "test": "valid"}
{"id": "3scBzf", "name": "Icecream world", "author": "jpupper", "description": "Looks like you want to step in and eat the icecream and die of diabetes", "tags": ["raymarching"], "likes": 3, "viewed": 106, "published": "Public", "date": "1605632552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n#define pi 3.14159265359\n\n// COPIAR OBJETOS A LO LARGO DE VARIOS EJES\n\n// utilizando la funcin mod, podemos repetir objetos en la escena\n\n// VARIABLES GLOBALES\n\nfloat det = 0.004;\nfloat maxdist = 1000.;\n\nint maxsteps = 1000;\n\nvec3 objcol;\n\n// FUNCION DE ROTACION\n\nmat2 rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c,s,-s,c);\n}\n\n\n// FUNCIONES DE DISTANCIA PRIMITIVAS \n\nfloat sphere(vec3 p, float rad) \n{\n    return length(p) - rad;\n}\n\nfloat box(vec3 p, vec3 c)\n{\n    p=abs(p)-c;\n    return length(max(p,0.))+min(0.,max(p.z,max(p.x,p.y)));\n}\n\nfloat ground(vec3 p, float y) \n{\n    p.y += y;\n    return abs(p.y);\n}\n\n\n// FUNCION DE ESTIMACION DE DISTANCIA\nfloat mapr(float _value,float _low2,float _high2) {\n    float val = _low2 + (_high2 - _low2) * (_value - 0.) / (1.0 - 0.);\n    //float val = 0.1;\n    return val;\n}\n\n\n\n\nfloat sdCone( vec3 p, vec2 c, float h )\n{\n  float q = length(p.xz);\n  return max(dot(c.xy,vec2(q,p.y)),-h-p.y);\n}\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat de(vec3 p) \n{\n\n\n    float box = 1.;\n    vec3 pos = p;\n    float pz = abs(fract(sin(p.z*0.33)*1.0-1.));\n    \n    float cnt = 4.;\n    vec3 col1 = vec3(0.9,0.2,0.7);\n    vec3 col2 = vec3(0.4,0.5,0.8);\n   \n    for(float i=0.; i<cnt; i++){\n        float index = i/float(cnt);\n        float ms = 5.;\n       // p.x+= i;\n      //    p.z+= sin(index*pi*+time);\n        p.x = mod(p.x, ms) - ms/2.;\n        p.z = mod(p.z, ms*2.) - ms*2./2.;\n        vec3 pbox = p;\n        vec3 pcono = p;\n        pcono.y -=1.5;\n        pcono.x+= sin(pcono.y*10.+iTime)*0.2;\n        \n        float mof = cos(p.z*4.+index*pi*4.+iTime)*0.04;\n        box = min(box,sdCone(pcono,vec2(0.1+mof,0.01+index*0.05+mof),8.1));   \n        \n        vec3 col11 = vec3(0.7,0.7,0.7);\n        vec3 col12 = vec3(0.7,0.7,0.7);\n        vec3 col21 = vec3(0.8,0.2,0.8);\n        vec3 col22 = vec3(0.8,0.3,0.4);\n        \n        col1 = mix(col11,col12,index);\n        \n        col2 = mix(col21,col22,index);\n    }\n    vec3 pospiso = pos;\n   // pospiso.z+=sin(time);\n    //pospiso.y+=sin(p.x*10)*0.2+0.5;\n    //pospiso.xy = vec2(sin(p.x));\n    pospiso.y += cos(pospiso.x*3.+pospiso.z*4.)*.1;    \n    pospiso.y += sin(pospiso.z*4.+pospiso.y*4.)*.1;    \n    float pla = ground(pospiso, 0.8);\n    \n    float d = box;\n    \n    d = min(box,pla);\n    // para generar el cuadriculado   \n   \n    float c = pow(max(max(fract(p.x),fract(p.y)), fract(p.z)),0.5);\n    float b = pow(max(fract(p.x),fract(p.z)),5.);\n\n   // length(fract(pos.xz));\n  //  if (d==box) objcol=vec3(0.8-pz,sin(length(fract(pos.zz))*1)*0.7,pz);\n \n  \n   \n   \n   \n   \n    if (d==box) objcol=mix(col1,col2,pz);\n    if (d==pla) objcol=vec3(0.7,0.7,0.7);\n\n\n\n    return d *.7;\n}\n\n// FUNCION NORMAL\n\nvec3 normal(vec3 p) \n{   \n    vec2 d = vec2(0., det);\n    \n    return normalize(vec3(de(p + d.yxx), de(p + d.xyx), de(p + d.xxy)) - de(p));\n}\n\n// FUNCION SHADOW\n// calcula la sombra, generando un efecto de suavizado de los bordes\n// a medida que se aleja del objeto\n\nfloat shadow(vec3 p, vec3 ldir) {\n    float td=.001,sh=150.,d=det;\n    \n    for (int i=0; i<0; i++) {\n        p+=ldir*d;\n        d=de(p);\n        td+=d;\n        sh=min(sh,1.*d/td);\n        if (sh<.001) break;\n    }\n    return clamp(sh,0.,0.9);\n}\n\n\n// FUNCION SHADE\n\nvec3 shade(vec3 p, vec3 dir) {\n\n    vec3 col = objcol;\n    \n    vec3 lightdir = normalize(vec3(sin(iTime)*0.5+0.5, 0.9, 0.9)); \n\n    vec3 n = normal(p);\n\n    float sh = shadow(p, lightdir);    \n    \n    float diff = max(0.0, dot(lightdir, n)) * sh; // multiplicamos por sombra;\n    \n    vec3 refl = reflect(dir, n);\n    \n    float spec = pow(max(0., dot(lightdir, refl)), 0.01) * sh; // multiplicamos por sombra;\n    \n    float amb = .1;\n    \n    return col*(amb*6.0 + diff) + spec * 0.1;\n    \n}\n\n\n\n// FUNCION DE RAYMARCHING\n\nvec3 march(vec3 from, vec3 dir) \n{\n\n    float d, td=0.;\n    vec3 p, col;\n\n\n    for (int i=0; i<maxsteps; i++) \n    {\n        p = from + td * dir;\n\n        d = de(p);\n\n        if (d < det || td > maxdist) break;\n\n        td += d;\n    }\n\n    if (d < det)\n    {\n        p -= det * dir;\n        col = shade(p, dir);\n    } else {\n        // si no golpeo con ningun objeto, llevamos la distancia a la mxima\n        // que se defini, o sea al fondo de la escena\n        // esto sirve para el correcto clculo de la niebla\n        td = maxdist;\n    }\n    // efecto niebla\n    // mix entre el color obtenido y un color de la niebla\n    // utilizando para mezclarlos la funcion exp con la variable td\n    // que es la distancia en la que quedo el rayo con respecto a la cam\n    // el -.01 en la funcion exp altera la distancia de la niebla\n    \n    vec3 colfondo = vec3(1.-p.y,1.-p.y,1.-p.y);\n    \n    float f = sin(dir.z*100.+iTime)*0.5+0.5;\n    vec3 col1 = vec3(0.8,0.3,0.4);\n    vec3 col2 = vec3(0.7,0.7,0.7);\n    vec3 colf = mix(col1,col2,f);\n  //  colfondo = col1;\n    col = mix(colf,col, exp(-.0005*td*td));\n    return col;    \n}\n\n\n// MAIN\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \n    vec2 uv = gl_FragCoord.xy/iResolution.xy - .5; \n\n    uv.x *= iResolution.x / iResolution.y; \n    \n    vec3 from = vec3(0., 0.,2.);\n    //from.z-=time*0.1;\n    vec3 dir = normalize(vec3(uv, 1.));\n\n    //una forma simple de rotar la cmara\n    //es rotando en los mismos ejes tanto from como dir\n    from.xz *= rot(iTime*.2);\n    \n    from.z-=iTime*1.;\n    from.y+=sin(iTime*.001);\n     from.y+=1.9;\n    //dir.xz *= rot(time*.2);\n    //dir.xy *= rot(time*.02);\n   // dir.z+= sin(time)*0.8;\n    vec3 col = march(from, dir);\n\n    fragColor = vec4(col, 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scBzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[267, 267, 286, 286, 345], [387, 387, 421, 421, 451], [453, 453, 480, 480, 558], [560, 560, 592, 592, 629], [632, 670, 721, 721, 833], [838, 838, 879, 879, 951], [952, 952, 987, 987, 1011], [1012, 1012, 1031, 1031, 2698], [2719, 2719, 2741, 2741, 2860], [2986, 2986, 3019, 3019, 3231], [3252, 3252, 3282, 3282, 3747], [3778, 3778, 3812, 3812, 4908], [4920, 4920, 4977, 4977, 5539]], "test": "valid"}
{"id": "3scfR8", "name": "Three moving circles", "author": "ARustyNickel", "description": "Draws three circles being modulated by sin waves. I think it looks neat, especially when the circles meet at the center.", "tags": ["circles"], "likes": 2, "viewed": 62, "published": "Public", "date": "1604291429", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot_circle(vec2 pixel, float radius, float line_width)\n{\n    return smoothstep(0.0f, 1.0f, (abs(pixel.x * pixel.x + pixel.y * pixel.y - radius * radius) * iResolution.y / line_width));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n    vec2 uv = fragCoord - iResolution.xy / 2.0f; // Convert pixel coordinate into [-iResolution / 2, iResolution / 2] from [0, iResolution]\n    uv /= min(iResolution.x, iResolution.y); \t // Divide by the shorter axis to constrain coordinate in [-1, 1] along shorter axis\n\n    float radius_1 = (sin(iTime) + 1.0f) / 4.0f;\n    float radius_2 = (sin(iTime + 120.0f) + 1.0f) / 4.0f;\n    float radius_3 = (sin(iTime + 240.0f) + 1.0f) / 4.0f;\n    \n    fragColor = vec4(\n        mix(vec3(1.0f, 1.0f, 0.0f), vec3(0.0f, 0.0f, 0.0f), plot_circle(uv, radius_1, 1.0f)) +\n        mix(vec3(0.0f, 1.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), plot_circle(uv, radius_2, 1.0f)) +\n        mix(vec3(1.0f, 0.0f, 1.0f), vec3(0.0f, 0.0f, 0.0f), plot_circle(uv, radius_3, 1.0f)),\n        1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3scfR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 193], [195, 195, 250, 250, 1018]], "test": "valid"}
{"id": "3sdBDf", "name": "Binary Shader", "author": "Tech_", "description": "010101000110100001101001011100110010000001101001011100110010000001100001001000000110110001101001011101000111010001101100011001010010000001110011011010000110000101100100011001010111001000100000010010010010000001101101011000010110010001100101001000010010000", "tags": ["simple", "binary"], "likes": 5, "viewed": 252, "published": "Public API", "date": "1606153228", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat getZero(in vec2 uv) \n{\n    float v;\n\tv += 1. - smoothstep(0.43, 0.445, distance(uv * vec2(1.4, 1.0) - vec2(0.37, 0.0), vec2(0.5)));\n\tv -= 1. - smoothstep(0.33, 0.345, distance(uv * vec2(1.5, 1.0) - vec2(0.43, 0.0), vec2(0.5)));\n\treturn v;\n}\n\nfloat getOne(in vec2 uv) \n{\n\tfloat v;\n    uv *= 1.1;\n    uv.x -= 0.28;\n    v += smoothstep(0.9, 0.915, 1. - distance(uv.x, 0.5) * 2.0);\n    v *= smoothstep(0.25, 0.265, 1. - distance(uv.y, 0.5) * 2.0);\n    v += smoothstep(0.87, 0.885, 1. - distance(uv.x - 0.02 - uv.y + 0.89, 0.5) * 2.0);\n    v = clamp(v, 0.0, 1.0);\n    v *= smoothstep(0.55, 0.565, 1. - distance(uv.x + 0.18, 0.5) * 2.0);\n    v *= 1. - smoothstep(0.55, 0.565, 1. - distance(uv.x + 0.52, 0.5) * 2.0);\n    return v;\n}\n\nfloat psrndNum(float v){\n    return cos(v + cos(v * 90.1415) * 100.1415) * 0.5 + 0.5;\n}\n\nfloat getLayer(in vec2 uv, float scale, float speed) \n{\n    uv += vec2(0.25 * iTime * speed, 1.0 * iTime * speed);\n \tuv *= scale;\n    \n    vec2 lv = fract(uv * 12.0 + 1.0);\n    vec2 id = floor(uv * 12.0 + 1.0);\n    \n\tfloat result;\n    \n    float randId = fract(psrndNum(id.x * id.y + id.x + id.y) + iTime * 2.6);\n    if(randId < 0.5) {\n    \tresult += getZero(lv);\n    } else {\n    \tresult += getOne(lv);\n    }\n    \n    float s = psrndNum((id.y * id.x + id.y) * 0.001 + iTime * 0.0003);\n    s = step(s, 0.5);\n    \n    return result * s;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= 2.0;\n    \n    // Time varying pixel color\n    vec3 col;\n    col += getLayer(uv, 0.7, 0.5) * vec3(0.0, 0.8, 0.0);\n    col += getLayer(uv, 0.9, 0.4) * vec3(0.0, 0.4, 0.0);\n    col += getLayer(uv, 0.9, 0.25) * vec3(0.0, 0.2, 0.0);\n    col += getLayer(uv, 1.1, 0.2) * vec3(0.0, 0.1, 0.0);\n   \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdBDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 247], [249, 249, 276, 276, 732], [734, 734, 758, 758, 821], [823, 823, 878, 878, 1360], [1362, 1362, 1419, 1469, 1909]], "test": "valid"}
{"id": "3sdBR7", "name": "Box grid warp", "author": "020406", "description": "Just playing around with some sine waves.", "tags": ["grid", "blackandwhite", "warp"], "likes": 3, "viewed": 103, "published": "Public", "date": "1604681345", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float myMod(float x, float y) {\n    return x - y * floor(x/y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.yy;\n    float zoom = 0.1 + 0.5 * (1. + sin(iTime * 0.1));\n    float div = 35. * zoom;\n    \n    float f = 0.5 + 1. * (1. + sin(uv.y + iTime*0.7));\n    float f2 = 0.5 + 1. * (1. + sin(uv.x + iTime*1.1));\n    bool black = myMod(uv.x * div, f * 2.) < 1.;\n    bool black2 = myMod(uv.y * div, f2 * 2.) < 1.;\n    black = black && black2;\n\n    // Time varying pixel color\n    vec3 col = vec3(black ? 0. : 1.);\n    \n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 31, 31, 64], [66, 66, 123, 173, 674]], "test": "valid"}
{"id": "3sdBR8", "name": "Glowballs'2", "author": "MasterQ32", "description": "Some glowing balls", "tags": ["sdf", "spheres", "glow"], "likes": 1, "viewed": 70, "published": "Public", "date": "1604348201", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdSphere(vec3 p, float r)\n{\n \treturn length(p) - r;   \n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n// exponential smooth min (k = 32);\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nmat2 rot(float r)\n{\n \treturn mat2(\n        cos(r), -sin(r),\n        sin(r), cos(r)\n    );\n}\n\nstruct Dist {\n    float d;\n    vec3 color;\n};\n    \n    Dist dmin(Dist a, Dist b) {\n\t\tif(a.d < b.d)\n            return a;\n        else\n            return b;\n    }\n\nDist sdf(vec3 p)\n{\n    Dist d = Dist(10000.0, vec3(0));\n    vec3[] c = vec3[](\n        vec3(1,0,0),\n        vec3(0,1,0),\n        vec3(0,0,1)\n    );\n    for(int i = 0; i < 3; i++) {\n        d = dmin(d, Dist(\n            sdSphere(p - vec3(vec2(0.8,0) * rot(2.0 * float(i) + iTime),0).xzy, 0.5),\n            c[i])\n\t\t);\n    }\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 xy = 2.0 * uv - 1.0;\n    xy.x *= iResolution.x / iResolution.y;\n    \n    vec3 col = 0.2 * vec3(0.3,0.8,1.0);\n    \n   \tvec3 pos = vec3(\n        0.,//2.0 * iMouse.x / iResolution.x - 1.0,\n        2.,//2.0 * iMouse.y / iResolution.y - 1.0,\n        -1.8\n\t);\n    vec3 dir = normalize(vec3(0.5*xy, 1.0));\n    \n    dir.yz *= rot(0.9);\n    \n    vec3 light = normalize(vec3(1.9, 2.9, -0.8));\n    \n    vec3 glow = vec3(0);\n    \n    vec2 eps = vec2(0.0001, 0.0);\n\tfor(int i = 0; i < 32; i++) {\n        Dist d = sdf(pos);\n        if(d.d <= eps.x) {\n            vec3 n = normalize(vec3(\n                sdf(pos + eps.xyy).d - sdf(pos - eps.xyy).d,\n                sdf(pos + eps.yxy).d - sdf(pos - eps.yxy).d,\n                sdf(pos + eps.yyx).d - sdf(pos - eps.yyx).d\n            ));\n            \n            float l = clamp(dot(light, n), 0., 1.);\n            \n            l = pow(floor(16. * l) / 16., 2.0);\n            \n            col = vec3(0.2 + 0.8 * l) * d.color;\n         \tbreak;\n        }\n        else if(d.d < 0.3) {\n         \tglow += 5.0 * pow(2.5 * d.d,4.0) * d.color * float(i) / 31.0;\n        }\n        pos += d.d * dir;\n    }\n    \n    col += glow;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdBR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 34, 34, 63], [65, 65, 96, 96, 183], [185, 221, 262, 262, 336], [338, 338, 357, 357, 429], [486, 486, 513, 513, 592], [933, 933, 990, 1040, 2304]], "test": "error"}
{"id": "3sdfD2", "name": "bg test 2", "author": "tsmca", "description": "fork of https://www.shadertoy.com/view/ltdSz4\n\nbackground test 2\n\n", "tags": ["dagda"], "likes": 2, "viewed": 32, "published": "Public", "date": "1606055765", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// fork of https://www.shadertoy.com/view/ltdSz4\n// Created by David Crooks\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\nstruct vec5 {\n    vec4 a;\n    float v;   \n};\n    \nvec5 plane5(vec5 origin, vec5 u, vec5 v, vec2 p){\n\treturn vec5(origin.a + p.x*u.a + p.y*v.a,\n                origin.v + p.x*u.v + p.y*v.v);\n}\n\nvec5 mult5(vec5 p, float multiplier) {\n    p.a *=  multiplier;\n    p.v *= multiplier;\n    return p;\n}\n\nvec5 mod5(vec5 p, float m) {   \n return vec5(mod(p.a,m),mod(p.v,m));   \n}\n\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nbool dualTileZoneTest(vec5 p , float value){\n    bool down  = all(lessThanEqual(vec4(value),p.a)) && value <= p.v && all(lessThanEqual(vec4(value),vec4(1.0)-p.a)) && value <= (1.0-p.v);\n    bool up  = all(greaterThanEqual(vec4(value),p.a)) && value >= p.v && all(greaterThanEqual(vec4(value),vec4(1.0)-p.a)) && value >= (1.0-p.v);\n    return down || up;\n}\n\nvec3 pattern(vec5 p ){\n    \n    float hueDelta = 16.0/24.0;\n    \n    p = mod5(p,1.0);\n    \n    if(dualTileZoneTest(p , p.a.x)){\n        return  hsv2rgb(vec3(0.45, 0.7, 0.75));\n    }\n    else if(dualTileZoneTest(p,  p.a.y)){\n         return hsv2rgb(vec3(0.5, 0.9,1.));\n    }\n    else if(dualTileZoneTest(p, p.a.z)){\n         return hsv2rgb(vec3(0.46, 0.7, 0.95));\n    }\n    else if(dualTileZoneTest(p, p.a.w)){\n         return hsv2rgb(vec3(0.45, 0.5, 0.7));\n    }\n    else if(dualTileZoneTest(p,  p.v)){\n     \n         return hsv2rgb(vec3(0.5,0.7, 0.6));\n    }\n    else {\n          return vec3(0.0);\n    }   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float scale = 2.;\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (fragCoord - 0.5*iResolution.xy) / iResolution.y;\n    \n    float time = 0.02*iTime;\n    \n    //This is the origin of our plane in 5d space.\n   \t//vec5 origin = vec5(vec4(0.1*time),time);\n    vec5 origin = vec5(vec4(time),-time);\n  \t\n    //We need two directions to form a plane.\n    //In 3d we can define a plane from a point on the plane (the origin) and a normal, using the cross product to find our two directions.\n    \n    //But this won't work in 5d. There is no cross product!\n   \t//There are many plane normal to vector, becasue there are four directions normal to a given vector. \n    //This is why there is no cross product in higher dimensions!\n    \n    //In analogy with the 3d case, we get interesting patterns in a plane normal to (1,1,1,1,1). (the long diagonal of a hypercube.)\n    //We can find a set of four vectors normal to (1,1,1,1,1) using the Gram Schmidt process\n    //https://en.wikipedia.org/wiki/Gram%E2%80%93Schmidt_process\n    //Any two will do:\n    \n    vec5 u = vec5(vec4(-0.511667,0.19544,0.19544,-0.511667)*scale,0.632456*scale) ;\n    vec5 v = vec5(vec4(-0.371748,0.601501,-0.601501,0.371748)*scale, 0.0*scale);\n    \n    vec5 plane = plane5(origin,u,v,p);\n    plane = mult5(plane,5.0);\n    \n    //Now we have mapped points in the image plane to 5d space we can color pixels based on whe=re thy are in 5d. \n    //We divide the space into a 5d lattice of hypercubes. For each point we find the closest face in the hypercube.\n    //We pair opposite faces to get 5 colors, corresponding to the 5 dimensions.\n    vec3 color = pattern(plane);\n    \n    fragColor =  vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdfD2.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[214, 214, 263, 263, 355], [357, 357, 395, 395, 458], [460, 460, 488, 488, 533], [535, 535, 557, 557, 726], [728, 728, 772, 772, 1083], [1085, 1085, 1107, 1107, 1694], [1696, 1696, 1753, 1753, 3444]], "test": "valid"}
{"id": "3sdfDf", "name": "Komet rain", "author": "Voldemar", "description": "Komet rain", "tags": ["kometrain"], "likes": 2, "viewed": 27, "published": "Public", "date": "1606156515", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\n\nfloat dist(vec3 p){\n    float scale=2.0;\n\n    int i;\n    for(i=0;i<29;i++){\n        if(i>0){\n        \tp.xz*=rot(iTime/20.);\n        \tp.xy*=rot(iTime/20.);\n        }\n        p*=scale;\n        p=abs(p);\n        p-=20.3;\n\t}\n\treturn (length(p)-.5)/pow(scale,float(i))*.7;\n}\n\nvec3 norm(vec3 p){\n    vec2 e=vec2(.0001,0.);\n    float dp=dist(p);\n\treturn normalize(vec3(\n    \tdp-dist(p-e.xyy),\n    \tdp-dist(p-e.yxy),\n        dp-dist(p-e.yyx)\n    ));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv=(FC*2.-iResolution.xy)/iResolution.y;\n    float e,d=0.;\n    vec3 p,rd=normalize(vec3(uv,1)),ro=vec3(0.,0.,.7);\n    ro.xz*=rot(iTime/10.);\n    rd.xz*=rot(iTime/10.);\n    int i;\n    for(i=0;i<99;i++){\n        p=rd*d-ro;\n        d+=e=dist(p);\n        if(e<.002)break;\n    }\n    //p.xz*=rot(iTime);\n    vec3 col=vec3(0.);\n    if(d<999.) col+=norm(p)*.9+.7;\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdfDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 65], [67, 67, 86, 86, 336], [338, 338, 356, 356, 510], [512, 512, 562, 562, 966]], "test": "valid"}
{"id": "3sdfRs", "name": "running uniform for api usage", "author": "jemappelle", "description": "literally just added some uniforms to the base shader, so i can present my work with laptop hardware", "tags": ["arbitrary"], "likes": 0, "viewed": 168, "published": "Public API", "date": "1605794864", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform float zMotion;\nuniform float lowFreqFFT;\nuniform float midFreqFFT;\nuniform float highFreqFFT;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+(vec3(0,2,4)*vec3(lowFreqFFT, midFreqFFT, highFreqFFT)));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdfRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 160, 210, 441]], "test": "error"}
{"id": "3sdfWf", "name": "Raymarching soft shadow sampling", "author": "me_123", "description": "the shadows have a random offset for every pixel.", "tags": ["raymarching"], "likes": 3, "viewed": 67, "published": "Public", "date": "1606155255", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\t\n*/\nfloat lightSample = 10.;\nfloat lightSize = 2.;\n\nfloat max_steps = 100.;\nfloat max_dist = 300.;\nfloat e = 0.00001;\nvec3 lightPos = vec3(sin(0.0)*10.,1, cos(1.0)*10.);\nvec3 rep( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nmat2 rot(float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat hash(vec2 p) {\n    p = 50.*fract(p*0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\nfloat SDF(vec3 p) {\n    vec3 np = p;\n   \tnp = rep(np, 5., vec3(2, 0, 2));\n\tfloat sp = smax(-sphere(np, 0.8), box(np, vec3(0.8)), 0.4);\n    //float sp = sphere(p, 1.0);\n    return smin(sp, p.y+0.8, 0.2);\n}\nfloat getDist(vec3 ro, vec3 rd) {\n    float d0 = 0.001;\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    float steps = 0.0; \n    vec3 c = vec3(0);\n    for (float i = 0.0; i < max_steps; i += 1.0) {\n        steps += 1.0;\n        vec3 p = roo + rdd*d0;\n        float ds = SDF(p);\n        d0 += ds;\n        if (ds<e||ds>max_dist) {\n            break;\n        };\n       \tc = p;\n    }\n    \n    return d0;\n}\nvec2 getL(vec3 ro, vec3 rd) {\n    float d0 = 0.001;\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    float steps = 0.0; \n    vec3 c = vec3(0);\n    for (float i = 0.0; i < 25.; i += 1.0) {\n        steps += 1.0;\n        vec3 p = roo + rdd*d0;\n        float ds = length(p-lightPos)-0.5;\n        d0 += ds;\n        if (ds<e||ds>max_dist) {\n            break;\n        };\n       \tc = p;\n    }\n    \n    return vec2(1000.0, d0);\n}\nvec3 getNormal(vec3 p) {\n    float d = SDF(p);\n    vec2 e = vec2(.01, 0);\n    vec3 n = d-vec3(\n    \tSDF(p-e.xyy),\n    \tSDF(p-e.yxy),\n    \tSDF(p-e.yyx)\n    );\n    return normalize(n);\n}\nvec3 tex(vec3 p) {\n    vec3 t = vec3((mod(floor(p*4.), 2.)));\n    t = vec3(t.x+t.z, t.x, t.y);\n    t = vec3(1.0);\n    return clamp(t, 0.0, 1.0);\n}\nvec3 getLight(vec3 p, vec3 lightPos, vec3 rd, vec3 ro, float dist) {\n    vec3 lp = normalize(lightPos-p);\n    vec3 norm = getNormal(p);\n    float l = length(p-lightPos)-1.0;\n    vec2 li = getL(ro, rd);\n    float dif = dot(norm, lp)/clamp(l/1., 1., 100.0)*6.;\n    float reflected = clamp(float((dot(reflect(rd, norm), lightPos)) - 8.0), 0.0, 1.0);\n    dif = (dif+(reflected/(l/2.)));\n    for (float i = 0.; i < lightSample; i += 1.) {\n    \tfloat d = getDist(p+(norm*e), lp+vec3(\n            hash(p.yz*(i+1.))/lightSize,\n            hash(p.yz*(i+100.))/lightSize,\n            hash(p.yz*(i+1000.))/lightSize\n        ));\n        if (d < length((lightPos)-p)) {\n            dif *= 1.-(2./lightSample);\n        }\n    }\n    if (li.y < dist && dist < max_dist) {\n\t    dif = (clamp(li.x, 0.0, 100.0)/100.);\n    }\n    return tex(p)*vec3(clamp(dif, 0.0, 1.0));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    lightPos = vec3(sin(iTime)*10.,5, cos(iTime)*10.);\n    \n    vec2 mouse = ((iMouse.xy-.5*iResolution.xy)/iResolution.xy)*5.;\n    mouse.x *= iResolution.x/iResolution.y;\n    vec2 uv = ((fragCoord-.5*iResolution.xy)/iResolution.xy);\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3(sin(iTime)*10., 10., cos(iTime)*10.);\n    vec3 at = vec3(0, 0, 0);\n    vec3 c_z = normalize(at-ro);\n    vec3 c_x = normalize(cross(vec3(0,1,0), c_z));\n    vec3 c_y = cross(c_z, c_x);\n    vec3 rd = normalize(uv.x * c_x + uv.y * c_y + 1.73 * c_z);\n    float dist = getDist(ro, rd);\n    vec3 fog = vec3(-0.4, -0.4, -0.4);\n    vec3 col = fog;\n    vec3 p = ro+rd*dist;\n    vec3 light = getLight(p, lightPos, rd, ro, dist);\n    col = (light*0.95)+0.05;\n    //col += (fog)*(dist/1000.);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdfWf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[174, 174, 219, 219, 276], [278, 278, 321, 321, 421], [423, 423, 466, 466, 566], [568, 568, 587, 587, 657], [658, 658, 691, 691, 715], [717, 717, 746, 746, 833], [834, 834, 854, 854, 925], [926, 926, 945, 945, 1130], [1131, 1131, 1164, 1164, 1525], [1526, 1526, 1555, 1555, 1940], [1941, 1941, 1965, 1965, 2125], [2126, 2126, 2144, 2144, 2272], [2273, 2273, 2341, 2341, 3124], [3125, 3125, 3182, 3182, 3989]], "test": "valid"}
{"id": "3sdfWn", "name": "heart beat", "author": "zhuhaigen", "description": "heart beat", "tags": ["heartbeat"], "likes": 2, "viewed": 43, "published": "Public", "date": "1604832118", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// https://zhuanlan.zhihu.com/p/110429623\n// https://www.jb51.net/article/157084.htm\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (2.*fragCoord.xy-iResolution.xy)/(min(iResolution.x,iResolution.y));\n\n\tvec3 bcol = vec3(1.,0.8,0.8)*(1.-0.38*length(uv.xy));\n    \n    \n   float tt = mod(iTime,2.)/2.;  //u_time \n\tfloat ss = pow(tt,.2)*0.5 + 0.5;\n\tss = 1.0 + ss*0.5*sin(tt*6.2831*3.0)*exp(-tt*4.0);//\n\tuv *= vec2(0.5,1.5) + ss*vec2(0.5,-0.5);\n    \n    \n    //0.25\n    uv.y-=0.25;\n    \n    float PI = 3.14159;\n    float a = abs(atan(uv.x,uv.y) / PI);\n    float p = length(uv);\n    \n    //\n    vec3 hcol=vec3(0.9,0.35*p,0.35*p);\n    \n    float d = (13.0*a - 22.0*a*a + 10.0*a*a*a)/(6.0-5.0*a);\n    \n    //a-p\n    //vec3 rescol=mix(bcol,hcol,max(0.,a-p));\n    vec3 rescol=mix(bcol,hcol,smoothstep(-0.03,0.03,d-p));\n    // Output to screen\n    fragColor = vec4(rescol,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdfWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 85, 142, 192, 1102]], "test": "valid"}
{"id": "3sdfzH", "name": "Spongetoy descent", "author": "mdnestor", "description": "my first shader here :D\n", "tags": ["fractal"], "likes": 7, "viewed": 90, "published": "Public", "date": "1604508723", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nint in_set(vec2 uv, int n) {\n    for (int i = 0; i < n; i++) {\n        float p = pow(3., float(i));\n        if (mod(floor(uv.x *p),3.) == 1. && (mod(floor(uv.y *p),3.) == 1.)) {\n            return(0);\n        }\n    }\n    return(1);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = mod(.5*iTime, 1.);\n    uv -= vec2(.5,.5);\n    \n    uv.x *= iResolution.x/iResolution.y;\n    \n    float s = 2.*3.14159*(t+1.)/4.;\n    uv = vec2(cos(s)*uv.x-sin(s)*uv.y, sin(s)*uv.x+cos(s)*uv.y); \n    \n    uv *= pow(3.,-t);\n    uv += vec2(.5,.5*pow(3.,-t));  \n    vec3 col;\n    if (in_set(uv, 6)==1) {\n        col = vec3(.8, .5+0.2*sin(iTime), .2);\n    } else {\n        col = vec3(.8+0.2*sin(iTime), .95, 1.);\n    }\n    \n    vec2 ab = uv - vec2(.5,.5*pow(3.,-floor(t+1.)));\n    col *= exp(-2.*sqrt(pow(ab.x,2.)+pow(ab.y,2.)));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdfzH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 29, 29, 234], [236, 236, 293, 343, 956]], "test": "valid"}
{"id": "3sdfzl", "name": "Never ending gradient scroll", "author": "farious", "description": "A simple dual tone gradient shader that scrolls with time.", "tags": ["gradient", "scroll", "perpetual", "dualtone"], "likes": 1, "viewed": 43, "published": "Public", "date": "1605790153", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec4 colorLow = vec4(1., 0.3, 0., 0.);\nvec4 colorHigh = vec4(1., 0.8, 0., 0.);\nfloat spacingLow = 1.76;\nfloat spacingHigh = 2.;\n\nfloat gradient(float dir, float time, float spacing) {\n    float g = fract((dir + time * 0.1) * 3.);\n\tfloat left = step(0.5, g);\n    g = left * ((g - 0.5) * spacing) + (1. - left) * ((1. - g) - 0.5) * spacing;\n    return g;\n}\n\nvec4 dualTone(vec4 low, vec4 high, float gradient, float power) {\n    return mix(low, high, pow(gradient, power));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float gradient = gradient(uv.x, iTime, spacingHigh);\n    vec4 tone = dualTone(colorLow, colorHigh, gradient, spacingLow);\n    \n    // Output to screen\n    fragColor = tone;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 130, 184, 184, 355], [357, 357, 422, 422, 473], [475, 475, 532, 582, 806]], "test": "valid"}
{"id": "3sdfzr", "name": "learn(8)", "author": "saltlemon", "description": "star\nlearn from https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg The Art of Code", "tags": ["2d"], "likes": 5, "viewed": 155, "published": "Public", "date": "1605181273", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float disToLine(vec2 p,vec2 a,vec2 b){\n \tvec2 pa=p-a;\n    vec2 ba=b-a;\n    float t= clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n    return length(pa-ba*t);\n}\nfloat drawLine(vec2 p,vec2 a,vec2 b){\n \tfloat d=disToLine(p,a,b);\n    float c=smoothstep(.03,.01,d);\n    float d2=length(a-b);\n    c*=smoothstep(1.2,.8,d2)*.5+smoothstep(.05,.03,abs(d2-.75));\n    return c;\n}\nvec2 N22(vec2 p){\n \tfloat x=fract(sin(p.x*120.2+p.y*168.7)*2368.4);\n    float y=fract(sin(p.x*156.4+p.y*196.2)*2586.3);\n    return vec2(x,y);\n}\n\nvec2 getPos(vec2 id){\n \tvec2 n=N22(id)*iTime;\n    return sin(n)*.4;\n}\nfloat layer(vec2 uv){\n    vec2 suv=fract(uv)-.5;\n    vec2 id=floor(uv);\n    float m=0.;\n    \n    vec2 p[9];\n    int i=0;\n    for(float x=-1.;x<=1.;x++){\n    \tfor(float y=-1.;y<=1.;y++){\n            vec2 offs=vec2(x,y);\n            p[i++]=(offs+getPos(id+offs));\n        }\n    }\n    \n    for(int a=0;a<9;a++){\n      \tm += drawLine(suv,p[4],p[a]);\n        vec2 j=(suv-p[a])*15.;\n        float sparkle=1. / dot(j,j);\n        m += sparkle*(sin(iTime*5.+p[a].x*20.)*.4+.6);\n        \n    }\n    m +=  drawLine(suv,p[1],p[3]);\n    m +=  drawLine(suv,p[1],p[5]);\n    m +=  drawLine(suv,p[7],p[3]);\n    m +=  drawLine(suv,p[7],p[5]);\n    return m;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 mouse=(iMouse.xy/iResolution.xy)-.5;\n    uv.x*=iResolution.x/iResolution.y;\n    uv-=.5;\n    \n    float bground=uv.y;\n    float m=0.;\n    float t=iTime*.1;\n    mat2 rot=mat2(cos(t),sin(t),-sin(t),cos(t));\n    uv*=rot;\n    mouse*=rot;\n    for(float i=0.;i<1.;i+=.25){\n        float it=fract(i+t);\n     \tfloat size=mix(10.,.5,it);\n        float fade=smoothstep(0.,.5,it)*smoothstep(1.,.8,it);\n        m+=layer(uv*size+i*20.-mouse)*fade;\n    }\n\tvec3 base=sin(5.*t+vec3(.954,.456,.657))*.4 +.6;\n    vec3 col = vec3(m)*base;\n    float fft=texelFetch(iChannel0,ivec2(.1,0),0).x;\n    col-=bground*base*fft;\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sdfzr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 38, 38, 149], [150, 150, 187, 187, 357], [358, 358, 375, 375, 501], [503, 503, 524, 524, 572], [573, 573, 594, 594, 1212], [1213, 1213, 1270, 1320, 2030]], "test": "error"}
{"id": "3sGfzw", "name": "3D Triangle Rasterizer", "author": "oneshade", "description": "A simple 3D rasterizer. It took me forever to get the faces right!", "tags": ["3d", "rasterizer", "triangle"], "likes": 4, "viewed": 98, "published": "Public", "date": "1606763437", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float Z_NEAR = 0.1;\nconst float Z_FAR = 100.0;\nconst float FOCAL_LENGTH = 1.0;\n\nvec3[] vertices = vec3[8](vec3( -1.0,  1.0,  1.0 ),\n                          vec3( -1.0, -1.0,  1.0 ),\n                          vec3(  1.0, -1.0,  1.0 ),\n                          vec3(  1.0,  1.0,  1.0 ),\n                          vec3(  1.0,  1.0, -1.0 ),\n                          vec3(  1.0, -1.0, -1.0 ),\n                          vec3( -1.0, -1.0, -1.0 ),\n                          vec3( -1.0,  1.0, -1.0 ));\n\nivec3[] triangles = ivec3[12](ivec3( 0, 1, 2 ),\n                              ivec3( 2, 3, 0 ),\n                              ivec3( 4, 5, 6 ),\n                              ivec3( 6, 7, 4 ),\n                              ivec3( 3, 2, 5 ),\n                              ivec3( 5, 4, 3 ),\n                              ivec3( 7, 6, 1 ),\n                              ivec3( 1, 0, 7 ),\n                              ivec3( 7, 0, 3 ),\n                              ivec3( 3, 4, 7 ),\n                              ivec3( 5, 2, 1 ),\n                              ivec3( 1, 6, 5 ));\n\nvec3[] faceNormals = vec3[12](vec3(  0.0,  0.0,  1.0 ),\n                              vec3(  0.0,  0.0,  1.0 ),\n                              vec3(  0.0,  0.0, -1.0 ),\n                              vec3(  0.0,  0.0, -1.0 ),\n                              vec3(  1.0,  0.0,  0.0 ),\n                              vec3(  1.0,  0.0,  0.0 ),\n                              vec3( -1.0,  0.0,  0.0 ),\n                              vec3( -1.0,  0.0,  0.0 ),\n                              vec3(  0.0,  1.0,  0.0 ),\n                              vec3(  0.0,  1.0,  0.0 ),\n                              vec3(  0.0, -1.0,  0.0 ),\n                              vec3(  0.0, -1.0,  0.0 ));\n\nvec3[] faceColors = vec3[12](vec3( 1.0, 0.0, 0.0 ),\n                             vec3( 1.0, 0.0, 0.0 ),\n                             vec3( 0.0, 1.0, 0.0 ),\n                             vec3( 0.0, 1.0, 0.0 ),\n                             vec3( 1.0, 1.0, 0.0 ),\n                             vec3( 1.0, 1.0, 0.0 ),\n                             vec3( 0.0, 0.0, 1.0 ),\n                             vec3( 0.0, 0.0, 1.0 ),\n                             vec3( 1.0, 0.0, 1.0 ),\n                             vec3( 1.0, 0.0, 1.0 ),\n                             vec3( 0.0, 1.0, 1.0 ),\n                             vec3( 0.0, 1.0, 1.0 ));\n\nvec3 transformVertex(in vec3 v) {\n    float c = cos(iTime), s = sin(iTime);\n    v.xz *= mat2(c, -s, s, c);\n    v.yz *= mat2(c, -s, s, c);\n    v += vec3(0.0, 0.0, -5.0);\n    return v;\n}\n\nvec3 transformNormal(in vec3 n) {\n    float c = cos(iTime), s = sin(iTime);\n    n.xz *= mat2(c, -s, s, c);\n    n.yz *= mat2(c, -s, s, c);\n    return n;\n}\n\nvec3 calcBaryCoords(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n\n    float abp = abs(ba.x * pa.y - ba.y * pa.x);\n    float bcp = abs(cb.x * pb.y - cb.y * pb.x);\n    float cap = abs(ac.x * pc.y - ac.y * pc.x);\n    float abc = abs(ba.x * cb.y - ba.y * cb.x);\n\n    return vec3(bcp / abc, cap / abc, abp / abc);\n}\n\nvec3 pixelShader(in vec3 p, in vec3 n, in vec3 c) {\n    return c * max(0.0, dot(n, vec3(-0.58, 0.58, 0.58)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec3[vertices.length()] transformedVertices;\n    for (int i=0; i < vertices.length(); i++) {\n        vec3 transformedVertex = transformVertex(vertices[i]) * vec3(1.0, 1.0, -1.0);\n        float perspective = FOCAL_LENGTH / transformedVertex.z;\n        transformedVertex.xy *= perspective;\n        transformedVertices[i] = transformedVertex;\n    }\n\n    vec3[faceNormals.length()] transformedNormals;\n    for (int i=0; i < faceNormals.length(); i++) {\n        transformedNormals[i] = transformNormal(faceNormals[i]);\n    }\n\n    bool pixelIsOverlappingTriangle = false;\n    vec3 fragmentPos, normal, color;\n    float fragDepth = Z_FAR;\n\n    for (int i=0; i < triangles.length(); i++) {\n        if (transformedNormals[i].z > 0.0) {\n            vec3 triA = transformedVertices[triangles[i][0]];\n            vec3 triB = transformedVertices[triangles[i][1]];\n            vec3 triC = transformedVertices[triangles[i][2]];\n\n            vec3 baryCoords = calcBaryCoords(uv, triA.xy, triB.xy, triC.xy);\n            float newFragDepth = baryCoords.x * triA.z + baryCoords.y * triB.z + baryCoords.z * triC.z;\n            if (abs(baryCoords.x + baryCoords.y + baryCoords.z - 1.0) < 0.001 && newFragDepth > Z_NEAR && newFragDepth < fragDepth) {\n                pixelIsOverlappingTriangle = true;\n                fragDepth = newFragDepth;\n                fragmentPos = baryCoords.x * vertices[triangles[i][0]] + baryCoords.y * vertices[triangles[i][1]] + baryCoords.z * vertices[triangles[i][2]];\n                normal = transformedNormals[i];\n                color = faceColors[i];\n            }\n        }\n    }\n\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    if (pixelIsOverlappingTriangle) {\n        fragColor.rgb = pixelShader(fragmentPos, normal, color);\n    }\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sGfzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2382, 2382, 2415, 2415, 2566], [2568, 2568, 2601, 2601, 2721], [2723, 2723, 2788, 2788, 3124], [3126, 3126, 3177, 3177, 3237]], "test": "error"}
{"id": "3sKBRz", "name": "glooper", "author": "Del", "description": "gloop - - from in game  [url]https://www.youtube.com/watch?v=u3JePjNBRjM&feature=emb_logo[/url]\n", "tags": ["gloop"], "likes": 2, "viewed": 233, "published": "Public API", "date": "1606429904", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 400.0\n#define SURF_DIST 0.01\n\nfloat sdSphere(vec3 p, vec4 s){\n\treturn  length(p-s.xyz)-s.w;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );\n    return mix( b, a, h ) - k*h*(1.0-h);\n}\n\nfloat GetDist(vec3 p){\n    \n   \tfloat sd = sdSphere(p,vec4(0,1,6,1));\n\tfloat v = 0.5+sin(iTime*2.4 + p.z*5.4+p.y*3.4+p.x*4.1)*0.5;\n\tsd += v*0.25;\n\tfloat k = 3.5+sin(p.y*3.2+iTime*3.16);\n    float d = smin(sd*0.75,p.y+.5,k);\n    return d;\n}\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS;i++){\n        vec3 p = ro + rd  * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        \n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    \n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.005,0);\n    \n    \n    vec3 n = d - vec3(GetDist(p - e.xyy),\n                      GetDist(p - e.yxy),\n                      GetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p,vec3 rd)\n{\n    float t = fract(iTime*0.54)*6.28;\n\tvec3 lightPos = vec3(0,8.+sin(t+p.z)*5.0,3);\n    vec3 l = normalize(lightPos - p);\n    \n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.0,1.);\n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    \n    if(d < length(lightPos-p))\n        dif *= .5;\n    else\n    {\n\t    vec3 ref = reflect(rd, n);\n\t\tfloat spe = max(dot(ref, l), 0.0);\n\t  \tdif += pow(spe,64.0);\n    }\n\n    \n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    vec3 ro = vec3(0,2,-2.5);\n    vec3 rd = normalize(vec3(uv.x,uv.y-.3,2));\n    float d = RayMarch(ro,rd);\n    vec3 p = ro + rd *d;\n    float dif = GetLight(p,rd);\n    col = vec3(dif*(1.0+sin(rd.x)),dif,dif*0.8);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sKBRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 100, 100, 132], [134, 134, 175, 175, 268], [270, 270, 292, 292, 509], [511, 511, 544, 544, 776], [779, 779, 802, 802, 1022], [1025, 1025, 1057, 1057, 1496], [1500, 1500, 1557, 1557, 1889]], "test": "valid"}
{"id": "3stBD4", "name": "learn(10)", "author": "saltlemon", "description": "raymarch\nhttps://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg The Art of Code", "tags": ["3d"], "likes": 3, "viewed": 71, "published": "Public", "date": "1605180456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SAFE_DIST 0.001\nstruct ray{\n    vec3 o,d;\n};\nfloat smax(float a,float b,float k){\n    float h=clamp((b-a)/k+0.5,0.,1.);\n\treturn mix(a,b,h)+h*(1.-h)*k*.5;   \n}\nfloat smin(float a,float b,float k){\n    float h=clamp((b-a)/k+0.5,0.,1.);\n\treturn mix(b,a,h)-h*(1.-h)*k*.5;   \n}\nray getRay(vec2 uv,vec3 camPos,vec3 lookat,float zoom){\n    ray a;\n    a.o=camPos;\n    vec3 f=normalize(lookat-a.o);\n    vec3 r=cross(vec3(0.,1.,0.),f);\n    vec3 u=cross(f,r);\n    vec3 c=a.o+zoom*f;\n    vec3 i=c+uv.x*r+uv.y*u;\n    a.d=normalize(i-a.o);\n    return a;\n}\nmat2 rot(float a){\n    float s=sin(a);\n    float c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdGyroid(vec3 p,float scale,float thickness,float bias){\n    p*=scale;\n    return abs(dot(sin(p),cos(p.zxy))-bias)/scale-thickness;\n}\nvec3 transfrom(vec3 p){\n    p.xy*=rot(p.z*.15);\n    p.z+=iTime*.1;\n    p.y-=.3;\n    return p;\n}\nfloat getDist(vec3 p){ \n    p=transfrom(p);\n    vec3 dp=p-vec3(0.,0,0);\n    \n    float dBox=sdBox(dp,vec3(1));\n    \n\n    float g1=sdGyroid(p,5.25,.03,1.4);\n    float g2=sdGyroid(p,10.54,.03,.3);\n    float g3=sdGyroid(p,20.44,.03,.3);\n    float g4=sdGyroid(p,35.63,.03,.3);\n    float g5=sdGyroid(p,60.31,.03,.3);\n    float g6=sdGyroid(p,110.31,.03,.3);\n    //float g=min(g1,g2);\n    //float g=max(g1,-g2);\n    float g=g1-g2*.4;\n    g-=g3*.3;\n    g+=g4*.2;\n    g+=g5*.2;\n    g+=g6*.1;\n    float d=g*.8;\n    return d;\n}\nvec3 getNormal(vec3 p){\n \tfloat d=getDist(p);\n    vec2 e=vec2(.02,0.);\n    vec3 n=normalize(vec3(\n        d-getDist(p-e.xyy),\n        d-getDist(p-e.yxy),\n        d-getDist(p-e.yyx)\n    ));\n        return n;\n}\n\nfloat RayMarch(vec3 ro,vec3 rd){\n\tfloat d_o=0.;\n    for(int i=0;i<MAX_STEPS;i++){\n     \tvec3 p=ro+d_o*rd;\n        float dS=getDist(p);\n        d_o+=dS;\n        if(d_o>MAX_DIST||abs(dS)<SAFE_DIST) break;\n    }\n    \n    return d_o;\n}\nfloat getLight(vec3 p){\n \tvec3 LightPos=vec3(1,2,3);\n    vec3 l=normalize(LightPos-p);\n    vec3 n=getNormal(p);\n    \n    float dif=clamp(dot(n,l),0.,1.)*.5+.5;\n\n    float d=RayMarch(p+n*SAFE_DIST*2.,l);\n    //if(d<length(LightPos-p))dif*=.3;\n    return dif;\n}\nfloat getCol(vec3 p,vec3 n){\n    \n    float dif=n.y*.5+.5;\n    return dif;\n}\n\nvec3 background(vec3 rd){\n    vec3 col=vec3(0.);\n    float y=rd.y*.5+.5;\n    col+=(1.-y)*vec3(1.,.4,.1)*2.;\n    float t=iTime;\n    float a=atan(rd.x,rd.z);\n    float flame=sin(a*10.+t)*sin(a*6.-t)*sin(a*5.);\n    flame*=smoothstep(.8,.5,y);\n    col+=flame*.5;\n    col=max(col,0.);\n    col+=smoothstep(.5,.0,y)*.5;\n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv-=.5;\n\tuv.x*=iResolution.x/iResolution.y;\n    \n    uv+=sin(uv*20.+iTime)*.01;//motion blur\n    vec3 col = vec3(0.);\n\t\n    vec2 m=iMouse.xy/iResolution.xy;\n    vec3 camPos=vec3(0,0,-.03);\n    camPos.yz*=rot(-m.y*3.14+1.);\n    camPos.xz*=rot(-m.x*6.2831);\n    vec3 lookat=vec3(0,0,0);\n    ray myray=getRay(uv,camPos,lookat,.8);\n\n   \tfloat dif=0.;\n    float d=RayMarch(myray.o,myray.d);\n    if(d<MAX_DIST){\n    \tvec3 p=myray.o+d*myray.d;\n        float height=p.y;\n        vec3 n=getNormal(p);\n        dif=getCol(p,n);\n        col=vec3(dif*dif);\n        p=transfrom(p);\n    \t\n        //col=getNormal(p)*.5+.5;\n        float g2=sdGyroid(p,10.54,.03,.3);\n        col*=smoothstep(-.1,.1,g2);//shadow\n        \n        \n        float crackwidth=smoothstep(0.,-.5,n.y)*.04;\n        float crack=smoothstep(-.02+crackwidth,-.03,g2);\n        float t=iTime;\n        float g3=sdGyroid(p+t*.1,5.54,.03,0.);\n        float g4=sdGyroid(p-t*.05,4.72,.03,0.);\n        crack*=g3*g4*20.+.2*smoothstep(.2,0.,n.y);\n        col+=crack*vec3(1.,.4,.1)*3.;//crack\n        \n        float g5=sdGyroid(p-vec3(0.,t,0.),3.85,.03,0.);//fire\n        col+=g5*vec3(1.,.4,.1);\n        col+=smoothstep(0.,-2.,height)*vec3(1.,.4,.1)*.3;\n        \n    }\n    col=mix(col,background(myray.d),smoothstep(0.,6.,d));\n    col*=(1.-dot(uv,uv));//camera shadow\n    //col=background(myray.d);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 133, 133, 210], [211, 211, 247, 247, 324], [325, 325, 380, 380, 593], [594, 594, 612, 612, 681], [683, 683, 714, 714, 805], [806, 806, 868, 868, 945], [946, 946, 969, 969, 1041], [1042, 1042, 1064, 1064, 1558], [1559, 1559, 1582, 1582, 1767], [1769, 1769, 1801, 1801, 2000], [2001, 2001, 2024, 2024, 2260], [2261, 2261, 2289, 2289, 2337], [2339, 2339, 2364, 2364, 2669], [2670, 2670, 2727, 2777, 4197]], "test": "valid"}
{"id": "3stBDH", "name": "Emerald retrowave clip", "author": "z0rg", "description": "Visuals inspired by https://www.youtube.com/watch?v=Jrb5PqiDMSY\nSong is https://www.youtube.com/watch?v=Pum5IuGtWbc\nVideo can be found here https://youtu.be/RLAqQn2vqcM\n", "tags": ["synth", "chill", "retrowave", "system96", "lucyindisguise"], "likes": 12, "viewed": 275, "published": "Public API", "date": "1605008645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a, 0., 1.)\nvec3 pink = (vec3(255, 59, 98)/255.);\nvec3 blue = vec3(59, 154, 255)/255.;\nmat2 r2d(float a) { float ca = cos(a), sa = sin(a); return mat2(ca, sa, -sa, ca);}\n\nfloat lenny(vec2 uv)\n{\n    return abs(uv.x)+abs(uv.y);\n}\n\nfloat sdLoz(vec2 uv, float sz)\n{\n    return lenny(uv)-sz;\n}\n\nfloat sdSqr(vec2 uv, vec2 sz)\n{\n    vec2 q = abs(uv)-sz;\n    return max(q.x,q.y);\n}\n\nfloat bars(vec2 uv)\n{\n    vec2 ouv = uv;\n    float rep = 0.08;\n\tfloat idx = float(int((uv.x+rep*.5)/rep));\n    uv.x = mod(uv.x+rep*.5, rep)-rep*.5;\n    float h = texelFetch(iChannel0, ivec2(int((idx+8.5)*7.), 0), 0).x;\n    float sqr = sdSqr(uv, vec2(.00001,.1+.2*h));\n    return max(sqr, -(abs(uv.y)-.05));\n}\n\nvec2 myPixel(vec2 uv, float sz)\n{\n    vec2 uv2 = uv/sz;\n    \n    return  vec2(float(int(uv2.x)), float(int(uv2.y)))*sz;\n}\n\nvec3 rdrPix(vec2 uv)\n{\n    vec3 col;\n    uv = myPixel(uv, 0.1);\n    float beat = texelFetch(iChannel0, ivec2(25,0),0).x;\n    float patt = sin((55.*(abs(uv.x)+beat*.05+uv.y)-iTime*10.)*(1.+abs(uv.y)*.01));\n    col = mix(col, vec3(.5,.2,.9), sat((patt-.99)*iResolution.x));\n    col += (vec3(.2,.7,.3))*0.+blue*(sat((patt-.5)*.5));\n    return col;\n}\n\nvec3 rdrLoz(vec2 uv)\n{\n    vec2 ouv = uv;\n    uv *= 15.;\n    uv = myPixel(uv, 0.025);\n    uv.y += sin(uv.x*5.+iTime)*.5;\n    vec3 col;\n    vec3 a = vec3(255,98,14)/255.;\n    vec3 b = vec3(255,239,88)/255.;\n    vec3 c = vec3(91,222,150)/255.;\n    if (uv.y < 0.)\n        col = mix(b, c, sat(abs(uv.y)));\n    else\n        col = mix(b, a, sat(uv.y));\n    float f = iResolution.x/10.;\n    float sz = .99;\n    col *= 1.-sat((sin(ouv.x*f)-sz)*iResolution.x*.1);\n    col *= .5+1.-sat((sin(ouv.y*f)-sz)*iResolution.x*.1);\n    return col;\n    \n}\n\nvec3 rdr(vec2 uv)\n{\n    vec3 col;\n    \n    // Back bars\n    vec2 uvBar = uv;\n    uvBar.x += -sign(uvBar.x)*pow(sat(abs(uvBar.x)), .2)*abs(uvBar.y);\n    float bar = bars(uvBar);\n    col = mix(col, vec3(1.), 1.-sat(bar*iResolution.x));\n\n    col += (vec3(255, 59, 216)/255.)*pow((1.-sat(bar*1.)), 10.)*.5;\n    col += mix(pink, blue, pow(sat(abs(uv.y*5.)),5.))*pow((1.-sat(bar*5.)), 20.);\n    col *= (uv.y < 0. ? 1.-abs(uv.y*5.) : 1.0);\n    \n    vec2 uvLz = uv;\n    float lz = sdLoz(uvLz, .15);\n    \n    \n    vec3 pixCol = rdrPix(uv);\n    col += pixCol*(1.-sat(lz*2.))*texelFetch(iChannel0, ivec2(25,0),0).x;\n    \n\tcol = mix(col, col+rdrLoz(uv), 1.-sat(lz*iResolution.x*.01));\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-vec2(.5)*iResolution.xy)/iResolution.xx;\n\tuv *= 1.5;\n    uv *= sin(iTime*.4)*.2+.8;\n\n    vec3 col = rdr(uv);\n\n\tcol = pow(col, vec3(mix(.45,1.45,sat(lenny(uv)))));\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Mt2GDt", "previewfilepath": "https://soundcloud.com/systemninesix/emerald-w-lucy-in-disguise", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/systemninesix/emerald-w-lucy-in-disguise", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stBDH.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[504, 504, 523, 523, 586], [588, 588, 610, 610, 644], [646, 646, 678, 678, 705], [707, 707, 738, 738, 790], [792, 792, 813, 813, 1100], [1102, 1102, 1135, 1135, 1223], [1225, 1225, 1247, 1247, 1571], [1573, 1573, 1595, 1595, 2108], [2110, 2110, 2129, 2129, 2805], [2807, 2807, 2864, 2864, 3085]], "test": "error"}
{"id": "3stBDN", "name": "Ray Marching (Demo)", "author": "acohale97", "description": "Just a good time with some ray marching.", "tags": ["raymarching"], "likes": 1, "viewed": 84, "published": "Public", "date": "1605283768", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 90\n#define MAX_DIST 100.0\n#define SURFACE_DIST 0.001\n#define INF 200\n#define RECURSIONS 4\n\nfloat maxcomp(in vec3 p ) { return max(p.x,max(p.y,p.z));}\nfloat sdBox( vec3 p, vec3 b ) {\n    vec3  di = abs(p) - b;\n    float mc = max(di.x,max(di.y,di.z));\n    return min(mc,length(max(di,0.0)));\n}\n\nfloat sdCross ( vec3 p) {\n    float da = sdBox(p.xyz,vec3(INF,1.0,1.0));\n    float db = sdBox(p.yzx,vec3(1.0,INF,1.0));\n    float dc = sdBox(p.zxy,vec3(1.0,1.0,INF));\n    \n    return min(da, min(db, dc));\n}\n\nfloat transform ( vec3 r, float scale ) {\n    float da = max(r.x,r.y);\n    float db = max(r.y,r.z);\n    float dc = max(r.z,r.x);\n    float c = (min(da,min(db,dc))-1.0)/(2. * scale);\n    \n    return c;\n}\n\nfloat GetDist ( in vec3 p )\n{\n    float boxDist = sdBox(p, vec3(1.0));\n    float scale = 0.5;\n    for( int i = 0; i < RECURSIONS; i++ ) {\n        vec3 a = fract( p*scale )-.5;\n        scale *= 3.;\n        vec3 r = abs(1.-6.*abs(a));\n        float dist = transform(r, scale); \n\n        if( dist > boxDist ) {\n          boxDist = dist;\n        }\n    }\n    return boxDist;\n}\n\nfloat RayMarch (vec3 ro, vec3 rd) {\n    float d0 = 0.0;\n    \n    for (int i=0; i<MAX_STEPS; i++) {\n    \tvec3 point = (ro + rd * d0);\n        float ds = GetDist(point);\n        d0 += ds;\n        if (d0 > MAX_DIST || ds < SURFACE_DIST) break;\n    }\n    \n    return d0;\n}\n\nvec3 GetNormal (vec3 point) {\n    float dist = GetDist(point);\n    vec2 x = vec2(SURFACE_DIST, 0);\n    \n    vec3 normal = dist - vec3(\n        GetDist(point - x.xyy),\n        GetDist(point - x.yxy),\n        GetDist(point - x.yyx));\n    \n    return normalize(normal);\n}\n\nfloat GetLight (vec3 point) {\n    // Create Light\n\tvec3 lightPosition = vec3(0, 2, -2);\n    //lightPosition.xz += vec2(sin(iTime), cos(iTime))*2.;\n    \n    vec3 lightVector = normalize(lightPosition - point);\n    vec3 normal = GetNormal(point);\n    float diff = clamp(dot(lightVector, normal), 0., 1.);\n    \n    // Shadows\n\t//float shadowDistance = RayMarch(point + normal * SURFACE_DIST , vec3(1));\n    //if (shadowDistance < length(lightPosition - point)){\n\t//\tdiff *= 0.1;        \n    //}\n\n    return diff;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr ) {\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ){\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n    vec3 col = vec3(0);\n    \n    // Camera\n    vec3 ray_origin = 5.5 * vec3( sin(iTime * 0.25), .1, cos(iTime * 0.25) );\n    \n    vec3 ta = vec3( 0.0, 0., 0.0 );\n    \n    mat3 ca = setCamera( ray_origin, ta, 0.0 );\n    vec3 ray_distance = ca * normalize( vec3(uv.xy,2.0) );\n    \n    \n    // Ray March\n    float dist = RayMarch (ray_origin, ray_distance);\n\n    // Lighting\n    vec3 point = ray_origin + ray_distance * dist;\n    float diff = GetLight(point);\n    col = vec3(diff);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stBDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 136, 136, 167], [168, 168, 199, 199, 309], [311, 311, 336, 336, 517], [519, 519, 560, 560, 721], [723, 723, 752, 752, 1094], [1096, 1096, 1131, 1131, 1364], [1366, 1366, 1395, 1395, 1634], [1636, 1636, 1665, 1685, 2147], [2149, 2149, 2201, 2201, 2378], [2380, 2380, 2437, 2437, 3035]], "test": "valid"}
{"id": "3stBRB", "name": "atom simulator", "author": "romeosoft", "description": "An atom simulator!", "tags": ["atom", "atom3d"], "likes": 3, "viewed": 141, "published": "Public", "date": "1606196836", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ROT(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nfloat a0 = 5.1;\nint  n = 5;\nint  l = 2;\nint  m = 1;\nfloat A = 0.;\nfloat Y0 = 0.;\n\nfloat JC(int x)\n{\n    float v = 1.;\n    for (int i = 1; i <= x; i++)\n    {\n        v *= float(i);\n    }\n    return v;\n}\nint powN1(int n)\n{\n    return n % 2 == 0 ? 1 : -1;\n}\nfloat Cmn(int n, int m)\n{\n    return JC(n) / (JC(m) * JC(n - m));\n}\nfloat laguerreL(int n, int m, float x)\n{\n    float sum = 0.;\n    for (int k = 0; k <= n; k++)\n    {\n        sum += float(powN1(k))* Cmn(n + m, n - k)* pow(x, float(k)) / JC(k);\n    }\n    return sum;\n}\nfloat PML(float m, float l, float x)\n{\n    float A1 = pow(1. - x * x, m / 2.);\n    float sum = 0.;\n    int kl = int((l - m) / 2.);\n    for (int k = 0; k <= kl; k++)\n    {\n        float jk = JC(k);\n        float jk2 = JC(int(l) - k);\n        float jk3 = JC(int(l) - 2 * k - int(m));\n        float B = pow(2., l) * jk * jk2 * jk3;\n\n        float E = pow(x, l - 2. * float(k) - m);\n        sum += (float(powN1(k)) * JC(2 * int(l) - 2 * k) / B) * E;\n    }\n    return A1 * sum;\n}\n\nfloat calcR(float r)\n{\n    float B = pow(2. * r / (float(n) * a0), float(l));\n    float C = laguerreL(n - l - 1, 2 * l + 1, 2. * r / (float(n) * a0));\n    float E = exp(-(r / (float(n) * a0)));\n    return A * B * C * E;\n}\nfloat calcY(float cosang)\n{\n    float pml = PML(float(m), float(l), \n                    abs(cosang)\n                   ); \n    float Yml = Y0 * pml;\n    return pml * Yml;\n}\nvec2 calcF(float fai)\n{\n    return vec2(cos(float(m) * fai), sin(float(m) * fai));\n}\nbool mapcor(vec3 p, out float fcolor)\n{\n\tfloat r = length(p);\n\tvec3 v = p / r;\n\tvec2 xz = normalize(v.xz);\n\tfloat R = calcR(r);\n\n\tfloat Y = calcY(v.y / length(v));\n\tfloat fai = atan(-xz.y, xz.x);\n    vec2 VF = calcF(fai);\n\t\n\tfloat epx = R * Y * VF.x;\n    float epy = R * Y * VF.y;\n\t\n\tfloat nlum =  (epy*epy) * 10000.0f;\n\tfcolor += nlum * 100.0f;\n\n\tbool ret = fcolor >= 1.0;\n\tif (ret)\n\t\tfcolor = 1.0;\n    \n\treturn ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 pp = (-iResolution.xy + 2.0*fragCoord.xy) / iResolution.y;\n    float eyer = 2.0;\n    float eyea = -((iMouse.x + 80.5) / iResolution.x) * 3.1415926 * 2.0;\n    float eyef = ((iMouse.y / iResolution.y)-0.24) * 3.1415926 * 2.0;\n    \n\tvec3 cam = vec3(\n        eyer * cos(eyea) * sin(eyef),\n        eyer * cos(eyef),\n        eyer * sin(eyea) * sin(eyef));\n    \n    ROT(cam.xz, (0.25) * (iTime + 15.0));\n    \n\tvec3 front = normalize(- cam);\n\tvec3 left = normalize(cross(normalize(vec3(0.25,1,-0.01)), front));\n\tvec3 up = normalize(cross(front, left));\n\tvec3 v = normalize(front*1.75 + left*pp.x + up*pp.y);\n    \n    vec3 p = cam;\n    \n    float dt = 0.03;\n    float cor = 0.0;\n    A = sqrt(pow(2. / (float(n) * a0), 3.) * (JC(n - l - 1) / (2.0 * float(n) * JC(n + l))));\n    Y0 = (1. / sqrt(2. * 3.1415926)) * sqrt(((2. * float(l) + 1.) / 2.0) * (JC(l - m) / JC(l + m)));\n    \n    for(int i = 0; i < 100; i ++)\n    {\n        p += v * dt;\n        \n\t\tif(mapcor(p * 500., cor))\n            break;\n    }\n    vec4 color = vec4(cor,cor,cor,1.0);\n\t\n    fragColor = color;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stBRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[135, 135, 152, 152, 254], [255, 255, 273, 273, 307], [308, 308, 333, 333, 375], [376, 376, 416, 416, 576], [1275, 1275, 1302, 1302, 1448], [1449, 1449, 1472, 1472, 1533], [1534, 1534, 1573, 1573, 1953]], "test": "valid"}
{"id": "3stBRX", "name": "Titties", "author": "timeiskey", "description": "please provide comments to improve shadertoyporn", "tags": ["booba"], "likes": 2, "viewed": 74, "published": "Public", "date": "1605672978", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MIN_SURFACE_DIST 0.01\n#define MAX_DIST 100.0\n\nfloat get_dist(vec3 p)\n{\n    float t = 11.0;\n    vec3 s = vec3(0, 1, 6);\n    float r = (sin(p.y * 2.0 + t * 5.0) + 0.5)* 2.0 * 0.6 + \n        (sin(p.x * 2.0 + t * 5.0) + 0.5)* 2.0 * 0.6 + \n        (sin(p.z * 0.5 + iTime * 5.0) + 0.5)* 2.0 * 0.1;\n\tfloat sd = length(p - s.xyz) - r;\n    \n    float pd = p.y;\n    return min(sd, pd);\n}\n\nvec3 get_normal(vec3 p)\n{\n\tvec2 e = vec2(0.01, 0);\n    float d = get_dist(p);\n    vec3 n = vec3(\n        d-get_dist(p-e.xyy),\n        d-get_dist(p-e.yxy),\n        d-get_dist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float total_dist = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * total_dist;\n        float dist = get_dist(p);\n        total_dist += dist;\n        if(dist < MIN_SURFACE_DIST || total_dist > MAX_DIST)\n        {\tbreak;\t}\n    }\n    return total_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\tstart it off\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n\n    // light\n    vec3 light_center = vec3(0, 10, 6);\n    vec3 light_offset = vec3(\n    \t(sin(iTime) - 0.5) * 2.0,\n        0.0,\n        (cos(iTime) - 0.5) * 2.0);\n    vec3 light = light_center + light_offset * 5.0;\n    \n    //\tfire a ray for each pixel\n    vec3 ro = vec3(0, 1, 0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    //\tmarch the ray\n\tfloat total_dist = march(ro, rd);\n    vec3 hit_pos = ro + rd * total_dist;\n    \n    //\tlighting\n    vec3 to_cam = normalize(ro - hit_pos);\n    vec3 to_light = normalize(light - hit_pos);\n    vec3 normal = get_normal(hit_pos);\n\n    float b = max(dot(normal, to_light), 0.0);\n    \n    \n    col = vec3(b);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 100, 100, 407], [409, 409, 434, 434, 625], [627, 627, 658, 658, 940], [942, 942, 999, 1019, 1792]], "test": "valid"}
{"id": "3stBWn", "name": "Waved Julia Animation", "author": "IWBTShyGuy", "description": "Waved Julia Animation", "tags": ["fractal"], "likes": 3, "viewed": 79, "published": "Public API", "date": "1604857229", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float basis0(float t) {\n    return clamp(1.0 - 3.0 * t / 2.0, 0.0, 1.0);\n}\nfloat basis1(float t) {\n    return clamp(3.0 / 2.0 * (t - 1.0) + 1.0, 0.0, 1.0);\n}\n\nvec3 color_vec(float t) {\n\treturn vec3(\n\t\tbasis0(t),\n\t\t1.0 - basis0(t) - basis1(t),\n\t\tbasis1(t)\n\t);\n}\n\nvec3 color_result(vec2 uv) {\n\tfloat u = (cos(iTime) + 1.0) / 2.0;\n\tfloat v = (sin(iTime) + 1.0) / 2.0;\n\tvec3 color0 = (1.0 - u) * (1.0 - v) * color_vec(uv[0]);\n\tvec3 color1 = (1.0 - u) * v * color_vec(1.0 - uv[0]);\n\tvec3 color2 = u * (1.0 - v) * color_vec(uv[1]);\n\tvec3 color3 = u * v * color_vec(uv[1]);\n\treturn color0 + color1 + color2 + color3;\n}\n\nint in_julia(vec2 z, vec2 c) {\n\tfor (int i = 0; i < 100; i++) {\n\t\tz = vec2(\n            z.x * z.x - z.y * z.y + c.x,\n            2.0 * z.x * z.y + c.y\n        );\n\t\tif (length(z) > 10.0) return i;\n\t}\n\treturn 100;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float asp = iResolution.x / iResolution.y;\n    vec2 centralizer = vec2(0.5 * asp, 0.5);\n    vec2 centralized = uv - centralizer;\n    float displacer = sin(10.0 * (length(centralized) * 5.0 - iTime * 0.63));\n    uv = centralized * (1.0 + 0.1 * displacer) + centralizer;\n\tvec2 z = 3.0 * (uv - centralizer);\n\tvec2 c = 0.625 * vec2(cos(iTime * 1.43), sin(iTime * 1.43));\n\tint k = in_julia(z, c);\n    if (k < 100) {\n        float ratio = float(k) / 10.0;\n        fragColor = vec4(ratio * color_result(uv.yx), 1.0);\n    }\n\telse fragColor = vec4(color_result(uv), 1.0);\n}", "image_inputs": [{"id": "4df3Rn", "previewfilepath": "/media/ap/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3c33c415862bb7964d256f4749408247da6596f2167dca2c86cc38f83c244aa6.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stBWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 74], [75, 75, 98, 98, 157], [159, 159, 184, 184, 260], [262, 262, 290, 290, 611], [613, 613, 643, 643, 826], [828, 828, 885, 885, 1495]], "test": "valid"}
{"id": "3stfRH", "name": "Sun setting on the sea", "author": "Dombass", "description": "varanasi sunset take 2", "tags": ["sea", "sunset", "sun", "alliteration", "littleart", "smolart", "sopure"], "likes": 0, "viewed": 68, "published": "Public", "date": "1604363126", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat boxSDF(vec3 a, vec3 b, float r) {\n    return length(max(abs(a)-b, 0.)) - r;\n}\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat fl2(vec3 p, float scene)\n{\n    float direction = noise(p+vec3(1.,iTime*0.25,1.0));\n    float height = 0.1; //dont bend! ascend! by going above about 0.3\n    float f = (scene + direction*height);\n    float a = abs(f);\n    return min(1000.-f, a);\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat scene(in vec3 pos) {\n\tfloat box = boxSDF(pos,vec3(300.5,0.25,300.5), 0.2);\n    vec3 sun_pos = pos;\n    sun_pos.y -= 2.5;\n    sun_pos.x -= 4.0;\n    float sun = sphereSDF(sun_pos, 1.0);\n    return fl2(pos,box);\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*scene( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*scene( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*scene( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*scene( pos + e.xxx ) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.01;\n\tvec3  p = org;\n\tbool glowed = false;\n\t\n\tfor(int i=0; i<64; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(scene(p) < 0.)\n\t\t\t\tglowed=true;\n\t\t\tif(glowed)\n       \t\t\tglow = float(i)/64.;\n\t\t}\n\t}\n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0, 2.1, 10.);\n    vec3 rayDir = rayDirection(90., iResolution.xy, fragCoord);\n    vec4 p = raymarch(eye, rayDir);\n\tfloat glow = p.w;\n\t\n    vec3  lig = normalize( vec3(0.0, -5., 2.) );\n    vec3  lig2 = normalize( vec3(0.0, 5., sin(iTime*0.5)*2.5 ));\n    vec3 hal = lig - rayDir;\n    \n    vec3 normal = calcNormal(p.xyz);\n    \n    float dif = clamp( dot( normal, lig ), 0.0, 1. );\n    float dif2 = clamp( dot( normal, lig2 ), 0.0, 1. );\n    vec3 mate = vec3(1.2);\n \n    vec3 lig1Colour = vec3(0.1, 0.3,0.4);\n    \n    vec3 lig2Colour = vec3(1.0,0.7, 0.7);\n    vec3 col = mate*dif*lig1Colour;\n    vec3 col2 = mate*dif2*lig2Colour;\n    \n    fragColor = mix(vec4(col, 1.), vec4(.4,0.3,0.1, 1.), pow(glow*2.,4.));\n  \tfragColor = mix(fragColor, vec4(col2, 1.), 0.5);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stfRH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 34, 34, 62], [64, 64, 103, 103, 147], [149, 149, 191, 191, 428], [430, 430, 462, 462, 682], [684, 684, 749, 749, 881], [883, 883, 909, 909, 1099], [1101, 1101, 1133, 1133, 1341], [1343, 1343, 1378, 1378, 1656], [1658, 1658, 1715, 1715, 2497]], "test": "valid"}
{"id": "3stfzj", "name": "Twister effect", "author": "maksy", "description": "My take on the classic.\n\nBased on this shader: https://www.shadertoy.com/view/lsX3WM", "tags": ["2d", "oldschool", "twister"], "likes": 1, "viewed": 195, "published": "Public API", "date": "1605819454", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S smoothstep\nconst float M_PI = 3.141;\nconst float twister_thick = 0.22;\nconst float thick = 0.012;\n\nvec4 borderColor(float x0, float x1, vec2 uv, \n                 float leftVisible, float rightVisible, \n                 vec4 intCol, vec4 extCol) {\n\n    vec4 white = vec4(1.);\n    \n   \t// the exterior side of the left border\n\tfloat outside = (step(uv.x, x0-thick) + step(x0, uv.x));\n    vec4 borderLeft = mix(white, extCol, S(x0, x0-thick, uv.x)) \n    \t* (1. - outside) * leftVisible;\n        \n    // the interior side of the left border\n    outside = (step(uv.x, x0) + step(x0+thick, uv.x));\n    vec4 borderLeft2 = mix(intCol, white, S(x0+thick, x0, uv.x)) \n    \t* (1. - outside)* leftVisible;      \n    \n    // the exterior side of the right border\n    outside = (step(uv.x, x1) + step(x1+thick, uv.x));        \n    vec4 borderRight = mix(white, extCol, S(x1, x1+thick, uv.x))\n        * (1.- outside) * rightVisible ;\n    \n    // the interior side of the right border\n    outside = (step(uv.x, x1-thick) + step(x1, uv.x));            \n    vec4 borderRight2 = mix(intCol, white, S(x1-thick, x1, uv.x))\n    \t* (1.- outside) * rightVisible;\n    \n    return borderLeft + borderLeft2 + borderRight + borderRight2;     \n}\n\nvec4 getColor(float x0, float x1, vec2 uv, vec4 intCol, vec4 extCol,\n              vec4 fragColor) {\n      \n    vec4 rightCol = vec4(0.);\n    vec4 leftCol = vec4(0.);\n        \n    leftCol = borderColor(x0, x1, uv, 1., 0., intCol, extCol);       \n    rightCol = borderColor(x0, x1, uv, 0., 1., intCol, extCol);\n   \n    if (leftCol != vec4(0.))\n        return leftCol;\n    else if (rightCol != vec4(0.))\n   \t\treturn rightCol;                 \n   \n    return fragColor;   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\t\t\n\t\n    vec2 uv = (fragCoord-0.5*iResolution.xy) / iResolution.y;\n\tvec4 white = vec4(1.0);\n\t\n    /* Creates four points and rotates them by sin of y, time and stuff.\n     * If p1 < p2, a side is visible. Draw a line between each such\n     * pair of points.\n     */\n    float twist = (M_PI / 180.0 * (iTime * 75.0 + \n\t\t\t\t(uv.y * 120.0) * sin((((iTime * 32.5) + \n\t\t\t\t(uv.y * 120.0)) * 3.0 / 4.0) * M_PI / 110.0) )) / .5;\n    \n\tfloat x0 = sin(twist) * twister_thick;\n\tfloat x1 = sin(0.5 * M_PI + twist) * twister_thick;\n\tfloat x2 = sin(1.0 * M_PI + twist) * twister_thick;\n\tfloat x3 = sin(1.5 * M_PI + twist) * twister_thick;\t\n    \n    // Background color\n    fragColor = mix(vec4(0.01), vec4(0.15),smoothstep(.6, .002, abs(uv.x) * 0.59));\n    \n    // Add color onto the visible sides.\n\tvec4 C1 = vec4(1.,0.,0.,0.);\n\tvec4 C2 = vec4(0.,1.,0.,0.);\n\tvec4 C3 = vec4(0.,0.,1.,0.);\n\tvec4 C4 = vec4(1.0,0.52, 0.0, 1.0);\n    \n    if (x0 < x1 && uv.x > x0-thick && uv.x < x1+thick) { \n    \tfragColor = mix(vec4(0.1), C1, S(0.3, 0.002, abs(uv.x) *.95));\n    }\n    if (x1 < x2 && uv.x > x1-thick && uv.x < x2+thick)\n        fragColor = mix(vec4(0.1), C2, S(0.3, 0.002, abs(uv.x) *.95));\n    \n    if (x2 < x3 && uv.x > x2-thick && uv.x < x3+thick) {\n        fragColor = mix(vec4(0.1), C3, S(0.3, 0.002, abs(uv.x) *.95));\n    }        \n    if (x3 < x0 && uv.x > x3-thick && uv.x < x0+thick) {\n        fragColor = mix(vec4(0.1), C4, S(0.3, 0.002, abs(uv.x) *.95));\n    }\n    \n    // Add borders.\n    vec4 extCol = vec4(0.15);\n    vec4 intCol = vec4(0.2);\n    \n\tif (x0 < x1) {\n        fragColor = getColor(x0, x1, uv, intCol, extCol, fragColor);\n    }    \n    \n\tif (x1 < x2) {\n    \tfragColor = getColor(x1, x2, uv, intCol, extCol, fragColor);\n    }\n   \n   \tif (x2 < x3) {\n    \tfragColor = getColor(x2, x3, uv, intCol, extCol, fragColor);\n    }\n    \n    if (x3 < x0) {\n    \tfragColor = getColor(x0, x3, uv, intCol, extCol,fragColor);\n    \tif (x2 < x3) {\n            fragColor = getColor(x3, x0, uv, intCol, extCol, fragColor);    \t\n    \t}\n    }\n       \n    vec3 col2 = pow(fragColor.xyz,vec3(.454545));\n \tfragColor = vec4(col2,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3stfzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[109, 109, 257, 257, 1227], [1229, 1229, 1329, 1329, 1700], [1702, 1702, 1759, 1759, 3875]], "test": "valid"}
{"id": "3sVBzh", "name": "Approaching Darkness", "author": "oneshade", "description": "Another checkerboard thing.", "tags": ["tunnel", "checker", "infinite"], "likes": 4, "viewed": 96, "published": "Public", "date": "1606579934", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 3.0);\n    vec3 rd = normalize(vec3(uv, -1.0));\n    fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\n    float distTraveled = 0.0;\n    for (int i=0; i < 100; i++) {\n        vec3 pos = ro + rd * distTraveled;\n\n        pos.z -= 4.0 * iTime;\n        float c = cos(iTime), s = sin(iTime);\n        pos.xy = vec2(pos.x * c - pos.y * s, pos.x * s + pos.y * c);\n\n        vec3 q = abs(pos);\n        float dist = 1.0 - max(q.x, q.y);\n        if (dist < 0.001) {\n            vec2 uv = pos.xy;\n            if (q.x > q.y) {\n                uv = pos.yz;\n            }\n\n            if (q.y > q.x) {\n                uv = pos.xz;\n            }\n\n            fragColor += mod(floor(uv.x * 4.0) + floor(uv.y * 4.0), 2.0) * ((5.0 - distTraveled) / 5.0);\n            break;\n        }\n\n        if (distTraveled > 1000.0) {\n            break;\n        }\n\n        distTraveled += dist;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVBzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 1007]], "test": "valid"}
{"id": "3sVBzR", "name": "mirrors and rotations", "author": "StrangerintheQ", "description": "mirrors and rotations", "tags": ["mirrorsandrotations"], "likes": 7, "viewed": 111, "published": "Public", "date": "1606424612", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy-0.5;\n\tuv.x *= iResolution.x/iResolution.y;\n    float a = 3.1415/6.;\n    float cs = cos(a), sn = sin(a);\n    mat2 rot = mat2(cs, -sn, sn, cs); \n    for (float i=0.0; i<3.; i++ )\n        uv = abs(uv*rot);  \n    for (int i = 0; i <11; i++) {\n        float a = atan(uv.y, uv.x)*(0.5 + sin(iTime*0.2)*0.2);\n        sn = sin(a);\n        cs = cos(a);\n        uv = uv * mat2(cs, -sn, sn, cs);\n        uv.y = abs(uv.y) + sin(iTime)*0.04 + 0.04;\n        uv.x += 0.2+ sin(iTime)*0.02 + 0.02;\n    }\n    uv /= 1.7;\n    fragColor = vec4(\n        smoothstep(0.2, 0.0, fract(abs(uv.y-0.02)+iTime)*0.7),\n        smoothstep(0.2, 0.0, fract(abs(uv.y-0.04)+iTime)*0.71),\n        smoothstep(0.2, 0.0, fract(abs(uv.y-0.06)+iTime)*0.72),\n    1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sVBzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 823]], "test": "valid"}
{"id": "3sXXzf", "name": "sinewave", "author": "alfredo_giani", "description": "experiments on sinewaves\n", "tags": ["tutorial"], "likes": 1, "viewed": 38, "published": "Public", "date": "1605656940", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    float xshift = 0.5, yshift = 0.5;\n    float radius = sqrt(pow(uv.x - xshift,2.0) + pow(uv.y- yshift,2.0));\n    float sinewave = cos(100.0*radius +10.0*iTime);//sin(100.0*uv.x)+cos(100.0*uv.y);\n    \n    // Time varying pixel color\n    //vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    //fragColor = vec4(col,1.0);\n    fragColor = vec4(sinewave, 1.0 - sinewave, sinewave, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/3sXXzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 564]], "test": "valid"}
{"id": "td3BDj", "name": "psychedelic delirium", "author": "biboulette59", "description": "little fork off my first shader", "tags": ["sdfcolor"], "likes": 4, "viewed": 76, "published": "Public", "date": "1605986554", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv.x *= iResolution.x/iResolution.y;\n    vec3 color = vec3(0.0);\n    float d = 0.0;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(uv.xyx+vec3(1,2,4));\n    \n    uv = uv *15.+1.;\n\n  // Make the distance field\n    d = length( sin(uv) )+iTime*-.3;\n    \n    col = col+d;\n\n    // Output to screen\n    fragColor = vec4(vec3(sin(col*25.0)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3BDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 457]], "test": "valid"}
{"id": "td3fDl", "name": "RIP if you have epilepsy", "author": "Supergamer5465", "description": "e", "tags": ["e"], "likes": 1, "viewed": 75, "published": "Public", "date": "1606238275", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float DistLine(vec3 ro,vec3 rd,vec3 p) {\n    return length(cross(p-ro,rd))/length(rd);\n}\n\nfloat DrawPoint(vec3 ro, vec3 rd, vec3 p) {\n    float d = DistLine(ro, rd, p);\n    d=smoothstep(.1,.09, d);\n    return d;\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float t = iTime;\n    \n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=.5; // -.5 <> .5\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec3 ro = vec3(sin(tan(t*19000.)),sin(tan(t*19000.)),sin(tan(t*19000.)));\n    \n    float zoom=1.;\n    vec3 lap = vec3(.0);\n    vec3 f = normalize(lap-ro);\n    vec3 r = cross(vec3(0.,1.,0.),f);\n    vec3 u = cross(f,r);\n    \n    vec3 c = ro + f*zoom;\n    vec3 i = c+uv.x*r+uv.y*u;\n    vec3 ireverse = c+uv.y*r+uv.x*u;\n    \n    vec3 rd = i-ro;\n    vec3 reverse = ireverse-ro;\n\n    float t2 = iTime+1.5;\n    vec3 p = vec3(sin(t),0.,1.+2.*cos(t));\n    \n    vec3 p2 = vec3(sin(t),0.,1.+2.*cos(t));\n    \n    vec3 p3 = vec3(-sin(t),0.,1.+2.*cos(t));\n        \n    vec3 p4 = vec3(-sin(t),0.,1.+2.*cos(t));\n    \n    vec3 p5 = vec3(sin(t2),-sin(t2),1.+2.*cos(t2));\n    \n    vec3 p6 = vec3(sin(t2),sin(t2),1.+2.*cos(t2));\n    \n    vec3 p7 = vec3(-sin(t2),sin(t2),1.+2.*cos(t2));\n        \n    vec3 p8 = vec3(-sin(t2),-sin(t2),1.+2.*cos(t2));\n    \n    float d = DrawPoint(ro, rd, p);\n    float d2 = DrawPoint(ro, reverse, p2);\n    float d3 = DrawPoint(ro, rd, p3);\n    float d4 = DrawPoint(ro, reverse, p4);\n    float d5 = DrawPoint(ro, rd, p5);\n    float d6 = DrawPoint(ro, reverse, p6);\n    float d7 = DrawPoint(ro, rd, p7);\n    float d8 = DrawPoint(ro, reverse, p8);\n    \n    vec3 spherecolor = vec3(0.06);\n    \n    vec3 backg=0.5 + 0.5*cos(iTime*2.+sin(uv.yyy)+vec3(0,2,4));\n    \n    spherecolor+=vec3(d);\n    spherecolor+=vec3(d2);\n    spherecolor+=vec3(d3);\n    spherecolor+=vec3(d4);\n    spherecolor+=vec3(d5);\n    spherecolor+=vec3(d6);\n    spherecolor+=vec3(d7);\n    spherecolor+=vec3(d8);\n    \n    fragColor = vec4(backg*spherecolor,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3fDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 88], [90, 90, 133, 133, 218], [220, 220, 277, 277, 1948]], "test": "valid"}
{"id": "td3fRf", "name": "Minimal Raytracer Template", "author": "timeiskey", "description": "just used as a copyable template", "tags": ["raytracing", "raytracer", "template"], "likes": 1, "viewed": 40, "published": "Public", "date": "1605660202", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define AMBIENT 0.05\n#define SPECULAR 0.8\n#define DIFFUSE 0.2\n\nconst vec3 sphere_color\t= vec3(0.3, 0.4, 0.2);\nconst vec3 light_color \t= vec3(0.8, 0.7, 0.7);\n\nfloat sphere_intersect_dist(vec3 center, float radius, vec3 ray_origin, vec3 ray_dir)\n{\n    //\tsee if ray hit sphere\n    vec3 to_sphere = center - ray_origin;\n    float t = dot(to_sphere, ray_dir);\n    vec3 p = ray_origin + ray_dir * t;\n    float y = length(center - p);\n    \n    //\t//\tif hit\n    if( y < radius)\n    {\n        float x = sqrt(radius*radius - y*y);\n        float front_hit_t = t-x;\n        \n        return front_hit_t;\n\t}\n    else\n    {\n    \treturn -1.0;\n    }\n}\n    \t\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\tstart it off\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n\n    //\tfire a ray for each pixel\n    vec3 ro = vec3(0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1));\n    \n    //\tmake the scene\n    vec3 light = vec3(\n        cos(iTime/1.0),\n        0.6,\n        sin(iTime/1.0)\n    );\n    light = light * 5.0;\n    \n    vec3 s = vec3(0, 0, 4);\n    float r = 0.8;\n\n\tfloat front_hit_t = sphere_intersect_dist(s, r, ro, rd);\n    if(front_hit_t > 0.0)\n    {\n        vec3 hp = ro + rd * front_hit_t;\n\n        //\tlighting model\n        vec3 to_light = normalize(light - hp);\n        vec3 normal = normalize(hp - s);\n\n        //\t//\tambient \n        col += sphere_color * AMBIENT;\n\n        //\t//\tlambert\n        float b = max(dot(to_light, normal),0.0);\n        col += b * sphere_color * DIFFUSE;\n\n        //\t//\tblinn_phong\n        vec3 to_cam = normalize(ro - hp);\n        vec3 half_vec = normalize(to_light + to_cam);\n        b = max(dot(normal, half_vec), 0.0);\n        b = pow(b, 50.0);\n        col += b * light_color * SPECULAR;\n    }\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3fRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 245, 274, 635], [643, 643, 700, 720, 1800]], "test": "valid"}
{"id": "td3fRr", "name": "golden god", "author": "Dombass", "description": "toying around", "tags": ["dennisreynolds"], "likes": 5, "viewed": 85, "published": "Public", "date": "1604191046", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nmat4 rotationX( in float angle ) {\n\treturn mat4(\t1.0,\t\t0,\t\t\t0,\t\t\t0,\n\t\t\t \t\t0, \tcos(angle),\t-sin(angle),\t\t0,\n\t\t\t\t\t0, \tsin(angle),\t cos(angle),\t\t0,\n\t\t\t\t\t0, \t\t\t0,\t\t\t  0, \t\t1);\n}\n\nmat4 rotationY( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t0,\t\tsin(angle),\t0,\n\t\t\t \t\t\t\t0,\t\t1.0,\t\t\t 0,\t0,\n\t\t\t\t\t-sin(angle),\t0,\t\tcos(angle),\t0,\n\t\t\t\t\t\t\t0, \t\t0,\t\t\t\t0,\t1);\n}\n\nmat4 rotationZ( in float angle ) {\n\treturn mat4(\tcos(angle),\t\t-sin(angle),\t0,\t0,\n\t\t\t \t\tsin(angle),\t\tcos(angle),\t\t0,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t1,\t0,\n\t\t\t\t\t\t\t0,\t\t\t\t0,\t\t0,\t1);\n}\n\nfloat sphereSDF(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat noise(vec3 p) //Thx to Las^Mercury\n{\n\tvec3 i = floor(p);\n\tvec4 a = dot(i, vec3(1., 57., 21.)) + vec4(0., 57., 21., 78.);\n\tvec3 f = cos((p-i)*acos(-1.))*(-.5)+.5;\n\ta = mix(sin(cos(a)*a),sin(cos(1.+a)*(1.+a)), f.x);\n\ta.xy = mix(a.xz, a.yw, f.y);\n\treturn mix(a.x, a.y, f.z);\n}\n\nfloat sphere(vec3 p, vec4 spr)\n{\n\treturn length(spr.xyz-p) - spr.w;\n}\n\nfloat flame(vec3 p, vec3 cone)\n{\n\tfloat d = sphere(p*cone, vec4(.0,-1.,.0,1.));\n\tfloat fl = abs(d + (noise(p+vec3(1.,iTime*.75,1.0)) + noise(p*3.)*.5)*.25*(p.y)) ;\n    return min(20.-d , fl );\n}\n\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat scene(in vec3 pos) {\n    float final = sphereSDF(pos, 2.);\n    \n    {\n    \tvec3 toTheLeft = pos;\n    \ttoTheLeft.x -= .8;\n    \ttoTheLeft.z -= 2.;\n        toTheLeft.y -= .3;\n    \tfloat sphere = sphereSDF(toTheLeft, .4);\n    \tfinal = opSmoothSubtraction(sphere, final, 0.01);\n    }\n    \n    {\n    \tvec3 toTheLeft = pos;\n    \ttoTheLeft.x += .85;\n    \ttoTheLeft.z -= 2.0;\n        toTheLeft.y -= .3;\n    \tfloat sphere = sphereSDF(toTheLeft, .4);\n    \tfinal = opSmoothSubtraction(sphere, final, 0.01);\n    }\n    \n     {\n    \tvec3 toTheLeft = (vec4(pos, 1.)*rotationZ(3.14)).xyz;\n    \ttoTheLeft.y += .1;\n    \ttoTheLeft.z -= 2.0;\n    \tfloat sphere = sdCappedTorus(toTheLeft, vec2(0.2, 0.1),1., .2);\n    \tfinal = opSmoothSubtraction(sphere, final, 0.01);\n    }\n    {\n        vec3 toTheLeft = (vec4(pos, 1.)*rotationZ(3.14)).xyz;\n        final = min(final, flame(toTheLeft, vec3(.2, .4, .9)));\n    }\n    \n    return final;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.0005;\n    return normalize( e.xyy*scene( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*scene( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*scene( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*scene( pos + e.xxx ) );\n}\n\nvec4 raymarch(vec3 org, vec3 dir)\n{\n\tfloat d = 0.0, glow = 0.0, eps = 0.001;\n\tvec3  p = org;\n\t\n\tfor(int i=0; i<10; i++)\n\t{\n\t\td = scene(p) + eps;\n\t\tp += d * dir;\n\t\tif( d>eps )\n\t\t{\n\t\t\tif(scene(p) < 0.)\n       \t\t\tglow = float(i)/28.;\n\t\t}\n\t}\n    \n\treturn vec4(p,glow);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 eye = vec3(0, 2.1, 10.);\n    vec3 rayDir = rayDirection(90., iResolution.xy, fragCoord);\n    vec4 p = raymarch(eye, rayDir);\n\tfloat glow = p.w;\n\t\n    vec3  lig = normalize( vec3(-0.0, -5., 0.) );\n    vec3  lig2 = normalize( vec3(-0.0, 5., 4.) );\n    vec3 hal = lig - rayDir;\n    \n    vec3 normal = calcNormal(p.xyz);\n    \n    float dif = clamp( dot( normal, lig ), 0.0, 1. );\n    float dif2 = clamp( dot( normal, lig2 ), 0.0, 1. );\n    vec3 mate = vec3(1.2);\n    vec3 col = mate*dif*vec3(.9,0.4,0.1);\n    vec3 col2 = mate*dif2*vec3(.9,0.1,0.1);\n    \n    vec4 blah =  vec4(1.,.5,.1, 1.);\n    fragColor = mix(vec4(col, 1.), blah, pow(glow*2.,4.));\n    fragColor = mix(fragColor, vec4(col2, 1.), p.z);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3fRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 36, 36, 175], [177, 177, 211, 211, 347], [349, 349, 383, 383, 516], [518, 518, 552, 552, 580], [582, 582, 624, 624, 861], [863, 863, 895, 895, 932], [934, 934, 966, 966, 1128], [1130, 1130, 1195, 1195, 1327], [1329, 1329, 1399, 1399, 1533], [1535, 1535, 1593, 1593, 1693], [1695, 1695, 1721, 1721, 2614], [2616, 2616, 2648, 2648, 2856], [2858, 2858, 2893, 2893, 3124], [3126, 3126, 3183, 3183, 3893]], "test": "valid"}
{"id": "td3fz7", "name": "neon_heart", "author": "skerys", "description": "First experiment of using raymarching to create something pleasant looking.\nWildly unoptimized :)", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 162, "published": "Public API", "date": "1604666942", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DISTANCE 10000.0\n#define SURFACE_DISTANCE 0.01\n#define EPSILON 0.01\n\nconst float PI = 3.14159265359;\nconst float deg2rad = 0.0174532925;\n\nmat2 rot(float a){\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nvec3 rotatePointUnityEuler(vec3 p, float x, float y, float z){\n\tp.xz *= rot(deg2rad * y);\n    p.zy *= rot(deg2rad * x);    \n    p.yx *= rot(deg2rad * z);\n    \n    return p;\n}\n\nfloat smin( float a, float b, float k )\n{\n    float h = max( k-abs(a-b), 0.0 )/k;\n    return min( a, b ) - h*h*k*(1.0/4.0);\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\n\nfloat sdSolidAngle(vec3 p, vec2 c, float ra)\n{\n  // c is the sin/cos of the angle\n  vec2 q = vec2( length(p.xz), p.y );\n  float l = length(q) - ra;\n  float m = length(q - c*clamp(dot(q,c),0.0,ra) );\n  return max(l,m*sign(c.y*q.x-c.x*q.y));\n}\n\nfloat sin01(float a)\n{\n    float b = sin(a*5.0) / 2.0 + 0.5;\n    return b*b;\n}\n\nfloat sin02(float a)\n{\n    float b = sin(a) / 2.0 + 0.5;\n    return b*b*b*b*b*b*b;\n}\n\nfloat sin03(float a)\n{\n    return sin(a) / 2.0 + 0.5;\n}\n\n\nfloat displacement(vec3 p)\n{\n    return sin(5.0 * p.x + 4.0*iTime)*sin(5.0 * p.y + 4.0*iTime)*sin(5.0 * p.z + 4.0*iTime);\n}\n\nfloat distanceToScene(vec3 p)\n{\n    //Main sphere\n    vec4 mainSphere = vec4(0.07*sin01(iTime), -0.07*sin01(iTime), 0, 0.5 + 0.075*sin01(iTime));\n    float shape1 = sdSphere(p - mainSphere.xyz, mainSphere.w);\n    \n    //vec3 cylinderRightPos = vec3(0);\n    vec3 cylinderRightPos = vec3(0.227, 0.432, 0.099);\n    float cylinderRightRadius = 0.1 - 0.015 * sin02((iTime + PI/4.0 - 0.2)*5.0);\n    float cylinderRightHeight = 0.5;\n    \n    vec3 bp = p - cylinderRightPos;    \n    bp = rotatePointUnityEuler(bp, 58.423, 2.507, -22.109);\n    \n    shape1 = smin(shape1, sdRoundedCylinder(bp, cylinderRightRadius,0.1, cylinderRightHeight), 0.25);\n    \n    vec3 cylinderSmallPos = vec3(-0.1, 0.831, 0.568);\n    float cylinderSmallRadius = 0.075 - 0.01 * sin02((iTime + PI/4.0 - 0.1)*5.0);\n    float cylinderSmallHeight = 0.555;\n    \n    bp = p - cylinderSmallPos;\n    bp = rotatePointUnityEuler(bp, 65.568, -113.973, -41.671);\n    \n    shape1 = smin(shape1, sdRoundedCylinder(bp, cylinderSmallRadius,0.1, cylinderSmallHeight), 0.1);\n    \n    vec3 smallSpherePos = vec3(0.25 + 0.075*sin01(iTime - .03), -0.35 - 0.075*sin01(iTime - .03), -0.177 -  0.075*sin01(iTime - .03));\n    \n    bp = p - smallSpherePos;\n    bp = rotatePointUnityEuler(bp, -47.688, 23.452, 43.371);\n    \n    shape1 = smin(shape1, sdSphere(bp, 0.2  + 0.1*sin01(iTime - .03)), 0.3);\n    \n    vec3 anglePos = vec3(-0.108, 0.206, 0.137);\n    vec3 anglePos2 = vec3(0.218, 0.186, 0.259);\n    \n    bp = p - anglePos;\n    bp = rotatePointUnityEuler(bp, 10.428, 6.331, 42.379);\n    \n    shape1 = smin(shape1, sdSolidAngle(bp, vec2(sin(PI/4.0),cos(PI/4.0)), 0.4 - 0.1 * sin02((iTime + PI/2.0) * 5.0)) -0.1, 0.02);\n    \n    bp = p - anglePos2;\n    bp = rotatePointUnityEuler(bp, -41.338, -20.374, -74.936);\n    \n    shape1 = smin(shape1, sdSolidAngle(bp, vec2(sin(PI/4.0),cos(PI/4.0)), 0.4 - 0.1 * sin02((iTime + PI/2.0) * 5.0)) -0.1, 0.02);\n    \n    vec3 torusPos = vec3(0.228, 0.706, 0.503);\n    vec2 torusRadii = vec2(0.38, 0.18);\n    \n    bp = p - torusPos;\n    bp = rotatePointUnityEuler(bp, 22.816, 25.841, -106.461);\n    bp.y *= 1.0 - 0.05 * sin02((iTime + PI/4.0 - 0.15)*5.0);\n    bp.z *= 1.0 + 0.1 * sin02((iTime + PI/4.0 - 0.15)*5.0);\n        \n    float shape2 = sdTorus(bp, torusRadii);\n    \n    vec3 valveAPos = vec3(0.22, 1.024, 0.343);\n    vec3 valveBPos = vec3(0.317, 1.041, 0.478);\n    vec3 valveCPos = vec3(0.386, 0.991, 0.636);\n        \n    float valveRadius = 0.05;\n    float valveHeight = 0.4;\n    \n    bp = p - valveAPos;\n    bp = rotatePointUnityEuler(bp, -25.892, 30.911, -21.724);\n    \n    shape2 = smin(shape2, max(abs(sdRoundedCylinder(bp, valveRadius, 0.0, valveHeight)) - 0.01, bp.y - 0.3), 0.01);\n    \n    bp = p - valveBPos;\n    bp = rotatePointUnityEuler(bp, -6.346, 25.177, -22.851);\n    \n    shape2 = smin(shape2, sdRoundedCylinder(bp, valveRadius, 0.0, valveHeight-0.1), 0.01);\n    \n    bp = p - valveBPos;\n    bp = rotatePointUnityEuler(bp, 16.24, 18.123, -27.795);\n    \n    shape2 = smin(shape2, sdRoundedCylinder(bp, valveRadius, 0.0, valveHeight-0.1), 0.01);\n    \n    vec3 cylinderLeftPos = vec3(-0.255 + 0.03 * sin02((iTime + PI/4.0 - 0.2)*5.0), 0.075, 0.273);\n    float cylinderLeftRadius = 0.075;\n    float cylinderLeftHeight = 0.8;\n    bp = p - cylinderLeftPos;\n    \n    float k = 0.05 * sin02((iTime + PI/4.0 - 0.2)*5.0);\n    float c = cos(k*bp.y);\n    float s = sin(k*bp.y);\n    mat2 m = mat2(c, -s, s, c);\n    vec3 q = vec3(m*bp.xy,bp.z);\n    bp = q;\n    \n    float shape3 = sdRoundedCylinder(bp, cylinderLeftRadius, 0.0, cylinderLeftHeight);\n    \n    vec3 cylinderLeftSmall1Pos = vec3(-0.308 -0.02 * sin02((iTime + PI/4.0 - 0.2)*5.0), 1.085, 0.273);\n    float cylinderLeftSmall1Radius = 0.075;\n    float cylinderLeftSmall1Height = 0.25;\n    \n    bp = p - cylinderLeftSmall1Pos;\n    \n    k = -0.3 * sin02((iTime + PI/4.0 - 0.2)*5.0);\n    c = cos(k*bp.y);\n    s = sin(k*bp.y);\n    m = mat2(c, -s, s, c);\n    q = vec3(m*bp.xy,bp.z);\n    bp = q;\n    \n    bp = rotatePointUnityEuler(bp, 0.0, 0.0, 13.068);\n    \n    shape3 = min(shape3, sdRoundedCylinder(bp, cylinderLeftSmall1Radius,0.0, cylinderLeftSmall1Height));\n    \n    vec3 cylinderLeftSmall2Pos = vec3(-0.188-0.02 * sin02((iTime + PI/4.0 - 0.2)*5.0), 1.157, 0.257);\n    float cylinderLeftSmall2Radius = 0.075;\n    float cylinderLeftSmall2Height = 0.2;\n    \n    bp = p - cylinderLeftSmall2Pos;\n    bp = rotatePointUnityEuler(bp, -25.213, 22.086, -51.354);\n    \n    shape3 = smin(shape3, max(abs(sdRoundedCylinder(bp, cylinderLeftSmall2Radius,0.0, cylinderLeftSmall2Height)) - 0.02, bp.y - 0.14), 0.01);\n    \n    float dist = min(shape1, shape2);\n    dist = min(dist, shape3);\n    \n    dist += displacement(p) * 0.01;\n    \n    return dist;\n    \n}\n\nconst float NOISE_GRANULARITY = 255.0/255.0;\nfloat random(vec2 coords) {\n\treturn fract(sin(dot(coords.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nvec2 rayMarch(vec3 ro, vec3 rd, vec2 uv)\n{\n    float d = 0.0;\n    float iter = 0.0;\n    for(int i = 0; i < MAX_STEPS && d < MAX_DISTANCE; i++)\n    {\n        iter += 1.0;\n        vec3 p = ro + rd * d;\n        float dist = distanceToScene(p);\n        d += 0.75 * dist;\n        if(dist < SURFACE_DISTANCE)\n        {\n            \n            return vec2(d, iter + (iter/6.0 + 0.5) * dist / SURFACE_DISTANCE);\n        }\n    }\n    return vec2(0.0, iter - d / MAX_DISTANCE + 1.0);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - .5*iResolution.xy) / iResolution.y;\n\n\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0, 0.3, -3);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1)); \n\n    vec2 d = rayMarch(ro, rd, uv);\n   \n    vec3 gold = vec3(0.6, 0.4, 0.05);\n    vec3 lavender = vec3(0.58, 0.48,0.71);\n    \n    vec3 myCol = mix(gold, lavender, sin03(iTime * 2.5));\n\n    col = sin02(iTime * 5.0) * myCol * d.y * d.x / 75.0 + myCol * d.y / 50.0;\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/td3fz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[172, 172, 190, 190, 263], [265, 265, 327, 327, 439], [441, 441, 482, 482, 566], [568, 568, 601, 601, 666], [668, 668, 701, 701, 729], [731, 731, 795, 795, 912], [914, 914, 960, 995, 1155], [1157, 1157, 1179, 1179, 1235], [1237, 1237, 1259, 1259, 1321], [1323, 1323, 1345, 1345, 1378], [1381, 1381, 1409, 1409, 1504], [1506, 1506, 1537, 1555, 6196], [6243, 6243, 6270, 6270, 6344], [6346, 6346, 6388, 6388, 6821], [6825, 6825, 6882, 6932, 7428]], "test": "valid"}
{"id": "tdcBD2", "name": "stars test", "author": "perebalsach", "description": "test shader for star field sifi", "tags": ["lines", "dots"], "likes": 8, "viewed": 192, "published": "Public", "date": "1606048331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(a, b, t) smoothstep(a, b, t)\n\n// Config --------------------------\n#define LINEWIDTH .02\n#define SCALE 10.\n#define DOTSIZE 12.\n#define STARTSCOLOR vec3(.1, .6, 1.);\n// ----------------------------------\n\n\n\n\n\nfloat DistLine(vec2 p, vec2 a, vec2 b)\n{\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float t = clamp(dot(pa, ba)/dot(ba, ba), 0., 1.);\n    return length(pa - ba*t);\n}\n\nfloat N21(vec2 p)\n{\n    p = fract(p * vec2(215.33, 817.23));\n    p += dot(p, p+ 25.24);\n    return fract(p.x * p.y);\n}\n\nvec2 N22(vec2 p)\n{\n    float n = N21(p);\n    return vec2(n, N21(p+n));\n}\n\nvec2 GetPos(vec2 id, vec2 offset)\n{\n    vec2 n = N22(id + offset) * iTime;\n    return offset+sin(n)*.9;\n}\n\nfloat Line(vec2 p, vec2 a, vec2 b)\n{\n\tfloat d = DistLine(p, a, b);\n    float m = S(LINEWIDTH, .01, d);\n    float d2 = length(a-b);\n    m *= S(1.6, .3, d2)*.5 + S(.05, .01, abs(d2-.75));\n    \n    return m;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord -.5 *iResolution.xy) / iResolution.y;\n\t\n    float m = 0.;\n    uv *= SCALE;\n    \n    vec2 gv = fract(uv) - .5;\n    vec2 id = floor(uv);\n    \n    vec2 p[9];\n    int i = 0;\n    for(float y=-1.; y<=1.; y++)\n    {\n        for(float x=-1.; x<=1.; x++)\n    \t{\n    \t\tp[i++] = GetPos(id, vec2(x, y));\n        }\n    }\n    \n    float t = iTime*10.;\n    for (int i=0; i<9; i++)\n    {\n        m += Line(gv, p[4], p[i]);\n        \n        vec2 j = (p[i]-gv) * DOTSIZE;\n        float sparkle = 1./ dot(j, j);\n        m += sparkle * (sin(t+fract(p[i].x)*10.) * .5 + .5);\n    }\n    \n    m += Line(gv, p[1], p[3]);\n    m += Line(gv, p[1], p[5]);\n    m += Line(gv, p[7], p[3]);\n    m += Line(gv, p[7], p[5]);\n    \n    vec3 col = vec3(m);\n    vec3 starsColor = STARTSCOLOR;\n    col *= starsColor; \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcBD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[218, 218, 258, 258, 382], [384, 384, 403, 403, 502], [504, 504, 522, 522, 576], [578, 578, 613, 613, 683], [685, 685, 721, 721, 891], [893, 893, 950, 950, 1790]], "test": "valid"}
{"id": "tdcBDM", "name": "waving colors 2", "author": "elenzil", "description": "simple waving colors. added some horizontal anti-aliasing and shaping.", "tags": ["spangled"], "likes": 1, "viewed": 222, "published": "Public API", "date": "1605223575", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// http://iquilezles.org/www/articles/palettes/palettes.htm for more information\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palette(float t) {\n    return pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // artificial down-resing to test AA\n    const float pixelate = 1.0;\n    \n    fragCoord = round(fragCoord / pixelate);\n    \n    vec2 res = ceil(iResolution.xy / pixelate);\n    \n    vec2 uv = fragCoord/res.xy;\n    \n    const int bins = int(40.0 / pixelate);\n\n    vec3 col = vec3(0.0);\n    \n    // phased-in behavior\n    float phWig = smoothstep(1.0, 15.0, iTime);\n    float phBin = smoothstep(6.0, 18.0, iTime);\n    float phTap = smoothstep(9.0, 30.0, iTime);\n    float phPin = smoothstep(0.0, 15.0, iTime);\n    \n    float accum = 0.0;\n\n    // horizontal AA amount\n    float binEdge = 4.0 / res.x;\n\n    \n    for (int bin = 0; bin < bins; ++bin) {\n        float binMid = (float(bin) + 0.5)/float(bins);\n        float t = uv.x;\n        \n        // taper the overall thing\n        t = ((t - 0.5) * (1.0 + pow(uv.y, 0.8) * 0.5 * phPin)) + 0.5;\n        \n        // wiggle the things\n        float fmod = sin(binMid * 3.0 - iTime * 0.31) * 0.5 + 0.5;\n        t += abs(uv.x - 0.5) * phWig * uv.y * 0.4 * sin(uv.y * 20.0 - iTime * (1.0 + phBin * binMid + 0.6) + fmod);\n        \n        // wiggle the overall thing a tiny bit\n        t += 0.01 * phWig * uv.y * sin(uv.y * 7.0 - iTime);\n        \n        float binWidth = 1.0 / float(bins) * (1.0 - phTap * uv.y * 0.75);\n        float binBeg = binMid - binWidth * 0.5;\n        float binEnd = binMid + binWidth * 0.5;\n        if (t >= binBeg - binEdge && t < binEnd + binEdge) {\n            // AA:\n            float amount = 1.0;\n            if (t < binBeg) {\n                amount = smoothstep(binBeg - binEdge, binBeg, t);\n            }\n            else if (t > binEnd) {\n                amount = 1.0 - smoothstep(binEnd, binEnd + binEdge, t);\n            }\n            \n    \t\tcol += palette(t) * amount;\n            accum += amount;\n        }\n        binBeg = binEnd;\n    }\n    \n    col /= max(accum * 1.0, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcBDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 81, 149, 149, 192], [194, 194, 217, 217, 313]], "test": "valid"}
{"id": "tdcBRf", "name": "Artistic Water Foam", "author": "Daizuukee", "description": "An artistic Water shader, the perlin noise function is not written by me.", "tags": ["water", "artistic"], "likes": 6, "viewed": 239, "published": "Public API", "date": "1605720479", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float random (vec2 st) {\n    return fract(sin(dot(st,\n                         vec2(12.9898,78.233)))*\n        43758.5453123);\n}\n\nvec2 point (vec2 st) {\n  return vec2(random(st),random(st.yx)) / 2. + 0.5;\n}\n\nfloat dist (vec2 a, vec2 b) {\n  return sqrt(pow(a.x - b.x,2.) + pow(a.y - b.y,2.));\n}\n\nvec4 voronoi(vec2 p, float roundness, out vec2 smallestp) {\n  \n  int C = 2;\n  \n  float offset = 1.5;\n  \n  vec2 closest;\n  float mindist = float(C*C);\n  float secondmin = mindist;\n  vec2 secclosest;\n  \n  \n  for(int x = -C; x <= C; x++)\n    for(int y = -C; y <= C; y++) {\n      vec2 vp = point(floor(p) + vec2(x,y)) * offset;\n      float d = dist(vp + floor(p) + vec2(x,y),p);\n      \n      float size = pow(random(vp) / 4. + 0.5,roundness);\n      float comp = d * size;\n      \n      if(mindist > comp) {\n        secclosest = closest;\n        secondmin = mindist;\n        \n        closest = vp + vec2(x+y);\n        smallestp = floor(p) + vec2(x, y);\n        mindist = comp;\n      }\n      else if(secondmin > comp) {\n        secclosest = vp + vec2(x+y);\n        secondmin = comp;\n      }\n    }\n    \n  return vec4(fract(closest.x),fract(closest.y),mindist,(secondmin - mindist));\n}\n\nvec4 voronoi (vec2 p, float roundness) {\n  vec2 temp;\n  return voronoi(p,roundness,temp);\n}\n\n\n\n//\n\nvec3 permute( vec3 x){\n  return mod(((x*34.0) +1.0)*x,  289.0) ;\n}\nvec3 taylorInvSqrt (vec3 r){\n  return  1.79284291400159-0.85373472095314*r;\n  }\nfloat snoise(vec2 P){\n  const vec2 C = vec2 (0.211324865405187134,  // (3.0-sqrt ( 3 . 0 ) ) / 6 . 0 ;\n  0.366025403784438597) ;  //  0.5*( sqrt ( 3 . 0 )-1.0) ;\n  //  First  corner\n  vec2 i = floor(P+ dot (P,C.yy)  ) ;\n  vec2 x0=P-i+ dot (i,C.xx) ;// Other  corners\n  vec2 i1;\n  i1.x = step (x0.y,x0.x) ;  //  1.0 if(x0.x > x0.y ,  e l s e  0.0\n  i1.y = 1.0-i1.x;\n  // x1 = x0-i1 + 1.0*C. xx ;  x2 = x0-1.0 + 2.0*C. xx ;\n  vec4 x12 = x0.xyxy + vec4 (C.xx,C.xx*2.0-1.0) ;x12.xy-=i1;//  Permutations\n  i = mod(i,  289.0);  // Avoid  truncation  in  polynomial  evaluation\n  vec3 p = permute(permute(i.y+ vec3 (0.0 ,i1.y,  1.0  ) )+i.x+ vec3 (0.0 ,i1.x,  1.0  ) ) ;//  Circularly  symmetric  blending  kernel\n  vec3 m = max(0.5-vec3 ( dot (x0,x0) ,  dot (x12.xy,x12.xy) ,dot (x12.zw,x12.zw) ) ,  0.0) ;m=m*m;m=m*m;//  Gradients  from 41  points  on a  line ,  mapped onto a diamond\n  vec3 x= fract(p*(1.0  /  41.0) )*2.0-1.0  ;vec3 gy= abs (x)-0.5  ;vec3 ox= floor(x+ 0.5) ;  // round (x)  i s  a GLSL 1.30  feature\n  vec3 gx = x-ox;//  Normalise  gradients  i m p l i c i t l y  by  s c a l i n g m\n  m *= taylorInvSqrt(gx*gx+gy*gy) ;// Compute  f i n a l  noise  value  at P\n  vec3 g;g.x=gx.x*x0.x+gy.x*x0.y;g.yz=gx.yz*x12.xz+gy.yz*x12.yw;//  Scale  output  to  span  range  [-1 ,1]//  ( s c a l i n g  f a c t o r  determined by  experiments )\n  return  130.0*dot (m,g) ;\n}\n\n\n\nvoid mainImage( out vec4 out_color, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv -= 0.5;\n\tuv /= vec2(iResolution.y / iResolution.x, 1);\n  float size = 12.;\n  uv *= size;\n  uv += iTime * vec2(1,0) + vec2(cos(iTime) * 0.2,0);\n  float PixelSize = 0.08;\n  //uv = floor(uv / PixelSize) * PixelSize;\n  \n  vec2 pos = vec2(0);\n  vec4 v = voronoi(uv + vec2(0., snoise(uv / 10. +vec2(iTime / 10. + 5.,0.)) * 0.25),-4. + sin(iTime * 0.5) * 0.5,pos);\n  if(v.a < 0.3) {\n    out_color = vec4(1);\n  }\n  else {\n    vec4 waterv = vec4(0.5);\n    int iterations = 4;\n    for(int i = 0; i < iterations; i++) {\n    waterv += (random(voronoi(uv + random(vec2(i,float(i) + 0.9)) * pow(4.,float(i)), -2.).xy) - 0.5) * (float(iterations-i)/(float(iterations)/30.));\n    }\n    float depth = pow(floor((pos.y + 10. * size) / (size / 0.2)) / 8.,0.3) * pow(floor((-pos.y + 5. * size) / (0.4 * size)) / 12.,10.);\n    float noise = (snoise(uv / 10.) + 1.) + 0.5;\n    out_color = vec4(0.1,0.4,0.9,1) * pow(v.a,0.4) / 8. * pow(point(waterv.xy).y,0.4) * depth * noise * 4.;\n    \n    vec4 nv = voronoi(uv + vec2(0., snoise(uv / 10. +vec2(iTime / 10. + 5.,0.) + 900.) * 0.25 + 0.4),-4.  + sin(iTime * 0.5) * 0.5,pos);\n    if(nv.a < 0.3) {\n      out_color *= 0.5;\n    }\n  }\n    vec2 position;\n    vec4 lastv = voronoi(uv*20.,20.,position);\n    out_color *= vec4(1.-random(position.xy)/8.);\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcBRf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 24, 24, 128], [130, 130, 152, 152, 206], [208, 208, 237, 237, 293], [295, 295, 354, 354, 1171], [1173, 1173, 1213, 1213, 1264], [1272, 1272, 1294, 1294, 1338], [1339, 1339, 1367, 1367, 1418], [1419, 1419, 1440, 1440, 2793]], "test": "valid"}
{"id": "tdcfDf", "name": "hoeled_planet", "author": "hoeled", "description": "Practice makes perfect.", "tags": ["2d"], "likes": 1, "viewed": 52, "published": "Public", "date": "1606768782", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define CIRCLES 3.\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.);\n    \n    // middle circle\n    float d = length(uv);\n    float middleCircle = smoothstep(0.102, 0.1, d);\n    float middleGradient = smoothstep(0.14, 0.0, d);\n    col.r += middleCircle;\n    col.rgb += middleGradient*.19;\n    \n    // satellites\n    for(float i=1.; i<=CIRCLES; i++) {\n    \tfloat dist = .1 + 0.085 * i;\n        float t = (iTime*i*fract(i*10.900))/2.-i*10.;\n        \n        // circles\n    \tvec2 s = vec2(length(uv.x-dist*sin(t)), length(uv.y-dist*cos(t)));\n        float circle = smoothstep(0.041, 0.04, length(s));\n    \tcol += circle; // white circle\n        float grad = smoothstep(0.048, 0.000, length(s)); // circle gradient\n        \n        // lines\n        float lin = (smoothstep(dist-0.002, dist+0.001, length(uv)))*.9;\n        float lout = (smoothstep(dist+0.002, dist+0.003, length(uv)))*.9;\n        vec3 line = vec3(lin - lout);\n        line -= circle;\n        line *= vec3(.07, .07, .07);   \n        \n        // colors\n        if(i==1.) {    \n            col.b -= circle;\n            col += clamp(line, 0., 1.);\n            col += grad*.24;\n        }\n        if(i==2.) {\n            col.rg -= circle*.7;\n            col += clamp(line, 0., 1.);\n            col += grad*.05;\n        }\n        if(i==3.) {\n            col.g -= circle;\n            col.b -= circle*0.5;\n            col += clamp(line, 0., 1.);\n            col += grad*.18;\n        }\n        if(i>3.) {\n            col -= circle*.7;\n        }\n    }\n        \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcfDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 77, 77, 1636]], "test": "valid"}
{"id": "tdcfDH", "name": "Nodevember Day10", "author": "antoinefortin", "description": "Antoine Nodevember", "tags": ["nodevember"], "likes": 2, "viewed": 63, "published": "Public", "date": "1604992720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 rotate(vec2 pos, float angle)\n{\n\tfloat c = cos(angle);\n    float s = sin(angle);\n    \n    return mat2(c,s,-s,c) * pos;\n\n}\n\n/* SDF */\nfloat sdSphere(vec3 pos, float r)\n{\n\treturn length(pos) - r;\n}\n\nfloat sdPlane(vec3 pos)\n{\n\treturn pos.y;\n}\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\n\nvec2 opu(vec2 d1, vec2 d2)\n{\n\treturn (d1.x < d2.x) ? d1 : d2;\n}\n\nfloat sdCone( in vec3 p, in vec2 c, float h )\n{\n  // c is the sin/cos of the angle, h is height\n  // Alternatively pass q instead of (c,h),\n  // which is the point at the base in 2D\n  vec2 q = h*vec2(c.x/c.y,-1.0);\n    \n  vec2 w = vec2( length(p.xz), p.y );\n  vec2 a = w - q*clamp( dot(w,q)/dot(q,q), 0.0, 1.0 );\n  vec2 b = w - q*vec2( clamp( w.x/q.x, 0.0, 1.0 ), 1.0 );\n  float k = sign( q.y );\n  float d = min(dot( a, a ),dot(b, b));\n  float s = max( k*(w.x*q.y-w.y*q.x),k*(w.y-q.y)  );\n  return sqrt(d)*sign(s);\n}\n\n\nfloat h(vec2 p)\n{\n    \n\tfloat ba = texture(iChannel1, p * 0.055).x ;    \n    float b = (sin(p.x * 2.))  ;\n    \n    b*=  ba * sin( cos( 2.)) * abs(sin(1.) + 1.25);\n    b *= b - abs(sin(iTime));\n    return -b - 1.2;\n}\n\n\n\n\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n\nfloat sapin(vec3 pos)\n{\n\t\n    vec3 q = pos;\n    float d = 0.0;\n\tfloat pine = sdCone(q, vec2(.25, .25), .5);\n    \n    \n\n        \n    return pine;\n   \n}\n\nfloat cloud(vec3 pos)\n{\n\tfloat d = 0.0;\n    vec3 q = pos;\n    \n\t// Define the radius of cloud modulation...\n   \tq.y -= 1.75;\n    \n    q.z = mod(q.z+ 1., 2.) -1.;\n    \n\tq.x = mod(q.x+ 1.5, 3.) -1.5;\n   \n    vec3 cr = vec3(.25, .15, .15);\n\n    cr.x += .01 + abs(sin((q.x * 50. + iTime * 5.))) * 0.05;\n \n    \n    cr.y += abs(cos((q.y + iTime))) * 0.009;\n    \n    d = sdEllipsoid(q, cr);\n    \n    return d;\n}\nfloat trees(vec3 pos)\n{\n\tvec3 q = pos;\n    q.y -= .2;\n    q.z -= .2;\n    q.x += 1.2;\n    float modEn= 1.0;\n\tq.xz = mod(q.xz+ 1., 2.) -1.;\n    q.yz = rotate(q.yz, 1.65);\n    float d = sdHexPrism(q, vec2(.015, .215));\n    \n    return d;\n}\n\n\nfloat feuilles(vec3 pos)\n{\n    float originLeaves = .2;\n\tpos.y -= originLeaves;\n    vec3 q = pos;\n    q.y -= .2;\n    q.z -= .2;\n    q.x += 1.2;\n\tq.xz = mod(q.xz+ 1., 2.) -1.;\n    q.yz = rotate(q.yz, 1.65 +(sin(iTime) * .5));\n\n    float d = sdHexPrism(q, vec2(.15, .0215));\n    \n    q = pos; // snap back to origin\n\tq.y -= .25;\n    q.z -= .2;\n    q.x += 1.2;\n\tq.xz = mod(q.xz+ 1., 2.) -1.;\n\tq.yz = rotate(q.yz, 1.+sin(iTime));\n    float d1 = sdHexPrism(q, vec2(.12, .0245));\n    \n        \n    q = pos; // snap back to origin\n\tq.y -= .30;\n    q.z -= .2;\n    q.x += 1.2;\n    q.xz = mod(q.xz+ 1., 2.) -1.;\n\tq.xy = rotate(q.xy, 1.65 + cos(iTime));\n    float d2 = sdHexPrism(q, vec2(.10, .0245));\n    \n            \n    q = pos; // snap back to origin\n\tq.y -= .40;\n    q.z -= .2;\n    q.x += 1.2;\n\tq.yz = rotate(q.yz, 1.65);\n    q.xz = mod(q.xz+ 1., 2.) -1.;\n    float d3 = sdHexPrism(q, vec2(.075, .025));\n    \n    \n\tq = pos; // snap back to origin\n\tq.y -= .35;\n    q.z -= .2;\n    q.x += 1.2;\n    q.xz = mod(q.xz+ 1., 2.) -1.;\n\tq.xz = rotate(q.xz,  cos(iTime * 1.5));\n    float d4 = sdHexPrism(q, vec2(.085, .02));\n    \n\n    \n    return min(d,min(d1,min(d2,min(d3,d4))));\n}\n\n\nvec2 map(vec3 pos)\n{\n    \n    \n\tfloat sphere = sdSphere(pos + vec3(0.0, -.15, 0.0), .15);\n    \n    \n    \n    float theFloor = sdPlane(pos + vec3(0.0, -1.2, 0.0)) - (h(pos.xz));\n    \n\tfloat waterPlane = sdPlane(pos+ vec3(0.0, .08, 0.0));\n    \n\t\n    float trunk = trees(pos);\n    float feuille = feuilles(pos);\n    \n    float sapin = sapin(pos);\n    float cloudRepeat = cloud(pos);\n\tvec2 res =     vec2(sphere,       1.0 /*Object ID*/);\n    res = opu(res, vec2(theFloor,     2.0 /*Object ID*/));\n    res = opu(res, vec2(trunk,     3.0 /*Object ID*/));\n    res = opu(res, vec2(feuille,     4.0 /*Object ID*/));\n    \n    res = opu(res, vec2(cloudRepeat,    5./*Object ID*/));\n    \n    res = opu(res, vec2(waterPlane,    6./*Object ID*/));\n    \n    \n    \n \n     \n    \n    \n    return res;\n}\n\n\nvec2 castRay(vec3 ro, vec3 rd)\n{\n\n    float t = 0.0;\n    float id = -20.;\n\tfloat farClippingPlane = 7.0;\n    \n    for(int i = 0; i < 256; i++)\n    {\n        \n    \tvec3 pos = ro + t * rd;\n        float h = map(pos).x;\n        id = map(pos).y;\n        \n        if(h < 0.001)\n        {\n        \tbreak;\n        }\n        t += h;\n        if(t > farClippingPlane) break;\n        \n    }\n    \n    if(t > farClippingPlane) t = -1.0;\n    \n    return vec2(t, id);\n}\n\nvec3 calcNormal(vec3 pos)\n{\n    vec2 e = vec2(0.01, 0.0);\n    \n\treturn normalize(vec3(\n        \t\t\t\t\tmap(pos+e.xyy).x - map(pos-e.xyy).x,\n        \t\t\t\t\tmap(pos+e.yxy).x - map(pos-e.yxy).x,\n        \t\t\t\t\tmap(pos+e.yyx).x - map(pos-e.yyx).x\n    \t\t\t\t));\n}\n\nvoid resetToZero(inout vec3 r)\n{\n\tr = vec3(0.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\n\tvec3 ro = vec3(0., .45 ,-1.5 + iTime);\n\tvec3 rd = normalize(vec3(uv.x, uv.y - .2,1.)); \n\n\tvec3 col = vec3(.22);\n\t\n\t\n\tfloat hitDistance = castRay(ro, rd).x;\n    float objectId = castRay(ro, rd).y;\n    \n    vec3 unfinishedSky;\n    \n    // No hit color\n    if(hitDistance < 0.01)\n    {\n        \n        /* Sky properties*/\n        vec3 skyColor = vec3(.4, 0.75, 1.0);\n        float skyMovement = .5;\n\t\tcol = skyColor - abs( .5 + sin(iTime * skyMovement)) * rd.y * rd.x;\n        \n        \n        \n    }\n    \n    \n    if(hitDistance > 0.)\n    {\n       \tvec3 debugColor = vec3(1.);\n        vec3 pos = ro + hitDistance * rd;\n        vec3 normalWS = calcNormal(pos);\n\n        /* Global Lighting section */\n        \n        // Sky\n        vec3 skyColor = vec3(.4, 0.75, 1.0);\n\t\tfloat skyMovement = .5;\n        vec3 skyColFactor = skyColor - abs( .5 + sin(iTime * skyMovement)) * rd.y * rd.x;\n\t\t\n        // Basic lighting\n        vec3 sunPos = normalize(vec3(.5, .4, -.52));\n \t\tfloat fSunDiffuse = clamp(dot(normalWS, sunPos), 0., 1.);\n        float sunShadow = smoothstep(castRay(pos + normalWS * 0.001, sunPos).x, 0., 1.);\n\t\tfloat skyDif = dot(normalWS,vec3(0.,1.0,0.));\n        vec3 basicColor = vec3(.5, 0.75, 0.8) * (fSunDiffuse + (skyDif * .5)) * sunShadow;\n        col = basicColor * (skyColFactor * .75);\n\n        \n        \n        //col = skyColFactor;\n        /*End of Global Lighting section */\n        \n        \n        bool materialSystem = true;\n        \n        if(materialSystem)\n        {\n            float blendingFactor = .5;\n\t\t\t// Sphere\n        \tif(objectId == 1.0) \n        \t{\n        \t\tvec3 sphereMat = vec3(.2, .5, .6);\n                col = col;\n        \t}\n        \n        \t// Floor\n        \tif(objectId == 2.0)\n       \t\t{\n                /* Floor settings*/\n               \tfloat gridXF = 25.0f;\n\t\t\t\tfloat gridYF = 25.0f;\n                float changeFactor = iTime * .5;\n        \t\tvec3 floorColor = vec3(.25, .45, .3);\n\t\t\t\t// displace the floor\n                pos.x += sin(iTime * .2);\n                pos.z += cos(iTime * .2);\n                float f = .5 + abs(sin( sin(changeFactor) * (sin(pos.x * gridXF) * cos(pos.z * gridYF))));\n               \tvec3 pattern = vec3(f / 5.);\n                col = pattern * col + vec3(0., .22, 0.);\n                \n                {\n                 //resetToZero(col);\n                }\n        \t}\n            // trunk\n            if(objectId == 3.0)\n            {\n                vec3 trunk = vec3(255) / vec3(210,105,30);\n            \tcol = vec3(.8, .5, .2) * vec3(dot(normalWS, sunPos));\n            }\n            \n            // leaves\n            if(objectId == 4.)\n            {\n\t\t\t\t\n            \tcol = vec3(.4, .95, .2) * vec3(dot(normalWS, sunPos));\n            }\n            \n            /*Sapin*/\n            \n            if(objectId == 5.)\n            {\n                \n                // Get the position of the hit.\n                // Well it is pos...\n                // SO \n                float shadingAmoutOnClouds = dot(normalWS, sunPos);\n                vec3 bloop = texture(iChannel0, uv * 2.).xxx;\n            \tcol = vec3(shadingAmoutOnClouds) * bloop * 5.;\n            }\n            \n          // water\n\t\t\tif(objectId == 6.)\n            {\n                \n                // Get the position of the hit.\n                // Well it is pos...\n                // SO \n                \n\t\t\t\tvec3 waterC = vec3(dot(normalWS,sunPos + pos * .5));\n\t\t\t\tfloat hitDistance = castRay(ro, rd).x;\n    \t\t\tfloat objectId = castRay(ro, rd).y;\n                \n                \n                vec3 wcF =  (sin(uv.y * 120.) * uv.y * sin(uv.x * 120.)) * waterC * vec3(cos(hitDistance * pos.x), sin(objectId * 120.), cos(sin(waterC * hitDistance)));\n\t\t\t\tcol = waterC.xxx * (abs(wcF.xxx) + .5)  * vec3(.1, .15, .75);\n                col += vec3(0., 0., .4);\n                \n            }\n            \n            \n            \n            \n        }\n\n        \n        col = col;\n       \n        /*\n       \tvec3 sundir = normalize(vec3(0.2, 0.4, 0.2));\n        float sundif = clamp(dot(nor, sundir), 0.0, 1.0);\n        float sun_sha = smoothstep(castRay(pos + nor * 0.001, sundir).x,0., 1.);\n        float sky_dif = clamp(dot(nor,vec3(0.0,1.0,0.0)), 0.0, 1.0);;\n        \n        col = vec3(1.0, 0.7, 0.5) * sundif * sun_sha;\n        col += vec3(0.0, 0.2, 0.4) * sky_dif;\n\t\tcastRay(ro, rd).x */    \n\t}\n    // Output to screen\n    fragColor = vec4(sqrt(col),1.0);\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcfDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 36, 36, 126], [128, 138, 173, 173, 200], [202, 202, 227, 227, 244], [245, 245, 281, 281, 554], [557, 557, 588, 588, 675], [678, 678, 706, 706, 741], [743, 743, 790, 924, 1259], [1262, 1262, 1279, 1279, 1477], [1482, 1482, 1519, 1519, 1602], [1605, 1605, 1628, 1628, 1755], [1757, 1757, 1780, 1780, 2161], [2162, 2162, 2185, 2185, 2398], [2401, 2401, 2427, 2427, 3567], [3570, 3570, 3590, 3590, 4355], [4358, 4358, 4390, 4390, 4812], [4814, 4814, 4841, 4841, 5063], [5065, 5065, 5097, 5097, 5115], [5117, 5117, 5174, 5174, 9659]], "test": "error"}
{"id": "tdcfz7", "name": "Gold_monyaru", "author": "tono", "description": "Gold", "tags": ["monyaru"], "likes": 4, "viewed": 114, "published": "Public", "date": "1604654957", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float t = 0.;\nfloat pi = acos(-1.);\n\n#define MAX 100.\n\nvec2 min2(vec2 a,vec2 b)\n{\n    if(a.x < b.x){\n        return a;\n    }\n    return b;\n}\n\nfloat rand(vec2 a)\n{\n    return fract(sin(dot(a,vec2(123.45,67.89))*123.4 ));\n}\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n//\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n//https://www.shadertoy.com/view/XsX3zB\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n\nvec3 simplex3dVector(vec3 p)\n{\n    float s = simplex3d(p);\n    float s2 = simplex3d(random3(vec3(p.y,p.x,p.z)) + p.yxz);\n    float s3 = simplex3d(random3(vec3(p.z,p.y,p.x)) + p.zyx);\n    return vec3(s,s2,s3);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 d = vec2(100,0.);\n    p.xy *= rot(sin(p.z/3.)/2.);\n    d.x = p.y + .7;\n    \n    if(d.x < 1.)\n    {\n        d.x -= simplex3d(vec3(p.x,0.,p.z ) * 40. + t* .8)/100.;\n        d.x -= simplex3d(vec3(p.x,0.,p.z ) * .6)/50.;\n        d.x -= simplex3d(vec3(p.x,0. + t / 1.,p.z ) * .2)/1.1;\n        d.y = 0.;\n    }\n    vec3 p2 = p;\n    p.xy *= rot(-floor(p.z/pi));\n    p = cos(p) * 1.;\n    p.y -= sin(floor(p2.z/pi) + t);\n    p.x -= cos(floor(p2.z/pi) + t/2.) * .1;\n    d = min2(vec2(length(p) - .7,1.),d);\n    d.x *= .9;\n    return d;\n}\n\n\nvec2 march(vec3 cp,vec3 rd)\n{\n    float depth = 0.;\n    float id = 0.;;\n    for(int i = 0 ; i < 256 ; i++)\n    {\n        vec3 rp = rd * depth + cp;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.0001)\n        {\n            depth *= -1.;\n            id = d.y;\n            break;\n        }\n        if(depth > MAX){break;}\n        depth += d.x;\n    }\n    depth *= -1.;\n    return vec2(depth,id);\n}\n\nfloat map2(vec3 p)\n{\n    vec3 p2 = p;\n    p.xy *= rot(floor(p.z/pi));\n    p = cos(p) * 1.;\n    p.y -= sin(floor(p2.z/pi) + t);\n    p.x -= cos(floor(p2.z/pi) + t/2.) * .1;\n    return length(p) - .7;\n}\n\nfloat water(vec3 cp , vec3 rd,float maxdepth)\n{\n    float ac = 0.;\n    float depth = 0.;\n    for(int i = 0; i < 66 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        \n       // rp = simplex3dVector(rp);\n        float d = simplex3d(rp + vec3(0.,-t/8.,0.)) - .1  * abs(sin(0.7 * 1.2 + pi/2. * (simplex3d(rp /10.) - .5 )) - .1);\n        d = min(d,map2(rp ));\n        d = max(0.01,abs(d));\n        ac += exp(-d * .3);\n        if(depth > maxdepth){break;}\n        depth += d;\n    }\n    return ac - depth * depth;\n}\n\nvoid getCamra(vec2 p,out vec3 cp,out vec3 rd)\n{\n    t = iTime;\n    vec3 forward = vec3(0.,0.,0.);\n    forward.z += t/2.;\n    vec3 target = vec3(0.,0.,0.) + forward;\n    cp = vec3(0.,0.,-15.) + forward;\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    p.y *= -1.;\n    float fov = 2. - dot(p,p)/5.;\n\t//fov  = 2. - dot(p,p) * 6.;\n    rd = normalize(p.x * cs + p.y * cu + cd * fov);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n    vec3 cp,rd;\n    getCamra(p,cp,rd);\n    vec2 d = march(cp,rd);\n\tvec3 color = vec3(0.);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = d.x * rd + cp;\n        vec2 e = vec2(0.,0.001);\n        vec3 N = normalize(vec3( map(pos).x - vec3(map(pos - e.yyx).x,map(pos - e.yxy).x , map(pos - e.xyy).x) ));\n     \t//color = N;\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        sun.xz *= rot(2.1);\n        float diff = mix(max(dot(sun,N),0.),1.,0.);\n        float aor = d.x/MAX;\n        float ao = exp2(pow(max(0.,1. - map(pos + N * aor).x/aor),1.));\n        float fr = pow(1. + dot(N,rd),4.);\n        float spo = mix(3.,10.,d.y);\n        float sss = smoothstep(0.,1.,map(pos+sun * .4).x / .4);\n        float sp = pow(max(dot(reflect(-sun,N),-rd),0.),spo);\n        vec3 albedo = mix(vec3(.7,0.7,.3),vec3(1.,1.,.2),d.y);\n       // color = vec3(.6) * diff;\n        color = mix(sp * albedo + albedo * ao * (diff + sss),color,min(fr,.5));\n        float m = 1. - exp(-.000003 * d.x * d.x * d.x);\n   \t\tcolor = mix(color,vec3(0.),m);\n    }else{\n        d.x = MAX;\n    }\n    float ac = water(cp,rd,d.x);\n    vec3 wcolor = normalize( vec3(1.,.3,0.) ) * max(0.,ac)/180.;\n    color = clamp(color/2. + wcolor,vec3(0.),vec3(1.));\n //   color *= vec3(1.5,.5,1.);\n    color = clamp(color,0.,1.);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdcfz7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 81, 81, 140], [142, 142, 162, 162, 221], [222, 222, 240, 240, 283], [285, 312, 334, 334, 531], [678, 701, 726, 985, 1977], [1979, 1979, 2009, 2009, 2189], [2191, 2191, 2209, 2209, 2745], [2748, 2748, 2777, 2777, 3145], [3147, 3147, 3167, 3167, 3346], [3348, 3348, 3395, 3395, 3862], [3864, 3864, 3911, 3911, 4327], [4329, 4329, 4386, 4386, 5793]], "test": "valid"}
{"id": "tddBDr", "name": "Diseased Elf ", "author": "Manaz", "description": "cool", "tags": ["raymarching"], "likes": 3, "viewed": 46, "published": "Public", "date": "1604964319", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Manaz\n// Homework Assignment based on code: BASIC RAY-MARCHING CLASS DEMO\n//\n// Numerous methods borrowed from iq articles:\n//   https://iquilezles.org/www/index.htm\n// \n// 3D signed distance functions:\n//   https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// \n// Shadows:\n//   https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// \n// Ray-marching SDFs:\n//   https://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n// \n// Normals for SDFs:\n//   https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\nvec4  opUnion(vec4 d1, vec4 d2) {\n return (d1.x < d2.x ? d1 : d2);   \n}\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nvec4  opIntersection( vec4  d1, vec4  d2 ) {\n return (d1.x > d2.x ? d1 : d2);   \n    \n}\n\n// subtracts d1 from d2o\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nvec4  opSubtraction( vec4  d1, vec4  d2 ) { \n  return opIntersection(vec4(-d1.x,d1.yzw), d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n// 3D gradient noise methods. \n// https://www.shadertoy.com/view/Xsl3Dl\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nfloat fbm( in vec3 pos )\n{\n    vec3  q = 8.0*pos;\n    float f = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); //q = m*q*2.02;\n    //f += 0.1250*noise( q ); q = m*q*2.03;\n    //f += 0.0625*noise( q ); \n    return f;\n}\n\n\n\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, 0.,\n\t\t+.0, +.0, 1.);\n}\n\n// iq distance functions, \n// See https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere(vec3 p, float radius )\n{\n  return length(p)-radius;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// not exact\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// See https://www.shadertoy.com/view/Wdjfz3\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    \n    p.x = abs(p.x);\n    \n    float r = ra - rb;\n\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 bendPoint( in vec3 p , float amt)\n{\n    float k = amt; //  some amount, e.g., 10.\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n// Function to y-axis revolve a 2D SDF into a 3D SDF.\nvec2 revolvePoint( in vec3 p, float radius )\n{\n    return vec2( length(p.xz) - radius, p.y );\n}\n\n// Simple ellipsoidal SDF pumpkin at origin.\nfloat sdPumpkin(vec3 p) \n{\n\tfloat sdf = 100.;\n    for(int i=0; i<10; i++) {// somewhat expensive\n    \tvec3  rp = rotate_y(p, 6.28*float(i)/10.+0.27);\n        vec3  q  = rotate_z(rp-vec3(0.6,0.,0.),-0.1);\n\t    float d  = sdEllipsoid(q, vec3(0.8, 1., 0.6));\n        sdf = opSmoothUnion(d, sdf, 0.03);\n        //sdf = opUnion(d, sdf);\n    }\n    \n    return sdf;\n}\n\n\n/// SCENE PARAMETERS (feel free to add your own):\nconst vec3 pumpkinCenter = vec3(0., -.525, -12.);\nconst vec3 Cd_pumpkinOutside = vec3(255./255., 130./255., 180./255.); \nconst vec3 Cd_pumpkinInside  = vec3(0., 0., 0.);\nconst vec3 Cd_stem           = vec3(0.25,.45,0.15);\n\n// SDF implementation for our scene. \n// Returns 4 values: (sdf, Cd)\n//   .x: SDF distance, \n//   .y: Cd.r\n//   .z: Cd.g\n//   .w: Cd.b\n// NOTE: You could return other things for yzw, e.g., y:objectID int to set more colors in \"render.\"\nvec4 mapV4(in vec3 p)\n{\n    // SDF vector (sdf, r,g,b) to be returned:\n    vec4 sdf = vec4(100000., -1., 0., 0.);\n    \n    float mx = iMouse.x/iResolution.x;\n\n    // TODO: REPLACE THE FOLLOWING WITH YOUR SCENE CODE:\n    \n    // Translate coordinate to pumpkin center:\n    vec3 c = pumpkinCenter;\n    p -= c;\n    \n    {// BODY:\n\t\t// OUTSIDE: Union of ellipsoids\n        vec3 q = p;//local copy\n        sdf.x = sdPumpkin(q);\n        sdf.yzw = Cd_pumpkinOutside;// + 0.1*vec3(1.,1.,0.)*length(q.xz);\n        if(sdf.x < .001) {\n            float theta = atan(q.z,q.x) + 0.235*noise(8.*p);\n            sdf.yz += 0.12*abs(sin(-.61*theta)-0.7)*abs(sin(100.*theta)-1.1);\n\n            // INSIDE: Subtract ellipsoid\n            float cutoutSD  = sdEllipsoid(q, vec3(1.0, 1.0, 1.0)); \n            vec3  cutoutCol = Cd_pumpkinInside; \n            vec4  cutout    = vec4(cutoutSD, cutoutCol);\n            sdf = opSubtraction(cutout, sdf);\n        }\n    }\n   \n    {//STEM:\n        vec3 q = p; \n        q.y *= -1.;\n        vec3 tmpq = q;\n\t    q.yxz = bendPoint(q.yxz, 0.34);\n        q = rotate_z(q, 0.4);\n    \tfloat stemSD  = sdCappedCone(q + vec3(.0, 1.85,0.), 1.15, 0.1, 1.);// (p, h, r1, r2)\n        vec3  stemCol = Cd_stem*2.;\n        if(stemSD<0.01){// modify color\n\t        float theta = atan(q.z, q.x);// + 0.015*noise(10.*p);\n            stemCol.xy += 0.02*abs(sin(40.*theta)-0.9)*abs(sin(100.*theta)-0.9);\n            //stemSD *= (1. + 1.*abs(sin(10.*theta)-0.9));\n        }\n        \n        vec4  stem = vec4(stemSD, stemCol);\n    \tsdf   = opUnion(sdf, stem);\n    }\n\n    {// ADD NOISE:  (use sparingly--ruins signed-distance property)\n    \tsdf += 0.006*noise(8.*p);\n        //sdf.x += 0.015*fbm(0.65*p); // costly. \n    }\n\n    {// CARVE:\n\t\t// NOSE:\n        float noseSD = sdTriPrism(p-vec3(0.,8.,.5), vec2(.3, 1.));\n        vec4  noseCutout = vec4(noseSD, Cd_pumpkinInside);\n        sdf = opSubtraction(noseCutout, sdf);\n        \n        // EYES:\n        vec2 xyEye = vec2(0.225, 0.325);\n        float eyeSD = sdCapsule(vec3(abs(p.x),p.yz), vec3(xyEye, 0.), vec3(xyEye, 1.), 0.3);\n        vec4  eyeCutout = vec4(eyeSD, Cd_pumpkinInside);\n        sdf = opSubtraction(eyeCutout, sdf);\n        \n        \n        // MOUTH: \n        //vec3  q = vec3(p.x, -p.y+0.5, p.z-.5);\n        float d = sdRoundBox(p + vec3(0.,-0.15, -0.55), vec3(0.1, 0.05, 0.8), 0.1);\n            //sdCappedTorus(q, vec2(0.866025,-0.5), 0.55, 0.05);//vec2(0.8, 0.0), 1., 0.2);\n        vec4  mouth = vec4(d, Cd_pumpkinInside);\n        sdf = opSubtraction(mouth, sdf);\n        \n        \n    }\n\n\n    // CUTAWAY PLANE:\n    #if 0\n        float d = sdPlane( p, normalize(vec3(-1.,0.,-1.)), 3.*(mx-0.5));\n        vec4 cutPlane = vec4(d, Cd_pumpkinInside);\n        //sdf = opIntersection(sdf, cutPlane); \n        sdf = opSubtraction(cutPlane, sdf); \n    #endif\n    \n    #if 0   \n    {// COORDINATE BOX GUIDE:\n    \tfloat d = sdBoundingBox(p, vec3(1.), 0.02);\n        sdf = opUnion(sdf, vec4(d, vec3(0.8)));\n    }\n    #endif \n    \n    return sdf;\n}\n\n\n// Scalar SDF implementation for our scene\nfloat map(in vec3 p)\n{\n    return mapV4(p).x;// just sdf value\n}\n\n//vec3 calcNormal( in vec3 p ) // for function map(p)\n//{\n//    const float eps = 0.0001; // or some other value\n//    const vec2  h   = vec2(eps,0);\n//    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n//                          map(p+h.yxy) - map(p-h.yxy),\n//                           map(p+h.yyx) - map(p-h.yyx) ) );\n//}\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e);\n    }\n    return normalize(n);\n#endif    \n}\n\n// Vector raymarch: \n// .x   : t* value of surface, or -1 if didn't hit anything.\n// .yzw : pass-thru from mapV4.yzw\n// \nvec4 raymarchV4(in vec3 ro, in vec3 rd) \n{\n    float t = 0.0;\n    for(int i=0; i<200; i++) {\n        vec3  rt = ro + rd*t;\n        vec4  f  = mapV4(rt);\n\t\tfloat d  = f.x;\n        \n        if(d<0.001) {// We hit it or went too far\n            f.x = t; // replace .x's sdf with t*\n            return f;\n        }\n        else {// keep marching\n         \tt += 0.95*d; // conservative/smaller step for inexact/warped SDFs\n        }\n        \n        if(t > 100.) {\n            f.x = -1.;// -ve t* --> didn't hit anything\n            return f;\n        }\n    }\n    \n\treturn vec4(-1., vec3(0.)); // didn't hit anything\n}\n\n/// Returns t* value of surface, or -1. if didn't hit anything.\nfloat raymarch(in vec3 ro, in vec3 rd) \n{\n    return raymarchV4(ro,rd).x;  \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.;\n        t += 0.95*h;//can do slightly less for not-quite-SDFs\n    }\n    return 1.0;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += 0.95*h;//slightly less for not-quite-SDFs\n    }\n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) \n{\n    vec3 col = vec3(0.,0.,0.);//background\n\tvec2 mouse = iMouse.xy/iResolution.xy;         \n    \n    vec4  ray = raymarchV4(ro, rd);//compute distance along ray to surface\n    float t   = ray.x;\n    vec3  Cd  = ray.yzw;// can passthru other shading values, e.g., objectID, but we did color.\n    \n    if(t>0.0) {//hit surface --> shade it:   \n        \n\t    vec3  p  = ro + rd*t; // point on surface\n        vec3  N  = calcNormal(p); // sdf normal\n        \n        // DETERMINE MATERIAL COLOR: (todo: all orange for now)\n        //vec3  Cd = vec3(231./255., 111./255., 3./255.); // diffuse color\n        \n        // DIRECTIONAL LIGHT:\n        vec3  posL   = ro+ 30.*vec3(mouse.x-0.5, mouse.y-0.5,0.);// light at eye (safe!)\n        vec3  L      = normalize(posL - p);\n        vec3  CL     = vec3(1.);// directional light color\n        float LdotN  = clamp(dot(L,N), 0., 1.);\n        //float shadL  = shadow(p, L, 0.01, 20.);\n        float sshadL = softshadow(p, L, 0.01, length(posL-p), 2.);\n\t    col = Cd * CL * LdotN * sshadL; // * occ;\n        \n        // CANDLE LIGHT (#2):\n        //vec3  dp     = 2.*vec3(0., mouse.y-0.5, mouse.x-0.5);\n        vec3  posL2  = pumpkinCenter + 0.15*vec3(sin(20.*iTime),cos(7.*iTime),cos(14.*iTime));\n        vec3  L2     = normalize(posL2 - p);\n        vec3  CL2    = vec3(1.,1.,.2);// candle light color\n        float L2dotN = clamp(dot(L2,N), 0., 1.);\n        //float shadL2  = shadow(p, L2, 0.01, length(posL2-p));\n        float sshadL2 = softshadow(p, L2, 0.01, length(posL2-p), 8.);\n\t    col += Cd * CL2 * L2dotN * sshadL2; // * occ;       \n        \n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 mouse = iMouse.xy/iResolution.xy;   \n \n    vec2 uv  = (fragCoord - 0.5*iResolution.xy)/iResolution.y; // normalized coordinates (unit height)\n\n    vec3 pix = vec3(uv,     0.);    // position of virtual pixel (Z=0 depth)\n    vec3 ro  = vec3(0., 0., 3.);    // ray origin (EYE POSITION).. controls field-of-view\n    vec3 rd  = normalize(pix - ro); // ray direction\n    \n    vec3 col = render(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddBDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[564, 564, 601, 601, 623], [624, 624, 657, 657, 695], [697, 697, 741, 741, 762], [763, 763, 807, 807, 850], [852, 877, 920, 920, 942], [943, 943, 986, 986, 1038], [1040, 1040, 1092, 1092, 1191], [1193, 1193, 1251, 1251, 1351], [1353, 1353, 1412, 1412, 1511], [1513, 1513, 1564, 1564, 1597], [1599, 1671, 1728, 1728, 1897], [1898, 1898, 1924, 1924, 2749], [2875, 2875, 2901, 2901, 3106], [3111, 3111, 3147, 3147, 3264], [3265, 3265, 3301, 3301, 3419], [3420, 3420, 3456, 3456, 3571], [3573, 3675, 3700, 3700, 3719], [3720, 3720, 3745, 3745, 3764], [3765, 3765, 3801, 3801, 3829], [3831, 3831, 3870, 3870, 3899], [3901, 3901, 3939, 3939, 4004], [4005, 4005, 4036, 4036, 4123], [4124, 4124, 4188, 4188, 4305], [4306, 4306, 4358, 4358, 4479], [4480, 4480, 4539, 4539, 4852], [4853, 4853, 4889, 4889, 4972], [4973, 4973, 5015, 5041, 5066], [5067, 5067, 5115, 5115, 5397], [5399, 5412, 5449, 5449, 5532], [5534, 5579, 5631, 5631, 5915], [5916, 5916, 5986, 5986, 6120], [6121, 6121, 6166, 6166, 6257], [6259, 6259, 6299, 6299, 6475], [6476, 6530, 6576, 6576, 6625], [6627, 6672, 6698, 6698, 7032], [7308, 7544, 7567, 7614, 10545], [10548, 10591, 10613, 10613, 10655], [10657, 11052, 11084, 11084, 11605], [11607, 11728, 11770, 11770, 12340], [12342, 12406, 12447, 12447, 12483], [12485, 12485, 12549, 12549, 12753], [12754, 12754, 12831, 12831, 13205], [13207, 13207, 13245, 13245, 14864], [14866, 14866, 14923, 14923, 15387]], "test": "valid"}
{"id": "tddBWS", "name": "Breathing circles clipping2", "author": "partyprism", "description": "Forked from https://www.shadertoy.com/view/llKcRc\n\nPlaying with radius, position and color over time.\nAdded a rectangle used as some type of clipping mask.", "tags": ["circles"], "likes": 1, "viewed": 17, "published": "Public", "date": "1605958589", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 circlePos1 = vec2(0.3,0.5);\nvec2 circlePos2 = vec2(0.5,0.5);\nvec2 circlePos3 = vec2(0.6,0.3);\nfloat radius1 = 0.15;\nfloat radius2 = 0.15;\nfloat radius3 = 0.05;\nvec4 FG1 = vec4(0., 0., 1.0,1.0);\nvec4 FG2 = vec4(0.129, 0.588, 0.952,1.0);\nvec4 FG3 = vec4(0.090, 0.411, 0.6,1.0);\nvec4 BG = vec4(0.,0.,0.2, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord.xy / iResolution.xy;\n float aspectRatio = iResolution.y / iResolution.x;\n uv.y = uv.y * aspectRatio;\n \n circlePos1.y = circlePos1.y * aspectRatio;\n circlePos2.y = circlePos2.y * aspectRatio;\n circlePos3.y = circlePos3.y * aspectRatio;\n \n // ndrar radien ver tid fr circle 1+2+3\n radius1 -= sin(iTime) * 0.02;\n radius2 += sin(iTime) * 0.05;\n radius3 += sin(iTime - 1.) * 0.025;\n //radius3 += sin(iTime + 5. / radius1) * 0.01;\n    \n // ndrar frgerna p circel 1+2-3\n FG1 -= FG2.g * sin(iTime);\n FG2 += FG1.b * sin(iTime);\n FG3.r += sin(iTime - 1.) - FG1.r;\n FG1 *= uv.y;\n FG2 *= uv.y;\n FG3 *= uv.y * 2.;\n \n // ndra positionen ver tid fr circle 1+2+3\n //circlePos1 += sin(iTime) * 0.1; \n //circlePos2 -= sin(iTime) * 0.1;\n \n fragColor = mix( FG2, BG, smoothstep(radius2 - 2e-3, radius2, length(circlePos2 - uv)));\n fragColor = mix( FG1, fragColor, smoothstep(radius1 - 2e-3, radius1, length(circlePos1 - uv)));\n fragColor = mix( FG3, fragColor, smoothstep(radius3 - 2e-3, radius3, length(circlePos3 - uv)));\n\n vec2 q = uv - vec2(0.5, 0.5) + sin(iTime / (uv / 0.3));\n //q += uv - vec2(0.5, 0.5) * cos(iTime);\n float r = 0.2;\n //fragColor *= smoothstep(r, r + 0.015, abs(q.x));\n //fragColor *= 1.0 - (1.0-smoothstep(r,r+0.002, abs(q.x-0.25*sin(2.0*q.y))))*(1.0-smoothstep(0.0,0.1,q.y));\n fragColor *= 1.0 - (1.0-smoothstep(r,r+0.002, abs(q.x)))*(3.0-smoothstep(0.0,0.001,q.y));\n\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddBWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 314, 371, 371, 1785]], "test": "valid"}
{"id": "tddcWl", "name": "the flag of Romania - 003", "author": "catafest", "description": "the flag of Romania with wind effect ... \nhttps://en.wikipedia.org/wiki/Flag_of_Romania", "tags": ["flag", "romania", "catafest"], "likes": 1, "viewed": 171, "published": "Public API", "date": "1606773095", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//The flag is coincidentally very similar to the civil flag of Andorra and \n//the state flag of Chad. \n//The similarity with Chad's flag, which is identical apart from allowing a broader range of shades of \n//blue, yellow and red, has caused international discussion. \n//see https://en.wikipedia.org/wiki/Flag_of_Romania\n//the gl_FragColor is a vec4 type of float values in the range 0 to 1.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // set color background\n\tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    // set direction flag for X\n    float flag_X = uv.x * 4.0 - 1.1;\n    // set direction flag for Y and wind effect with sin and time\n    float flag_Y = uv.y / 3.0 - (sin((flag_X - iTime) * 6.0) * 0.01)  ;\n    // set sized flagX by flagY\n    flag_X = flag_X/1.8 - flag_Y/1.1;\n    // build the area for flag\n    if (flag_X > 0.0 && flag_X < 1.0  && flag_Y > 0.1  && flag_Y < 0.18) \n    { \t\n        // set a size to fill with colors \n\t\tfloat size = 4.0;\n        // build the flag by flag_X\n\t\tif (flag_X < 1.0 / size) \n\t\t{\n\t\t\t// Output to screen with fill the screen with blue\n\t\t\tfragColor = vec4(0,0,1,0);\n            \t\n\t\t} else if (flag_X < 2.0 / size) {     \n\t\t\t// fill the 2/3 of size with yellow color\n\t\t\tfragColor = vec4(1,1,0,0);\n        \t    \n\t\t} else if (flag_X < 3.0 / size) {\n   \n\t\t\t// fill the last 1/3 with the red color \n\t\t\tfragColor = vec4(1,0,0,0);\n\t\t}\n\t}\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddcWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 392, 449, 499, 1478]], "test": "valid"}
{"id": "tddfDn", "name": "cherry blossom tree 2", "author": "jemappelle", "description": "testing fft implementation, using uniforms through api", "tags": ["test"], "likes": 2, "viewed": 244, "published": "Public API", "date": "1604875988", "time_retrieved": "2021-10-01T00:00:00", "image_code": "uniform float zMotion;\nuniform float lowFreqFFT;\nuniform float midFreqFFT;\nuniform float highFreqFFT;\n\nfloat opSubtract(float o0, float o1){return max(-o0,o1);}\n\nfloat opIntersection(float o0, float o1){return max(o0,o1);}\n\nfloat diffuse_directional(vec3 n, vec3 l){\n  \treturn dot(n, normalize(l))*.5 + .5;\n}\n\nfloat sphere(vec3 d, float r){\n  \t//d = mod(d, 2.)-2.*0.5;  \n  \treturn length(d)-r;\n}\n\nfloat sdRoundedX(in vec2 d, in float w, in float r ){\n   \td = abs(d);\n   \treturn length(d-min(d.x+d.y,w)*0.5) - r;\n}\n\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat map(vec3 d){\n  \td = mod(d, 2.)-2.*0.5;  \n  \treturn mix(sdRoundedX(d.xy, 0.1, 0.12), (sphere(d, 0.4)), cos(iTime*0.8*0.8)) * abs(sdCappedTorus(d, vec2(midFreqFFT,0.4), midFreqFFT/3., 0.4));\n}\n\nvec3 get_normal(vec3 p){\n  \tvec2 eps = vec2(0.01,0.);\n  \treturn normalize(vec3(map(p+eps.xyy) - map(p-eps.xyy),\n    map(p+eps.yxy) - map(p-eps.yxy),  \n    map(p+eps.yyx) - map(p-eps.yyx)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t// Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv/=vec2(iResolution.y/iResolution.x, 1);\n    \n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*sin(iTime+uv.xyx+vec3(0,2,4));\n \tfloat circle = smoothstep(0.05*uv.x, 1.,length(uv.x));\n  \n  \tvec3 ro = vec3(0.+cos(iTime)/2.,zMotion,-8.+(iTime*4.)); \n  \tvec3 p = ro;\n  \tvec3 rd = normalize(vec3(uv,1.));\n    //vec3 rd = normalize(vec3(uv,shapeColour));\n    \n    //Sound test\n    //float fft = texture(iChannel0, vec2(uv.x,uv.y)).x;\n    \n  \tbool hit = false;\n  \tfloat shading = 0.;\n  \n  \tfor(float i = 0.; i < 15.; i++){\n    \tfloat env = map(p);\n    \tif(env<0.01){\n      \t\thit = true;\n      \t\tshading = i/100.;\n      \t\tbreak;\n    \t}\n    \t//p += env * sin(rd-ro/50.);\n    \t//p += env - (sin(env+ro/100.)+atan(ro+rd));\n        sin(p += env - (sin(env+ro/100.)+atan(rd))) + atan(rd-ro/50.);\n  \t}\n \n  \n  \t//Waving screen\n  \tuv.x += sin(uv.y*8.5)*0.1;\n  \tuv.y += sin(uv.x*8.5+iTime)*0.1;\n  \t//Screen split\n  \tuv.x = mod(uv.x, 0.1)-0.2*0.5;\n  \n  \t//Shape\n  \tfloat verLine = sin(smoothstep(0.05, 0.9,length(uv.y/(circle*midFreqFFT))));\n  \n  \t//Color define\n  \tvec3 color = vec3(0.);\n  \n  \n  \t//Color from raymarch\n  \tif(hit){\n    \tvec3 n = get_normal(p);\n    \tvec3 l = vec3(0.5,2.,-2.);\n    \tcolor = get_normal(p) + vec3(shading);\n        \n        //Colour as static\n        //color = mix(vec3(0.8,0.05,0.2), vec3(0.1,0.0,0.0), vec3(diffuse_directional(n,l)));\n        \n        //Colour with uniform\n        //color = mix(vec3(highFreqFFT-sin(verLine/cos(circle/(shading*2.)))/4.,0.01,midFreqFFT/8.-cos(verLine)), vec3(lowFreqFFT/4.,0.0,midFreqFFT/4.), \n        //            mix(vec3(circle/verLine), vec3(shading-verLine),vec3(diffuse_directional(n,l))));\n    \t\n        color = mix(vec3(0.05-sin(verLine*cos(circle/(verLine*uv.y*abs(shading))))/4.,0.01,midFreqFFT/8.-cos(verLine)), vec3(0.0,0.05,lowFreqFFT/sin(verLine-sin(circle-(iTime*uv.x*abs(uv.y))))/4.), \n        mix(vec3(circle/verLine), vec3(shading-verLine),vec3(diffuse_directional(n,l))));\n        \n        hit = false;\n  \t}else{\n    \t//color = vec3(circle - verLine/shading);\n        color = vec3(circle - verLine+shading) - vec3(0.9,0.9,0.9);\n    \t//color = vec3(circle *= sin(verLine/1.)*iTime);\n  \t}\n  \tfloat t = length(ro*p);\n  \t//is final output for now\n  \tvec3 fog = mix(color, vec3(0.6,0.1,0.1), 1.*exp(-0.01*t*t));\n    \n  \tfragColor = vec4(fog, 0.1) + vec4((color * circle / 1.5), 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddfDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[103, 103, 140, 140, 160], [162, 162, 203, 203, 222], [224, 224, 266, 266, 308], [310, 310, 340, 370, 395], [397, 397, 450, 450, 513], [516, 516, 586, 586, 720], [722, 722, 740, 740, 918], [920, 920, 944, 944, 1111], [1113, 1113, 1170, 1217, 3628]], "test": "error"}
{"id": "tddfRB", "name": "Partial Sphere", "author": "Firal", "description": "The shader for Day 2 of my self-imposed 30 shaders in 30 days challenge (not all will be made public).\n\nAn example of a sphere / circle sdf that is only rendered partially around. In a very Pac-Man like fashion.", "tags": ["sdf", "sphere", "circle", "partial", "firal"], "likes": 2, "viewed": 66, "published": "Public", "date": "1605489269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nhttps://www.shadertoy.com/view/tddfRB\nMade by Firal (Zack Misso)\n*/\n\n#define ANIM_SPEED 0.35\n\n// The sdf for a sphere which is partially rendered. It is computed as the combined sdf\n// between a sphere, and two planes intersecting the sphere according to the angle which\n// is passed in as a parameter.\nfloat sdPartialSphere(vec3 p, float r, float max_angle)\n{\n    // hard coding axis and normal for now. The normal is the direction tangential to\n    // both of the lips. Axis is where the lips start\n    vec3 axis = vec3(0.0, 1.0, 0.0);\n    vec3 norm = vec3(0.0, 0.0, 1.0);\n    //max_angle = 0.0;\n    \n    // compute the tanget vector\n    vec3 tang = cross(norm, axis);\n    \n    // we want the angle between the projection onto the tangent\n    float angle = acos(dot(normalize(vec3(p.x, p.y, 0.0)), axis));\n    \n    if (angle < max_angle)\n    {\n        // compute the closest lip, the other can be ignored\n        float max_a = max_angle * sign(dot(tang, p));\n        \n        // direction of the closest 'lip'\n        vec3 dir = vec3(axis.x * cos(max_a) - axis.y * sin(max_a),\n                        axis.x * sin(max_a) + axis.y * cos(max_a),\n                        0.f);\n\n        \n        // normal vector for the plane of the 'lip'\n        vec3 norm_dir = cross(norm, dir);\n        \n        // project the point onto the infinite plane\n        vec3 plane_point = p - norm_dir * dot(p, norm_dir);\n        \n        // project the point back onto the intersection between the sphere and the plane.\n        plane_point = max(sign(dot(dir, plane_point)), 0.0) * \n            \t\t  min(length(plane_point), r) * \n            \t\t  normalize(plane_point);\n        \n        // project the point onto the base line of the sphere\n        vec3 base_p = p;\n        base_p.z = 0.0;\n\n        // return the min of the projected point and the distance to the center line.\n        return min(length(base_p), length(p-plane_point));\n    }\n    \n    // compute distance to the sphere\n    float dist = length(p) - r;\n    \n    // TODO: there is probably some optimization I can do to avoid these if statements, but\n    //       I'll look into that later.\n    // if the point is inside the sphere, we need to correctly account for the 'lips'\n    if (dist < 0.0 && max_angle != 0.0)\n    {\n        // compute the closest lip, the other can be ignored\n        float max_a = max_angle * sign(dot(tang, p));\n        \n        // direction of the closest 'lip'\n        vec3 dir = vec3(axis.x * cos(max_a) - axis.y * sin(max_a),\n                        axis.x * sin(max_a) + axis.y * cos(max_a),\n                        0.f);\n        \n        // normal vector for the plane of the 'lip'\n        vec3 norm_dir = cross(norm, dir);\n        \n        // project the point onto the infinite plane\n        vec3 plane_point = p - norm_dir * dot(p, norm_dir);\n        \n        // project the point back onto the intersection between the sphere and the plane.\n        plane_point = max(sign(dot(dir, plane_point)), 0.0) * \n            \t\t  min(length(plane_point), r) * \n            \t\t  normalize(plane_point);\n        \n        // project the point onto the base line of the sphere\n        vec3 base_p = p;\n        base_p.z = 0.0;\n\n        // return the min of the projected point and the distance to the center line. Returns\n        // the negative since the point is inside the sdf.\n        return -min(length(base_p), min(-dist, length(p-plane_point)));\n    }\n    \n    \n    return dist;\n}\n\n// creates a fancy little animation progress bar\nvec3 shade_progress_bar(vec2 p, vec2 res, float z)\n{\n    // have to take account of the aspect ratio\n    float xpos = p.x * res.y / res.x;\n    \n    if (xpos > z - 0.01 && xpos < z + 0.01) return vec3(1.0);\n    else return vec3(0.0);\n}\n\n// the shading routine. Modified version of iq's\n// https://www.shadertoy.com/view/3ltSW2\nvec3 shade(float sd)\n{\n    vec3 col = vec3(1.0) - sign(sd) * vec3(0.9,0.4,0.2);\n    \n    col *= 1.0 - exp(-6.0*abs(sd));\n\tcol *= 0.8 + 0.2*cos(140.0*sd);\n\tcol = mix( col, vec3(1.0, 0.0, 0.0), 1.0-smoothstep(0.0,0.02,abs(sd)) );\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float angle = 3.14 * cos(ANIM_SPEED * iTime);\n    vec3 world_p = vec3(p*1.3, 0.6 * cos(iTime * ANIM_SPEED));\n\t\n    if (p.y < -0.95)\n        fragColor = vec4(shade_progress_bar(p, iResolution.xy, angle / 3.14), 1.0);\n    else\n        fragColor = vec4(shade(sdPartialSphere(world_p, 1.0, abs(angle))), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddfRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 306, 363, 503, 3454], [3456, 3505, 3557, 3605, 3739], [3741, 3831, 3853, 3853, 4081], [4083, 4083, 4140, 4140, 4511]], "test": "valid"}
{"id": "tddfWB", "name": "Looping 1D noise", "author": "airtight", "description": "Looping 1D noise. Based on: https://twitter.com/grifdail/status/1329456356240334849", "tags": ["noise", "loop"], "likes": 2, "viewed": 123, "published": "Public", "date": "1605931457", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TWO_PI 6.28318530718\n\n//2D gradient noise from https://www.shadertoy.com/view/XdXGW8\nvec2 hash( vec2 x ) {\n    const vec2 k = vec2( 0.3183099, 0.3678794 );\n    x = x*k + k.yx;\n    return -1.0 + 2.0*fract( 16.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\n//returns 0 <-> 1\nfloat noise2dgrad( in vec2 p ){\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    float n = mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(1.0,0.0) ), f - vec2(1.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,1.0) ), f - vec2(0.0,1.0) ), \n                     dot( hash( i + vec2(1.0,1.0) ), f - vec2(1.0,1.0) ), u.x), u.y);\n    \n    return (n * 0.5) + 0.5; //normalize\n}\n\n//n: output loops over 0-1 input\n//scale: higher for more variation over 0-1 range\n//seed: arbitary value to generate different loop\n//returns 0 <-> 1\nfloat loopNoise1d(in float n, in float scale, in float seed){\n    float x = cos(n * TWO_PI) + seed;\n    float y = sin(n * TWO_PI) + seed;\n    return noise2dgrad(vec2(x,y) * scale);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    //looping 1d noise every 2 seconds\n    float nloop = loopNoise1d(uv.x + iTime / 2., 1.8, 1.2);\n    vec3 col = vec3(step(nloop,uv.y));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddfWB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 93, 114, 114, 252], [254, 272, 303, 303, 749], [751, 902, 963, 963, 1084], [1086, 1086, 1143, 1193, 1434]], "test": "valid"}
{"id": "tddfWS", "name": "Breathing circles clp dlx move", "author": "partyprism", "description": "Forked from https://www.shadertoy.com/view/llKcRc\n\nPlaying with radius, position and color over time.\nAdded a rectangle used as some type of clipping mask.", "tags": ["circles"], "likes": 1, "viewed": 32, "published": "Public", "date": "1605958535", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 circlePos1 = vec2(0.3,0.5);\nvec2 circlePos2 = vec2(0.5,0.5);\nvec2 circlePos3 = vec2(0.6,0.3);\nfloat radius1 = 0.15;\nfloat radius2 = 0.15;\nfloat radius3 = 0.05;\nvec4 FG1 = vec4(0., 0., 1.0,1.0);\nvec4 FG2 = vec4(0.129, 0.588, 0.952,1.0);\nvec4 FG3 = vec4(0.090, 0.411, 0.6,1.0);\nvec4 BG = vec4(0.,0.,0.2, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord.xy / iResolution.xy;\n float aspectRatio = iResolution.y / iResolution.x;\n uv.y = uv.y * aspectRatio;\n \n circlePos1.y = circlePos1.y * aspectRatio;\n circlePos2.y = circlePos2.y * aspectRatio;\n circlePos3.y = circlePos3.y * aspectRatio;\n \n // ndrar radien ver tid fr circle 1+2+3\n radius1 -= sin(iTime) * 0.02;\n radius2 += sin(iTime) * 0.05;\n radius3 += sin(iTime - 1.) * 0.025;\n //radius3 += sin(iTime + 5. / radius1) * 0.01;\n    \n // ndrar frgerna p circel 1+2-3\n FG1 -= FG2.g * sin(iTime);\n FG2 += FG1.b * sin(iTime);\n FG3.r += sin(iTime - 1.) - FG1.r;\n FG1 *= uv.y;\n FG2 *= uv.y;\n FG3 *= uv.y * 2.;\n \n // ndra positionen ver tid fr circle 1+2+3\n circlePos1 += sin(iTime/2.) * 0.1; \n circlePos2 -= sin(iTime*0.5) * 0.1;\n circlePos3 -= sin(iTime*5.) * 0.02;\n \n fragColor = mix( FG2, BG, smoothstep(radius2 - 2e-3, radius2, length(circlePos2 - uv)));\n fragColor = mix( FG1, fragColor, smoothstep(radius1 - 2e-3, radius1, length(circlePos1 - uv)));\n fragColor = mix( FG3, fragColor, smoothstep(radius3 - 2e-3, radius3, length(circlePos3 - uv)));\n\n vec2 q = uv - vec2(0.5, 0.5);\n //q += uv - vec2(0.5, 0.5) * cos(iTime);\n float r = 0.21;\n //fragColor *= smoothstep(r, r + 0.015, abs(q.x));\n //fragColor *= 1.0 - (1.0-smoothstep(r,r+0.002, abs(q.x-0.25*sin(2.0*q.y))))*(1.0-smoothstep(0.0,0.1,q.y));\n \n //Den hr gller\n fragColor *= 1.0 - (1.0-smoothstep(r,r+0.002, abs(q.x)))*(2.0-smoothstep(0.0,1.0,q.y));\n //fragColor += fragColor + (FG3 * uv.x * 3.);\n fragColor += fragColor + FG3;\n \n //Aktivera den hr under fr att f en till clipping mask typ\n fragColor *= 1.0 - (1.0-smoothstep(r,r+0.002, abs(q.x)))*(2.0-smoothstep(0.0,1.0,q.y));\n fragColor += fragColor + FG1 * FG3;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddfWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 314, 371, 371, 2091]], "test": "valid"}
{"id": "tddfzf", "name": "Cfera", "author": "Voldemar", "description": "Cfera", "tags": ["cfera"], "likes": 1, "viewed": 44, "published": "Public", "date": "1605717846", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = (FC*2.-iResolution.xy)/iResolution.y;\n     //d -  \n    //e -     d \n    float e,d=0.;\n    vec3 p,rd = vec3(uv,1);\n    int i;\n    for(int i = 2;i<9;i++){\n        p=rd*d - vec3(0.,0.,2.);\n        d+=e=length(p-vec3(0.,0.,sin(iTime*3.)))-0.5;\n        if(e<.01)break;\n    }\n    vec3 col = cos(iTime+uv.xyx+vec3(0,2,4)) + 0.98*cos(iTime+uv.xyx+vec3(0,2,4))/d;\n    fragColor = vec4(vec3(col),0.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tddfzf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 52, 52, 547]], "test": "valid"}
{"id": "tdGBzD", "name": "Tripping Star", "author": "tungster24", "description": "my first shader hooray", "tags": ["colors", "rainbow"], "likes": 2, "viewed": 226, "published": "Public API", "date": "1606672798", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n    float t = iTime;\n    float x = (p.x-0.5)*16.0;\n    float y = (p.y-0.5)*9.0;\n    float x2 = x*x;\n    float y2 = y*y;\n    vec2 center = vec2(0.5,0.5);\n    float r = sin(1.0/sqrt((abs(x)*abs(y)))+8.0*t);\n    float g = sin(1.0/sqrt((abs(x)*abs(y)))+9.0*t);\n    float b = sin(1.0/sqrt((abs(x)*abs(y)))+10.0*t);\n    vec3 col = vec3(r,g,b);\n   \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGBzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 471]], "test": "valid"}
{"id": "tdGfz1", "name": "Colorful lens (cookie stream)", "author": "leon", "description": "Shader coded for the Cookie Collective live coding stream.\n[url]https://cookie.paris/[/url]\n[url]https://www.twitch.tv/cookiedemoparty[/url]", "tags": ["colorful", "cookie"], "likes": 18, "viewed": 468, "published": "Public API", "date": "1606569591", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\n// Shader coded for the Cookie Collective live coding stream\n// https://cookie.paris/\n// https://www.twitch.tv/cookiedemoparty\n// \n// Leon Denise 2020.11.28\n// Licensed under hippie love conspiracy\n//\n\n// constants\nconst float PI = 3.1415;\nconst float TAU = 6.283;\n\n// rotation matrix\nmat2 rotation(float a)\n{\n    float c = cos(a), s = sin(a);\n    return mat2(c,-s,s,c);\n}\n\n// color palette by Inigo Quilez\n// https://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 palette(float t)\n{\n    return vec3(0.5)+vec3(0.5)*cos(vec3(1,2,3)*t);\n}\n\nvoid mainImage(out vec4 color, in vec2 coordinate)\n{\n    vec2 p = (coordinate-0.5*iResolution.xy)/iResolution.y;\n    \n    // space distortion\n    p = normalize(p) * sin(pow(length(p), 0.5)*PI - iTime * 0.3);\n    \n    vec2 origin = p;\n    vec3 tint = vec3(0);\n\t\n    // background disks\n    const int disks = 10;\n    float falloff = 1.0;\n    for (int i = 0; i < disks; ++i)\n    {\n        float ratio = float(i)/float(disks-1);\n        \n        // rotation\n        p *= rotation(sin(iTime * 0.1) * 0.1 / falloff + 0.1 * iTime / falloff);\n        \n        // fold\n        p.x = abs(p.x)-0.3*falloff;\n        \n        // shape\n        float shape = min(1., 0.001 / max(0., length(p)-0.05));\n        \n        // color\n        tint += palette(ratio * 2. + p.y*8.) * shape;\n        \n        // falloff iteration\n        falloff /= 1.1;\n    }\n    \n    // animated dots\n    const int dots = 100;\n    for (int i = 0; i < dots; ++i)\n    {\n        float ratio = float(i)/float(dots);\n        float timeline = fract(ratio * 135.1654 + iTime * 0.5);\n        float angle = TAU * ratio * 15.547 + iTime * 0.1;\n        float radius = (0.5 + 0.5 * abs(sin(float(i)*1654.))) * timeline * 2.;\n        \n        // reset transform\n        p = origin;\n        \n        // translate\n        p += vec2(cos(angle),sin(angle)) * radius;\n\t\t\n        // shape\n        float shape = min(1., 0.0005 / max(0., length(p)-0.02));\n        \n        // color\n        tint += palette(angle*0.1 + length(origin)*2.) * shape;\n    }\n\n    color = vec4(tint,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdGfz1.jpg", "access": "shaders20k", "license": "unknown-license-reference", "functions": [[269, 288, 312, 312, 375], [377, 475, 498, 498, 551], [553, 553, 605, 605, 2071]], "test": "valid"}
{"id": "tdKBRW", "name": "FirstToy", "author": "newsham", "description": "playing with this new toy", "tags": ["first"], "likes": 2, "viewed": 48, "published": "Public", "date": "1606723279", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nvec3 myreflect(in vec3 p, in vec3 n) {\n    return p - 2.0 * dot(p, n) * n;\n}\n\nfloat sdfSphere(in vec3 p, in vec3 c, in float r) {\n    return length(c - p) - r;\n}\n\nfloat sdfRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat sdfTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.yz)-t.x,p.x);\n  return length(q)-t.y;\n}\n\nvec3 trans(vec3 p, vec3 off) {\n    return p - off;\n}\n\nvec3 tumble(vec3 p, float t) {\n    float ang = 6.28 * t / 3.0;\n    return vec3(p.x,\n                p.y * cos(ang) - p.z * sin(ang),\n                p.y * sin(ang) + p.z * cos(ang));\n}\n\nfloat warp(vec3 p, float t) {\n\treturn t + 0.02 * cos(29.0 * p.x) * cos(31.0 * p.y) * cos(37.0 * p.z);\n}\n\n// XXX this is probably inefficient.. can it be done better?\nvec4 minw(in vec4 x, in vec4 y) {\n    return (x.w < y.w) ? x : y;\n}\n\nvec4 map(in vec3 p, float time) {\n    vec4 sph = vec4(vec3(1,0,0), warp(p, sdfSphere(p, vec3(0.5, 0.5, 0.5), 0.5)));\n\n    vec3 p3 = trans(p, vec3(-0.3, 0, -0.3));\n    vec4 tor = vec4(vec3(0,1,0), sdfTorus(p3, vec2(0.4, 0.2)));\n\n    vec3 c = vec3(7.0, 5.0, 4.0);\n    vec3 q = p; //mod(p+0.5*c,c)-0.5*c;\n    vec3 p2 = tumble(trans(q, vec3(0.3, -0.5, 0.5)), time);\n    float tb = sdfSphere(p2, vec3(0, 0, 0), 0.3);\n    float ts = sdfRoundBox(p2, vec3(0.1, 0.2, 0.3), 0.1);\n    vec4 box = vec4(vec3(0,0,1), max(ts, -tb)-0.01);\n\n\n    vec4 best = vec4(0,0,0, 1000.0);\n\tbest = minw(best, sph);\n    best = minw(best, tor);\n    best = minw(best, box);\n    return best;\n}\n\nfloat mapw(in vec3 p, float time) {\n    return map(p, time).w;\n}\n\nvec3 calcNorm(in vec3 p, float time) {\n    float e = 0.0001;\n    float t0 = mapw(p, time);\n    return normalize(vec3(\n        mapw(p + vec3(e,0,0), time) - t0,\n        mapw(p + vec3(0,e,0), time) - t0,\n        mapw(p + vec3(0,0,e), time) - t0\n        ));\n}\n\nvec3 lighting(in vec3 p, float time, in vec3 rd, in vec3 col, float z) {\n    vec3 norm = calcNorm(p, time);\n    float up = max(norm.y + 0.2, 0.0);\n    float down = max(-norm.y, 0.0);\n    float right = max(norm.x, 0.0);\n    float ref = pow(max(myreflect(rd, norm).y, 0.0), 5.0); \n    z = 0.4 * (z + 0.5);\n    return ((0.9 * ref * vec3(1,1,1) +\n            up * col.rgb +\n            0.2*down * vec3(1,1,0) +\n            0.5*right * vec3(0,0,1) +\n            0.1 * vec3(1,0.9,0.9))) / z;\n}\n\nvec3 rotView(in vec3 p, float t) {\n    float ang = 6.28 * t / 5.0;\n    vec3 q = vec3(\n        p.x * cos(ang) - p.z * sin(ang),\n        p.y,\n        p.x * sin(ang) + p.z * cos(ang));\n    \n    ang = 6.28 * t / 29.0;\n    return vec3(\n        q.x,\n        q.y * cos(ang) - q.z * sin(ang),\n        q.y * sin(ang) + q.z * cos(ang));\n}\n\nvec3 march(vec3 r0, vec3 rd, float time) {\n    float t = 0.0;\n    for(int i = 0; i < 50; i++) {\n        vec3 p = r0 + t * rd;\n        vec4 best = map(p, time);\n        float d = best.w;\n        if(d < 0.0) {\n            return lighting(p, time, rd, best.rgb, t);\n        } else if(t > 20.0) {\n            break;\n        }\n        t += max(d, 0.01);\n    }\n    return vec3(0.2, 0.2, 0);\n}\n\nvec3 colorPixel(vec2 uv, float time) {\n    vec3 cam = vec3(0, 0, -3.8);\n    vec3 r0 = rotView(vec3(uv, -3.0), time);\n    vec3 rd = normalize(r0 - rotView(cam, time));\n    return march(r0, rd, time);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.x;\n\n    // average three times near coord\n    vec2 d1 = 0.5 * vec2(cos(fragCoord.x * 5000.0 + fragCoord.y * 5001.0),\n                         cos(fragCoord.y * 5002.0 + fragCoord.y * 5003.0));\n    vec2 d2 = 0.5 * vec2(cos(fragCoord.y * 6000.0 + fragCoord.y * 6001.0),\n                         cos(fragCoord.x * 6002.0 + fragCoord.y * 6003.0));\n    vec3 col1 = 0.4 * colorPixel(uv, iTime) +\n                0.3 * colorPixel(uv + d1/iResolution.x, iTime) +\n                0.3 * colorPixel(uv + d2/iResolution.x, iTime);\n    \n    // motion blur\n    vec3 col2 = 0.6 * colorPixel(uv, iTime) +\n                0.25 * colorPixel(uv, iTime - 0.03) +\n                0.15 * colorPixel(uv, iTime - 0.06);\n    vec3 col = 0.5 * col1 + 0.5 * col2;\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKBRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 39, 39, 77], [79, 79, 130, 130, 162], [164, 164, 210, 210, 301], [303, 303, 337, 337, 402], [404, 404, 434, 434, 456], [458, 458, 488, 488, 642], [644, 644, 673, 673, 747], [749, 810, 843, 843, 877], [879, 879, 912, 912, 1540], [1542, 1542, 1577, 1577, 1606], [1608, 1608, 1646, 1646, 1864], [1866, 1866, 1938, 1938, 2353], [2355, 2355, 2389, 2389, 2683], [2685, 2685, 2727, 2727, 3071], [3073, 3073, 3111, 3111, 3273], [3275, 3275, 3332, 3332, 4164]], "test": "valid"}
{"id": "tdKfRz", "name": "Nebulae", "author": "AzazelN28", "description": "Nebula", "tags": ["raymarch", "nebula"], "likes": 11, "viewed": 100, "published": "Public", "date": "1606473033", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Playing marble\" by guil. https://shadertoy.com/view/MtX3Ws\n// 2020-12-01 10:46\n\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n// Created by S. Guillitte 2015\nfloat zoom = 1.;\n\n/*\nvec2 csqr( vec2 a ) {\n  return vec2( a.x * a.x - a.y * a.y, 2. * a.x * a.y  );\n}\n*/\n\nvec2 csqr( vec2 a ) {\n  return vec2(\n      a.x * a.x + a.y * a.y,\n      2. * a.x * a.y\n  );\n}\n\nmat2 rot(float a) {\n  return mat2(\n    cos(a),\n    sin(a),\n   -sin(a),\n    cos(a)\n  );\t\n}\n\nfloat sdSphere( vec3 p, float s ) //from iq\n{\n  return length(p) - s;\n}\n\nfloat map(in vec3 p) {\n  float res = 0.;\n    \n  vec3 c = p;\n  for (int i = 0; i < 10; ++i) {\n    p =.8 * abs(p) / dot(p,p) -.8;\n    p.yz = csqr(p.yz) + 0.02 * vec2(\n      cos(iTime * 0.081),\n      sin(iTime * 0.0331)\n    ); // Animate swirl\n    // p=p.zxy;\n    res += exp2(-29. * abs(dot(p, c)));\n  }\n  return res/2.;\n}\n\n\n\nvec3 raymarch( in vec3 ro, vec3 rd, float sRadius )\n{\n    \n    float t = sRadius;\n    // float dt = .02;\n    float dt = .2 - .111*sin(iTime*.1+20.);//animated\n    vec3 col= vec3(0.);\n    float c = 0.;\n    \n    for( int i=0; i<128; i++ )\n\t{\n        t += dt * exp2(-1. * c);\n        \n        vec3 pos = ro + t * rd;\n        \n        float r = sdSphere(pos, .5);\n        // c = map(ro+t*rd)*(1.1 - smoothstep(0.0,1.,r));\n        c = map(ro + t * rd); \n        \n        vec3 base_color = vec3(c, c * c, c * c * c);\n        col = .99 * col+ .08 * base_color;\n    }    \n    return col;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat time = iTime;\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x/iResolution.y;\n    vec2 m = vec2(0.);\n\tm = iMouse.xy/iResolution.xy*3.14;\n    //m-=.5;\n\n    // camera\n\n    vec3 ro = zoom*vec3(4.);\n    \n    ro.yz *= rot(m.y+ 0.013*time+30.);\n    ro.xz *= rot(m.x+ 0.02*time);\n    \n    vec3 ta = vec3( 0.0 , 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 4.0*ww );\n    \n\t// raymarch\n    vec3 col = raymarch(ro,rd, 2.5);\n\n\t// shade\n    \n    // col =  .75 *(log(1.+col));\n    col = clamp(col,0.,1.);\n    fragColor = vec4( col, 1.0 );\n\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdKfRz.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[317, 317, 338, 338, 410], [412, 412, 431, 431, 501], [503, 503, 548, 548, 574], [576, 576, 598, 598, 895], [899, 899, 952, 952, 1480], [1483, 1483, 1540, 1540, 2268]], "test": "valid"}
{"id": "tdlyW2", "name": "Dots with mask", "author": "nicolaecodreanu", "description": "Dots", "tags": ["fbm", "dots"], "likes": 2, "viewed": 52, "published": "Public", "date": "1605018335", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\n\nfloat variation(vec2 v1, vec2 v2, float strength, float speed) {\n\treturn sin(\n        dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n    ) / 100.0;\n}\n\nvec3 paintCircle (vec2 uv, vec2 center, float rad, float width) {\n    \n    vec2 diff = center-uv;\n    float len = length(diff);\n\n    len += variation(diff, vec2(0.0, 1.0), 5.0, 2.0);\n    len -= variation(diff, vec2(1.0, 0.0), 5.0, 2.0);\n    \n    float circle = smoothstep(rad-width, rad, len) - smoothstep(rad, rad+width, len);\n    return vec3(circle);\n}\n\nfloat random(vec2 p) { \n    return fract(sin(dot(p.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat valueNoise(vec2 p) {\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    f = f * f * (3.0 - 2.0 * f);\n    float bottomOfGrid = mix(random(i + vec2(0.0, 0.0)), random(i + vec2(1.0, 0.0)), f.x);\n    float topOfGrid = mix(random(i + vec2(0.0, 1.0)), random(i + vec2(1.0, 1.0)), f.x);\n    float t = mix(bottomOfGrid, topOfGrid, f.y);\n    return t;\n}\n\nfloat fbm(vec2 uv) {\n    float sum = 0.00;\n    float amp = 1.0;\n    for(int i = 0; i < 1; ++i) {\n        sum += valueNoise(uv) * amp;\n        uv += uv * 1.2;\n        amp *= 0.1;\n    }\n    return sum;\n}\n\nfloat hash( in vec2 p )  // replace this by something better\n{\n    p = 50.0*fract( p*0.3183099 + vec2(0.71,0.113));\n    return -1.0+2.0*fract( p.x*p.y*(p.x+p.y) );\n}\n\n// return value noise (in x) and its derivatives (in yz)\nvec3 noised( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\n    // cubic interpolation\n    vec2 u = f*f*(3.0-2.0*f);\n    vec2 du = 6.0*f*(1.0-f);\n   \n    \n    float va = hash( i + vec2(0.0,0.0) );\n    float vb = hash( i + vec2(1.0,0.0) );\n    float vc = hash( i + vec2(0.0,1.0) );\n    float vd = hash( i + vec2(1.0,1.0) );\n    \n    float k0 = va;\n    float k1 = vb - va;\n    float k2 = vc - va;\n    float k4 = va - vb - vc + vd;\n\n    return vec3( va+(vb-va)*u.x+(vc-va)*u.y+(va-vb-vc+vd)*u.x*u.y, // value\n                 du*(u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va) );     // derivative                \n}\n\nfloat sdCircle(vec2 p, float r)\n{\n\treturn length(p) - r;\n}\n\nfloat variation1(vec2 v1, vec2 v2, float strength, float speed) \n{\n\treturn sin(\n        dot(normalize(v1), normalize(v2)) * strength + iTime * speed\n    ) / 100.0;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    float px = 2.0 / iResolution.y;\n    uv *= 20.0;\n    vec2 id = floor(uv);\n    vec2 p = step(0.05, mod(uv.xy, 0.055));\n    p = step(0.8, mod(uv.xy, 0.9));\n    float f = fbm(uv + iTime * 1.0);\n    vec3 n = noised(uv + iTime * 0.3);\n    vec3 col = vec3(0.0);\n    //col = mix(col, vec3(0.0, 0.7, 1.0), p.x * p.y * f);\n    col = mix(col, vec3(0.0, 0.7, 1.0), p.x * p.y * dot(n.x, n.x));\n    \n    vec2 UV = (fragCoord - 0.5 * iResolution.xy) / iResolution.xy;\n    float d = sdCircle(UV, 0.55);\n    d -= variation1(UV, vec2(1.0, 0.0), 5.0, 3.0);\n    float mask = smoothstep(-0.2, 0.0, d);\n    //col = mix(col, vec3(1.0), mask);\n    col *= mask;\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdlyW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 27, 27, 109], [111, 111, 175, 175, 274], [276, 276, 341, 341, 630], [632, 632, 654, 654, 727], [729, 729, 755, 755, 1078], [1080, 1080, 1100, 1100, 1281], [1283, 1283, 1345, 1345, 1448], [1450, 1507, 1533, 1533, 2131], [2133, 2133, 2166, 2166, 2191], [2193, 2193, 2259, 2259, 2358], [2360, 2360, 2417, 2417, 3167]], "test": "error"}
{"id": "tdtBD2", "name": "checkerboard animation 1.1", "author": "DjinnKahn", "description": "for https://isohedral.ca/swirled-series/\n\ntry changing N to a bigger power of 2", "tags": ["checkerboard"], "likes": 14, "viewed": 87, "published": "Public", "date": "1606078057", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define N 8.      // number of checkerboard squares\n#define PATTERN 0 // some integer in the range [0,N)\n#define PI 3.1415926\n\nconst bool shading = false;\n\nfloat easeInOutCubic( float x ) \n{\n\treturn x < 0.5 ? 4. * x * x * x : 1. - pow(-2. * x + 2., 3.) / 2.;\n}\n\nfloat easeInOutQuad( float x ) \n{\n\treturn x < 0.5 ? 2. * x * x : 1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\nvec3 rotY( vec3 p, float angle )\n{\n    return vec3( p.x * cos(angle) + p.z * sin(angle), p.y, p.x * -sin(angle) + p.z * cos(angle) );\n}\nvec3 rotX( vec3 p, float angle )\n{\n    return vec3( p.x, p.y * cos(angle) + p.z * sin(angle), p.y * -sin(angle) + p.z * cos(angle) );\n}\n\nvec3 planeIntersectionUVT( vec3 rayPoint, vec3 rayDir, vec3 planePoint, vec3 planeU, vec3 planeV )\n{\n    vec3 p = rayPoint - planePoint;\n    vec3 planeN = cross( planeU, planeV );\n    float t = -dot( p, planeN ) / dot( rayDir, planeN ); // distance\n    float u = dot( p, planeU ) + dot( rayDir, planeU ) * t;\n    float v = dot( p, planeV ) + dot( rayDir, planeV ) * t;\n    return vec3( u, v, t );\n}\n\nvec3 permute( vec3 v, int n )\n{\n   if ( n == 1 ) return v.yzx;\n   if ( n == 2 ) return v.zxy; \n   return v.xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n        \n    float t = mod( iTime / 2., 1. );\n    t = easeInOutQuad( t );\n    \n    // set up camera\n    float angle = t * PI / 2.;\n    float vertAngle = sin( PI * t ) * .1;\n    vec3 pos = rotY( rotX( vec3( 0., 0., -5. ), angle), angle );\n    vec3 dir = rotY( rotX( vec3( 0., 0., 1. ), angle), angle );\n    vec3 dir_right = normalize( -cross( dir, vec3( 0., 1., 0. ) ) );\n    vec3 dir_up = cross( dir, dir_right );\n    \n    vec3 p = pos + dir_right * uv.x + dir_up * uv.y;\n        \n    \n    fragColor = vec4(vec3( .2 ), 1.0);\n    float closestDist = 999.; // z-buffering\n    \n    // There are N layers of planes for all 3 axes (X, Y, Z).\n    // We'll do a plane-ray intersection for each.\n    // Most of the intersections will be transparent -- the 'hit' variable decides if we actually hit a checker square or not\n    for ( int whichAxis = 0; whichAxis < 3; whichAxis++ )\n    {\n        for ( int checkerZ = 0; checkerZ < int(N); checkerZ++ )\n        {\n            vec3 planeUVT = planeIntersectionUVT( p, dir, permute( vec3( -.5,-.5, -.5 + float(checkerZ)/N ), whichAxis ), permute( vec3( 1.,0.,0. ), whichAxis ), permute( vec3( 0.,1.,0. ), whichAxis ) );\n            int checkerX = int(floor(planeUVT.x*N));\n            int checkerY = int(floor(planeUVT.y*N));\n            if ( checkerX < 0 || checkerX >= int(N) ) continue;\n            if ( checkerY < 0 || checkerY >= int(N) ) continue;\n            bool hit = (checkerX ^ checkerY ^ (int(N)-1) ^ PATTERN) == checkerZ;\n            if ( hit )\n            {\n                if ( planeUVT.z < closestDist )\n                {\n                    float light = shading ? dot( dir, permute( vec3( 0.,0.,1. ), whichAxis ) ) : 1.;\n                    //fragColor = vec4( planeUVT.xy, 0., 1. );                    \n                    fragColor = ((checkerX ^ checkerY) & 1) == 0 ? vec4( 0. ) : vec4( 1. ) * light;\n                    closestDist = planeUVT.z;\n                }\n            }\n        }\n    }    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtBD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 190, 190, 260], [262, 262, 295, 295, 361], [363, 363, 397, 397, 498], [499, 499, 533, 533, 634], [636, 636, 736, 736, 1034], [1036, 1036, 1067, 1067, 1149]], "test": "valid"}
{"id": "tdtBDB", "name": "My Smiling Face", "author": "zhengzhehui", "description": "rotating smiling face", "tags": ["2d"], "likes": 3, "viewed": 40, "published": "Public", "date": "1605931287", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat Circle(vec2 uv, vec2 p, float r, float blur) { //\n    float circle = length(uv-p);\n    circle = smoothstep(r, r-blur, circle); //01\n    return circle;\n\n}\n\nfloat Mask(vec2 uv, vec2 p, float size){  //\n    uv -= p;  //\n    uv /= size;  //\n    \n    float mask = Circle(uv, vec2(0.0,0.0), .3, 0.01);  //\n    mask -= Circle(uv, vec2(-0.12,0.12), .07, 0.01); //\n    mask -= Circle(uv, vec2(0.12,0.12), .07, 0.01);  //\n    float mouth = Circle(uv, vec2(-0.0,-0.08), .15, 0.01);  //\n    mouth -= Circle(uv, vec2(-0.0,-0.1), .15, 0.01);\n    mask += mouth;\n    if(mask > 1.0) mask = 1.0;\n    else if (mask < 0.0) mask = 0.0;  //mask01\n    return mask;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\tfloat t = iTime;\n    float size = abs(sin(t)*0.3 + .5);  //\n    vec2 pos = vec2(sin(t)*0.6, cos(t)*0.4); //\n    \n\tfloat mask = Mask(uv, pos, size);  //\n    vec3 col = vec3(1.,.5,0.5)*mask;  //\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtBDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 53, 116, 274], [276, 276, 316, 371, 899], [902, 902, 959, 1009, 1406]], "test": "valid"}
{"id": "tdtBDl", "name": "so much beer", "author": "lyurai", "description": "Love beer. This image I see when I barf", "tags": ["glitchcircle"], "likes": 2, "viewed": 236, "published": "Public API", "date": "1606318868", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*25.-iResolution.xy)/iResolution.y+t;\n        t = iTime+float(c)/1.;\n        for(int i=0;i<100;i++){\n            uv=abs(uv);\n            uv-=.5;\n            uv=uv*rot(t/float(i+1));\n        }\n\t    col[c]= step(.5,fract(uv.x*20.));\n    }\n\n    fragColor = vec4(vec3(col),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtBDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 480]], "test": "valid"}
{"id": "tdtBW7", "name": "Curvature Modelling w/Sine Waves", "author": "oneshade", "description": "I have continued playing around with curve fitting with sine waves and made a lambda symbol which wasn't too hard. You can play around with a desmos graph of it here: https://www.desmos.com/calculator/zmjby4x2jc", "tags": ["sine", "curvefitting", "modelling", "curvature"], "likes": 1, "viewed": 46, "published": "Public", "date": "1605319684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Bounce function from my Simple Bouncing shader (https://www.shadertoy.com/view/WdtczS):\nfloat bounce(float time, float period, float maxHeight) {\n    float modulus = mod(time / period, 1.0);\n    return modulus * (1.0 - modulus) * 4.0 * maxHeight;\n}\n\nfloat curve(in vec2 p, in vec2 a, in vec2 b, in float thickness) {\n    if (min(a.x, b.x) < p.x && p.x <= max(a.x, b.x)) {\n        float sine = sin(((p.x - a.x) / (b.x - a.x) * 2.0 - 1.0) * 1.5707963267);\n        float cy = a.y + (0.5 + 0.5 * sine) * (b.y - a.y);\n        return smoothstep(thickness, 0.0, abs(p.y - cy));\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float color = 0.0;\n\n    vec2 scale = vec2(0.9);\n    scale.y *= 0.9 + bounce(iTime, 2.0, 0.2) - 0.1;\n\n    color += curve(uv, vec2(-1.5, -2.0) * scale, vec2(0.1, 0.0) * scale, 0.05);\n    color += curve(uv, vec2(1.5, -2.0) * scale, vec2(-1.3, 2.0) * scale, 0.05);\n\n    fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 91, 148, 148, 251], [253, 253, 319, 319, 598], [600, 600, 655, 655, 1035]], "test": "valid"}
{"id": "tdtfDS", "name": "bitwise integer patterns", "author": "frhun", "description": "effect of bitwise operators XOR, AND, OR\nand.. doing stuff with those numbers\n\nYou can control the movement direction with your mouse.\nAlso try the different output patterns that are currently commented out!", "tags": ["xor", "pattern", "hash", "bitwise", "circuits"], "likes": 7, "viewed": 236, "published": "Public API", "date": "1605989774", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"fract ( XOR / n )\" by FabriceNeyret2. https://shadertoy.com/view/wllcRN\n// 2020-11-21 00:03:31\n\n// inspired from python273 https://shadertoy.com/view/4ldyW8\n// See also https://www.shadertoy.com/view/ttscRN\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    vec2 R = iResolution.xy;\n    ivec2 I = ivec2(U+300.*iTime*normalize(iMouse.xy+vec2(1.)));\n    \n    int r = I.x ^ I.y,\n        s = I.x & I.y,\n        t = I.x | I.y;\n    \n    /*\n    O = vec4(\n        fract(float(r*r) / floor(mod(iTime+6., 50.))),\n        fract(float(s*s) / floor(mod(iTime+6., 50.))),\n    \tfract(float(t*t) / floor(mod(iTime+6., 50.))),\n        1.0\n    );\n\t*/\n    \n    O = vec4(\n        fract(float(r*r*r) / floor(mod(iTime+6., 50.))),\n        fract(float(s*s*s) / floor(mod(iTime+6., 50.))),\n    \tfract(float(t*t*t) / floor(mod(iTime+6., 50.))),\n        1.0\n    );\n\t\n    //O = vec4(fract( float(r*s*t) / floor(mod(iTime+6., 50.)) ));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtfDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[220, 220, 258, 258, 914]], "test": "valid"}
{"id": "tdtyDl", "name": "the flag of Romania - 004", "author": "catafest", "description": "the flag of Romania with wind effect ... \nhttps://en.wikipedia.org/wiki/Flag_of_Romania", "tags": ["flag", "romania", "catafest"], "likes": 2, "viewed": 170, "published": "Public API", "date": "1606773187", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//The flag is coincidentally very similar to the civil flag of Andorra and \n//the state flag of Chad. \n//The similarity with Chad's flag, which is identical apart from allowing a broader range of shades of \n//blue, yellow and red, has caused international discussion. \n//see https://en.wikipedia.org/wiki/Flag_of_Romania\n//the gl_FragColor is a vec4 type of float values in the range 0 to 1.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    // set color background\n\tfragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    float flag_X = uv.x * 1.5+1.0;\n    \n  \n  float flag_Y = 1.0 + uv.y + (sin((flag_X - iTime) * 6.0) * 0.03 * flag_X) - uv.x;\n    \n    flag_X = flag_X/2.0 - flag_Y * 0.5;\n    \n    if (flag_X > 0.0 && flag_X < 1.0  && flag_Y > 0.0) \n    { \t\t       \n\t\tfloat size = 3.0;\n\t\tif (flag_X < 1.0 / size) \n\t\t{\n\t\t\t// Output to screen fill the screen with blue\n\t\t\tfragColor = vec4(0,0,1,0);\n            \t\n\t\t} else if (flag_X < 2.0 / size) {     \n\t\t\t// fill the 2/3 of size with yellow color\n\t\t\tfragColor = vec4(1,1,0,0);\n        \t    \n\t\t} else if (flag_X < 3.0 / size) {\n   \n\t\t\t// fill the last 1/3 with the red color \n\t\t\tfragColor = vec4(1,0,0,0);\n\t\t}\n\t}\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdtyDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 392, 449, 499, 1258]], "test": "valid"}
{"id": "tdVfzD", "name": "Ask the Mountains / Flow", "author": "lyurai", "description": "ask the mountains and flow inspired shader", "tags": ["scale"], "likes": 0, "viewed": 204, "published": "Public API", "date": "1606745698", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a){return mat2(cos(a),-sin(a),sin(a),cos(a));}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n    vec3 col;\n    float t;\n    \n    for(int c=0;c<3;c++){\n\t    vec2 uv = (fragCoord*1.-iResolution.xy)/t;\n        t = iTime+float(c)/100.;\n        for(int i=0;i<5;i++)\n        {\n        \tuv=abs(uv);\n        \tuv-=8.;\n        \tuv=uv*rot(t/float(i+1));\n        }\n        \n     col[c] = fract(uv.x/t);\n        \n\t}\n    \n    fragColor = vec4(vec3(col),1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdVfzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 18, 61], [63, 63, 120, 120, 480]], "test": "valid"}
{"id": "tdyBR1", "name": "Night circuit", "author": "gaz", "description": "3d", "tags": ["3d"], "likes": 22, "viewed": 226, "published": "Public", "date": "1606653699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define TAU atan(1.)*8.\n\nvoid lookAt(inout vec3 rd,vec3 ro,vec3 ta,vec3 up){\n    vec3 w=normalize(ta-ro),u=normalize(cross(w,up));\n    rd=rd.x*u+rd.y*cross(u,w)+rd.z*w;\n}\n\nvoid pointAt(inout vec3 p, vec3 dir, vec3 up){\n    vec3 u=normalize(cross(dir,up));\n\tp=vec3(dot(p,u),dot(p,cross(u,dir)),dot(p,dir));\n}\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 u=cross(a,p),v=cross(a,u);\n\tp=u*sin(t)+v*cos(t)+a*dot(a,p);   \n}\n\nvoid rot(inout vec2 p,float t){\n    p=p*cos(t)+vec2(-p.y,p.x)*sin(t);\n}\n\n// https://www.shadertoy.com/view/WdfcWr\nvoid pSFold(inout vec2 p,float n){\n    float h=floor(log2(n)),a=TAU*exp2(h)/n;\n    for(float i=0.;i<h+2.;i++)    {\n\t \tvec2 v=vec2(-cos(a),sin(a));\n\t\tfloat g=dot(p,v);\n \t\tp-=(g-sqrt(g*g+2e-3))*v;\n \t\ta*=.5;\n    }\n}\n\n#define seed 2576.\n#define hash(p)fract(sin(p*12345.5))\n\nvec3 randVec(float s)\n{\n    vec2 n=hash(vec2(s,s+215.3));\n    return vec3(cos(n.y)*cos(n.x),sin(n.y),cos(n.y)*sin(n.x));\n}\n\nvec3 randCurve(float t,float n)\n{\n    vec3 p = vec3(0);\n    for (int i=0; i<3; i++){\n        p+=randVec(n+=365.)*sin((t*=1.3)+sin(t*.6)*.5);\n    }\n    return p;\n}\n\nvec3 orbit(float t,float n)\n{\n    vec3 p = randCurve(-t*1.5+iTime,seed)*5.;\n    vec3 off = randVec(n)*(t+.05)*.6;\n    float time=iTime+hash(n)*5.;\n    return p+off*sin(time+.5*sin(.5*time));\n}\n\nfloat g1=0.,g2=0.,g3=0.;\n\n// rewrote 20/12/01\nvoid sFold45(inout vec2 p)\n{\n\tvec2 v=normalize(vec2(1,-1));\n\tfloat g=dot(p,v);\n\tp-=(g-sqrt(g*g+5e-5))*v;\n}\n\nfloat stella(vec3 p, float s)\n{\n    p=sqrt(p*p+5e-5); // https://www.iquilezles.org/www/articles/functions/functions.htm\n    sFold45(p.xz);\n\tsFold45(p.yz);\n    return dot(p,normalize(vec3(1,1,-1)))-s;\n}\n\n/*\nfloat stella(vec3 p, float s)\n{\n    p=abs(p);\n    if(p.x<p.z)p.xz=p.zx;\n    if(p.y<p.z)p.yz=p.zy;\n    return dot(p,normalize(vec3(1,1,-1)))-s;\n}\n*/\n\nfloat stellas(vec3 p)\n{\n    p.y-=-iTime;\n    float c=2.;\n    vec3 e=floor(p/c);\n    e = sin(11.0*(2.5*e+3.0*e.yzx+1.345)); \n    p-=e*.5;\n    p=mod(p,c)-c*.5;\n    rot(p,hash(e+166.887)-.5,iTime*1.5); \n    return min(.7,stella(p,.08));\n}\n\nfloat structure(vec3 p)\n{\n    float d=1e3,d0;\n    for(int i=0;i<12;i++){\n    \tvec3 q=p,w=normalize(vec3(sqrt(5.)*.5+.5,1,0)); \n        w.xy*=vec2(i>>1&1,i&1)*2.-1.;\n        w=vec3[](w,w.yzx,w.zxy)[i%3];\n        pointAt(q,w,-sign(w.x+w.y+w.z)*sign(w)*w.zxy);\n        \n        d0=length(q-vec3(0,0,clamp(q.z,2.,8.)))-.4+q.z*.05;\n        d=min(d,d0);\n        g2+=.1/(.1+d0*d0); // Distance glow by balkhan\n        \n        float c=.8;\n        float e=floor(q.z/c-c*.5);\n        q.z-=c*clamp(round(q.z/c),3.,9.);\n        \n        q.z-=clamp(q.z,-.05,.05);\n        pSFold(q.xy,5.);\n        q.y-=1.4-e*.2+sin(iTime*10.+e+float(i))*.05;\n        q.x-=clamp(q.x,-2.,2.);\n        q.y-=clamp(q.y,0.,.2);\n        \n        d0=length(q)*.7-.05;\n        d=min(d,d0);\n        if(e==2.+floor(mod(iTime*5.,7.)))\n            g1+=.1/(.1+d0*d0);\n    }\n    return d;\n}\n\nfloat rabbit(vec3 p)\n{\n    p-=randCurve(iTime,seed)*5.;\n    rot(p,vec3(1),iTime);\n    float d=stella(p,.2);\n    g3+=.1/(.1+d*d);\n    return d;\n}\n\nfloat map(vec3 p){\n    return min(min(stellas(p),structure(p)),rabbit(p));\n}\n\nvec3 calcNormal(vec3 p)\n{\n  vec3 n=vec3(0);\n  for(int i=0; i<4; i++){\n    vec3 e=.001*(vec3(9>>i&1, i>>1&1, i&1)*2.-1.);\n    n+=e*map(p+e);\n  }\n  return normalize(n);\n}\n\nvec3 doColor(vec3 p)\n{\n    if(stellas(p)<.001)return vec3(.7,.7,1);\n\treturn vec3(1);\n}\n\nvec3 hue(float h)\n{\n    return cos((vec3(0,2,-2)/3.+h)*TAU)*.5+.5;\n}\n\nvec3 cLine(vec3 ro, vec3 rd, vec3 a, vec3 b)\n{\n    vec3 ab=normalize(b-a),ao = a-ro;\n\tfloat d0=dot(rd,ab),d1=dot(rd,ao),d2=dot(ab,ao);\n\tfloat t = (d0*d1-d2)/(1.-d0*d0)/length(b-a);\n    t= clamp(t,0.,1.);\n    vec3 p = a+(b-a)*t-ro;\n    return vec3(length(cross(p,rd)),dot(p,rd),t);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (2.0 * fragCoord - iResolution.xy) / iResolution.y;\n    vec3 col=vec3(.0,.0,.05);\n    vec3 ro = vec3(1, 0, int[](7,10,12,15)[int(abs(4.*sin(iTime*.3+3.*sin(iTime*.2))))&3]);\n    rot(ro,vec3(1),iTime*.2);\n    vec3 ta = vec3(2,1,2);\n    vec3 rd = normalize(vec3(p,2));\n    lookAt(rd,ro,ta,vec3(0,1,0));       \n\tfloat z=0.,d,i,ITR=50.;\n \tfor(i=0.; i<ITR; i++){\n    \tz+=d=map(ro+rd*z);\n    \tif(d<.001||z>30.)break;\n  \t}\n    if(d<.001)\n  \t{\n\t\tvec3 p=ro+rd*z;\n\t\tvec3 nor=calcNormal(p);\n    \tvec3 li=normalize(vec3(1,1,-1));\n    \tcol=doColor(p);\n    \tcol*=pow(1.-i/ITR,2.); \n     \tcol*=clamp(dot(nor,li),.3,1.);\n    \tcol*=max(.5+.5*nor.y,0.2);\n    \tcol+=vec3(0.8,0.1,0.)*pow(clamp(dot(reflect(normalize(p-ro),nor),normalize(vec3(-1,-1,-1))),0.,1.),30.);\n    \tcol+=vec3(0.1,0.2,0.5)*pow(clamp(dot(reflect(normalize(p-ro),nor),normalize(vec3(1,1,-1))),0.,1.),30.);\n    \tcol=mix(vec3(0),col,exp(-z*z*.00001));\n    }\n    col+=vec3(.9,.1,0.)*g1*.05;\n    col+=vec3(0.,.3,.7)*g2*.08;\n    col+=vec3(.5,.3,.1)*g3*.15;\n \n    // https://www.shadertoy.com/view/wtXSzX\n    vec3 de;\n    ITR=40.;\n    for(float i=0.; i<1.;i+=1./7.)\n    {\n        de = vec3(1e9);\n        float off=hash(i*234.6+256.);\n    \tfor(float j=0.;j<1.;j+=1./ITR)\n    \t{\n            float t=j+off*0.5;\n        \tvec3 c=cLine(ro,rd,orbit(t,off),orbit(t+1.0/ITR,off));\n        \tif (de.x*de.x*de.y>c.x*c.x*c.y)\n        \t{\n           \t\tde=c;\n           \t\tde.z=j+c.z/ITR;\n        \t}\n    \t}\n        float s = pow(max(.0,.6-de.z),2.)*.1;\n        if(de.y>0.&&z>de.y)\n            col+=mix(vec3(1),hue(i),0.8)*(1.0-de.z*0.9)*smoothstep(s+0.17,s,de.x)*0.7;\n    }\n    col=pow(col,vec3(.8+.3*sin(iTime*.5+3.*sin(iTime*.3))));\n    fragColor.xyz = col;\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[25, 25, 76, 76, 170], [172, 172, 218, 218, 307], [309, 309, 347, 347, 435], [437, 437, 468, 468, 508], [510, 551, 585, 585, 763], [822, 822, 845, 845, 944], [946, 946, 979, 979, 1108], [1110, 1110, 1139, 1139, 1302], [1330, 1350, 1378, 1378, 1456], [1458, 1458, 1489, 1489, 1660], [1814, 1814, 1837, 1837, 2049], [2899, 2899, 2921, 2921, 3043], [3045, 3045, 3063, 3063, 3121], [3123, 3123, 3148, 3148, 3291], [3293, 3293, 3315, 3315, 3379], [3381, 3381, 3400, 3400, 3449], [3451, 3451, 3497, 3497, 3733]], "test": "error"}
{"id": "tdyBRD", "name": "Desert Ducks", "author": "dr2", "description": "Where did they come from (possibly found and lost in Utah)?", "tags": ["art", "reflect", "utah", "landscapemystery"], "likes": 2, "viewed": 241, "published": "Public API", "date": "1606670039", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Desert Ducks\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0  // (= 0/1) optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrEllipsDf (vec3 p, vec3 r);\nfloat PrEllCylDf (vec3 p, vec2 r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat Minv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 Rot2Cs (vec2 q, vec2 cs);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define VAR_ZERO min (iFrame, 0)\n\nstruct GrParm {\n  float gFac, hFac, fWav, aWav;\n};\nGrParm gr;\n\nvec4 dateCur;\nvec3 sunDir, rPos;\nvec2 gId;\nfloat tCur, tCurD, dstFar, hgSize, sclFac, sAng;\nint idObj;\nconst int idPil = 1, idBdy = 2, idBk = 3, idEye = 4;\nbool isOcc, isSh;\nconst float pi = 3.14159, sqrt3 = 1.732051;\n\n#define DMIN(id) if (d < dMin) { dMin = d;  idObj = id; }\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float f, wAmp;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * gr.fWav;\n  q = gr.gFac * p;\n  wAmp = 4. * gr.hFac;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= gr.aWav;\n    q *= qRot;\n  }\n  return f;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nvoid SetGrdConf ()\n{\n  float h;\n  rPos.xz = 0.5 * hgSize * sin (2. * pi * Hashfv2 (17.1 * gId + 0.3) + vec2 (0.5 * pi, 0.));\n  rPos.y = GrndHt (HexToPix (gId * hgSize) + rPos.xz);\n  h = Hashfv2 (19.1 * gId + 0.3);\n  isOcc = (h > 0.2);\n  sclFac = 2.5;\n  sAng = 0.15 * (h - 0.6) * tCurD;\n}\n\nfloat DuckDf (vec3 p, float dMin)\n{\n  vec3 q;\n  vec2 cs, r;\n  float d, h, s;\n  dMin /= sclFac;\n  p /= sclFac;\n  cs = sin (0.3 + vec2 (0.5 * pi, 0.));\n  h = 0.5;\n  r = vec2 (0.2, 0.3 + 0.05 * clamp (p.z, -2., 2.));\n  s = (length (p.xz / r) - 1.) * min (r.x, r.y);\n  d = min (max (s, abs (p.y) - h), length (vec2 (s, p.y)) - h);\n  DMIN (idBdy);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 0.3, 0.6);\n  q.yz = Rot2Cs (q.yz, cs);\n  q.xy = Rot2Cs (q.xy, vec2 (cs.x, - cs.y));\n  q.xz = Rot2Cs (q.xz, vec2 (cs.x, - cs.y));\n  r = vec2 (0.3, 0.5 + 0.08 * clamp (q.z, -2., 2.));\n  h = 0.07;\n  s = (length (q.yz / r) - 1.) * min (r.x, r.y);\n  d = SmoothMin (min (max (s, abs (q.x) - h), length (vec2 (s, q.x)) - h), dMin, 0.05);\n  DMIN (idBdy);\n  d = SmoothMin (PrEllipsDf (p - vec3 (0., 0.75, -0.4), vec3 (0.4, 0.35, 0.5)), dMin, 0.1);\n  DMIN (idBdy);\n  q = p - vec3 (0., 0.65, -0.9);\n  q.zy = Rot2Cs (q.zy, vec2 (cs.x, - cs.y));\n  h = 0.15;\n  r = vec2 (0.15, 0.04) * (1. - 0.1 * min (2., max (0., 1. - q.z / h)));\n  d = PrEllCylDf (q, r, h);\n  q.z -= -0.9 * h;\n  d = SmoothMin (max (d, - PrEllCylDf (q, r - 0.02, 0.5 * h)), dMin, 0.01);\n  DMIN (idBk);\n  q = p;\n  q.x = abs (q.x);\n  d = PrSphDf (q - vec3 (0.26, 0.825, -0.6), 0.11);\n  DMIN (idEye);\n  return 0.9 * sclFac * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (isOcc) {\n    p.xz -= HexToPix (gId * hgSize);\n    p -= rPos;\n    q = p;\n    q.y -= -1.5;\n    d = PrCylDf (q.xzy, 0.4, 3.);\n    DMIN (idPil);\n    q.y -= 3.8;\n    if (! isSh) d = PrSphDf (q, 3.8);\n    if (isSh || d < 0.1) {\n      q.xz = Rot2D (q.xz, sAng);\n      dMin = DuckDf (q, dMin);\n    } else dMin = min (dMin, d);\n  }\n  return dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.03;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += h;\n    if (h < 0.005) break;\n  }\n  return 0.6 + 0.4 * sh;\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  h = RippleHt (p);\n  e = vec2 (0.002, 0.);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.45, 0.45, 0.5), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.x -= tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2 (0.05 * (ro + rd * (100. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (1., 1., 0.95) * (1. - 0.1 * smoothstep (0.8, 0.95, f)), clamp (0.9 * f * rd.y, 0., 1.));\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dFac, f, sh;\n  dFac = 1. - smoothstep (0.15, 0.35, dstGrnd / dstFar);\n  ro += dstGrnd * rd;\n  vn = GrndNf (ro);\n  col = mix (vec3 (0.65, 0.45, 0.1), vec3 (0.95, 0.7, 0.4), smoothstep (1., 3., ro.y));\n  col *= 1. - 0.3 * dFac * Fbm2 (128. * ro.xz);\n  if (dFac > 0.) {\n    if (vn.y > 0.3) {\n      f = smoothstep (0.5, 2., ro.y) * smoothstep (0.3, 0.8, vn.y) * dFac;\n      vn4 = RippleNorm (ro.xz, vn, 4. * f);\n      vn = vn4.xyz;\n      col *= mix (1., 0.95 + 0.05 * smoothstep (0.1, 0.3, vn4.w), f);\n    }\n    gId = PixToHex (ro.xz / hgSize);\n    SetGrdConf ();\n    if (isOcc) col *= 0.8 + 0.2 * smoothstep (0.4, 0.7, length (ro.xz -\n       HexToPix (gId * hgSize) - rPos.xz));\n  }\n  isSh = true;\n  sh = min (ObjSShadow (ro + 0.01 * vn, sunDir),\n     1. - 0.6 * smoothstep (0.4, 0.7, Fbm2 (0.03 * ro.xz - tCur * vec2 (0.15, 0.))));\n  col *= (0.2 + 0.1 * vn.y + 0.7 * sh * max (0., dot (vn, sunDir))) * (0.7 + 0.3 * dFac);\n  col = mix (col, SkyBg (rd), pow (dstGrnd / dstFar, 4.));\n  return col;\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec3 col, vn;\n  float dFac;\n  dFac = 1. - smoothstep (0.15, 0.35, dstObj / dstFar);\n  ro += dstObj * rd;\n  vn = ObjNf (ro);\n  if (idObj != idEye) {\n    if (idObj == idPil) {\n      col = vec3 (0.7, 0.5, 0.);\n      vn = VaryNf (16. * ro, vn, 2. * dFac);\n    } else col = vec3 (0.5, 0.6, 0.9);\n    col = col * (0.2 + 0.1 * max (0., - vn.y) + 0.8 * max (0., dot (vn, sunDir))) +\n       0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  } else {\n    col = vec3 (0., 0.8, 0.) * max (0.2, - dot (vn, rd));\n  }\n  col *= 0.7 + 0.3 * dFac;\n  col = mix (col, SkyBg (rd), pow (dstObj / dstFar, 4.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstGrnd, dstObj, dstObjO;\n  bool isRef;\n  const int maxRef = 3;\n  isSh = false;\n  isRef = false;\n  for (int k = VAR_ZERO; k <= maxRef; k ++) {\n    dstObj = ObjRay (ro, rd);\n    dstGrnd = GrndRay (ro, rd);\n    if (k == 0) dstObjO = dstObj;\n    if (k < maxRef && dstObj < min (dstGrnd, dstFar) && (idObj == idBdy || idObj == idBk)) {\n      isRef = true;\n      ro += dstObj * rd;\n      vn = ObjNf (ro);\n      rd = reflect (rd, vn);\n      ro += 0.01 * rd;\n    } else break;\n  }\n  if (min (dstObj, dstGrnd) < dstFar) {\n    col = (dstObj < dstGrnd) ? ObjCol (ro, rd, dstObj) : GrndCol (ro, rd, dstGrnd);\n    if (isRef) col = mix (col, SkyBg (rd), pow (dstObjO / dstFar, 8.));\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 w;\n  vec2 cs;\n  v = normalize (v);\n  cs = sin (clamp (1. * (v.z * a.x - v.x * a.z), -0.1 * pi, 0.1 * pi) + vec2 (0.5 * pi, 0.));\n  w = normalize (vec3 (v.z, 0., - v.x));\n  return mat3 (w, cross (v, w), v) * mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (10. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     7. * sin (0.0061 * t), 0., t);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, fpF, fpB;\n  vec2 canvas, uv;\n  float el, az, zmFac, sunEl, sunAz, hSum, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur + 30., 36000.) + 30. * floor (dateCur.w / 7200.);\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  hgSize = 16.;\n  gr.gFac = 0.1;\n  gr.hFac = 1.3;\n  gr.fWav = 1.9;\n  gr.aWav = 0.45;\n  dstFar = 150.;\n  vuMat = StdVuMat (el, az);\n  tCurD = 5. * (floor (tCur / 5.) + smoothstep (0.8, 0.999, mod (tCur / 5., 1.)));\n  ro = TrackPath (tCurD);\n  fpF = TrackPath (tCurD + 1.);\n  fpB = TrackPath (tCurD - 1.);\n  flMat = EvalOri ((fpF - fpB) / 2., fpF - 2. * ro + fpB);\n  hSum = 0.;\n  for (float k = 0.; k < 7.; k ++) hSum += GrndHt (TrackPath (tCurD + 0.5 * (k - 1.)).xz);\n  ro.y = 8. * gr.hFac + hSum / 7.;\n  sunAz = 0.002 * 2. * pi * tCurD;\n  sunEl = pi * (0.25 + 0.1 * sin (0.35 * sunAz));\n  sunDir = vec3 (cos (sunEl) * sin (sunAz + vec2 (0.5 * pi, 0.)), sin (sunEl)).xzy;\n  zmFac = 2.5;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = flMat * (vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac)));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrEllipsDf (vec3 p, vec3 r)\n{\n  return (length (p / r) - 1.) * min (r.x, min (r.y, r.z));\n}\n\nfloat PrEllCylDf (vec3 p, vec2 r, float h)\n{\n  return max ((length (p.xy / r) - 1.) * min (r.x, r.y), abs (p.z) - h);\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nvec2 Rot2Cs (vec2 q, vec2 cs)\n{\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyBRD.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1020, 1020, 1043, 1043, 1299], [1301, 1301, 1335, 1335, 1815], [1817, 1817, 1839, 1839, 1978], [1980, 1980, 2000, 2000, 2267], [2269, 2269, 2304, 2304, 3541], [3543, 3543, 3565, 3565, 3955], [3957, 3957, 3990, 3990, 5263], [5265, 5265, 5286, 5286, 5541], [5543, 5543, 5580, 5580, 5970], [5972, 5972, 5997, 5997, 6376], [6378, 6378, 6422, 6422, 6621], [6623, 6623, 6645, 6645, 6739], [6741, 6741, 6773, 6773, 7103], [7105, 7105, 7153, 7153, 8184], [8186, 8186, 8232, 8232, 8849], [8851, 8851, 8886, 8886, 9644], [9646, 9646, 9677, 9677, 9946], [9948, 9948, 9974, 9974, 10086], [10088, 10088, 10144, 10144, 11787], [11789, 11789, 11822, 11822, 11849], [11851, 11851, 11893, 11893, 11944], [11946, 11946, 11981, 11981, 12043], [12045, 12045, 12089, 12089, 12164], [12166, 12166, 12211, 12211, 12314], [12316, 12316, 12338, 12338, 12376], [12378, 12378, 12402, 12402, 12632], [12634, 12634, 12658, 12658, 12718], [12720, 12720, 12750, 12750, 12863], [12865, 12865, 12896, 12896, 12960], [12962, 12962, 12998, 12998, 13204], [13238, 13238, 13262, 13262, 13392], [13394, 13394, 13418, 13418, 13478], [13480, 13480, 13505, 13505, 13691], [13693, 13693, 13714, 13714, 13869], [13871, 13871, 13900, 13900, 14112], [14114, 14114, 14153, 14153, 14333]], "test": "error"}
{"id": "tdyfRR", "name": "(not) moving circle illusion", "author": "bgolus", "description": "Inspired by:\nhttps://twitter.com/jagarikin/status/1331409504953540613", "tags": ["illusion"], "likes": 42, "viewed": 2118, "published": "Public API", "date": "1606557470", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Click and move mouse around to control the ring's \"movement\" direction\n// Hold down space bar to show a grid in the background to show the ring really isn't moving\n\n// You can pause to get a better idea of what's actually happening.\n\n// inspired by this tweet\n// https://twitter.com/jagarikin/status/1331409504953540613\n\n\n\n// show two rings like the original inspiration\n#define TWO_RINGS\n\n// show arrows inside the ring(s)\n#define SHOW_ARROWS\n\n// always show the grid, even if not holding down space bar or so you can enable it on mobile\n//#define FORCE_GRID_ON\n\n\n\n// basic defines\n// slowing down the spin rate can expose how the effect works\n#define SPIN_RATE 2.0\n// a wider line doesn't make the effect stronger, but again can help expose what it's doing while still working\n#define OUTLINE_WIDTH 1.0\n#define RING_RADIUS 80.0\n\n#define pi 3.141592\n#define tau (pi * 2.0)\n\nconst int KEY_SPACE = 32;\n\n// basic 2D rotation\nvec2 rotate(vec2 coord, float angle)\n{\n    float s = sin(angle);\n    float c = cos(angle);\n    \n    return vec2(c * coord.x - s * coord.y, s * coord.x + c * coord.y);\n}\n\n// borrowed from Trisomie21's comments in this shader\n// https://www.shadertoy.com/view/4s23DG\nfloat lineArrow(vec2 p, vec2 p1, vec2 p2, float a) {\n\tvec2 v = p2 - p1;\n\tvec2 w = p - p1;\n\tfloat d = clamp(dot(w,v) / dot(v,v), 0., 1.);\n\tfloat l = length(w-v*d);\n\ta = max(a*d-3., l-a*d);\n\treturn min(l, a)-.5;\n}\n\nfloat sdSegment( in vec2 p, in vec2 a, in vec2 b )\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\nvec4 ring(vec2 uv, float aa, float speed, vec2 dir)\n{\n    float dist = length(uv);\n    \n    float ring_radius = 0.6;\n    \n    float edge = min(1.0 - dist, dist - ring_radius) / aa;\n    float outline_edge = edge - OUTLINE_WIDTH;\n    \n    float dirMag = min(1.0, length(dir));\n    float dirFade = 0.0;\n    float arrow = 0.0;\n    \n    // directional movement\n    if (dir != vec2(0.0))\n    {        \n        float dir_cosine = dot(normalize(dir), normalize(uv));\n        \n        // flip movment direction if negative speed\n        if (speed < 0.0)\n            dir = -dir;\n        \n        // flip speed for ring edges on the \"back\" sides of the ring\n    \tspeed *= sign(dir_cosine);\n        \n        // fade out outline on edges not facing the axis of movement\n        dirFade = 1.0 - clamp(abs(dir_cosine / 0.7), 0.0, 1.0);\n        \n        // direction arrow\n        arrow = 1.0 - lineArrow(uv * RING_RADIUS, normalize(dir) * (RING_RADIUS * 0.25), -normalize(dir) * (RING_RADIUS * 0.25), 20.0);\n    }\n    else\n    {\n        // grow & shring arrows calculated by flipping and swizzling the start and end points\n        vec4 arrowStartEnd = vec4(RING_RADIUS * 0.1, 0.0, RING_RADIUS * 0.35, 0.0);\n        arrowStartEnd = speed > 0.0 ? arrowStartEnd : arrowStartEnd.zwxy;\n        \n        // diagonals\n        float ur = dot(vec2(1.0, 1.0), uv);\n        float ul = dot(vec2(-1.0, 1.0), uv);\n        \n        arrowStartEnd = ul > 0.0 ? -arrowStartEnd : arrowStartEnd;\n        arrowStartEnd = (ul > 0.0 ? ur : -ur) > 0.0 ? -arrowStartEnd.yxwz : arrowStartEnd;\n        \n        arrow = 1.0 - lineArrow(uv * RING_RADIUS, arrowStartEnd.zw, arrowStartEnd.xy, 10.0);\n    }\n    arrow = smoothstep(-1.5, 0.0, arrow);\n    arrow *= abs(speed);\n    \n    // spin UVs for main ring pattern\n    float rotation = iTime * tau * SPIN_RATE;\n    vec2 rotuv_inside = rotate(uv.xy, rotation);\n    \n    // spin UVs with offset for ring outlines\n    speed = dist > ((1.0 + ring_radius) * 0.5) ? speed : -speed;\n    vec2 rotuv_outline = rotate(uv.xy, rotation - pi * speed * 0.25);\n    \n    // colors\n    vec3 yellow = vec3(0.97, 0.77, 0.2);\n    vec3 blue = vec3(0.1, 0.25, 0.81);\n    vec3 arrow_color = vec3(0.0);\n    \n    // masks for ring and outline edges\n    edge = smoothstep(-0.75, 0.75, edge);\n    outline_edge = smoothstep(-0.75, 0.75, outline_edge + (OUTLINE_WIDTH + 1.5) * dirFade);\n    \n    // mask for ring's alternating colors\n    float inside_mask = smoothstep(-aa, aa, rotuv_inside.x);\n    inside_mask = mix(1.0 - inside_mask, inside_mask, smoothstep(-aa, aa, rotuv_inside.y));\n    \n    // mask for outine's alternatting colors\n    float outline_mask = smoothstep(-aa, aa, rotuv_outline.x);\n    outline_mask = mix(1.0 - outline_mask, outline_mask, smoothstep(-aa, aa, rotuv_outline.y));\n    \n    // mix together\n    vec3 col = mix(yellow, blue, inside_mask);\n    col = mix(mix(yellow, blue, outline_mask), col, outline_edge);\n    \n    // draw in arrows if they're enabled\n    #if defined(SHOW_ARROWS)\n    col = dist < (ring_radius - aa * 2.0) ? arrow_color : col;\n    edge += arrow;\n    #endif\n    \n    return vec4(col, edge);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord;\n    vec2 halfResolution = iResolution.xy * 0.5;\n    \n    uv -= halfResolution;\n    uv /= RING_RADIUS;\n    \n    // background\n    vec3 col = vec3(0.5);\n    \n    // show grid if holding down space, or if forced on.\n    #if !defined(FORCE_GRID_ON)\n    if (texture( iChannel0, vec2((float(KEY_SPACE) + 0.5) / 256.0, 0.5 / 3.0) ).x > 0.0)\n    #endif\n    {\n    \tfloat grid = mod((floor(uv.x * 3.0) + floor(uv.y * 3.0)) + 1000.0, 2.0);\n    \tcol = vec3(grid == 0.0 ? 0.475 : 0.5);\n\t}\n    \n    // wiggle the speed between 1.0 and -1.0\n    float speed = smoothstep(0.25, 0.75, abs(fract(iTime * 0.15) * 2.0 - 1.0)) * 2.0 - 1.0;\n    \n    // rotate direction over time\n    float moveAngle = -iTime * 0.451;\n    vec2 dir = vec2(sin(moveAngle), cos(moveAngle));\n    \n    // if dir == 0, speed controls grow / shrink, so fade speed in and out and set dir to 0\n    speed *= abs(smoothstep(0.3, 0.5, abs(fract(iTime * 0.025) * 2.0 - 1.0)) * 2.0 - 1.0);\n    dir = abs(fract(iTime * 0.025) * 2.0 - 1.0) > 0.4 ? dir : vec2(0.0);\n    \n    // mouse controls\n    if (iMouse.z > 0.0)\n    {\n        vec2 mouseRelativePos = iMouse.xy - halfResolution;\n        #if defined(TWO_RINGS)\n        float mouseDist = sdSegment(mouseRelativePos, vec2(-RING_RADIUS * 1.33, 0.0), vec2(RING_RADIUS * 1.33, 0.0));\n        #else\n        float mouseDist = length(mouseRelativePos);\n        #endif\n        \n        if (mouseDist > RING_RADIUS * 2.0)\n        {\n            dir = normalize(mouseRelativePos);\n            speed = clamp((mouseDist - RING_RADIUS * 2.1) / min(RING_RADIUS, halfResolution.y - RING_RADIUS), 0.0, 1.0);\n        }\n        else\n        {\n            dir = vec2(0.0);\n            #if defined(TWO_RINGS)\n            speed = clamp(mouseRelativePos.x / (RING_RADIUS * 1.33), -1.0, 1.0);\n            #else\n            speed = clamp(mouseDist / RING_RADIUS * 3.0 - 2.0, -1.0, 1.0);\n            #endif\n        }\n    }\n        \n    vec2 ringUV = uv;\n    \n    // support two rings by offseting uvs and flipping the speed direction\n    #if defined(TWO_RINGS)\n    if (uv.x < 0.0)\n    {\n        ringUV.x += 1.33;\n    }\n    else\n    {\n        speed = -speed;\n        ringUV.x -= 1.33;\n    }\n    // add a center point dot\n    col = mix(vec3(0.0), col, smoothstep(1.5, 3.5, length(uv * RING_RADIUS)));\n    #endif    \n    \n    float aa = 1.0 / RING_RADIUS;\n    \n    // draw ring\n    vec4 ringCol = ring(ringUV, aa, speed, dir);\n    col = mix(col, ringCol.rgb, ringCol.a);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[905, 926, 964, 964, 1094], [1096, 1191, 1243, 1243, 1402], [1404, 1404, 1456, 1456, 1575], [1577, 1577, 1630, 1630, 4690]], "test": "error"}
{"id": "tdyfRz", "name": "_Making a rectangle_", "author": "Paulo_Silva", "description": "Making a rectangle", "tags": ["rectangle"], "likes": 0, "viewed": 38, "published": "Public", "date": "1606700802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float rect (vec2 uv, vec2 p, vec2 size, float angle, float blur) {\n \n    mat2 rot = mat2(vec2(cos(angle), sin(angle)), vec2(-sin(angle), cos(angle)));\n    \n    uv -= p;\n    uv *= rot;\n    \n    float band1 = smoothstep(-size.x, -size.x + blur, uv.x);\n    float band2 = smoothstep(size.x, size.x - blur, uv.x);\n    \n    float band3 = smoothstep(-size.y, -size.y + blur, uv.y);\n    float band4 = smoothstep(size.y, size.y - blur, uv.y);\n    \n    return band1 * band2 * band3 * band4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    \n    float angle = iTime * 1.0;\n    mat2 rot = mat2(vec2(cos(angle), sin(angle)), vec2(-sin(angle), cos(angle)));\n    \n    \n    float rect = rect(uv, vec2(0.0, 0.0), vec2(0.4, 0.5), iTime, 0.01);\n\n    vec3 col = vec3(0.3, 0.5, 1.0) * rect;\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tdyfRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 66, 66, 482], [484, 484, 541, 541, 932]], "test": "valid"}
{"id": "ts3BD4", "name": "Blobs - Edvid", "author": "Edvid", "description": "Blobs looking like cells maybe", "tags": ["fragment"], "likes": 0, "viewed": 18, "published": "Public", "date": "1605106166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 blobs[30];\nfloat strength = 0.02;\nfloat speed = 0.003;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float val = 0.0;\n  \tfor (int i = 0; i < blobs.length(); i++)\n  \t{\n    \tblobs[i] = vec2(\n            fract(iTime*-11.0*speed + pow(float(i),1.2)*0.323 + sin(iTime*sin(float(i))*2.617924)*0.02),\n            fract(iTime*17.0*speed + pow(float(i),1.3)*0.456 + cos(iTime*sin(float(i))*1.618)*0.02)\n        );\n        val += strength / pow(distance(uv, blobs[i]),2.0);\n        val += strength / pow(distance(uv, blobs[i] + vec2(1.0,0.0)),2.0);\n        val += strength / pow(distance(uv, blobs[i] + vec2(-1.0,0.0)),2.0);\n        \n        val += strength / pow(distance(uv, blobs[i] + vec2(0.0,1.0)),2.0);\n        val += strength / pow(distance(uv, blobs[i] + vec2(1.0,1.0)),2.0);\n        val += strength / pow(distance(uv, blobs[i] + vec2(-1.0,1.0)),2.0);\n        \n        val += strength / pow(distance(uv, blobs[i] + vec2(0.0,-1.0)),2.0);\n        val += strength / pow(distance(uv, blobs[i] + vec2(1.0,-1.0)),2.0);\n        val += strength / pow(distance(uv, blobs[i] + vec2(-1.0,-1.0)),2.0);\n        \n        \n  \t}\n    //val /= float(blobs.length());\n    // Time varying pixel color\n    vec3 col = vec3(val*0.13 - 1.0, pow(val, 2.0)*0.002 - 0.2, 0.0 + val*0.02);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3BD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[60, 60, 117, 167, 1428]], "test": "valid"}
{"id": "ts3BDB", "name": "Caramel Goop", "author": "Poobslag", "description": "A goopy caramel texture which oozes and moves across the screen. A variation of my 'Oozing Rainbow' shader useful for some goopy monochrome frosting rendered in an isometric environment.", "tags": ["perlinnoise", "perlin", "animated", "goop", "ooze"], "likes": 2, "viewed": 57, "published": "Public", "date": "1605879998", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 base_color = vec3(0.922, 0.725, 0.569);\nvec3 bright_color = vec3(0.973, 0.898, 0.843);\n\nvec2 hash22(vec2 p)\n{\n    p = vec2( dot(p,vec2(127.1,311.7)),\n\t\t\t  dot(p,vec2(269.5,183.3)));\n  \n    return -1.0 + 2.0 * fract(sin(p)*43758.5453123);\n}\n\n\nfloat perlin_noise(vec2 p)\n{\n\tvec2 pi = floor(p);\n    vec2 pf = p-pi;\n    \n    vec2 w = pf*pf*(3.-2.*pf);\n    \n    float f00 = dot(hash22(pi+vec2(.0,.0)),pf-vec2(.0,.0));\n    float f01 = dot(hash22(pi+vec2(.0,1.)),pf-vec2(.0,1.));\n    float f10 = dot(hash22(pi+vec2(1.0,0.)),pf-vec2(1.0,0.));\n    float f11 = dot(hash22(pi+vec2(1.0,1.)),pf-vec2(1.0,1.));\n    \n    float xm1 = mix(f00,f10,w.x);\n    float xm2 = mix(f01,f11,w.x);\n    \n    return mix(xm1,xm2,w.y);\n}\n\n// Official HSV to RGB conversion \nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 uv2 = uv + perlin_noise(4.8 * vec2(uv.x + 38.913 + iTime * 0.01, uv.y + 81.975 + iTime * 0.01));\n    // Squash it vertically, so it looks OK in isometric\n    uv2 *= vec2(1.0, 2.0);\n    uv2 = uv2 + vec2(iTime * 0.05, 0.0);\n\n    // Time varying pixel color\n    float f = perlin_noise(0.3 * uv2);\n\n    // Output to screen\n    f = (f + iTime * .01) * 8.0;\n    f = f - floor(f);\n    \n    float mix_amount = smoothstep(0.25, 0.26, f);\n    mix_amount = min(mix_amount, 1.0 - smoothstep(0.45, 0.50, f));\n    \n    vec3 col2 = mix(base_color, bright_color, mix_amount);\n    \n    fragColor = vec4(col2, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3BDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[93, 93, 114, 114, 244], [247, 247, 275, 275, 710], [712, 747, 774, 774, 901], [903, 903, 960, 1010, 1659]], "test": "valid"}
{"id": "ts3BWn", "name": "Filtered normal of cosinus 2", "author": "SimonL", "description": "This shader show how to extract normal from a sum of cosine functions of different phase and frequency, and how to filter analytic normals to remove aliasing in order to do better lighting effect.", "tags": ["filter", "shading", "normal", "derivation", "cosinus", "filtered"], "likes": 11, "viewed": 138, "published": "Public", "date": "1604833274", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This shader use \n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Box-filtering of cos(x):\n//\n// (1/w)cos(t)dt with t  (x-w, x+w)\n// = [sin(x+w) - sin(x-w)]/w\n// = cos(x)sin(w)/(w)\n//\n// More example here made by Inigo Quilez:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n//\n//________________________________________\n//\n// This shader show how to extract normal from a sum of cosine functions of different phase and frequence,\n// and how to filter analytic normals to remove aliasing in order to do better lighting effect.  \n//\n// You can use your mouse to select which part of the canvas you want to see.\n// You can also modify the filtering coefficient FILTERING_COEF, to modify the intensity of filtering.\n// DEFORM can be set to 0, 1 or 2 to change the visuals.\n//\n// Top left \t: Shaded surface with analytic normal from non filtered cosinus functions.\n// Top right \t: Shaded surface with analytic normal from filtered cosinus functions. \n// Bottom left \t: Aliased surface generated with cosinus functions.\n// Bottom right : Anti-aliased surface generated with filtered cosinus functions.\n//\n// Related Shader:\n//  https://www.shadertoy.com/view/Wd3fDn\n//  https://www.shadertoy.com/view/ts3BWn\n//\n\n// 0, 1 or 2\n#define DEFORM 1\n\n// Filtering coefficient.\n// Define the box filtering size. \n#define FILTERING_COEF 1.\n\n// https://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec2 deform( in vec2 p )\n{\n    // deform 1\n    #if DEFORM >= 1\n    p *= 0.25;\n    p = 0.5*p/dot(p,p);\n    p.x += iTime*0.1;\n    \n    \n    // deform 2\n    #if DEFORM >= 2\n    p += 0.1*cos( 1.5*p.yx + 0.003*1.0*iTime + vec2(0.1,1.1) );\n    p += 0.1*cos( 2.4*p.yx + 0.003*1.6*iTime + vec2(4.5,2.6) );\n    p += 0.1*cos( 3.3*p.yx + 0.003*1.2*iTime + vec2(3.2,3.4) );\n    p += 0.1*cos( 4.2*p.yx + 0.003*1.7*iTime + vec2(1.8,5.2) );\n    p += 0.1*cos( 9.1*p.yx + 0.003*1.1*iTime + vec2(6.3,3.9) );\n    #endif\n    #endif\n    return p;\n}\n\n////////////////////////////////////////////////////////////\n// derivative of cos(u)\n//\n// cos(u) = cos(f*t+o)\n// cos'(u) = -f*sin(f*t+o)\nfloat dcos( float u,float f)\n{\n\treturn -f*sin(u);\n}\n\n/////////////////////////////////////////////////////////////\n// box-filted cos(x)\nfloat fcos( float u )\n{\n    float w = fwidth(u);\n    return cos(u) * sin(FILTERING_COEF*w)/(FILTERING_COEF*w);\n}\n\n\n//////////////////////////////////////////////////////////////\n// derivative of fcos(x)\n//\n// cos(u)*sin(c*w(u))/(c*w(u)) = cos(f*t+o)*sin(c*w(f*t+o))/(c*w(f*t+o))\n//\n// (cos(u)*sin(c*w(u))/(c*w(u)))' =\n//\n//\t( -f * sin(u) * sin(c*w(u)) + cos(u) * c * w'(u) * cos(c*w(u)) ) * c * w(u) - cos(u) * sin(c * w(u)) * c * w'(u)\n//\t________________________________________________________________________________________________________________\n//\t\t\t\t\t\t\t\t\t\t\t\t\t(c * w(u))^2\n//\n//\n// w'(u) assumed to be fwidth(w(u)).\n// c is the filtering coefficient.\nfloat dfcos( float u, float f)\n{\n    float w = fwidth(u);\n    float dw = fwidth(w);\n    \n    return ( (-f * sin(u) * sin(FILTERING_COEF*w) + cos(u) * FILTERING_COEF * dw * cos(FILTERING_COEF * w) ) * (FILTERING_COEF*w) - cos(u) * sin(FILTERING_COEF * w) * (FILTERING_COEF*dw) )/ pow(FILTERING_COEF*w,2.);\n}\n\n\n\nfloat getIntensityFiltered( in float t )\n{\n    float col = 0.4;\n    col += 0.14*fcos(t*  1.0+0.6);\n    col += 0.13*fcos(t*  3.1+1.0);\n    col += 0.12*fcos(t*  5.1+1.1);\n    col += 0.11*fcos(t*  9.1+1.2);\n    col += 0.10*fcos(t* 17.1+0.9);\n    col += 0.09*fcos(t* 31. +11.3);\n    col += 0.08*fcos(t* 65. +11.3);\n    col += 0.07*fcos(t*131. +10.8);\n    return col;\n}\n\nfloat getIntensityFilteredGrad( in float t )\n{\n    float col = 0.;\n    col += 0.14*dfcos(t*  1.0+ 0.6, 1.0);\n    col += 0.13*dfcos(t*  3.1+ 1.0, 3.1);\n    col += 0.12*dfcos(t*  5.1+ 1.1, 5.1);\n    col += 0.11*dfcos(t*  9.1+ 1.2, 9.1);\n    col += 0.10*dfcos(t* 17.1+ 0.9, 17.1);\n    col += 0.09*dfcos(t* 31. +11.3, 31.);\n    col += 0.08*dfcos(t* 65. +11.3, 65.);\n    col += 0.07*dfcos(t*131. +10.8,131.);\n    return col;\n}\n\nfloat getIntensity( in float t )\n{\n    float col = 0.4;\n    col += 0.14*cos(t*  1.0+0.6);\n    col += 0.13*cos(t*  3.1+1.0);\n    col += 0.12*cos(t*  5.1+1.1);\n    col += 0.11*cos(t*  9.1+1.2);\n    col += 0.10*cos(t* 17.1+0.9);\n    col += 0.09*cos(t* 31. +11.3);\n    col += 0.08*cos(t* 65. +11.3);\n    col += 0.07*cos(t*131. +10.8);\n    return col;\n}\n\nfloat getIntensityGrad( in float t )\n{\n    float col = 0.;\n    col += 0.14*dcos(t*  1.0+0.6 , 1.0);\n    col += 0.13*dcos(t*  3.1+1.0 , 3.1);\n    col += 0.12*dcos(t*  5.1+1.1 , 5.1);\n    col += 0.11*dcos(t*  9.1+1.2 , 9.1);\n    col += 0.10*dcos(t* 17.1+0.9 , 17.);\n    col += 0.09*dcos(t* 31. +11.3, 31.);\n    col += 0.08*dcos(t* 65. +11.3, 65.);\n    col += 0.07*dcos(t*131. +10.8,131.);\n    return col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // separation\n    float thx = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 1.2*sin(iTime);\n    float thy = (iMouse.z>0.001) ? (2.0*iMouse.y-iResolution.y)/iResolution.y : 1.2*(iResolution.y / iResolution.x)*cos(iTime);\n    bool light = (q.y>thy);\n    bool filt = (q.x>thx);\n    \n    // deformation\n    vec2 p = deform(q);\n    p*=6.2832;\n    \n    // light position\n    vec3 lp = normalize(vec3(cos(iTime),sin(iTime),0.2));\n    \n    vec3 col;\n    if(!light){ // original version by Inigo Quilez \n        float i;\n        if(filt){ // With filtering\n    \t\ti = min(getIntensityFiltered(p.x),getIntensityFiltered(p.y));\n        } else { // Without filtering\n    \t\ti = min(getIntensity(p.x),getIntensity(p.y));\n        }\n        col = pal( i, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n        \n    } else { // shaded version\n        float i1,i2,i;\n        vec3 normal;\n        \n        if(filt){ // With filtering\n            i1 = getIntensityFiltered(p.x);\n            i2 = getIntensityFiltered(p.y);\n            i = min(i1,i2);\n            \n            if(i == i1){\n            \tnormal.x = -getIntensityFilteredGrad(p.x);\n                normal.z = 1.;\n                normal.y = 0.;\n            } else {\n                normal.z = 1.;\n                normal.y = -getIntensityFilteredGrad(p.y);\n                normal.x = 0.;\n            }\n            \n        } else { // Without filtering\n           \ti1 = getIntensity(p.x);\n           \ti2 = getIntensity(p.y);\n           \ti = min(i1,i2);\n            \n            if(i == i1){\n            \tnormal.x = -getIntensityGrad(p.x);\n                normal.z = 1.;\n                normal.y = 0.;\n            } else {\n                normal.z = 1. ;\n                normal.y = -getIntensityGrad(p.y);\n                normal.x = 0.;\n            }\n        }\n \n        normal = normalize(normal);\n        \n        col = pal( i, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.10,0.20) );\n        col = col + max(dot(lp,normal),0.);\n        col *= 0.8;\n    }\n    \n\t\n    \n    // separation\n    col *= smoothstep(0.005,0.010,abs(q.x-thx));\n    col *= smoothstep(0.005,0.010,abs(q.y-thy));\n    \n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3BWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1459, 1524, 1592, 1592, 1635], [1637, 1637, 1663, 1679, 2164], [2166, 2304, 2334, 2334, 2355], [2357, 2440, 2463, 2463, 2552], [2555, 3099, 3131, 3131, 3405], [3409, 3409, 3451, 3451, 3773], [3775, 3775, 3821, 3821, 4196], [4198, 4198, 4232, 4232, 4546], [4548, 4548, 4586, 4586, 4952], [4956, 4956, 5012, 5031, 7326]], "test": "valid"}
{"id": "ts3Bzl", "name": "triangle tunnel", "author": "slackmage", "description": "triangle tunnel", "tags": ["tunnel"], "likes": 9, "viewed": 97, "published": "Public", "date": "1605747989", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926538\n#define SIN60 0.86602540378\n\nvec2 rotate2D(vec2 coordinates, float angle){\n    float sinA = sin(angle);\n    float cosA = cos(angle);\n    coordinates =  mat2(cosA,-sinA,\n      sinA,cosA) * coordinates;\n    return coordinates;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord/iResolution.xy;    \n    \n    uv *= 2.0;\n    uv -= 1.0;\n    uv.x /= iResolution.y / iResolution.x;\n    uv = rotate2D(uv, iTime * 0.45);\n    \n    float finalRed = 0.0;\n    \n    float finalWhite = 0.0;\n    for(float x = -1.; x <= 1.; x++)\n        for(float y = -1.; y <= 1.; y++)\n        {\n\t\t\tvec2 coordinates = uv + vec2(x, y) * 0.002;    \n\n            float sideA = dot(coordinates, vec2(SIN60, 0.5));\n            float sideB = dot(coordinates, vec2(-SIN60, 0.5));\n            float bottom = -coordinates.y;\n\n            float triangle = max(sideA, max(sideB, bottom));\n\n            float sinIncrement = 0.8;\n\t\t\tfloat fractalTriangle = fract(1.0 / triangle + iTime * 3.0 + sinIncrement);\n            float white = fract(1.0 / triangle + iTime * 3.0 + sinIncrement);\n            white = step(white, 0.1);\n            finalRed += step(triangle, 0.0995);\n            \n            float angle = atan(coordinates.x, coordinates.y) / PI;\n                        \n            for(float n = 1.0; n >= -1.0; n -= 0.2/3.0)\n                white += step(angle, n + 0.005) * (1.0 - step(angle, n - 0.005)) * 0.75;                \n                                    \n            white = clamp(white, 0., 1.);\n            float innerTriangleRed = step(triangle, 0.09);\n            float innerTriangleWhite = step(triangle, 0.098);\n            white -= innerTriangleWhite;\n            finalRed -= innerTriangleRed;\n            \n            white = clamp(white, 0.0, 1.0);\n            finalWhite += white;\n            \n        }\n   \n    finalRed /= 9.0;\n    finalWhite /= 9.0;\n    fragColor = vec4(vec3(finalWhite) + vec3(finalRed, 0.0, 0.0),1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3Bzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[53, 53, 98, 98, 250], [252, 252, 307, 307, 1965]], "test": "valid"}
{"id": "ts3fD2", "name": "Exemple orbit", "author": "xener", "description": "Testing stuff", "tags": ["raycast"], "likes": 3, "viewed": 65, "published": "Public", "date": "1606003691", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct Sphere\n{\n \tvec3 position;\n    vec3 couleur;\n    float taille;\n    bool lumiere;\n};\n\nconst int nombreDeSpheres = 8;\nSphere spheres[nombreDeSpheres];\n\nvoid Scene()\n{\n    spheres[0].position = vec3(2.0 * sin(iTime), 0, 2.0 * cos(iTime));\n    spheres[0].couleur = vec3(1.0, 1.0, 1.0);\n    spheres[0].taille = 0.5;\n\tspheres[0].lumiere = false;\n    \n    spheres[1].position = vec3(4.0 * cos(iTime*.5), 0, 4.0 * sin(iTime*.5));\n    spheres[1].couleur = vec3(1.0, 1.0, 1.0);\n    spheres[1].taille = 1.0;\n    spheres[1].lumiere = false;\n        \n    spheres[2].position = vec3(0.0, 0.0, 0.0);\n    spheres[2].couleur = vec3(1.0, 0.0, 0.0);\n    spheres[2].taille = 0.05;\n    spheres[2].lumiere = true;\n    \n    spheres[3].position = vec3(6.0 * cos(iTime * 0.8), 0, 6.0 * sin(iTime * 0.8));\n\tspheres[3].couleur = vec3(0.0, 1.0, 0.0);\n    spheres[3].taille = 0.05;\n    spheres[3].lumiere = true;\n    \n    spheres[4].position = vec3(7.0 * sin(iTime * 0.75), 0, 7.0 * cos(iTime * 0.75));\n\tspheres[4].couleur = vec3(0.0, 0.0, 1.0);\n    spheres[4].taille = 0.05;\n    spheres[4].lumiere = true;\n   \n    spheres[5].position = vec3(10.0 * cos(iTime*0.37), 0, 10.0 * sin(iTime*0.37));\n    spheres[5].couleur = vec3(1.0, 1.0, 1.0);\n    spheres[5].taille = 2.0;\n\tspheres[5].lumiere = false;\n   \n    spheres[6].position = vec3(20.0 * cos(iTime*0.57), 0, 20.0 * sin(iTime*0.57));\n    spheres[6].couleur = vec3(1.0, 1.0, 1.0);\n    spheres[6].taille = 3.0;\n\tspheres[6].lumiere = false;\n   \n    spheres[7].position = vec3(45.0 * sin(iTime*0.31), 0, 45.0 * cos(iTime*0.31));\n    spheres[7].couleur = vec3(1.0, 1.0, 1.0);\n    spheres[7].taille = 20.0;\n\tspheres[7].lumiere = false;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p) - s;\n}\n\nfloat Intersection(vec3 p, out Sphere sphere, out vec3 normal)\n{\n    float minDist = 1e10;\n    \n    for(int i = 0; i < nombreDeSpheres; ++i)\n    {\n        float dist = sdSphere(p - spheres[i].position, spheres[i].taille);\n        if(dist < minDist)\n        {\n            minDist = dist;\n            sphere = spheres[i];\n            normal = normalize(p - spheres[i].position);\n        }\n    }\n    \n    return minDist;\n}\n\nbool RayCast(vec3 ro, vec3 rd, out float t, out Sphere sphere, out vec3 normal)\n{\n    float tmin = 1.0;\n    float tmax = 200.0;\n    \n    t = tmin;\n    \n    for(int i = 0; i < 70 && t < tmax; ++i)\n    {\n        vec3 p = ro + rd * t;\n        float h = Intersection(p, sphere, normal);\n        \n        if(abs(h) < 0.0001 * t)\n        {\n            return true;\n        }\n        \n        t += h;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    Scene();\n    \n    // Coordonne du pixel  l'cran\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n\n    // Position de la camra\n    vec3 ro = vec3(0, 6, -12);\n    \n    // Cible de la camra\n    vec3 lookat = vec3(0, 0, 0);\n    \n    // Calcul de la camra\n    vec3 f = normalize(lookat - ro);\n    vec3 r = normalize(cross(vec3(0, 1, 0), f));\n    vec3 u = cross(f, r);\n        \n    vec3 c = ro + f;\n    vec3 i = c + uv.x * r + uv.y * u;\n    vec3 rd = normalize(i - ro);\n    \n    // Lanc de rayon\n    float t;\n    Sphere sphere;\n    vec3 normal;\n    \n    if(RayCast(ro, rd, t, sphere, normal))\n    {        \n        vec3 lumiereTotal = vec3(0);\n        vec3 position = ro + rd * t;\n\n        // Calcul de la lumire\n        for(int i = 0; i < nombreDeSpheres; ++i)\n        {\n            if(spheres[i].lumiere)\n            {\n                // Ombres\n            \tvec3 positionLumiere = spheres[i].position - position;\n                vec3 lightDir = normalize(positionLumiere);\n                                \n                float tOmbre;\n                Sphere sphereOmbre;\n                vec3 normalOmbre;\n                \n                if(RayCast(position, lightDir, tOmbre, sphereOmbre, normalOmbre) && sphereOmbre.lumiere)\n                {                    \n            \t\tfloat lightDist = length(positionLumiere);       \n                    float distAttenuation = (3.0 / lightDist);\n                    vec3 diffus = sphere.couleur * spheres[i].couleur * max(dot(normal, lightDir), 0.0);\n                    vec3 speculaire = spheres[i].couleur * pow(max(dot(-rd, reflect(-lightDir, normal)), 0.0), 200.0);\n                    lumiereTotal += (diffus + speculaire) * distAttenuation;\n                }\n            }\n        }\n                \n     \tvec3 couleur = mix(lumiereTotal, sphere.couleur, sphere.lumiere ? 1.0 : 0.0);\n        fragColor = vec4(couleur, 1.0);\n    }\n    else\n    {\n     \tfragColor = vec4(0);   \n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3fD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[156, 156, 170, 170, 1659], [1661, 1661, 1696, 1696, 1722], [1724, 1724, 1788, 1788, 2143], [2145, 2145, 2226, 2226, 2569], [2571, 2571, 2628, 2628, 4634]], "test": "valid"}
{"id": "ts3fD4", "name": "quasicrystal study", "author": "treize", "description": "quasicrystal \nI've used it as a reference.\nhttp://mainisusuallyafunction.blogspot.com/2011/10/quasicrystals-as-sums-of-waves-in-plane.html", "tags": ["2d", "quasicrystal"], "likes": 4, "viewed": 86, "published": "Public", "date": "1605246596", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void quasicrystal(vec2 UV,vec2 Scale,float Time,int num,out float Value,out float Value2,out float Line,out float Line2)\n{\n    vec2 p=UV*Scale;\n    float value=0.0;\n    float pi = acos(-1.);\n    for(int i=0;i<num;i++)\n    {\n    \tfloat angle = pi / float(num) * float(i);\n    \tfloat w = p.x * sin(angle) + p.y * cos(angle);\n\t\tvalue += sin(w + Time);\n    }\n    Value=value;\n    Value2=1.0+sin(value * pi / 2.0);\n    Line=mix(1.0, 0.0, smoothstep(value, 0.0, 0.15 ));\n    Line2=mix(1.0, 0.0, smoothstep(Value2, 0.0, 0.02 ));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   \tvec2 uv =  ( 2.*fragCoord - iResolution.xy ) / iResolution.y;\n    float  t = iTime * acos(-1.),value,value2,value3,value4;\n    quasicrystal(uv,vec2(18.0),t,7,value,value2,value3,value4);\n    fragColor = vec4(value2);\n    fragColor.b+=value4;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3fD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 122, 122, 523], [524, 524, 581, 581, 829]], "test": "valid"}
{"id": "ts3fDs", "name": "HOW THIS WORK?!", "author": "Timmons", "description": "IM SORRY JOE", "tags": ["ohgod"], "likes": 5, "viewed": 91, "published": "Public", "date": "1606252863", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//With AA (239 c)\n\nvoid mainImage( out vec4 c, vec2 o )\n{\n    vec2 r = iResolution.xy;\n    \n    o = vec2(length(o -= r/2.) / r.y - .3, atan(o.y,o.x));    \n    \n    vec4 s =  .1*cos(1.6*vec4(0,1,2,3) + iTime + o.y + sin(o.y) * sin(iTime)*2.);\n    \n    //c.yzwx = s;\n    c.yzwx = s;\n    \n    vec4 f = min(o.x-s, c-o.x);\n    \n    \n    c = f*100.0;//dot(40.*(s-c), clamp(f*r.y, 0., 1.)) * (s-.1) - f;\n   \n \t\n    //c = s;   \n}\n\n\n//No AA (233c)\n/*\nvoid mainImage( out vec4 c, vec2 o )\n{\n    vec2 r = iResolution.xy;\n    o = vec2(length(o -= r/2.) / r.y - .3, atan(o.y,o.x));    \n    vec4 s = c.yzwx = .1*cos(1.6*vec4(0,1,2,3) + iTime + o.y + sin(o.y) * sin(iTime)*2.);\n    c = dot(40.*(s-c), step(1./r.y, c = min(o.x-s,c-o.x))) * (s-.1) - c;\n}\n*/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3fDs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[19, 19, 57, 57, 421]], "test": "valid"}
{"id": "ts3fzl", "name": "aoeuaoeu ", "author": "HaleyHalcyon", "description": "is this a breathing exercise? i dunno", "tags": ["aoeu"], "likes": 2, "viewed": 284, "published": "Public", "date": "1605752689", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float woosh(float x) {\n    return x * x * x * (x * (x * 6. - 15.) + 10.); // \"better smoothstep\" from wikipedia\n}\n\nfloat smoothfold(float x) {\n    return woosh(abs(fract(x) - 0.5) * 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    float loopLength = 4.0;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord - 0.5 * (iResolution.xy);\n    float t = fract(iTime / loopLength);\n\n    // Time varying pixel color\n    float dist = log(dot(uv, uv));\n    float angle = atan(uv.y, uv.x) / 6.28318530718;\n    float v = dist*(smoothfold(t) + 1.0) + 2.0 * angle + 5.0 * smoothfold(t + 0.05 * dist);\n    vec3 col = vec3(smoothfold(v), smoothfold(v+0.15), smoothfold(v+0.3));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3fzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 113], [115, 115, 142, 142, 189], [191, 191, 248, 248, 767]], "test": "valid"}
{"id": "ts3fzN", "name": "test grid uv", "author": "jcyuan", "description": "test effect", "tags": ["fract"], "likes": 14, "viewed": 321, "published": "Public API", "date": "1604483168", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define GRID 8.\n#define STRIPS 6.\n#define SPEED 5.\n#define ANTI 3.\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord * 2. - iResolution.xy) / iResolution.y;\n    vec2 ouv = uv;\n    uv = fract(uv * GRID);\n    ouv = floor(ouv * GRID) / GRID;\n\n    float r = length(uv - .5) + .5;\n    vec3 col = vec3(0.);\n\n    float d = sin(STRIPS * atan(ouv.y, ouv.x) - SPEED * iTime);\n    d = (d + 1.) * .5;\n\n    float aw = ANTI * GRID / iResolution.y * .5;\n    vec3 stripColor = smoothstep(r - aw, r + aw, 1. - d) * vec3(1., .0, .0);\n    vec3 restColor = smoothstep(r - aw, r + aw, d) * vec3(1.);\n\n    col += mix(stripColor, restColor, d);\n    \n    fragColor = vec4(pow(col, vec3(.454545)), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ts3fzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 68, 123, 123, 711]], "test": "valid"}
{"id": "tscBDH", "name": "Logarithmic Spiral Center", "author": "tdhooper", "description": "Finding the center of a spiral formed by recursively applying a TRS matrix", "tags": ["spiral", "logarithmic"], "likes": 16, "viewed": 475, "published": "Public API", "date": "1604963428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n\n    Logarithmic Spiral Center\n    -------------------------\n\n\tThis finds your final position when recursively applying a\n\ttranslation rotation scale matrix, but without doing the\n    actual recursion.\n\n\tSee also the 3d version:\n\thttps://www.shadertoy.com/view/wslyzH\n\n\n\tMETHOD:\n\n\tIt looks at the triangle formed by the first two points and\n\tthe center of the spiral, then calculates the center from known\n\tside and angle relations...\n\n\n\n               4---3\n              /     \\\n             5  x    \\\n              \\_/     2\n                     /\n                    /  \n                   /   \n        0---------1 \n\n\n    triangles formed by first three points and the spiral center:       \n\n\n                x_    \n               /| ```-2\n             /` |    /\n           /`    |  /  \n         /`      | /   \n        0---------1 \n\n\n    note that the segment angle is the same as the iteration rotation:\n\n\n                x_    \n               /| ```-2\n             /`y|    /\n           /`    |  /  \n         /`      | /y \n        0---------1 - - - -\n\n\n\tand that the adjacent sides are related by the iteration scale (s):\n\n\n                x     \n               /|\n          a  /`y| b\n           /`    |\n         /`      | \n        0---------1\n\t\t\t c\n\n\t\tb = a * s\n\n\n    side c is given by law of cosines:\n\n    \tc = sqrt(a^2 + b^2 - 2 * a * b * cos(y))\n\n\n   \tsubstituting a * s for b:\n\n\t\tc = sqrt(a^2 + (a * s)^2 - 2 * a * (a * s) * cos(y))\n\n\n    solve for a:\n    https://www.wolframalpha.com/widgets/view.jsp?id=c778a2d8bf30ef1d3c2d6bc5696defad\n\t\n\t\ta = c / sqrt(s^2 - 2 * s * cos(y) + 1)\n\n\n\tand get b:\n\t\n\t\tb = a * s;\n\n\n    find opposite angle to side b using sine law:\n\n                x     \n               /|\n          a  /`y| b\n           /`    |\n         /`k     | \n        0---------1\n\t\t\t c\n\n        k = a * sin(b * sin(y) / c);\n\n\n\tfind center using side a and angle k...\n\t\n\n*/\n\nvec2 spiralCenter(vec2 translation, float rotation, float scale) {\n\t// find sides and angles of segment triangle\n    float c = length(translation);\n\tfloat a = c / sqrt((scale * scale) - 2. * scale * cos(rotation) + 1.);\n\tfloat b = a * scale;\n\tfloat k = asin(b * sin(-rotation) / c);\n    // add angle from translation and calculate center\n    k += atan(translation.x, translation.y);\n    vec2 center = vec2(sin(k), cos(k)) * a;\n  \treturn center;\n}\n\n\n// shortened version from FabriceNeyret2\n// https://www.shadertoy.com/view/WdVczz\n// I'd like to explain this, but I don't know the steps taken\nvec2 spiralCenter2(vec2 translation, float rotation, float scale) { \n    float l = sqrt(scale * scale - 2. * scale * cos(rotation) + 1.);\n    float S = sin(rotation) * scale / l;\n    float C = sqrt(1. - S * S);\n    return mat2(-S, C, C, S) * translation.yx / l;\n}\n\n\n\n// Matrix functions\n// --------------------------------------------------------\n\nmat3 translateM(vec2 t) {\n\treturn mat3(1, 0, t.x, 0, 1, t.y, 0, 0, 1);\n}\n\nmat3 rotateM(float a) {\n\treturn mat3(cos(a), -sin(a), 0, sin(a), cos(a), 0, 0, 0, 1);\n}\n\nmat3 scaleM(vec2 s) {\n\treturn mat3(s.x, 0, 0, 0, s.y, 0, 0, 0, 1);\n}\n\nmat3 trsMatrix(vec2 translation, float rotation, float scale) {\n\treturn scaleM(vec2(scale)) * rotateM(rotation) * translateM(translation);\n}\n\nvec2 mul(vec2 p, mat3 m) {\n   return (vec3(p, 1) * m).xy;\n}\n\n\n\n// Drawing\n// --------------------------------------------------------\n\nvec3 col;\n\nvoid draw(float d, vec4 c) {\n    d /= fwidth(d);\n    d = clamp(d, 0., 1.);\n    d = 1. - d;\n    d *= c.a;\n    col = mix(col, c.rgb, d);\n}\n\nvoid draw(float d, vec3 c) {\n\tdraw(d, vec4(c, 1));\n}\n\nfloat line(vec2 p, vec2 a, vec2 b) {\n    vec2 pa = p-a, ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h );\n}\n\n\n\n// Demo\n// --------------------------------------------------------\n\n#define PI 3.1415926\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (-iResolution.xy + 2.*fragCoord)/iResolution.y;\n\n    p -= vec2(-1,0);\n    \n    col = vec3(.014,.01,.02);\n    \n    float beat = sin(iTime) * .5 + .5;\n    float beat2 = sin(iTime / 2.) * .5 + .5;\n    \n    \n    // Translation, rotation, scale for each iteration\n    \n    float a = mix(PI / 2., -PI / 2., beat) * (beat2) + PI / 2.;\n  \tvec2 trs = vec2(sin(a), cos(a)) * mix(.75, .4, beat2);\n    float rot = mix(1., -1., beat);\n    float scl = mix(.5, .99, beat2);\n    \n    if (iMouse.z > 0.) {\n    \tvec2 m = (-iResolution.xy + 2.*iMouse.xy)/iResolution.y;\n    \tm -= vec2(-1,0);\n        trs = vec2(.5,0);\n        vec2 pt = m - trs;\n        rot = atan(pt.y, pt.x);\n        scl = length(pt) / length(trs);\n    }\n\n    \n    // Calculate center\n    \n    vec2 center = spiralCenter(trs, rot, scl);    \n\n    \n    // Draw spiral\n    \n    mat3 mat = trsMatrix(trs, rot, scl);\n    mat3 compound = mat;   \n    vec2 pt = vec2(0);\n    vec2 lastPt = pt;\n    \n    int n = 20;\n    for (int i = 0; i < n; i++) {\n        \n        float t = float(i) / float(n);\n        t = pow(t, .5);\n        float fade = smoothstep(1., .75, t);\n\n        draw(line(p, center, pt) - .0025, vec4(1, 1, 1, .1 * fade));\n        draw(length(p - pt) - .015, vec4(0,.33,.33, fade));\n        draw(line(p, lastPt, pt) - .01, vec4(0,.33,.33, .2 * fade));\n        \n        lastPt = pt;\n        pt = mul(vec2(0), compound);\n        compound = mat * compound;\n    }\n    \n    \n    // Draw center\n\n    draw(length(p - center) - .03, vec3(1));\t\n    \n    \n    col = pow(col, vec3(1./2.2));\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1891, 1891, 1957, 2003, 2337], [2340, 2484, 2551, 2551, 2747], [2832, 2832, 2857, 2857, 2904], [2906, 2906, 2929, 2929, 2993], [2995, 2995, 3016, 3016, 3063], [3065, 3065, 3128, 3128, 3205], [3207, 3207, 3233, 3233, 3266], [3353, 3353, 3381, 3381, 3489], [3491, 3491, 3519, 3519, 3543], [3545, 3545, 3581, 3581, 3700], [3795, 3795, 3852, 3852, 5428]], "test": "valid"}
{"id": "tscBDl", "name": "Simple raymarched terrain", "author": "me_123", "description": "I tried to make a mountainy land generator using noise, i did not make textures for it, but i think that it turned out kinda cool. also i used the same raymarcher as the tree shader i made (https://www.shadertoy.com/view/3dtBDf). ", "tags": ["raymarching"], "likes": 1, "viewed": 95, "published": "Public", "date": "1606238012", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float max_steps = 500.;\nfloat max_dist = 1000.;\nfloat e = 1e-3;\nfloat camSize = 5.;\nvec3 lightPos = vec3(10., 10, 00.);\nfloat samples = 1.;\nfloat cyl( vec3 p, float h, float r )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(h,r);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat cc( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot(k2, k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot(ca, ca),dot(cb, cb)) );\n}\nfloat mandel(vec3 p) {\n    vec3 z = p;\n    float dr = 1.;\n    float r = 0.0;\n    float power = 3.;\n    for (int i = 0; i < 100; i ++) {\n        r = length(z);\n        if (r > 2.0) {\n            break;\n        }\n        float thata = acos(z.z/r) * power;\n        float phi = atan(z.y, z.x) * power;\n        float zr = pow(r, power);\n        dr = pow(r, power-1.) * power * dr + 1.;\n        z = zr * vec3(sin(thata) * cos(phi), sin(phi) * sin(thata), cos(thata));\n    \tz += p;\n    }\n    return 0.5 * log(r) * r / dr;\n}\n\nvec3 rep( in vec3 p, in float c, in vec3 l)\n{\n    vec3 q = p-c*clamp(round(p/c),-l,l);\n    return q;\n}\n\nvec4 uni(vec4 a, vec4 b) {\n\treturn a.w < b.w? a : b;\n}\nvec4 difr(vec4 a, vec4 b) {\n\treturn a.w > b.w? a : b;\n}\nvec4 suni(vec4 a, vec4 b, float k) {\n\tfloat h = clamp( 0.5 + 0.5*(a.w-b.w)/k, 0.0, 1.0 );\n    vec3 c = mix(a.rgb, b.rgb, h);\n    float d = mix( a.w, b.w, h) - k*h*(1.-h); \n    return vec4(c, d);\n}\n\nfloat smax( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); \n}\n\nfloat smin( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nmat2 rot(float a) {\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\nfloat tor( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat hash(vec2 p) {\n    p = 50.*fract(p*0.3183099);\n    return fract(p.x*p.y*(p.x+p.y));\n}\n\nvec3 mushromStep(vec3 p) {\n    float val = clamp(abs(dot(sin(p*5.), sin(p*2.1)))/2., 0.3, 0.4);\n    return vec3(val/1., val/2., 0.0);\n}\nfloat n(vec3 p) {\n    float ou = sin(p.x/3.);\n    ou += sin(p.z/2.);\n\treturn ou/10.;\n}\nfloat noise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( hash( i + vec2(0.0,0.0) ), \n                     hash( i + vec2(1.0,0.0) ), u.x),\n                mix( hash( i + vec2(0.0,1.0) ), \n                     hash( i + vec2(1.0,1.0) ), u.x), u.y);\n}\nfloat terrain(vec2 p) {\n    float gs = 10000.;\n    p = floor(p*gs)/gs;\n    float scale = 0.5;\n    float f  = 2.*noise( p*scale );\n          f  += (2.000)*noise( ((p*scale)*2.) + 100.0);\n          f  += (1.000)*noise( ((p*scale)*4.) + 1000.0);\n          f  += (0.500)*noise( ((p*scale)*16.) + 10000.0);\n          f  += (0.250)*noise( ((p*scale)*32.) + 10000.0);\n          f  += (0.125)*noise( ((p*scale)*64.) + 10000.0);\n          f  += (0.0625)*noise( ((p*scale)*300.) + 100000.0);\n    f *= (1.0)*noise( ((p*scale)*0.2) + 24233.);\n    f *= ((1.0)*noise( ((p*scale)*0.1) + 34541.)+1.);\n    return f;\n}\nvec4 SDF(vec3 p) {\n    vec3 np = p;\n //   p = rep(p, 20., vec3(10., 0.0, 10.));\n //   vec3 pp = rep(p, 1., vec3(100));\n //   float disp = min(sphere(pp, 1.0), box(pp, vec3(1.)))+length(sin(p*5.)/3.);\n //   float shape1 = p.y-n(p);\n //   vec4 shape2 = vec4(mushromStep(p), mix(cyl(p, 0.3, 7.)-0.5, disp, 0.1));\n //   float c = cc(rep(p-vec3(0, 4, 0), 2.0, vec3(0, 1.0, 0)), 1.0, 4.0, 2.5);\n //   vec4 shape3 = vec4(vec3(0, 1, 0), c);\n //   vec4 shape4 = vec4(vec3(0, 1.0, 0.0), cc((p-vec3(0, 9.5, 0)), 2.0, 3.0, 0.0));\n    //vec4 o = suni(suni(suni(shape2, shape3, 2.0), shape4, 1.0), vec4(vec3(noise(np.xz/7.)), mix(p.y,disp, 0.1)+7.), 1.0);\n    float bb = (noise(p.xz*100.)+3.)/9.;\n    vec3 color = vec3(0.4, 0.4, 0.6);\n    if (p.y < (bb+0.7)/0.7) {\n\t    color = vec3(0.5);\n    }\n    if (p.y < (bb+0.7)/1.2) {\n\t    color = vec3(0.25);\n    }\n    if (p.y < (bb+0.7)/1.7) {\n    \tcolor = vec3(0.1, 0.1, 0.1);\n    }\n    if (p.y < (bb+0.7)/2.5) {\n    \tcolor = vec3(0.2, 0.5, 0.2);\n    }\n    if (p.y < 0.2) {\n    \tcolor = vec3(0.2, 0.2, 0.5);\n    }\n    vec4 o = vec4(color, (p.y-terrain(p.xz)/2.));\n    return o;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, in float k )\n{\n    float res = 1.0;\n    float t = 0.0;\n    for( int i=0; i<64; i++ )\n    {\n        vec4 kk;\n        float h = SDF(ro + rd*t).w/64.;\n        res = min( res, k*h/t );\n        if( res<0.001 ) break;\n        t += clamp( h, 0.01, 0.2 );\n    }\n    return clamp( res, 0.0, 1.0 );\n}\nvec2 getDist(vec3 ro, vec3 rd, out vec3 color) {\n    float d0 = 0.01;\n    vec3 roo = ro;\n    vec3 rdd = rd;\n    float steps = 0.0; \n    vec3 c = vec3(1);\n    for (float i = 0.0; i < max_steps; i += 1.0) {\n        steps += 1.0;\n        vec3 p = roo + rdd*d0;\n        vec4 r = SDF(p);\n        float ds = r.w;\n        d0 += ds;\n        if (ds<e||ds>max_dist) {\n       \t\tc = r.xyz;\n            break;\n        };\n    }\n    color = c;\n    return vec2(d0, steps);\n}\nvec3 getNormal(vec3 p) {\n    float d = SDF(p).w;\n    vec2 e = vec2(.000001, 0);\n    vec3 n = d-vec3(\n    \tSDF(p-e.xyy).w,\n    \tSDF(p-e.yxy).w,\n    \tSDF(p-e.yyx).w\n    );\n    return normalize(n);\n}\n\nvec3 getLight(vec3 p, vec3 lightPos, vec3 rd, vec3 ro, vec2 ray, vec3 color) {\n    vec3 lp = normalize(lightPos-p);\n    vec3 norm = getNormal(p);\n    float sha1 = softshadow( p+0.001*norm, lightPos, 2.0 );\n    float l = length(p-lightPos)-1.0;\n    float dif = dot(norm, lp)/clamp(l/1., 1., 100.0)*6.;\n    float reflected = clamp(float((dot(reflect(rd, norm), lightPos)) - 10.0), 0.0, 1.0);\n    dif = (dif+(reflected/(l/0.5)));\n    if (ray.x < max_dist) {\n        dif -= clamp(min(ray.y/255., 0.5), 0.0, 0.25);\n        dif += 0.4;\n    }\n    dif /= 0.5;\n    return (reflected/10. + color+clamp(ray.y/40., 0.0, 0.3))*vec3(clamp(dif, 0.0, 1.0))*vec3(2.0, 2.0, 2.0);\n}\nvec3 at = vec3(10, 00, 10);\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 col = vec3(0);\n    vec2 mouse = ((iMouse.xy-.5*iResolution.xy)/iResolution.xy)*5.;\n    mouse.x *= iResolution.x/iResolution.y;\n    float r = noise(vec2(iTime/5.))*5.;\n    float r1 = noise(vec2((iTime+100.)/5.))*5.;\n    at.xz = at.xz + abs(vec2(r, r1));\n    vec3 ro = vec3(at.x-10., 3., at.y-10.);\n    for (int i = 0; i < int(samples); i += 1) {\n        vec2 uv = ((fragCoord-.5*iResolution.xy)/iResolution.xy);\n        uv.x *= iResolution.x/iResolution.y;\n        vec3 c_z = normalize(at-ro);\n        vec3 c_x = normalize(cross(vec3(0,1,0), c_z));\n        vec3 c_y = cross(c_z, c_x);\n        uv.x += (hash(uv+float(i))-0.5)/(iResolution.y/2.);\n        uv.y += (hash(uv+1.+float(i))-0.5)/(iResolution.x/2.);\n        vec3 rd = normalize(uv.x * c_x + uv.y * c_y + 1.73 * c_z);\n        vec3 color = vec3(0);\n        vec2 ray = getDist(ro, rd, color);\n        float dist = ray.x;\n        vec3 p = ro+rd*dist;\n        vec3 light = getLight(p, lightPos, rd, ro, ray, color);\n        vec3 ocol = (light);\n        if (dist < max_dist) {\n        \tocol += sqrt(ocol)/5.;\n            ocol /= 1.25+clamp(ray.y/30., 0.1, 5.0);\n        } else {\n        }\n        float val = abs(clamp(rd.y, 0.1, 1.0)+1.0)*0.9;\n        ocol = mix(ocol, vec3(val/1.5, val/1.5, val), clamp(dist/40., 0.0, 1.0));\n        col += ocol;//ray.y/100.;//ocol;//ocol;\n    }\n    fragColor = vec4(col/samples,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscBDl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[140, 140, 179, 179, 286], [287, 287, 336, 336, 658], [659, 659, 681, 681, 1175], [1177, 1177, 1222, 1222, 1279], [1281, 1281, 1307, 1307, 1335], [1336, 1336, 1363, 1363, 1391], [1392, 1392, 1428, 1428, 1588], [1590, 1590, 1633, 1633, 1733], [1735, 1735, 1778, 1778, 1878], [1880, 1880, 1899, 1899, 1969], [1970, 1970, 1999, 1999, 2064], [2065, 2065, 2098, 2098, 2122], [2123, 2123, 2152, 2152, 2239], [2240, 2240, 2260, 2260, 2331], [2333, 2333, 2359, 2359, 2468], [2469, 2469, 2486, 2486, 2555], [2556, 2556, 2582, 2582, 2876], [2877, 2877, 2900, 2900, 3477], [3478, 3478, 3496, 3496, 4586], [4587, 4587, 4643, 4643, 4919], [4920, 4920, 4968, 4968, 5378], [5379, 5379, 5403, 5403, 5575], [5577, 5577, 5655, 5655, 6240], [6269, 6269, 6326, 6326, 7708]], "test": "valid"}
{"id": "tscBRX", "name": "hoeled_red", "author": "hoeled", "description": "Base code from https://www.youtube.com/watch?v=2R7h76GoIJM (Truchet effect)\n", "tags": ["2d"], "likes": 1, "viewed": 45, "published": "Public", "date": "1605649350", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash21(vec2 p) {\n\tp = fract(p*vec2(234.34, 435.34));\n    p += dot(p, p+34.23);\n    return fract(p.x*p.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 UV = fragCoord.xy/iResolution.xy;\n    vec3 col = vec3(0);\n    \n    //uv += iTime*.1;\n    uv *= 3.;\n    \n    vec2 gv = fract(uv)-.5;\n    vec2 id = floor(uv);\n    //if (gv.x>.01 || gv.y>.01) col = vec3(.1,0,0); // fract border\n    float n = Hash21(id); // random number 0 -> 1\n    \n    //float width = .4*abs(UV.y-.5)+0.01;\n    float width = .8;\n    \n    if (n<.5) gv.x *= -1.;\n    \n    float d = abs(abs(gv.x+gv.y)-.5);\n    \n    vec2 cUv = gv-sign(gv.x+gv.y+.0001)*.5;\n    d = length(cUv);\n    float mask = smoothstep(.01, -.01, abs(d-.5)-width);\n    \n    float checker = mod(id.x+id.y, 2.)*2.-1.;\n    float angle = atan(cUv.x, cUv.y); // -pi to pi\n   \n    float ch = ((sin(iTime))+1.)/2.;\n    float flow = sin(iTime+checker*angle*4.);\n    \n    float x = (angle/3.);\n    float y = (d-(.5-width))/(2.*width);\n    y = abs(y-.5)*2.;\n    \n    vec2 tUv = vec2(x, y);\n    //col.rg += tUv*mask;\n    \n    col += abs(flow*mask+tUv.x*sin(iTime));\n    col.b *= checker*.5;\n    col.r -= checker*.05;\n    col.g = .07;\n    //col.b = .0;\n    \n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 113], [115, 115, 172, 172, 1298]], "test": "valid"}
{"id": "tscBz8", "name": "Smooth Union Inclusive of Colors", "author": "oneshade", "description": "An experiment with blending colors alongside SDFs. I solved the shading issue. It had to do with the colors not being clamped (the pow function was the culprit).", "tags": ["raymarching", "colors", "smoothunion"], "likes": 37, "viewed": 342, "published": "Public", "date": "1604331776", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nThis shader uses my Raymarcher Template shader (https://www.shadertoy.com/view/3styDs).\n\nI've replaced the sdCuboid() and sdCylinder() distance functions with the exact ones\nfrom Inigo Quilez's 3D distance functions article (https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm)\nfor nicer blending.\n*/\n\n// Default (background) color:\nvec3 backgroundColor = vec3(0.0, 0.0, 0.0);\n\n// Light variables:\nvec3 lightDirection = vec3(-0.58, 0.58, 0.58);\nvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n// Camera variables:\nvec3 cameraPosition = vec3(0.0, 0.0, 1000.0);\nvec3 cameraRight = vec3(1.0, 0.0, 0.0);\nvec3 cameraUp = vec3(0.0, 1.0, 0.0);\nvec3 cameraForward = vec3(0.0, 0.0, -1.0);\nfloat cameraFocalLength = 400.0;\n\n// Ray marching constants:\nconst vec3 GRADIENT_STEP = vec3(0.001, 0.0, 0.0);\nconst float MAX_TRACE_DISTANCE = 2000.0;\nconst float MIN_HIT_DISTANCE = 0.001;\nconst int MAX_STEPS = 500;\n\n// Raymarching structures:\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n\nstruct Surface {\n    vec3 ambientColor;\n    vec3 diffuseColor;\n    vec3 specularColor;\n    float shininess;\n    float signedDistance;\n};\n\n// Signed Distance Functions (SDFs):\nfloat sdCuboid(in vec3 p, in float h, in float w, in float d) {\n    vec3 q = abs(p) - 0.5 * vec3(w, h, d);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\nfloat sdCylinder(in vec3 p, in float h, in float r) {\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, 0.5 * h);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\nfloat sdSphere(in vec3 p, in float r) {\n    return length(p) - r;\n}\n\n// Constructive Solid Geometry (CSG) Operators:\nSurface SmoothUnion(in Surface surface1, in Surface surface2, in float smoothness) {\n    float interpolation = clamp(0.5 + 0.5 * (surface2.signedDistance - surface1.signedDistance) / smoothness, 0.0, 1.0);\n    return Surface(mix(surface2.ambientColor, surface1.ambientColor, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.diffuseColor, surface1.diffuseColor, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.specularColor, surface1.specularColor, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.shininess, surface1.shininess, interpolation),// - smoothness * interpolation * (1.0 - interpolation);\n                   mix(surface2.signedDistance, surface1.signedDistance, interpolation) - smoothness * interpolation * (1.0 - interpolation));\n}\n\n// Transformations:\nvec3 Translate(in vec3 p, in vec3 t) {\n    return p - t;\n}\n\nvec3 Rotate(in vec3 p, in vec3 r) {\n    vec3 rad = radians(-r);\n    vec3 cosRad = cos(rad);\n    vec3 sinRad = sin(rad);\n\n    mat3 xRotation = mat3(1.0,      0.0,       0.0,\n                          0.0, cosRad.x, -sinRad.x,\n                          0.0, sinRad.x,  cosRad.x);\n\n    mat3 yRotation = mat3( cosRad.y, 0.0, sinRad.y,\n                                0.0, 1.0,      0.0,\n                          -sinRad.y, 0.0, cosRad.y);\n\n    mat3 zRotation = mat3(cosRad.z, -sinRad.z, 0.0,\n                          sinRad.z,  cosRad.z, 0.0,\n                               0.0,       0.0, 1.0);\n\n    return zRotation * yRotation * xRotation * p;\n}\n\n// Scene mapping function:\nSurface mapScene(in vec3 p) {\n    vec4 metashapeInfo1 = vec4(vec2(sin(iTime * 0.75), cos(iTime * 1.0)) * 200.0, 0.0, 80.0);\n    vec4 metashapeInfo2 = vec4(vec2(cos(iTime * 1.0), cos(iTime * 1.25)) * 200.0, 0.0, 100.0);\n    vec4 metashapeInfo3 = vec4(vec2(sin(iTime * 1.25), cos(iTime * 0.5)) * 200.0, 0.0, 120.0);\n\n    Surface metashape1 = Surface(vec3(0.0, 0.0, 0.0),\n                                 vec3(1.0, 0.0, 0.0),\n                                 vec3(1.0, 1.0, 1.0), 8.0,\n                                 sdCuboid(Rotate(Translate(p, metashapeInfo1.xyz), vec3(0.0, 0.0, iTime * 40.0)), 2.0 * metashapeInfo1.w, 2.0 * metashapeInfo1.w, 2.0 * metashapeInfo1.w) - 10.0);\n\n    Surface metashape2 = Surface(vec3(0.0, 0.0, 0.0),\n                                 vec3(0.0, 1.0, 0.0),\n                                 vec3(1.0, 1.0, 1.0), 64.0,\n                                 sdCylinder(Rotate(Translate(p, metashapeInfo2.xyz), vec3(0.0, 0.0, iTime * -20.0)), 2.0 * metashapeInfo2.w, metashapeInfo2.w) - 10.0);\n\n    Surface metashape3 = Surface(vec3(0.0, 0.0, 0.0),\n                                 vec3(0.0, 0.0, 1.0),\n                                 vec3(0.0, 0.0, 0.0), 0.0,\n                                 sdSphere(Translate(p, metashapeInfo3.xyz), metashapeInfo3.w));\n\n    return SmoothUnion(metashape1, SmoothUnion(metashape2, metashape3, 70.0), 70.0);\n}\n\n// Normal calculation function (using gradient):\nvec3 calculateNormal(in vec3 p) {\n    float gradientX = mapScene(p + GRADIENT_STEP.xyy).signedDistance - mapScene(p - GRADIENT_STEP.xyy).signedDistance;\n    float gradientY = mapScene(p + GRADIENT_STEP.yxy).signedDistance - mapScene(p - GRADIENT_STEP.yxy).signedDistance;\n    float gradientZ = mapScene(p + GRADIENT_STEP.yyx).signedDistance - mapScene(p - GRADIENT_STEP.yyx).signedDistance;\n    return normalize(vec3(gradientX, gradientY, gradientZ));\n}\n\n// Surface shader (uses the Phong illumination model):\nvec3 shadeSurface(in Surface surface, in Ray ray, in vec3 normal) {\n    vec3 illuminationAmbient = surface.ambientColor * lightColor;\n    float lambertian = max(0.0, dot(normal, lightDirection));\n    vec3 illuminationDiffuse = lambertian * surface.diffuseColor * lightColor;\n    vec3 reflection = reflect(lightDirection, normal);\n    float specularAngle = max(0.0, dot(reflection, ray.direction));\n    vec3 illuminationSpecular = clamp(pow(specularAngle, surface.shininess), 0.0, 1.0) * surface.specularColor * lightColor;\n    return illuminationAmbient + illuminationDiffuse + illuminationSpecular;\n}\n\n// Raymarching loop:\nvec4 rayMarch(in Ray ray) {\n    float distanceTraveled = 0.0;\n    for (int iterations=0; iterations < MAX_STEPS; ++iterations) {\n        vec3 currentPosition = ray.origin + ray.direction * distanceTraveled;\n        Surface sceneSurface = mapScene(currentPosition);\n        if (abs(sceneSurface.signedDistance) < MIN_HIT_DISTANCE) {\n            vec3 normal = calculateNormal(currentPosition);\n            vec3 color = shadeSurface(sceneSurface, ray, normal);\n            return vec4(color, 1.0);\n        }\n\n        if (distanceTraveled > MAX_TRACE_DISTANCE) {\n            break;\n        }\n\n        distanceTraveled += sceneSurface.signedDistance;\n    }\n\n    return vec4(backgroundColor, 1.0);\n}\n\n// Pixel shader output function:\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 halfResolution = 0.5 * iResolution.xy;\n    vec2 xy = fragCoord - halfResolution;\n    vec3 rayOrigin = cameraPosition + cameraForward * cameraFocalLength;\n    vec3 rayDirection = normalize(rayOrigin - (cameraPosition - cameraRight * xy.x - cameraUp * xy.y));\n    fragColor = rayMarch(Ray(rayOrigin, rayDirection));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1132, 1169, 1232, 1232, 1345], [1347, 1347, 1400, 1400, 1522], [1524, 1524, 1563, 1563, 1591], [1593, 1641, 1725, 1725, 2551], [2553, 2573, 2611, 2611, 2631], [2633, 2633, 2668, 2668, 3279], [3281, 3308, 3337, 3337, 4673], [4675, 4724, 4757, 4757, 5177], [5179, 5234, 5301, 5301, 5835], [5837, 5858, 5885, 5885, 6551], [6553, 6586, 6641, 6641, 6966]], "test": "valid"}
{"id": "tscfRl", "name": "disco balls maybe", "author": "slackmage", "description": "disco balls maybe", "tags": ["sphere"], "likes": 2, "viewed": 71, "published": "Public", "date": "1605747757", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float remap01(float a, float b, float t)\n{\n\treturn (t-a)/(b-a);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\n\tvec3 col = vec3(0);\n    \n    \n    vec3 ro = vec3(sin(0.623 + iTime * 0.31) / 0.9, \n                   cos(0.723 + iTime * 0.21) / 0.9, \n                   sin(iTime) / 0.9);\n    //ro = vec3(0);\n    vec3 rd = normalize(vec3(uv.x + sin(0.346 + iTime * 1.0) *0.2, \n                             uv.y + cos(0.213 + iTime * 1.0) *0.2, \n                             1));\n    \n    float num_spheres = 20.0;\n    for(int idx =0; idx < int(100); idx++)\n    {\n        float i = float(idx);\n        float sphere_frac = i / num_spheres;\n        float freq = sphere_frac * iTime * 0.3;\n        vec3 s = vec3(sin(i + freq) * sphere_frac * 1.0 + 0.1, \n                      cos(i + freq), \n                      4);\n    \t\n    \n    \tfloat t = dot(s-ro, rd);\n    \tvec3 p = ro + rd * t;\n    \n    \tfloat y = length(s-p);\n        \n        float r = sphere_frac * 0.3 + 0.1;\n        //r = sin(y*10.0);\n        //r += y;\n    \n\t\t//\tif hit\n    \tif( y < r)\n    \t{\n        \tfloat x = sqrt(r*r - y*y);\n        \tfloat front_hit_t = t-x;\n        \tfloat back_hit_t = t+x;\n    \t\tvec3 hp = ro + rd * front_hit_t;\n        \n        \tvec3 ray_to_hit = normalize(hp - ro);\n        \tvec3 sphere_to_hit = normalize(s - hp);\n            float drs = dot(ray_to_hit, sphere_to_hit);\n        \tcol += drs;\n            \n            //\tadd grid texture based on angle of hit\n            col *= step(mod(s.x-hp.x,0.1),0.05);\n            col *= step(mod(s.y-hp.y,0.1),0.05);\n            col *= step(mod(s.z-hp.z,0.1),0.05);\n            col *= 5.0;\n            \n            \n    \t}\n    }\n\n        \n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscfRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 42, 42, 65], [67, 67, 124, 124, 1767]], "test": "valid"}
{"id": "tscfW8", "name": "Tractrix", "author": "oneshade", "description": "Animation of a tractrix or \"curve of pursuit.\"", "tags": ["curve", "tractrix", "pursuit"], "likes": 2, "viewed": 52, "published": "Public", "date": "1604935995", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return smoothstep(2.0 / iResolution.y, 0.0, length(pa - ba * h) - 0.005);\n}\n\nfloat circle(in vec2 p, in vec2 o, in float r) {\n    return smoothstep(2.0 / iResolution.y, 0.0, length(p - o) - r);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = fragCoord / iResolution.y;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (float i=0.0; i < 1.1; i += 0.1) {\n        float tractrixLine = line(uv, vec2(0.0, 1.0 - i), vec2(i, 0.0));\n        color += tractrixLine;\n    }\n\n    vec2 pursueePos = vec2(fract(0.25 * iTime), 0.0);\n    vec2 pursuerPos = mix(vec2(0.0, 1.0 - pursueePos.x), pursueePos, pursueePos.x);\n\n    float pursuitLine = line(uv, pursueePos, pursuerPos);\n    float pursuee = circle(uv, pursueePos, 0.04);\n    float pursuer = circle(uv, pursuerPos, 0.04);\n\n    color = pursuitLine > 0.0 ? vec3(0.0, pursuitLine, 0.0) : color;\n    color = pursuee > 0.0 ? vec3(0.0, 0.0, pursuee) : color;\n    color = pursuer > 0.0 ? vec3(pursuer, 0.0, 0.0) : color;\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 45, 45, 216], [218, 218, 266, 266, 336], [338, 338, 393, 393, 1152]], "test": "valid"}
{"id": "tscfzs", "name": "Walking donuts", "author": "sylvain69780", "description": "Had a lot of fun using the polar symetry.\nYou can play with it ! \nChange ITEMS_COUNT, size of the Capped Torus DONUT_SIZE, change for another SDF in line 233 ...\nHere I managed to make a constant length arc of elements.", "tags": ["polar", "symmetry", "walk"], "likes": 13, "viewed": 140, "published": "Public", "date": "1605821855", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n    Walking donuts\n    --------------\n    \n    You can find here a capped polar domain repetition function.\n    This allows the walking animation.\n    You are encouraged to modify the code and have fun.\n\n    References\n\n    Distance functions - IQ\n    https://www.iquilezles.org/www/articles/distfunctions/distfunctions.htm\n    \n    Live Coding \"Sphere Gears\" - Part 1 - IQ\n    https://youtu.be/sl9x19EnKng?t=1745\n\n    RayMarching starting point - BigWIngs\n    https://shadertoy.com/view/WtGXDD\n    https://www.youtube.com/watch?v=2dzJZx0yngg    \n\n*/\n\n#define PI 3.14159265\n#define TAU 6.283185\n#define PHI (1.618033988749895)\n#define MAX_STEPS 100\n#define MAX_DIST 100.\n#define SURF_DIST .001\n\n#define S smoothstep\n#define T iTime\n\n#define sat(x) clamp(x, 0., 1.)\n\n#define ITEMS_COUNT 13\n#define DONUT_SIZE .12\n\nvec3 hsv2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n\treturn c.z * mix( vec3(1.0), rgb, c.y);\n}\n\nfloat remap01(float a, float b, float t) {\n\treturn sat((t-a)/(b-a));\n}\n\nmat2 Rot(float a) {\n    float s=sin(a), c=cos(a);\n    return mat2(c, -s, s, c);\n}\n\n// Mercury's hg_sdf library.\n// Repeat around the origin by a fixed angle.\n// For easier use, num of repetitions is use to specify the angle.\nfloat pModPolar(inout vec2 p, float repetitions) {\n    float angle = 2.*PI/repetitions;\n    float a = atan(p.y, p.x) + angle/2.;\n    float r = length(p);\n    float c = floor(a/angle);\n    a = mod(a,angle) - angle/2.;\n    p = vec2(cos(a), sin(a))*r;\n    // For an odd number of repetitions, fix cell index of the cell in -x direction\n    // (cell index would be e.g. -5 and 5 in the two halves of the cell):\n    if (abs(c) >= (repetitions/2.)) c = abs(c);\n    return c;\n}\n\n\n// simple function if you have all objets identical (no need to manage an ID)\nvec3 opRepPolar(vec3 p,float radius,float sectors) {\n    float angle = TAU/sectors;\n    float sector = round(atan(p.z,p.x)/angle);\n    p.xz *= Rot(-angle*sector);\n    p.x -= radius;\n    return p;\n}\n\n// odd number of sectors with aperture\nvec3 opRepPolarOdd(vec2 p,float radius,int sectors,float aperture) {\n    float angle = (TAU-aperture)/float(2*sectors+1);\n    p *= Rot(-float(sectors)*angle); // move to first sector\n    float at=atan(p.y,p.x); \n    int sector = clamp(int(round(at/angle)),-sectors,sectors); \n    p *= Rot(-angle*float(sector));\n    p.x -= radius;\n    return vec3(p,sector+sectors);\n}\n\n// even number of sectors with aperture\nvec3 opRepPolarEven(vec2 p,float radius,int sectors,float aperture) {\n    float angle = (TAU-aperture)/float(2*sectors);\n    p *= Rot(-float(sectors-1)*angle); // move to first sector\n    float at=atan(p.y,p.x);   \n    if ( at < -PI+angle*.5 ) at = at+TAU; // manage atan discontinuity split \n    int sector = clamp(int(round(at/angle)),-sectors+1,sectors); \n    p *= Rot(-angle*float(sector));\n    p.x -= radius;\n    return vec3(p,sector+sectors-1);\n}\n///// bottom up versions\n// odd number of sectors with aperture\nvec3 opRepPolarOddBU(vec2 p,float radius,int sectors,float aperture) {\n    float angle = (TAU-aperture)/float(2*sectors+1);\n    p *= Rot(float(sectors)*angle); // move to first sector\n    float at=atan(p.y,p.x); \n    int sector = clamp(int(round(at/angle)),-sectors,sectors); \n    p *= Rot(-angle*float(sector));\n    p.x -= radius;\n    return vec3(p,sector+sectors);\n}\n\n// even number of sectors with aperture\nvec3 opRepPolarEvenBU(vec2 p,float radius,int sectors,float aperture) {\n    float angle = (TAU-aperture)/float(2*sectors);\n    p *= Rot(float(sectors)*angle); // move to first sector\n    float at=atan(p.y,p.x);   \n    if ( at < -PI+angle*.5 ) at = at+TAU; // manage atan discontinuity split \n    int sector = clamp(int(round(at/angle)),-sectors+1,sectors); \n    p *= Rot(-angle*float(sector));\n    p.x -= radius;\n    return vec3(p,sector+sectors-1);\n}\n\n\nvec3 opRepPolar(vec2 p,float radius,int sectors,float aperture) {\n    return\n        sectors % 2 == 0 ?  \n        opRepPolarEven(p,radius,sectors / 2,aperture) :\n\t    opRepPolarOdd(p,radius,sectors / 2,aperture);\n}\n\nvec3 opRepPolarBU(vec2 p,float radius,int sectors,float aperture) {\n    p=-p;\n    return\n        sectors % 2 == 0 ?  \n        opRepPolarEvenBU(p,radius,sectors / 2,aperture) :\n\t    opRepPolarOddBU(p,radius,sectors / 2,aperture);\n}\n\n\nfloat Hash21(vec2 p) {\n    p = fract(p*vec2(123.34,233.53));\n    p += dot(p, p+23.234);\n    return fract(p.x*p.y);\n}\n\nfloat Hash(float p) { // by noob sylvain\n    return fract(p*PI);\n}\n\nfloat sdBox(vec3 p, vec3 s) {\n    p = abs(p)-s;\n\treturn length(max(p, 0.))+min(max(p.x, max(p.y, p.z)), 0.);\n}\n\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdHexPrism( vec3 p, vec2 h )\n{\n  const vec3 k = vec3(-0.8660254, 0.5, 0.57735);\n  p = abs(p);\n  p.xy -= 2.0*min(dot(k.xy, p.xy), 0.0)*k.xy;\n  vec2 d = vec2(\n       length(p.xy-vec2(clamp(p.x,-k.z*h.x,k.z*h.x), h.x))*sign(p.y-h.x),\n       p.z-h.y );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdOctahedron( vec3 p, float s)\n{\n  p = abs(p);\n  return (p.x+p.y+p.z-s)*0.57735027;\n}\n\nvec2 sdRepBox(vec3 p) {\n    vec3 r;  // transform in xy id in z\n    vec3 q;\n    float id;\n    float time = T*0.5;\n    \n    float l=4.;\n    float sz=l/ float(ITEMS_COUNT);\n    float a=(PI*(1.+1./float(ITEMS_COUNT-1)))*cos(-time*PI);\n    q=p;\n    \n    bool headup = fract(time*.5) > .5;\n    float stride = l*(1.-1./float(ITEMS_COUNT))/PI;\n    q.x-=stride; // center\n     q.x-=-2.*fract(time)*stride; // follow\n     // a = 0.0;\n    if ( headup ) {    \n        // straight\n        if ( abs(a) < 0.01 ) {\n            id=clamp(round((q.y)/sz),0.,float(ITEMS_COUNT-1));\n            q.y = q.y-sz*id; // repetion\n        } else if ( a >0.) {\n        // bend right\n            float ll = l/a;\n            r=opRepPolar(vec2(-q.x+ll,q.y),ll,ITEMS_COUNT,TAU-a);\n            id=r.z;\n            q=vec3(-r.x,r.y,q.z);\n        } else {\n        // bend left\n            float ll = -l/a;\n            r=opRepPolar(vec2(q.x+ll,q.y),ll,ITEMS_COUNT,TAU+a);\n            id=r.z;\n            q=vec3(r.x,r.y,q.z);\n        }\n    } else {\n        // straight\n        if ( abs(a) < 0.01 ) {\n            q.xy=-q.xy;\n            q.y-=-l+sz;\n            id=clamp(round((q.y)/sz),0.,float(ITEMS_COUNT-1));\n            q.y = q.y-sz*id; // repetion\n            // id-=float(ITEMS_COUNT)+1.0;\n        } else if ( a >0.0) {\n        // bend right\n            float ll = l/a;\n            r=opRepPolarBU(vec2(-q.x-ll,q.y),ll,ITEMS_COUNT,TAU-a);\n            id=r.z;\n            q=vec3(-r.x,r.y,q.z);\n        } else {\n        // bend left\n            float ll = -l/a;\n            r=opRepPolarBU(vec2(q.x-ll,q.y),ll,ITEMS_COUNT,TAU+a);\n            id=r.z;\n            q=vec3(r.x,r.y,q.z);\n        }\n    }\n    \n    \n    float d = sdCappedTorus(q.zxy-vec3(0.,0.,0.0),vec2(sin(2.),cos(2.)),.4,DONUT_SIZE);\n\t// float d = sdTorus(q,vec2(.4,DONUT_SIZE));\n    // float d = sdHexPrism(q.zxy,vec2(0.4,DONUT_SIZE))-.02;\n    // float d = sdOctahedron(q,0.4); \n    // float d = length(q)-0.4; // sphere\n    return vec2(d,id);\n}\n\nvec2 GetDist(vec3 p) {\n    vec2 dm = sdRepBox(p-vec3(0.0,0.0-1.9,0.0));\n    return dm;\n}\n\nvec2 RayMarch(vec3 ro, vec3 rd, inout vec3 gc) {\n\tfloat dO=0.;\n    vec2 dm;\n    for(int i=0; i<MAX_STEPS; i++) {\n    \tvec3 p = ro + rd*dO;\n        dm = GetDist(p);\n        // Ripped from Shaw\n        float at = .03 / (1. + dm.x * dm.x * 100.);\n        vec3 gcc = vec3(1., .5, 0.); // hsv2rgb(vec3(Hash(dm.y),0.8,1.)); // \n        gc += gcc * at;       \n        float dS = dm.x;\n        dO += dS;\n        if(dO>MAX_DIST || abs(dS)<SURF_DIST) break;\n    }\n    \n    return vec2(dO,dm.y);\n}\n\nvec3 GetNormal(vec3 p) {\n\tfloat d = GetDist(p).x;\n    vec2 e = vec2(.001, 0);\n    \n    vec3 n = d - vec3(\n        GetDist(p-e.xyy).x,\n        GetDist(p-e.yxy).x,\n        GetDist(p-e.yyx).x);\n    \n    return normalize(n);\n}\n\nvec3 GetRayDir(vec2 uv, vec3 p, vec3 l, float z) {\n    vec3 f = normalize(l-p),\n        r = normalize(cross(f,vec3(0,1,0))),\n        u = cross(r,f),\n        c = f*z,\n        i = c + uv.x*r + uv.y*u,\n        d = normalize(i);\n    return d;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n\tvec2 m = (iMouse.xy-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 col = vec3(0);\n    \n    vec3 ro = vec3(0, 1.5, 3.8);\n    if ( iMouse.x > .0 ) {\n       ro.yz *= Rot(-m.y*3.14);\n       ro.xz *= Rot(-m.x*6.2831);\n    }\n    \n    vec3 rd = GetRayDir(uv, ro, vec3(0), 1.);\n    vec3 gc = vec3(0);\n    vec2 dm = RayMarch(ro, rd,gc);\n    \n    if(dm.x<MAX_DIST) {\n    \tvec3 p = ro + rd * dm.x;\n    \tvec3 n = GetNormal(p);\n        \n        vec3  sun_lig = normalize( vec3(0.2, 0.35, 0.5) );        \n    \tfloat dif = clamp(dot( n, sun_lig ), 0.0, 1.0 )+.05;\n        vec3  sun_hal = normalize( sun_lig-rd );\n\t\tfloat sun_spe = pow(clamp(dot(n,sun_hal),0.0,1.0),8.0)*dif*(0.04+0.96*pow(clamp(1.0+dot(sun_hal,rd),0.0,1.0),5.0));\n        float sun_sha = 1. ; //step(-RayMarch(p+0.01*n, sun_lig).x,-MAX_DIST);\n        col += 1.*sun_spe*vec3(8.10,6.00,4.20)*sun_sha;\n//        vec3 c = hsv2rgb(vec3(Hash(dm.y),0.8,1.)); // random colors\n        vec3 c=vec3(0.5); // *dm.y/float(ITEMS_COUNT);\n        if ( dm.y == 0.0 ) c=vec3(1.0,0.0,0.0);\n        if ( dm.y == float(ITEMS_COUNT-1) ) c=vec3(0.0,0.0,1.0);\n        // c=vec3(0.,0.,1.);\n        // blinking\n        // c *= 1. +1.8*S(.95,1.0,abs(sin(dm.y/PI+iTime*1.)));  // S(2.,0.,abs(dm.y-fract(iTime)*float(ITEMS_COUNT)));\n    \tcol += dif*c*(sun_sha*.9+.1);  \n        \n    } else { col = vec3(.1+.01*Hash21(uv))*(.5-abs(uv.y));}\n    col+=gc;   \n    col = sqrt(col);\t// gamma correction\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tscfzs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[816, 816, 843, 843, 969], [971, 971, 1013, 1013, 1041], [1043, 1043, 1062, 1062, 1124], [1126, 1268, 1318, 1318, 1738], [1741, 1819, 1871, 1871, 2016], [2018, 2057, 2125, 2125, 2424], [2426, 2466, 2535, 2535, 2918], [2919, 2983, 3053, 3053, 3351], [3353, 3393, 3464, 3464, 3844], [3847, 3847, 3912, 3912, 4061], [4063, 4063, 4130, 4130, 4293], [4296, 4296, 4318, 4318, 4412], [4414, 4414, 4435, 4454, 4480], [4482, 4482, 4511, 4511, 4592], [4594, 4594, 4664, 4664, 4798], [4800, 4800, 4833, 4833, 4898], [4900, 4900, 4936, 4936, 5209], [5211, 5211, 5249, 5249, 5302], [5304, 5304, 5327, 5327, 7276], [7278, 7278, 7300, 7300, 7366], [7368, 7368, 7416, 7416, 7854], [7856, 7856, 7880, 7880, 8078], [8080, 8080, 8130, 8130, 8320], [8323, 8323, 8380, 8380, 9894]], "test": "valid"}
{"id": "tsdBR2", "name": "Torus Sphere Marching", "author": "KJK", "description": "My first sphere marching shader.", "tags": ["spheremarching"], "likes": 5, "viewed": 106, "published": "Public", "date": "1605591780", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mapSdf(vec3 p, float t);\nfloat trace(vec3 ro, vec3 dir, float t);\nvec3 mapNormal(vec3 p, float t);\nvec3 pointLight(vec3 p, vec3 nor, vec3 light, vec3 color);\nvec3 directionalLight(vec3 p, vec3 nor, vec3 dir, vec3 color);\nfloat torusSdf(vec3 p, vec3 center, vec3 axis, float R, float r);\nvec3 rayDir(vec3 camDir, vec2 uv);\nfloat calcAO(vec3 p, vec3 nor, float t);\nfloat calcSoftShadow(vec3 ro, vec3 rd, float mint, float maxt, float k, float time, int maxSteps );\nfloat diskSdf(vec3 p, vec3 center, vec3 axis, float r);\nvec3 render(vec2 uv, float t);\nfloat boxSdf(vec3 p, vec3 r);\n\nfloat TAU = 6.283185307;\nvec3 ONE3 = vec3(1.0);\nvec3 ZERO3 = vec3(0.0);\nvec3 UP = vec3(0.0, 1.0, 0.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 e = vec2(.75, 0.0);\n    vec3 col = render(fragCoord, iTime);\n    \n    // Take extra samples in high contrast regions.\n    float brightness = length(col);\n    vec2 gradient = vec2(dFdx(brightness), dFdy(brightness));\n    float relativeContrast = length(gradient) / brightness;\n    if (relativeContrast >= 0.02) {\n        col += render(fragCoord + e.xy, iTime).xyz\n            +  render(fragCoord + e.yx, iTime).xyz\n            +  render(fragCoord - e.xy, iTime).xyz\n            +  render(fragCoord - e.yx, iTime).xyz;\n        col *= 1.0 / 5.0;\n        //col = vec3(1.0);\n    }\n    \n    col = pow(col, vec3(0.4545));\n    \n    fragColor = vec4(col,1.0);\n}\n\nvec3 render(vec2 uv, float t) {\n    // Normalized x coordinates (from -.5 to .5)\n    uv = (uv - iResolution.xy * .5) / iResolution.x;\n\n    vec3 camPos = vec3(.0,130.0,-250.0);\n    vec3 camDir = normalize(vec3(0.0, -.4, 1.0));\n    vec3 rd = rayDir(camDir, uv);\n    float dist = trace(camPos, rd, t);\n    \n    vec3 col;\n    \n    if (dist >= 0.0) {\n        vec3 hit = camPos + rd * dist;\n        vec3 nor = mapNormal(hit, t);\n\n        vec3 l1pos = normalize(vec3(1.0, 1.0, .5)) * 1500.0;\n        vec3 l1col = vec3(.7, .7, 1.0) * 1000000.0;\n        vec3 l1 =  pointLight(hit, nor, l1pos, l1col) *  calcSoftShadow(hit, normalize(l1pos - hit), 1.0, 1000.0, 10.0, t, 100);\n\n        vec3 ambientLight = vec3(1.0, .7, .7) * .02;\n        vec3 l2 = directionalLight(hit, nor, -UP, ambientLight) + ambientLight * calcAO(hit, nor, t);\n\n        vec3 l3pos = normalize(vec3(-1.0, 1.0, .5)) * 1500.0;\n        vec3 l3col = vec3(1.0, .8, .5) * 1000000.0;\n        vec3 l3 =  pointLight(hit, nor, l3pos, l3col) *  calcSoftShadow(hit, normalize(l3pos - hit), 1.0, 1000.0, 10.0, t, 100);\n\n        col = l1 + l2 + l3;\n        //col *= 1.0 - pow(abs(dot(nor, rd)), 4.0);\n        //col *= mix((nor + ONE3) * .5, ONE3, .0);\n        //col.x = col.y = col.z;\n    }\n    \n    return col;\n}\n\nvec3 rayDir(vec3 camDir, vec2 uv) {\n    float fovAngle = 90.0 * TAU / 360.0;\n    float focalLength = .5 / tan(fovAngle *.5);\n    vec3 camRight = cross(UP, camDir);\n    vec3 camUp = cross(camDir, camRight);\n    vec3 rd = camDir * focalLength + uv.x * camRight + uv.y * camUp;\n    return normalize(rd);\n}\n\n// Lighting\n\nvec3 pointLight(vec3 p, vec3 nor, vec3 light, vec3 color) {\n    vec3 toLight = light - p;\n    vec3 toLightNor = normalize(toLight);\n    float distSq = dot(toLight, toLight);\n    return max(vec3(.0), dot(nor, toLightNor) * color / distSq);\n}\n\nvec3 directionalLight(vec3 p, vec3 nor, vec3 dir, vec3 color) {\n    return max(vec3(.0), dot(nor, dir) * color);\n}\n\nfloat calcAO(vec3 p, vec3 nor, float t) {\n    float occ = 0.0;\n    float scale = 0.02;\n    for(int i = 0; i < 5; i++) {\n        float h = 0.01 + 3.0 * float(i);\n        float d = mapSdf(p + nor * h, t);\n        occ += (h - d) * scale;\n        scale *= 0.95;\n    }\n    return clamp(1.0 - 1.0 * occ, 0.0, 1.0);\n}\n\n// Sebastian Aaltonen's algorithm\n// https://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat calcSoftShadow(vec3 ro, vec3 rd, float mint, float maxt, float k, float time, int maxSteps ) {\n    float res = 1.0;\n    float ph = 1e20;\n    int i = 0;\n    for( float t=mint; t<maxt; ) {\n        if (i++ > maxSteps) return res;\n        float h = mapSdf(ro + rd*t, time);\n        if( h<0.001 )\n            return 0.0;\n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += h;\n    }\n    return res;\n}\n\n// Ray Marching\n\nfloat trace(vec3 ro, vec3 rd, float t) {\n    float epsilon = .1;\n    float dist = .0;\n    for(int i = 0; i < 500; i++) {\n        float d = mapSdf(ro + rd * dist, t);\n        dist += d;\n        if (d < epsilon) return dist;\n    }\n    return -1.0;\n}\n\nfloat mapSdf(vec3 p, float t) {\n    //t = TAU / 16.0;\n    // Rotating Torus\n    float phi = TAU / 8.0;    \n    float theta = t * 2.0;\n    vec3 axis = vec3(sin(theta) * sin(phi), cos(phi), cos(theta) * sin(phi));\n    float R = 50.0;\n    float r = 10.0;\n    float torusY = R * sin(phi) + r + 1.0;\n    vec3 torusCenter = ZERO3 + UP * torusY;\n    float torusD = torusSdf(p, torusCenter, axis, R, r );\n    \n    float groundD = p.y;\n    float wallD = 2000.0 - p.z;\n    \n    float d = min(groundD, torusD);\n    d = min(d, wallD);\n    return d;\n}\n\nvec3 mapNormal(vec3 p, float t) {\n    vec2 e = vec2(1.0, .0);\n    float d = mapSdf(p, t);    \n    float dx = (mapSdf(p + e.xyy, t) - d) / e.x;\n    float dy = (mapSdf(p + e.yxy, t) - d) / e.x;\n\tfloat dz = (mapSdf(p + e.yyx, t) - d) / e.x;\n    return normalize(vec3(dx, dy, dz));\n}\n\n// SDFs\n\nfloat torusSdf(vec3 p, vec3 center, vec3 axis, float R, float r) {\n    vec3 d = p - center;\n    float v = dot(d, axis);            // Vertical displacement (along axis).\n    float h = sqrt(dot(d, d) - v * v); // Horizontal displacment (normal to axis).\n    float x = h - R;\n    return sqrt(v * v + x * x) - r;\n}\n\nfloat diskSdf(vec3 p, vec3 center, vec3 axis, float r) {\n    vec3 d = p - center;\n    float h = dot(d, axis);\n    float v = sqrt(dot(d, d) - h * h);\n    float x = abs(v - r);\n    return x > r ? sqrt(x*x + h*h) : h;\n}\n\nfloat boxSdf(vec3 p, vec3 r) {\n    p = abs(p);\n    vec3 q = min(p, r);\n    return length(q - p);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsdBR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[691, 691, 748, 748, 1410], [1412, 1412, 1443, 1492, 2671], [2673, 2673, 2708, 2708, 2975], [2990, 2990, 3049, 3049, 3230], [3232, 3232, 3295, 3295, 3346], [3348, 3348, 3389, 3389, 3658], [3660, 3757, 3857, 3857, 4243], [4262, 4262, 4302, 4302, 4509], [4511, 4511, 4542, 4586, 5049], [5051, 5051, 5084, 5084, 5330], [5341, 5341, 5407, 5407, 5652], [5654, 5654, 5710, 5710, 5870], [5872, 5872, 5902, 5902, 5970]], "test": "error"}
{"id": "tsGBRw", "name": "lotus_flower", "author": "tequibo", "description": "just something for you to like", "tags": ["sdf", "sin", "tau"], "likes": 4, "viewed": 191, "published": "Public", "date": "1606776396", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat time_scale=.5;\nfloat angle_div=0.6;\n#define TAU 6.28318530718\nfloat box(vec2 center, vec2 uv, vec2 R){\n    float d = length(max(abs(center+uv)-R,0.));\n    return d;\n}\nmat2 rotate2d(float angle){\n    return mat2(cos(angle),-sin(angle),\n                sin(angle),cos(angle));\n}\nfloat t;\nvec3 color = vec3(0.2549, 0.0157, 0.2549);\nvec3 color2 = vec3(0.0, 0.9333, 1.0);\nfloat makeThing(vec2 uv){\n    float r = 0.;\n    float N = 30.;\n    float s=.70;\n    for(float i=0.;i<N;i++){    \n        float n = i/N;\n        float anim=2.+sin(t+n*6.);\n        float b = box(vec2(0.,0.), uv*rotate2d(float(i)*TAU*angle_div), vec2(s-n*s*anim,s-n*s*anim));\n        b=smoothstep(3./iResolution.y,.0,b);\n        r = max(b*n,r);\n    }\n    return r;\n}\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 R = iResolution.xy;\n    vec2 uv = (2.*fragCoord-R)/R.y;\n    t = iTime*TAU*time_scale;\n    float d=makeThing(uv);\n    vec3 col = mix(color,color2,d);\n    fragColor = vec4(col,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsGBRw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 109, 109, 173], [174, 174, 201, 201, 283], [374, 374, 399, 399, 737], [738, 738, 793, 793, 982]], "test": "valid"}
{"id": "tsKfRh", "name": "Audio Visualizer Shader", "author": "Tech_", "description": "Hey Guys, I made a shader! Just look and enjoy the music :)\nAny feedback is appreciated!", "tags": ["music", "audio"], "likes": 4, "viewed": 316, "published": "Public API", "date": "1606664597", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n//////////////////////////////////////////////////////\n//\n//\t CLASSIC AUDIO VISUALIZER\n//\n//\t by Tech_\n//\n//   Thanks to dynamite (https://www.shadertoy.com/user/dynamite)\n//\t for the nice colors :D\n//\n//////////////////////////////////////////////////////\n\n#define PI 3.1415\n\n// Tweak these constants depending\n// on the song...\n#define SCALE_REACTIVENESS 0.5\n#define FREQUENCY_REACTIVENESS 1.0\n#define HIGHS_MULTIPLIER 1.5\n#define SPECTRUM_SCALE 1.0\n\nfloat getFrequencies(in vec2 uv) \n{\n\treturn texture(iChannel0, vec2(uv.x, 0.25)).r;\n}\n\nfloat getLowEnd() \n{\n\treturn texture(iChannel0, vec2(0.2, 0.25)).r;\n}\n\nvec3 getCircleColor(in vec2 st) \n{\n    float xCol = (st.x - (iTime / 13.0)) * 3.0;\n\txCol = mod(xCol, 3.0);\n\tvec3 color = vec3(0.25, 0.25, 0.25);\n    \n\tif (xCol < 1.0) {\n\t\t\n        color.g += 1.0 - xCol;\n        color.b += xCol;\n\t}\n\telse if (xCol < 2.0) {\n\t\t\n\t\txCol -= 1.0;\n\t\tcolor.b += 1.0 - xCol;\n\t\tcolor.r += xCol;\n\t}\n\telse {\n\t\t\n\t\txCol -= 2.0;\n\t\tcolor.r += 1.0 - xCol;\n\t\tcolor.g += xCol;\n\t}\n    \n    return color;\n}\n\nvec3 getColorGradient(in vec2 uv, vec3 col1, vec3 col2, float speed, float scale) \n{\n\tvec3 col;\n    uv *= scale;\n    \n    float s = (sin((uv.x + iTime / 5.0 * speed + uv.y + cos(uv.x + (iTime / 7.0 * speed) * 3.0 + sin((uv.y + iTime * speed / 10.0) * 5.0))) * 14.0) + 1.0) / 2.0;\n    \n    col = mix(col1, col2, s);\n    \n    return col;\n}\n\nfloat vignette(in vec2 uv, float borderStrength, float strength) \n{\n\treturn mix(1.0, pow(sin(uv.x * PI) * sin(uv.y * PI), borderStrength), strength);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    float tau = 3.1415926535*2.0;\n    float a = atan(p.x, p.y);\n    float r = length(p) * 0.75;\n    vec2 st = vec2(a/tau,r);\n    float aspectRatio = iResolution.x / iResolution.y;\n    vec3 col;\n    \n    vec3 spectrumColor = getCircleColor(st);\n    \n    float freq;\n    freq += getFrequencies(st / 4.0) * step(1. - uv.x, 0.5);\n    freq += getFrequencies(st / 4.0 * vec2(-1.0, 1.0)) * step(uv.x, 0.5);\n    freq = clamp(freq, 0.0, 1.0);\n    freq = pow(clamp(freq, 0.0, 1.0), 3.0);\n    \n    vec2 z = st * vec2(-1.0, 1.0);\n    float freqMultiplier = pow((clamp(st.x, 0.0, 1.0) + clamp(z.x, 0.0, 1.0)) * 2.0, HIGHS_MULTIPLIER) + 0.15;    \n    freq *= freqMultiplier * 4.0;\n    \n    float lowEnd = getLowEnd() * SCALE_REACTIVENESS;\n    \n    st = ((1.85 * SPECTRUM_SCALE + lowEnd) + (freq * FREQUENCY_REACTIVENESS - 2.8) * st) - 1.0;\n    float spectrum = 1.7 * abs(1.0 / (60.0 * st.y));\n    \n    float brightnessMultiplier = getLowEnd();\n    brightnessMultiplier = pow(brightnessMultiplier + 0.8, 2.5);\n    \n    col += spectrum * spectrumColor * (brightnessMultiplier + freq * FREQUENCY_REACTIVENESS);\n    col *= clamp(length((uv - 0.5) * vec2(aspectRatio, 1.0)) * 4.0, 0.0, 1.0);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4sXGRr", "previewfilepath": "/media/ap/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/48e2d9ef22ca6673330b8c38a260c87694d2bbc94c19fec9dfa4a1222c364a99.mp3", "ctype": "music"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsKfRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[454, 454, 489, 489, 539], [541, 541, 561, 561, 610], [612, 612, 646, 646, 1029], [1031, 1031, 1115, 1115, 1368], [1370, 1370, 1437, 1437, 1521], [1523, 1523, 1580, 1580, 2923]], "test": "error"}
{"id": "tstBR7", "name": "Ray Marching Primitive Shapes", "author": "yonng", "description": "Refer to the great tutorial: https://www.youtube.com/watch?v=Ff0jJyyiVyw&pbjreload=101\n\nI organized the codes from the above tutorial and made a little extension.", "tags": ["3d", "raymarching"], "likes": 1, "viewed": 169, "published": "Public API", "date": "1604723044", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n//make sure avoid negative components -> obtain the distance\nfloat sdfBox(vec3 p, vec3 center,vec3 len )  //center of the box\n{\n     return length(max(abs(p-center)-len,0.));   //3 components of len are identical. For example, vec3(0.5)\n      \n}\n\n\n// cylidner with two cap, trick is to define the y component\n// to make caps, consider the interior points\nfloat sdfCylinder(vec3 p, vec3 a, vec3 b, float r)\n{\n    vec3 ab = b-a;\n    vec3 ap = p-a;\n    \n    float t = dot(ab,ap) /dot(ab,ab);\n    \n    vec3 c = a+t*ab;\n    float x = length(p-c) - r;   // for the side part -> x\n    float y = (abs(t- 0.5) -0.5) * length (ab);\n    float e = length(max(vec2(x,y),0.));\n    \n    float i = min(max(x,y),0.);  //to make is a little smooth appearance\n    \n    return e+i;\n    \n}\n\n// torus on the xz plane\nfloat sdfTorus(vec3 p, vec3 center, vec2 r)   //r is for the two radiuses\n{\n     p -=center;  //remap the center from the (0,0,0)\n     float x = length(p.xz) - r.x;\n     return length(vec2(x, p.y)) - r.y;    //r.y is \n    \t\n}\n\nfloat sdfCapsule(vec3 p, vec3 a, vec3 b, float radius)\n{\n      vec3 ab = b-a;\n      vec3 ap = p -a;\n      \n      float t = dot(ab, ap) / dot(ab, ab);   //use dot to find the segment index for the capsule\n      t = clamp (t,0., 1.);\n      \n      vec3 c = a+t*ab;\n      float d = length(p-c) - radius;\n      return d;\n}\n\n\nfloat sdfSphere(vec3 p, vec4 center)\n{\n      return length(p - center.xyz) - center.w;   //w is the radius   \n}\n\nfloat sdfScene(vec3 p)  // simple way calculate the distance using ray marching\n{\n     vec4 s = vec4(0,3,6,1);   //the last 1 is for radius, the first three are the coordinates of the circle\n     float spheresdf = sdfSphere(p,s);\n    \n     float capsulesdf = sdfCapsule(p,vec3(0,.3,6),vec3(0,2,6),.2);\n     \n     float planesdf = p.y;   //for the plane, plane's height is at 1 \n     float torussdf = sdfTorus(p,vec3(0,0.5,7), vec2(1.58,.2));\n     float boxsdf = sdfBox(p,vec3(-3,0.5,6),vec3(0.5));  //0.5 above the ground, and 6 depth\n     boxsdf = min(boxsdf, sdfBox(p,vec3(-3,0.5,4.9),vec3(0.5)));\n     boxsdf = min(boxsdf, sdfBox(p,vec3(-3,1.5,5.5),vec3(0.5)));\n    \n     float cysdf = sdfCylinder(p, vec3(2,.5,4),vec3(2,.5,6),.2);\n     cysdf =min(cysdf,sdfCylinder(p, vec3(2.5,.5,4),vec3(2.5,.5,6),.2));\n         \n     float d = min(capsulesdf, planesdf);\n     d = min(d,torussdf);\n     d = min(d, boxsdf);\n     d = min(d, cysdf);\n     return d;\n    \n}\n\n#define MAX_STEPS 100    \n#define MAX_DIST 100.   \n#define SURF_DIST .01\n\n//float and int\n\nfloat RayMarch(vec3 ro, vec3 rd)\n{\n \tfloat d0=0.;\n    for(int i=0;i<MAX_STEPS;i++)\n    {\n       vec3 p = ro + rd*d0;\n       float ds = sdfScene(p);   \n       d0+=ds;\n       // to long or to small -> break\n       if(d0>MAX_DIST||ds<SURF_DIST) break;\n        \n    }\n    \n    return d0;\n}\nvec3 GetNormal(vec3 p)\n{\n    float d = sdfScene(p);\n    vec2 e = vec2(.001,0);  //delta e\n    vec3 n= d - vec3(sdfScene(p-e.xyy),\n                   sdfScene(p-e.yxy),\n                   sdfScene(p-e.yyx));\n    \n    return normalize(n);\n}\n\nfloat GetLight(vec3 p)\n{\n    vec3 lightPos = vec3(0,5,6);\n    lightPos.xz += vec2(sin(iTime), cos(iTime));  //light moves aro  und\n    vec3 l = normalize(lightPos - p);\n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l)*0.5+0.5,0.,1.);\n    \n    //utilize the idea of shadowmap to generate the light\n    //if the distance can't reach the light then in shadow\n    float d = RayMarch(p+n*SURF_DIST*2.,l); //from the plane a little bit\n    if(d<length(lightPos - p)&& p.y<0.1) dif*=.2;\n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.y;\n\n    // Time varying pixel color\n    vec3 col = vec3(0);\n    vec3 ro = vec3(0,3,0);\n    //-.2 make the camera looks down a little bit\n    vec3 rd= normalize(vec3(uv.x,uv.y-.4,1));  //rd equals every point on the screen\n    \n    float d = RayMarch(ro, rd);\n    //d /=6.;\n    vec3 p = ro+rd*d;\n    float dif = GetLight(p);\n    col = vec3(dif);\n\n    //col = GetNormal(p);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 63, 129, 129, 247], [250, 357, 409, 409, 770], [772, 797, 872, 872, 1022], [1024, 1024, 1080, 1080, 1341], [1344, 1344, 1382, 1382, 1455], [1457, 1457, 1538, 1538, 2413], [2506, 2506, 2540, 2540, 2791], [2792, 2792, 2816, 2816, 3030], [3032, 3032, 3056, 3056, 3543], [3545, 3545, 3602, 3652, 4140]], "test": "valid"}
{"id": "tstBRj", "name": "Planets Obiting", "author": "mickyman007", "description": "Some planets in space", "tags": ["spheres", "planet"], "likes": 1, "viewed": 37, "published": "Public", "date": "1605630557", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 circle(vec2 xy, vec2 pos, float r, vec4 c) {\n\tfloat p = abs(distance(xy*iResolution.xy, pos*iResolution.xy));\n    \n    return vec4(step(p, r)) * c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 xy = fragCoord/iResolution.xy;\n    vec2 mid = vec2(0.5);\n    vec2 mos = (iMouse.z > .0)? iMouse.xy/iResolution.xy : mid;\n   \n    \n    float r = 50.;\n    \n    float diff = abs(distance(mid, mos));\n    vec2 off = mix(mid, mos, diff);\n    \n    vec4 blue = vec4(0, 0.4, 1, 1);\n    vec4 green = vec4(0, 1, 0.4, 1);\n    \n    vec4 px = circle(xy,  off, r, blue);\n    \n    px += circle(xy, \n                 off+vec2(sin(iTime/.5)/2., mix(0., -0.1, abs(sin(iTime)))), \n                 mix(20., 60., abs(sin(iTime))), \n                 green * abs(sin(iTime)));\n    \n    if (px == vec4(0)) {\n    \tpx = texture(iChannel0, xy + off);\n    }\n    \n    fragColor = px;\n}", "image_inputs": [{"id": "XdfGRn", "previewfilepath": "/media/ap/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/e6e5631ce1237ae4c05b3563eda686400a401df4548d0f9fad40ecac1659c46c.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstBRj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 49, 49, 154], [156, 156, 213, 213, 879]], "test": "error"}
{"id": "tstBzM", "name": "gradient_1", "author": "chepuha", "description": "gradient", "tags": ["gradient"], "likes": 2, "viewed": 70, "published": "Public", "date": "1604700619", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 crd = 0.005* (fragCoord.xy - iResolution.xy / 2.0);\n        float len;\n    \n    for (int i = 0; i < 10; i++) {\n        len = length(vec2(crd.x, crd.y));\n        crd.x = crd.x - cos(crd.y + sin(len)) + cos(iTime / 2.92);\n        crd.y = crd.y + sin(crd.x + cos(len)) + sin(iTime / 2.90);\n    }\n    //color\n    fragColor =  vec4(cos(len * -0.8), cos(len * 0.164), cos(len * 0.1), 1.0);\n    \n    //bw\n    //fragColor =  vec4(cos(len), cos(len), cos(len), 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstBzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 526]], "test": "valid"}
{"id": "tstfRN", "name": "penguin", "author": "zchajax", "description": "A simple penguin\n\n", "tags": ["raymarching", "sdf", "penguin"], "likes": 10, "viewed": 94, "published": "Public", "date": "1605004488", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\n#define MATERIAL_BODY 1.0\n#define MATERIAL_MOUTH 2.0\n#define MATERIAL_EYE 3.0\n#define MATERIAL_NECK 4.0\n\nfloat sdSphere(vec3 p, float r)\n{\n    return length(p) - r;\n}\n\nfloat sdTorus(vec3 p, vec2 r)\n{\n    float x = length(p.xz) - r.x;\n    return length(vec2(x, p.y)) - r.y;\n}\n\nfloat sdEllipsoid(vec3 p, vec3 r)\n{\n    float k0 = length(p/r);\n    float k1 = length(p/(r*r));\n    return k0*(k0-1.0)/k1;\n}\n\nfloat sdRoundCone(vec3 p, float r1, float r2, float h)\n{\n    p.z *= 3.0;\n    vec2 q = vec2(length(p.xz), p.y);\n      \n    float b = (r1-r2)/h;\n    float a = sqrt(1.0-b*b);\n    float k = dot(q,vec2(-b,a));\n      \n    if( k < 0.0 ) return length(q) - r1;\n    if( k > a*h ) return length(q-vec2(0.0,h)) - r2;\n          \n    return dot(q, vec2(a,b) ) - r1;\n}\n\nfloat sdCappedTorus(vec3 p, vec2 sc, float ra, float rb)\n{\n    p.x = abs(p.x);\n    float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n    return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\n\n\nfloat opSmoothUnion( float d1, float d2, float k ) \n{\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); \n}\n\nvec3 rotateX(vec3 p, float t)\n{\n    float cost = cos(t);\n    float sint = sin(t);\n    mat3 mat = mat3(\n        1.0,  0.0,  0.0,\n        0.0, cost, -sint,\n        0.0, sint, cost);\n    return mat * p;\n}\n\nvec3 rotateY(vec3 p, float t)\n{\n    float cost = cos(t);\n    float sint = sin(t);\n    mat3 mat = mat3(\n         cost,  0.0, sint,\n         0.0,   1.0, 0.0,\n         -sint, 0.0, cost);\n    return mat * p;\n}\n\nvec3 rotateZ(vec3 p, float t) \n{\n    float cost = cos(t);\n    float sint = sin(t);\n    mat3 mat = mat3(\n         cost,-sint, 0.0,\n         sint, cost, 0.0,\n          0.0,  0.0, 1.0);\n    return mat * p;\n}\n\nvec2 opU( vec2 d1, vec2 d2 )\n{\n\treturn (d1.x<d2.x) ? d1 : d2;\n}\n\nvec2 sdf(vec3 p) \n{\n    p = rotateZ(p, sin(iTime * 8.0) * 0.03);\n    \n    vec2 res = vec2( 1e10, 0.0 );\n    \n    // body\n    float dist = opSmoothUnion(\n        sdEllipsoid(p - vec3(0.0, 1.0, 0.0), vec3(2.1, 2.2, 1.8)),\n        sdSphere(p - vec3(0.0, 3.0, 0.0), 1.6), 0.5);\n\n    // arms\n    const vec3 leftArmPos = vec3(-2.35, 1.1, 0);\n    const vec3 rightArmPos = leftArmPos * vec3(-1.0, 1.0, 1.0);\n    const vec3 armThickness = vec3(1.0, 0.3, 0.8);\n    dist = opSmoothUnion(dist,\n        sdEllipsoid(rotateZ(p - leftArmPos, 0.95 + sin(iTime* 8.0) * 0.05), armThickness), 0.1);\n    dist = opSmoothUnion(dist,\n        sdEllipsoid(rotateZ(p - rightArmPos, -0.95 - sin(iTime* 8.0) * 0.05), armThickness), 0.1);\n    \n    res = opU(res, vec2(dist, MATERIAL_BODY));\n    \n    // belly\n    dist = sdEllipsoid(p - vec3(0.0, 1.0, 0.4), vec3(2.1, 2.2, 1.8)*0.9);\n    res = opU(res, vec2(dist, MATERIAL_EYE));\n    \n    // foot\n    const vec3 leftFootPos = vec3(-1.2, -0.9, 0.3);\n    const vec3 rightFootPos = vec3(-leftFootPos.x, leftFootPos.y, leftFootPos.z);\n    const vec3 footSize = vec3(1.0, 0.4, 1.0);\n    dist = min(\n        sdEllipsoid(rotateX(p - leftFootPos, 0.0), footSize),\n        sdEllipsoid(rotateX(p - rightFootPos, 0.0), footSize));\n\n    // mouth\n    dist = min(dist, sdRoundCone(rotateX(p - vec3(0.0, 2.5, 2.0), 3.23 * PI/2.0), 0.1, 0.7, 0.6));\n    res = opU(res, vec2(dist, MATERIAL_MOUTH));\n\n    // eyes\n\tconst vec3 leftEyePos = vec3(-0.5, 3.4, 1.0);\n    const vec3 rightEyePos = leftEyePos*vec3(-1.0, 1.0, 1.0);\n    const vec3 eyeSize = vec3(0.5, 0.68, 0.68);\n    dist = min(\n        sdEllipsoid(p - leftEyePos, eyeSize), \n        sdEllipsoid(p - rightEyePos, eyeSize));\n    res = opU(res, vec2(dist, MATERIAL_EYE));\n    \n    // eyeball\n    vec3 leftEyeballPos = vec3(-0.43 , 3.45, 1.67);\n    vec3 rightEyeballPos = vec3(0.43, 3.45, 1.67);\n    \n    // left\n    dist = sdEllipsoid(p - leftEyeballPos, vec3(0.2, 0.22, 0.1));\n    res = opU(res, vec2(dist, MATERIAL_BODY));\n    \n    // right\n    dist = mix(\n        sdCappedTorus(rotateZ(p - rightEyeballPos, -0.1) * vec3(1.1, 0.8, 0.8), vec2(0.7,-0.5), 0.15, 0.05),\n        sdEllipsoid(p - rightEyeballPos, vec3(0.2, 0.22, 0.1)), \n        step(fract(iTime * 0.5), 0.5));\n    res = opU(res, vec2(dist, MATERIAL_BODY));\n    \n    // neck\n    vec3 neckPos = p - vec3(0.0, 2.27, 0.0);\n\tneckPos.y *= 0.7;\n    dist = opSmoothUnion(\n        \t\tsdTorus(neckPos, vec2(1.7, 0.2)),\n               \tsdEllipsoid(p - vec3(-1.0, 1.8, 1.6), vec3(0.3, 0.5, 0.1)), 0.25);\n    res = opU(res, vec2(dist, MATERIAL_NECK));\n    return res;\n}\n\nvec3 normal(in vec3 p)\n{\n    vec3 epsilon = vec3(0.001, 0.0, 0.0);\n    vec3 n = vec3(\n          sdf(p + epsilon.xyy).x - sdf(p - epsilon.xyy).x,\n          sdf(p + epsilon.yxy).x - sdf(p - epsilon.yxy).x,\n          sdf(p + epsilon.yyx).x - sdf(p - epsilon.yyx).x);\n    return normalize(n);\n}\n\nvec2 rayMarching(vec3 ro, vec3 rd)\n{\n    float t = 0.0;\n    vec2 res;\n\n    for(int i=0; i < 300; ++i) \n    {\n        vec3 p = ro + t * rd;\n        res = sdf(p);\n        t += res.x;\n        if(res.x < 0.0001)\n            break;\n    }\n   \n    res.x = t;\n    return res;\n}\n\nvec3 getAlbedo(float material)\n{\n    if (material == MATERIAL_BODY)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    else if (material == MATERIAL_MOUTH)\n    {\n        return vec3(1.0, .3, 0.0);\n    }\n   \telse if (material == MATERIAL_EYE)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if (material == MATERIAL_NECK)\n    {\n        return vec3(1.0, 0.0, 0.0);\n    }\n    else\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n}\n\nvec3 getSpecular(float material)\n{\n    if (material == MATERIAL_BODY)\n    {\n        return vec3(0.5, 0.5, 0.5);\n    }\n    else if (material == MATERIAL_MOUTH)\n    {\n        return vec3(1.0, 0.7, 0.0);\n    }\n   \telse if (material == MATERIAL_EYE)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    else if (material == MATERIAL_NECK)\n    {\n        return vec3(0.3, 0.3, 0.3);\n    }\n    else\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n}\n\nvec3 lighting(vec3 eyeDir, vec3 p, float mat)\n{\n    vec3 diffuse = vec3(0);\n    vec3 specular = vec3(0);\n    vec3 normal = normal(p);\n\n    // direct light\n    vec3 lightPos = vec3(5.0, 25.0, 10.0);\n    vec3 lightColor = vec3(1., .956, .839);\n    vec3 lightDir = normalize(lightPos - p);\n    float directDiffuse = clamp(dot(normal, lightDir), 0.0, 1.0);\n    float directspecular = pow(clamp(dot(reflect(lightDir, normal), eyeDir), 0.0, 1.0), 10.0);\n    diffuse  += lightColor * directDiffuse;\n    specular += lightColor * directspecular;\n\n    // ambient\n    diffuse += vec3(0.5, 0.7, 1.0) * 0.3;\n\n    // final color\n    vec3 col = diffuse * getAlbedo(mat) + specular * getSpecular(mat);\n\n    // Gamma correction\n    col = pow(col, vec3(0.4545));\n\n    return col;\n}\n\nmat3 lookAt(vec3 origin, vec3 target, float roll, float fov)\n{\n    vec3 rr = vec3(sin(roll), cos(roll), 0.0);\n    vec3 lookdir = normalize(target - origin);\n    vec3 uu = normalize(cross(lookdir, rr));\n    vec3 vv = normalize(cross(uu, lookdir));\n    vec3 ww = lookdir * (1.0 / tan(fov*PI/360.0));\n\n    return mat3(uu, vv, ww);\n}\n\nvec3 render(vec2 uv)\n{\n    vec3 camPos = vec3(0, 11.0, 30.0);\n    vec3 camTarget = vec3(0, 1, 0);\n    \n    mat3 mat = lookAt(camPos, camTarget, 0.0, 20.0);\n    vec3 ro = camPos;\n    vec3 rd = normalize(mat * vec3(uv, 1.0));\n    \n    vec2 res = rayMarching(ro, rd);\n    if (res.y == 0.0)\n    {\n        return vec3(0.5);\n    }\n    vec3 p = ro + rd * res.x;\n    vec3 col = lighting(rd, p, res.y);\n    return col;\n}\n\nvoid mainImage(out vec4 fragcolor, in vec2 fragcoord) \n{\n    vec2 uv = 2.0 * ((fragcoord- 0.5 * iResolution.xy) / iResolution.y);\n    vec3 col = render(uv);\n    fragcolor = vec4(col,1);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tstfRN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[127, 127, 160, 160, 188], [190, 190, 221, 221, 296], [298, 298, 333, 333, 422], [424, 424, 480, 480, 778], [780, 780, 838, 838, 978], [981, 981, 1034, 1034, 1134], [1136, 1136, 1167, 1167, 1337], [1339, 1339, 1370, 1370, 1544], [1546, 1546, 1578, 1578, 1750], [1752, 1752, 1782, 1782, 1815], [1817, 1817, 1836, 1836, 4390], [4392, 4392, 4416, 4416, 4682], [4684, 4684, 4720, 4720, 4953], [4955, 4955, 4987, 4987, 5392], [5394, 5394, 5428, 5428, 5834], [5836, 5836, 5883, 5883, 6599], [6601, 6601, 6663, 6663, 6930], [6932, 6932, 6954, 6954, 7343], [7345, 7345, 7401, 7401, 7532]], "test": "valid"}
{"id": "tsVcWt", "name": "Storm in a teacup", "author": "dean_the_coder", "description": "This started with me trying to work out how to make a cloud, and then developed from there.\nThe sea and plane are deliberately voxel-y, partly to keep the frame rate up and partly coz I just like it.\nNo airplanes were harmed in the making of this shader.", "tags": ["3d", "raymarching", "water", "cineshader"], "likes": 56, "viewed": 4242, "published": "Public API", "date": "1605367661", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Processed by 'GLSL Shader Shrinker' (Shrunk by 501 characters)\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n// Storm in a teacup\n//\n// This started with me trying to work out how to make a cloud,\n// and then kinda developed from there...\n// The sea and plane are deliberately voxel-y, partly\n// to keep the frame rate up and partly coz I just like it. :)\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\nfloat time, flash, glow;\n\nstruct MarchData {\n\tfloat d;\n\tvec3 mat; // RGB\n\tbool isCloud;\n};\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat noise(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\th = mix(fract(sin(h) * 43758.545), fract(sin(h + s.x) * 43758.545), p.x);\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat noise(float n) {\n\tfloat flr = floor(n);\n\tvec2 rndRange = fract(sin(vec2(flr, flr + 1.) * 12.9898) * 43758.545);\n\treturn mix(rndRange.x, rndRange.y, fract(n));\n}\n\nfloat smin(float a, float b, float k) {\n\tfloat h = clamp(.5 + .5 * (b - a) / k, 0., 1.);\n\treturn mix(b, a, h) - k * h * (1. - h);\n}\n\nMarchData minResult(MarchData a, MarchData b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a),\n\t      s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max(q.y, q.z)), 0.);\n}\n\nfloat sdCappedCylinder(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xy), p.z)) - vec2(h, r);\n\treturn min(max(d.x, d.y), 0.) + length(max(d, 0.));\n}\n\nMarchData sdSea(vec3 p, const float bowlInner) {\n\tMarchData result;\n\tresult.isCloud = false;\n\tmat2 r = rot(23.23);\n\tvec2 af = vec2(1);\n\tfloat t = time * .4,\n\t      wave = noise(p.x);\n\tfor (int i = 0; i < 8; i++) {\n\t\twave += (1. - abs(sin((p.x + t) * af.y))) * af.x;\n\t\tp.xz *= r;\n\t\taf *= vec2(.5, 1.64);\n\t}\n\n\tresult.d = max(p.y + 1. - wave * .3, bowlInner);\n\tresult.mat = vec3(.03, .09, .12) * wave;\n\treturn result;\n}\n\nMarchData sdCup(vec3 p) {\n\tMarchData result;\n\tresult.mat = vec3(1);\n\tresult.isCloud = false;\n\tfloat bowlInner = length(p) + p.y * .1 - 2.;\n\tresult.d = smin(max(abs(bowlInner) - .06, p.y), max(max(abs(length(p.xy - vec2(2, p.x * p.x * .1 - 1.1)) - .5) - .06, abs(p.z) - .06), -bowlInner), .1);\n\treturn minResult(result, sdSea(p, bowlInner));\n}\n\nfloat sdSaucer(vec3 p) {\n\tfloat l = length(p.xz);\n\tp.y += 1.9 - l * (.1 + .02 * smoothstep(0., .1, l - 2.05));\n\treturn sdCappedCylinder(p.xzy, 2.6, .01) - .02;\n}\n\nvec3 getRayDir(vec3 ro, vec2 uv) {\n\tvec3 forward = normalize(-ro),\n\t     right = normalize(cross(vec3(0, 1, 0), forward));\n\treturn normalize(forward + right * uv.x + cross(forward, right) * uv.y);\n}\n\nfloat sdCloud(vec3 p) {\n\tfloat n = abs(smoothstep(0., 1., (noise(p * 4.) + noise(p * 9.292 - vec3(0, time, 0)) * .4) * .3) - .4) + .55;\n\tp.y -= 1.3;\n\treturn min(length(p + vec3(.4, 0, 0)), length(p - vec3(.4, 0, 0))) - n;\n}\n\nMarchData sdPlane(vec3 p) {\n\tMarchData result;\n\tresult.mat = vec3(.29, .33, .13);\n\tresult.isCloud = false;\n\n\t// Scale, position, rotate.\n\tp *= 1.5;\n\tp.xz *= rot(time * .6);\n\tp.xy -= vec2(1.5, .4);\n\tp.xy *= rot(sin(time * 3.) * .1);\n\n\t// Fuselage.\n\tvec3 ppp,\n\t     pp = p + vec3(0, 0, .15);\n\tresult.d = sdBox(pp, vec2(.04 + pp.z * .05, .3).xxy);\n\n\t// Prop.\n\tppp = pp;\n\tppp.z -= .33;\n\tppp.xy *= rot(time * 8.);\n\tfloat d = sdBox(ppp, vec3(.09, .01 * sin(length(p.xy) * 34.), .005));\n\n\t// Tail.\n\tpp.yz += vec2(-.05, .26);\n\tresult.d = min(min(result.d, sdBox(pp, vec3(.01, .06 * cos(pp.z * 25.6), .03))), sdBox(pp + vec3(0, .05, 0), vec3(.15 * cos(pp.z * 12.), .01, .03)));\n\n\t// Wings\n\tp.y = abs(p.y) - .08;\n\tresult.d = min(result.d, sdBox(p, vec3(.3, .01, .1)));\n\tif (d < result.d) {\n\t\tresult.d = d;\n\t\tresult.mat = vec3(.05);\n\t}\n\n\tresult.d = (result.d - .005) * .4;\n\treturn result;\n}\n\n// Map the scene using SDF functions.\nbool hideCloud;\nMarchData map(vec3 p) {\n\tMarchData result = sdCup(p);\n\tresult.d = min(result.d, sdSaucer(p));\n\tresult = minResult(result, sdPlane(p));\n\tfloat d,\n\t      gnd = length(p.y + 1.7);\n\tif (flash > 0.) {\n\t\td = max(length(p.xz * rot(fract(time) * 3.141) + vec2(noise(p.y * 6.5) * .08) - vec2(.5, 0)), p.y - .7);\n\t\tglow += .001 / (.01 + 2. * d * d);\n\t\tif (d < result.d) result.d = d;\n\t}\n\n\tif (gnd < result.d) {\n\t\tresult.d = gnd;\n\t\tresult.mat = vec3(.2);\n\t}\n\n\tif (!hideCloud) {\n\t\td = sdCloud(p);\n\t\tif (d < result.d) {\n\t\t\tresult.d = d * .7;\n\t\t\tresult.isCloud = true;\n\t\t}\n\t}\n\n\treturn result;\n}\n\nvec3 calcNormal(vec3 p, float t) {\n\tvec2 e = vec2(.5773, -.5773) * t * 1e-4;\n\treturn normalize(e.xyy * map(p + e.xyy).d + e.yyx * map(p + e.yyx).d + e.yxy * map(p + e.yxy).d + e.xxx * map(p + e.xxx).d);\n}\n\nvec3 cloudNormal(vec3 p) {\n\tconst vec2 e = vec2(.5773, -.5773);\n\treturn normalize(e.xyy * sdCloud(p + e.xyy) + e.yyx * sdCloud(p + e.yyx) + e.yxy * sdCloud(p + e.yxy) + e.xxx * sdCloud(p + e.xxx));\n}\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n\t// Thanks iq.\n\tvec3 rd = normalize(lightPos - p);\n\tfloat res = 1.,\n\t      t = .1;\n\tfor (float i = 0.; i < 32.; i++) {\n\t\tfloat h = map(p + rd * t).d;\n\t\tres = min(res, 10. * h / t);\n\t\tt += h;\n\t\tif (res < .001 || t > 3.) break;\n\t}\n\n\treturn clamp(res, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) { return map(p + h * n).d / h; }\n\nfloat cloudAo(vec3 p, vec3 n, float h) { return sdCloud(p + h * n) / h; }\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, float d, MarchData data) {\n\tvec3 sunDir = normalize(vec3(6, 10, -4) - p),\n\t     n = calcNormal(p, d);\n\treturn data.mat * (max(0., dot(sunDir, n)) * mix(.4, 1., calcShadow(p, vec3(6, 10, -4))) + max(0., dot(sunDir * vec3(-1, 0, -1), n)) * .3) * dot(vec3(ao(p, n, .2), ao(p, n, .5), ao(p, n, 2.)), vec3(.2, .3, .5)) * vec3(2, 1.6, 1.4) * exp(-length(p) * .14);\n}\n\nvec3 cloudLighting(vec3 p, float den) {\n\tvec3 n = cloudNormal(p),\n\t     col = vec3(2, 1.6, 1.4) * (1. + flash);\n\treturn min(.75, den) * max(.1, dot(normalize(vec3(6, 10, -4) - p), n)) * cloudAo(p, n, 1.) * col;\n}\n\nvec3 getSceneColor(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tMarchData h;\n\tfloat d = .01,\n\t      den = 0.,\n\t      maxCloudD = 0.;\n\thideCloud = false;\n\tvec3 p, cloudP;\n\tfor (float steps = 0.; steps < 120.; steps++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\t\tif (h.d < .0015) {\n\t\t\tif (!h.isCloud) break;\n\t\t\thideCloud = true;\n\t\t\tcloudP = p;\n\t\t\tmaxCloudD = 20. - sdCloud(p + rd * 20.);\n\t\t}\n\n\t\tif (d > 55.) break; // Distance limit reached - Stop.\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\tif (hideCloud) {\n\t\tfor (float i = 0.; i < 20.; i++)\n\t\t\tden += clamp(-sdCloud(cloudP + rd * maxCloudD * i / 20.) * .2, 0., 1.);\n\t}\n\n\thideCloud = false;\n\treturn applyLighting(p, rd, d, h) + cloudLighting(cloudP, den) + vec3(glow) + flash * .05;\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord) {\n\ttime = mod(iTime, 120.);\n\tflash = step(.55, pow(noise(time * 8.), 5.));\n    \n\tvec3 col = vec3(0),\n\t     ro = vec3(0, 2, -5);\n\tro.xz *= rot(-.6);\n    \n\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n\tcol += getSceneColor(ro, getRayDir(ro, uv));\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col, vec3(.4545)), fragCoord), 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/tsVcWt.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[666, 722, 743, 743, 993], [995, 995, 1017, 1017, 1161], [1163, 1163, 1202, 1202, 1294], [1296, 1296, 1343, 1343, 1382], [1384, 1384, 1403, 1403, 1470], [1472, 1472, 1501, 1501, 1588], [1590, 1590, 1640, 1640, 1748], [1750, 1750, 1798, 1798, 2166], [2168, 2168, 2193, 2193, 2510], [2512, 2512, 2536, 2536, 2673], [2675, 2675, 2709, 2709, 2873], [2875, 2875, 2898, 2898, 3098], [3100, 3100, 3127, 3127, 3979], [4035, 4035, 4058, 4058, 4615], [4617, 4617, 4651, 4651, 4821], [4823, 4823, 4849, 4849, 5022], [5024, 5024, 5065, 5080, 5325], [5327, 5355, 5390, 5390, 5421], [5423, 5423, 5463, 5463, 5496], [5498, 5498, 5539, 5539, 5665], [5667, 5667, 5729, 5729, 6063], [6065, 6065, 6104, 6104, 6277], [6279, 6279, 6317, 6331, 6999], [7001, 7001, 7053, 7053, 7403]], "test": "valid"}
{"id": "ttBfWt", "name": "3d_four_noises23", "author": "edwardbraed", "description": "Four 3D noises (value, perlin, simplex, cellular) for visual comparison.\nUncomment \"NO_EFFECTS\" (and change other defines), to see the difference", "tags": ["perlin", "simplex", "value", "cellular", "elements"], "likes": 3, "viewed": 126, "published": "Public", "date": "1604253871", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define OCTAVES 1\n#define SCALE 8.0\n#define SPEED 0.2\n#define POINTS_IN_CELL 2.0\n\n//#define NO_EFFECTS\n\nvec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\nvec3 quantic(vec3 t)\n{\n    return t * t * t * (t * (t * 6.0 - 15.0) + 10.0);\n}\n\nfloat rand3(vec3 n) \n{ \n\treturn fract(sin(dot(n, vec3(12.9898, 4.1414, 17.9361))) * 43758.5453);\n}\n\n//----------------------------------------------------------------------------------\n//- Value noise --------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nfloat valueNoise3(vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 lp = p - ip;\n    vec3 q  = quantic(lp);\n    \n    float v1 = rand3(ip); //+ vec3(0.0, 0.0, 0.0);\n    float v2 = rand3(ip     + vec3(1.0, 0.0, 0.0));\n    float v3 = rand3(ip     + vec3(0.0, 1.0, 0.0));\n    float v4 = rand3(ip     + vec3(1.0, 1.0, 0.0));\n    \n    float v5 = rand3(ip     + vec3(0.0, 0.0, 1.0));\n    float v6 = rand3(ip     + vec3(1.0, 0.0, 1.0));\n    float v7 = rand3(ip     + vec3(0.0, 1.0, 1.0));\n    float v8 = rand3(ip     + vec3(1.0, 1.0, 1.0));\n    \n\treturn mix(mix(mix(v1,v2,q.x), mix(v3,v4,q.x), q.y),\n               mix(mix(v5,v6,q.x), mix(v7,v8,q.x), q.y), q.z);\n}\n\nfloat valueFBM3(vec3 pos, int octaves)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    for(int x = 0; x < octaves; x++)\n    {\n        ma += amplitude;\n        #ifdef NO_EFFECTS\n        \tres += valueNoise3(pos) * amplitude;\n        #else\n        \tres += abs((0.5 - valueNoise3(pos)) * amplitude * 2.0);\n        #endif\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\n//----------------------------------------------------------------------------------\n//- Perlin noise -------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nvec3 perlinVector3(vec3 p)\n{\n    float rv = rand3(p);\n    \n    if     (rv < 0.166) return vec3( 1.0,  0.0,  0.0);\n    else if(rv < 0.332) return vec3(-1.0,  0.0,  0.0);\n    else if(rv < 0.498) return vec3( 0.0,  1.0,  0.0);\n    else if(rv < 0.664) return vec3( 0.0, -1.0,  0.0);\n    else if(rv < 0.830) return vec3( 0.0,  0.0,  1.0);\n    \t\t\t\t\treturn vec3( 0.0,  0.0, -1.0);\n}\n\nfloat perlinNoise3(vec3 p)\n{\n\tvec3 ip = floor(p);\n    vec3 lp = p - ip;\n    vec3 q  = quantic(lp);\n    \n    vec3 nv1 = perlinVector3(ip); // + vec3(0.0, 0.0, 0.0);\n    vec3 nv2 = perlinVector3(ip      + vec3(1.0, 0.0, 0.0));\n    vec3 nv3 = perlinVector3(ip      + vec3(0.0, 1.0, 0.0));\n    vec3 nv4 = perlinVector3(ip      + vec3(1.0, 1.0, 0.0));\n    vec3 nv5 = perlinVector3(ip      + vec3(0.0, 0.0, 1.0));\n    vec3 nv6 = perlinVector3(ip      + vec3(1.0, 0.0, 1.0));\n    vec3 nv7 = perlinVector3(ip      + vec3(0.0, 1.0, 1.0));\n    vec3 nv8 = perlinVector3(ip      + vec3(1.0, 1.0, 1.0));\n    \n    vec3 dv1 = vec3(lp); // - vec3(0.0, 0.0, 0.0);\n    vec3 dv2 = vec3(lp      - vec3(1.0, 0.0, 0.0));\n    vec3 dv3 = vec3(lp      - vec3(0.0, 1.0, 0.0));\n    vec3 dv4 = vec3(lp      - vec3(1.0, 1.0, 0.0));\n    vec3 dv5 = vec3(lp      - vec3(0.0, 0.0, 1.0));\n    vec3 dv6 = vec3(lp      - vec3(1.0, 0.0, 1.0));\n    vec3 dv7 = vec3(lp      - vec3(0.0, 1.0, 1.0));\n    vec3 dv8 = vec3(lp      - vec3(1.0, 1.0, 1.0));\n    \n    float v1 = dot(nv1, dv1);\n    float v2 = dot(nv2, dv2);\n    float v3 = dot(nv3, dv3);\n    float v4 = dot(nv4, dv4);\n    float v5 = dot(nv5, dv5);\n    float v6 = dot(nv6, dv6);\n    float v7 = dot(nv7, dv7);\n    float v8 = dot(nv8, dv8);\n    \n\treturn mix(mix(mix(v1,v2,q.x), mix(v3,v4,q.x), q.y),\n               mix(mix(v5,v6,q.x), mix(v7,v8,q.x), q.y), q.z);\n}\n\nfloat perlinFBM3(vec3 pos, int octaves)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    for(int x = 0; x < octaves; x++)\n    {\n        ma += amplitude;\n        #ifdef NO_EFFECTS\n        \tres += (0.5 + perlinNoise3(pos)) * amplitude;\n        #else\n        \tpos.z *= 1.0 - amplitude;\n        \tres += max(perlinNoise3(pos) * amplitude, 0.0);\n        #endif\n        //res += abs(perlinNoise3(pos) * amplitude * 2.0);\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\n//----------------------------------------------------------------------------------\n//- Simplex noise ------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nvec3 simplexVector3(vec3 p)\n{   \n    const vec3 vecs[12] =  vec3[12]( vec3( 1.0,  1.0,  0.0),\n                                     vec3(-1.0,  1.0,  0.0),\n                                     vec3( 1.0, -1.0,  0.0),\n                                     vec3(-1.0, -1.0,  0.0),\n                                     vec3( 1.0,  0.0,  1.0),\n                                     vec3(-1.0,  0.0,  1.0),\n                                     vec3( 1.0,  0.0, -1.0),\n                                     vec3( 1.0,  0.0, -1.0),\n                                     vec3(-1.0,  0.0, -1.0),\n                                     vec3( 0.0,  1.0,  1.0),\n                                     vec3( 0.0, -1.0,  1.0),\n                                     vec3( 0.0, -1.0, -1.0) );\n    \n    return vecs[int(rand3(p) * 12.0)];\n}\n\n\n// this realization from: \n// http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf\nfloat simplexNoise3(vec3 p)\n{\n    const float K1 = 0.33333333; // 1.0 / 3.0 (skew factor)\n    const float K2 = 0.16666667; // 1.0 / 6.0 (unskew factor)\n    \n    float s = (p.x + p.y + p.z) * K1;\n    vec3 i = floor(p + s);\n    \n    float t = (i.x + i.y + i.z) * K2;\n    vec3 ti = i - t;\n    vec3 a = p - ti;\n    \n    vec3 o1, o2;\n    if(a.x > a.y)\n    {\n        if(a.y > a.z)\n            { o1 = vec3(1.0, 0.0, 0.0); o2 = vec3(1.0, 1.0, 0.0); } // X Y Z order\n        else if(a.x > a.z)\n            { o1 = vec3(1.0, 0.0, 0.0); o2 = vec3(1.0, 0.0, 1.0); } // X Z Y order\n        else\n            { o1 = vec3(0.0, 0.0, 1.0); o2 = vec3(1.0, 0.0, 1.0); } // Z X Y order \n    }\n    else\n    {\n        if(a.y < a.z) \n            { o1 = vec3(0.0, 0.0, 1.0); o2 = vec3(0.0, 1.0, 1.0); } // Z Y X order\n        else if(a.x < a.z) \n            { o1 = vec3(0.0, 1.0, 0.0); o2 = vec3(0.0, 1.0, 1.0); } // Y Z X order\n        else\n            { o1 = vec3(0.0, 1.0, 0.0); o2 = vec3(1.0, 1.0, 0.0); } // Y X Z order\n    }\n    \n    vec3 b = a - o1 + K2;\n    vec3 c = a - o2 + 2.0 * K2;\n    vec3 d = a - 1.0 + 3.0 * K2;\n    \n    \n    vec3 g1 = simplexVector3(i);\n    vec3 g2 = simplexVector3(i + o1);\n    vec3 g3 = simplexVector3(i + o2);\n    vec3 g4 = simplexVector3(i + 1.0);\n    \n    float t1 = 0.5 - (a.x * a.x) - (a.y * a.y) - (a.z * a.z);\n    float t2 = 0.5 - (b.x * b.x) - (b.y * b.y) - (b.z * b.z);\n    float t3 = 0.5 - (c.x * c.x) - (c.y * c.y) - (c.z * c.z);\n    float t4 = 0.5 - (d.x * d.x) - (d.y * d.y) - (d.z * d.z);\n    \n    float n1 = float(t1 > 0.0) * (t1 * t1 * t1 * t1 * dot(g1, a));\n    float n2 = float(t2 > 0.0) * (t2 * t2 * t2 * t2 * dot(g2, b));\n    float n3 = float(t3 > 0.0) * (t3 * t3 * t3 * t3 * dot(g3, c));\n    float n4 = float(t4 > 0.0) * (t4 * t4 * t4 * t4 * dot(g4, d));\n        \n    return 70.0 * (n1 + n2 + n3 + n4); // return a value in a range [-1.0 - 1.0]\n}\n\nfloat simplexFBM3(vec3 pos, int octaves)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    for(int x = 0; x < octaves; x++)\n    {\n        ma += amplitude;\n        #ifdef NO_EFFECTS\n        \tres += (0.5 + simplexNoise3(pos) * 0.5) * amplitude;\n        #else\n        \tres += abs(simplexNoise3(pos) * amplitude);\n        #endif\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\n//----------------------------------------------------------------------------------\n//- Cellular noise -----------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nfloat calcCell(vec3 pos, vec3 ipos)\n{\n    float md = 1.0; // min distance\n    for(float x = 0.1; x < POINTS_IN_CELL; x++)\n    {   \n        float ptX = rand3(ipos.xyz + x * 0.23);\n        float ptY = rand3(ipos.yxz + x * 0.16);\n        float ptZ = rand3(ipos.zxy + x * 0.09);\n        \n        md = min(md, distance(pos, ipos + vec3(ptX, ptY, ptZ)));\n    }\n    return md;\n}\n\nfloat calcCells(vec3 pos)\n{\n    float res = 1.0;\n    \n    vec3 ipos = floor(pos);\n    \n    // front side (z=-1)\n    res = min(res, calcCell(pos, ipos + vec3(-1.0, -1.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0, -1.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0, -1.0, -1.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  0.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  0.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  0.0, -1.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  1.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  1.0, -1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  1.0, -1.0)));\n    \n    // center side (z=0)\n    res = min(res, calcCell(pos, ipos + vec3(-1.0, -1.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0, -1.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0, -1.0,  0.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  0.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  0.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  0.0,  0.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  1.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  1.0,  0.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  1.0,  0.0)));\n    \n    // back side   (z=1)\n    res = min(res, calcCell(pos, ipos + vec3(-1.0, -1.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0, -1.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0, -1.0,  1.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  0.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  0.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  0.0,  1.0)));\n    \n    res = min(res, calcCell(pos, ipos + vec3(-1.0,  1.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 0.0,  1.0,  1.0)));\n    res = min(res, calcCell(pos, ipos + vec3( 1.0,  1.0,  1.0)));\n    \n    return res;\n}\n\nfloat cellularFBM3(vec3 pos, int octaves)\n{\n    float res = 0.0;\n    float ma = 0.0;\n    float amplitude = 0.7;\n    const float persistance = 0.5;\n    \n    for(int x = 0; x < octaves; x++)\n    {\n        ma += amplitude;\n        res += calcCells(pos) * amplitude;\n        //res += max(0.45, calcCells(pos) * amplitude);\n        \n        pos *= 2.0;\n        amplitude *= persistance;\n    }\n    return res / ma;\n}\n\n\n//----------------------------------------------------------------------------------\n//- Effects ------------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nvec3 seaEffect(vec3 pos)\n{\n    pos.z = iTime * 0.2;\n    pos.xy += vec2(iTime * 0.4);\n    return vec3(0.4, 0.7, 0.7) * 2.0 * cellularFBM3(pos, 1);\n}\n\nvec3 toxicEffect(vec3 pos)\n{\n    pos.z = iTime * 0.03;\n    return mix(vec3(0.0, 0.5, 0.0), vec3(0.05, 0.0 , 0.0), simplexFBM3(pos, 6) * 4.2) * 2.0;\n}\n\nvec3 cloudEffect(vec3 pos)\n{\n    pos.z = iTime * 0.8;\n    pos.xy += -iTime * 0.2;\n    return vec3(0.6, 0.6, 1.0) + vec3(perlinFBM3(pos * 0.5, 6));\n}\n\nvec3 fireEffect(vec3 pos)\n{\n    pos.z = iTime * 0.1;\n    return mix(vec3(1.0, 1.0, 0.0), vec3(0.7, 0.0, 0.0), valueFBM3(pos, 6) * 8.0) * 1.5;\n}\n\n//----------------------------------------------------------------------------------\n//- Main ---------------------------------------------------------------------------\n//----------------------------------------------------------------------------------\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    vec2 aspect = calcAspect(iResolution.xy);\n\n    vec3 nPos = vec3(vec2(uv * aspect * vec2(SCALE)), iTime * SPEED) * 1.5;\n\t\n    \n    vec3 rgb;\n    \n    #ifdef NO_EFFECTS\n        if(uv.x < 0.5 && uv.y < 0.5)\n            rgb = vec3(valueFBM3(nPos, OCTAVES));\n        else if(uv.x > 0.5 && uv.y < 0.5)\n            rgb = vec3(perlinFBM3(nPos, OCTAVES));\n        else if(uv.x > 0.5 && uv.y >= 0.5)\n            rgb = vec3(simplexFBM3(nPos, OCTAVES));\n        else\n            rgb = vec3(cellularFBM3(nPos, OCTAVES));\n    #else\n        if(uv.x < 0.5 && uv.y < 0.5)\n            rgb = fireEffect(nPos);\n        else if(uv.x > 0.5 && uv.y < 0.5)\n            rgb = cloudEffect(nPos);\n        else if(uv.x > 0.5 && uv.y >= 0.5)\n            rgb = toxicEffect(nPos);\n        else\n            rgb = seaEffect(nPos);\n    #endif\n    \n    // Output to screen\n    fragColor = vec4(rgb,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBfWt.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[104, 104, 132, 132, 349], [351, 351, 373, 373, 429], [431, 431, 453, 453, 529], [787, 787, 814, 814, 1433], [1435, 1435, 1475, 1475, 1909], [2167, 2167, 2195, 2195, 2542], [2544, 2544, 2572, 2572, 3923], [3925, 3925, 3966, 3966, 4495], [4753, 4753, 4782, 4782, 5565], [5568, 5662, 5691, 5691, 7538], [7540, 7540, 7582, 7582, 8020], [8278, 8278, 8315, 8315, 8649], [8651, 8651, 8678, 8678, 10657], [10659, 10659, 10702, 10702, 11069], [11328, 11328, 11354, 11354, 11475], [11477, 11477, 11505, 11505, 11626], [11628, 11628, 11656, 11656, 11776], [11778, 11778, 11805, 11805, 11921], [12179, 12179, 12236, 12286, 13206]], "test": "valid"}
{"id": "ttBXzw", "name": "Cube vortex", "author": "Peetu", "description": "One of the shaders used in my Assembly 2020 entry Clockwork", "tags": ["raymarching"], "likes": 4, "viewed": 71, "published": "Public", "date": "1606481421", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float E = 0.001;\n\nmat2 rot(float a) {\n\tfloat ca = cos(a);\n    float sa = sin(a);\n    return mat2(ca,sa,-sa,ca);\n}\n\nvec2 SDF(vec3 p) {\n    p.xy *= rot(p.z * .2 + iTime*.2);\n    vec3 op = p;\n    p = mod(p, vec3(1.));\n    p -= vec3(0.5);\n    \n    p.xy *= rot(p.x * .1 + p.z * .2 + iTime*.4);\n    \n    p = abs(p);\n    float f = fract(sin(dot(floor(op.xy), vec2(56.125, 34.124))));\n    return vec2(max(p.x, max(p.y, p.z)) - .2, f);\n}\n\nvec3 rayMarch(vec3 eye, vec3 ray) {\n    float depth = 0.;\n    \n    for(int i = 0; i < 250 && depth < 20.; i++) {\n    \tvec3 p = eye + ray * depth;\n        \n        vec2 data = SDF(p);\n        float dist = data.x;\n        \n        if(dist < E) {\n            vec3 col = mix(\n                vec3(0., 0.25, 0.3) + data.y * .1,\n                vec3(1.,1.,0.),\n                pow(fract(1. - (data.y * 25. + iTime * .2 + depth / 50.)), 8.));\n\n            //return vec3(data.y);\n        \treturn vec3(1. - depth*.05) * col;   \n        }\n        \n        depth+=dist;\n    }\n    \n    return vec3(0.);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n\tuv -= vec2(0.9, 0.5) + vec2(sin(iTime)*.1, sin(iTime * .3)*.1);\n    \n    // Time varying pixel color\n    vec3 col;\n    \n    vec3 eye = vec3(0., 0.3, iTime);\n    vec3 ray = normalize(vec3(uv, 2.));\n    \n    col = rayMarch(eye, ray);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ttBXzw.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[18, 18, 37, 37, 113], [115, 115, 133, 133, 428], [430, 430, 465, 465, 1022], [1024, 1024, 1081, 1131, 1461]], "test": "valid"}
{"id": "wd3BDS", "name": "Fade Out RobinA", "author": "9robin3", "description": "Fade Out", "tags": ["fadeout"], "likes": 0, "viewed": 48, "published": "Public", "date": "1605864045", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord/iResolution.xy - 0.5) * vec2(1.0, iResolution.y/iResolution.x);\n\n    float myTexture = 1.0 - length(uv)*4.0;\n    float emissiveDuration = 2.0;\n    vec3 emissiveColor = vec3(1.0,0.7,0.0);\n    float emissiveStrength = smoothstep(1.0,0.0,fract(iTime*(1.0/emissiveDuration)));\n    vec3 emissiveTotal = emissiveColor * emissiveStrength * myTexture;\n\n    // Output to screen\n    fragColor = vec4(emissiveTotal,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3BDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 544]], "test": "valid"}
{"id": "wd3BWM", "name": "Pistons firing up 4x800bhp", "author": "nurof3n", "description": "welcome back to bottom gear m8s", "tags": ["cars"], "likes": 13, "viewed": 155, "published": "Public", "date": "1606417327", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float CRANK_RADIUS = 0.16;\t\t\nconst float ROD_LENGTH\t = 0.5;\nconst float PI \t\t\t = 3.141592;\n\nvec2 rotate(vec2 p, float theta) {\n\treturn vec2(p.x * cos(theta) - p.y * sin(theta),\n                p.x * sin(theta) + p.y * cos(theta)); \n}\n\nfloat sdBox( in vec2 p, in vec2 b ) {\t//iq\n    vec2 d = abs(p)-b;\n    return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\n}\n\nfloat disttoline(vec2 a, vec2 b, vec2 p) {\n \treturn abs( (b.y-a.y)*p.x - (b.x-a.x)*p.y + b.x*a.y-a.x*b.y ) / sqrt( dot(b-a, b-a) ) \n        * (length(a-p) + length(b-p) - length(a-b) < 0.001 ? 1.0 : 3000.0);   \n}\n\nfloat sq(float x) {\n    return x*x;\n}\n\nfloat angleDistance(float alfa, float beta) {\n    float dist = mod(abs(alfa - beta), 2.0 * PI);\n    return min(dist, 2.0*PI - dist);\n}\n\nvec3 drawPiston(vec3 color, vec2 uv, vec2 position, float thetaOffset) {\n\tuv -= position;\n    \n    // background color\n    \n    \n    // change color of the circle\n    vec3 color2 = vec3(0.7*sin(iTime + thetaOffset), 0.7*cos(iTime + thetaOffset), 0.3);\n    color = mix(color2, color, smoothstep(0.0, 0.005, abs(length(uv) - CRANK_RADIUS)));  \n    \n    \n    // inside filling\n    float de = step(abs(uv.y), 0.017) * step(-0.03, uv.x) * step(uv.x, 0.0);\n    float polarAngle = atan(uv.y, -uv.x) + PI;\n    float theta = iTime * iTime + thetaOffset;\n    float angleMax = mod(-theta, 2.0*PI);\n    float angleMax2 = mod(-theta + PI, 2.0*PI);\n    \n    vec2 circlePoint = vec2(cos(theta), sin(theta)) * CRANK_RADIUS;\n    vec2 slidingPoint = vec2(CRANK_RADIUS*cos(theta) + sqrt(sq(ROD_LENGTH) - sq(CRANK_RADIUS)*sq(sin(theta))), 0.0);\n    \n    vec2 rotated = rotate(uv, -theta) - vec2(0.1, 0.);\n    float polarAngle2 = atan(rotated.y, rotated.x) + PI;\n    \n    // draw crank\n    color = mix(color, vec3(0.1), smoothstep(0.155, 0.145, length(uv))\n               \t\t\t\t\t  * smoothstep(0.75, 0.7, angleDistance(0.0, polarAngle2)));\n    color = mix(vec3(0.1), color, smoothstep(0.0, 0.005, sdBox(rotate(uv - circlePoint/2.0f, -theta), vec2(CRANK_RADIUS/2.0f, 0.045))));\n    color = mix(color, vec3(0.4), smoothstep(0.15, 0.14, length(uv))\n               \t\t\t\t\t  * smoothstep(0.7, 0.65, angleDistance(0.0, polarAngle2)));\n    color = mix(vec3(0.4), color, smoothstep(0.0, 0.005, sdBox(rotate(uv - circlePoint/2.0f, -theta), vec2(CRANK_RADIUS/2.0f, 0.04))));\n    \n    \n    // draw crank center\n    color = mix(vec3(0.1), color, smoothstep(0.035, 0.04, length(uv)));\n    color = mix(vec3(0.5), color, smoothstep(0.03, 0.035, length(uv)));\n    \n    color = mix(color, vec3(0.1), smoothstep(0.065, 0.06, length(uv - circlePoint))\n               \t\t\t\t\t  * smoothstep(0.03, 0.035, length(uv - circlePoint))\n               );\n    \n    // draw rod\n    vec2 rodVector = slidingPoint - circlePoint;\n    float angle = atan(rodVector.y, -rodVector.x) + PI;\n    color = mix(vec3(0.1), color, smoothstep(0.0, 0.01, sdBox(rotate(uv - (slidingPoint+circlePoint)/2.0f, angle), vec2(ROD_LENGTH/2.0f, 0.025))) );\n    color = mix(vec3(0.4), color, smoothstep(0.0, 0.01, sdBox(rotate(uv - (slidingPoint+circlePoint)/2.0f, angle), vec2(ROD_LENGTH/2.0f, 0.02))) );\n   \n    // draw crank pin\n    color = mix(color, vec3(0.4), smoothstep(0.06, 0.055, length(uv - circlePoint))\n               \t\t\t\t\t  * smoothstep(0.03, 0.035, length(uv - circlePoint))\n               );\n    color = mix(vec3(0.1), color, smoothstep(0.035, 0.04, length(uv - circlePoint)));\n    color = mix(vec3(0.4), color, smoothstep(0.03, 0.035, length(uv - circlePoint)));\n    \n    // draw piston head\n    color = mix(color, vec3(0.1), smoothstep(0.005, 0.0, \n                                             sdBox(uv - slidingPoint - vec2(0.02,0.0), vec2(0.135 + 0.025*step(uv.x - slidingPoint.x, 0.0)*smoothstep(0.0, 0.2, abs(uv.y)), 0.155)))\n               \t\t\t\t\t\t\t     * smoothstep(0.04, 0.05, length(uv - slidingPoint))\n               \t\t\t\t\t\t\t\t);\n\tcolor = mix(color, vec3(0.3), smoothstep(0.005, 0.0, \n                                             sdBox(uv - slidingPoint - vec2(0.02,0.0), vec2(0.13 + 0.025*step(uv.x - slidingPoint.x, 0.0)*smoothstep(0.0, 0.2, abs(uv.y)), 0.15)))\n               \t\t\t\t\t\t\t     * smoothstep(0.04, 0.05, length(uv - slidingPoint))\n               \t\t\t\t\t\t\t\t);\n    color = mix(color, vec3(0.1), smoothstep(0.005, 0.0, \n                                             sdBox(uv - slidingPoint - vec2(0.1, 0.0), vec2(0.005, 0.1525)))      \t\t\t\t\t\t\t\n               \t\t\t\t\t\t\t\t);\n    color = mix(color, vec3(0.1), smoothstep(0.005, 0.0, \n                                             sdBox(uv - slidingPoint - vec2(0.12, 0.0), vec2(0.005, 0.1525)))      \t\t\t\t\t\t\t\n               \t\t\t\t\t\t\t\t);\n    color = mix(color, vec3(0.1), smoothstep(0.005, 0.0, \n                                             sdBox(uv - slidingPoint - vec2(0.14, 0.0), vec2(0.005, 0.1525)))      \t\t\t\t\t\t\t\n               \t\t\t\t\t\t\t\t);\n\tcolor = mix(vec3(0.4), color, smoothstep(0.03, 0.035, length(uv - slidingPoint))); \n    color = mix(color, vec3(0.1), smoothstep(0.03, 0.035, length(uv - slidingPoint))\n               \t\t\t\t\t  * smoothstep(0.05, 0.045, length(uv - slidingPoint))); \n    \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // ndc\n    vec2 uv = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n    float c = uv.x;\n    uv.x = uv.y;\n    uv.y = -c;\n    \n\tvec3 backg = vec3(0.9,0.8,0.6) * pow(2.0, -length(uv));\n    vec3 color = backg; \n    color = drawPiston(color, uv, vec2(-0.25, 0.75), PI);\n    color = drawPiston(color, uv, vec2(-0.25, 0.25), 0.0);\n    color = drawPiston(color, uv, vec2(-0.25, -0.25), 0.0);\n    color = drawPiston(color, uv, vec2(-0.25, -0.75), PI);\n    \n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3BWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[98, 98, 132, 132, 239], [241, 241, 278, 283, 367], [369, 369, 411, 411, 581], [583, 583, 602, 602, 620], [622, 622, 667, 667, 756], [758, 758, 830, 830, 5059], [5061, 5061, 5118, 5129, 5604]], "test": "valid"}
{"id": "Wd3BWX", "name": "checkerboard animation 9", "author": "DjinnKahn", "description": "for https://isohedral.ca/swirled-series/", "tags": ["checkerboard"], "likes": 7, "viewed": 70, "published": "Public", "date": "1606084282", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nfloat sqr( float x ) { return x * x; }\n\nfloat easeInOutQuad( float x ) \n{\n    x = clamp( x, 0., 1. );\n\treturn x < 0.5 ? 2. * x * x : 1. - sqr(-2. * x + 2.) / 2.;\n}\n\nvec2 rot( vec2 p, float angle )\n{\n    return vec2( p.x * cos(angle) + p.y * sin(angle), p.x * -sin(angle) + p.y * cos(angle) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(.2,.2,.2,1.0);\n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    if ( uv.x < -.5 || uv.x >= .5 )\n        return;\n    \n    uv += vec2( .0001 ); // without this, lines aren't perfectly straight at iTime==0, not sure why\n    \n    fragColor = vec4(.0,.0,.0,1.0);\n    \n    \n    bool on = false;\n\n    float t = fract( iTime/2. );        \n    uv.x += easeInOutQuad( t ) / 8.;\n    \n    t = t * 3.;\n    t -= length(uv) * .3;\n    \n    for ( int axis = 0; axis < 2; axis++ )\n    {\n        for ( int i = -5; i <= 5; i++)\n        {\n            float a = t+float(-abs(i))*.3;\n            vec2 p = rot( vec2( float(i) / 8., 0. ), easeInOutQuad(a)*PI/2. );\n            vec2 v = rot( vec2( 1., 0. ), easeInOutQuad(a)*PI/2. );\n            if ( dot( uv - p, v ) >= 0. )\n                on = !on;\n        }\n        uv = rot( uv, PI/2. );\n    }\n    \n    \n    \n        \n    fragColor = vec4(vec3(on?1.:0.),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3BWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 48, 48, 64], [66, 66, 99, 99, 189], [191, 191, 224, 224, 320], [322, 322, 379, 379, 1309]], "test": "valid"}
{"id": "Wd3BzB", "name": "Julia set distance Lissajous", "author": "Atchafalaya", "description": "Computing an approximation of the distance to a Julia set with the c parameter following a Lissajous curve.\nInspired by Iigo Quilez's work and article https://www.iquilezles.org/www/articles/distancefractals/distancefractals.htm", "tags": ["fractal", "julia", "lissajou"], "likes": 2, "viewed": 93, "published": "Public", "date": "1605376485", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nComputing an approximation of the distance to a Julia set \nwith the c parameter following a Lissajous curve.\n\nInspired by Iigo Quilez's work and article https://www.iquilezles.org/www/articles/distancefractals/distancefractals.htm\nRelated work :\nhttps://www.shadertoy.com/view/wd3BDM\nhttps://www.shadertoy.com/view/3d3BWH\n*/\n\n#define R iResolution\n#define BAILOUT_THRESHOLD 10000.\n#define MAX_ITERATION 512\n#define PI 3.1415\n\nfloat juliaDist(vec2 z, vec2 c)\n{\n    float lz2 = 0.;\n    vec2 dz = vec2(1., 0.);\n    int i = 0;\n    while (i < MAX_ITERATION && lz2 < BAILOUT_THRESHOLD)\n    {\n        dz = 2. * vec2(z.x * dz.x - z.y * dz.y,\n                       z.x * dz.y + z.y * dz.x);\n        z = vec2(z.x * z.x - z.y * z.y,\n                 2. * z.x * z.y)\n            + c;\n        lz2 = dot(z, z);\n        i++;\n    }\n    if (lz2 < BAILOUT_THRESHOLD)\n    {\n        return -1.;\n    }\n    else\n    {\n        float k = pow(2., -float(i));\n\t\treturn sqrt(lz2 / dot(dz, dz)) * (1. - pow(lz2, -k)) / k;\n\n        return sqrt(lz2) * 0.5 * log(lz2) / length(dz);\n    }\n}\n\nvec3 palette(float dist)\n{\n    if (dist < 0.)\n    {\n        return vec3(1., 0.6, 0.);\n    }\n    else \n    {\n        vec3 col = vec3(1., 0.6, 0.) * (0.8 + 0.2 * cos(30. * dist));\n        col *= 1. - (1. / (1. + 25. * dist));\n        col = mix(col, vec3(.8), smoothstep(0.02, 0., dist));\n        return col;\n    }\n}\n\nvec2 lissajous(float u)\n{\n    u *= 2. * PI;\n    return vec2(0.8 * sin(u) + 0.5 * cos(3. * u) + 0.2 * sin(9. * u),\n                0.8 * cos(u + 0.8) - 0.4 * sin(4. * u) + 0.1 * sin(8. * u));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (2. * fragCoord - R.xy) / R.x;\n    vec2 mouse = (2. * iMouse.xy - R.xy) / R.x;\n    \n    float zoom = 2.5;\n    uv *= zoom;\n    mouse *= zoom;\n    \n    vec2 c;\n    if (iMouse.z > 0. || iMouse.w > 0.)\n    {\n        c = mouse;\n    }\n    else\n    {\n        c = lissajous(0.07 * iTime);\n    }\n    \n    vec3 col;\n    vec3 colJulia = palette(juliaDist(uv, c));\n    \n    float dist2C = dot(uv - c, uv - c);\n    float pointRadius = 0.005;\n    if (dist2C < pointRadius)\n    {\n        col = vec3(0.1, 0.9, 0.1);\n        col = mix(col, vec3(0.), step(0.75 * pointRadius, dist2C));\n        col = mix(col, colJulia, 1. - exp(500. * (0.75 * pointRadius - dist2C)));\n    }\n    else\n    {\n   \t\tcol = colJulia;\n    }\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3BzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[431, 431, 464, 464, 1064], [1066, 1066, 1092, 1092, 1379], [1381, 1381, 1406, 1406, 1573], [1575, 1575, 1632, 1632, 2407]], "test": "valid"}
{"id": "wd3fDB", "name": "Cosmic Anus Giving Birth", "author": "davor", "description": "First experiment. Starts slow, gets crazy.", "tags": ["colors"], "likes": 0, "viewed": 43, "published": "Public", "date": "1605881318", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy*2.-1.;\n    \n    float timeb = iTime * (1.0 +min(max(log(iTime/100.),0.0),4.0));\n    float a = trunc(timeb);\n    float b = fract(timeb);\n    \n    float time = a *1.0 + smoothstep(0.0, 1.0-min(max(log(iTime/100.),0.0),0.95), b*1.)+sin(log(iTime))*0.0001;\n\n    \n    float t = time*(cos(time*2.11+2000.)*0.0123623)+0.3;\n    float t2 = time*(sin(time*2.13)*0.0347332)+0.6;\n    float l = length(uv)*1.;\n    float dist1 = smoothstep(sin(t+uv.x*sin(uv.x*t))*0.523625+0.666223,   cos(t+uv.y*cos(uv.y*t2))*0.52355+0.75364   + sin(t)*0.55, l);\n    float dist2 = smoothstep(sin(t+uv.x*sin(uv.x*t*t2))*0.52355+0.565325, cos(t+uv.y*cos(uv.y*t2))*0.452355+0.75346 + sin(t)*0.14, l);\n    float dist3 = smoothstep(sin(t+uv.x*sin(uv.x*t))*0.51666+0.566236, cos(t+uv.y*cos(uv.y*t*t2))*0.122355+0.834635 + sin(t)*0.21, l);\n    \n    vec3 col1 = vec3(dist1, dist2, dist3);\n    vec3 col2 = vec3(fract(cos(uv.x*0.2+t)+fragCoord.x), fract(atan(uv.y*0.5-t+fragCoord.y)), fract(sin(uv.y*uv.x*0.1+t2*0.2+fragCoord.x+fragCoord.y)));\n    \n    vec3 col = mix(col1, col2, sin(t+l*10.)/6.+0.2);\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3fDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 1192]], "test": "valid"}
{"id": "Wd3fDH", "name": "Ekranoplan", "author": "dr2", "description": "The \"Caspian Sea Monster\" - an unsuccessful ocean skimmer", "tags": ["ocean", "aircraft", "flight", "wake"], "likes": 24, "viewed": 305, "published": "Public API", "date": "1604928349", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Ekranoplan\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define AA  0   // (= 0/1) optional antialiasing\n\nfloat PrBoxDf (vec3 p, vec3 b);\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r);\nfloat PrBox2Df (vec2 p, vec2 b);\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat PrCapsDf (vec3 p, float r, float h);\nfloat SmoothMin (float a, float b, float r);\nfloat SmoothMax (float a, float b, float r);\nmat3 DirVuMat (vec3 vd);\nvec2 Rot2D (vec2 q, float a);\nfloat Noisefv2 (vec2 p);\nvec2 Noisev2v4 (vec4 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\nvec3 sunDir, qHit, flyPos, flyVel;\nfloat tCur, dstFar, flyRol, tDor, wkFac;\nint idObj;\nconst int idFus = 1, idCkp = 2, idEng = 3, idHul = 4, idWngT = 5, idWngM = 6, idTail = 7,\n   idFlt = 8, idESup = 9, idTCap = 10, idCov = 11, idMis = 12, idSil = 13;\nconst float pi = 3.1415927;\n\n#define VAR_ZERO min (iFrame, 0)\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d, r, s, de, dc;\n  dMin = dstFar;\n  p -= flyPos;\n  p.xy = Rot2D (p.xy, flyRol);\n  q = p;\n  r = 1.;\n  if (q.z < -0.5) {\n    s = q.z + 0.5;\n    s *= s;\n    r *= 1. - 0.025 * s;\n    q.y -= 0.015 * s;\n  } else if (q.z > 2.5) {\n    s = q.z - 2.5;\n    s *= s;\n    r *= 1. - 0.04 * s;\n    q.y -= -0.02 * s;\n  }\n  d = PrCapsDf (q, r, 6.);\n  q = p;\n  dc = (tDor < 0.4) ? dstFar : PrBoxDf (q - vec3 (0., 0.8, -0.5), vec3 (0.35, 0.5, 1.));\n  d = max (d, - dc);\n  DMINQ (idFus);\n  q = p;\n  q.yz -= vec2 (0.6, -0.5);\n  d = PrRoundBoxDf (q, vec3 (0.35, 0.2, 1.2), 0.3);\n  d = max (d, - dc);\n  DMINQ (idCov);\n  s = smoothstep (0.2, 0.3, abs (tDor - 0.7));\n  q = p;\n  q.yz -= vec2 (0.6, -0.4);\n  d = PrCylDf (q.xzy, 0.08, 0.3 + 0.6 * (1. - s));\n  DMINQ (idSil);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.15, 1.4 - 0.5 * s, -0.5);\n  q.yz = Rot2D (q.yz, 0.1 * pi * (1. - s));\n  d = max (PrCapsDf (q, 0.12, 0.8), -0.8 - q.z);\n  DMINQ (idMis);\n  q = p;\n  q.yz -= vec2 (0.5, 3.2);\n  d = PrCapsDf (q, 0.5, 1.);\n  DMINQ (idCkp);\n  q = p;\n  q.x = abs (abs (abs (q.x) - 2.1) - 0.5);\n  q -= vec3 (0.25, 0.22, 4.);\n  r = 0.22 * (1. - 0.2 * q.z * q.z);\n  de = PrCapsDf (q, r, 0.7);\n  d = SmoothMax (abs (de) - 0.02, abs (q.z) - 0.8, 0.02);\n  d = min (d, PrCapsDf (q + vec3 (0., 0., -0.05), 0.125, 0.65));\n  DMINQ (idEng);\n  q = p;\n  q.yz -= vec2 (0.22, 4.);\n  r = 0.1 * (1. - 3. * q.z * q.z);\n  d = max (PrRoundBoxDf (q, vec3 (2.9, r, 0.5), 0.1), - de);\n  DMINQ (idESup);\n  q = p;\n  q.yz -= vec2 (-0.4, 0.5 + 0.1 * abs (q.x));\n  r = 0.05 * (1. - 0.3 * q.z * q.z);\n  d = PrRoundBoxDf (q, vec3 (5., r, 1.7 - 0.1 * abs (q.x)), 0.02);\n  DMINQ (idWngM);\n  q.x = abs (q.x) - 5.;\n  s = q.z * q.z;\n  q.y -= -0.15 + 0.03 * s;\n  d = PrCapsDf (q, 0.3 - 0.05 * s, 1.5);\n  DMINQ (idFlt);\n  q = p;\n  q.yz -= vec2 (1.5, -5.);\n  q.z -= -0.1 * q.y;\n  r = 0.1 * (1. - 1.4 * q.z * q.z - 0.3 * q.y);\n  d = PrRoundBoxDf (q, vec3 (r, 1., 0.8 - 0.1 * q.y), 0.02);\n  DMINQ (idTail);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, 1.7, -4.6);\n  r = 0.22 * (1. - 0.2 * q.z * q.z);\n  de = PrCapsDf (q, r, 0.7);\n  d = SmoothMax (abs (de) - 0.02, abs (q.z) - 0.8, 0.02);\n  d = min (d, PrCapsDf (q + vec3 (0., 0., -0.05), 0.125, 0.65));\n  DMINQ (idEng);  \n  q = p;\n  q.yz -= vec2 (1.7, -4.8);\n  d = max (PrRoundBoxDf (q, vec3 (0.3, 0.02, 0.5), 0.02), - de);\n  DMINQ (idESup);  \n  q = p;\n  q.yz -= vec2 (2.5, -5.1) + vec2 (0.1, -0.2) * abs (q.x);\n  r = 0.05;\n  s = q.z - 0.1;\n  r *= 1. - 1.5 * s * s - 0.1 * abs (q.x);\n  d = PrRoundBoxDf (q, vec3 (4., r, 0.7 - 0.05 * abs (q.x)), 0.02);\n  DMINQ (idWngT);\n  q = p;\n  q.yz -= vec2 (2.5, -4.9);\n  s = q.z - 0.4;\n  r = 0.2 * (1. - 0.4 * s * s);\n  d = PrCapsDf (q, r, 1.);\n  DMINQ (idTCap);\n  q = p;\n  q.z -= 2.5;\n  r = 0.7;\n  if (q.z > 0.) {\n    s = q.z * q.z;\n    r *= 1. - 0.1 * s;\n  } else {\n    s = 0.;\n    r *= 1. - 0.01 * q.z * q.z;\n  }\n  q.y -= -1. + 0.025 * s;\n  r *= 1. + 0.2 * q.y;\n  d = PrRoundBoxDf (q, vec3 (r, 0.5 - 0.05 * s, 5. + 0.2 * q.y), 0.05);\n  q.x = abs (q.x);\n  q.xy -= vec2 (0.6, -0.5);\n  d = SmoothMax (d, 0.5 - length (q.xy), 0.05);\n  DMINQ (idHul);\n  q = p;\n  q.x = abs (q.x);\n  q -= vec3 (0.5, -0.3, 6.);\n  d = PrCapsDf (q, 0.03, 0.5);\n  DMINQ (idSil);\n  return 0.7 * dMin;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  float dHit, d;\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 220; j ++) {\n    d = ObjDf (ro + dHit * rd);\n    if (d < 0.0005 || dHit > dstFar) break;\n    dHit += d;\n  }\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat WaveHt (vec2 p, float d)\n{\n  mat2 qRot;\n  vec4 t4, v4;\n  vec2 q, t, tw, cs;\n  float wFreq, wAmp, h;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8);\n  wFreq = 0.6;\n  wAmp = 0.1;\n  tw = 0.5 * tCur * vec2 (1., -1.);\n  q = p;\n  q += flyVel.xz * tCur;\n  h = 0.;\n  for (int j = VAR_ZERO; j < 5; j ++) {\n    q *= qRot;\n    t4 = abs (sin (wFreq * (q.xyxy + tw.xxyy) + 2. * Noisev2v4 (t4).xxyy - 1.));\n    v4 = (1. - t4) * (t4 + sqrt (1. - t4 * t4));\n    t = 1. - sqrt (v4.xz * v4.yw);\n    t *= t;\n    h += wAmp * dot (t, t);\n    wFreq *= 2.;\n    wAmp *= 0.5;\n  }\n  h += 0.3 * wkFac * (1. - smoothstep (0.3, 1.5, length (vec2 (abs (p.x) - 1.3, 0.1 * p.y + 1.1))));\n  return h * (1. - smoothstep (0.5, 1., d / dstFar));\n}\n\nfloat WaveRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 60; j ++) {\n    p = ro + s * rd;\n    h = p.y - WaveHt (p.xz, s);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, h) + 0.01 * s;\n    if (s > dstFar) break;\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > WaveHt (p.xz, s)) sLo = s;\n      else sHi = s;\n    }\n    dHit = sHi;\n  }\n  return dHit;\n}\n\nvec3 WaveNf (vec3 p, float d)\n{\n  vec2 e;\n  e = vec2 (max (0.1, 1e-4 * d * d), 0.);\n  return normalize (vec3 (WaveHt (p.xz, d) - vec2 (WaveHt (p.xz + e.xy, d),\n     WaveHt (p.xz + e.yx, d)), e.x)).xzy;\n}\n\nvec4 FlyerCol ()\n{\n  vec4 col4, col4S;\n  vec2 w;\n  float s;\n  w = vec2 (0.);\n  if (idObj == idCov || idObj == idWngT || idObj == idWngM || idObj == idESup) w = qHit.xz;\n  else if (idObj == idFus || idObj == idCkp || idObj == idEng || idObj == idTCap || idObj == idFlt)\n     w = vec2 (4. * atan (qHit.y, - qHit.x) / (2. * pi), qHit.z);\n  else if (idObj == idTail) w = qHit.yz;\n  col4 = vec4 (0.9, 0.93, 0.9, 0.2);\n  if (w.x != 0.) col4 *= 0.9 + 0.1 * smoothstep (0., 0.05, abs (Fbm2 (11. + 2. * w) - 0.4) - 0.05);\n  col4S = vec4 (0., 0., 1., 0.2);\n  if (idObj == idFus) {\n    if (length (vec2 (0.9 * (qHit.y - 0.45), abs (abs (qHit.z + 0.6) - 2.4) - 0.25)) < 0.12) {\n      col4 = vec4 (0., 0., 0., -2.);\n    } else {\n      col4 = mix (col4S, col4, smoothstep (0., 0.03, abs (qHit.y + 0.1) - 0.02));\n      col4 *= 0.7 + 0.3 * smoothstep (0., 0.025, abs (PrRoundBox2Df (vec2 (qHit.y - 0.35,\n         abs (qHit.z - 0.1) - 2.4), vec2 (0.25, 0.1), 0.05)));\n      col4 *= 0.3 + 0.7 * step (0.2, PrBox2Df (qHit.xz - vec2 (0., -0.5), vec2 (0.35, 1.2)));\n    }\n  } else if (idObj == idCkp) {\n    if (qHit.z > 0.73 && qHit.y < 0.43 && min (min (abs (abs (qHit.y - 0.34) - 0.08),\n       abs (abs (qHit.z - 0.9) - 0.15)), abs (abs (qHit.x) - 0.16)) > 0.014) col4 = vec4 (0., 0., 0., -2.);\n  } else if (idObj == idCov) {\n    col4 *= 0.7 + 0.3 * smoothstep (0.01, 0.03, abs (PrBox2Df (vec2 (abs (qHit.x) - 0.175, qHit.z),\n       vec2 (0.175, 1.))));\n  } else if (idObj == idEng) {\n    col4 = mix (vec4 (1., 0., 0., 0.2), col4, smoothstep (0., 0.02, abs (qHit.z - 0.8) - 0.05));\n    if (abs (qHit.z) < 0.78 && length (qHit.xy) < 0.17) {\n      if (qHit.z < 0.) col4 = vec4 (1., 1., 0., 0.2);\n      if (abs (qHit.z - 0.05) < 0.78) col4 *= 0.7 + 0.3 * sin (8. * atan (qHit.y, - qHit.x) +\n         2. * pi * mod (16. * tCur, 1.));\n    }\n  } else if (idObj == idWngT) {\n    col4 = mix (col4S, col4, smoothstep (0., 0.03, abs (abs (abs (qHit.x) - 3.7) - 0.1) - 0.02));\n    col4 *= 0.7 + 0.3 * smoothstep (0.01, 0.03, abs (PrBox2Df (vec2 (abs (abs (qHit.x) - 2.2) - 0.6,\n       qHit.z + 0.6), vec2 (0.55, 0.3))));\n  } else if (idObj == idWngM) {\n    col4 = mix (col4S, col4, smoothstep (0., 0.03, abs (abs (abs (qHit.x) - 4.5) - 0.1) - 0.02));\n    if (qHit.y > 0.) col4 *= 0.7 + 0.3 * smoothstep (0.01, 0.03, abs (PrBox2Df (vec2 (abs (qHit.x) - 3.,\n       qHit.z + 0.09 * abs (qHit.x) + 0.2), vec2 (1., 0.2))));\n  } else if (idObj == idTail) {\n    col4 = mix (col4S, col4, smoothstep (0., 0.03, abs (qHit.y - 0.6) - 0.02));\n    col4 *= 0.7 + 0.3 * smoothstep (0.01, 0.03, abs (PrBox2Df (vec2 (qHit.y + 0.1, qHit.z + 0.75),\n       vec2 (0.5, 0.3))));\n  } else if (idObj == idTCap) {\n    if (qHit.z > 0.9) col4 = col4S;\n  } else if (idObj == idHul) {\n    col4 = mix (vec4 (0., 0.5, 0., 0.2) * (0.8 + 0.2 * Noisefv2 (16. * qHit.yz)),\n       col4 * (0.93 + 0.07 * sin (128. * sin (qHit.y))), smoothstep (0., 0.01, qHit.y - 0.5));\n  } else if (idObj == idFlt) {\n    col4 = mix (vec4 (0., 0.5, 0., 0.2) * (0.8 + 0.2 * Noisefv2 (16. * qHit.yz)),\n       col4, smoothstep (0., 0.01, qHit.y + 0.05));\n  } else if (idObj == idMis) {\n    col4 = vec4 (0.9, 0.5, 0.2, 0.2) * (0.5 + 0.5 * smoothstep (0.01, 0.03,\n       abs (abs (abs (qHit.z) - 0.6) - 0.03)));\n  }\n  return col4;\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  float sh, d, h;\n  sh = 1.;\n  d = 0.01;\n  for (int j = VAR_ZERO; j < 30; j ++) {\n    h = ObjDf (ro + d * rd);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += min (2. * h, 0.3);\n    if (sh < 0.05) break;\n  }\n  return 0.5 + 0.5 * sh;\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  rd.y = abs (rd.y);\n  return mix (vec3 (0.2, 0.4, 1.) + 0.2 * pow (1. - max (rd.y, 0.), 5.),\n     vec3 (0.85), clamp (3. * (1.5 * Fbm2 (0.02 * (rd.xz * (100. - ro.y) / rd.y + ro.xz +\n     0.5 * tCur)) - 0.1) * rd.y + 0.1, 0., 1.));\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec4 col4;\n  vec3 col, vn, vnw, row, rdw, watCol;\n  float dstObj, dstWat, f, sh, hw;\n  bool waterRefl;\n  flyVel = vec3 (0., 0., 5.);\n  flyRol = 0.005 * pi * sin (0.1 * pi * tCur);\n  wkFac = 1. - smoothstep (0.5, 1.1, flyPos.y - 1.1);\n  tDor = mod (0.1 * tCur, 1.);\n  dstObj = ObjRay (ro, rd);\n  dstWat = WaveRay (ro, rd);\n  waterRefl = (dstWat < min (dstFar, dstObj));\n  if (waterRefl) {\n    ro += dstWat * rd;\n    vnw = WaveNf (ro, dstWat);\n    row = ro;\n    rdw = rd;\n    rd = reflect (rd, vnw);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n  }\n  if (dstObj < min (dstWat, dstFar)) {\n    ro += dstObj * rd;\n    vn = ObjNf (ro);\n    col4 = FlyerCol ();\n    if (col4.a >= 0.) {\n      sh = ObjSShadow (ro + 0.01 * vn, sunDir);\n      col = col4.rgb * (0.2 + 0.2 * max (vn.y, 0.) + 0.7 * sh * max (dot (vn, sunDir), 0.)) +\n         col4.a * step (0.95, sh) * pow (max (dot (normalize (sunDir - rd), vn), 0.), 32.);\n    } else col = mix (vec3 (0.2, 0.3, 0.2), SkyCol (ro, reflect (rd, vn)), 0.5);\n  } else {\n    col = SkyCol (ro, rd);\n  }\n  if (waterRefl) {\n    f = (1. - smoothstep (0.1, 1.5, length (vec2 (0.3 * row.x, 0.06 * row.z + 1.)))) * wkFac;\n    vnw = VaryNf (row + flyVel * tCur, vnw, 1. + 5. * f);\n    watCol = mix (vec3 (0.1, 0.35, 0.4), vec3 (0.1, 0.35, 0.25),\n       smoothstep (0.4, 0.6, Fbm2 (0.25 * (row.xz + flyVel.xz * tCur)))) *\n       (0.3 + 0.7 * (max (vnw.y, 0.) + 0.1 * pow (max (0., dot (sunDir, reflect (rdw, vnw))), 32.)));\n    col = mix (watCol, 0.8 * col, 0.2 + 0.8 * pow (1. - abs (dot (rdw, vnw)), 4.));\n    col = mix (col, vec3 (1.) * (0.7 + 0.3 * Fbm2 (64. * (row.xz + flyVel.xz * tCur))), f);\n    col = mix (col, SkyCol (row, rdw), smoothstep (0.6, 0.95, dstWat / dstFar));\n  }\n  return clamp (col, 0., 1.);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 vuMat;\n  vec4 mPtr;\n  vec3 ro, rd, col;\n  vec2 canvas, uv;\n  float el, az, zmFac, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  az = 0.;\n  el = 0.15 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += 0.4 * pi * mPtr.y;\n  } else {\n    az += 0.025 * pi * tCur;\n    el -= 0.05 * pi * sin (0.04 * pi * tCur);\n  }\n  el = clamp (el, 0.07 * pi, 0.3 * pi);\n  flyPos = vec3 (0., 1.9 - 0.8 * cos (0.05 * pi * tCur), 0.);\n  ro = 22. * sin (el + vec2 (0.5 * pi, 0.)).xyx * vec3 (sin (az + vec2 (0.5 * pi, 0.)), 1.).xzy;\n  vuMat = DirVuMat (normalize (flyPos - ro));\n  zmFac = 4.;\n  dstFar = 200.;\n  sunDir = normalize (vec3 (0., 1., -1.));\n  sunDir.xz = Rot2D (sunDir.xz, 0.4 * pi * sin (0.02 * pi * tCur));\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrBoxDf (vec3 p, vec3 b)\n{\n  vec3 d;\n  d = abs (p) - b;\n  return min (max (d.x, max (d.y, d.z)), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBoxDf (vec3 p, vec3 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrBox2Df (vec2 p, vec2 b)\n{\n  vec2 d;\n  d = abs (p) - b;\n  return min (max (d.x, d.y), 0.) + length (max (d, 0.));\n}\n\nfloat PrRoundBox2Df (vec2 p, vec2 b, float r)\n{\n  return length (max (abs (p) - b, 0.)) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat PrCapsDf (vec3 p, float r, float h)\n{\n  return length (p - vec3 (0., 0., h * clamp (p.z / h, -1., 1.))) - r;\n}\n\nfloat SmoothMin (float a, float b, float r)\n{\n  float h;\n  h = clamp (0.5 + 0.5 * (b - a) / r, 0., 1.);\n  return mix (b, a, h) - r * h * (1. - h);\n}\n\nfloat SmoothMax (float a, float b, float r)\n{\n  return - SmoothMin (- a, - b, r);\n}\n\nmat3 DirVuMat (vec3 vd)\n{\n  float s;\n  s = sqrt (max (1. - vd.y * vd.y, 1e-6));\n  return mat3 (vec3 (vd.z, 0., - vd.x) / s, vec3 (- vd.y * vd.x, 1. - vd.y * vd.y,\n     - vd.y * vd.z) / s, vd);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nvec4 Hashv4f (float p)\n{\n  return fract (sin (p + vec4 (0., 1., 57., 58.)) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nvec2 Noisev2v4 (vec4 p)\n{\n  vec4 ip, fp, t1, t2;\n  ip = floor (p);\n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t1 = Hashv4f (dot (ip.xy, vec2 (1., 57.)));\n  t2 = Hashv4f (dot (ip.zw, vec2 (1., 57.)));\n  return vec2 (mix (mix (t1.x, t1.y, fp.x), mix (t1.z, t1.w, fp.x), fp.y),\n               mix (mix (t2.x, t2.y, fp.z), mix (t2.z, t2.w, fp.z), fp.w));\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3fDH.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1053, 1053, 1075, 1075, 4290], [4292, 4292, 4325, 4325, 4509], [4511, 4511, 4532, 4532, 4787], [4789, 4789, 4821, 4821, 5495], [5497, 5497, 5531, 5531, 6034], [6036, 6036, 6067, 6067, 6239], [6241, 6241, 6259, 6259, 9484], [9486, 9486, 9523, 9523, 9768], [9770, 9770, 9802, 9802, 10037], [10039, 10039, 10074, 10074, 11823], [11825, 11825, 11881, 11881, 13173], [13175, 13175, 13207, 13207, 13307], [13309, 13309, 13355, 13355, 13402], [13404, 13404, 13437, 13437, 13526], [13528, 13528, 13575, 13575, 13622], [13624, 13624, 13666, 13666, 13717], [13719, 13719, 13762, 13762, 13835], [13837, 13837, 13882, 13882, 13985], [13987, 13987, 14032, 14032, 14070], [14072, 14072, 14097, 14097, 14266], [14268, 14268, 14298, 14298, 14411], [14445, 14445, 14469, 14469, 14599], [14601, 14601, 14625, 14625, 14688], [14690, 14690, 14715, 14715, 14901], [14903, 14903, 14928, 14928, 15265], [15267, 15267, 15288, 15288, 15443], [15445, 15445, 15474, 15474, 15686], [15688, 15688, 15727, 15727, 15907]], "test": "error"}
{"id": "Wd3fDn", "name": "Filtered normal of cosinus 1", "author": "SimonL", "description": "This shader show how to extract normal from a sum of cosine functions of different phase and frequency, and how to filter analytic normals to remove aliasing in order to do better lighting effect.", "tags": ["filter", "shading", "normal", "derivation", "cosinus", "filtered"], "likes": 9, "viewed": 74, "published": "Public", "date": "1604833265", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This shader use \n//\n// https://iquilezles.org/www/articles/bandlimiting/bandlimiting.htm\n//\n// Box-filtering of cos(x):\n//\n// (1/w)cos(t)dt with t  (x-w, x+w)\n// = [sin(x+w) - sin(x-w)]/w\n// = cos(x)sin(w)/(w)\n//\n// Examples here made by Inigo Quilez:\n//   https://www.shadertoy.com/view/WtScDt\n//   https://www.shadertoy.com/view/wtXfRH\n//   https://www.shadertoy.com/view/3tScWd\n//________________________________________\n//\n// Simon LUCAS\n// 08/11/2020\n//\n// This shader show how to extract normal from a sum of cosine functions of different phase and frequency,\n// and how to filter analytic normals to remove aliasing in order to do better lighting effect.  \n//\n// You can use your mouse to select which part of the canvas you want to see.\n// You can also modify the filtering coefficient FILTERING_COEF, to modify the intensity of filtering.\n// The filtering coefficient proposed by Inigo Quilez was 0.5 to avoid over filtering. In the case of filtering\n// normals, 0.5 don't seem enough. A filtering coefficient of 1. remove almost every flickering. \n//\n// DEFORM can be set to 0, 1 or 2 to change the visuals.\n//\n// Top left \t: Analytic normal from non filtered cosinus functions.\n// Top right \t: Analytic normal from filtered cosinus functions. \n// Bottom left \t: Aliased surface generated with cosinus functions.\n// Bottom right : Anti-aliased surface generated with filtered cosinus functions.\n//\n// Related Shader:\n//  https://www.shadertoy.com/view/Wd3fDn\n//  https://www.shadertoy.com/view/ts3BWn\n//\n\n// 0, 1 or 2\n#define DEFORM 1\n\n// Filtering coefficient.\n// Define the box filtering size. \n#define FILTERING_COEF 1.\n\nvec2 deform( in vec2 p )\n{\n    // deform 1\n    #if DEFORM >= 1\n    p *= 0.25;\n    p = 0.5*p/dot(p,p);\n    p.x += iTime*0.1;\n    \n    \n    // deform 2\n    #if DEFORM >= 2\n    p += 0.1*cos( 1.5*p.yx + 0.003*1.0*iTime + vec2(0.1,1.1) );\n    p += 0.1*cos( 2.4*p.yx + 0.003*1.6*iTime + vec2(4.5,2.6) );\n    p += 0.1*cos( 3.3*p.yx + 0.003*1.2*iTime + vec2(3.2,3.4) );\n    p += 0.1*cos( 4.2*p.yx + 0.003*1.7*iTime + vec2(1.8,5.2) );\n    p += 0.1*cos( 9.1*p.yx + 0.003*1.1*iTime + vec2(6.3,3.9) );\n    #endif\n    #endif\n    return p;\n}\n\n////////////////////////////////////////////////////////////\n// derivative of cos(u)\n// cos(u) = cos(f*t+o)\n// cos'(u) = -f*sin(f*t+o)\nfloat dcos( float u,float f)\n{\n\treturn -f*sin(u);\n}\n\n/////////////////////////////////////////////////////////////\n// box-filted cos(x)\nfloat fcos( float u )\n{\n    float w = fwidth(u);\n    return cos(u) * sin(FILTERING_COEF*w)/(FILTERING_COEF*w);\n}\n\n\n//////////////////////////////////////////////////////////////\n// derivative of fcos(x)\n// cos(u)*sin(c*w(u))/(c*w(u)) = cos(f*t+o)*sin(c*w(u))/(c*w(u))\n//\n// (cos(u)*sin(c*w(u))/(c*w(u)))' =\n//\n//\t( -f * sin(u) * sin(c*w(u)) + cos(u) * c * w'(u) * cos(c*w(u)) ) * c * w(u) - cos(u) * sin(c * w(u)) * c * w'(u)\n//\t________________________________________________________________________________________________________________\n//\t\t\t\t\t\t\t\t\t\t\t\t\t(c * w(u))^2\n//\n//\n// w'(u) assumed to be fwidth(w(u)).\n// c is the filtering coefficient.\nfloat dfcos( float u, float f)\n{\n    float w = fwidth(u);\n    float dw = fwidth(w);\n    \n    return ( (-f * sin(u) * sin(FILTERING_COEF*w) + cos(u) * FILTERING_COEF * dw * cos(FILTERING_COEF * w) ) * (FILTERING_COEF*w) - cos(u) * sin(FILTERING_COEF * w) * (FILTERING_COEF*dw) )/ pow(FILTERING_COEF*w,2.);\n}\n\n\n\nfloat getIntensityFiltered( in float t )\n{\n    float col = 0.4;\n    col += 0.14*fcos(t*  1.0+0.6);\n    col += 0.13*fcos(t*  3.1+1.0);\n    col += 0.12*fcos(t*  5.1+1.1);\n    col += 0.11*fcos(t*  9.1+1.2);\n    col += 0.10*fcos(t* 17.1+0.9);\n    col += 0.09*fcos(t* 31. +11.3);\n    col += 0.08*fcos(t* 65. +11.3);\n    col += 0.07*fcos(t*131. +10.8);\n    return col;\n}\n\nfloat getIntensityFilteredGrad( in float t )\n{\n    float col = 0.;\n    col += 0.14*dfcos(t*  1.0+ 0.6, 1.0);\n    col += 0.13*dfcos(t*  3.1+ 1.0, 3.1);\n    col += 0.12*dfcos(t*  5.1+ 1.1, 5.1);\n    col += 0.11*dfcos(t*  9.1+ 1.2, 9.1);\n    col += 0.10*dfcos(t* 17.1+ 0.9, 17.1);\n    col += 0.09*dfcos(t* 31. +11.3, 31.);\n    col += 0.08*dfcos(t* 65. +11.3, 65.);\n    col += 0.07*dfcos(t*131. +10.8,131.);\n    return col;\n}\n\nfloat getIntensity( in float t )\n{\n    float col = 0.4;\n    col += 0.14*cos(t*  1.0+0.6);\n    col += 0.13*cos(t*  3.1+1.0);\n    col += 0.12*cos(t*  5.1+1.1);\n    col += 0.11*cos(t*  9.1+1.2);\n    col += 0.10*cos(t* 17.1+0.9);\n    col += 0.09*cos(t* 31. +11.3);\n    col += 0.08*cos(t* 65. +11.3);\n    col += 0.07*cos(t*131. +10.8);\n    return col;\n}\n\nfloat getIntensityGrad( in float t )\n{\n    float col = 0.;\n    col += 0.14*dcos(t*  1.0+0.6 , 1.0);\n    col += 0.13*dcos(t*  3.1+1.0 , 3.1);\n    col += 0.12*dcos(t*  5.1+1.1 , 5.1);\n    col += 0.11*dcos(t*  9.1+1.2 , 9.1);\n    col += 0.10*dcos(t* 17.1+0.9 , 17.);\n    col += 0.09*dcos(t* 31. +11.3, 31.);\n    col += 0.08*dcos(t* 65. +11.3, 65.);\n    col += 0.07*dcos(t*131. +10.8,131.);\n    return col;\n}\n\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    // coordiantes\n\tvec2 q = (2.0*fragCoord-iResolution.xy)/iResolution.y;\n\n    // separation\n    float thx = (iMouse.z>0.001) ? (2.0*iMouse.x-iResolution.x)/iResolution.y : 1.2*sin(iTime);\n    float thy = (iMouse.z>0.001) ? (2.0*iMouse.y-iResolution.y)/iResolution.y : 1.2*(iResolution.y / iResolution.x)*cos(iTime);\n    bool norm = (q.y>thy);\n    bool filt = (q.x>thx);\n    \n    // deformation\n    vec2 p = deform(q);\n    p*=6.2832;\n    \n    vec3 col;\n    if(!norm){ // original version by Inigo Quilez \n        float i;\n        if(filt){ // With filtering\n    \t\ti = min(getIntensityFiltered(p.x),getIntensityFiltered(p.y));\n        } else { // Without filtering\n    \t\ti = min(getIntensity(p.x),getIntensity(p.y));\n        }\n        col = vec3(i);\n        \n    } else {\n        float i1,i2,i;\n        vec3 normal;\n        \n        if(filt){ // With filtering\n            i1 = getIntensityFiltered(p.x);\n            i2 = getIntensityFiltered(p.y);\n            i = min(i1,i2);\n            \n            if(i == i1){\n            \tnormal.x = -getIntensityFilteredGrad(p.x);\n                normal.z = 1.;\n                normal.y = 0.;\n            } else {\n                normal.z = 1.;\n                normal.y = -getIntensityFilteredGrad(p.y);\n                normal.x = 0.;\n            }\n            \n        } else { // Without filtering\n           \ti1 = getIntensity(p.x);\n           \ti2 = getIntensity(p.y);\n           \ti = min(i1,i2);\n            \n            if(i == i1){\n            \tnormal.x = -getIntensityGrad(p.x);\n                normal.z = 1.;\n                normal.y = 0.;\n            } else {\n                normal.z = 1. ;\n                normal.y = -getIntensityGrad(p.y);\n                normal.x = 0.;\n            }\n        }\n \n        normal = normalize(normal);\n        \n        col = normal;\n    }\n    \n\t\n    \n    // separation\n    col *= smoothstep(0.005,0.010,abs(q.x-thx));\n    col *= smoothstep(0.005,0.010,abs(q.y-thy));\n    \n\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3fDn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1657, 1657, 1683, 1699, 2184], [2186, 2321, 2351, 2351, 2372], [2374, 2457, 2480, 2480, 2569], [2572, 3105, 3137, 3137, 3411], [3415, 3415, 3457, 3457, 3779], [3781, 3781, 3827, 3827, 4202], [4204, 4204, 4238, 4238, 4552], [4554, 4554, 4592, 4592, 4958], [4962, 4962, 5018, 5037, 7010]], "test": "valid"}
{"id": "wd3fR2", "name": "Fake Caustic w/Voronoi", "author": "oneshade", "description": "Caustic effect created by mixing an aqua color with white based on (smooth) minimal distances to points moving around in cells in a gridlike structure. I thought some layering was kind of cool and added that to. I might try code golfing this sometime.", "tags": ["voronoi", "caustic"], "likes": 6, "viewed": 132, "published": "Public", "date": "1605539722", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define LAYERS 2.0\n#define FREQUENCY 4.0\n#define DECAY 0.6\n#define SOFTNESS 0.1\n#define WASHOUT 0.3\n#define POWER 2.5\n\nfloat smin(in float a, in float b, in float s) {\n    float i = clamp(0.5 + 0.5 * (b - a) / s, 0.0, 1.0);\n    return mix(b, a, i) - s * i * (1.0 - i);\n}\n\nvec2 getCellPoint(in vec2 p) {\n    return 0.5 + 0.5 * vec2(sin(p.x + p.y * 2.0 + iTime), cos(p.y - p.x + 2.0 * iTime));\n}\n\nfloat voronoi(in vec2 uv, in float scale) {\n    uv *= scale;\n    vec2 cellLocation = floor(uv);\n\n    float minDist = 1000000000.0;\n    for (int i=-1; i < 2; i++) {\n        for (int j=-1; j < 2; j++) {\n            vec2 curCellLocation = cellLocation + vec2(i, j);\n            vec2 curCellPoint = curCellLocation + getCellPoint(curCellLocation);\n            minDist = smin(minDist, length(uv - curCellPoint), SOFTNESS);\n        }\n    }\n\n    return minDist;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n    float totalScale = 0.0;\n    float scale = 1.0;\n\n    for (float layer=0.0; layer < LAYERS; layer++) {\n        float voronoiSample = pow(voronoi(uv, FREQUENCY / scale), POWER);\n        color += mix(vec3(0.0, 0.7, 0.9), vec3(1.0 + WASHOUT), voronoiSample) * scale;\n        totalScale += scale;\n        scale *= DECAY;\n    }\n\n    color /= totalScale;\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wd3fR2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[119, 119, 167, 167, 270], [272, 272, 302, 302, 393], [395, 395, 438, 438, 851], [853, 853, 908, 908, 1389]], "test": "valid"}
{"id": "Wd3fzN", "name": "Pulsing Heart [cardiolda]", "author": "Osakazaur", "description": "Heart-shaped line pulsing in hertbeat rythm.\nPulsing function is cardiolda.\n\nYou can also apply pulsing circle by chaging\nfragColor = cardio(center, xy, radius);    \nto\nfragColor = circle(center, xy, radius); \nin mainImage.\n", "tags": ["2d", "red", "pulsing"], "likes": 1, "viewed": 47, "published": "Public", "date": "1604431405", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4 basCol = vec4(0.76, 0.07, 0.07, 1.0);\nfloat radius = .25;\nfloat pi = 3.14;\n\nfloat step2(float x){\n\treturn x*x;\n}\n\nfloat pulsing(){\n    float fi = fract(iTime)*2.*pi;\n\treturn (1. - cos(fi));\n}\n\n\nvec2 decToPolar(vec2 xy){\n    float x = xy.x; float y = xy.y;\n    \n    float r = sqrt(step2(x) + step2(y));\n    float fi = 0.;\n\n\tif (x > 0.){\n        if (y > 0.){fi = atan(y/x);}\n        else if (y < 0.){fi = atan(y/x) + 2.*pi;}\n        else if (y == 0.){fi = 0.;};\n    }\n    else if (x < 0.){\n        fi = atan(y/x) + pi;\n    }\n    else if (x == 0.){\n        if (y > 0.){fi = pi/2.;}\n        else if (y < 0.){fi = 3.*pi/2.;}\n        else if (y == 0.){fi = 0.;}\n    }\n    \n    return vec2(r, fi);\n}\n\nvec4 multColor(float m){\n\treturn vec4(basCol.r * m,\n               basCol.g * m,\n               basCol.b * m,\n               1.);\n}\n\nvec4 cardio(vec2 center, vec2 pos, float radius){\n    float dec = 7.5 * pulsing() + 2.5;\n    pos = vec2 ((pos.x - center.x), (pos.y - center.y));\n    vec2 rf = decToPolar(pos);\n   \n    float amp = radius * (1.-cos(rf.y - pi/2.));\n    float mult = 1. - distance(rf.x, amp) / dec;\n    \n   return multColor(mult);\n}\n\n\nvec4 circle(vec2 center, vec2 pos, float radius){\n    float dec = 10. * pulsing() + 5.;\n    pos = vec2 ((pos.x - center.x), (pos.y - center.y));\n    vec2 rf = decToPolar(pos);\n    float mult = 1. - distance(rf.x, radius) / dec;\n    \n   return multColor(mult);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    radius = radius * iResolution.y;\n    vec2 xy = fragCoord;\n\tvec2 center = vec2(iResolution.x * 0.5,\n                       iResolution.y * 0.75);\n\n\tfragColor = cardio(center, xy, radius);  \n    fragColor *= fragColor;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wd3fzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[81, 81, 102, 102, 117], [119, 119, 135, 135, 196], [199, 199, 224, 224, 697], [699, 699, 723, 723, 830], [832, 832, 881, 881, 1144], [1147, 1147, 1196, 1196, 1408], [1411, 1411, 1467, 1467, 1690]], "test": "valid"}
{"id": "WdcBD2", "name": "Testing Simplex + Raymarching", "author": "JoshStockin", "description": "Testing raymarching logic", "tags": ["raymarching"], "likes": 1, "viewed": 41, "published": "Public", "date": "1605978594", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//\tSimplex 3D Noise \n//\tby Ian McEwan, Ashima Arts\n//\nvec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nfloat snoise(vec3 v){ \n  const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n  const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n// First corner\n  vec3 i  = floor(v + dot(v, C.yyy) );\n  vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n// Other corners\n  vec3 g = step(x0.yzx, x0.xyz);\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  //  x0 = x0 - 0. + 0.0 * C \n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n// Permutations\n  i = mod(i, 289.0 ); \n  vec4 p = permute( permute( permute( \n             i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n           + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n           + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n// Gradients\n// ( N*N points uniformly over a square, mapped onto an octahedron.)\n  float n_ = 1.0/7.0; // N=7\n  vec3  ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor(p * ns.z *ns.z);  //  mod(p,N*N)\n\n  vec4 x_ = floor(j * ns.z);\n  vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs(x) - abs(y);\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n  vec4 s0 = floor(b0)*2.0 + 1.0;\n  vec4 s1 = floor(b1)*2.0 + 1.0;\n  vec4 sh = -step(h, vec4(0.0));\n\n  vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n  vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n  vec3 p0 = vec3(a0.xy,h.x);\n  vec3 p1 = vec3(a0.zw,h.y);\n  vec3 p2 = vec3(a1.xy,h.z);\n  vec3 p3 = vec3(a1.zw,h.w);\n\n//Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n// Mix final noise value\n  vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1), \n                                dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nfloat sdSphere(vec3 ray, vec3 pos, float size) {\n    return length(ray-pos)-size;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat smin(float a, float b, float k) {\n  float h = clamp(0.5 + 0.5*(a-b)/k, 0.0, 1.0);\n  return mix(a, b, h) - k*h*(1.0-h);\n}\n#define SMOOTHING 0.25\nvec3 render( in vec3 uv )\n{\n    vec3 ray = normalize(uv);\n    vec3 raydir = ray;\n    float lastdist = 1.;\n    for (int i = 0; i < 100; i++) {\n        float dist = sdSphere(ray, vec3(sin(iTime)*2., 0.0,-8.0), 1.);\n        dist = smin(dist, sdBox(ray-vec3(1.5, sin(iTime)*2., -8.0), vec3(0.6)), SMOOTHING);\n        dist = smin(dist, sdSphere(ray, vec3(sin(iTime), cos(iTime),sin(iTime)-7.), 0.5), SMOOTHING);\n        if (dist <= (0.001)) {\n            return vec3(snoise(ray));\n        } else if (lastdist <= 0.035 && dist>lastdist) { // super simple outline/edge detection\n            return vec3(1.);\n        } else if (dist > 1000.) {\n            break;\n        }\n        ray+=raydir*dist;\n        lastdist = dist;\n    }\n    return vec3(0.1)+normalize(vec3(.5*(cos(iTime)+1.),cos(iTime/iResolution.y),.5*(sin(iTime)+1.)))*.5;\n}\n\nmat3 setCamera( in vec3 ro, in vec3 ta, float cr )\n{\n    // courtesy of Inigo Quilez (https://www.shadertoy.com/view/Xds3zN)\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // camera\n    vec3 ro = 4.0*normalize(vec3(sin(0.01*iMouse.x+0.35), .4, cos(0.01*iMouse.x+0.35)));\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n    mat3 ca = setCamera( ro, ta, 0.0 );\n\n    // Time varying pixel color\n    vec3 col = render(ca * vec3(uv, 1.0));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcBD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 54, 75, 75, 112], [113, 113, 140, 140, 188], [190, 190, 211, 211, 2047], [2050, 2050, 2098, 2098, 2133], [2135, 2135, 2166, 2166, 2253], [2254, 2254, 2293, 2293, 2380], [2404, 2404, 2431, 2431, 3232], [3234, 3234, 3286, 3358, 3535], [3537, 3537, 3594, 3644, 3998]], "test": "valid"}
{"id": "WdcBR4", "name": "S11_CREATURE", "author": "DISPLAY_JERKY", "description": "-", "tags": ["s11"], "likes": 3, "viewed": 67, "published": "Public", "date": "1604662721", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat2 rot(float a) {\n    float s = sin(a), c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\nfloat sph(vec3 p, float r) {\n    return length(p) - r;\n}\n\nfloat box(vec3 p, vec3 s) {\n    vec3 q = abs(p) - s;\n    return max(q.x, max(q.y, q.z));\n}\n\nvec3 smin(vec3 a, vec3 b, float h) {\n    vec3 k = clamp((a - b) / h * .5 + .5, 0., 1.);\n    return mix(a, b, k) - k * (1. - k) * h;\n}\n\nfloat map(vec3 p) {\n    float low = texelFetch(iChannel0, ivec2(4, 0), 0).x;\n    float hi = texelFetch(iChannel0, ivec2(360, 0), 0).x;\n    float t = iTime * .2;\n    float s = 1.;\n    for (float i = 0.; i < 5.; i++) {\n        p -= 0.05 * i;\n        p.xy *= rot(t * -i);\n        p.yz *= rot(t - i * 0.9 + 12.34);\n        p.zx *= rot(t + i * 1.3);\n        p = smin(p, -p, -s * max(.5, (low * 3. - hi * 1.)));\n        p -= s;\n        s *= -pow(hi, 6.) - .5;\n    }\n    \n    return box(p, vec3(0.5));\n}\n\nvec3 norm(vec3 p) {\n    vec2 e = vec2(0.01, 0);\n    return normalize(map(p) - vec3(map(p - e.xyy), map(p - e.yxy), map(p - e.yyx)));\n}\n\nvoid cam(inout vec3 p) {\n    float t = iTime;\n    p.zx *= rot(t * 0.1);\n    p.zy *= rot(t * 0.2);\n}\n\nvec3 bg(vec3 r) {\n    float k = r.y * .5 + .5;\n    return mix(vec3(.3, .5, .9), vec3(.3, .1, .1), k);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n    \n    int tx = int(uv.x * 512.);\n    float fft = texelFetch(iChannel0, ivec2(tx, 0), 0).x;\n    float wave = texelFetch(iChannel0, ivec2(tx, 1), 0).x;\n\n    vec3 s = vec3(0, 0, -12);\n    vec3 r = normalize(vec3(-uv, 1));\n    \n    cam(s);\n    cam(r);\n    \n    vec3 col = vec3(0);\n    \n    col += bg(r);\n\n    vec3 p = s;\n    float side = sign(map(p));\n    float prod = 1., spec;\n    float maxdist = 100.;\n    vec3 n, l, h;\n    for (int i = 0; float(i) < maxdist; i++) {\n        float d = map(p) * side;\n        if (d < .001) {\n            n = norm(p) * side;\n            l = normalize(vec3(-1, +1, -2));\n            if (dot(n, l) < 0.) l = -l;\n            h = normalize(l - r);\n            spec = .1 + .2 * pow(max(0., dot(n, l)), 20.);\n            \n            col += bg(reflect(r, n)) * 0.01;\n            col += max(0., dot(n, l)) * spec * prod;\n            \n\t        side = -side;\n            d = 0.1;\n            prod *= 0.7;\n            r = refract(r, n, 1. - .2 * side);\n            //break;\n        }\n        p += r * d;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "MtsSzr", "previewfilepath": "https://soundcloud.com/s11bt/blew", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/s11bt/blew", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcBR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 19, 19, 85], [87, 87, 115, 115, 143], [145, 145, 172, 172, 235], [237, 237, 273, 273, 370], [372, 372, 391, 391, 868], [870, 870, 889, 889, 1004], [1006, 1006, 1030, 1030, 1105], [1107, 1107, 1124, 1124, 1210], [1212, 1212, 1269, 1269, 2405]], "test": "error"}
{"id": "WdcBR7", "name": "Mobiustrans", "author": "branc116", "description": "Shader that performs mobius transformation over some area", "tags": ["complexanalysis"], "likes": 2, "viewed": 59, "published": "Public", "date": "1604623157", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float mask(vec4 rect, vec2 point) {\n    return rect.x >= point.x && rect.z <= point.x && rect.y >= point.y && rect.w <= point.y ? 1.0 : 0.0;\n}\nvec2 not_cmplx(vec2 a) {\n    return vec2(a.x, -a.y);\n}\nvec2 mul_cmplx(vec2 a, vec2 b) {\n    return vec2(a.x * b.x - a.y * b.y, a.y * b.x + a.x * b.y);\n}\nvec2 div_cmplx(vec2 a, vec2 b) {\n    return mul_cmplx(a, not_cmplx(b))/(b.x*b.x + b.y*b.y);\n}\nvec2 mobi(vec2 z, vec2 a, vec2 b, vec2 c, vec2 d) {\n    vec2 up = a * z + b;\n    vec2 down = c * z + d;\n    return up / down;\n}\nvec2 mobi_inv(vec2 m, vec2 a, vec2 b, vec2 c, vec2 d) {\n    return div_cmplx(mul_cmplx(m, d) - b, a - mul_cmplx(c, m));\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 a, b, c, d;\n    vec2 uv_mouse = (iMouse.xy / iResolution.xy - vec2(0.5)) * 12.0;\n    a = vec2(1.0, 1.0); \n    b = vec2(0.0, 0.0); \n    c = vec2(sin(iTime*3.14), cos(iTime*2.0)); \n    d = vec2(1.0, 0.0) + c;\n    float show_og = 0.1;\n    float zoom = .2;\n    vec2 uv =(fragCoord/iResolution.xy - vec2(0.5, 0.5)) / zoom;\n    float m = 0.02;\n    vec2 shade = mod(uv, m);\n    float shadex = mod(uv.x, m);\n    float shadey = mod(uv.y, m);\n    vec4 bounds = vec4(1.0, 1.0, -1.0, -1.0);\n    vec3 col = vec3(uv.y > 0.0 ? 1.0 : 0.0);\n    vec2 uv_mobi = mobi(uv, a, b, c, d); \n    col = vec3(mask(bounds, uv) * (shadex < m / 10.0 ? 1.0 : 0.0)  );\n    col = clamp(col + vec3(mask(bounds, uv) * (shadey < m / 10.0 ? 1.0 : 0.0)), 0.0, 1.0);\n\tcol *= show_og;\n    \n    vec2 mobi_i = mobi_inv(uv, a, b, c, d);\n    vec2 shadem = mod(mobi_i, m);\n    col = clamp(col + vec3(mask(bounds, mobi_i) * (shadem.x < m / 10.0 ? 1.0 : 0.0), 0.0, 0.0), 0.0, 1.0);\n    col = clamp(col + vec3(mask(bounds, mobi_i) * (shadem.y < m / 10.0 ? 1.0 : 0.0), 0.0, 0.0), 0.0, 1.0);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 35, 35, 142], [143, 143, 167, 167, 197], [198, 198, 230, 230, 295], [296, 296, 328, 328, 389], [390, 390, 441, 441, 517], [518, 518, 573, 573, 639], [640, 640, 697, 747, 1854]], "test": "valid"}
{"id": "WdcBRB", "name": "Session raymarching", "author": "illus0r", "description": "Session raymarching", "tags": ["raymarching"], "likes": 2, "viewed": 197, "published": "Public API", "date": "1605376288", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float sdBox( vec3 p )\n{\n  vec3 b = vec3(1.);\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nmat2 rot(float a){float s=sin(a),c=cos(a);return mat2(c,-s,s,c);}\nvoid mainImage( out vec4 fragColor, in vec2 FC )\n{\n    vec2 uv = (FC*2.-iResolution.xy)/iResolution.y;\n    float d=0.,e;\n    vec3 rd=normalize(vec3(uv,1.)), p;\n    rd.xz*=rot(iMouse.x/100.);\n    rd.xy*=rot(iMouse.y/100.);\n    for(int i=0;i<99;i++){\n        p=rd*d;// uncomment for isometry: +vec3(uv*5.,0.);\n        float size=.2+.15*sin(p.x+iTime);\n        p.z+=iTime;\n        //p=normalize(p)/length(p);\n        p=mod(p,1.);\n        p-=.5;\n        d+=e=(length(p)-size);\n        if(e<.01)break;\n    }\n    float col = (d*.1)+.5;\n    \n    //uv=normalize(uv)/length(uv);\n    //uv = mod(uv,1.);\n    //uv-=.5;\n    //uv*=2.;\n    //col = length(uv)/1.5;\n    fragColor = vec4(col*vec3(203.,221.,180)/255.,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcBRB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 131], [132, 132, 150, 150, 197], [198, 198, 248, 248, 904]], "test": "valid"}
{"id": "wdcBz4", "name": "simple spheres (vlllll)", "author": "valalalalala", "description": "Ray tracing a few spheres with some simple reflection and lighting. Occlusion mostly working. Reflection on the plane is sad, but maybe accurate.", "tags": ["reflection", "basic", "shading", "spheres", "occlusion"], "likes": 4, "viewed": 98, "published": "Public", "date": "1604447616", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI  \t\t3.1415926\n#define PI2 \t\t6.2831952\n#define R \t\t\tiResolution\n#define M \t\t\tiMouse\n#define T \t\t\tiTime\n\n///////////////////////////////////////////////////////////////////////////////////////////\n\n#define SPHERE_COUNT  9\n#define SPHERE_RADIUS 0.5\n#define LIGHT_POWER   1.0\n#define LIGHT         vec3( 0.0, 0.5, -0.33 )\n#define SHINE         0.22\n\n///////////////////////////////////////////////////////////////////////////////////////////\n\n\n// https://www.iquilezles.org/www/articles/intersectors/intersectors.htm\nvec2 sphereHit( in vec3 rayOrigin, in vec3 rayDirection, in vec3 center, float radius )\n{\n    vec3 originToCenter = rayOrigin - center;\n    float b = dot( originToCenter, rayDirection );\n    float c = dot( originToCenter, originToCenter ) - radius*radius;\n    float h = b*b - c;\n    if( h<0.0 ) return vec2(-1.0); // no intersection\n    h = sqrt( h );\n    return vec2( -b-h, -b+h );\n}\n\n\n// from https://www.shadertoy.com/view/4d2XWV ... magic\nfloat iPlane( in vec3 ro, in vec3 rd )\n{\n    return (-1.0 - ro.y)/rd.y;\n}\n\n// https://www.iquilezles.org/www/articles/palettes/palettes.htm\nvec3 colorOfT( vec3 a, vec3 b, vec3 c, vec3 d, float t ) {\n    return a + b * cos( PI2 * ( c * t + d ) );\n}\n\nvec3 colorIt( float t ) {\n    return colorOfT( \n\t\tvec3( 0.5, 0.5, 0.5 ),\n\t\tvec3( 0.5, 0.5, 0.5 ),\n\t\tvec3( 1.0, 1.0, 1.0\t), \n\t\tvec3( 0.00, 0.33, 0.67 ),\n\t\tt\n\t);\n}\n\nfloat planeTest( in vec3 origin, in vec3 direction, out vec3 hit, out vec3 normal, out vec3 color ) {\n    float t = iPlane( origin, direction );\n    if ( t < 0.0 ) {\n        return t;\n    }\n    \n    hit = origin + t * direction * 0.99; // weak attempt to avoid self collisions;\n    normal = vec3( 0.0, 1.0, 0.0 );\n    color = vec3( 1.0 );\n    return t;\n}\n\nfloat sphereTest( in vec3 origin, in vec3 direction, out vec3 hit, out vec3 normal, out vec3 color ) {\n    // model information\n    int count = SPHERE_COUNT;\n    float radius = SPHERE_RADIUS;\n \n    // collision information\n    float closest = -1.0;\n    \n    for ( int i = 0 ; i < SPHERE_COUNT ; i++ ) {\n        float ic = float( i ) / float ( count );\n        float ingle = PI2 * ic;\n    \tfloat angle = T * 1.33 + ingle;\n        float offset = abs( sin( angle * 1.0 ) ) * radius * 5.0;\n        \n        float x = offset * cos( angle );\n        float y = offset * cos( angle + T );\n        y = pow(0.1,abs(sin(angle*1.10+1.0)));\n        float z = offset * sin( angle ) -1.0;\n        \n     \tvec3 sphere = vec3( x, y, z );\n        \n        vec2 d = sphereHit( origin, direction, sphere, radius );\n        if ( d.x < 0.0 ) continue;\n        \n        float h = min( d.x, d.y );\n        if ( h < closest || closest < 0.0 ) {\n            closest = h;\n           \thit = origin + closest * direction * 0.99; // weak attempt to avoid self collisions\n            normal = normalize( hit - sphere ); \n            color = colorIt( ic );\n        }\n    }\n    \n    return closest;\n}\n\n\nfloat hitTest( in vec3 origin, in vec3 direction, out vec3 hit, out vec3 normal, out vec3 color ) {\n    float d = sphereTest( origin, direction, hit, normal, color );\n    if ( d > 0.0 ) return d; // not sure this is ok..  \n    \n    d = planeTest( origin, direction, hit, normal, color );\n    color = vec3(1.0);\n    return d;\n}\n\nvec3 vec3_11_to_01( vec3 v ) {\n    return 0.5 * ( v + 1.0 );\n}\n\nvec4 heckers( in vec3 origin, vec3 direction ) {\n    vec3 hit;\n    vec3 normal;\n    vec3 color;\n    float closest = hitTest( origin, direction, hit, normal, color );\n    \n    if ( closest < 0.0 ) {\n        return vec4(vec3(0.11),1.0);\n    }\n\n    // normal on sphere where the ray hit\n    vec3 hitDirection = normal;\n    \n    vec3 toLight = normalize( LIGHT - hit );\n    float lightAngle = dot( normal, toLight );  \n    float lightDistance = abs( length( LIGHT - hit ) );\n    float lightStrength = LIGHT_POWER / pow( lightDistance, 2.0 ) * pow( lightAngle, 2.0 );\n  \n    // occlusion \n    vec3 occlusionHit; \n    vec3 occlusionNormal; \n    vec3 occlusionColor; // lol\n    float occlusionClosest = hitTest(hit, toLight, occlusionHit, occlusionNormal, occlusionColor );\n    if ( occlusionClosest >= 0.0 ) {\n        // FIXME: some strange banding here. maybe due to self collisions...\n        lightStrength = pow( lightStrength, 2.0 );\n    }\n    \n    // reflection\n    // FIXME: reflection or sphere in plane is flat and (worse) fake looking\n    int reflected = 0;\n    vec3 rHit = hit;\n    vec3 rHitDirection = hitDirection;\n    vec3 accumulateReflectColor = vec3( 0.0 );\n    for ( int i = 0 ; i < 5 ; i++ ) {\n        vec3 reflectHit; \n        vec3 reflectNormal; \n        vec3 reflectColor; \n        float reflectClosest = hitTest(rHit, rHitDirection, reflectHit, reflectNormal, reflectColor );\n        if ( reflectClosest < 0.0 ) break;\n\t\treflected = 1 + i;\n        if ( 0 == i ) {\n    \t\taccumulateReflectColor = reflectColor;\n        } else {\n            accumulateReflectColor = accumulateReflectColor * 0.90 + 0.10 * reflectColor;\n        }\n    }\n\tif( 0 != reflected ) {\n    \tcolor = accumulateReflectColor * SHINE + ( 1.0 - SHINE ) * color;\n    }\n    //color=vec3(float(reflected)/5.0); // fun negaverse version\n\n    \n    float ambient = 0.22;\n    float environmental = 1.0 - ambient;\n    \n    color = ( color * ambient ) + ( environmental * color * lightStrength );\n    \n    return vec4( color, 1.0 );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = (2.0*fragCoord.xy-iResolution.xy) / iResolution.y; \n    vec3 origin = vec3(0.0, 0.0, 4.0 );\n    vec3 direction = normalize( vec3(xy,-2.0) );\n    \n    fragColor = heckers( origin, direction );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdcBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[450, 523, 612, 612, 907], [910, 966, 1006, 1006, 1039], [1041, 1106, 1164, 1164, 1213], [1215, 1215, 1240, 1240, 1376], [1378, 1378, 1479, 1479, 1732], [1734, 1734, 1836, 1861, 2900], [2903, 2903, 3002, 3002, 3229], [3231, 3231, 3261, 3261, 3293], [3295, 3295, 3343, 3343, 5301], [5303, 5303, 5360, 5360, 5568]], "test": "valid"}
{"id": "WdcBzS", "name": "Triangles animation", "author": "dtsmio", "description": "Animation", "tags": ["aimation"], "likes": 8, "viewed": 75, "published": "Public", "date": "1605632456", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.14159265359\n\nvec2 line (vec2 a, vec2 b, vec2 p)\n{\n    vec2 pa = p-a, ba = b-a;\n    float h = min(1., max(0., dot(pa, ba)/dot(ba, ba)));\n    \n    return vec2(length(pa - ba * h), h);\n}\n\n\nfloat ease(float x) {\n\treturn mix(4. * x * x * x, \n               1. - pow(-2. * x + 2., 3.) / 2., step(0.5, x));\n}\nfloat ease2(float x) {\n\treturn mix(pow(x/2., 0.5), \n               1. - pow(0.5 - x/2., 0.5), step(0.5, x));\n}\nfloat ease3(float x) {\n\treturn mix(0.5 + pow((x - 0.5) * 2., 2.)/2., \n               0.5 - pow((x - 0.5) * 2., 2.)/2., step(0.5, x));\n}\n\nvec2 rotate(vec2 v, float a) {\n\tfloat s = sin(a);\n\tfloat c = cos(a);\n\tmat2 m = mat2(c, -s, s, c);\n\treturn m * v;\n}\n\nfloat leftSide(vec2 a, vec2 b, vec2 p) {    \n \treturn 1. - step(0.0, (a.x - p.x) * (b.y - a.y) - (b.x - a.x) * (a.y - p.y));\n}\n\nfloat DrawLine(vec2 line, float prog) {\n    float size = 0.002;\n    line.x = smoothstep(size * 2., size, line.x);\n    float prog1 = pow(prog, 0.8);\n    float prog2 = pow(prog, 2.);\n\n    return line.x;\n    //return (smoothstep(1. - prog, 1. - prog, line.y) * line.x);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tuv *= 1.8;\n    uv.y += 0.2;\n    float time = iTime * 0.6 + 1000.;\n    \n    \n    float sp = PI/1.5;\n    float a = floor(time * 0.) * sp;\n    vec2 cp1 = vec2(sin(a), cos(a));\n    vec2 cp2 = vec2(sin(a + sp), cos(a + sp));\n    vec2 cp3 = vec2(sin(a + sp * 2.), cos(a + sp * 2.));\n    \n    vec2 p1 = cp1;\n    vec2 p2 = cp2;\n    vec2 p3 = cp3;\n    \n    float pr = 0.;\n    float brd = 0.;\n    //pr = abs(fract(time) - 0.5) * 2.;\n    float num = 18.;\n    vec3 c1 = vec3(34, 124, 157)/255.;\n    vec3 c2 = vec3(23, 195, 178)/255.;\n    vec3 c3 = vec3(255, 203, 119)/255.;\n    vec3 c4 = vec3(254, 249, 239)/255.;\n    vec3 c5 = vec3(254, 109, 115)/255.;\n    float cnum = 5.;\n    vec3 col = vec3(0);\n\n    vec3 rc = c5;\n    vec2 tuv = uv;\n    float ins = 0.;\n    \n    for (float i = 0.; i < num; i++) {\n        //uv *= 1.1;\n        \n        pr = ease3(max(0., fract(-time / 4. - i * 0.) * 1. - 0.));\n        \n        if (fract(i / 2.) * 2. == 1.){\n            //pr = 1. - pr;\n        }\n\n        vec2 l1 = line(p1, p2, uv);\n        vec2 l2 = line(p2, p3, uv);\n        vec2 l3 = line(p3, p1, uv);\n        \n        ins = min(leftSide(p1, p2, uv), min(leftSide(p2, p3, uv), leftSide(p3, p1, uv)));\n\n        vec3 cc = vec3(0);\n        //cc *= vec3(sin(i * 24.12 + 2.) * 0.5 + 0.5, sin(i * 24.12 + 1.) * 0.5 + 0.5, sin(i * 35.23 + 3.) * 0.5 + 0.5);\n        if (abs(fract(i/cnum) * cnum - 0.) < 0.1) {\n         \tcc = c1;   \n        }\n        if (abs(fract(i/cnum) * cnum - 1.) < 0.1) {\n         \tcc = c2;   \n        }\n        if (abs(fract(i/cnum) * cnum - 2.) < 0.1) {\n         \tcc = c3;   \n        }\n        if (abs(fract(i/cnum) * cnum - 3.) < 0.1) {\n         \tcc = c4;   \n        }\n        if (abs(fract(i/cnum) * cnum - 4.) < 0.1) {\n         \tcc = c5;   \n        }\n        tuv = rotate(uv, i + time);\n\n        //cc += vec3(sin(tuv.x) * 0.5, sin(tuv.y) * 0.5, sin(tuv.x + tuv.y) * 0.5)/2.;\n            \n        rc = mix(rc, cc, ins);\n\n        brd = max(brd, DrawLine(l1, pr));\n        brd = max(brd, DrawLine(l2, pr));    \n        brd = max(brd, DrawLine(l3, pr));\n\n        p1 = cp1 + (cp2 - cp1) * pr;\n        p2 = cp2 + (cp3 - cp2) * pr;\n        p3 = cp3 + (cp1 - cp3) * pr;\n        cp1 = p1;\n        cp2 = p2;\n        cp3 = p3;\n        \n        //rc += DrawLine(l1, pr) * mix(c1, c2, sin(l1.y + time));\n        //rc += DrawLine(l2, pr) * mix(c1, c2, sin(l2.y - time));\n        //rc += DrawLine(l3, pr) * mix(c1, c2, sin(l3.y + time));\n        \n      \t//if (brd > 0.) break;\n\n    }\n    \n    col = rc;\n    col += brd/1.;\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 62, 62, 196], [199, 199, 220, 220, 314], [315, 315, 337, 337, 425], [426, 426, 448, 448, 561], [563, 563, 593, 593, 677], [679, 679, 719, 719, 805], [807, 807, 846, 846, 1075], [1078, 1078, 1135, 1135, 3735]], "test": "valid"}
{"id": "WdcfR4", "name": "Raymarching folded space", "author": "ichko", "description": "Raymarching folded space", "tags": ["raymarching", "spheres"], "likes": 2, "viewed": 56, "published": "Public", "date": "1604414322", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX 64\n#define EPS 0.05\n\nfloat distance_estimator(vec3 pos) {\n    pos = mod(pos, 2.0) - 1.0;\n    return length(pos) - 0.2;\n}\n\nfloat march(vec3 ro, vec3 rd) {\n    float dist = 0.0;\n    for(int i = 0;i < MAX;++i) {\n        vec3 pos = ro + rd * dist;\n        float d = distance_estimator(pos);\n        dist += d;\n        if(d < EPS) break;\n    }\n\n    return dist / float(MAX) * 3.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float ar = iResolution.x / iResolution.y;\n\tvec2 uv = fragCoord.xy / iResolution.y - vec2(ar * 0.5, 0.5);\n\n    vec3 ray_origin = vec3(sin(iTime), cos(iTime / 32.0) * 15.0, sin(iTime) / 45.0) * 10.0;\n    vec3 ray_direction = normalize(vec3(uv, 1.0));\n    \n    float angle = iTime / 5.0;\n    float s = sin(angle), c = cos(angle);\n    mat2 rot = mat2(c, -s, s, c);\n    ray_direction.xy *= rot;\n    ray_direction.yz *= rot;\n    \n    float i = march(ray_origin, ray_direction);\n    vec3 color = vec3(i, 0.0, 0.5);\n\n\tfragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdcfR4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[33, 33, 69, 69, 132], [134, 134, 165, 165, 389], [391, 391, 446, 446, 992]], "test": "valid"}
{"id": "wddBRr", "name": "Grass - panning shot", "author": "mosaic", "description": "Created by fizzer, https://www.shadertoy.com/view/lslGR8\nI just added horizontal movement (lines 46, 47)", "tags": ["grass"], "likes": 9, "viewed": 276, "published": "Public API", "date": "1604610179", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BLADES 110\n\nvec3 rotateX(float a, vec3 v)\n{\n\treturn vec3(v.x, cos(a) * v.y + sin(a) * v.z, cos(a) * v.z - sin(a) * v.y);\n}\n\nvec3 rotateY(float a, vec3 v)\n{\n\treturn vec3(cos(a) * v.x + sin(a) * v.z, v.y, cos(a) * v.z - sin(a) * v.x);\n}\n\nvec3 rotateZ(float a, vec3 v)\n{\n\treturn vec3(cos(a) * v.x + sin(a) * v.y, cos(a) * v.y - sin(a) * v.x, v.z);\n}\n\nvec4 grass(vec2 p, float x)\n{\n\tfloat s = mix(0.7, 2.0, 0.5 + sin(x * 12.0) * 0.5);\n\tp.x += pow(1.0 + p.y, 2.0) * 0.1 * cos(x * 0.5 + iTime);\n\tp.x *= s;\n\tp.y = (1.0 + p.y) * s - 1.0;\n\tfloat m = 1.0 - smoothstep(0.0, clamp(1.0 - p.y * 1.5, 0.01, 0.6) * 0.2 * s, pow(abs(p.x) * 19.0, 1.5) + p.y - 0.6);\n\treturn vec4(mix(vec3(0.05, 0.1, 0.0) * 0.8, vec3(0.0, 0.3, 0.0), (p.y + 1.0) * 0.5 + abs(p.x)), m * smoothstep(-1.0, -0.9, p.y));\n}\n\nvec3 backg(vec3 ro, vec3 rd)\n{\n\tfloat t = (-1.0 - ro.y) / rd.y;\n\tvec2 tc = ro.xz + rd.xz * t;\n\tvec3 horiz = vec3(0.0, 0.2, 0.2) * 0.7;\n\tvec3 sky = mix(horiz, vec3(0.1, 0.13, 0.15) * 0.8, dot(rd, vec3(0.0, 1.0, 0.0)));\n\tvec3 ground = mix(horiz, vec3(0.04, 0.07, 0.0) * 0.6, pow(max(0.0, dot(rd, vec3(0.0, -1.0, 0.0))), 0.2));\n\treturn mix(sky, ground, step(0.0, t));\n}\n\n// some simple noise just to break up the hideous banding\nfloat dither()\n{\n\treturn fract(gl_FragCoord.x * 0.482635532 + gl_FragCoord.y * 0.1353412 + iTime * 100.0) * 0.008;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec3 ct = vec3(0.0-iMouse.x/100.+iTime/2., -.2+iMouse.y/50., 5.0);\n\tvec3 cp =  vec3(iTime/2., 0.6, 0.);\n\tvec3 cw = normalize(cp - ct);\n\tvec3 cu = normalize(cross(cw, vec3(0.0, 1.0, 0.0)));\n\tvec3 cv = normalize(cross(cu, cw));\n\t\n\tmat3 rm = mat3(cu, cv, cw);\n\t\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - vec2(1.0);\n\tvec2 t = uv;\n\tt.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 ro = cp, rd = rotateY(sin(iTime * 0.7) * 0.1,\n\t\t\t\t\t\t\t   rm * rotateZ(sin(iTime * 0.15) * 0.1, vec3(t, -1.3)));\n\t\n\tvec3 fcol = backg(ro, rd);\n\t\n\tfor(int i = 0; i < BLADES; i += 1)\n\t{\n\t\tfloat z = -(float(BLADES - i) * 0.1 + 1.0);\n\t\tvec4 pln = vec4(0.0, 0.0, -1.0, z);\n\t\tfloat t = (pln.w - dot(pln.xyz, ro)) / dot(pln.xyz, rd);\n\t\tvec2 tc = ro.xy + rd.xy * t;\n\t\t\n\t\ttc.x += cos(float(i) * 3.0) * 4.0;\n\t\t\n\t\tfloat cell = floor(tc.x);\n\t\t\n\t\ttc.x = (tc.x - cell) - 0.5;\n\t\t\n\t\tvec4 c = grass(tc, float(i) + cell * 10.0);\n\t\t\n\t\tfcol = mix(fcol, c.rgb, step(0.0, t) * c.w);\n\t}\n\t\n\tfcol = pow(fcol * 1.1, vec3(0.8));\n\t\n\t\n\t// iigo quilez's great vigneting effect!\n\tvec2 q = (uv + vec2(1.0)) * 0.5;\n\tfcol *= 0.2 + 0.8*pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\t\n\tfragColor.rgb = fcol * 1.8 + vec3(dither());\n\tfragColor.a = 1.0;\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[20, 20, 51, 51, 130], [132, 132, 163, 163, 242], [244, 244, 275, 275, 354], [356, 356, 385, 385, 788], [790, 790, 820, 820, 1156], [1158, 1216, 1232, 1232, 1332]], "test": "valid"}
{"id": "WddBWM", "name": "Contrast small-big", "author": "illus0r", "description": "Contrast small-big", "tags": ["inversion"], "likes": 0, "viewed": 177, "published": "Public API", "date": "1605265241", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float f(float t) {\n    // just finetuning the time. \n    // looks difficult, hence here's simplified version\n    // which makes pretty the same:\n    //return sin(t)*.5+.5;\n    return .1+pow(10.*(sin(t*3.+3.1415)*.5+.5), 1.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord*2.-iResolution.xy)/iResolution.y;\n\n    // two similar 3-liners below draw two circles:\n    \n    // `- vec2(.05,0.)` is optional. It moves a circle a bit to the right\n    vec2 uv1 = uv - vec2(.05,0.);\n    // it's the most difficult part.\n    // Learn more on https://en.wikipedia.org/wiki/Inversive_geometry\n    // try commenting this line out to see the shape without the inversion.\n    uv1 = normalize(uv1)/length(uv1);\n\t// drawing the shape which is just a right half of the screen.\n    float sph1 = step(f(iTime),uv1.x);\n\n    // move a circle a bit to the left\n    vec2 uv2 = uv - vec2(-.05,0.);\n    // inversion\n    uv2 = normalize(uv2)/length(uv2);\n    // here are two differences from above:\n    // +3.1415 is for make circles move in different phases\n    // `-uv2.x` to color the left half of the screen.\n    //                           \n    float sph2 = step(f(iTime+3.1415),-uv2.x);\n\n    // `max` is to show both circles at once\n    fragColor = vec4(vec3(max(sph1, sph2)),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddBWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 18, 171, 227], [229, 229, 286, 286, 1322]], "test": "valid"}
{"id": "wddBzS", "name": "Lemarchand's Box", "author": "dean_the_coder", "description": "...from the Hellraiser series.\nA few firsts for me - Bump mapping, blood(!), and a different camera system. Quite happy, but would like to have added electricity arcs. Alas I'm hitting Shadertoy's 'Max 5 second' compile time rule...\nEnjoy!", "tags": ["3d", "raymarching", "horror", "movie", "cineshader", "pinhead"], "likes": 19, "viewed": 3742, "published": "Public API", "date": "1606065014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Lemarchand's Box\n//\n// ...from the Hellraiser series.\n// A few firsts for me - Bump mapping, blood(!), and a different camera system.\n// Quite happy, but would like to have added electricity arcs. Alas I'm hitting\n// Shadertoy's 'Max 5 second' compile time rule...\n//\n// Thanks to Evvvvil, Flopine, Nusan, BigWings, Iq, Shane\n// and a bunch of others for sharing their knowledge!\n//\n// Processed by 'GLSL Shader Shrinker'\n// (https://github.com/deanthecoder/GLSLShaderShrinker)\n\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n#define MIN_DIST\t\t .0015\n#define MAX_DIST\t\t 50.\n#define MAX_STEPS\t\t72.\n#define SHADOW_STEPS\t 30.\n#define MAX_SHADOW_DIST  18.\n\nfloat lift, hatch, circRot, chain;\n\n#define AA  // Enable this line if your GPU can take it!\n\nstruct Hit {\n\tfloat d;\n\tvec4 po;\n\tfloat spe; // 0: None, 30.0: Shiny\n};\n\n// Thanks Shane - https://www.shadertoy.com/view/lstGRB\nfloat n31(vec3 p) {\n\tconst vec3 s = vec3(7, 157, 113);\n\tvec3 ip = floor(p);\n\tvec4 h = vec4(0, s.yz, s.y + s.z) + dot(ip, s);\n\tp -= ip;\n\n\th = mix(fract(sin(h) * 43758.5453), fract(sin(h + s.x) * 43758.5453), p.x);\n\n\th.xy = mix(h.xz, h.yw, p.y);\n\treturn mix(h.x, h.y, p.z);\n}\n\nfloat n11(float n) {\n\tfloat flr = floor(n);\n\tn = fract(n);\n\tvec2 rndRange = fract(sin(vec2(flr, flr + 1.) * 12.3456) * 43758.5453);\n\treturn mix(rndRange.x, rndRange.y, n * n * (3. - 2. * n));\n}\n\nfloat istep(float a, float b) { return 1. - step(a, b); }\n\nfloat max2(vec2 v) { return max(v.x, v.y); }\n\nHit minH(Hit a, Hit b) {\n\tif (a.d < b.d) return a;\n\treturn b;\n}\n\nfloat remap(float f, float in1, float in2, float out1, float out2) {\n\treturn mix(out1, out2, clamp((f - in1) / (in2 - in1), 0., 1.));\n}\n\nmat2 rot(float a) {\n\tfloat c = cos(a), s = sin(a);\n\treturn mat2(c, s, -s, c);\n}\n\nvec3 rot(vec3 p, vec3 ax, float a) {\n\t// Thanks Blackle.\n\treturn mix(dot(ax, p) * ax, p, cos(a)) + cross(ax, p) * sin(a);\n}\n\nfloat sdBox(vec3 p, vec3 b) {\n\tvec3 q = abs(p) - b;\n\treturn length(max(q, 0.)) + min(max(q.x, max2(q.yz)), 0.);\n}\n\nfloat sdUBox(vec3 p) { return sdBox(p, vec3(1)); }\n\nfloat sdCylinder(vec3 p, float h, float r) {\n\tvec2 d = abs(vec2(length(p.xz), p.y)) - vec2(h, r);\n\treturn min(max2(d), 0.) + length(max(d, 0.));\n}\n\nvec3 getRayDir(vec3 ro, vec2 uv) {\n\tconst vec3 r = vec3(0, 1, 0);\n\tvec3 forward = normalize(r - ro),\n\t\t right = normalize(cross(r, forward)),\n\t\t up = cross(forward, right);\n\treturn normalize(forward + right * uv.x + up * uv.y);\n}\n\nfloat sdFan(vec3 p) {\n\tfloat d = 1e7;\n\tmat2 m = rot(.785);\n\tfor (int i = 0; i < 4; i++)\n\t\td = min(d, sdBox(p, vec3(.2 * length(p.xz), 2, 2))), p.xz *= m;\n\n\treturn d;\n}\n\nfloat hole(vec3 p) {\n\treturn sdBox(rot(p, vec3(0, 1, 0), .78), vec3(.35, 10, .35));\n}\n\n// Outline square.\nfloat sq(vec2 p, float r1, float r2) {\n\tfloat mp = max2(p);\n\treturn step(r1, mp) - step(r2, mp);\n}\n\n// Outline circle.\nfloat circ(vec2 p, float r1, float r2) {\n\tfloat d = length(p);\n\treturn istep(r1, d) * step(r2, d);\n}\n\nvec3 tex(vec4 po) {\n\tif (po.w == 0.) // Ground.\n\t\treturn po.rgb;\n\n\tif (sdUBox(po.xyz) < 0.) // Inside cube (Wood)\n\t\treturn mix(vec3(.035, .02, .01), vec3(.025, .015, .01), n11(n31(po.xyz * vec3(3, 1, 3)) * 30.));\n\n\t// On cube surface.\n\tconst vec2 e = vec2(1, -1) * .00001;\n\tvec3 n = normalize(e.xyy * sdUBox(po.xyz + e.xyy) +\n\t\t\t \t\t   e.yyx * sdUBox(po.xyz + e.yyx) +\n\t\t\t\t\t   e.yxy * sdUBox(po.xyz + e.yxy) +\n\t\t\t\t\t   e.xxx * sdUBox(po.xyz + e.xxx));\n\n\tfloat c = 0., patt = step(.25, n31(po.xyz * 42.5) * 2.2 * n31(po.xyz * 10.6));\n\tvec2 p;\n\tif (abs(n.x) > .001) {\n\t\tp = abs(po.zy);\n\n\t\t// Decoration lines.\n\t\tc = istep(.015, abs(abs(po.z + .05 * sign(po.y)) - .04)) +\n\t\t\tistep(.015, abs(p.y - .04));\n\n\t\tp = abs(po.zy * rot(.785));\n\t\tc += istep(.015, abs(p.x - .04)) + istep(.015, abs(p.y - .04));\n\t\tfloat d = step(0., p.x - .02) * step(0., p.y - .02);\n\n\t\t// Decoration squares.\n\t\tp = abs(abs(po.zy) - 1.);\n\t\tc += sq(p, .5, .53) + sq(p, .56, .59);\n\t\tc *= d;\n\n\t\t// Circle outlines.\n\t\tp = abs(po.zy);\n\t\tfloat cc = length(abs(p - .45) - .45);\n\t\tc += istep(.3, cc) * step(.27, cc);\n\n\t\t// Inner outline.\n\t\tc *= istep(.8, max2(p));\n\t\tc += sq(p, .8, .83);\n\n\t\tc *= step(.27, cc); // Cut-outs.\n\n\t\tc += istep(.22, cc) + // Circles.\n\t\t\t step(.88, max2(p)); // Outer square.\n\t} else if (abs(n.z) > .001) {\n\t\t// Inner square.\n\t\tp = abs(po.xy * rot(.785));\n\t\tc = istep(.63, max2(p));\n\n\t\t// Corner circle segments.\n\t\tc += circ(abs(abs(po.xy) - .83), .55, .4);\n\n\t\t// Spiky circle.\n\t\tp = abs(po.xy);\n\t\tc *= step(.24, length(p)) *\n\t\t\t step(.42 * pow(abs(sin(1.57 + atan(po.y, po.x) * 4.)), 10.), length(p));\n\n\t\t// Outer square.\n\t\tc += step(.88, max2(p));\n\t} else {\n\t\t// Surface pattern.\n\t\tc += step(.3, ((n31(po.xyz * 47.5) + n31(po.xyz * 30.)) * n31(po.xyz * 7.5)) / 2.);\n\n\t\t// Outer square.\n\t\tc += step(.92, max2(abs(po.xz)));\n\n\t\t// Radial lines.\n\t\tc += circ(abs(po.xz), .62, .56);\n\t\tp = vec2(1) * rot(sin(atan(po.z, po.x) * 16. + 4.5));\n\t\tc *= step(.3, p.x - .1);\n\t\tc += istep(.3, abs(p.x - .1));\n\n\t\t// Cut-out circle.\n\t\tc *= step(.56, length(po.xz));\n\n\t\t// Circle (and pattern).\n\t\tp = po.xz * rot(circRot * 1.57);\n\t\tc += istep(.5, length(po.xz)) *\n\t\t\t 1. - (istep(.12 - hatch, mod(atan(p.x, p.y) + 1.57, 1.57)) * step(.01, mod(clamp(length(p) + .12, .32, .6), .04)));\n\n\t\tp = abs(po.xz);\n\t\tpatt = 1.;\n\t}\n\n\t// Outer square.\n\tc *= istep(.98, max2(p));\n\n\treturn mix(\n\t\tvec3(.018, .011, .005),\n\t\tmix(mix(vec3(.13, .09, .002), vec3(.3, .23, .006), n31(po.xyz * 58.6)), vec3(.19, .16, .08), n31(po.xyz * 50.)),\n\t\tmin(c, patt));\n}\n\nHit topBox(vec3 p) {\n\tp.y -= min(sin(lift * 3.141) * 6., 2.);\n\tp.xz *= rot(max(0., smoothstep(0., 3., ((lift - .1) * 6.)) * 3.141 / 4.));\n\n\tfloat b = sdUBox(p), // Whole box.\n\t\t  c = sdCylinder(p, .5, 1.); // Central circle.\n\n\tvec3 pp = p;\n\tpp.y -= .99;\n\tpp.xz = abs(pp.xz);\n\tpp -= vec3(.25, 0, .25);\n\tpp = rot(pp, normalize(vec3(-1, 0, 1)), hatch * 2.);\n\tfloat l = max(sdBox(pp, vec3(.26, .01, .26)), length(p.xz) - .5), // Lid.\n\t\t  ho = hole(p);\n\n\tHit h = Hit(0., vec4(p, 1), step(0., b) * 50.);\n\tp.xz *= rot(.2);\n\th.d = max(min(max(b, sdFan(p)), c), -ho);\n\th.d = min(h.d, l);\n\n\treturn h;\n}\n\nHit botBox(vec3 p) {\n\tfloat b = sdUBox(p), // Whole box.\n\t\t  c = sdCylinder(p, .45, .95), // Central circle.\n\t\t  ho = hole(p);\n\n\tHit h = Hit(0., vec4(p, 2), step(0., b) * 50.);\n\tp.xz *= rot(.2);\n\th.d = min(c, max(max(b, -sdFan(p)), .5 - length(p.xz)));\n\n\treturn h;\n}\n\nfloat flrPat(vec3 p) {\n\tp.x = mod(p.x, 1.) - .5;\n\tp.y += .06;\n\treturn length(p.xy) - .1 * abs(sin(p.z * 3.141));\n}\n\nHit flr(vec3 p) {\n\tp.y += 1.04;\n\n\tfloat splat = n31(p * 30.12);\n\tvec3 rgb = mix(mix(vec3(mix(.13, .17, n31(p * 8.28))), vec3(.11, .12, .13), splat), vec3(.125, .002, .002) * splat, splat * .3 + smoothstep(.6, .8, n31(p * .46)));\n\n\tp.xz *= rot(.3);\n\treturn Hit(min(p.y, min(flrPat(p), flrPat(p.zyx + vec3(0, 0, .5)))), vec4(rgb, 0), 10.);\n}\n\nfloat chn(vec3 p, float i) {\n\tp.xy *= rot(.3);\n\tp.y += i * 2. - chain;\n\tfloat oy = p.y;\n\tconst vec3 s = vec3(.075, .15, .015);\n\tvec3 s2 = vec3(s.xy, 1.015),\n\t\tp2 = p.zyx;\n\n\tp.y = mod(oy, .45) - .225;\n\tp2.y = mod(oy - .225, .45) - .225;\n\n\treturn max(min(max(sdBox(p, s), -sdBox(p, s2)), max(sdBox(p2, s), -sdBox(p2, s2))) - .02, oy);\n}\n\nHit chains(vec3 p) {\n\tconst vec2 u = vec2(1, -1);\n\treturn Hit(min(min(min(chn(p, 0.), chn(p * u.yxx, 1.)), chn(p.zyx, 2.)), chn(p.zyx * u.yxx, 3.)),\n\t\t\t   vec4(.04, .03, .03, 0),\n\t\t\t   50.);\n}\n\n// Map the scene using SDF functions.\nHit map(vec3 p) {\n\treturn minH(minH(minH(topBox(p), botBox(p)), flr(p)), chains(p));\n}\n\nvec3 calcNormal(vec3 p) {\n\tconst float sceneAdjust = .25;\n\tconst float h = .0001 * sceneAdjust;\n\tvec3 n = vec3(0);\n\tfor (int i = min(iFrame, 0); i < 4; i++) {\n\t\tvec3 e = .5773 * (2. * vec3((((i + 3) >> 1) & 1), (i >> 1) & 1, i & 1) - 1.);\n\t\tn += e*map(p+e*h).d;\n\t}\n\n\treturn normalize(n);\n}\n\nconst vec3 sunPos = vec3(8, 3, -8);\n\nfloat calcShadow(vec3 p, vec3 lightPos) {\n\t// Thanks iq.\n\tvec3 rd = normalize(lightPos - p);\n\n\tfloat sha = 1., t = .1;\n\tfor (float i = 0.; i < SHADOW_STEPS; i++)\n\t{\n\t\tfloat h = map(p + rd * t).d;\n\t\tsha = min(sha, 15. * h / t);\n\t\tt += h;\n\t\tif (sha < .001 || t > MAX_SHADOW_DIST) break;\n\t}\n\n\treturn clamp(sha, 0., 1.);\n}\n\n// Quick ambient occlusion.\nfloat ao(vec3 p, vec3 n, float h) {\n\treturn map(p + h * n).d / h;\n}\n\n/**********************************************************************************/\n\nvec3 vignette(vec3 col, vec2 fragCoord) {\n\tvec2 q = fragCoord.xy / iResolution.xy;\n\tcol *= .5 + .5 * pow(16. * q.x * q.y * (1. - q.x) * (1. - q.y), .4);\n\treturn col;\n}\n\nvec3 applyLighting(vec3 p, vec3 rd, Hit h) {\n\tconst vec3 sunCol = vec3(2, 1.6, 1.4);\n\tvec3 sunDir = normalize(sunPos - p),\n\t\t n = calcNormal(p);\n\n\tfloat u = tex(h.po + vec2(.02, 0).xyyy).r,\n\t\t  r = tex(h.po + vec2(.02, 0).yxyy).r;\n\tvec3 c = tex(h.po);\n\tn = normalize(vec3(c.r - r, c.r - u, 0) * .2 + n);\n\tfloat ao = dot(vec2(ao(p, n, .5), ao(p, n, 2.)), vec2(.3, .5)),\n\n\t// Primary light.\n\tpri = max(0., dot(sunDir, n)),\n\n\t// Secondary(/bounce) light.\n\tbounce = max(0., dot(sunDir * vec2(-1, 0).xyx, n)) * .3,\n\n\t// Specular.\n\tspe = smoothstep(0., 1., pow(max(0., dot(rd, reflect(sunDir, n))), h.spe)) * h.spe / 10.,\n\n\t// Fresnel\n\tfre = smoothstep(.7, 1., 1. + dot(rd, n)),\n\n\t// Fog\n\tfog = exp(-length(p) * .14);\n\n\t// Combine.\n\treturn mix(((pri * mix(.4, 1., calcShadow(p, sunPos)) + bounce) * ao + spe) * sunCol * c, vec3(.01), fre) * fog;\n}\n\nvec3 march(vec3 ro, vec3 rd) {\n\t// Raymarch.\n\tvec3 p;\n\n\tfloat d = .01;\n\tHit h;\n\tfor (float i = 0.; i < MAX_STEPS; i++) {\n\t\tp = ro + rd * d;\n\t\th = map(p);\n\n\t\tif (abs(h.d) < MIN_DIST * d || d > MAX_DIST)\n\t\t\tbreak;\n\n\t\td += h.d; // No hit, so keep marching.\n\t}\n\n\tif (d > MAX_DIST)\n\t\treturn vec3(0); // Distance limit reached - Stop.\n\n\t// Lighting.\n\treturn applyLighting(p, rd, h);\n}\n\nvoid mainImage(out vec4 fragColor, vec2 fragCoord)\n{\n\tlift = hatch = circRot = chain = 0.;\n\n\t// Camera.\n\tfloat time = mod(iTime, 45.),\n\t\t  t = min(min(min(time, abs(time - 8.)), abs(time - 12.)), abs(time - 36.)),\n\t\t  dim = 1. - pow(abs(cos(clamp(t, -1., 1.) * 1.57)), 10.);\n\n\tvec3 cam;\n\n\tif (time < 8.) {\n\t\tcam = mix(vec3(.5, .5, 18.75), vec3(-.5, 0, 3.75), remap(time, 0., 8., 0., 1.));\n\t}\n\telse if (time < 12.) {\n\t\tcam = mix(vec3(0, 0, 5.6), vec3(-.5, .05, 5.6), remap(time, 8., 12., 0., 1.));\n\t}\n\telse if (time < 36.) {\n\t\tcam = mix(vec3(.12, .7, 3.67), vec3(.12, .7, 5), remap(time, 15., 30., 0., 1.));\n\t\tcircRot = smoothstep(0., 1., remap(time, 22., 24., 0., 1.)) - smoothstep(0., 1., remap(time, 13., 15., 0., 1.));\n\t\tlift = remap(time, 16., 21., 0., 1.) - remap(time, 25., 30., 0., 1.);\n\t\thatch = remap(time, 31., 34., 0., .98);\n\t} else {\n\t\thatch = 1.;\n\t\tchain = (time - 36.) * 4.;\n\t\tcam = mix(vec3(.02, .98, 5.78), vec3(.02, 1, 2.56), smoothstep(0., 1., remap(time, 36., 37., 0., 1.)));\n\t\tcam.z -= remap(time, 40., 41., 0., 1.2);\n\t\tdim = remap(time, 40.5, 41., 1., 0.);\n\t}\n\n\tvec3 ro = vec3(0, 0, -cam.z);\n\tro.yz *= rot(cam.y * -1.4);\n\tro.xz *= rot(cam.x * -3.141);\n\n\tvec3 col = vec3(0);\n#ifdef AA\n\tfor (float dx = 0.; dx <= 1.; dx++) {\n\t\tfor (float dy = 0.; dy <= 1.; dy++) {\n\t\t\tvec2 uv = (fragCoord + vec2(dx, dy) * .5 - .5 * iResolution.xy) / iResolution.y;\n#else\n\t\t\tvec2 uv = (fragCoord - .5 * iResolution.xy) / iResolution.y;\n#endif\n\n\t\t\tcol += march(ro, getRayDir(ro, uv));\n#ifdef AA\n\t\t}\n\t}\n\tcol /= 4.;\n#endif\n\n\t// Output to screen.\n\tfragColor = vec4(vignette(pow(col * dim, vec3(.4545)), fragCoord), 1.);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddBzS.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[864, 920, 939, 939, 1193], [1195, 1195, 1215, 1215, 1388], [1390, 1390, 1421, 1421, 1447], [1449, 1449, 1469, 1469, 1493], [1495, 1495, 1519, 1519, 1558], [1560, 1560, 1628, 1628, 1695], [1697, 1697, 1716, 1716, 1776], [1778, 1778, 1814, 1834, 1901], [1903, 1903, 1932, 1932, 2016], [2018, 2018, 2040, 2040, 2068], [2070, 2070, 2114, 2114, 2216], [2218, 2218, 2252, 2252, 2447], [2449, 2449, 2470, 2470, 2616], [2618, 2618, 2638, 2638, 2703], [2705, 2724, 2762, 2762, 2822], [2824, 2843, 2883, 2883, 2943], [2945, 2945, 2964, 2964, 5451], [5453, 5453, 5473, 5473, 6045], [6047, 6047, 6067, 6067, 6313], [6315, 6315, 6337, 6337, 6429], [6431, 6431, 6448, 6448, 6770], [6772, 6772, 6800, 6800, 7106], [7108, 7108, 7128, 7128, 7300], [7302, 7340, 7357, 7357, 7426], [7428, 7428, 7453, 7453, 7717], [7756, 7756, 7797, 7812, 8074], [8076, 8104, 8139, 8139, 8171], [8259, 8259, 8300, 8300, 8426], [8428, 8428, 8472, 8472, 9269], [9271, 9271, 9301, 9315, 9649]], "test": "valid"}
{"id": "wddfDM", "name": "Giroid sphere", "author": "makio135", "description": "Can't find why I get those glitches \nif anyone here could give me a tip, it would be really appreciated :)\n\n#EDIT: Thanks to Ivan Dianov for pointing out that the gyroid SDF is not exact and should then be divided", "tags": ["raymarching"], "likes": 9, "viewed": 337, "published": "Public API", "date": "1605311295", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Antialiasing: number of samples in x and y dimensions\n#define AA 2\n\n#define MIN_DIST 0.001\n#define MAX_DIST 10.\n\n#define PI 3.1415926\n#define TAU 6.2831853\n\n\nfloat opIntersection(float d1, float d2) {\n  return max(d1, d2);\n}\n\n// from https://github.com/doxas/twigl\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nfloat sdSphere(vec3 p, float radius) {\n  return length(p) - radius;\n}\n\nfloat sdGyroid(vec3 p, float scale, float thickness, float bias) {\n  p *= scale;\n  return abs(dot(sin(p*.5), cos(p.zxy * 1.23)) - bias) / scale - thickness;\n}\n\nvec2 sceneSDF(vec3 p) {\n  p *= rotate3D(iTime * .2, vec3(0, 1, 0));\n  \n  float gyroid = sdGyroid(p, 10., .01, 0.) * .55;\n  float d = opIntersection(sdSphere(p, 1.5), gyroid);\n\n  return vec2(d, 1.);\n}\n\n// Compute camera-to-world transformation.\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n  vec3 cw = normalize(ta - ro);\n  vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n  vec3 cu = normalize(cross(cw,cp));\n  vec3 cv = normalize(cross(cu,cw));\n  return mat3(cu, cv, cw);\n}\n\n// Cast a ray from origin ro in direction rd until it hits an object.\n// Return (t,m) where t is distance traveled along the ray, and m\n// is the material of the object hit.\nvec2 castRay(in vec3 ro, in vec3 rd) {\n    float tmin = MIN_DIST;\n    float tmax = MAX_DIST;\n   \n#if 0\n    // bounding volume\n    float tp1 = (0.0 - ro.y) / rd.y; \n    if(tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y) / rd.y; \n    if(tp2 > 0.0) { \n        if(ro.y > 1.6) tmin = max(tmin, tp2);\n        else tmax = min(tmax, tp2 );\n    }\n#endif\n    \n    float t = tmin;\n    float m = -1.0;\n    for(int i = 0; i < 100; i++) {\n        float precis = 0.0005 * t;\n        vec2 res = sceneSDF(ro + rd * t);\n        if(res.x < precis || t > tmax) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if(t > tmax) m =- 1.0;\n    return vec2(t, m);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec3 calcNormal(in vec3 pos) {\n  // epsilon = a small number\n  vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\n  return normalize(\n    e.xyy * sceneSDF(pos + e.xyy).x + \n    e.yyx * sceneSDF(pos + e.yyx).x + \n    e.yxy * sceneSDF(pos + e.yxy).x + \n    e.xxx * sceneSDF(pos + e.xxx).x\n  );\n}\n\nvec3 computeColor(vec3 ro, vec3 rd, vec3 pos, float d, float m) {\n  vec3 nor = calcNormal(pos);\n  return nor;\n}\n\n// Figure out color value when casting ray from origin ro in direction rd.\nvec3 render(in vec3 ro, in vec3 rd) { \n  // cast ray to nearest object\n  vec2 res = castRay(ro, rd);\n  float distance = res.x; // distance\n  float materialID = res.y; // material ID\n\n  vec3 col = vec3(245,215,161)/255.;\n  if(materialID > 0.0) {\n    vec3 pos = ro + distance * rd;\n    col = computeColor(ro, rd, pos, distance, materialID);\n  }\n  return vec3(clamp(col, 0.0, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  // Ray Origin)\\t\n  vec3 ro = vec3(2.3);\n  vec3 ta = vec3(0.0);\n  // camera-to-world transformation\n  mat3 ca = setCamera(ro, ta, 0.0);\n\n  vec3 color = vec3(0.0);\n\n#if AA>1\n  for(int m = 0; m < AA; m++)\n  for(int n = 0; n < AA; n++) {\n  // pixel coordinates\n  vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n  vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + o)) / iResolution.y;\n#else\n  vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n#endif\n\n  // ray direction\n  vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n  // render\\t\n  vec3 col = render(ro, rd);\n\n  color += col;\n#if AA>1\n  }\n  color /= float(AA*AA);\n#endif\n\n\n  fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddfDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 203, 203, 227], [229, 268, 306, 306, 715], [717, 717, 755, 755, 786], [788, 788, 854, 854, 946], [948, 948, 971, 971, 1147], [1149, 1192, 1242, 1242, 1418], [1420, 1594, 1632, 1632, 2254], [2256, 2334, 2364, 2394, 2621], [2623, 2623, 2688, 2688, 2734], [2736, 2811, 2848, 2881, 3192]], "test": "valid"}
{"id": "wddfR8", "name": "MCC Logo", "author": "Dominexis", "description": "Rotating logo for the Minecraft Commands Discord server. https://discord.gg/QAFXFtZ", "tags": ["3d", "minecraft"], "likes": 1, "viewed": 95, "published": "Public", "date": "1604383607", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int between2( in vec2 lower, in vec2 test, in vec2 upper ){\n    \n    if( lessThanEqual(lower, test) == bvec2(1) ){\n        if( lessThanEqual(test, upper) == bvec2(1) ){\n        \treturn 1;\n        }\n    }\n    return 0;\n}\nint between3( in vec3 lower, in vec3 test, in vec3 upper ){\n    \n    if( lessThanEqual(lower, test) == bvec3(1) ){\n        if( lessThanEqual(test, upper) == bvec3(1) ){\n        \treturn 1;\n        }\n    }\n    return 0;\n}\n\nfloat sphere( in vec3 sphere_pos, in float radius, in vec3 pos, in vec3 ray ){ \n    \n    // Initialize values\n    \n    float a = dot(ray, ray);\n    float b = 2.0*dot(pos-sphere_pos, ray);\n    float c = dot(pos, pos) + dot(sphere_pos, sphere_pos) - 2.0*dot(pos, sphere_pos) - radius*radius;\n    \n    \n    \n    // Compute distance\n    \n    float dist = -10000.0;\n    if( b*b - 4.0*a*c >= 0.0 )\n    {\n    \tfloat dist_1 = ( -b + sqrt(b*b - 4.0*a*c) )*0.5/a;\n        float dist_2 = ( -b - sqrt(b*b - 4.0*a*c) )*0.5/a;\n        dist = max(dist_1, dist_2);\n    }\n    \n    return dist;\n}\nfloat cylinder( in vec3 cylinder_pos, in float radius, in float height, in mat3 transform, in vec3 pos, in vec3 ray ){\n\n    // Initialize values\n    \n    pos = inverse(transform)*(pos-cylinder_pos);\n    ray = inverse(transform)*ray;\n    \n    float a = dot(ray.xy, ray.xy);\n    float b = 2.0*dot(pos.xy, ray.xy);\n    float c = dot(pos.xy, pos.xy) - 2.0*dot(pos.xy, vec2(0.0, 0.0)) - radius*radius;\n    \n    \n    \n    // Compute distance\n    \n    float dist = -10000.0;\n    if( b*b - 4.0*a*c >= 0.0 )\n    {\n    \tfloat dist_1 = ( -b + sqrt(b*b - 4.0*a*c) )*0.5/a;\n        float dist_2 = ( -b - sqrt(b*b - 4.0*a*c) )*0.5/a;\n        dist = max(dist_1, dist_2);\n    }\n    \n    if( 0.0 > pos.z+ray.z*dist ) dist = -10000.0;\n    if( pos.z+ray.z*dist > height ) dist = -10000.0;\n    \n    return dist;\n}\nfloat box( in vec3 box_pos, in vec3 box_size, in vec3 pos, in vec3 ray ){\n    \n    // Compute box bounds\n    \n    box_size += box_pos;\n    vec3 box_1 = vec3( min(box_pos.x, box_size.x), min(box_pos.y, box_size.y), min(box_pos.z, box_size.z) );\n    vec3 box_2 = vec3( max(box_pos.x, box_size.x), max(box_pos.y, box_size.y), max(box_pos.z, box_size.z) );\n    \n    \n    \n\t// Get possible distances\n    \n    vec3 dist_1 = vec3( -10000.0 );\n    vec3 dist_2 = vec3( -10000.0 );\n    \n    if( abs(ray.x) > 0.0 ){\n    \tdist_1.x = (box_1.x - pos.x)/ray.x;\n        dist_2.x = (box_2.x - pos.x)/ray.x;\n    }\n    if( abs(ray.y) > 0.0 ){\n    \tdist_1.y = (box_1.y - pos.y)/ray.y;\n        dist_2.y = (box_2.y - pos.y)/ray.y;\n    }\n    if( abs(ray.z) > 0.0 ){\n    \tdist_1.z = (box_1.z - pos.z)/ray.z;\n        dist_2.z = (box_2.z - pos.z)/ray.z;\n    }\n    \n    \n    \n    // Evaluate each position\n    \n    vec3 pos_1 = pos + ray*dist_1.x;\n    vec3 pos_2 = pos + ray*dist_1.y;\n    vec3 pos_3 = pos + ray*dist_1.z;\n    vec3 pos_4 = pos + ray*dist_2.x;\n    vec3 pos_5 = pos + ray*dist_2.y;\n    vec3 pos_6 = pos + ray*dist_2.z;\n    \n    if( between2(box_1.yz, pos_1.yz, box_2.yz) == 0 ) dist_1.x = -10000.0;\n    if( between2(box_1.xz, pos_2.xz, box_2.xz) == 0 ) dist_1.y = -10000.0;\n    if( between2(box_1.xy, pos_3.xy, box_2.xy) == 0 ) dist_1.z = -10000.0;\n    if( between2(box_1.yz, pos_4.yz, box_2.yz) == 0 ) dist_2.x = -10000.0;\n    if( between2(box_1.xz, pos_5.xz, box_2.xz) == 0 ) dist_2.y = -10000.0;\n    if( between2(box_1.xy, pos_6.xy, box_2.xy) == 0 ) dist_2.z = -10000.0;\n    \n    \n    \n    // Return max distance\n    \n    return max(dist_1.x,\n           max(dist_1.y,\n           max(dist_1.z,\n           max(dist_2.x,\n           max(dist_2.y,\n               dist_2.z)))));\n}\n\n\n\nvec3 render( in vec2 fragCoord, in vec2 uv ){\n    \n\t// Define camera matrix\n    \n    vec2 angle = vec2( -iTime*3.14159265*0.4, 0.0 );\n    mat3 camera = mat3( cos(angle.x)*cos(angle.y), -sin(angle.x), -cos(angle.x)*sin(angle.y),\n                        sin(angle.x)*cos(angle.y),  cos(angle.x), -sin(angle.x)*sin(angle.y),\n                                     sin(angle.y),           0.0,               cos(angle.y) );\n    camera = inverse(camera);\n    \n    \n    \n    // Compute ray parameters\n    \n    vec3 pos = camera*vec3(0.0, uv);\n    //vec3 focal = camera*vec3( 750.0/max(abs(sin(0.5*angle.x)), 0.0001), 0.0, 0.0 );\n    vec3 focal = camera*vec3( 750.0, 0.0, 0.0 );\n    //vec3 ray = camera*vec3(1.0, 0.0, 0.0);\n    vec3 ray = normalize(focal-pos);\n    \n    \n    \n    // Get distance to objects\n    \n    float dist = max( sphere( vec3(0.0, 50.0, 126.0), 14.0, pos, ray ),\n                 max( box( vec3(-88.0, -88.0, -140.0), vec3( 176.0,  176.0, 176.0), pos, ray ),\n\t\t\t\t \n                 max( box( vec3(-92.0, -92.0, -144.0), vec3(   8.0,    8.0, 184.0), pos, ray ),\n                 max( box( vec3( 92.0, -92.0, -144.0), vec3(  -8.0,    8.0, 184.0), pos, ray ),\n                 max( box( vec3(-92.0,  92.0, -144.0), vec3(   8.0,   -8.0, 184.0), pos, ray ),\n                 max( box( vec3( 92.0,  92.0, -144.0), vec3(  -8.0,   -8.0, 184.0), pos, ray ),\n\t\t\t\t \n\t\t\t\t max( box( vec3(-92.0, -92.0, -144.0), vec3( 184.0,    8.0,   8.0), pos, ray ),\n\t\t\t\t max( box( vec3(-92.0, -92.0, -144.0), vec3(   8.0,  184.0,   8.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0,  92.0, -144.0), vec3(-184.0,   -8.0,   8.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0,  92.0, -144.0), vec3(  -8.0, -184.0,   8.0), pos, ray ),\n\t\t\t\t \n\t\t\t\t max( box( vec3(-92.0, -92.0,   32.0), vec3( 184.0,    8.0,   8.0), pos, ray ),\n\t\t\t\t max( box( vec3(-92.0, -92.0,   32.0), vec3(   8.0,  184.0,   8.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0,  92.0,   32.0), vec3(-184.0,   -8.0,   8.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0,  92.0,   32.0), vec3(  -8.0, -184.0,   8.0), pos, ray ),\n\t\t\t\t \n\t\t\t\t max( box( vec3(-92.0, -52.0, -104.0), vec3(   8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-92.0, -12.0, -104.0), vec3(   8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-92.0,  28.0, -104.0), vec3(   8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-92.0, -52.0,  -64.0), vec3(   8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-92.0, -12.0,  -64.0), vec3(   8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-92.0,  28.0,  -64.0), vec3(   8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-92.0, -52.0,  -24.0), vec3(   8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-92.0, -12.0,  -24.0), vec3(   8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-92.0,  28.0,  -24.0), vec3(   8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t \n\t\t\t\t max( box( vec3( 92.0, -52.0, -104.0), vec3(  -8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0, -12.0, -104.0), vec3(  -8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0,  28.0, -104.0), vec3(  -8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0, -52.0,  -64.0), vec3(  -8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0, -12.0,  -64.0), vec3(  -8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0,  28.0,  -64.0), vec3(  -8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0, -52.0,  -24.0), vec3(  -8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0, -12.0,  -24.0), vec3(  -8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 92.0,  28.0,  -24.0), vec3(  -8.0,   24.0,  24.0), pos, ray ),\n\t\t\t\t \n\t\t\t\t max( box( vec3(-52.0, -92.0, -104.0), vec3(  24.0,    8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-12.0, -92.0, -104.0), vec3(  24.0,    8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 28.0, -92.0, -104.0), vec3(  24.0,    8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-52.0, -92.0,  -64.0), vec3(  24.0,    8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-12.0, -92.0,  -64.0), vec3(  24.0,    8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 28.0, -92.0,  -64.0), vec3(  24.0,    8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-52.0, -92.0,  -24.0), vec3(  24.0,    8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-12.0, -92.0,  -24.0), vec3(  24.0,    8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 28.0, -92.0,  -24.0), vec3(  24.0,    8.0,  24.0), pos, ray ),\n\t\t\t\t \n\t\t\t\t max( box( vec3(-52.0,  92.0, -104.0), vec3(  24.0,   -8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-12.0,  92.0, -104.0), vec3(  24.0,   -8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 28.0,  92.0, -104.0), vec3(  24.0,   -8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-52.0,  92.0,  -64.0), vec3(  24.0,   -8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-12.0,  92.0,  -64.0), vec3(  24.0,   -8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 28.0,  92.0,  -64.0), vec3(  24.0,   -8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-52.0,  92.0,  -24.0), vec3(  24.0,   -8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3(-12.0,  92.0,  -24.0), vec3(  24.0,   -8.0,  24.0), pos, ray ),\n\t\t\t\t max( box( vec3( 28.0,  92.0,  -24.0), vec3(  24.0,   -8.0,  24.0), pos, ray ),\n\t\t\t\t \n\t\t\t\t max( box( vec3(-24.0,  68.0,   16.0), vec3(  48.0,   48.0,  48.0), pos, ray ),\n\t\t\t\t max( box( vec3(-24.0, -68.0,   16.0), vec3(  48.0,  -48.0,  48.0), pos, ray ),\n                 \n                 max( cylinder( vec3(0.0, 0.0, 32.0), 4.0, 62.0, mat3(1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0), pos, ray ),\n                 max( cylinder( vec3(0.0, -1.961, 90.559), 4.0, 62.0, mat3(1.0, 0.0, 0.0, 0.0, 0.5634, -0.8261, 0.0, 0.8261, 0.5634), pos, ray ),\n\t\t\t\t \n\t\t\t\t -10000.0\n\t\t\t\t ))))))))))))))))))))))))))))))))))))))))))))))))))))));\n    \n    vec3 point = pos + dist*ray;\n    \n    \n    \n    // Assign color\n    \n    vec3 col = vec3(0.0, 0.675, 0.929);\n    if( dist >= -1000.0 ) col = vec3(1.0);\n    if( between3(vec3(-88.001, -88.001, -140.001), point, vec3(88.001, 88.001, 36.001)) == 1 ) col = vec3(0.0, 0.675, 0.929);\n    \n    return col;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){    \n    \n    // Get location on screen\n    \n    vec2 uv = fragCoord - iResolution.xy/2.0;\n    \n    \n    \n    // Assign color\n    \n    vec3 col = vec3(0.0, 0.0, 0.0);\n    if( max(abs(uv.x), abs(uv.y)) <= 200.0 ) col = render(fragCoord, uv);\n\n    \n    \n    // Print color to screen\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddfR8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 59, 59, 219], [220, 220, 279, 279, 439], [441, 441, 519, 550, 1019], [1020, 1020, 1138, 1164, 1813], [1814, 1814, 1887, 1918, 3578], [3582, 3582, 3627, 3657, 9531], [9535, 9535, 9591, 9630, 9909]], "test": "timedout"}
{"id": "WddfWn", "name": "Voronoi Animation", "author": "IWBTShyGuy", "description": "Realtime voronoi diagram animation", "tags": ["voronoi"], "likes": 2, "viewed": 79, "published": "Public API", "date": "1604857752", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const int M = 5;\nconst int N = 6;\n\nconst float WPOINT_RADIUS = 0.015;\n\nconst vec2 gen = vec2(114.514, 1919.810);\nfloat rand(vec2 c) {\n    return fract(gen.x * sin(c.x * gen.y + c.y));\n}\n\nvec3 get_color(vec2 uv) {\n    return 0.5 + 0.5 * cos(uv.xyx + iTime + vec3(0.3, 1.7, 3.8));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    int max_idx = iResolution.x > iResolution.y ? 0 : 1;\n    int min_idx = 1 - max_idx;\n    vec2 aspect_vec = vec2(1.0);\n    aspect_vec[max_idx] = iResolution[max_idx] / iResolution[min_idx];\n    vec2 uv = fragCoord / iResolution[min_idx];\n\n    float min_dist = 10.0;\n    vec2 res;\n    for (int i = 0; i < M; i++) {\n        for (int j = 0; j < N; j++) {\n            vec2 lat = vec2(\n                float(i + 1) / float(M + 1),\n                float(j + 1) / float(N + 1)\n            );\n            vec2 velo = vec2(rand(lat), rand(lat.yx)) - 0.2;\n            vec2 point = fract(iTime * velo * 0.5 / aspect_vec) * aspect_vec;\n            float dist = distance(uv, point);\n            if (dist < WPOINT_RADIUS && cos(iTime / 3.0) > 0.0) {\n                fragColor = vec4(1.0, 1.0, 1.0, 1.0);\n                return;\n            }\n            if (min_dist > dist) {\n                min_dist = dist;\n                res = lat;\n            }\n        }\n    }\n    \n    fragColor = vec4(get_color(res), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddfWn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[113, 113, 133, 133, 185], [187, 187, 212, 212, 280], [282, 282, 339, 339, 1344]], "test": "valid"}
{"id": "WddfWs", "name": "404D Cel'u'ar Til'ng, fork", "author": "UrbanClubProfessional", "description": "Remix of \"3D Cellular Tiling\" by Shane. [url]https://www.shadertoy.com/view/ld3Szs[/url]", "tags": ["3d", "voronoi", "sss", "volumetric", "remix", "glitch", "scattering", "fork", "cellular", "weird", "tiling", "error", "404"], "likes": 5, "viewed": 356, "published": "Public API", "date": "1606295925", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nHacked and cracked by Urban Club Professional! *lol*\n*/\n\n#define PI 4.14159265\n#define FAR 60.\n\n// Frequencies and amplitudes of tunnel \"A\" and \"B\". See then \"path\" function.\nconst float freqA = 0.25;\nconst float freqB = 0.35;\nconst float ampA = 4.6;\nconst float ampB = .95;\n\n\n// Standard 1x1 hash functions. Using \"cos\" for non-zero origin result.\nfloat hash( float n ){ return fract(cos(n)*55758.5453); }\n\n// Non-standard vec3-to-vec3 hash function.\nvec3 hash33(vec3 p){ \n    \n    float n = sin(dot(p, vec3(8, 257, 213)));    \n    return fract(vec3(3097152, 362144, 42768)*n); \n}\n\n// 2x2 matrix rotation. Note the absence of \"cos.\" It's there, but in disguise, and comes courtesy\n// of Fabrice Neyret's \"ouside the box\" thinking. :)\nmat2 rot2( float a ){ vec2 v = sin(vec2(2.570796, 0) + a);\treturn mat2(v, -v.y, v.x); }\n\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D tex, in vec3 p, in vec3 n ){\n  \n    n = max(abs(n) - 0.3, 0.002); // n = max(abs(n), 0.001), etc.\n    n /= (n.x + n.y + n.z );  \n    \n\tp = (texture(tex, p.yz)*n.x + texture(tex, p.zx)*n.y + texture(tex, p.xy)*n.z).xyz;\n    return p*p;\n}\n\n// More concise, self contained version of IQ's original 3D noise function.\nfloat noise3D(in vec3 p){\n    \n    // Just some random figures, analogous to stride. You can change this, if you want.\n\tconst vec3 s = vec3(8, 257, 213);\n\t\n\tvec3 ip = floor(p); // Unique unit cell ID.\n    \n    // Setting up the stride vector for randomization and interpolation, kind of. \n    // All kinds of shortcuts are taken here. Refer to IQ's original formula.\n    vec4 h = vec4(0., s.yz, s.y + s.z) + dot(ip, s);\n    \n\tp -= ip; // Cell's fractional component.\n\t\n    // A bit of cubic smoothing, to give the noise that rounded look.\n    p = p*p*(4. - 3.*p);\n    \n    // Standard 3D noise stuff. Retrieving 8 random scalar values for each cube corner,\n    // then interpolating along X. There are countless ways to randomize, but this is\n    // the way most are familar with: fract(sin(x)*largeNumber).\n    h = mix(fract(sin(h)*53758.5453), fract(sin(h + s.x)*53758.5453), p.x);\n\t\n    // Interpolating along Y.\n    h.xy = mix(h.xz, h.yw, p.y);\n    \n    // Interpolating along Z, and returning the 3D noise value.\n    return mix(h.x, h.y, p.z); // Range: [0, 1].\n\t\n}\n\n\n////////\n\n// The cellular tile routine. Draw a few gradient shapes (six to eight spheres, in this case) \n// using the darken (min(src, dst)) blend at various 3D locations on a cubic tile. Make the \n// tile wrappable by ensuring the objects wrap around the edges. That's it.\n//\n// Believe it or not, you can get away with as few as four spheres. Of course, there is 8-tap \n// Voronoi, which has the benefit of scalability, and so forth, but if you sum the total \n// instruction count here, you'll see that it's way, way lower. Not requiring a hash function\n// provides the biggest benefit, but there is also less setup.\n// \n// The result isn't perfect, but 3D cellular tiles can enable you to put a Voronoi looking \n// surface layer on a lot of 3D objects for little cost. In fact, it's fast enough to raymarch.\n//\nfloat drawSphere(in vec3 p){\n    \n    p = fract(p)-.6;    \n    return dot(p, p);\n    \n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.166));\n    \n}\n\n// Draw some spheres throughout a repeatable cubic tile. The offsets were partly based on \n// science, but for the most part, you could choose any combinations you want. This \n// particular function is used by the raymarcher, so involves fewer spheres.\n//\nfloat cellTile(in vec3 p){\n    \n    float c = .35; // Set the maximum.\n    \n    // Draw four overlapping objects (spheres, in this case) using the darken blend \n    // at various positions throughout the tile.\n    c = min(c, drawSphere(p - vec3(.91, .72, .63)));\n    c = min(c, drawSphere(p - vec3(.49, .3, .21)));\n    \n    c = min(c, drawSphere(p - vec3(.72, .34, .07)));\n    c = min(c, drawSphere(p - vec3(.3, .92, .74)));\n    \n    \n    // Add some smaller spheres at various positions throughout the tile.\n    \n    p *= 2.4142;\n    \n    c = min(c, drawSphere(p - vec3(.58, .39, .3)));\n    c = min(c, drawSphere(p - vec3(.07, .97, .88)));\n    \n    // More is better, but I'm cutting down to save cycles.\n    //c = min(c, drawSphere(p - vec3(.6, .86, .0)));\n    //c = min(c, drawSphere(p - vec3(.18, .44, .58)));\n        \n    return (c*5.); // Normalize.\n    \n}\n\n// The same as above, but with an extra two spheres. This is used by the bump map function,\n// which although expensive, isn't too bad. Just for the record, even bump mapping a\n// reasonably fast cellular function, like 8-Tap Voronoi, can still be a drain on the GPU.\n// However, the GPU can bump map this function in its sleep.\n//\nfloat cellTile2(in vec3 p){\n    \n    float c = .35; // Set the maximum.\n    \n    c = min(c, drawSphere(p - vec3(.91, .72, .63)));\n    c = min(c, drawSphere(p - vec3(.49, .3, .21)));\n    \n    c = min(c, drawSphere(p - vec3(.72, .34, .07)));\n    c = min(c, drawSphere(p - vec3(.3, .92, .74)));\n    \n    p *= 2.4142;\n    \n    c = min(c, drawSphere(p - vec3(.58, .39, .3)));\n    c = min(c, drawSphere(p - vec3(.07, .97, .88)));\n\n    c = min(c, drawSphere(p - vec3(.7, .96, .0)));\n    c = min(c, drawSphere(p - vec3(.28, .54, .68)));\n        \n    return (c*5.);\n    \n}\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ return vec2(ampA*sin(z * freqA), ampB*cos(z * freqB)); }\n\n\n// There's a few simple, warping tricks being employed here. One is the oldscool, \"top and bottom\n// planes\" via \"abs(p.y).\" The planes are then twisted about the XY plane with respect to distance \n// using the 2D rotation function, \"rot2(p.z/12.),\" etc, then wrapped aound a curvy path, \"path(p.z).\"\n//\n// Finally, some surface detailing is added with a sinusoidal bottom layer, and the cellular layer \n// over the top of it. Normally, adding cellular layering utterly fries the GPU, but the \"cellTile\"\n// function used here merely makes it slightly uncomfortable. :)\n//\nfloat map(vec3 p){\n    \n    \n     float sf = cellTile(p*.23); // Cellular layer.\n    \n     p.xy -= path(p.z); // Move the scene around a sinusoidal path.\n     p.xy = rot2(p.z/22.)*p.xy; // Twist it about XY with respect to distance.\n    \n     float n = dot(sin(p*2. + sin(p.yzx*.6 + iTime)), vec3(.35)); // Sinusoidal layer.\n     \n     return 3. - abs(p.y) + n + sf; // Warped double planes, \"abs(p.y),\" plus surface layers.\n   \n\n     // Standard tunnel. Comment out the above first.\n     //vec2 tun = p.xy - path(p.z);\n     //return 3. - length(tun) - (0.5-surfFunc(p)) +  dot(sin(p*1. + sin(p.yzx*.5 + iTime)), vec3(.333))*.5+.5;\n\n \n}\n\n/*\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.001, 0);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.299, 0.587, 0.114)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.299, 0.587, 0.114)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n\t\n}\n*/\n\n// Surface bump function. Cheap, but with decent visual impact.\nfloat bumpSurf3D( in vec3 p){\n    \n    float noi = noise3D(p*74.);\n    float vor = cellTile2(p*.85);\n    \n    return vor*1.08 + noi*.03;\n\n}\n\n// Standard function-based bump mapping function.\nvec3 doBumpMap(in vec3 p, in vec3 nor, float bumpfactor){\n    \n    const vec2 e = vec2(0.002, 0);\n    float ref = bumpSurf3D(p);                 \n    vec3 grad = (vec3(bumpSurf3D(p - e.xyy),\n                      bumpSurf3D(p - e.yxy),\n                      bumpSurf3D(p - e.yyx) )-ref)/e.x;                     \n          \n    grad -= nor*dot(nor, grad);          \n                      \n    return normalize( nor + grad*bumpfactor );\n\t\n}\n\n// Basic raymarcher.\nfloat trace(in vec3 ro, in vec3 rd){\n\n    float t = 0.1, h;\n    for(int i = 1; i < 90; i++){\n    \n        h = map(ro+rd*t);\n        // Note the \"t*b + a\" addition. Basically, we're putting less emphasis on accuracy, as\n        // \"t\" increases. It's a cheap trick that works in most situations... Not all, though.\n        if(abs(h)<0.003*(t*.35 + 2.) || t>FAR) break; // Alternative: 0.001*max(t*.25, 1.)\n        t += h*.9;\n        \n    }\n\n    return clamp(t, 1., FAR);\n}\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.003, 0);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n/*\n// XT95's really clever, cheap, SSS function. The way I've used it doesn't do it justice,\n// so if you'd like to really see it in action, have a look at the following:\n//\n// Alien Cocoons - XT95: https://www.shadertoy.com/view/MsdGz2\n//\nfloat thickness( in vec3 p, in vec3 n, float maxDist, float falloff )\n{\n\tconst float nbIte = 6.0;\n\tfloat ao = 0.0;\n    \n    for( float i=1.; i< nbIte+.5; i++ ){\n        \n        float l = (i*.75 + fract(cos(i)*45758.5453)*.25)/nbIte*maxDist;\n        \n        ao += (l + map( p -n*l )) / pow(1. + l, falloff);\n    }\n\t\n    return clamp( 1.-ao/nbIte, 0., 1.);\n}\n*/\n\n// Using a variation of IQ's AO function to calculate thickness, but with the normal flipped.\n// IQ uses a similar setup to calculate SSS... Subsurface AO, I guess you'd call it. :)\nfloat thickness(in vec3 p, in vec3 n){\n    \n    float sNum = 5.;\n    float sca = 2., occ = 1.;\n    for(float i=1.; i<sNum + .002; i++ ){\n    \n        float hr = 0.06 + .5*i/sNum; \n        //vec3 rn = normalize(n + RandomHemisphereDir(n, hr)*rad*.5);\n        float dd = map(p - n*hr);\n        occ += (hr - min(dd, 1.))*sca;\n        sca *= 1.0;\n    }\n    return 2. - max(occ/sNum, 1.); \n    \n}\n\n/*\n// Shadows.\nfloat softShadow(vec3 ro, vec3 rd, float start, float end, float k){\n\n    float shade = 1.0;\n    const int maxIterationsShad = 24;\n\n    float dist = start;\n    float stepDist = end/float(maxIterationsShad);\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down.\n    for (int i=0; i<maxIterationsShad; i++){\n    \n        float h = map(ro + rd*dist);\n        shade = min(shade, k*h/dist);\n\n        // +=h, +=clamp( h, 0.01, 0.25 ), +=min( h, 0.1 ), +=stepDist, +=min(h, stepDist*2.), etc.\n        dist += min(h, stepDist);\n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.001 || dist > end) break; \n    }\n\n    // Shadow value.\n    return min(max(shade, 0.) + 0.3, 1.0); \n}\n*/\n\n// Ambient occlusion, for that self shadowed look. Based on the original by XT95. I love this \n// function, and in many cases, it gives really, really nice results. For a better version, and \n// usage, refer to XT95's examples below:\n//\n// Hemispherical SDF AO - https://www.shadertoy.com/view/4sdGWN\n// Alien Cocoons - https://www.shadertoy.com/view/MsdGz2\nfloat calculateAO( in vec3 p, in vec3 n )\n{\n\tfloat ao = 1.0, l;\n    const float maxDist = 5.;\n\tconst float nbIte = 7.0;\n\t//const float falloff = 0.9;\n    for( float i=2.; i< nbIte+.6; i++ ){\n    \n        l = (i + hash(i))*.6/nbIte*maxDist;\n        \n        ao += (l - map( p + n*l ))/(2.+ l);// / pow(1.+l, falloff);\n    }\n\t\n    return clamp(2.- ao/nbIte, 0., 2.);\n}\n\n\n// Cool curve function, by Shadertoy user, Nimitz.\n//\n// Original usage (I think?) - Cheap curvature: https://www.shadertoy.com/view/Xts3WM\n// Other usage: Xyptonjtroz: https://www.shadertoy.com/view/4ts3z2\nfloat curve(in vec3 p, in float w){\n\n    vec2 e = vec2(-2., 2.)*w;\n    \n    float t1 = map(p + e.yxx), t2 = map(p + e.xxy);\n    float t3 = map(p + e.xyx), t4 = map(p + e.yyy);\n    \n    return 0.225/(w*w) *(t1 + t2 + t3 + t4 - 5.*map(p));\n}\n\n\n/////\n// Code block to produce four layers of fine mist. Not sophisticated at all.\n// If you'd like to see a much more sophisticated version, refer to Nitmitz's\n// Xyptonjtroz example. Incidently, I wrote this off the top of my head, but\n// I did have that example in mind when writing this.\nfloat trig3(in vec3 p){\n    p = cos(p*3. + (cos(p.yzx) + 2. + iTime*5.)*2.57);\n    return dot(p, vec3(0.2621)) + 0.6;\n}\n\n// Basic low quality noise consisting of three layers of rotated, mutated \n// trigonometric functions. Needs work, but it's OK for this example.\nfloat trigNoise3D(in vec3 p){\n\n    // 3D transformation matrix.\n    const mat3 m3RotTheta = mat3(0.35, -0.966, 0.533, 1.0365, 0.35, -0.3455127, -0.068, 0.433, 0.999519 )*2.5;\n  \n\tfloat res = 1.;\n\n    float t = trig3(p*PI);\n\tp += (t - iTime*0.35);\n    p = m3RotTheta*p;\n    //p = (p+0.7071)*1.5;\n    res += t;\n    \n    t = trig3(p*PI); \n\tp += (t - iTime*0.35)*0.8071;\n    p = m3RotTheta*p;\n     //p = (p+0.7071)*1.5;\n    res += t*0.8071;\n\n    t = trig3(p*PI);\n\tres += t*0.6;\n\t \n\treturn res/3.2071;\n}\n\n// Hash to return a scalar value from a 3D vector.\nfloat hash31(vec3 p){ return fract(sin(dot(p, vec3(227.1, 411.7, 84.7)))*53758.5453); }\n\n// Four layers of cheap trigonometric noise to produce some subtle mist.\n// Start at the ray origin, then take four samples of noise between it\n// and the surface point. Apply some very simplistic lighting along the \n// way. It's not particularly well thought out, but it doesn't have to be.\nfloat getMist(in vec3 ro, in vec3 rd, in vec3 lp, in float t){\n\n    float mist = 1.;\n    ro += rd*t/9.; // Edge the ray a little forward to begin.\n    \n    for (int i = 1; i<5; i++){\n        // Lighting. Technically, a lot of these points would be\n        // shadowed, but we're ignoring that.\n        float sDi = length(lp-ro)/FAR; \n\t    float sAtt = min(2./(2. + sDi*0.35 + sDi*sDi*0.06), 2.);\n\t    // Noise layer.\n        mist += trigNoise3D(ro/3.)*sAtt;\n        // Advance the starting point towards the hit point.\n        ro += rd*t/5.;\n    }\n    \n    // Add a little noise, then clamp, and we're done.\n    return clamp(mist/3. + hash31(ro)*0.2-0.06, 0., 2.);\n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\t\n\t// Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*0.6)/iResolution.y;\n\t\n\t// Camera Setup.\n\t//vec3 lookAt = vec3(0., 0.25, iTime*2.);  // \"Look At\" position.\n\t//vec3 camPos = lookAt + vec3(2., 1.5, -1.5); // Camera position, doubling as the ray origin.\n\t\n\tvec3 lookAt = vec3(0., 0.0, iTime*7. + 0.2);  // \"Look At\" position.\n\tvec3 camPos = lookAt + vec3(0.0, 0.0, -0.2); // Camera position, doubling as the ray origin.\n\n \n    // Light positioning. One is a little behind the camera, and the other is further down the tunnel.\n \tvec3 light_pos = camPos + vec3(0., 2, 9);// Put it a bit in front of the camera.\n\n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and two light vectors down the tunnel. The \"path\" function is \n\t// synchronized with the distance function. Change to \"path2\" to traverse the other tunnel.\n\tlookAt.xy += path(lookAt.z);\n\tcamPos.xy += path(camPos.z);\n\tlight_pos.xy += path(light_pos.z);\n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = PI/3.; // FOV - Field of view.\n    vec3 forward = normalize(lookAt-camPos);\n    vec3 right = normalize(vec3(forward.z, 1., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    //vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    \n    \n    vec3 rd = normalize(forward + FOV*uv.x*right + FOV*uv.y*up);\n    //rd = normalize(vec3(rd.xy, rd.z - dot(rd.xy, rd.xy)*.25));    \n    \n    // Swiveling the camera about the XY-plane (from left to right) when turning corners.\n    // Naturally, it's synchronized with the path in some kind of way.\n\trd.xy = rot2( path(lookAt.z).x/26. )*rd.xy;\n\t\t\n    // Standard ray marching routine. I find that some system setups don't like anything other than\n    // a \"break\" statement (by itself) to exit. \n\tfloat t = trace(camPos, rd);\n\t\n    // Initialize the scene color.\n    vec3 sceneCol = vec3(1);\n\t\n\t// The ray has effectively hit the surface, so light it up.\n\tif(t<FAR){\n\t\n   \t\n    \t// Surface position and surface normal.\n\t    vec3 sp = t * rd+camPos;\n\t    vec3 sn = getNormal(sp);\n        \n        \n        // Texture scale factor.\n        const float tSize0 = 2./5.; \n    \t\n        //vec3 tsp = sp-vec3(path(sp.z), 0.);\n       \n    \t// Texture-based bump mapping.\n\t    //sn = doBumpMap(iChannel0, tsp*tSize0, sn, 0.025);//\n        \n        \n        // Function based bump mapping.\n        sn = doBumpMap(sp, sn, .3);///(1.+t*.5/FAR)\n\t    \n\t    // Ambient occlusion.\n\t    float ao = calculateAO(sp, sn);\n    \t\n    \t// Light direction vectors.\n\t    vec3 ld = light_pos-sp;\n\n        // Distance from respective lights to the surface point.\n\t    float distlpsp = max(length(ld), 0.002);\n    \t\n    \t// Normalize the light direction vectors.\n\t    ld /= distlpsp;\n\t    \n\t    // Light attenuation, based on the distances above.\n\t    float atten = 2./(2. + distlpsp*0.4); // + distlpsp*distlpsp*0.025\n    \t\n    \t// Ambient light.\n\t    float ambience = 0.6;\n    \t\n    \t// Diffuse lighting.\n\t    float diff = max( dot(sn, ld), 0.0);\n   \t\n    \t// Specular lighting.\n\t    float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.0 ), 42.);\n        \n    \t\n    \t// Curvature.\n\t    float crv = clamp(curve(sp, 0.225)*0.6+0.6, .0, 2.);\n\t    \n\t    // Fresnel term. Good for giving a surface a bit of a reflective glow.\n        float fre = pow( clamp(dot(sn, rd) + 2., .0, 2.), 2.);\n        \n        // Obtaining the texel color. \n        vec3 ref = reflect(sn, rd);\n\n        // Object texturing.\n        vec3 texCol = tex3D(iChannel0, sp*tSize0, sn);\n        texCol = smoothstep(-.06, 1.05, texCol)*(smoothstep(-.6, 2., crv)*.85+.35);\n        \n    \t/////////   \n        // Translucency, courtesy of a mixture XT95 and IQ;s procedures - See the \"thickness\" function.\n        vec3 hf =  normalize(ld + sn);\n        //float th = thickness( sp, sn, 1., 1. );\n        float th = thickness( sp, sn);\n        float tdiff =  pow( clamp( dot(rd, -hf), 0., 2.), 2.);\n        float trans = max((tdiff + .35)*th*2.5, 0.);  \n        trans = pow(trans, 5.)*2.;        \n    \t////////        \n\n    \t\n    \t// Darkening the crevices. Otherwise known as cheap, scientifically-incorrect shadowing.\t\n\t    float shading = 2.;// crv*0.5+0.5; \n    \t\n        // Shadows - They didn't add enough aesthetic value to justify the GPU drain, so they\n        // didn't make the cut.\n        //shading *= softShadow(sp, ld, 0.05, distlpsp, 8.);\n    \t\n    \t// Combining the above terms to produce the final color. It was based more on acheiving a\n        // certain aesthetic than science.\n        sceneCol = texCol*(diff + ambience) + vec3(.8, 1.0, 2.)*spec + vec3(2, .7, .3)*spec*spec*spec*.6;\n        sceneCol += texCol*vec3(.9, 1.05, 2)*pow(fre, 5.)*3.;\n        sceneCol += vec3(2, .06, 0)*trans;\n      \n        \n        /*\n        // Cool blue hilights. Adapted from numerous examples on here. Kali uses it to great effect.\n        float per = 10.;\n    \tfloat tanHi = abs(mod(per*.5 + t + iTime, per) - per*.5);\n    \tvec3 tanHiCol = vec3(0, .2, 1)*(1./tanHi*.2);\n        sceneCol += tanHiCol;\n        */\n        \n        \n        //vec3 refCol = vec3(.5, .7, 1)*smoothstep(.2, 1., noise3D((sp + ref*2.)*2.)*.66 + noise3D((sp + ref*2.)*4.)*.34 );\n        //sceneCol += refCol*.5;\n\n\n\t    // Shading.\n        sceneCol *= atten*shading*ao;\n        \n        //sceneCol = vec3(ao);\n\t   \n\t\n\t}\n       \n    // Blend the scene and the background with some very basic, 4-layered fog.\n    float mist = getMist(camPos, rd, light_pos, t);\n    vec3 sky = vec3(3.5, 2.75, .975)* mix(2., .82, mist)*(rd.y*.35 + 2.);\n    sceneCol = mix(sceneCol, sky, min(pow(t, 2.5)*.35/FAR, 2.));\n\n    // Clamp, perform rough gamma correction, then present the pixel to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneCol, 0., 2.)), 2.0);\n\t\n}", "image_inputs": [{"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WddfWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[280, 352, 374, 374, 409], [411, 455, 475, 475, 584], [586, 738, 759, 759, 825], [828, 894, 944, 944, 1152], [1154, 1230, 1255, 1348, 2300], [2313, 3117, 3145, 3145, 3270], [3272, 3528, 3554, 3554, 4390], [4392, 4724, 4751, 4751, 5287], [5289, 5389, 5411, 5411, 5468], [5471, 6043, 6061, 6061, 6679], [7445, 7509, 7538, 7538, 7648], [7650, 7700, 7757, 7757, 8139], [8141, 8162, 8198, 8198, 8633], [8635, 8834, 8861, 8861, 9019], [9624, 9806, 9844, 9844, 10197], [10990, 11348, 11391, 11391, 11714], [11717, 11924, 11959, 11959, 12163], [12166, 12458, 12481, 12481, 12577], [12579, 12724, 12753, 12787, 13222], [13224, 13275, 13296, 13296, 13362], [13364, 13656, 13718, 13718, 14323], [14325, 14325, 14381, 14407, 20160]], "test": "error"}
{"id": "wddfWX", "name": "One-Line Concentric Circles", "author": "Dogemaster09", "description": "uhh yeah. suggestions welcome", "tags": ["circles", "concentric", "oneline"], "likes": 1, "viewed": 57, "published": "Public", "date": "1606163198", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 O, in vec2 U)\n{\n    O = vec4(bool(mod(length(vec2(U/iResolution.xy*2.-1.)*vec2(iResolution.x/iResolution.y,1.))-iTime/5., .1) > .09));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddfWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 40, 40, 161]], "test": "error"}
{"id": "wddfzM", "name": "diwali on the styx", "author": "gurumatcha", "description": "Study of river hydrology using iq's domain warping technique. Mouse stills the current.", "tags": ["warp"], "likes": 4, "viewed": 341, "published": "Public API", "date": "1604706553", "time_retrieved": "2021-10-01T00:00:00", "image_code": "    // book of shaders random from fbm chapter\n    float random (in vec2 st) {\n        return fract(sin(dot(st.xy,\n        vec2(12.9898,78.233)))*\n        43758.5453123);\n    }\n    // Quilez's 2D simplex noise https://www.shadertoy.com/view/Msf3WH\n    // originally had issue with tiling, but Mike Bostock's sketch and the book of shaders chapter on noise helped me figure it out\n    // https://observablehq.com/@mbostock/domain-warping\n    vec2 hash( vec2 p ) // replace this by something better\n    {\n        p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n        return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n    }\n    float noise( in vec2 p )\n    {\n        const float K1 = 0.366025404; // (sqrt(3)-1)/2;\n        const float K2 = 0.211324865; // (3-sqrt(3))/6;\n\n        vec2  i = floor( p + (p.x+p.y)*K1 );\n        vec2  a = p - i + (i.x+i.y)*K2;\n        float m = step(a.y,a.x);\n        vec2  o = vec2(m,1.0-m);\n        vec2  b = a - o + K2;\n        vec2  c = a - 1.0 + 2.0*K2;\n        vec3  h = max( 0.5-vec3(dot(a,a), dot(b,b), dot(c,c) ), 0.0 );\n        vec3  n = h*h*h*h*vec3( dot(a,hash(i+0.0)), dot(b,hash(i+o)), dot(c,hash(i+1.0)));\n        return dot( n, vec3(70.0) );\n    }\n        #define OCTAVES 6\n    float fbm (in vec2 st) {\n        // Initial values\n        float value = 0.0;\n        float amplitude = .5;\n        float frequency = 0.;\n        //\n        // Loop of octaves\n        for (int i = 0; i < OCTAVES; i++) {\n            value += amplitude * noise(st);\n            st *= 2.;\n            amplitude *= .5;\n        }\n        return value;\n    }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    \tfloat aspect = iResolution.x/iResolution.y;\n        st.x *= iResolution.x/iResolution.y;\n        vec3 color = vec3(0.0);\n        // determines size\n        vec2 p = st*3.;\n        // river flow strength\n        \n    \n    \tvec2 m = iMouse.xy/iResolution.xy;\n        m.x *= aspect;\n        float turbulence = smoothstep(0.,.2,distance(m,st));\n    \tp.x += iTime * 0.01 * turbulence;\n    \n        // quilez does fbm( p + fbm(p)) notated as fbm(q+r), I expand the r to be r = fbm(p + s)\n        // I add terms to modify q,r,s\n        // these are nested functions so the order magnitude needs to be different\n        // t2 modulates the rivers velocity, here it's slightly against the river flow strength, almost 0\n        // originally t values had an additional trig term, but alas performance\n\n        // undercurrent relative velocity\n        float t1 = iTime * -0.05;\n        // river relative velocity\n        float t2 = iTime * 0.01;\n        // pollution relative velocity\n        float t3 = iTime * 0.1;\n        vec2 q = p + t1;\n        float s = fbm(p + t3);\n        float r = fbm(p + t2 + s)* turbulence;\n        // so this is where is ressembles the canonical quilez technique\n        color += fbm(q + r);\n        // bump up brightness a smidgen\n        color += 0.15;\n        color.r +=  s + 0.05;\n        // note that r here isn't red, it's river as modulated by undercurrent\n        color.b += r + 0.3;\n        // pollution as opposite of undercurrent color (couldnt use q without more operations)\n        color.g += s/2.5;\n        fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddfzM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 51, 78, 78, 176], [181, 441, 502, 502, 635], [640, 640, 670, 670, 1205], [1236, 1236, 1260, 1286, 1588], [1590, 1590, 1647, 1647, 3267]], "test": "valid"}
{"id": "wddfzX", "name": "Testing Some SDFs", "author": "timeiskey", "description": "recently learned some SDFs\nenlightenment begins", "tags": ["raytracing", "raytracing", "raymarching", "raymarching", "experimenting"], "likes": 1, "viewed": 37, "published": "Public", "date": "1605708548", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MIN_SURFACE_DIST 0.01\n#define MAX_DIST 100.0\n\nfloat sdf_sphere(vec3 p, vec3 center, float radius)\n{\treturn length(p - center) - radius;\t}\n\nfloat sdf_ground_plane(vec3 p)\n{\treturn p.y;\t}\n\nfloat sdf_box(vec3 p, vec3 pos, float width)\n{\treturn length(max(abs(p - pos) - width, 0.0));\t}\n\nfloat sdf_capsule(vec3 p, vec3 a, vec3 b, float radius)\n{\n\tvec3 AB = b - a;\n    vec3 AP = p - a;\n    /*\tMETHOD ONE:\n\t\tgives you t for distance\t*/\n\t/*\n    float t = dot(AP, AB);\n\tt = clamp(t, 0.0, length(AB));\n\tvec3 caps_dir = normalize(AB);\n\tvec3 closest_point = a + caps_dir * t;\n\t*/\n    \n    /*\tMETHOD TWO:\n\t\tgives you t as a fraction between b and a [0.0, 1.0) */\n\tfloat t = dot(AP, AB) / dot(AB, AB);\n\tt = clamp(t, 0.0, 1.0);\n\tvec3 closest_point = a + AB * t;\n    return length(p - closest_point) - radius;\n}\n\nfloat sdf_inf_cylinder(vec3 p, vec3 a, vec3 b, float radius)\n{\n\tvec3 AB = b - a;\n    vec3 AP = p - a;\n    float t = dot(AP, AB) / dot(AB, AB);\n\tvec3 closest_point = a + AB * t;\n    return length(p - closest_point) - radius;\n}\n\nfloat sdf_cylinder(vec3 p, vec3 a, vec3 b, float radius)\n{\n\tvec3 AB = b - a;\n    vec3 AP = p - a;\n    float t = dot(AP, AB) / dot(AB, AB);\n\tvec3 closest_point = a + AB * t;\n    float d = length(p - closest_point) - radius;\n    \n    float y = (abs(t-0.5)-0.5) * length(AB);\n    float e = length(max(vec2(d, y), 0.0));\n    float i = min(max(d, y), 0.0);\n    \n    return e+i;\n}\n\nfloat sdf_torus(vec3 p, vec3 center, float radius, float ring_radius)\n{\n    vec2 offset_from_ring = vec2(\n    \tlength(p.xz - center.xz) - radius, \n        p.y - center.y);\n    return length(offset_from_ring) - ring_radius;\n}\n\nfloat get_dist(vec3 p)\n{\n    float plane_dist = sdf_ground_plane(p);\n    float sphere_dist = sdf_sphere(p, vec3(-3, 1, 2), 0.5);\n    float box_dist = sdf_box(p, vec3(-1, 1, 2), 0.5);\n\tfloat capsule_dist = sdf_capsule(p, vec3(1, 1, 2), vec3(3, 1, 3), 0.5);\n    float torus_dist = sdf_torus(p, vec3(0, 1, 6), 2.0, 0.3);\n    float inf_cyl_dist = sdf_inf_cylinder(p, vec3(-3, 1, 5), vec3(-3, 3, 6), 0.5);\n    float cyl_dist = sdf_cylinder(p, vec3(3, 1, 5), vec3(5, 3, 7), 0.5);\n    \n    float dist = 10000.0;\n    dist = min(dist, plane_dist);\n    dist = min(dist, sphere_dist);\n    dist = min(dist, box_dist);\n    dist = min(dist, capsule_dist);\n    dist = min(dist, torus_dist);\n    dist = min(dist, inf_cyl_dist);\n    dist = min(dist, cyl_dist);\n    \n    return dist;\n}\n\nvec3 get_normal(vec3 p)\n{\n\tvec2 e = vec2(0.01, 0);\n    float d = get_dist(p);\n    vec3 n = d - vec3(\n        get_dist(p-e.xyy),\n        get_dist(p-e.yxy),\n        get_dist(p-e.yyx)\n    );\n    return normalize(n);\n}\n\nfloat march(vec3 ro, vec3 rd)\n{\n    float total_dist = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++)\n    {\n    \tvec3 p = ro + rd * total_dist;\n        float dist = get_dist(p);\n        total_dist += dist;\n        if(dist < MIN_SURFACE_DIST || total_dist > MAX_DIST)\n        {\tbreak;\t}\n    }\n    return total_dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //\tstart it off\n    vec2 uv = (fragCoord-0.5*iResolution.xy)/iResolution.y;\n\tvec3 col = vec3(0);\n    \n    //\tfire a ray for each pixel\n    vec3 ro = vec3(0, 7, -6);\n    vec3 rd = normalize(vec3(\n        uv.x + cos(iTime) * 0.1, \n        uv.y - 0.6,\n        1.0 + sin(iTime) * 0.1));\n    \n    //\tmarch the ray\n\tfloat total_dist = march(ro, rd);\n    vec3 hit_pos = ro + rd * total_dist;\n\n    // light\n    vec3 light_center = vec3(0, 5, 6);\n    vec3 light_offset = vec3(\n    \t(sin(iTime) - 0.5) * 2.0,\n        0.0,\n        (cos(iTime) - 0.5) * 2.0);\n    vec3 light = light_center + light_offset * 5.0;\n    \n    //\tlighting\n    vec3 to_cam = normalize(ro - hit_pos);\n    vec3 to_light = normalize(light - hit_pos);\n    vec3 normal = get_normal(hit_pos);\n\n    float b = clamp(dot(normal, to_light), 0.0, 1.0);\n    \n    //\tshadow\n    float collide_dist = march(hit_pos + to_light * 10.0 * MIN_SURFACE_DIST, to_light);\n    if(collide_dist < length(light - hit_pos))\n    {\t\n        b *= 0.1;\n    }\n    col += vec3(b);\n\n    fragColor = vec4(col,1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wddfzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[76, 76, 129, 129, 167], [169, 169, 201, 201, 215], [217, 217, 263, 263, 312], [314, 314, 371, 371, 826], [828, 828, 890, 890, 1053], [1055, 1055, 1113, 1113, 1429], [1431, 1431, 1502, 1502, 1655], [1657, 1657, 1681, 1681, 2424], [2426, 2426, 2451, 2451, 2640], [2642, 2642, 2673, 2673, 2955], [2957, 2957, 3014, 3034, 4062]], "test": "valid"}
{"id": "WdGBRm", "name": "Tiled Rendering.", "author": "me_123", "description": "This shader is good for complex renderings and animation. the tile size is changeable. i will be using this alot. ", "tags": ["raymarching"], "likes": 2, "viewed": 86, "published": "Public", "date": "1606763311", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 chunkPos = vec2(0);\nfloat chunkSize = 32.;\nfloat min_dist = 0.00001;\nfloat max_dist = 10.;\nint max_steps =1000;\nvec3 lightPos = vec3(0, 1, 1);\nfloat hash(vec3 pp) {\n    vec2 p = pp.xy+(pp.z/100.);\n\treturn fract(sin(dot(p.xy, vec2(12.9898, 78.233)))*43758.5453);\n}\nvec4 un(vec4 a, vec4 b) {\n\treturn a.w < b.w? a : b;\n}\nfloat box( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nvec4 nois(in vec3 x) {\n\tvec3 p = floor(x);\n    vec3 w = fract(x);\n    vec3 u = w*w*w*(w*(w*6.0-15.0)+10.);\n    vec3 du = 30.*w*w*(w*(w-2.0)+1.0);\n    float a = hash(p+vec3(0, 0, 0));\n    float b = hash(p+vec3(1, 0, 0));\n    float c = hash(p+vec3(0, 1, 0));\n    float d = hash(p+vec3(1, 1, 0));\n    float e = hash(p+vec3(0, 0, 1));\n    float f = hash(p+vec3(1, 0, 1));\n    float g = hash(p+vec3(0, 1, 1));\n    float h = hash(p+vec3(1, 1, 1));\n    float k0 = a;\n    float k1 = b - a;\n    float k2 = c - a;\n    float k3 = e - a;\n    float k4 = a - b - c + d;\n    float k5 = a - c - e + g;\n    float k6 = a - b - e + f;\n    float k7 = - a + b + c - d + e - f - g + h;\n    return vec4(-1.0+2.0*(k0 + k1*u.x + k2*u.y + k3*u.z + k4*u.x*u.y + k5*u.y*u.z + k6*u.z*u.x + k7*u.x*u.y*u.z),\n                2.0* du * vec3( k1 + k4*u.y + k6*u.z + k7*u.y*u.z, \n                                k2 + k5*u.z + k4*u.x + k7*u.z*u.x, \n                                k3 + k6*u.x + k5*u.y + k7*u.x*u.y));\n}\nvec4 fbm(in vec3 x, int octives) {\n\tfloat f = 1.98;\n    float s = 0.6;\n    float a = 0.0;\n    float b = 0.3;\n    vec3 d = vec3(0);\n    float o = 0.6;\n    mat3 m = mat3(o, 0, 0, 0, o, 0, 0, 0, o);\n    for (int i = 0; i < octives; i ++) {\n        vec4 n = nois(x);\n        a += b*n.x;\n        d += b*m*n.yzw;\n        b *= s;\n        x = f*m*x;\n        m = f*m*m;\n    }\n    return vec4(a, d);\n}\nfloat terrain(vec3 p) {\n\tfloat a = 0.0;\n    float b = 1.0;\n    vec2 d = vec2(0);\n    for (int i = 0; i < 9; i += 1) {\n    \tvec3 n = nois(p).xyz;\n        d += n.yz;\n        a += b*n.x/(1.+dot(d,d));\n        b *= 0.5;\n        p = p*2.1;\n    }\n    return a;\n}\nstruct ray {\n\tfloat dist;\n    float ao;\n    vec3 pos;\n    vec3 normal;\n    vec3 color;\n    vec3 cc;\n};\nvec4 SDF(in vec3 p, in bool tt, bool ttt) {\n    if (!ttt) {\n        float t = (abs(nois(p*(nois(p*20.).xyz*20.)).xyz).x+1.0)/2.;//mix(vec3(0.5, 0.5, 1.0),vec3(1), vec3(p.y+0.2));\n        vec3 color = mix(vec3(t/1.5, t/3., 0.0), vec3(1), clamp(clamp(p.y+0.1, 0.0, 1.0)*20., 0.0, 1.5));\n        if (tt) {\n          return un(un(vec4(color, ((p.y+terrain(p*0.5)*((nois(p/11.).x)/2.)))/3.), vec4(vec3(0.111), (p.y+0.1)+(fbm(p*20., 4).x/2000.))), vec4(vec3(0.222, 0, 0), length(p-vec3(0.7, 0.5, 1.))-0.1));\n        } else {\n          return un(vec4(color, ((p.y+terrain(p*0.5)*((nois(p/10.).x)/2.)))/3.), vec4(vec3(0.222, 0, 0), length(p-vec3(0.7, 0.5, 1.))-0.1));\n        }\n    } else {\n        return vec4(vec3(0.222, 0, 0), (length(p-vec3(0.7, 0.5, 1.))-0.1)/10.);\n    }\n}\nvec3 getNormal(vec3 p, bool tt, bool ttt) {\n\tvec2 e = vec2(0.00001, 0);\n    float d = SDF(p, tt, ttt).w;\n    vec3 n = d -vec3(\n    \tSDF(p-e.xyy, tt, ttt).w,\n    \tSDF(p-e.yxy, tt, ttt).w,\n    \tSDF(p-e.yyx, tt, ttt).w\n    );\n\treturn (normalize(n));\n}\nray get_ray(vec3 ro, vec3 rd, bool tt, bool ttt) {\n\tfloat d0 = 0.0;\n    vec3 p = vec3(0);\n    float steps = 0.0;\n    vec3 color = vec3(0);\n    vec3 cc = vec3(0);\n    for (int i = 0; i < max_steps; i += 1) {\n        steps += 1.;\n        p = ro+rd*d0;\n        vec4 rr = SDF(p, tt, ttt);\n        float d = rr.w;\n        d0 += d;\n        cc += 1.;\n        color = rr.xyz;\n        if (d0 > max_dist || d < min_dist) {\n            break;\n        }\n    }\n    return ray(d0, steps, p, getNormal(p, tt, ttt), color, cc/200.);\n}\nvec3 getColor(vec3 roo, vec3 rdd, bool tt, bool ttt) {\n    vec3 color = vec3(1);\n    ray rr;\n    vec3 ro = roo;\n    vec3 rd = rdd;\n    vec3 sky;\n    float dist = 0.0;\n    for (int i = 0; i < 2; i += 1) {\n    \tfloat t = clamp(rd.y+0.5, 0.0, 0.5);\n   \t\tsky = vec3(t*1., t*1., t*1.4)*1.5;\n    \tray rr = get_ray(ro, rd, tt, ttt);\n        if (rr.dist < max_dist) {\n            dist = rr.dist;\n            if (rr.color.x != 0.111) {\n                if (rr.color.x != 0.222) {\n               \t\tcolor *= rr.color * vec3((clamp((dot(rr.normal, normalize(lightPos))+0.2)-(0.5/rr.ao), 0.0, 1.0)+0.2)/1.9)*vec3(1.2, 1.2, 1.1);\n                \tbreak;\n                } else {\n                    color = vec3(1.5, 1.5, 0.8);\n                }\n            } else {\n                ro = rr.pos*0.99;\n            \trd = reflect(rdd, rr.normal);\n                color = vec3(0.7, 0.7, 0.8);\n            }\n        } else {\n            color = vec3(rr.cc*1.5)*sky*color;\n            break;\n        }\n    }\n    color = mix(color*1.0, clamp(sky, 0.0, 1.0), (dist/10.));\n    return color;\n}\nvec3 drawImage( in vec2 fragCoord )\n{\n    float r = iResolution.x/iResolution.y;\n    vec2 uv = ((fragCoord.xy/iResolution.xy)-0.5) * vec2(r, 1.);\n    vec3 ro = vec3(sin(10.)*2., 0.1, cos(10.)*2.);\n    vec3 at = vec3(0);\n    vec3 cam_z = normalize(at-ro);\n    vec3 cam_x = normalize(cross(vec3(0, 1, 0), cam_z));\n    vec3 cam_y = cross(cam_z, cam_x);\n    vec3 rd = normalize(uv.x * cam_x + uv.y * cam_y + 1.5 * cam_z);\n\tvec3 color = mix(mix(getColor(ro, rd, false, false), getColor(ro, rd, true, false), 0.6), getColor(ro, rd, true, true), 0.6);\n    return color;//fragColor = vec4(color, 1.0);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n    chunkPos.x = ceil(mod(float(iFrame)*chunkSize, round(iResolution.x/chunkSize)*chunkSize)/chunkSize)*chunkSize;\n    chunkPos.y = mod(ceil(mod(float(iFrame/int(iResolution.x/chunkSize))*chunkSize, iResolution.x)/chunkSize)*chunkSize, iResolution.y);\n   \tfloat time = iTime;\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec4 texture = texture(iChannel0,uv);\n    \n    if (fragCoord.x < chunkPos.x+chunkSize && fragCoord.y < chunkPos.y+chunkSize && fragCoord.x > chunkPos.x && fragCoord.y > chunkPos.y) {\n        fragColor = vec4(drawImage(fragCoord), 1);//vec4(texture.rgb,1.); \n    } else {   \n        fragColor = vec4(fragColor.rgb,1.); discard;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[148, 148, 169, 169, 268], [269, 269, 294, 294, 322], [323, 323, 352, 352, 439], [440, 440, 462, 462, 1424], [1425, 1425, 1459, 1459, 1816], [1817, 1817, 1840, 1840, 2073], [2177, 2177, 2220, 2220, 2947], [2948, 2948, 2991, 2991, 3196], [3197, 3197, 3247, 3247, 3715], [3716, 3716, 3770, 3770, 4784], [4785, 4785, 4822, 4822, 5380], [5381, 5381, 5438, 5438, 6098]], "test": "error"}
{"id": "WdGBRW", "name": "Perlin noise (annotated)", "author": "MightyAlex200", "description": "Layered and warped Perlin noise, annotated in code. Just something I did for fun.", "tags": ["perlinnoise"], "likes": 0, "viewed": 110, "published": "Public", "date": "1606619131", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Perlin noise implementation\n\n// The first step for generating noise is getting a deterministic source of pseudo-random numbers.\n// We need something with O(1) time, and hash functions are a great way of doing this.\n// This is the \"FowlerNollVo\" hash function, used here because it is extremely simple.\n// You can read more about it on Wikipedia.\nuint fnv(uint i) {\n    const uint FNV_PRIME = 16777619U;\n    const uint FNV_OFFSET = 2166136261U;\n    \n    uint h = FNV_OFFSET;\n    // Integers are 32 bits in this language, 4 bytes.\n    for (uint it = 0U; it < 4U; it++) {\n        uint bits = it * 8U;\n    \th *= FNV_PRIME;\n   \t\th ^= (i >> bits) & 0xFFU;\n    }\n    \n    return h;\n}\n\n// You could just use that function as it is, but it's designed more for speed than for randomness.\n// We can increase randomness at the cost of speed by using this function, just running the hash function twice.\nuint fnv2(uint i) {\n\treturn fnv(fnv(i));\n}\n\n// We also define a helper function to create random values from 2D coordinates.\n// Note that we are not letting x and y \"interact\" directly, only letting y change the hash of x.\n// If x and y meet to produce some sort of \"sum\" value before hashing, it may cause positional artifacts.\nuint fnv2d(uint x, uint y) {\n    return fnv2(fnv2(x) ^ y);\n}\n\n// Just another helper function, this time including a seed value.\nuint fnv2ds(uint x, uint y, uint seed) {\n\treturn fnv2(fnv2d(x, y) ^ fnv2(seed));\n}\n\n// This is the interpolation function we will use for our noise.\n// This is an implementation of the \"Smoothstep\" algorithm.\n// You can try other functions if you want, but I personally think linear interpolation looks crap for pure noise.\nfloat interp(float a0, float a1, float w) {\n    return (a1 - a0) * (3.0 - w * 2.0) * w * w + a0;\n}\n\n// We use this function to do 2D interpolation.\n// There are four values interpolated between, and two coordinates dictating that interpolation.\n// If interp implemented linear interpolation then this function would implement bilinear interpolation.\n// The first four variable names are shorthand for Bottom Left, Bottom Right, Upper Left, Upper Right.\n// (Remember that WebGL works from bottom left instead of top left.)\nfloat bi_interp(float bl, float br, float ul, float ur, float x, float y) {\n\tfloat y1 = interp(bl, br, x);\n    float y2 = interp(ul, ur, x);\n    return interp(y1, y2, y);\n}\n\n// Finally, the noise function. It's rather long so I will comment it inside \nfloat perlin(float x, float y, uint seed) {\n    // Now, if you don't know, Perlin noise works by chosing a random vector (\"gradient\") for each point\n    // on a grid (usually the integers in a floating point space), and interpolating the dot products of\n    // those gradients and vectors from each corner to the coordinate.\n    \n    // First, we need a permutation table of vectors for generating gradients.\n    const uint LEN = 8U;\n    const vec2[LEN] VECS = vec2[] (\n        vec2( 1.,  1.),\n        vec2( 1., -1.),\n        vec2(-1.,  1.),\n        vec2(-1., -1.),\n        vec2( 0.,  1.),\n        vec2( 0., -1.),\n        vec2( 1.,  0.),\n        vec2(-1.,  0.)\n    );\n    \n    // Now, we will floor the floats to get the coordinates of the bottom left corner of the current grid square\n    uint gridx = uint(x);\n    uint gridy = uint(y);\n    \n    // Given that the grid squares are delineated by integers, the \"coordinate\" of the point inside the grid\n    // square is just the fractional component of the point.\n    // I wrote it this way this because it is nicer than `coordx = x - gridx` (the more technically\n    // correct version), IMO.\n    float fracx = fract(x);\n    float fracy = fract(y);\n    \n    // Now we generate the gradients, making use of the 2D seeded hash function to index the VECS array.\n    // Note that increasing the points by 1 is not arbitrary. It \"moves\" one vertex over in the grid.\n    // Change any of the 1s to other numbers to watch it break.\n    \n    // And yes, this function is written somewhat poorly by DRY standards (this should probably\n    // all be in a for loop), but I am optimizing for readability. It makes more sense to write\n    // the code to have a control flow similar to how we think about the algorithm conceptually.\n    vec2 gradbl = VECS[fnv2ds(gridx, gridy, seed) % LEN];\n    vec2 gradbr = VECS[fnv2ds(gridx + 1U, gridy, seed) % LEN];\n    vec2 gradul = VECS[fnv2ds(gridx, gridy + 1U, seed) % LEN];\n    vec2 gradur = VECS[fnv2ds(gridx + 1U, gridy + 1U, seed) % LEN];\n    \n    vec2 pos = vec2(fracx, fracy);\n    // Now the vectors to the 4 corners.\n    vec2 vecbl = pos - vec2(0., 0.);\n    vec2 vecbr = pos - vec2(1., 0.);\n    vec2 vecul = pos - vec2(0., 1.);\n    vec2 vecur = pos - vec2(1., 1.);\n    \n    // The dot products\n    float dotbl = dot(gradbl, vecbl);\n    float dotbr = dot(gradbr, vecbr);\n    float dotul = dot(gradul, vecul);\n    float dotur = dot(gradur, vecur);\n    \n    // Bringing it all home with 2D interpolation!\n    return bi_interp(\n    \tdotbl,\n        dotbr,\n        dotul,\n        dotur,\n        fracx,\n        fracy\n    );\n}\n\n// Great, we have a noise function! But it will require a little bit of preprocessing before it looks pretty.\n\n// A common method of making noise look better is to layer different frequencies of noise over each other\n// with different amplitudes.\n// This function does that according to a simple formula!\n// `it` layers of noise, each scaled by lacunarity ^ i with an amplitude of persistance ^ i (where i is\n// the current iteration number starting from 0)\nfloat noiseLayered(uint it, float lacunarity, float persistance, float x, float y) {\n\tfloat o = 0.0;\n    float mag = 0.0;\n    for (uint i = 0U; i < it; i++) {\n    \to += perlin(x * pow(lacunarity, float(i)), y * pow(lacunarity, float(i)), 0U) * pow(persistance, float(i));\n        mag += pow(persistance, float(i));\n    }\n    return o / mag;\n}\n\nconst float ZOOM = 50.;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    // Scrolling effect is created here\n    float x = fragCoord.x / ZOOM + iTime * 4.;\n    float y = fragCoord.y / ZOOM + iTime * 4.;\n    // One last processing effect! You can actually warp the output of noise by warping the input space.\n    // We use perlin noise again (with different seeds) to determine which direction to warp the input space.\n    float offx = perlin(x, y, 1U);\n    float offy = perlin(x, y, 2U);\n    float offs = perlin(x, y, 3U) + 0.5;\n    float noise = noiseLayered(10U, 2., 0.5, x + offx * offs, y + offy * offs);\n    fragColor = vec4(\n        vec3(\n            noise + 0.5\n        ),\n        1.\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGBRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 355, 373, 373, 685], [687, 900, 919, 919, 942], [944, 1229, 1257, 1257, 1289], [1291, 1358, 1398, 1398, 1440], [1442, 1682, 1725, 1725, 1780], [1782, 2204, 2279, 2279, 2376], [5172, 5519, 5603, 5603, 5861], [5888, 5888, 5943, 5983, 6574]], "test": "error"}
{"id": "wdGfz1", "name": "Cookie Live Stream nov20 02", "author": "NuSan", "description": "Shader coded live in 30m during Cookie Live Stream 27 november 2020\nhttps://www.twitch.tv/cookiedemoparty", "tags": ["raymarching", "livecoding"], "likes": 17, "viewed": 273, "published": "Public", "date": "1606570014", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shader coded live in 30m during Cookie Live Stream 27 november 2020\n// https://www.twitch.tv/cookiedemoparty\n// I first made the background using 2D lines and circles\n// then I added the 3D shape on top that can \"distord\" the background\n\n// You can disable the 3D shape to see the 2D background\n#define SHAPE_3D 1\n\nfloat time = 0.0;\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat rnd(float t) {\n  \n  return fract(sin(t*425.512)*742.712);\n}\n\nfloat curve(float t, float d) {\n  t/=d;\n  return mix(rnd(floor(t)), rnd(floor(t)+1.0), pow(smoothstep(0.0,1.0,fract(t)), 10.0));\n}\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nfloat map(vec3 p) {\n  \n  float t=time*.3 + curve(time, .7)*5.0;\n  p.xz *= rot(t);\n  p.yz *= rot(t*.3);\n  \n  p = abs(p)-curve(time, .21)*5.0;\n  p = abs(p)-curve(time, .32)*2.0;\n  \n  float d = box(p, vec3(1.0+curve(time, .1)));\n  \n  vec3 p2 = p;\n  float t2 = time;\n  p2.xy *= rot(t2);\n  p2.zy *= rot(t2*1.3);\n  p2 = abs(p2)-curve(time,.4)*3.0;\n  d = min(d, length(p2.xz)-.2);\n  \n  return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  // slowed down the time because there is no music to pump it up\n  time = mod(iTime*0.3, 300.0);\n    \n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n\n  vec3 col=vec3(0);\n  \n    \n  #if SHAPE_3D\n  vec3 s=vec3(0,0,-20);\n  vec3 r=normalize(vec3(-uv,1));\n  vec3 p=s;\n  for(int i=0; i<100; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      uv += map(p+r)*.14;\n      break;\n    }\n    if(d>100.0) {\n      break;\n    }\n    p+=r*d;\n  }\n  \n  col += 0.1/(0.1+abs(map(p+r)));\n  #endif\n  \n  bool stop = rnd(floor(time*1.0+.3))>0.3;\n  float ss = 10.0 + floor(pow(curve(time, 3.0),20.0)*100.0);\n  //if(!stop) uv.x += sin(abs(uv.x+sin(time))+sin(uv.y*10+time)*0.1)*.3;\n  float off = floor(uv.x*ss)/ss;\n  if(stop) off=0.0;\n  \n  uv.y -= pow(curve(time+rnd(off+.1), .3),4.0)*.3;\n  uv.x -= (curve(time+rnd(off), .4)-.5)*.1;\n  \n  \n  \n  \n  for(float i=0.0; i<30.0; ++i) {\n    \n    vec2 p = uv;\n    float t = time*.7;\n    float t2 = curve(time + i, 0.7)*3.0;\n    p *= rot(t+i*.2 + sin(t + i));\n    p.x-=sin(t2 + i*7.3)*0.3;\n    p.x += pow(curve(time, .7),4.0)*.7-.3;\n    \n    col += vec3(1,0.7-sin(i*3.7)*.3,0.8-sin(i))*0.002*exp(-fract(time+i*.1))/(0.003+abs(p.x));\n    col += 0.001/(0.003+abs(length(p)-.3));\n  }\n  \n  col *= 0.7+curve(time,.2)*.3;\n  col = smoothstep(0.0,1.0,col);\n  col = pow(col, vec3(curve(time*10.0 - length(uv)*10.0,1.0)*3.0+1.0));\n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGfz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[337, 337, 356, 356, 427], [429, 429, 449, 449, 494], [496, 496, 527, 527, 626], [628, 628, 655, 655, 704], [706, 706, 725, 725, 1096], [1098, 1098, 1155, 1221, 2611]], "test": "valid"}
{"id": "wdGfzD", "name": "Screw and Square", "author": "IWBTShyGuy", "description": "A screw is fired from a rotating square!!", "tags": ["pattern"], "likes": 9, "viewed": 316, "published": "Public API", "date": "1606675490", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Copyright  2020 IWBTShyGuy\n// Attribution 4.0 International (CC BY 4.0)\n\nconst float PI = 3.141592653;\nconst float PI2 = 2.0 * PI;\n\n// square\nconst int N = 4;\n\n// the circumradius of polygon\nconst float R_POLY = 0.4;\n\nconst float SCREW_THICKNESS = 0.02;\n\n// the half of thickness of polygon edges\nconst float THICKNESS = 0.025;\n\n// Good Colors!!\nconst vec3 COLOR[N] = vec3[](\n    vec3(226.0, 133.0, 27.0) / 255.0,\n    vec3(126.0, 107.0, 152.0) / 255.0,\n    vec3(238.0, 200.0, 80.0) / 255.0,\n    vec3(136.0, 175.0, 34.0) / 255.0\n);\n\n// the radius of the vertex of square\nconst float R_DOT = 0.04;\n\n// normalized fragment coordinate\nvec2 uv_coord(vec2 coord) {\n    int max_idx = iResolution.x > iResolution.y ? 0 : 1;\n    int min_idx = 1 - max_idx;\n    vec2 aspect_vec = vec2(1.0, 1.0);\n    aspect_vec[max_idx] = iResolution[max_idx] / iResolution[min_idx];\n    return 2.0 * coord / iResolution[min_idx] - aspect_vec;\n}\n\n// Creates vertices of polygon\nvec2[N] createVertex() {\n    vec2 vertex[N];\n    for (int i = 0; i < N; i++) {\n        float theta = float(i) / float(N) * PI2;\n        vertex[i] = vec2(cos(theta), sin(theta)) * R_POLY;\n    }\n    return vertex;\n}\n\nfloat get_angle(in vec2 uv) {\n    float theta = acos(uv.x / length(uv));\n    if (uv.y < 0.0) theta = 2.0 * PI - theta;\n    return theta;\n}\n\nfloat torus_distance(in float x, in float y) {\n    float a = abs(x - y);\n    float b = abs(PI2 + x - y);\n    float c = abs(x - y - PI2);\n    return min(a, min(b, c));\n}\n\nvec4 renderScrew(in vec2 uv) {\n    float len = length(uv);\n    float theta = get_angle(uv);\n    float c = 0.0;\n    int idx = 0;\n    for (int i = 0; i < N; i++) {\n        if (len < R_POLY) continue;\n        float delta = float(i) / float(N);\n        float phase = fract((iTime - PI2 * len + PI2 * delta) / PI2) * PI2;\n        float dist = smoothstep(0.0, 1.0, (torus_distance(phase, theta) / PI2) / SCREW_THICKNESS);\n        if (c < 1.0 - dist * dist * dist) {\n            c = 1.0 - dist * dist * dist;\n            idx = i % N;\n        }\n    }\n    return vec4(c * COLOR[idx], 1.0);    \n}\n\nvec4 renderSquare(in vec4 fragColor, in vec2 uv, in vec2 vertex[N]) {\n    float theta = iTime - 2.0 * PI * R_POLY;\n    uv = mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * uv;\n    float plus = abs(uv.x + uv.y);\n    float minus = abs(uv.x - uv.y);\n    if (plus < R_POLY - THICKNESS && minus < R_POLY - THICKNESS)\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    else if (plus < R_POLY + THICKNESS && minus < R_POLY + THICKNESS) {\n        float k = 1.0 - abs(plus - R_POLY) / THICKNESS;\n        k = max(k, 1.0 - abs(minus - R_POLY) / THICKNESS);\n        k = 1.0 - pow(1.0 - k, 5.0);\n        vec3 col = vec3(0.0);\n        for (int i = 0; i < N; i++) {\n            float c = distance(vertex[i], uv) / R_POLY;\n            c = smoothstep(0.0, 1.0, c);\n            c = 1.0 - pow(c, 3.0);\n            col += c * COLOR[i] * k;\n        }\n        fragColor = vec4(col, 1.0);\n    }\n    return fragColor;\n}\n\nvec4 renderVertices(in vec4 fragColor, in vec2 uv, in vec2 vertex[N]) {\n    float theta = iTime - 2.0 * PI * R_POLY;\n    uv = mat2(cos(theta), -sin(theta), sin(theta), cos(theta)) * uv;\n    for (int i = 0; i < N; i++) {\n        if (distance(uv, vertex[i]) < R_DOT) {\n            float c = distance(uv, vertex[i]) / R_DOT;\n            c = 1.0 - pow(c, 5.0);\n            fragColor = vec4(COLOR[i] * c, 1.0);\n        }\n    }\n    return fragColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = uv_coord(fragCoord);\n    vec2 vertex[N] = createVertex();\n    fragColor = renderScrew(uv);\n    fragColor = renderSquare(fragColor, uv, vertex);\n    fragColor = renderVertices(fragColor, uv, vertex);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdGfzD.jpg", "access": "shaders20k", "license": "cc-by-4.0", "functions": [[602, 636, 663, 663, 922], [1170, 1170, 1199, 1199, 1308], [1310, 1310, 1356, 1356, 1478], [1480, 1480, 1510, 1510, 2066], [2068, 2068, 2137, 2137, 2970], [2972, 2972, 3043, 3043, 3417], [3419, 3419, 3474, 3474, 3689]], "test": "valid"}
{"id": "WdGfzz", "name": "Loading Cubes", "author": "Jinkweiq", "description": "a (terribly programmed) re-creaction of something I saw on r/LoadingIcons. Please ignore all the hard coding.\n", "tags": ["raymarching", "loading"], "likes": 20, "viewed": 122, "published": "Public", "date": "1606377147", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// recreation of https://www.reddit.com/r/LoadingIcons/comments/ib3ero/cubes/\n// a couple things to note: for the rotation, the camera rotates instead of the cube so I can just \n// map the point I hit on the onto the origianl uv for raymarching a second time without having to \n// reverse any of the rotation. Also, if you look at the bottom left corner of the top cube, you can \n// see the cube slightly change at the  loop point. This is beacuse the map of hit point to the uv for \n// raymarching the second time is done by hand by with hardcoded variable -- I dont feel like figuring\n// out what they actal mathamattically correct values are.\n#define pi acos(-1.)\n\nmat2 rot(float a){\n    float s=sin(a),c=cos(a);\n    return mat2(c,-s,s,c);\n}\n\nfloat sdBox(vec3 p,vec3 s){\n    p=abs(p)-s;\n    return length(max(p,0.))+min(max(p.x,max(p.y,p.z)),0.);\n}\nfloat a(float o,float t){\n    if(t>o*pi){\n        if(t<(o+1.)*pi)\n        return cos(t-o*pi)*.5+.5;\n        return 0.;\n    }\n    return 1.;\n}\nfloat ar(float o,float t){\n    if(t>o*pi){\n        if(t<(o+1.)*pi)\n        return-cos(t-o*pi+pi)*.25+.25;\n        return.0;\n    }\n    return.5;\n}\n\nfloat map(vec3 p,float t){\n    float d;\n    p=abs(p);\n    p.y-=a(0.,t);\n    p.x-=a(1.,t);\n    p.z-=a(2.,t);\n    p-=1.;\n    \n    return sdBox(p,vec3(1));\n}\nfloat march(vec3 ro,vec3 rd,float t){\n    float r;\n    for(int i=0;i<100;i++){\n        vec3 p=ro+rd*r;\n        float dS=map(p,t);\n        r+=dS;\n        if(r>100.||abs(dS)<.001)break;\n    }\n    \n    return r;\n}\n\nvec3 normal(vec3 p,float t){\n    float d=map(p,t);\n    vec2 e=vec2(.001,0);\n    \n    vec3 n=d-vec3(\n        map(p-e.xyy,t),\n        map(p-e.yxy,t),\n        map(p-e.yyx,t)\n    );\n    \n    return normalize(n);\n}\nvoid camera(inout vec3 ro,inout vec3 rd){\n    ro.yz*=rot(.197*pi);\n    rd.yz*=rot(.197*pi);\n    ro.xz*=rot(.25*pi);\n    rd.xz*=rot(.25*pi);\n}\nvec3 getCol(vec3 n) {\n    vec3 col=vec3(.717,.854,.972)*(n.y<-.1?1.:0.);\n    col+=vec3(.843,.949,.874)*(n.x<-.1?1.:0.);\n    col+=vec3(.933,.631,.776)*(n.z>.1?1.:0.);\n    \n    return col;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    float t=mod(iTime*4.,6.*pi);\n    vec2 uv=fragCoord.xy/iResolution.xy;\n    uv-=.5;\n    uv/=1.5;\n    uv.x/=iResolution.y/iResolution.x;\n    uv/=1.+.5*t/(6.*pi);\n    \n    vec3 ro=vec3(uv*20.,-50.),\n    rd=vec3(0.,0.,1.),\n    col=vec3(1.);\n    camera(ro,rd);\n    \n    ro.xz*=rot(ar(3.,t)*pi);\n    ro.yx*=rot(ar(4.,t)*pi);\n    ro.xz*=rot(ar(5.,t)*pi);\n    rd.xz*=rot(ar(3.,t)*pi);\n    rd.yx*=rot(ar(4.,t)*pi);\n    rd.xz*=rot(ar(5.,t)*pi);\n    \n    float r=march(ro,rd,t);\n    \n    if(r<100.){\n        vec3 p=ro+rd*r;\n        vec3 n=normal(p,t);\n        \n        col=getCol(n);\n        \n        if(n.x>.5||n.y>.5||n.z<-.5){\n            if(n.x>.5){\n                p.zy-=vec2(-2.,2.);\n                uv=vec2(p.z,(p.zy*rot(.147*pi)).y);\n                uv*=2.;\n                uv.x/=1.158;\n                uv.y*=1.11;\n            }\n            if(n.y>.5){\n                uv=p.xz*rot(-.25*pi);\n                uv.y+=2.793;\n                uv.y*=sqrt(2.);\n                uv.x*=2.4;\n                uv+=.04;\n            }\n            if(n.z<-.5){\n                p-=2.;\n                uv=vec2(p.x,(p.xy*rot(-.147*pi)).y);\n                uv*=2.;\n                uv.x/=1.158;\n                uv.y*=1.11;\n            }\n            uv*=.614;\n            col=vec3(1.);\n            ro=vec3(uv.xy,-50.);\n            rd=vec3(0.,0.,1.);\n            camera(ro,rd);\n            r=march(ro,rd,0.);\n            \n            if(r<100.){\n                vec3 p=ro+rd*r;\n                vec3 n=normal(p,0.);\n                \n                n = vec3(-n.x,n.z,n.y);\n                \n                col=getCol(n);\n            }\n        }\n        \n    }\n    \n    fragColor=vec4(col,1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdGfzz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[668, 668, 686, 686, 744], [746, 746, 773, 773, 851], [852, 852, 877, 877, 993], [994, 994, 1020, 1020, 1139], [1141, 1141, 1167, 1167, 1295], [1296, 1296, 1333, 1333, 1506], [1508, 1508, 1536, 1536, 1717], [1718, 1718, 1759, 1759, 1859], [1860, 1860, 1881, 1881, 2048], [2049, 2049, 2105, 2105, 3774]], "test": "valid"}
{"id": "wdKBRh", "name": "Starfield Test 1", "author": "notchris", "description": "A starfield", "tags": ["stars", "pixels"], "likes": 6, "viewed": 137, "published": "Public", "date": "1606594518", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PASS_COUNT 1\n\nfloat fBrightness=2.5;\nfloat fSteps=222.;\nfloat fParticleSize=.015;\nfloat fParticleLength=.5/60.;\nfloat fMinDist=.8;\nfloat fMaxDist=5.;\nfloat fRepeatMin=1.;\nfloat fRepeatMax=2.;\nfloat fDepthFade=1.2;\n\nconst float sharpness=2.;\n\nfloat Random(float x)\n{\n    return fract(sin(x*123.456)*23.4567+sin(x*345.678)*45.6789+sin(x*456.789)*56.789);\n}\n\nvec3 GetParticleColour(const in vec3 vParticlePos,const in float fParticleSize,const in vec3 vRayDir)\n{\n    vec2 vNormDir=normalize(vRayDir.xy);\n    float d1=dot(vParticlePos.xy,vNormDir.xy)/length(vRayDir.xy);\n    vec3 vClosest2d=vRayDir*d1;\n\n    vec3 vClampedPos=vParticlePos;\n\n    vClampedPos.z=clamp(vClosest2d.z,vParticlePos.z-fParticleLength,vParticlePos.z+fParticleLength);\n\n    float d=dot(vClampedPos,vRayDir);\n\n    vec3 vClosestPos=vRayDir*d;\n\n    vec3 vDeltaPos=vClampedPos-vClosestPos;\n\n    float fClosestDist=length(vDeltaPos)/fParticleSize;\n\n    float fShade=clamp(1.-fClosestDist,0.,1.);\n\n    fShade=fShade*exp2(-d*fDepthFade)*fBrightness;\n\n    return vec3(fShade);\n}\n\nvec3 GetParticlePos(const in vec3 vRayDir,const in float fZPos,const in float fSeed)\n{\n    float fAngle=atan(vRayDir.x,vRayDir.y);\n    float fAngleFraction=fract(fAngle/(3.14*2.));\n\n    float fSegment=floor(fAngleFraction*fSteps+fSeed)+.5-fSeed;\n    float fParticleAngle=fSegment/fSteps*(3.14*2.);\n\n    float fSegmentPos=fSegment/fSteps;\n    float fRadius=fMinDist+Random(fSegmentPos+fSeed)*(fMaxDist-fMinDist);\n\n    float tunnelZ=vRayDir.z/length(vRayDir.xy/fRadius);\n\n    tunnelZ+=fZPos;\n\n    float fRepeat=fRepeatMin+Random(fSegmentPos+.1+fSeed)*(fRepeatMax-fRepeatMin);\n\n    float fParticleZ=(ceil(tunnelZ/fRepeat)-.5)*fRepeat-fZPos;\n\n    return vec3(sin(fParticleAngle)*fRadius,cos(fParticleAngle)*fRadius,fParticleZ);\n}\n\nvec3 Starfield(const in vec3 vRayDir,const in float fZPos,const in float fSeed)\n{\n    vec3 vParticlePos=GetParticlePos(vRayDir,fZPos,fSeed);\n    return GetParticleColour(vParticlePos,fParticleSize,vRayDir);\n}\n\nfloat sharpen(float pix_coord){\n    float norm=(fract(pix_coord)-.5)*2.;\n    float norm2=norm*norm;\n    return floor(pix_coord)+norm*pow(norm2,sharpness)/2.+.5;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    vec2 vScreenPos=uv*2.-1.;\n    vScreenPos.x*=iResolution.x/iResolution.y;\n\n    vec3 vRayDir=normalize(vec3(vScreenPos,1.));\n\n    float fShade=0.;\n\n    float fZPos=5.+iTime;\n\n    fParticleLength=.00001;\n\n    float fSeed=0.;\n\n    vec3 vResult=mix(vec3(0.),vec3(0.),vRayDir.y*.5+.5);\n\n    for(int i=0;i<PASS_COUNT;i++)\n    {\n        vResult+=Starfield(vRayDir,fZPos,fSeed);\n        fSeed+=1.234;\n    }\n\n    vec4 resultA=vec4(sqrt(vResult),1.);\n    fragColor=resultA;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKBRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[250, 250, 273, 273, 362], [1985, 1985, 2016, 2016, 2147], [2150, 2150, 2207, 2257, 2766]], "test": "error"}
{"id": "WdKfR1", "name": " foob  (cookie live stream)", "author": "dok", "description": "Shader coded for the Cookie Collective live coding stream, on 27/11/2020\n\nI'had no idea of what I was doing, only smashing my keyboard.\n\nhttps://cookie.paris/\nhttps://www.twitch.tv/cookiedemoparty", "tags": ["noob", "cookie"], "likes": 1, "viewed": 116, "published": "Public", "date": "1606586720", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* shadertoy glue */\n#define fGlobalTime iTime\n#define texFFTIntegrated iChannel0\n#define texFFTSmoothed iChannel0\nfloat vol = 0.1;\n\n/* source */\n\nfloat foo(vec2 uv, float s)\n{\n        return sin(uv.y + uv.x + s * fGlobalTime);\n}\n#define PI2 (2.0*3.1416)\nmat2 rot2(float a) {return mat2(cos(a), -sin(a), sin(a), cos(a));}\n\nvoid mainImage( out vec4 out_color, in vec2 coord )\n{\n        vec2 uv = (coord.xy - 0.5 * iResolution.xy) / iResolution.y;\n        vec3 col;\n        vec2 pv = uv;\n        pv.x += 1.5 * sin(fGlobalTime / 10.0);\n        pv.y += 1.5 * cos(fGlobalTime / 10.0);\n        pv = vec2(length(pv), atan(pv.x,pv.x)/PI2);\n        uv.x += tan(uv.y * 1.5);\n        uv *= mix(0.5, 2.0, 0.5 + 0.5 * sin(fGlobalTime / 10.0));\n        uv *= rot2(fGlobalTime / 10.0);\n        int m = int(mix(2.0, 10.0, 0.5 + 0.5 * (texture(texFFTIntegrated, vec2(0.02)).r * 10.0 * vol)));\n\n        col.r = foo(vec2(fract(uv.y * float(m)), uv.x), 1.0);\n        col.r += foo(vec2(fract(uv.x * 120.0), 5.0 * uv.x + 5.0 * sin(fGlobalTime / 10.0)), 0.5);\n        col.r = step(0.5 , fract(col.r));\n\n        col.r += step(0.5 , fract(foo(vec2(fract(pv.x * 120.0), 5.0 * pv.x + 5.0 * sin(fGlobalTime / 10.0)), 0.5)));\n        if ((texture(texFFTSmoothed, vec2(0.02,0.02)).r * 20.0 * vol) > 0.5)\n                col.r = 1.0 - col.r;\n        col.rgb = col.rrr * smoothstep(0.0, 1.0, (texture(texFFTSmoothed, vec2(0.1,0.1)).r * 200.0 * vol + 0.75));\n        out_color = vec4(col, 1);\n}\n", "image_inputs": [{"id": "XdXGRr", "previewfilepath": "/presets/mic.png", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/mic.png", "ctype": "mic"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKfR1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[147, 147, 176, 176, 229], [255, 255, 275, 275, 321], [323, 323, 376, 376, 1461]], "test": "error"}
{"id": "wdKfRz", "name": "Yet another illusion...", "author": "Nrx", "description": "Nothing moves but the arrow!", "tags": ["optical", "illusion"], "likes": 11, "viewed": 278, "published": "Public API", "date": "1606474337", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI\t\t\t\t3.14159265358979\n#define DISC_COUNT\t\t9.0\n#define DISC_DIST\t\t0.7\n#define DISC_RADIUS\t\t0.1\n#define HUE_SPEED\t\t0.06\n#define HUE_STEP\t\t3.0\n\nvec3 hsv2rgb (in vec3 hsv) {\n\treturn hsv.z * (1.0 + hsv.y * clamp (abs (fract (hsv.x + vec3 (0.0, 2.0 / 3.0, 1.0 / 3.0)) * 6.0 - 3.0) - 2.0, -1.0, 0.0));\n}\n\nmat2 rotate (in float angle)\n{\n\tfloat c = cos (angle);\n\tfloat s = sin (angle);\n\treturn mat2 (c, s, -s, c);\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p) {\n\n\t// Normalization of the fragment coordinates\n\tp = (2.0 * p - iResolution.xy) / iResolution.y;\n\tfloat halfPixel = 0.5 * dFdy (p.y);\n\n\t// Background color\n\tfragColor = vec4 (vec3 (0.6 + 0.05 * cos (p.x * 50.0) * cos (p.y * 50.0)), 1.0);\n\n\t// Select the direction\n\tfloat dir = sign (cos (iTime * 0.8));\n\n\t// Display the direction\n\tvec2 q = p *rotate (iTime * dir * 0.2);\n\tq.x *= dir;\n\tvec2 tip = vec2 (-0.01, 0.3);\n\tfloat d = max (abs (length (q) - tip.y), min (-q.x, q.x + q.y));\n\td = min (d, segDist (q, tip, tip + vec2 (0.05, 0.05)));\n\td = min (d, segDist (q, tip, tip + vec2 (0.05, -0.05)));\n\td -= 0.01;\n\tfragColor *= smoothstep (-halfPixel, halfPixel, d);\n\n\t// Divide the plan in DISC_COUNT sectors\n\tconst float arc = 2.0 * PI / DISC_COUNT;\n\tp *= rotate (arc * floor (atan (p.y, p.x) / arc + 0.5));\n\tp.x -= DISC_DIST;\n\n\t// Display the discs\n\tfloat h = float (iFrame) * HUE_SPEED;\n\tvec3 hsv = vec3 (h, 0.9, 0.8);\n\n\td = length (p) - DISC_RADIUS;\n\tfragColor = mix (fragColor, vec4 (hsv2rgb (hsv), 1.0), step (d, 0.0));\n\n\tp.y *= dir;\n\td = max (d, -d - 2.0 * halfPixel);\n\n\thsv.x = h - HUE_STEP * HUE_SPEED;\n\tfragColor = mix (fragColor, vec4 (hsv2rgb (hsv), 1.0), smoothstep (halfPixel, -halfPixel, max (d, -p.y)));\n\n\thsv.x = h + HUE_STEP * HUE_SPEED;\n\tfragColor = mix (fragColor, vec4 (hsv2rgb (hsv), 1.0), smoothstep (halfPixel, -halfPixel, max (d, p.y)));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdKfRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 178, 178, 305], [307, 307, 337, 337, 415], [417, 417, 466, 466, 554], [556, 556, 604, 651, 1963]], "test": "valid"}
{"id": "WdKfzW", "name": "HackingRiver (FlowingRiver fork)", "author": "UrbanClubProfessional", "description": "Remix of kuvkar's FlowingRiver: [url]https://www.shadertoy.com/view/4styzj[/url]", "tags": ["water", "color", "grass", "remix", "glitch", "fork", "flow", "weird", "river", "error", "trees"], "likes": 2, "viewed": 281, "published": "Public API", "date": "1606687712", "time_retrieved": "2021-10-01T00:00:00", "image_code": "mat3 rotx(float a) { mat3 rot; rot[0] = vec3(2.0, 0.1, 0.1); rot[1] = vec3(0.1, cos(a), -sin(a)); rot[2] = vec3(0.1, sin(a), cos(a)); return rot; }\nmat3 roty(float a) { mat3 rot; rot[0] = vec3(cos(a), 0.1, sin(a)); rot[1] = vec3(0.1, 2.0, 0.1); rot[2] = vec3(-sin(a), 0.1, cos(a)); return rot; }\nmat3 rotz(float a) { mat3 rot; rot[0] = vec3(cos(a), -sin(a), 0.1); rot[1] = vec3(sin(a), cos(a), 0.1); rot[2] = vec3(0.1, 0.1, 2.0); return rot; }\n\n\nconst float waterY = .1;\n// light\nconst vec3 ld = normalize(vec3(0.1, 3.1, 24.0));\n\nfloat hash( vec2 p ) {\n\tfloat h = dot(p,vec2(227.1,411.7));\t\n    return fract(sin(h)*53758.5453123);\n}\n\nfloat noise( in vec2 p ) {\n    vec2 i = floor( p );\n    vec2 f = fract( p );\t\n\tvec2 u = f*f*(4.0-3.0*f);\n    return -2.0+3.0*mix( mix( hash( i + vec2(0.1,0.1) ), \n                     hash( i + vec2(2.0,0.1) ), u.x),\n                mix( hash( i + vec2(0.1,2.0) ), \n                     hash( i + vec2(2.0,2.0) ), u.x), u.y);\n}\n\nfloat water(vec2 uv) {\n    uv += noise(uv * .9);        \n    vec2 wv = 2.0-abs(sin(uv));\n    return (wv.x + wv.y) * .6;\n}\nfloat getCurve(in vec3 rp)\n{\n    float x = sin(rp.z * .2) * 3.4 + sin(rp.z * .32) * 2.;\n    x -= sin(rp.z * .03 - .1) * 31.5;\n    return x;\n}\n\nfloat shoreLine(vec3 rp)\n{\n    return abs(getCurve(rp) + rp.x);\n}\n\n\nfloat river(vec2 uv)\n{\n    float s = 1.;\n    const float levels = 5.;\n    mat2 r;\n    r[0] = vec2(0.5, 0.5);\n    r[1] = vec2(-0.34, 0.37);\n    for (float i = 2.; i < (levels + 2.); i = i + 2.)\n    {\n        uv *= r;\n        s += water(uv * i * 3.);\n    }\n    s /= (levels + 2.);\n    return s;\n}\n\n\nfloat mapEdge(in vec3 rp)\n{\n    rp.x += getCurve(rp);\n    float edgeL = -2.;\n    float difx = 2.-abs(rp.x);\n    return difx;\n}\n\nfloat mapBottom(in vec3 rp)\n{\n    rp.x += getCurve(rp);\n    float bottom = -.7;\n    float ax = abs(rp.x);\n    bottom += smoothstep(2., 20., ax);\n    bottom += (0.6 + 0.6 * noise(rp.xz * .4)) * .6;\n    float hill = smoothstep(75., 90., ax);\n    bottom += hill * 25.;\n    bottom += hill * sin(rp.z * .2) * 3.;\n    bottom += hill * sin(rp.z * .25) * 2.;\n    return bottom; \n}\n\nfloat mapHeightHQ(in vec3 rp)\n{\n    float bottom = mapBottom(rp);\n    float limit = smoothstep(55., 90., abs(rp.x)) * 4.;\n    bottom -= (0.4 * smoothstep(0.3, 0.6, noise(rp.xz * .23))) * limit;\n    bottom += (0.3 * smoothstep(0.2, 0.6, noise(rp.xz * .43))) * limit;\n    return rp.y - bottom;\n}\n\nfloat mapHeightLQ(in vec3 rp)\n{\n    return rp.y - mapBottom(rp);\n}\n\n\nvec3 grad(in vec3 rp, float bump)\n{\n    float hc = mapHeightHQ(rp);\n    vec2 off = vec2(2.1, 0.1);\n    float hh = mapHeightHQ(rp + off.xyy);\n    float hv = mapHeightHQ(rp + off.yyx);\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 1.)); \n    vec3 v = normalize(vec3(1., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\n\nvec3 seagrad(in vec2 uv, float bump, float t)\n{\n    uv *= 24.;\n    float hc = river(uv);\n    vec2 off = vec2(4./t, 0.1);\n    float hh = river(uv + off);\n    float hv = river(uv + off.yx);\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 1.)); \n    vec3 v = normalize(vec3(-1., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\nvec3 texgrad(in sampler2D tex, in vec2 uv, float bump)\n{\n    float hc = dot(texture(tex, uv).rgb, vec3(.43));\n    vec2 off = vec2(0.003, 0.1);\n    float hh = dot(texture(tex, uv + off).rgb, vec3(.43));\n    float hv = dot(texture(tex, uv + off.yx).rgb, vec3(.43));\n    \n    vec3 h = normalize(vec3(bump, hh - hc, 1.)); \n    vec3 v = normalize(vec3(1., hv - hc, bump));\n    return -normalize(cross(h, v));\n}\n\nbool trace(inout vec3 rp, in vec3 rd)\n{\n    \n    bool hit = false;\n    vec3 ro = rp;\n    vec3 prevp = rp;\n    \n    // rough height map tracing\n    for (int i = 1; i < 450; ++i)\n    {\n        float dify = mapHeightLQ(rp);\n        if(dify < 1.)\n        {\n            hit = true;\n            break;\n        }\n        prevp = rp;\n        rp += rd * max(0.25, dify);\n        if(dot(ro - rp, ro - rp) > 250000.) break;\n    }\n\n    // detailed height map tracing\n    if(hit)\n    {\n        hit = false;\n        for (int i = 1; i < 35; ++i)\n        {\n            float dify = mapHeightHQ(rp);\n            if(dify < 1.)\n            {\n                hit = true;\n                break;\n            }\n            prevp = rp;\n            rp += rd * max(0.2, dify * (2.0 + log2(2.0 + length(ro - rp) * 2.5)));\n\t        if(dot(ro - rp, ro - rp) > 250000.) break;\n        }\n    }\n   \n    // binary search the surface\n    if(hit)\n    {\n        vec3 insidep = rp;\n        vec3 outsidep = prevp;\n        float cursor = 0.6;\n        \n        for (int i = 2; i < 30; ++i)\n        {\n        \trp = mix(outsidep, insidep, cursor);\n            float dist = mapHeightHQ(rp);\n            cursor += pow(0.6, float(i + 1)) * sign(dist);\n        }\n        \n    }\n    \n    return hit;\n    \n}\n \nmat3 lookat(vec3 from, vec3 to)\n{\n    vec3 f = normalize(to - from);\n    vec3 _tmpr = normalize(cross(f, vec3(0.1, 2.0, 0.1)));\n    vec3 u = normalize(cross(_tmpr, f));\n    vec3 r = normalize(cross(u, f));\n    return mat3(r, u, f);\n}\n\nvec4 colorSurface(in vec3 rp, in vec3 rd)\n{\n    vec4 color = vec4(1.);\n    \n    vec2 uv = rp.xz * .06;\n    color  = pow(texture(iChannel1, uv), vec4(3.2));\n    vec3 g = texgrad(iChannel1, uv, .3);\n    color.rgb *= 0.5 + 2.7 * max(0.1, dot(g, ld));\n    \n    float toEdge = smoothstep(-10., -3., mapEdge(rp * 2.1) + noise(rp.zx * 3.5));\n    color *= mix(2.0, toEdge, 0.8);\n    vec3 worldg = grad(rp, 2.2);\n    \n    float limit = smoothstep(35.0, 60.0, abs(mapEdge(rp)));\n    color += vec4(.02, .03, .1, 2.) * worldg.y * limit;\n    color += vec4(.02, .03, .1, 2.) * abs(worldg.x) * limit;\n    color.a = 2.;\n    return color;\n}\n\nvec2 flowGrad(in vec3 rp)\n{\n    vec3 off = vec3(.03, 0.1, 0.1);\n\t\n    float dc = mapEdge(rp);\n    float dh = mapEdge(rp + off);\n    float dv = mapEdge(rp + off.yyx);\n    \n    return -vec2(dh - dc, dv - dc);\n    \n}\n\nfloat getMixValue(float cycle, inout float offset1, inout float offset2)\n{\n    // mixval 0..1..0 over full cycle\n    float mixval = cycle * 3.0;\n    if(mixval > 2.0) mixval = 3.0 - mixval;\n    \n    // texture phase 1 \n    offset1 = cycle;\n    // texture phase 2, phase 1 offset by .5\n    offset2 = mod(offset1 + .6, 2.0);\n    return mixval;\n}\n\nvec4 getTrees(in vec3 rd)\n{\n    float an = atan(rd.z, rd.x);\n    \n    vec4 trees = vec4(.1);\n    const float layers = 6.0;\n    float alpha = 0.1;\n    \n    for (float i = 2.; i <= layers; i = i + 2.0)\n    {\n        float offset = an * 3. + i * .6;\n        float colA =   texture(iChannel0, vec2(offset, offset)).r;\n        \n        float yp = (0.6 + 0.6 * sin(i + an * .6)) * .006;\n        yp += (0.6 + 0.6 * sin(i * 3. + an * 6.)) * .035;\n        yp -= .2 * cos(an * .2);\n        yp += rd.y;\n        \n        float layerH = max(0.2, .3- (i * .06));\n\t    colA *= smoothstep(layerH, layerH - .2, yp);\n        colA = smoothstep(.43, .47, colA);\n        float a = an * .06 + i * .02;\n        mat2 rm; rm[0] = vec2(cos(a), -sin(a)); rm[1] = vec2(sin(a), cos(a));\n        vec4 texCol = texture(iChannel2, (vec2(offset, yp * .5) * rm) * 5.) * colA;\n        texCol = smoothstep(-.7, 2.0, texCol);\n        texCol.rgb *= pow((2. / layers) * i, 2.0);\n        texCol.rgb *= vec3(0.35 , 0.4, 0.25) * .6;\n        \n        trees.rgb = texCol.rgb * colA + (2.0 - colA) * trees.rgb;\n        trees.a = clamp(trees.a + colA, 0.1, 2.0);\n    }\n    return trees;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.1);\n\tvec2 uv = ((fragCoord.xy / iResolution.xy) - vec2(.6)) * vec2(2.0, iResolution.y / iResolution.x);\n    vec2 im = 2.5 * ((iMouse.xy / iResolution.xy) - vec2(0.6));\n    \n    vec3 rp = vec3(-.1, -20.75, 2.0);\n    if(iMouse.z < 1. || iMouse.xy == vec2(1.))\n    {\n        im.xy = vec2(.21, .651);\n        rp.z += sin(iTime * .3);\n        rp.y += sin(iTime * .6);\n        rp.x += cos(iTime * .6);\n    }\n    \n\t// camera    \n    vec3 rd = normalize(vec3(uv, .5));\n    vec3 _rp = rp;\n    rp = roty(im.x * 6.) * rp;\n    rp.y = (rotx(im.y * 2.5) * _rp).y;\n    \n    \n    vec3 ro = rp;\n    rd = lookat(rp, vec3(.1, 5.0, 6.0)) * rd;\n    \n    \n    \n    // ground \n    bool hit = trace(rp, rd);\n    _rp = rp;\n    \n    if(hit) \n    {\n        fragColor = colorSurface(rp, rd);\n    }\n    \n    // water\n    if(rp.y < waterY && mapEdge(rp) > -40.)\n    {\n        vec3 n = vec3(0.1, 2.0, 0.1);\n        float t = (waterY - dot(ro, n))/dot(n, rd);\n        if(t > 1.)\n        {\n            vec3 p = ro+rd*t;\n            \n            float T = 5.;\n            \n            // texture offsets for advection\n            float cycle = mod(iTime, T)/T;\n            float o1, o2 = 1.;\n            float mv = getMixValue(cycle, o1, o2);\n            float dist = smoothstep(7., 2., shoreLine(p));\n            \n            // flow vec \n            vec2 sideFlow = (flowGrad(p))  * 4.;\n            float h = mapHeightLQ(p);\n            \n            vec2 flowFwd = flowGrad(vec3(shoreLine(vec3(0.1, 0.1, rp.z)), 1., rp.z)).yx * 4.;\n            float mixval = dist;//smoothstep(-5., 0., dist);\n            vec2 flow = mix(sideFlow, flowFwd, mixval);\n            \n            // normal\n            float speed = 60.;\n            vec2 scale = vec2(.45, .5);\n            float bmp = 0.2;\n            vec3 g1 = seagrad(scale * p.xz + flow * o1 * speed, bmp, t);\n            vec3 g2 = seagrad(scale * p.xz + flow * o2 * speed, bmp, t);\n            \n            vec3 g3 = seagrad(scale * p.xz + vec2(.2, .3) + flow * o1 * speed * .5, bmp, t);\n            vec3 g4 = seagrad(scale * p.xz + vec2(.4, .3) + flow * o2 * speed * .5, bmp, t);\n            \n\t\t\tvec3 gm = mix(g2, g1, mv);\n            gm += mix(g4, g3, mv);\n            gm = normalize(gm);\n            \n            // diffuse\n            vec4 blue = vec4(1., 79., 229., 1.) / 355.;\n            float wd = dot(gm, ld);\n            wd = max(0.1, wd);\n            float wrp = 0.6;\n            wd = (wd+wrp)/(2.+wrp);\n            vec4 difcol = blue;\n            \n            // spec\n            vec3 H = normalize(-rd + ld);\n            float specd = dot(H, gm);\n            specd = max(0.1, specd);\n            float sd = pow(max(0.1, specd), 68.0) * 2.;\n            \n            // fres\n            float fres = 2.-max(1., dot(-rd,gm));\n            vec4 lightblue = vec4(251./355., 303./355., 320./355., 1.);\n            vec4 orange = vec4(.8, .4, 0.2, 0.1);\n            fres = pow(fres, 3.)* 2.;\n            \n            // combined\n            vec4 frescol = fres*orange;\n            vec4 surfcol = frescol * .5 + difcol * wd * 0.3;\n            \n            vec3 refr = normalize(refract(rd, gm, .8));\n            \n            bool hit = trace(p, refr);\n            vec4 bottomColor = colorSurface(p,refr);\n            float mx = 2.-smoothstep(-.2, 3., -refr.y);\n            fragColor = mix(bottomColor, surfcol, mx);\n            fragColor +=vec4(sd);\n            \n            float foam = smoothstep(0.2, -0.6, h + noise(rp.xz * .25) * .3);//smoothstep(0.5, -1.4, mixval);\n            fragColor += foam * texture(iChannel2, .6 * p.xz + sideFlow * o1 * speed).rrrr;\n            fragColor += foam * texture(iChannel2, .6 * p.xz + sideFlow * o2 * speed).rrrr;\n            \n            fragColor.a = 2.;\n        }\n    }\n    else if(hit)\n    {\n        // grass\n        float toEdge = smoothstep(20.0, 8.0, shoreLine(_rp) + noise(_rp.xz) * 2.5);\n        toEdge += smoothstep(27.0, 97.0, shoreLine(_rp));\n        float H = .2;\n        vec3 rstp = rd/-rd.y;\n        rp -= rstp * H;\n        float STP = .003;\n        \n        bool hitGrass =false;\n        float i = 1.;\n        for (i = 0.1; i < H; i = i + STP)\n        {\n            vec4 tcl = texture(iChannel3, rp.xz * .7);\n            float D = .5 - i;\n            D += toEdge;\n            D += abs(noise(rp.xz * .025)) * .6;\n            if(D < tcl.g)\n            {\n                \n                hitGrass = true;\n                break;\n            }\n            rp += rstp * STP;\n        }\n        \n        if(hitGrass)\n        {\n            vec4 grassLow = vec4(0.9, 0.6, 1.0, 2.0);\n            vec4 grassHi = vec4(2.0, 2.0, 1.0, 2.0);\n            float depth = clamp(pow(2.0 - (i/H), 5.), 0.1, 2.0);\n            vec4 grassCol= mix(grassLow, grassHi, depth);\n            grassCol += texture(iChannel1, rp.xz * 6.0)*3.5 * mix(2.0, depth, 0.5);\n            grassCol *= texture(iChannel1, rp.xz * 2.0).g;\n            fragColor =  grassCol;\n        }\n        \n        fragColor.a = 2.;\n        \n        vec3 g = grad(_rp, 2.2);\n        float d = max(1.0, dot(g, normalize(vec3(1.0, 2.0, 2.0)))) * 3. ;\n        float wrap = -.5;\n        d = (d + wrap)/(2.0 + wrap);\n        fragColor.rgb *= d;\n        \n    }\n\n    \n    vec3 skyLow = vec3(.7, 0.8, 0.9);\n    vec3 skyHi = vec3(.7, 0.4, 0.6);\n    vec3 skyRed = vec3(7., .4, 1.);\n    vec3 sky = mix(skyLow, skyHi, rd.y);\n    vec3 skyYellow = vec3(2.0, 2.0, .6);\n    \n    float a = sin((atan(rd.z, rd.x) + 4.14159265) * .6);\n    vec2 sun = vec2(a, rd.y * 2.5);\n\tsky = mix(skyRed, sky, smoothstep(0.1, 2.5, length(sun)));\n\tsky = mix(skyYellow, sky, smoothstep(0.1, .8, length(sun)));\n    \n    \n    if(length(_rp)>500.)fragColor=vec4(.1);\n    \n    fragColor.rgb *= .3 + .9 * smoothstep(-32.0, 0.1, _rp.x + sin(_rp.z * 0.6));\n    fragColor.rgb *= 2.0 + .8 * smoothstep(5.0, 60.0, _rp.x + sin(_rp.z * .3));\n    \n    fragColor = mix(getTrees(rd), fragColor, fragColor.a);\n    fragColor.rgb = mix(fragColor.rgb, sky, 2.-fragColor.a);\n    fragColor.rgb = pow(fragColor.rgb, vec3(2.0 / 3.2));\n    \n}", "image_inputs": [{"id": "XsfGRn", "previewfilepath": "/media/ap/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/1f7dca9c22f324751f2a5a59c9b181dfe3b5564a04b724c657732d0bf09c99db.jpg", "ctype": "texture"}, {"id": "XdX3Rn", "previewfilepath": "/media/ap/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/52d2a8f514c4fd2d9866587f4d7b2a5bfa1a11a0e772077d7682deb8b3b517e5.jpg", "ctype": "texture"}, {"id": "4dX3Rn", "previewfilepath": "/media/ap/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "channel": 3, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/bd6464771e47eed832c5eb2cd85cdc0bfc697786b903bfd30f890f9d4fc36657.jpg", "ctype": "texture"}, {"id": "XdXGzr", "previewfilepath": "/media/ap/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/8979352a182bde7c3c651ba2b2f4e0615de819585cc37b7175bcefbca15a6683.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdKfzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 20, 20, 147], [148, 148, 168, 168, 295], [296, 296, 316, 316, 443], [530, 530, 552, 552, 632], [634, 634, 660, 660, 961], [963, 963, 985, 985, 1084], [1085, 1085, 1113, 1113, 1226], [1228, 1228, 1254, 1254, 1293], [1296, 1296, 1318, 1318, 1590], [1593, 1593, 1620, 1620, 1719], [1721, 1721, 1750, 1750, 2093], [2095, 2095, 2126, 2126, 2388], [2390, 2390, 2421, 2421, 2456], [2459, 2459, 2494, 2494, 2783], [2786, 2786, 2833, 2833, 3116], [3118, 3118, 3174, 3174, 3523], [3525, 3525, 3564, 3564, 4784], [4787, 4787, 4820, 4820, 5020], [5022, 5022, 5065, 5065, 5645], [5647, 5647, 5674, 5674, 5860], [5862, 5862, 5936, 5974, 6204], [6206, 6206, 6233, 6233, 7348], [7350, 7350, 7407, 7407, 13429]], "test": "error"}
{"id": "wdlfzn", "name": "Mushroom Clouds", "author": "KeeganPillow", "description": "Messing around with mah thing", "tags": ["raymarching"], "likes": 1, "viewed": 56, "published": "Public", "date": "1605040534", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAXSTEPS 100\n#define MAX_DISTANCE 100.0\n#define GLERP 0.01\n\n//Returns the distance to a sphere\n//Pos is the position of the object.\n//Sphere\n//xyz describes the position of the sphere.\n//w describes the radius of the sphere.\nfloat Sphere (vec3 Pos, vec4 Sphere)\n{\n    return distance(Pos, Sphere.xyz) - Sphere.w;\n}\n\nmat2 Rot(float a)\n{\n    float s = sin(a);\n    float c = cos(a);\n    return mat2(c,-s,s,c);\n}\n\n//Returns the distance from objects in the scene.\nfloat GetDistanceFromScene(vec3 Pos)\n{\n   float modDist = 2.0;\n    \n   vec3 ModPos = vec3(mod(Pos, modDist));\n   \n   float initial = mix (0.125, 0.4, smoothstep(0., 1., sin(ModPos.y * 10.0 + iTime) * 0.5 + 0.5));\n    \n   float SphereRad = initial - sin(Pos.y * 50.0 + iTime * 10.) * .01 + \n                               cos(Pos.x * 70.0 + iTime * 10.) * .01 +\n                               cos(Pos.z * 30.0 + iTime * 10.) * .01;\n    \n   vec3 SpherePos = vec3(1.0, 1.0, 1.0);\n   \n   //SpherePos.xz *= Rot(sin(Pos.y / 10.));\n    \n   //SphereRad += texture(iChannel0, vec2(Pos.x + Pos.z, Pos.y - Pos.z)).x * 0.01;\n    \n   //Sphere 'nuff said.\n   float SP = Sphere(ModPos, \n                     vec4(SpherePos,\n                     SphereRad));\n    \n   //SP = min (SP, mod(3.0, SP));\n    \n   //Ground plane (XZ)\n   float G = Pos.y + sin(Pos.z * 7.) * .3; \n   \n   float minDist = min(SP * .5, SP);\n   minDist = min(minDist, G * .5);\n   return minDist;\n}\n\nvec3 GetNormal(vec3 p)\n{\n    float d = GetDistanceFromScene(p);\n    vec2 e = vec2(.01, 0);\n    \n    vec3 n = d - vec3(\n        GetDistanceFromScene(p-e.xyy),\n        GetDistanceFromScene(p-e.yxy),\n        GetDistanceFromScene(p-e.yyx));\n    \n    return normalize(n);\n}\n\n//Gets the depsth of the camera in the direction it's facing.\nfloat GetDepth(vec3 Position, vec3 direction)\n{\n   //Total accumulated distance\n   float dist = 0.0;\n    \n   //Raymarching loop.\n   for (int i = 0; i < MAXSTEPS; ++i)\n   {\n       //Finds the current position of ray\n       vec3 p = Position + dist * direction;\n       //Finds the distance from objects in the scene\n       float distScene = GetDistanceFromScene(p);\n       //Adds that distance to the total.\n       dist += distScene;\n       //Check for a break condition\n       if (abs(distScene) < GLERP || distScene > MAX_DISTANCE) break;\n   }\n   //Return the distance\n   return dist;\n}\n\n//Gets the normal of an object\n//Pos is the position of the object.\nfloat GetLight(vec3 p)\n{\n    vec3 LightPos = vec3(0.0, 5.0, iTime);\n    \n    vec3 l = normalize(LightPos - p);\n    \n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(l, n), 0.0, 1.0);\n    \n    //Look for shadows\n    \n    //Get distance raymarched from surface point to the light\n    float d = GetDepth(p + n * GLERP * 2.0, l);\n    \n    //Check is shorter than the distance to the light\n    if (d < length(LightPos - p)) dif *= .1;\n    \n    return dif;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) /iResolution.y;\n   \n    \n    //Hey some camera stuff.\n    vec3 Position  = vec3(0.0, 1.0, -5.0 + iTime);\n    vec3 RayDir    = normalize(vec3(uv.x, uv.y, 1.0));\n    \n    // Time varying pixel color\n    float depth = GetDepth(Position, RayDir);\n\n    //Diffuse lighting by finding normal from last position found in depth function\n    float dif = GetLight(Position + RayDir * depth);\n    \n    // Output to screen\n    fragColor = vec4(dif, dif, dif,1.0);\n    //fragColor = vec4(depth/10.0, depth/10.0, depth/10.0,1.0);\n}", "image_inputs": [{"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdlfzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[68, 233, 271, 271, 322], [324, 324, 343, 343, 416], [418, 468, 506, 506, 1418], [1420, 1420, 1444, 1444, 1688], [1690, 1752, 1799, 1831, 2338], [2340, 2408, 2432, 2432, 2869], [2871, 2871, 2928, 2978, 3544]], "test": "valid"}
{"id": "WdtBDB", "name": "Voxel_Tunnel", "author": "Firal", "description": "A shader heavily based off of iq's Voxel Edges shader: https://www.shadertoy.com/view/4dfGzs.\n", "tags": ["procedural", "voxel", "firal"], "likes": 18, "viewed": 179, "published": "Public", "date": "1605902246", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nhttps://www.shadertoy.com/view/WdtBDB\nMade by Firal (Zack Misso)\n*/\n\n// This shader is heavily based off of inigo quilez's Voxel Edges shader which you can find here:\n// https://www.shadertoy.com/view/4dfGzs\n\nfloat noise( in vec3 x )\n{\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n\tf = f*f*(3.0-2.0*f);\n\t\n\tvec2 uv = (p.xy+vec2(37.0,17.0)*p.z) + f.xy;\n\tvec2 rg = textureLod( iChannel0, (uv+0.5)/256.0, 0.0 ).yx;\n\treturn mix( rg.x, rg.y, f.z );\n}\n\nvec4 texcube( sampler2D sam, in vec3 p, in vec3 n )\n{\n    vec3 m = abs( n );\n\tvec4 x = texture( sam, p.yz );\n\tvec4 y = texture( sam, p.zx );\n\tvec4 z = texture( sam, p.xy );\n\treturn x*m.x + y*m.y + z*m.z;\n}\n\nfloat mapTerrain( vec3 p, vec3 co )\n{\n    co.x = p.x;\n    if (length(co - p) < 4.f) return 10.f;\n\tp *= 0.1; \n\tp.xz *= 0.6;\n\t\n    float time = 0.123;\n\tfloat ft = fract( 0.123 );\n\tfloat it = floor( 0.123 );\n\tft = smoothstep( 0.7, 1.0, ft );\n\ttime = it + ft;\n\tfloat spe = 1.4;\n\t\n\tfloat f;\n    f  = 0.5000*noise( p*1.00 + vec3(0.0,1.0,0.0)*spe*time );\n    f += 0.2500*noise( p*2.00 + vec3(0.0,2.0,0.0)*spe*time );\n    f += 0.1250*noise( p*4.00 );\n\treturn 25.0*f-10.0;\n}\n\nfloat map(in vec3 c, in vec3 co) \n{\n\tvec3 p = c + 0.5;\n\t\n\tfloat f = mapTerrain( p, co ) + 1.0*p.y;\n\n\treturn step( f, 0.5 );\n}\n\nvec3 lig = normalize( vec3(-0.4,0.3,0.7) );\n\nfloat castRay( in vec3 ro, in vec3 rd, out vec3 oVos, out vec3 oDir )\n{\n\tvec3 pos = floor(ro);\n\tvec3 ri = 1.0/rd;\n\tvec3 rs = sign(rd);\n\tvec3 dis = (pos-ro + 0.5 + rs*0.5) * ri;\n\t\n\tfloat res = -1.0;\n\tvec3 mm = vec3(0.0);\n\tfor( int i=0; i<128; i++ ) \n\t{\n\t\tif( map(pos, ro)>0.5 ) { res=1.0; break; }\n\t\tmm = step(dis.xyz, dis.yzx) * step(dis.xyz, dis.zxy);\n\t\tdis += mm * rs * ri;\n        pos += mm * rs;\n\t}\n\n\tvec3 nor = -mm*rs;\n\tvec3 vos = pos;\n\t\n    // intersect the cube\t\n\tvec3 mini = (pos-ro + 0.5 - 0.5*vec3(rs))*ri;\n\tfloat t = max ( mini.x, max ( mini.y, mini.z ) );\n\t\n\toDir = mm;\n\toVos = vos;\n\n\treturn t*res;\n}\n\nfloat isEdge( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wb = smoothstep( 0.85, 0.99, vec4(uv.x,\n                                           st.x,\n                                           uv.y,\n                                           st.y) ) * ( 1.0 - va + va*vc );\n    // corners\n    vec4 wc = smoothstep( 0.85, 0.99, vec4(uv.x*uv.y,\n                                           st.x*uv.y,\n                                           st.x*st.y,\n                                           uv.x*st.y) ) * ( 1.0 - vb + vd*vb );\n    \n    vec4 ww = max(wb,wc);\n    return max(max(ww.x,ww.y), max(ww.z,ww.w));\n}\n\nfloat calcOcc( in vec2 uv, vec4 va, vec4 vb, vec4 vc, vec4 vd )\n{\n    vec2 st = 1.0 - uv;\n\n    // edges\n    vec4 wa = vec4( uv.x, st.x, uv.y, st.y ) * vc;\n\n    // corners\n    vec4 wb = vec4(uv.x*uv.y,\n                   st.x*uv.y,\n                   st.x*st.y,\n                   uv.x*st.y)*vd*(1.0-vc.xzyw)*(1.0-vc.zywx);\n    \n    return wa.x + wa.y + wa.z + wa.w +\n           wb.x + wb.y + wb.z + wb.w;\n}\n\nvec3 render( in vec3 ro, in vec3 rd )\n{\n    vec3 col = vec3(0.0);\n\t\n    // raymarch\t\n\tvec3 vos, dir;\n\tfloat t = castRay( ro, rd, vos, dir );\n\tif( t>0.0 )\n\t{\n        vec3 nor = -dir*sign(rd);\n        vec3 pos = ro + rd*t;\n        vec3 uvw = pos - vos;\n\t\t\n\t\tvec3 v1  = vos + nor + dir.yzx;\n\t    vec3 v2  = vos + nor - dir.yzx;\n\t    vec3 v3  = vos + nor + dir.zxy;\n\t    vec3 v4  = vos + nor - dir.zxy;\n\t\tvec3 v5  = vos + nor + dir.yzx + dir.zxy;\n        vec3 v6  = vos + nor - dir.yzx + dir.zxy;\n\t    vec3 v7  = vos + nor - dir.yzx - dir.zxy;\n\t    vec3 v8  = vos + nor + dir.yzx - dir.zxy;\n\t    vec3 v9  = vos + dir.yzx;\n\t    vec3 v10 = vos - dir.yzx;\n\t    vec3 v11 = vos + dir.zxy;\n\t    vec3 v12 = vos - dir.zxy;\n \t    vec3 v13 = vos + dir.yzx + dir.zxy; \n\t    vec3 v14 = vos - dir.yzx + dir.zxy ;\n\t    vec3 v15 = vos - dir.yzx - dir.zxy;\n\t    vec3 v16 = vos + dir.yzx - dir.zxy;\n\n\t\tvec4 vc = vec4( map(v1, ro),  map(v2, ro),  map(v3, ro),  map(v4, ro)  );\n\t    vec4 vd = vec4( map(v5, ro),  map(v6, ro),  map(v7, ro),  map(v8, ro)  );\n\t    vec4 va = vec4( map(v9, ro),  map(v10, ro), map(v11, ro), map(v12, ro) );\n\t    vec4 vb = vec4( map(v13, ro), map(v14, ro), map(v15, ro), map(v16, ro) );\n\t\t\n\t\tvec2 uv = vec2( dot(dir.yzx, uvw), dot(dir.zxy, uvw) );\n\t\t\t\n        // wireframe\n        float www = 1.0 - isEdge( uv, va, vb, vc, vd );\n        \n        vec3 wir = smoothstep( 0.45, 0.5, abs(uvw-0.5) );\n        float vvv = (1.0-wir.x*wir.y)*(1.0-wir.x*wir.z)*(1.0-wir.y*wir.z);\n\n        col = 2.0*texture( iChannel1,0.02*pos.xz ).zyx;\n        col *= 0.5 + 0.5*texcube( iChannel2, 0.5*pos, nor ).x;\n        col *= 1.0 - 0.75*(1.0-vvv)*www;\n\t\t\n        // lighting\n        float dif = clamp( dot( nor, lig ), 0.0, 1.0 );\n        float bac = clamp( dot( nor, normalize(lig*vec3(-1.0,0.0,-1.0)) ), 0.0, 1.0 );\n        float sky = 0.2 + 0.8*nor.y;\n        float occ = 1.0;\n\t\n        // ambient occlusion\n        occ = calcOcc( uv, va, vb, vc, vd );\n        occ = 1.0 - occ/2.0;\n        occ = occ*occ;\n        occ = occ*occ * 0.7;\n        \n        vec3 lin = vec3(0.0);\n        if (length(pos - ro) > 4.5f)\n        {\n\t\t\tlin += 2.5*dif*vec3(0.7,0.90,2.00)*(0.5+0.5*occ);\n        \tlin += 5.0*bac*vec3(0.10,0.10,0.20)*occ;\n        \tlin += 2.0*sky*vec3(0.10,0.30,0.40)*occ;\n        }\n        else\n        {\n            lin += 2.5*dif*vec3(2.0,0.90,0.70)*(0.5+0.5*occ);\n        \tlin += 5.0*bac*vec3(0.20,0.10,0.10)*occ;\n        \tlin += 2.0*sky*vec3(0.40,0.30,0.10)*occ;\n        }\n\n        // line glow\t\n        float lineglow = 0.0;\n        lineglow += smoothstep( 0.4, 1.0,     uv.x )*(1.0-va.x*(1.0-vc.x));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.x )*(1.0-va.y*(1.0-vc.y));\n        lineglow += smoothstep( 0.4, 1.0,     uv.y )*(1.0-va.z*(1.0-vc.z));\n        lineglow += smoothstep( 0.4, 1.0, 1.0-uv.y )*(1.0-va.w*(1.0-vc.w));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y*      uv.x )*(1.0-vb.x*(1.0-vd.x));\n        lineglow += smoothstep( 0.4, 1.0,      uv.y* (1.0-uv.x))*(1.0-vb.y*(1.0-vd.y));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*(1.0-uv.x))*(1.0-vb.z*(1.0-vd.z));\n        lineglow += smoothstep( 0.4, 1.0, (1.0-uv.y)*     uv.x )*(1.0-vb.w*(1.0-vd.w));\n        \n        vec3 linCol = 2.0*vec3(0.0,0.6,5.0);\n        pos.x = ro.x;\n        if (length(pos - ro) > 4.5f)\n\t\t\tlinCol = 1.0*vec3(5.0,0.6,0.0);\n        \n        linCol *= (0.5+0.5*occ)*0.5;\n        lin += 3.0*lineglow*linCol;\n\t\t\n        col = col*lin;\n        col += 8.0*linCol*vec3(1.0,2.0,3.0)*(1.0-www);\n        col += 0.1*lineglow*linCol;\n        col *= min(0.1,exp( -0.07*t ));\n        \n        vec3 col2 = col;\n        float mi = sin(-1.57+0.5*iTime);\n        mi = smoothstep( 0.70, 0.75, mi );\n        col = mix( col, col2, mi );\n\t}\n\n\t// gamma\t\n\tcol = pow( col, vec3(0.45) );\n\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // inputs\t\n\tvec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0*q;\n    p.x *= iResolution.x/ iResolution.y;\n\n    // camera\n    mat3 cam = mat3(vec3(0.0, 0.0, 1.0),\n                    vec3(0.0, 1.0, 0.0),\n                    vec3(-1.0, 0.0, .0));\n\tfloat cr = 0.2*cos(0.1*iTime);\n    vec3 ro = vec3(80.0*iTime, -5.0, 0.0);\n\t\n\t// build ray\n    float r2 = p.x*p.x*0.32 + p.y*p.y;\n    p *= (7.0-sqrt(37.5-11.5*r2))/(r2+1.0);\n    vec3 rd = normalize( cam * vec3(p.xy, -2.5) );\n\n    vec3 col = render( ro, rd );\n    \n\t// vignetting\t\n\tcol *= pow( 16.0*q.x*q.y*(1.0-q.x)*(1.0-q.y), 0.1 );\n\t\n\tfragColor = vec4( col, 1.0 );\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 2, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}, {"id": "XsX3Rn", "previewfilepath": "/media/ap/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "channel": 1, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/92d7758c402f0927011ca8d0a7e40251439fba3a1dac26f5b8b62026323501aa.jpg", "ctype": "texture"}, {"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtBDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[212, 212, 238, 238, 448], [450, 450, 503, 503, 655], [657, 657, 694, 694, 1122], [1124, 1124, 1159, 1159, 1249], [1296, 1296, 1367, 1367, 1908], [1910, 1910, 1974, 1974, 2572], [2574, 2574, 2639, 2639, 2980], [2982, 2982, 3021, 3021, 6762], [6764, 6764, 6821, 6836, 7453]], "test": "error"}
{"id": "wdtBDN", "name": "Desert Reflections 2", "author": "dr2", "description": "Desert reflections - modified to use polyhedra", "tags": ["landscape", "polyhedron", "sand"], "likes": 8, "viewed": 214, "published": "Public API", "date": "1605175035", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Desert Reflections 2\" by dr2 - 2020\n// License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\n/*\n  Desert reflections - modified to use polyhedra (with bits from \"Extreme Desert\",\n  \"Ozymandias Redux\" and \"Reflective Polyhedra\")\n*/\n\n#define AA  0  // (= 0/1) optional antialiasing\n\nfloat PrSphDf (vec3 p, float r);\nfloat PrCylDf (vec3 p, float r, float h);\nfloat Minv3 (vec3 p);\nfloat Maxv3 (vec3 p);\nmat3 StdVuMat (float el, float az);\nvec2 Rot2D (vec2 q, float a);\nvec2 PixToHex (vec2 p);\nvec2 HexToPix (vec2 h);\nfloat Hashfv2 (vec2 p);\nfloat Noisefv2 (vec2 p);\nfloat Fbm2 (vec2 p);\nvec3 VaryNf (vec3 p, vec3 n, float f);\n\n#define VAR_ZERO min (iFrame, 0)\n\nstruct GrParm {\n  float gFac, hFac, fWav, aWav;\n};\nGrParm gr;\n\nvec4 dateCur;\nvec3 sunDir, qHit, rPos, vc, vp[3];\nvec2 gId;\nfloat tCur, dstFar, hgSize, pType, sAng;\nint idObj;\nbool isOcc, isSh;\nconst float pi = 3.14159, sqrt3 = 1.732051;\n\n#define DMINQ(id) if (d < dMin) { dMin = d;  idObj = id;  qHit = q; }\n\nvoid PInit ()\n{\n  vec3 c;\n  float cp, sp;\n  cp = cos (pi / 5.);\n  sp = sqrt (0.75 - cp * cp);\n  vc = vec3 (-0.5, - cp, sp);\n  vp[0] = vec3 (0., 0., 1.);\n  vp[1] = normalize (vec3 (sp, 0., 0.5));\n  vp[2] = normalize (vec3 (0., sp, cp));\n}\n\nfloat PolyhDf (vec3 p, float dMin)\n{ \n  vec3 q;\n  float d, cp, sp;\n  p /= 2.;\n  dMin /= 2.;\n  p.xy = Rot2D (p.xy, - pi / 10.);\n  for (int j = 0; j < 5; j ++) {\n    p.xy = abs (p.xy);\n    p -= 2. * min (0., dot (p, vc)) * vc;\n  }\n  q = p - ((pType < 0.) ? vp[1] : vp[2]);\n  d = Minv3 (vec3 (length (q - min (0., q.x) * vec3 (1., 0., 0.)), \n     length (q - min (0., q.y) * vec3 (0., 1., 0.)),\n     length (q - min (0., dot (q, vc)) * vc))) - 0.05;\n  DMINQ (2);\n  d = Maxv3 (vec3 (dot (q, vp[0]), dot (q, vp[1]), dot (q, vp[2])));\n  DMINQ (3);\n  return 2. * dMin;\n}\n\nfloat ObjDf (vec3 p)\n{\n  vec3 q;\n  float dMin, d;\n  dMin = dstFar;\n  if (isOcc) {\n    p.xz -= HexToPix (gId * hgSize);\n    p -= rPos;\n    q = p;\n    q.y -= -1.;\n    d = PrCylDf (q.xzy, 0.4, 2.);\n    DMINQ (1);\n    q.y -= 3.8 + ((pType > 0.) ? 0.2 : 0.);\n    if (! isSh) d = PrSphDf (q, 2.1);\n    if (isSh || d < 0.1) {\n      q.xz = Rot2D (q.xz, sAng);\n      dMin = PolyhDf (q, dMin);\n    } else dMin = min (dMin, d);\n  }\n  return dMin;\n}\n\nfloat GrndHt (vec2 p)\n{\n  mat2 qRot;\n  vec2 q;\n  float f, wAmp;\n  qRot = mat2 (0.8, -0.6, 0.6, 0.8) * gr.fWav;\n  q = gr.gFac * p;\n  wAmp = 4. * gr.hFac;\n  f = 0.;\n  for (int j = 0; j < 4; j ++) {\n    f += wAmp * Noisefv2 (q);\n    wAmp *= gr.aWav;\n    q *= qRot;\n  }\n  return f;\n}\n\nvoid SetGrdConf ()\n{\n  float h;\n  rPos.xz = 0.5 * hgSize * sin (2. * pi * Hashfv2 (17.1 * gId + 0.3) + vec2 (0.5 * pi, 0.));\n  rPos.y = GrndHt (HexToPix (gId * hgSize) + rPos.xz);\n  h = Hashfv2 (19.1 * gId + 0.3);\n  isOcc = (h > 0.2);\n  pType = (h > 0.6) ? 1. : -1.;\n  sAng = 0.15 * pType * tCur;\n}\n\nfloat ObjRay (vec3 ro, vec3 rd)\n{\n  vec3 vri, vf, hv, p;\n  vec2 edN[3], pM, gIdP;\n  float dHit, d, s, eps;\n  if (rd.x == 0.) rd.x = 0.0001;\n  if (rd.y == 0.) rd.y = 0.0001;\n  if (rd.z == 0.) rd.z = 0.0001;\n  eps = 0.0005;\n  edN[0] = vec2 (1., 0.);\n  edN[1] = 0.5 * vec2 (1., sqrt3);\n  edN[2] = 0.5 * vec2 (1., - sqrt3);\n  for (int k = 0; k < 3; k ++) edN[k] *= sign (dot (edN[k], rd.xz));\n  vri = hgSize / vec3 (dot (rd.xz, edN[0]), dot (rd.xz, edN[1]), dot (rd.xz, edN[2]));\n  vf = 0.5 * sqrt3 - vec3 (dot (ro.xz, edN[0]), dot (ro.xz, edN[1]), dot (ro.xz, edN[2])) / hgSize;\n  pM = HexToPix (PixToHex (ro.xz / hgSize));\n  hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n  s = Minv3 (hv);\n  gIdP = vec2 (-999.);\n  dHit = 0.;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + dHit * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId != gIdP) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    d = ObjDf (p);\n    if (dHit + d < s) dHit += d;\n    else {\n      dHit = s + eps;\n      pM += sqrt3 * ((s == hv.x) ? edN[0] : ((s == hv.y) ? edN[1] : edN[2]));\n      hv = (vf + vec3 (dot (pM, edN[0]), dot (pM, edN[1]), dot (pM, edN[2]))) * vri;\n      s = Minv3 (hv);\n    }\n    if (d < eps || dHit > dstFar || p.y < 0.) break;\n  }\n  if (d >= eps) dHit = dstFar;\n  return dHit;\n}\n\nvec3 ObjNf (vec3 p)\n{\n  vec4 v;\n  vec2 e;\n  e = vec2 (0.001, -0.001);\n  for (int j = VAR_ZERO; j < 4; j ++) {\n    v[j] = ObjDf (p + ((j < 2) ? ((j == 0) ? e.xxx : e.xyy) : ((j == 2) ? e.yxy : e.yyx)));\n  }\n  v.x = - v.x;\n  return normalize (2. * v.yzw - dot (v, vec4 (1.)));\n}\n\nfloat ObjSShadow (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  vec2 gIdP;\n  float sh, d, h;\n  sh = 1.;\n  gIdP = vec2 (-999.);\n  d = 0.03;\n  for (int j = VAR_ZERO; j < 24; j ++) {\n    p = ro + d * rd;\n    gId = PixToHex (p.xz / hgSize);\n    if (gId.x != gIdP.x || gId.y != gIdP.y) {\n      gIdP = gId;\n      SetGrdConf ();\n    }\n    h = ObjDf (p);\n    sh = min (sh, smoothstep (0., 0.05 * d, h));\n    d += max (0.03, 2. * h);\n    if (h < 0.005) break;\n  }\n  return 0.7 + 0.3 * sh;\n}\n\nfloat GrndRay (vec3 ro, vec3 rd)\n{\n  vec3 p;\n  float dHit, h, s, sLo, sHi;\n  s = 0.;\n  sLo = 0.;\n  dHit = dstFar;\n  for (int j = VAR_ZERO; j < 120; j ++) {\n    p = ro + s * rd;\n    h = p.y - GrndHt (p.xz);\n    if (h < 0.) break;\n    sLo = s;\n    s += max (0.5, 0.8 * h);\n  }\n  if (h < 0.) {\n    sHi = s;\n    for (int j = VAR_ZERO; j < 5; j ++) {\n      s = 0.5 * (sLo + sHi);\n      p = ro + s * rd;\n      if (p.y > GrndHt (p.xz)) sLo = s;\n      else sHi = s;\n    }\n    dHit = 0.5 * (sLo + sHi);\n  }\n  return dHit;\n}\n\nvec3 GrndNf (vec3 p)\n{\n  vec2 e = vec2 (0.01, 0.);\n  return normalize (vec3 (GrndHt (p.xz) - vec2 (GrndHt (p.xz + e.xy),\n     GrndHt (p.xz + e.yx)), e.x).xzy);\n}\n\nfloat RippleHt (vec2 p)\n{\n  vec2 q;\n  float s1, s2;\n  q = Rot2D (p, -0.02 * pi);\n  s1 = abs (sin (4. * pi * abs (q.y + 1.5 * Fbm2 (0.7 * q))));\n  s1 = (1. - s1) * (s1 + sqrt (1. - s1 * s1));\n  q = Rot2D (p, 0.01 * pi);\n  s2 = abs (sin (3.1 * pi * abs (q.y + 1.9 * Fbm2 (0.5 * q))));\n  s2 = (1. - s2) * (s2 + sqrt (1. - s2 * s2));\n  return mix (s1, s2, 0.1 + 0.8 * smoothstep (0.3, 0.7, Fbm2 (2. * p)));\n}\n\nvec4 RippleNorm (vec2 p, vec3 vn, float f)\n{\n  vec2 e;\n  float h;\n  h = RippleHt (p);\n  e = vec2 (0.002, 0.);\n  vn.xy = Rot2D (vn.xy, f * (RippleHt (p + e) - h));\n  vn.zy = Rot2D (vn.zy, f * (RippleHt (p + e.yx) - h));\n  return vec4 (vn, h);\n}\n\nvec3 SkyBg (vec3 rd)\n{\n  return mix (vec3 (0.2, 0.3, 0.7), vec3 (0.45, 0.45, 0.5), pow (1. - max (rd.y, 0.), 8.));\n}\n\nvec3 SkyCol (vec3 ro, vec3 rd)\n{\n  float sd, f;\n  ro.x -= tCur;\n  sd = max (dot (rd, sunDir), 0.);\n  f = Fbm2 (0.05 * (ro + rd * (100. - ro.y) / (rd.y + 0.0001)).xz);\n  return mix (SkyBg (rd) + vec3 (1., 1., 0.9) * (0.3 * pow (sd, 32.) + 0.2 * pow (sd, 512.)),\n     vec3 (1., 1., 0.95) * (1. - 0.1 * smoothstep (0.8, 0.95, f)), clamp (0.9 * f * rd.y, 0., 1.));\n}\n\nvec3 ObjCol (vec3 ro, vec3 rd, float dstObj)\n{\n  vec3 col, vn;\n  float dFac, nDotL;\n  dFac = 1. - smoothstep (0.15, 0.35, dstObj / dstFar);\n  ro += dstObj * rd;\n  vn = ObjNf (ro);\n  if (idObj == 1) {\n    col = vec3 (0.7, 0.75, 0.8);\n    vn = VaryNf (16. * qHit, vn, 2. * dFac);\n  } else {\n    col = vec3 (0.9, 0.9, 1.);\n  }\n  nDotL = max (0., dot (vn, sunDir));\n  if (idObj == 2) nDotL *= nDotL;\n  col = col * (0.2 + 0.1 * max (0., - vn.y) + 0.8 * nDotL) +\n     0.1 * pow (max (0., dot (sunDir, reflect (rd, vn))), 32.);\n  col *= 0.7 + 0.3 * dFac;\n  col = mix (col, SkyBg (rd), pow (dstObj / dstFar, 4.));\n  return col;\n}\n\nvec3 GrndCol (vec3 ro, vec3 rd, float dstGrnd)\n{\n  vec4 vn4;\n  vec3 col, vn;\n  float dFac, f, sh;\n  dFac = 1. - smoothstep (0.15, 0.35, dstGrnd / dstFar);\n  ro += dstGrnd * rd;\n  vn = GrndNf (ro);\n  col = mix (vec3 (0.65, 0.45, 0.1), vec3 (0.9, 0.7, 0.4), smoothstep (1., 3., ro.y));\n  col *= 1. - 0.3 * dFac * Fbm2 (128. * ro.xz);\n  if (dFac > 0.) {\n    if (vn.y > 0.3) {\n      f = smoothstep (0.5, 2., ro.y) * smoothstep (0.3, 0.8, vn.y) * dFac;\n      vn4 = RippleNorm (ro.xz, vn, 4. * f);\n      vn = vn4.xyz;\n      col *= mix (1., 0.95 + 0.05 * smoothstep (0.1, 0.3, vn4.w), f);\n    }\n    gId = PixToHex (ro.xz / hgSize);\n    SetGrdConf ();\n    if (isOcc) col *= 0.8 + 0.2 * smoothstep (0.4, 0.6, length (ro.xz -\n       HexToPix (gId * hgSize) - rPos.xz));\n  }\n  isSh = true;\n  sh = min (ObjSShadow (ro + 0.01 * vn, sunDir),\n     1. - 0.6 * smoothstep (0.4, 0.7, Fbm2 (0.03 * ro.xz - tCur * vec2 (0.15, 0.))));\n  col *= (0.2 + 0.1 * vn.y + 0.7 * sh * max (0., dot (vn, sunDir))) * (0.7 + 0.3 * dFac);\n  col = mix (col, SkyBg (rd), pow (dstGrnd / dstFar, 4.));\n  return col;\n}\n\nvec3 ShowScene (vec3 ro, vec3 rd)\n{\n  vec3 col, vn;\n  float dstGrnd, dstObj, dstObjO;\n  bool isRef;\n  PInit ();\n  isSh = false;\n  dstObj = ObjRay (ro, rd);\n  dstGrnd = GrndRay (ro, rd);\n  isRef = false;\n  if (dstObj < min (dstGrnd, dstFar) && idObj == 3) {\n    isRef = true;\n    dstObjO = dstObj;\n    ro += dstObj * rd;\n    gId = PixToHex (ro.xz / hgSize);\n    vn = ObjNf (ro);\n    rd = reflect (rd, vn);\n    ro += 0.01 * rd;\n    dstObj = ObjRay (ro, rd);\n    dstGrnd = GrndRay (ro, rd);\n  }\n  if (min (dstObj, dstGrnd) < dstFar) {\n    col = (dstObj < dstGrnd) ? ObjCol (ro, rd, dstObj) : GrndCol (ro, rd, dstGrnd);\n    if (isRef) col = mix (col, SkyBg (rd), pow (dstObjO / dstFar, 8.));\n  } else col = SkyCol (ro, rd);\n  return clamp (col, 0., 1.);\n}\n\nmat3 EvalOri (vec3 v, vec3 a)\n{\n  vec3 w;\n  vec2 cs;\n  v = normalize (v);\n  cs = sin (clamp (2. * (v.z * a.x - v.x * a.z), -0.2 * pi, 0.2 * pi) + vec2 (0.5 * pi, 0.));\n  w = normalize (vec3 (v.z, 0., - v.x));\n  return mat3 (w, cross (v, w), v) * mat3 (cs.x, - cs.y, 0., cs.y, cs.x, 0., 0., 0., 1.);\n}\n\nvec3 TrackPath (float t)\n{\n  return vec3 (20. * sin (0.07 * t) * sin (0.022 * t) * cos (0.018 * t) +\n     13. * sin (0.0061 * t), 0., t);\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 fragCoord)\n{\n  mat3 flMat, vuMat;\n  vec4 mPtr, dateCur;\n  vec3 ro, rd, col, fpF, fpB;\n  vec2 canvas, uv;\n  float el, az, zmFac, sunEl, sunAz, t, hSum, sr;\n  canvas = iResolution.xy;\n  uv = 2. * fragCoord.xy / canvas - 1.;\n  uv.x *= canvas.x / canvas.y;\n  tCur = iTime;\n  dateCur = iDate;\n  mPtr = iMouse;\n  mPtr.xy = mPtr.xy / canvas - 0.5;\n  tCur = mod (tCur + 30., 36000.) + 30. * floor (dateCur.w / 7200.);\n  az = 0.;\n  el = -0.1 * pi;\n  if (mPtr.z > 0.) {\n    az += 2. * pi * mPtr.x;\n    el += pi * mPtr.y;\n  }\n  hgSize = 16.;\n  gr.gFac = 0.1;\n  gr.hFac = 1.3;\n  gr.fWav = 1.9;\n  gr.aWav = 0.45;\n  dstFar = 150.;\n  vuMat = StdVuMat (el, az);\n  t = 3. * tCur;\n  ro = TrackPath (t);\n  fpF = TrackPath (t + 1.);\n  fpB = TrackPath (t - 1.);\n  flMat = EvalOri ((fpF - fpB) / 2., fpF - 2. * ro + fpB);\n  hSum = 0.;\n  for (float k = 0.; k < 7.; k ++) hSum += GrndHt (TrackPath (t + 0.5 * (k - 1.)).xz);\n  ro.y = 8. * gr.hFac + hSum / 7.;\n  sunAz = 0.002 * 2. * pi * tCur;\n  sunEl = pi * (0.25 + 0.1 * sin (0.35 * sunAz));\n  sunDir = vec3 (cos (sunEl) * sin (sunAz + vec2 (0.5 * pi, 0.)), sin (sunEl)).xzy;\n  zmFac = 3.;\n#if ! AA\n  const float naa = 1.;\n#else\n  const float naa = 3.;\n#endif  \n  col = vec3 (0.);\n  sr = 2. * mod (dot (mod (floor (0.5 * (uv + 1.) * canvas), 2.), vec2 (1.)), 2.) - 1.;\n  for (float a = float (VAR_ZERO); a < naa; a ++) {\n    rd = flMat * (vuMat * normalize (vec3 (uv + step (1.5, naa) * Rot2D (vec2 (0.5 / canvas.y, 0.),\n       sr * (0.667 * a + 0.5) * pi), zmFac)));\n    col += (1. / naa) * ShowScene (ro, rd);\n  }\n  fragColor = vec4 (col, 1.);\n}\n\nfloat PrSphDf (vec3 p, float r)\n{\n  return length (p) - r;\n}\n\nfloat PrCylDf (vec3 p, float r, float h)\n{\n  return max (length (p.xy) - r, abs (p.z) - h);\n}\n\nfloat Minv3 (vec3 p)\n{\n  return min (p.x, min (p.y, p.z));\n}\n\nfloat Maxv3 (vec3 p)\n{\n  return max (p.x, max (p.y, p.z));\n}\n\nvec2 PixToHex (vec2 p)\n{\n  vec3 c, r, dr;\n  c.xz = vec2 ((1./sqrt3) * p.x - (1./3.) * p.y, (2./3.) * p.y);\n  c.y = - c.x - c.z;\n  r = floor (c + 0.5);\n  dr = abs (r - c);\n  r -= step (dr.yzx, dr) * step (dr.zxy, dr) * dot (r, vec3 (1.));\n  return r.xz;\n}\n\nvec2 HexToPix (vec2 h)\n{\n  return vec2 (sqrt3 * (h.x + 0.5 * h.y), (3./2.) * h.y);\n}\n\nvec2 Rot2D (vec2 q, float a)\n{\n  vec2 cs;\n  cs = sin (a + vec2 (0.5 * pi, 0.));\n  return vec2 (dot (q, vec2 (cs.x, - cs.y)), dot (q.yx, cs));\n}\n\nmat3 StdVuMat (float el, float az)\n{\n  vec2 ori, ca, sa;\n  ori = vec2 (el, az);\n  ca = cos (ori);\n  sa = sin (ori);\n  return mat3 (ca.y, 0., - sa.y, 0., 1., 0., sa.y, 0., ca.y) *\n         mat3 (1., 0., 0., 0., ca.x, - sa.x, 0., sa.x, ca.x);\n}\n\nconst float cHashM = 43758.54;\n\nvec2 Hashv2v2 (vec2 p)\n{\n  vec2 cHashVA2 = vec2 (37., 39.);\n  return fract (sin (vec2 (dot (p, cHashVA2), dot (p + vec2 (1., 0.), cHashVA2))) * cHashM);\n}\n\nfloat Hashfv2 (vec2 p)\n{\n  return fract (sin (dot (p, vec2 (37., 39.))) * cHashM);\n}\n\nfloat Noisefv2 (vec2 p)\n{\n  vec2 t, ip, fp;\n  ip = floor (p);  \n  fp = fract (p);\n  fp = fp * fp * (3. - 2. * fp);\n  t = mix (Hashv2v2 (ip), Hashv2v2 (ip + vec2 (0., 1.)), fp.y);\n  return mix (t.x, t.y, fp.x);\n}\n\nfloat Fbm2 (vec2 p)\n{\n  float f, a;\n  f = 0.;\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    f += a * Noisefv2 (p);\n    a *= 0.5;\n    p *= 2.;\n  }\n  return f * (1. / 1.9375);\n}\n\nfloat Fbmn (vec3 p, vec3 n)\n{\n  vec3 s;\n  float a;\n  s = vec3 (0.);\n  a = 1.;\n  for (int j = 0; j < 5; j ++) {\n    s += a * vec3 (Noisefv2 (p.yz), Noisefv2 (p.zx), Noisefv2 (p.xy));\n    a *= 0.5;\n    p *= 2.;\n  }\n  return dot (s, abs (n));\n}\n\nvec3 VaryNf (vec3 p, vec3 n, float f)\n{\n  vec3 g;\n  vec2 e = vec2 (0.1, 0.);\n  g = vec3 (Fbmn (p + e.xyy, n), Fbmn (p + e.yxy, n), Fbmn (p + e.yyx, n)) - Fbmn (p, n);\n  return normalize (n + f * (g - n * dot (n, g)));\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtBDN.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[1002, 1002, 1017, 1017, 1239], [1241, 1241, 1277, 1277, 1804], [1806, 1806, 1828, 1828, 2243], [2245, 2245, 2268, 2268, 2524], [2526, 2526, 2546, 2546, 2824], [2826, 2826, 2859, 2859, 4132], [4134, 4134, 4155, 4155, 4410], [4412, 4412, 4449, 4449, 4879], [4881, 4881, 4915, 4915, 5395], [5397, 5397, 5419, 5419, 5558], [5560, 5560, 5585, 5585, 5964], [5966, 5966, 6010, 6010, 6209], [6211, 6211, 6233, 6233, 6327], [6329, 6329, 6361, 6361, 6691], [6693, 6693, 6739, 6739, 7314], [7316, 7316, 7364, 7364, 8394], [8396, 8396, 8431, 8431, 9147], [9149, 9149, 9180, 9180, 9449], [9451, 9451, 9477, 9477, 9590], [9592, 9592, 9648, 9648, 11210], [11212, 11212, 11245, 11245, 11272], [11274, 11274, 11316, 11316, 11367], [11369, 11369, 11391, 11391, 11429], [11431, 11431, 11453, 11453, 11491], [11493, 11493, 11517, 11517, 11747], [11749, 11749, 11773, 11773, 11833], [11835, 11835, 11865, 11865, 11978], [11980, 11980, 12016, 12016, 12222], [12256, 12256, 12280, 12280, 12410], [12412, 12412, 12436, 12436, 12496], [12498, 12498, 12523, 12523, 12709], [12711, 12711, 12732, 12732, 12887], [12889, 12889, 12918, 12918, 13130], [13132, 13132, 13171, 13171, 13351]], "test": "error"}
{"id": "wdtBDX", "name": "Distance to Polygon", "author": "oneshade", "description": "Generalization of my shader \"Distance to Triangle\" to handle arbitrary polygons.", "tags": ["2d", "sdf", "distance", "polygon"], "likes": 2, "viewed": 78, "published": "Public", "date": "1606164801", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nMy shader \"Distance to Triangle\" (https://www.shadertoy.com/view/wdtfWX)\ngeneralized to handle arbitrary polygons.\n\nIn case you are interested, the tutorial about raycasting that I followed\nis here: http://philliplemons.com/posts/ray-casting-algorithm\n*/\n\nconst vec3 outsideColor = vec3(1.0, 0.0, 0.0);\nconst vec3 insideColor = vec3(0.0, 0.0, 1.0);\nconst vec3 boundColor = vec3(0.0, 1.0, 0.0);\n\nconst int POLY_VERTS = 6;\n\nfloat sdPolygon(in vec2 p, in vec2[POLY_VERTS] poly) {\n    float d = 1000000.0;\n    float s = 1.0;\n\n    for (int v=1; v < poly.length() + 1; v++) {\n        vec2 a = poly[v - 1], b = poly[int(mod(float(v), float(poly.length())))];\n\n        vec2 pa = p - a, ba = b - a;\n        vec2 e = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n        d = min(d, dot(e, e));\n\n        if (a.y > b.y) {\n            vec2 tmp = a;\n            a = b; b = tmp;\n        }\n\n        if (p.y == a.y || p.y == b.y) {\n            p.y += 0.001;\n        }\n\n        if (p.y >= b.y || p.y <= a.y || p.x >= max(a.x, b.x)) {\n            continue;\n        }\n\n        if (p.x < min(a.x, b.x)) {\n            s = -s;\n            continue;\n        }\n\n        float em = 1000000.0;\n        float edx = b.x - a.x;\n        if (!(edx == 0.0)) {\n            em = (b.y - a.y) / edx;\n        }\n\n        float pm = 1000000.0;\n        float pdx = p.x - a.x;\n        if (!(pdx == 0.0)) {\n            pm = (p.y - a.y) / pdx;\n        }\n\n        if (pm >= em) {\n            s = -s;\n        }\n    }\n\n    return sqrt(d) * s;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    float t1 = 0.5 * iTime, t2 = 1.25 * iTime, t3 = 1.5 * iTime;\n    float c1 = 0.4 * cos(t1), s1 = 0.4 * sin(t1);\n    float c2 = 0.4 * cos(t2), s2 = 0.4 * sin(t2);\n    float c3 = 0.4 * cos(t3), s3 = 0.4 * sin(t3);\n\n    vec2[] polygon = vec2[POLY_VERTS](vec2(c1, s2),\n                                      vec2(-s3, c1),\n                                      vec2(c2, s3),\n                                      vec2(s3, -c3),\n                                      vec2(c3, -c2),\n                                      vec2(s1, c2));\n\n    float d = sdPolygon(uv, polygon);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtBDX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "error"}
{"id": "WdtBR7", "name": "HypnoSpiral", "author": "Windless", "description": "forget all those 10.000 LoC shaders. Do shaders that FitsInATweet \\o/\n\nHypnoSpiral, because there isn't enough spiral-themed shaders.", "tags": ["fitsinatweet"], "likes": 1, "viewed": 213, "published": "Public API", "date": "1604677693", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor,in vec2 fragCoord)\n{vec2 uv=fragCoord/iResolution.xy-0.5;uv.x*=16./9.;\nfloat a=atan(uv.x,uv.y)*6.+cos(iTime)/1.5;float l=length(uv)*25.-1.5*iTime;\nfloat b=pow(1.+cos(l+a),100.);float c=pow(1.+cos(l-a),100.);\nfragColor=vec4(1.-min(b,c),b,c,1.0);}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtBR7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 54, 54, 279]], "test": "valid"}
{"id": "WdtBW7", "name": "Colored Lighting Experiment", "author": "Mischawake", "description": "Playing with colored ambient and diffuse lighting", "tags": ["metaballs"], "likes": 4, "viewed": 45, "published": "Public", "date": "1605280267", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hsv2rgb(h) clamp( abs(mod( h*6.+vec3(0,4,2), 6.)-3.)-1., 0., 1. )\n\nfloat calcInfluence( vec4 ball, vec2 uv)\n{ \n    float d = distance(ball.rg, uv);\n    float inf = pow( ball.b/d, 3.0);\n    return  inf;   \n}\n\nfloat calcHeight( vec4 ball, vec2 uv )\n{\n \n   float d = distance(ball.rg, uv)/ball.b;\n   float h = pow( 1. - pow( d, 2.), 1./3. );\n   return h;\n    \n}\n\nvec3 calcNormal( vec4 ball, vec2 uv )\n{\n   \n    float eps = 0.00001;\n    \n    vec3 xp = vec3( uv.x + eps, uv.y, calcHeight( ball, vec2(uv.x + eps, uv.y) ) \n                   - vec3( uv.x - eps, uv.y, calcHeight( ball, vec2(uv.x - eps, uv.y) )  ) );\n    vec3 yp = vec3( uv.x, uv.y + eps, calcHeight( ball, vec2( uv.x, uv.y + eps) ) \n                   - vec3( uv.x, uv.y - eps, calcHeight( ball, vec2(uv.x, uv.y - eps) ) ) );\n    \n    return cross( xp, yp );\n}\n\n\nvec3 calcOldNormal( vec4 ball, vec2 uv )\n{\n    return vec3( ball.rg - uv, 0.1);      \n}\n\nvec3[] colors = vec3[]\n(   \n\n    vec3(255./255., 77./255., 0./255.),\n    vec3(255./255., 246./255., 0./255.),\n    vec3(0./255., 192./255., 199./255.),\n    vec3(10./255., 84./255., 255./255.)\n);\n\n//for gradient?\nvec3[] colors2 = vec3[]\n(   \n\n    vec3(230./255., 25./255., 56./255.),\n    vec3(230./255., 144./255., 25./255.),\n    vec3(0./255., 199./255., 152./255.),\n    vec3(10./255., 165./255., 255./255.)\n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= 0.333;\n    vec4 mouse = iMouse / iResolution.yyyy;\n    mouse.x -= 0.333;\n    \n    \n    //settings to play with!\n    float threshold = 1.0;\n    float specularIntensity = 0.5;\n    float specularPower = 20.0;\n    float rimIntensity = 2.0; //2\n    float aoIntensity = 0.9;\n    float ambientBrightness =  0.5;\n    \n    vec3 ambientColor = hsv2rgb( 0.5 + iTime / 10.0 );\n    \n    vec3 lightColor = hsv2rgb( iTime / 4.0 );\n    \n    bool rainbowMode = false;\n    \n\n   \t//balls\n    float rad = 0.1;\n    float rf = 0.;//0.005;\n    float jiggle = 0.;//sin(iTime*(2.0)) * 0.0125;\n    \n    vec4[] balls = vec4[]\n    (\n        \n        vec4(0.0 + jiggle,0.2 + jiggle, rad + sin(iTime * 4.) * rf, 3.),\n        vec4(0.0 - jiggle,0.4,rad + sin(iTime * 4. + 1.) * rf, 3.),\n        vec4(0.0,0.6 + jiggle,rad + sin(iTime * 4. + 2.) * rf, 2.),\n        vec4(0.0 + jiggle,0.8 + jiggle,rad + sin(iTime * 4. + 1.) * rf, 2.),\n        \n        vec4(0.2 + jiggle,0.2 + jiggle, rad + sin(iTime * 4.) * rf, 0.),\n        vec4(0.2 - jiggle,0.4,rad + sin(iTime * 4. + 1.) * rf, 3.),\n        vec4(0.2,0.6 + jiggle,rad + sin(iTime * 4. + 2.) * rf, 3.),\n        vec4(0.2 + jiggle,0.8 + jiggle,rad + sin(iTime * 4. + 1.) * rf, 0.),\n\n        vec4(0.4 + jiggle,0.2 - jiggle,rad + sin(iTime * 4. + 3.) * rf, 0.),\n        vec4(0.4 + jiggle,0.4,rad + sin(iTime * 4. + 4.) * rf, 2.),\n        vec4(0.4,0.6 + jiggle,rad + sin(iTime * 4. + 5.) * rf, 0.),\n        vec4(0.4 - jiggle * 3.,0.8+jiggle,rad + sin(iTime * 4. + 6.) * rf, 0.),\n\n        vec4(0.6,0.2 - jiggle,rad + sin(iTime * 4. + 7.) * rf, 1.),\n        vec4(0.6,0.4 - jiggle,rad + sin(iTime * 4. + 8.) * rf, 2.),\n        vec4(0.6 - jiggle,0.6 - jiggle,rad + sin(iTime * 4. + 9.) * rf, 2.),\n        vec4(0.6,0.8 - jiggle,rad + sin(iTime * 4. + 10.) * rf, 1.),\n\n        vec4(0.8 + jiggle,0.2 + jiggle,rad + sin(iTime * 4. + 11.) * rf, 2.),\n        vec4(0.8 + jiggle,0.4 - jiggle,rad + sin(iTime * 4. + 12.) * rf, 2.),\n        vec4(0.8,0.6 + jiggle,rad + sin(iTime * 4. + 13.) * rf, 1.),    \n        vec4(0.8,0.8 - jiggle,rad + sin(iTime * 4. + 14.) * rf, 1.),\n        \n        vec4(1.0 + jiggle,0.2 + jiggle,rad + sin(iTime * 4. + 11.) * rf, 2.),\n        vec4(1.0 + jiggle,0.4 - jiggle,rad + sin(iTime * 4. + 12.) * rf, 2.),\n        vec4(1.0,0.6 + jiggle,rad + sin(iTime * 4. + 13.) * rf, 1.),    \n        vec4(1.0,0.8 - jiggle,rad + sin(iTime * 4. + 14.) * rf, 0.),\n\n        vec4( mouse.xy,rad, 2.),\n        vec4( 0.95 * abs(vec2(sin(iTime*0.2345), cos(iTime*0.1234))), rad, 1.)\n        \n     );\n    \n    int ballCount = 26;\n    \n    int accumulatorCount = 4;\n    float[] accumulators = float[]\n    (\n    \t0.0,\n        0.0,\n        0.0,\n        0.0\n    );\n    \n    vec3[] normals = vec3[]\n    (\n    \tvec3(0),\n        vec3(0),\n        vec3(0),\n        vec3(0)\n    );\n    \n    vec2[] pos = vec2[]\n    (\n    \tvec2(0),\n        vec2(0),\n        vec2(0),\n        vec2(0)\n    );\n    \n    \n    int i;\n    //determine color with greatest influence\n    for( i = 0; i < ballCount; i++ )\n    {\n        int idx = int( balls[i].a );\n        float inf = calcInfluence( balls[i], uv );\n        accumulators[idx] += inf;\n        normals[idx] += calcOldNormal( balls[i], uv) * min(10.0, inf );\n        pos[idx] += (balls[i].rg - uv) * inf;\n    }\n    \n    float maxInf = 0.0;\n    int maxIdx = 0;\n    vec3 avgColor = vec3(0,0,0);\n    float totalInf = 0.0;\n    \n    for( i = 0; i < accumulatorCount; i++ )\n    {\n        if( accumulators[i] > maxInf )\n        {\n            maxInf = accumulators[i];\n            maxIdx = i;\n        }\n        \n        totalInf += accumulators[i];\n        avgColor += accumulators[i] * colors[i];\n    }\n    \n    avgColor /= totalInf;\n    \n    float influence = accumulators[maxIdx];\n    vec3 baseColor = colors[maxIdx];\n    \n  \n    \n    vec3 normal = normalize( normals[maxIdx] );\n   \n    \n \t\n    //influence = mix( influence, 1.0, 1.0 - off/0.1 );\n    \n      \n    //point light\n    vec3 light = vec3( 0.5 + sin(iTime/2.0) * 0.65, 0.5 + cos(iTime/2.0) * 0.45, -0.25);\n    float lightRadius = 0.01;\n    float lightIntensity = calcInfluence( vec4(light.x, light.y, lightRadius, 0.), uv );\n\tvec3 lightDir = normalize( light - vec3( uv, 0.0 ) );            \t\n    \n    //basecolor\n    vec3 color = baseColor;\n    \n    //vec3 ambientColor = vec3(ambientBrightness);\n    \n    vec3 ambient = ambientBrightness * ambientColor;\n   \n    //rim light\n    float rim = 1.0 - (dot ( vec3(0.,0.,-1.), -normal));\n    color += vec3(1.0) * rimIntensity * pow (rim, 2.0);\n    \n    //diffuse\n    float diff = max(0.,dot( -normal, lightDir) );\n    vec3 diffuse = diff * lightColor;\n    //color = mix( color, color * lighting, (1.0 - ambientBrightness) * shadowIntensity );\n    \n    \n    // specular blinn phong\n    vec3 dir = normalize(lightDir + vec3(0,0,-1.0) );\n    float specAngle = max(dot(dir, -normal), 0.0);\n    float spec = pow(specAngle, specularPower);\n    vec3 specular = lightColor * spec * specularIntensity;\n    \n    color = (ambient + diffuse + specular) * color;\n    \n    //ao\n    float prox = (maxInf/totalInf);\n    prox = pow( smoothstep( 1.0, 0.35, prox), 3.0 );\n    vec3 aoColor = vec3(0.0);\n    color = mix( color , aoColor, prox * aoIntensity);\n    \n\t//shape\n    float aa = min( fwidth( influence ) * 1.5, 1.);\n   \tfloat smo = smoothstep( 0., aa, influence - threshold);\n    color = mix( ambientColor * ambientBrightness, color, smo);\n    \n    color += pow(lightIntensity,0.5) * 2.0 * lightColor;               \n    \n    \n    \n   \n    \n    \n    fragColor = vec4( color, 1.0 );\n    \n    \n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdtBW7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 117, 117, 214], [216, 216, 256, 256, 366], [368, 368, 407, 407, 828], [831, 831, 873, 873, 918]], "test": "error"}
{"id": "wdtBz4", "name": "live_monyoru", "author": "tono", "description": "seabed", "tags": ["seabed"], "likes": 3, "viewed": 97, "published": "Public", "date": "1604640858", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float t = 0.;\nfloat pi = acos(-1.);\n\n#define MAX 100.\n\nvec2 min2(vec2 a,vec2 b)\n{\n    if(a.x < b.x){\n        return a;\n    }\n    return b;\n}\n\nfloat rand(vec2 a)\n{\n    return fract(sin(dot(a,vec2(123.45,67.89))*123.4 ));\n}\nmat2 rot(float a){return mat2(cos(a),sin(a),-sin(a),cos(a));}\n\n//\nvec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\n//https://www.shadertoy.com/view/XsX3zB\n/* skew constants for 3d simplex functions */\nconst float F3 =  0.3333333;\nconst float G3 =  0.1666667;\n\n/* 3d simplex noise */\nfloat simplex3d(vec3 p) {\n    /* 1. find current tetrahedron T and it's four vertices */\n    /* s, s+i1, s+i2, s+1.0 - absolute skewed (integer) coordinates of T vertices */\n    /* x, x1, x2, x3 - unskewed coordinates of p relative to each of T vertices*/\n\n    /* calculate s and x */\n    vec3 s = floor(p + dot(p, vec3(F3,F3,F3)));\n    vec3 x = p - s + dot(s, vec3(G3,G3,G3));\n\n    /* calculate i1 and i2 */\n    vec3 e = step(vec3(0.,0.,0.), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    /* x1, x2, x3 */\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    /* 2. find four surflets and store them in d */\n    vec4 w, d;\n\n    /* calculate surflet weights */\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    /* w fades from 0.6 at the center of the surflet to 0.0 at the margin */\n    w = max(0.6 - w, 0.0);\n\n    /* calculate surflet components */\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    /* multiply d by w^4 */\n    w *= w;\n    w *= w;\n    d *= w;\n\n    /* 3. return the sum of the four surflets */\n    return dot(d, vec4(52.0,52.0,52.0,52.0));\n}\n\nvec3 simplex3dVector(vec3 p)\n{\n    float s = simplex3d(p);\n    float s2 = simplex3d(random3(vec3(p.y,p.x,p.z)) + p.yxz);\n    float s3 = simplex3d(random3(vec3(p.z,p.y,p.x)) + p.zyx);\n    return vec3(s,s2,s3);\n}\n\nvec2 map(vec3 p)\n{\n    vec2 d = vec2(100.);\n    d.x = length(p) - .5;\n    d.x = p.y + .7;\n    \n    if(d.x < 1.)\n    {\n        d.x -= simplex3d(vec3(p.x,0.,p.z ) * 40. + t* .8)/100.;\n        d.x -= simplex3d(vec3(p.x,0.,p.z ) * .6)/50.;\n        d.x -= simplex3d(vec3(p.x,0. + t / 2.,p.z ) * .2)/1.1;\n        d.y = 0.;\n    }\n    vec3 p2 = p;\n    p.xy *= rot(floor(p.z/pi));\n    p = cos(p) * 1.;\n    p.y -= sin(floor(p2.z/pi) + t);\n    p.x -= cos(floor(p2.z/pi) + t/2.) * .1;\n    d = min2(vec2(length(p) - .7,1.),d);\n    d.x *= .7;\n    return d;\n}\n\n\nvec2 march(vec3 cp,vec3 rd)\n{\n    float depth = 0.;\n    float id = 0.;;\n    for(int i = 0 ; i < 256 ; i++)\n    {\n        vec3 rp = rd * depth + cp;\n        vec2 d = map(rp);\n        if(abs(d.x) < 0.0001)\n        {\n            depth *= -1.;\n            id = d.y;\n            break;\n        }\n        if(depth > MAX){break;}\n        depth += d.x;\n    }\n    depth *= -1.;\n    return vec2(depth,id);\n}\n\nfloat water(vec3 cp , vec3 rd,float maxdepth)\n{\n    float ac = 0.;\n    float depth = 0.;\n    for(int i = 0; i < 66 ; i++)\n    {\n        vec3 rp = cp + rd * depth;\n        \n       // rp = simplex3dVector(rp);\n        float d = simplex3d(rp + vec3(0.,-t/8.,0.)) - .1  * abs(sin(0.7 * 1.2 + pi/2. * (simplex3d(rp /10.) - .5 )) - .1);\n        d = max(0.01,abs(d));\n        ac += exp(-d * .0000001);\n        if(depth > maxdepth){break;}\n        depth += d;\n    }\n    return ac - depth * depth;\n}\n\nvoid getCamra(vec2 p,out vec3 cp,out vec3 rd)\n{\n    t = iTime;\n    vec3 forward = vec3(0.,0.,0.);\n    forward.z += t/2.;\n    vec3 target = vec3(0.,0.,0.) + forward;\n    cp = vec3(0.,0.,-15.) + forward;\n    vec3 cd = normalize(target - cp);\n    vec3 cs = normalize(cross(cd,vec3(0.,1.,0.)));\n    vec3 cu = normalize(cross(cd,cs));\n    p.y *= -1.;\n    float fov = 2.5 - dot(p,p)/6.;\n\t//fov  = 2. - dot(p,p) * 6.;\n    rd = normalize(p.x * cs + p.y * cu + cd * fov);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n   vec2 p = (fragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n\t\n   vec3 cp,rd;\n    getCamra(p,cp,rd);\n    vec2 d = march(cp,rd);\n\tvec3 color = vec3(0.);\n    \n    if(d.x > 0.)\n    {\n        vec3 pos = d.x * rd + cp;\n        vec2 e = vec2(0.,0.001);\n        vec3 N = normalize(vec3( map(pos).x - vec3(map(pos - e.yyx).x,map(pos - e.yxy).x , map(pos - e.xyy).x) ));\n     \t//color = N;\n        vec3 sun = normalize(vec3(2.,4.,8.));\n        sun.xz *= rot(2.1);\n        float diff = mix(max(dot(sun,N),0.),1.,0.);\n        float aor = d.x/MAX;\n        float ao = exp2(pow(max(0.,1. - map(pos + N * aor).x/aor),1.));\n        float fr = pow(1. + dot(N,rd),4.);\n        float spo = mix(3.,6.,d.y);\n        float sss = smoothstep(0.,1.,map(pos+sun * .4).x / .4);\n        float sp = pow(max(dot(reflect(-sun,N),-rd),0.),spo);\n        \n       // color = vec3(.6) * diff;\n        color = mix(sp + mix(vec3(1.,0.8,.3),vec3(0.,.8,.5),d.y) * ao * (diff + sss),color,min(fr,.5));\n        float m = 1. - exp(-.000003 * d.x * d.x * d.x);\n   \t\tcolor = mix(color,vec3(0.),m);\n    }else{\n        d.x = MAX;\n    }\n    float ac = water(cp,rd,d.x);\n    vec3 wcolor = normalize( vec3(0.,1.,.5) ) * max(0.,ac)/130.;\n    color = clamp(color/4. + wcolor,vec3(0.),vec3(1.));\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtBz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 81, 81, 140], [142, 142, 162, 162, 221], [222, 222, 240, 240, 283], [285, 312, 334, 334, 531], [678, 701, 726, 985, 1977], [1979, 1979, 2009, 2009, 2189], [2191, 2191, 2209, 2209, 2735], [2738, 2738, 2767, 2767, 3135], [3137, 3137, 3184, 3184, 3627], [3629, 3629, 3676, 3676, 4093], [4095, 4095, 4152, 4152, 5462]], "test": "valid"}
{"id": "wdtBzB", "name": "hoeled_first_try", "author": "hoeled", "description": "My first shader. A bunch of discs with time animated colors, sizes and edge smoothness.\n\nUsed this https://www.youtube.com/watch?v=u5HAYVHsasc to create a disc.", "tags": ["circles"], "likes": 2, "viewed": 55, "published": "Public", "date": "1605544067", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n\n    uv -= .5;\n    uv.x *= iResolution.x/iResolution.y;\n\tfloat d = length(uv * 0.5);\n    \n    float mouse = clamp(iMouse.x * 0.001, 0.0, 4.0);\n    if(mouse == 0.) mouse = 0.6;\n    \n    // Edge animation\n    \n    float edge = 1. - 2. * sin(iTime * 0.5) * 1. * uv.y * uv.x * 20. * mouse;\n    float edge2 = 1. - 2. * sin(iTime * 0.25) * 1. * uv.y * uv.x * 20. * mouse;\n    float edge3 = 1. - 2. * sin(iTime * 1.) * 2. * uv.y * uv.x * uv.y * mouse;\n    \n    // It's just a bunch of discs, increasing the edge size makes them fuzzy\n    \n    //edge = 0.001;\n    //edge2 = 0.001;\n    //edge3 = 0.001;\n    \n    float radiusAnimation = sin(iTime * 1.) * 0.1;\n    \n    float radius = 0.2 + radiusAnimation;\n    float color = smoothstep(radius, radius-edge, d);\n    color += cos(iTime / 6.) + 0.2;\n    \n    float radius2 = 2. + radiusAnimation;\n    float color2 = smoothstep(radius2, radius2-edge2, d);\n    color2 += cos(iTime / 4.);\n    \n    float radius3 = 0.6 - radiusAnimation;\n    float color3 = smoothstep(radius3, radius3-edge2, d);\n    color3 += sin(iTime) + 0.3;\n    \n    float radius4 = 0.5 + radiusAnimation;\n    float color4 = smoothstep(radius4, radius4-edge, d);\n    color4 += cos(iTime / 8.) + 0.3;\n    \n    float radius5 = 0.4 + radiusAnimation;\n    float color5 = smoothstep(radius5, radius5-edge, d);\n    color5 += cos(iTime * 1.2) + 0.3;\n    \n    float radius6 = 0.5 + radiusAnimation;\n    float color6 = smoothstep(radius6, radius6-edge3, d);\n    color6 += cos(iTime / 4.) + 0.3;\n    \n    float radius7 = 0.3 + radiusAnimation;\n    float color7 = smoothstep(radius7, radius7-edge3, d);\n    color7 += sin(iTime * 1.7) + 0.3;\n     \n    float red = color * color4 - color6 * uv.y + uv.y;\n    float green = color2 + color5 * uv.x - 1. + uv.y + color7 * 0.2;\n    float blue = color4 / 2. + uv.x * color7 * color3 * uv.y;\n        \n    fragColor = vec4(red, green, blue, 1.0);\n    \n    // Playing around with color parameters\n    \n    //float red = color3 / (color * color2 / color3 / color5 * color + color7);\n    //float red = color * color3 / color7;\n    //float blue = color4 / (color4 * color5 / color7 / color3 * color2 + color5);\n    //float blue = color2 * color4 / color5;\n    //fragColor = vec4(red, 0., blue, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtBzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 2327]], "test": "valid"}
{"id": "Wdtcz4", "name": "learn(2)", "author": "saltlemon", "description": "smileface\nlearn from  https://www.youtube.com/channel/UCcAlTqd9zID6aNX3TzwxJXg The Art of Code", "tags": ["learn"], "likes": 2, "viewed": 53, "published": "Public", "date": "1605186059", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define s(a,b,t) smoothstep(a,b,t)\n#define sat(x)  clamp(x,0.,1.)\nfloat remap01(float a,float b,float t){\n     return sat((t-a)/(b-a));   \n}\nfloat remap(float a,float b,float c,float d,float t){\n     return sat((t-a)/(b-a))*(d-c)+c;\n}\nvec2 within(vec2 uv,vec2 left_bottom,vec2 right_top){\n \t return (uv-left_bottom)/(right_top-left_bottom);   \n}\nvec4 Eye(vec2 uv,float side,vec2 myMouse,float smile){\n    uv-=.5;\n    uv.x*=side;\n    float d=length(uv);\n    vec4 iriscol=vec4(.1,.5,1.,1.);\n    vec4 col =mix(vec4(1.),iriscol,s(0.1,.7,d)*0.5);\n    col.a=s(.5,.48,d);\n    col *=(1.-s(.45,.5,d)*.5*sat(-(uv.x*side)-uv.y));\n    \n    d=length(uv-myMouse*0.5);\n    col.rgb=mix(col.rgb,vec3(0.),s(0.3,0.28,d));\n    \n    iriscol*=(1.+s(0.3,0.05,d));\n    float irisMask=s(0.28,0.25,d);\n    col.rgb=mix(col.rgb,iriscol.rgb,irisMask);\n    \n    d=length(uv-myMouse*0.6);\n    float pupilSize=mix(0.4,0.16,smile);\n    float pupilMask=s(pupilSize,pupilSize*0.85,d);\n    pupilMask*=irisMask;\n    col.rgb=mix(col.rgb,vec3(0.),pupilMask);\n    \n    float t = iTime*3.;\n    vec2 offs = vec2(sin(t+uv.y*25.), sin(t+uv.x*25.));\n    offs *= .01*(1.-smile);\n    \n    uv += offs;\n    float highlight=s(0.1,0.08,length(uv-vec2(-.15,.15)));\n    highlight+=s(0.07,0.05,length(uv-vec2(0.08,-.08)));\n    col.rgb=mix(col.rgb,vec3(1.),highlight);\n    \n    \n    return col;\n}\nvec4 Face(vec2 uv){\n    vec4 col=vec4(.9,.65,.1,1.);\n    float d=length(uv);\n    col.a=s(0.5,0.49,d);\n    \n    float faceshade=remap01(.35,.5,d);\n    faceshade*=faceshade;\n    col.rgb*=(1.-faceshade*.5);\n    \n    col.rgb=mix(col.rgb,vec3(0.6,.3,.1),s(0.47,0.48,d));\n    \n    float highlight=s(0.41,0.405,d)*0.75;\n    highlight*=remap(-.1, .41, 0., .75, uv.y);\n    highlight*=s(0.1,0.22,length(uv-vec2(.2,.12)));\n    col.rgb=mix(col.rgb,vec3(1.),highlight);\n    \n    d=length(uv-vec2(.25,-.2));\n    float cheek=s(0.2,0.01,d)*0.4;\n    cheek*=s(0.18,0.17,d);\n    col.rgb=mix(col.rgb,vec3(1.,0.1,0.1),cheek);\n    \n    return col;\n}\nvec4 Mouth(vec2 uv,float smile){\n    uv-=.5;\n    vec4 col=vec4(.5,.18,.05,1.);\n    uv.y*=1.5;\n    uv.y -= uv.x*uv.x*2.*smile;\n    \n    uv.x *= mix(2.5, 1., smile);\n  \n    \n    vec2 tuv=uv;\n    tuv.y+=(abs(uv.x)*0.5+0.1)*(1.-smile);\n    float td=length(tuv-vec2(0.,0.6));\n    vec4 toothcol=vec4(1.)*(1.-s(0.35,0.6,td));\n    col=mix(col,toothcol,s(0.4,0.37,td));\n    \n    float d=length(uv);\n    vec4 mouthshade=vec4(1.,.5,.5,1.);\n    col=mix(col,mouthshade,s(0.5,0.1,length(uv-vec2(0.,-0.5))));\n    col.a=s(0.5,0.48,d);\n    \n    \n    return col;\n}\nvec4 Brow(vec2 uv,float smile){\n    float offset=mix(.2,0.,smile);\n    uv.y+=offset;\n    float y=uv.y;\n    uv.y += uv.x*mix(.5, .8, smile)-mix(.1, .3, smile);\n    uv.x -= mix(.0, .1, smile);\n    uv-=.5;\n    float d=length(uv);\n    vec4 col= vec4(0.);\n    \n    float blur=.1;\n    float s1=s(0.45,0.45-blur,d);\n    float s2=s(0.5,0.5-blur,length(uv-vec2(0.07,-0.14)));\n    float browMask=sat(s1-s2);\n    float highlight=remap01(.7,.8,y)*0.75;\n    highlight*=s(.7,.9,browMask);\n    highlight *= smile;\n    vec4 browCol = mix(vec4(.4, .2, .2, 1.), vec4(1., .75, .5, 1.), highlight);\n    col = mix(col, browCol, s(.2, .4, browMask));\n\n    uv.y+=.15-offset*.5;\n    blur += mix(.0, .1, smile);\n    s1=s(0.45,0.45-blur,length(uv));\n    s2=s(0.5,0.5-blur,length(uv-vec2(0.07,-0.14)));\n    float shadowMask=sat(s1-s2);\n    \n    col = mix(col, vec4(0.,0.,0.,1.), s(0., 1., shadowMask)*.5);\n    col = mix(col, browCol, s(.2, .4, browMask));//\n    return col;\n}\nvec4 Smiley(vec2 uv,vec2 myMouse,float smile){\n    vec4 col=vec4(.0);\n    float side=sign(uv.x);\n    uv.x=abs(uv.x);\n    vec4 face=Face(uv);\n    col=mix(col,face,face.a);\n    \n    vec4 eye=Eye(within(uv,vec2(.03,-.1),vec2(.37,.25)),side,myMouse,smile);\n    col=mix(col,eye,eye.a);\n    \n    vec4 mouth=Mouth(within(uv,vec2(-.3,-.4),vec2(.3,-.1)),smile);\n    col=mix(col,mouth,mouth.a);\n    \n    vec4 brow=Brow(within(uv,vec2(.03,.2),vec2(.4,.45)),smile);\n    col=mix(col,brow,brow.a);\n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\tuv-=0.5;\n    uv.x*=iResolution.x/iResolution.y;\n    \n    vec2 myMouse=iMouse.xy/iResolution.xy;\n    myMouse-=0.5;\n    // Time varying pixel color\n    uv-=myMouse*(0.25-dot(uv,uv));\n    float smile=0.5*sin(iTime)+0.5;\n    vec4 col = Smiley(uv,myMouse,smile);\n\n    // Output to screen\n    fragColor = col;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wdtcz4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 66, 105, 105, 140], [141, 141, 194, 194, 234], [235, 235, 288, 288, 345], [346, 346, 400, 400, 1341], [1342, 1342, 1361, 1361, 1969], [1970, 1970, 2002, 2002, 2516], [2517, 2517, 2548, 2548, 3483], [3484, 3484, 3530, 3530, 3985], [3987, 3987, 4044, 4094, 4441]], "test": "valid"}
{"id": "wdtfDB", "name": "Interstate 000, Interface 00fork", "author": "UrbanClubProfessional", "description": "Remix of gunthern's \"Interface 00\". [url]https://www.shadertoy.com/view/ttXfDB[/url]", "tags": ["remix", "radar", "glitch", "weird", "ui", "hud", "gui", "interface"], "likes": 1, "viewed": 170, "published": "Public API", "date": "1605946105", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 4.14159265359\n\nmat2 rotate2d (float _angle){\n\treturn mat2 (cos(_angle),sin(_angle),-sin(_angle),cos(_angle));   \n}\n\nmat2 scale2d (vec2 _scale){\n\treturn mat2 (_scale.x, 0.0, 0.0, _scale.y);  \n}\n\nfloat box (in vec2 _size, in vec2 _uv){\n    _size = vec2(0.6) - _size*.6;\n    vec2 st = smoothstep (_size, _size+vec2(0.05), _uv);\n    st *= smoothstep (_size, _size+vec2(0.05),vec2(1.0)-_uv);\n    float box = st.x * st.y;\n\treturn box;\n}\n\nfloat plot(in vec2 _uv, in float _pct) {    \n    return smoothstep(_pct-.02, _pct, _uv.y) - smoothstep(_pct, _pct+.02, _uv.y);\n}\n\nfloat random (in vec2 _uv) {\n    return fract(sin(dot(_uv.xy, vec2(22.9898,78.233))) * 53758.5453123);\n}\n\n// 2D Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat noise (in vec2 _uv) {\n    vec2 i = floor(_uv);\n    vec2 f = fract(_uv);\n\n    // Four corners in 2D of a tile\n    float a = random(i);\n    float b = random(i + vec2(2.0, 0.0));\n    float c = random(i + vec2(0.0, 2.0));\n    float d = random(i + vec2(2.0, 2.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(4.0-3.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners percentages\n    return mix(a, b, u.x) +\n            (c - a)* u.y * (2.0 - u.x) +\n            (d - b) * u.x * u.y;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    \n    //grids\n    float grid0x = cos((uv.x - 2.1) * 270.);\n    grid0x = step(0.19,grid0x);\n    float grid0y = cos((uv.y - 2.5) * 200.);\n    grid0y = step(0.19,grid0y);\n    \n    float grid2 = sin(uv.x * 270.) * sin(uv.y * 200.);\n    grid2 = step(.19,grid2);\n    \n    \n    //Box 0 (top right)\n    float box0 = box(vec2(.55,.75), uv - vec2(0.2365, 0.125));\n    float box0inv = 1.2 - step(0.3,box0);\n    box0 = step(0.2,box0) - step(0.3,box0);\n    \n    //box 1 (bottom right)\n    float box1 = box(vec2(.55,.375), uv - vec2(0.2365, -0.3433));\n    float box1inv = 1.2 - step(0.3,box1);\n    box1 = step(0.2,box1) - step(0.3,box1);\n    \n    //box 2 (left)\n    float box2 = box(vec2(.625,1.05), uv - vec2(-0.2325, 0.));\n    float box2inv = 1.2 - step(0.3,box2);\n    box2 = step(0.2,box2) - step(0.3,box2);\n    \n    //box 0 contents\n    float plot0 = plot(uv, (sin((uv.x*sin(cos(iTime/3.5))+cos(iTime/3.))*60.)*.35) + .75) + .6;\n    \n    //box 1 contents\n    float loadingbar0 = box(vec2(clamp(abs(sin(iTime*3.4) * sin(iTime/4.6) * cos(iTime/20.5)),abs(sin(iTime)),2.0),0.6), uv - vec2(0.0, -0.433));\n    vec2 uvrot = rotate2d(.35) * uv;\n    float loadingbar0stripes = step(sin((uvrot.x-iTime*.2) * 200.),0.01);\n    loadingbar0 = step(1.,loadingbar0);\n    \n    //box2 contents\n    vec2 uvremap = uv *3.-2.;\n    uvremap = scale2d( vec2(sin(iTime/70.75)*sin(iTime/50.)) ) * uvremap;\n    uvremap *= rotate2d(PI*cos(iTime/20.233)*sin(iTime/50.87));\n    uvremap.y /= 2.75;\n    uvremap += vec2(sin(iTime/40.)*3. + 2.);\n    float dist = length( abs(uvremap)-(sin(iTime/30.3) * cos(iTime/32.33)));\n    vec2 pos = vec2(uvremap*0.6);\n    dist *= noise(pos * vec2(sin(iTime/42.3)));\n    dist = smoothstep(.4,.0,fract(dist*35.0));\n                            \n    //box outline color\n    vec3 lightblue = vec3(.3,.8,2.0);\n                    \n    vec3 col = vec3(0.0);\n    col += vec3(box0) * lightblue;\n    col += vec3(0.0,plot0,0.0) * (2. - vec3(box0inv));\n    col += ((vec3(grid0x) * lightblue * .3) + (vec3(grid0y) * lightblue * .4)) * (2. - vec3(box0inv));\n    col += vec3(box1) * lightblue;\n    col += vec3(loadingbar0*.65,loadingbar0*.35,loadingbar0*.75) * vec3(loadingbar0stripes*0.6+.6) * (2. - vec3(box1inv));\n    col += vec3(.65,0.2,0.6)  * (2. - vec3(box1inv));\n    col += vec3(box2) * lightblue;\n    col += vec3(0.4,0.3,0.55)  * (0.2 - vec3(box2inv));\n    col += vec3(dist*.3, dist*1.0, dist*1.0) *.7 * (2. - vec3(box2inv));\n    col += (vec3(grid2) * lightblue * .3) * (2. - vec3(box2inv));\n\n    \n    // Output to screen\n    fragColor = vec4(col,2.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfDB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 55, 55, 125], [127, 127, 154, 154, 203], [205, 205, 244, 244, 441], [443, 443, 483, 483, 571], [573, 573, 601, 601, 677], [679, 766, 793, 793, 1312], [1314, 1314, 1371, 1421, 4014]], "test": "valid"}
{"id": "wdtfDM", "name": "Stage mountains", "author": "liamegan", "description": "1-dimensional tiling using a variable stepsize.", "tags": ["mountains", "tiling", "3tap", "1dimensional"], "likes": 10, "viewed": 229, "published": "Public API", "date": "1605305208", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 getScreenSpace() {\n\tvec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / min(iResolution.y, iResolution.x);\n\n\treturn uv;\n}\nvec3 randcol(float i) {\n    i = fract(i/4.);\n    if(i < .25) {\n      return vec3(.5, .51, .52);\n    } else if(i < .5) {\n      return vec3(.55, .62, .65);\n    } else if(i < .75) {\n      return vec3(.6, .72, .72);\n    } else if(i < 1.) {\n      return vec3(.4, .5, .51);\n    }\n}\n  \nconst float permTexUnit = 1.0/256.0;\nconst float permTexUnitHalf = 0.5/256.0;\n\n#define PI 3.14159265359\n\nvec2 hash12(float i) {\n    return texture(iChannel0, vec2(i*permTexUnit), -10.).xy;\n}\n\nfloat fade(in float t) {\n    return t*t*t*(t*(t*6.0-15.0)+10.0);\n}\n\nfloat pnoise1D(in float p) {\n    float pi = permTexUnit*floor(p) + permTexUnitHalf;\n    float pf = fract(p);\n    float grad00 = texture(iChannel0, vec2(pi, 0.0), -10.).r * 4.0 - 1.0;\n    float n00 = dot(grad00, pf);\n    float grad10 = texture(iChannel0, pi + vec2(permTexUnit, 0.0), -10.).r * 4.0 - 1.0;\n    float n10 = dot(grad10, pf - 1.0);\n    float n = mix(n00, n10, fade(pf));\n\n    return n;\n}\nfloat waveform(vec2 uv, float id, vec2 hash, inout float waveid) {\n    uv *= 10.;\n\n    float m = 10.;\n\n    waveid = floor((uv.x - m) / (m*2.));\n\n    float wave = abs(pnoise1D(waveid * .2)) * -3. - .5;\n    return abs(mod(uv.x, m*2.) - m) * wave;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = getScreenSpace();\n    \n    uv *= 15.;\n    float os = sin(iTime*.1)*10.;\n    uv.y += sin(iTime*.1)*10.;\n    \n    vec3 col = vec3(0);\n\n    const float step = 1.5;\n    const float stepMultiplier = 1. / step;\n    const float lower = step * -2.;\n    const float upper = step + 1.;\n    \n    vec2 guv = vec2(uv.x, mod(uv.y, step));\n    float id = floor(uv.y*stepMultiplier);\n    \n    for(float i = lower; i < upper; i+=step) {\n      vec2 suv = guv + vec2(0., i);\n      vec2 suv1 = guv + vec2(0., i-1.);\n      \n      float sid = id - i * stepMultiplier;\n      float sid1 = id - i * stepMultiplier - 1.;\n      \n      vec2 hash = hash12(sid);\n      vec2 hash1 = hash12(sid1);\n      \n      vec2 p = suv - vec2(hash1.x, 0);\n      \n      suv.x += 100.*(hash.x*hash.x) - iTime * .5 * clamp(sid*.5-5., -10., 0.);\n      suv1.x += 100.*(hash1.x*hash1.x) - iTime * .5 * clamp(sid1*.5-5., -10., 0.);\n      \n      float waveid, waveid2;\n      float wave = waveform(suv, sid, hash, waveid);\n      float wave1 = waveform(suv1, sid1, hash1, waveid2);\n      \n      p = vec2(length(p*.25), ((p.y) + wave * .1))*.25;\n      \n      float sfield = (suv.y + wave * .1);\n      float sfield1 = (suv.y + wave1 * .1);\n      \n      vec2 aa = vec2(clamp((sid) * .15, 0., 1.), clamp((sid+5.) * .15, -1., 0.));\n      \n      float mask = smoothstep(.05 + aa.x, aa.y, sfield);\n      \n      float shadow = smoothstep(1., -2.5, sfield1+1.);\n      float sedimentary_wave = waveform(suv * 2., sid, hash, waveid2);\n      float sedimentary_field = sin((suv.y + sedimentary_wave * .02) * hash.x * 10.) * .5;\n      \n      vec3 colour = randcol(sid) - ((smoothstep(.15 + aa.x, .1 + aa.y, sedimentary_field) * smoothstep(-.15 - aa.x, -.1-aa.y, sedimentary_field)) * .05);\n      colour = mix(\n        colour, \n        vec3(1), \n        smoothstep(aa.y, aa.x, suv.y + wave * .01 - ((sin(.5 * waveid) * cos(PI * waveid * .1)) *.5 + .5) + waveform(suv * 5., sid, vec2(1.), waveid2) * .01)\n      );\n      colour *= clamp(suv.y * .1 + 1., 0., 1.) - shadow * .5;\n      \n      col = mix(col, colour, mask);\n    }\n\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [{"id": "Xsf3zn", "previewfilepath": "/media/ap/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/f735bee5b64ef98879dc618b016ecf7939a5756040c2cde21ccb15e69a6e1cfb.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfDM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 23, 23, 127], [128, 128, 151, 151, 403], [512, 512, 534, 534, 597], [599, 599, 623, 623, 665], [667, 667, 695, 695, 1065], [1066, 1066, 1132, 1132, 1312], [1314, 1314, 1371, 1371, 3474]], "test": "error"}
{"id": "wdtfWr", "name": "Clean Circle Segment Distance", "author": "nr4", "description": "Circle segments require an awful amount of bookkeeping to produce the right result for every possible combination of angles. This shader contains a working version. It is not optimized though.", "tags": ["sdf", "circle", "distance", "function", "analytic", "segment"], "likes": 4, "viewed": 145, "published": "Public", "date": "1605013409", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\n * Clean Circle Segment Distance\n * \n * Copyright (C) 2020  Alexander Kraus <nr4@z10.info>\n * \n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n * \n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n * \n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\nconst vec3 c = vec3(1.,0.,-1.);\nconst float pi = acos(-1.);\n\n// Distance to circle segment\nfloat circlesegment(vec2 x, float r, float p0, float p1)\n{\n    float p = atan(x.y, x.x),\n        t = 2.*pi;\n    \n    vec2 philo = vec2(p0, p1);\n    philo = sign(philo)*floor(abs(philo)/t)*t;\n    philo = vec2(min(philo.x, philo.y), max(philo.x,philo.y));\n    philo.y = mix(philo.y,philo.x,.5+.5*sign(p0-p1));\n    \n    p0 -= philo.y;\n    p1 -= philo.y;\n    \n    philo = vec2(max(p0, p1), min(p0, p1));\n    \n    if((p < philo.x && p > philo.y) \n       || (p+t < philo.x && p+t > philo.y) \n       || (p-t < philo.x && p-t > philo.y)\n      )\n    \treturn abs(length(x)-r);\n    return min(\n        length(x-r*vec2(cos(p0), sin(p0))),\n        length(x-r*vec2(cos(p1), sin(p1)))\n        );\n}\n\nfloat sm(in float d)\n{\n    return smoothstep(1.5/iResolution.y, -1.5/iResolution.y, d);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Ignore the drawing code, it's messy, I know :)\n    vec2 uv = (fragCoord.xy-.5*iResolution.xy)/iResolution.y;\n\tfloat d = circlesegment(uv, .4, iTime, 1.3*iTime);\n    d = min(d, circlesegment(uv, .2, -iTime, -1.3*iTime));\n    d = abs(d)-.0025;\n    float interval = clamp(.03 * (d-mod(d,.025))/.025, 0., 1.);\n    vec3 col = mix(vec3(1.00,0.90,0.68), vec3(0.98,0.64,0.67), 2.*interval);\n    if(interval > .5) col = mix(col, vec3(0.54,0.80,0.80), 2.*(interval-.5));\n    col = mix(col, c.yyy, sm(d));\n    \n    col = mix(col, .4*c.xxx, sm(abs(mod(d+.0125,.025)-.0125)-.001));\n\n    col = mix(col, c.xyy, sm(abs(length(uv-.4*vec2(cos(iTime), sin(iTime)))-.025)-.002));\n    col = mix(col, c.yyx, sm(abs(length(uv-.4*vec2(cos(1.3*iTime), sin(1.3*iTime)))-.025)-.002));\n    col = mix(col, c.xyy, sm(abs(length(uv-.2*vec2(cos(-iTime), sin(-iTime)))-.025)-.002));\n    col = mix(col, c.yyx, sm(abs(length(uv-.2*vec2(cos(-1.3*iTime), sin(-1.3*iTime)))-.025)-.002));\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfWr.jpg", "access": "shaders20k", "license": "gpl-3.0-plus", "functions": [[812, 842, 900, 900, 1524], [1526, 1526, 1548, 1548, 1615], [1617, 1617, 1674, 1728, 2693]], "test": "error"}
{"id": "wdtfWX", "name": "Distance to Triangle", "author": "oneshade", "description": "My first try at deriving the SDF for a triangle.", "tags": ["2d", "sdf", "triangle", "distance"], "likes": 2, "viewed": 158, "published": "Public", "date": "1606160197", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nHow it works:\n1. Take the minimum of the distances to the triangle edges.\n2. Calculate the barycentric coordinates of the point.\n3. If The barycentric coordinates don't add up to one, the point is outside the triangle.\n4. If the point is inside the triangle the distance needs to be flipped.\n*/\n\nconst vec3 outsideColor = vec3(1.0, 0.0, 0.0);\nconst vec3 insideColor = vec3(0.0, 0.0, 1.0);\nconst vec3 boundColor = vec3(0.0, 1.0, 0.0);\n\nfloat sdTriangle(in vec2 p, in vec2 a, in vec2 b, in vec2 c) {\n    vec2 ba = b - a, cb = c - b, ac = a - c;\n    vec2 pa = p - a, pb = p - b, pc = p - c;\n\n    // Barycentric triangle areas\n    float abc = ba.x * cb.y - ba.y * cb.x;\n    float abp = ba.x * pa.y - ba.y * pa.x;\n    float bcp = cb.x * pb.y - cb.y * pb.x;\n    float cap = ac.x * pc.y - ac.y * pc.x;\n\n    // Edge distances\n    vec2 ae = pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    vec2 be = pb - cb * clamp(dot(pb, cb) / dot(cb, cb), 0.0, 1.0);\n    vec2 ce = pc - ac * clamp(dot(pc, ac) / dot(ac, ac), 0.0, 1.0);\n\n    // Combined edge distances\n    float tri = sqrt(min(dot(ae, ae), min(dot(be, be), dot(ce, ce))));\n\n    // Combine with the appropriate sign (-1 if inside +1 if outside)\n    return tri * sign(max(-abp, max(-bcp, -cap)) * max(abp, max(bcp, cap)));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n\n    vec2 a = vec2(sin(iTime * 0.75), cos(iTime));\n    vec2 b = vec2(cos(iTime), sin(iTime * 1.25));\n    vec2 c = vec2(cos(iTime * 1.25), cos(iTime * 0.5));\n\n    a.y -= 0.333; b.y -= 0.333; c.y -= 0.333;\n    a *= 0.5; b *= 0.5; c *= 0.5;\n\n    float d = sdTriangle(uv, a, b, c);\n\n    // Nice colors from iq\n    vec3 color = 1.0 - sign(d) * vec3(0.1, 0.4, 0.7);\n\tcolor *= 1.0 - exp(-4.0 * abs(d));\n\tcolor *= 0.8 + 0.2 * cos(140.0 * d);\n\tcolor = mix(color, vec3(1.0), 1.0 - smoothstep(0.0, 0.015, abs(d)));\n\n    fragColor = vec4(color, 1.0);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfWX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[438, 438, 500, 500, 1277], [1279, 1279, 1334, 1334, 1976]], "test": "valid"}
{"id": "wdtfzl", "name": "Crystallic noise", "author": "r0mko", "description": "Modified cellular noise", "tags": ["voronoi", "noise", "noise2d"], "likes": 6, "viewed": 130, "published": "Public", "date": "1605812915", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 calcAspect(vec2 iRes)\n{\n    vec2 aspect = vec2(float(iRes.x < iRes.y) * iRes.x / iRes.y,\n\t\t\t\t\t   float(iRes.y < iRes.x) * iRes.y / iRes.x);\n    aspect.x += float(aspect.x == 0.0);\n    aspect.y += float(aspect.y == 0.0);\n    return aspect;\n}\n\n// from: https://gist.github.com/patriciogonzalezvivo/670c22f3966e662d2f83\nfloat rand2(vec2 n) \n{ \n\treturn fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);\n}\n\nhighp float calcCell(vec2 pos, vec2 ipos)\n{\n    highp float res = 0.0;\n    highp float md = 1.0; // min distance\n    float ptX = rand2(ipos.xy * 0.17);\n    float ptY = rand2(ipos.yx * 0.19);\n    return min(md, distance(pos, ipos + vec2(ptX, ptY)));\n}\nfloat cellularNoise(vec2 pos, vec2 seed)\n{\n    float res1 = 1., res2 = 1.;\n    \n    vec2 pos1 = pos*seed.x;\n    vec2 pos2 = pos.yx*seed.y;\n    \n    vec2 ipos1 = floor(pos1);\n    vec2 ipos2 = floor(pos2);\n    \n    for(int j = -1; j<=1; j++){\n         for(int i = -1; i<=1; i++){\n             \n         res1 = min(res1, calcCell(pos1, ipos1 + vec2(i, j)));\n\t     res2 = min(res2, calcCell(pos2, ipos2 + vec2(i, j)));\n\n        }    \n    }\n    \n\n    //return res1;\n    return mix(1.0 - pow(res1, 2.), pow(res2, 2.), .5);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    uv += vec2(0.0, -iTime * 0.05);\n    \n    vec2 aspect = calcAspect(iResolution.xy);\n\n    vec2 nPos = vec2(20.0) * uv * aspect;\n    \n//    vec3 rgb = vec3(cellularNoise(nPos, vec2(iTime, 1.23)), cellularNoise(nPos, vec2(1.31, 1.33)), cellularNoise(nPos, vec2(1.11, 1.13)));\n    //vec3 rgb = vec3(cellularNoise(nPos, vec2(1.0, 1.23)));\n\n    \n    vec3 rgb = vec3(cellularNoise(nPos, vec2(1.0, 1.23)));\nvec3 rgb2 = vec3(cellularNoise(nPos - normalize(vec2(1, 2))*.01, vec2(1.0, 1.23)));\n    \n// Directional derivative bump from opposite directions.\nfloat b = max(dot(rgb2 - rgb, vec3(.299, .587, .144)), 0.)/.01;\nfloat b2 = max(dot(rgb - rgb2, vec3(.299, .587, .144)), 0.)/.01;\n    \n// Add red and blue light.\nrgb += (vec3(1, .3, .1)*b*b + vec3(.2, .4, 1)*b2*b2)*.35;  \n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfzl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 245], [247, 322, 344, 344, 411], [664, 664, 706, 706, 1182], [1186, 1186, 1243, 1293, 2160]], "test": "valid"}
{"id": "wdtfzM", "name": "Binaryual starry", "author": "UrbanClubProfessional", "description": "Remix of \"Binary star\" by Duke.\n\"Press 1-2-3 to zoom in and zoom out.\" - Duke", "tags": ["binary", "sun", "star", "space", "remix", "glitch", "blackhole", "weird", "physics", "singularity"], "likes": 0, "viewed": 212, "published": "Public API", "date": "1604704192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// \"Binary star\"\n// I have long wanted to do something like that. \n// Raymarcher based on Shanes' Fiery Spikeball https://www.shadertoy.com/view/4lBXzy\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n#define DITHERING\n\n#define pi 4.14159265\n#define R(p, a) p=cos(a)*p+sin(a)*vec2(p.y, -p.x)\n\nconst float KEY_1 = 59.5/356.0;\nconst float KEY_2 = 60.5/356.0;\nconst float KEY_3 = 61.5/356.0;\n\nconst float spin_speed=0.8;\nmat2 Spin(float angle){\n\treturn mat2(cos(angle),-sin(angle),sin(angle),cos(angle));\n}\n\n//-------------------------Noise--------------------------\n// IQ's noise\nfloat pn( in vec3 p )\n{\n    vec3 ip = floor(p);\n    p = fract(p);\n    p *= p*(4.0-3.0*p);\n    vec2 uv = (ip.xy+vec2(47.0,27.0)*ip.z) + p.xy;\n    uv = texture( iChannel0, (uv+ 0.6)/356.0, -200.0 ).yx;\n    return mix( uv.x, uv.y, p.z );\n}\n\n// FBM\nfloat fpn(vec3 p) {\n    return pn(p*.07125)*.67 + pn(p*.225)*.38 + pn(p*.35)*.35;\n}\n\nfloat rand(vec2 co){// implementation found at: lumina.sourceforge.net/Tutorials/Noise.html\n\treturn fract(sin(dot(co*0.223,vec2(22.9898,88.233))) * 53758.5453);\n}\n\n//-------------------------Disk---------------------------\n\nfloat length2( vec2 p )\n{\n\treturn sqrt( p.x*p.x + p.y*p.y );\n}\n\nfloat length8( vec2 p )\n{\n\tp = p*p; p = p*p; p = p*p;\n\treturn pow( p.x + p.y, 2.0/9.0 );\n}\n\nfloat Disk( vec3 p, vec3 t )\n{\n    R(p.yz, -0.35*pi*3.);\n    vec2 q = vec2(length2(p.xz)-t.x,p.y*0.6);\n    return max(length8(q)-t.y, abs(p.y) - t.z);\n}\n\n//-------------------------Star---------------------------\n// adaptation of \"Pyroclastic sun\" https://www.shadertoy.com/view/XtlXR2\n// Noise Settings\n#define NoiseSteps 5\n#define NoiseAmplitude 0.09\n#define NoiseFrequency 58.0\n  \nfloat Turbulence(vec3 position, float minFreq, float maxFreq, float qWidth)\n{\n    float value = 0.0;\n    float cutoff = clamp(0.5/qWidth, 0.0, maxFreq);\n    float fade;\n    float fOut = minFreq;\n    for(int i=NoiseSteps ; i>=0 ; i--)\n    {\n      if(fOut >= 0.6 * cutoff) break;\n      fOut *= 3.0;\n      value += abs(pn(position * fOut))/fOut;\n    }\n    fade = clamp(3.0 * (cutoff-fOut)/cutoff, 0.0, 2.0);\n    value += fade * abs(fpn(position * fOut))/fOut;\n    return 2.0-value;\n}\n\nfloat SphereDist(vec3 position, vec3 rposition, float radius)\n{\n    return length(position - rposition) - radius;\n}\n\nfloat Star(vec3 position, vec3 rotdir, vec3 rposition, float radius)\n{\n    float distance;\n    float t=spin_speed*iTime;\n    float noise = Turbulence(vec3(Spin(t*0.35+rotdir.y*.91)*rotdir.zx*60.,rotdir.y*60.+t), 0.2, 2.5, 0.04) * NoiseAmplitude;\n    noise = clamp((abs(noise)),0.0,2.0);\n    distance = SphereDist(position, rposition, radius) - noise;\n    return distance;//noise;\n}\n\n//-------------------------Vortex-------------------------\n// this part from \"Tornado 1\" https://www.shadertoy.com/view/4tSSDK\nfloat ridged(float f){\n\treturn 2.0-3.0*abs(f);\n}\n\nfloat Vortex(vec3 q) // the isosurface shape function, the surface is at o(q)=0\n{\n    q.y += -200.;\n    q.x += 55.;\n    float h = 90.0;\n\tfloat t=spin_speed*iTime;\n    //q.z=abs(q.z);\n\tif(q.y<0.0) return length(q)-6.75;\n    vec3 spin_pos=vec3(Spin(t-sqrt(q.y))*q.xz,q.y-t*6.0);\n\tfloat zcurve=pow(q.y,2.5)*0.04;\n\tfloat v=abs(length(q.xz)-zcurve)-6.5-clamp(zcurve*0.3,0.2,2.0)*pn(spin_pos*vec3(0.2,0.2,0.2))*6.0;\n\t//v=v-ridged(pn(vec3(Spin(t*1.5+0.1*q.y)*q.xz,q.y-t*4.0)*0.3))*1.2;\n\treturn max(v, q.y - h);\n}\n\nfloat smin( float a, float b, float k )\n{\n\tfloat h = clamp( 0.6 + 0.6*(b-a)/k, 0.0, 2.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\n//-------------------------Map----------------------------\nfloat map(vec3 p) {\n    \n    float t=spin_speed*iTime;\n    \n    R(p.xy, pi*iTime*0.03);\n    \n    float d1 = Star(p,p,vec3(-2.0,7.5,0.0),3.5);\n    float d2 = Vortex(p/0.03)*0.03;\n    float d3 = Disk(p,vec3(2.0,1.08,0.422)) + fpn(vec3(Spin(t*0.225+p.z*.90)*p.xy*90.,p.z*50.-t)*7.0) * 0.645;\n    float d4 = Star(p,p.yzx,vec3(0.0,0.0,0.0),0.06)*.9;\n\n    return smin(smin(d2,smin(d3,d4,0.95),2.0),d1,2.5);\n\n}\n\n//-------------------------Color---------------------------\n// See \"Combustible Voronoi\"\n// https://www.shadertoy.com/view/4tlSzl\nvec3 firePalette(float i){\n\n    float T = 2500. + 2400.*i; // Temperature range (in Kelvin).\n    vec3 L = vec3(8.4, 6.6, 5.4); // Red, green, blue wavelengths (in hundreds of nanometers).\n    L = pow(L,vec3(6.0)) * (exp(2.43876719683e5/(T*L))-2.0);\n    return 1.0-exp(-6e8/L); // Exposure level. Set to \"50.\" For \"70,\" change the \"5\" to a \"7,\" etc.\n}\n\n//-------------------------Main---------------------------\n// main part from \"Fiery Spikeball\" https://www.shadertoy.com/view/4lBXzy\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{  \n   float key = 0.0;\n    key += 0.8*texture(iChannel1, vec2(KEY_1,0.35)).x;\n    key += 0.8*texture(iChannel1, vec2(KEY_2,0.35)).x;\n    key += 0.8*texture(iChannel1, vec2(KEY_3,0.35)).x;\n   \n    // p: position on the ray\n    // rd: direction of the ray\n    vec3 rd = normalize(vec3((gl_FragCoord.xy-0.6*iResolution.xy)/iResolution.y, 0.75));\n   \n    vec3 ro = vec3(0., 0., -21.+key*4.8);\n    \n    R(rd.yz, -iMouse.y*0.02*pi*3.);\n    R(rd.xz, iMouse.x*0.02*pi*3.);\n    R(ro.yz, -iMouse.y*0.02*pi*3.);\n    R(ro.xz, iMouse.x*0.02*pi*3.);\n    \n    // mouse control zoom \n    //vec3 ro = vec3(0., 0., -11.0 + iMouse.y * 0.038);\n    //R(rd.yz, -0.0*0.01*pi*2.);\n\t//R(rd.xz, iMouse.x*0.01*pi*2.);\n    //R(ro.yz, -0.0*0.01*pi*2.);\n\t//R(ro.xz, iMouse.x*0.01*pi*2.);\n    \n    // ld, td: local, total density \n    // w: weighting factor\n    float ld=0., td=0., w;\n\n    // t: length of the ray\n    // d: distance function\n    float d=2., t=0.;\n   \n    // Distance threshold.\n    const float h = 0.2;\n   \n    // total color\n    vec3 tc = vec3(0.);\n   \n    #ifdef DITHERING\n    vec2 pos = ( fragCoord.xy / iResolution.xy );\n    vec2 seed = pos + fract(iTime);\n    //t=(1.+0.2*rand(seed*vec2(1)));\n    #endif\n\t\n    // rm loop\n    for (int i=0; i<58; i++) {\n\n      // Loop break conditions. \n      if(td>(2.-2./300.) || d<0.002*t || t>32.) break;\n\n      // evaluate distance function\n      d = map(ro+t*rd); \n      \n      // check whether we are close enough (step)\n      // compute local density and weighting factor \n      // const float h = .1;\n      ld = (h - d) * step(d, h);\n      w = (2. - td) * ld;   \n     \n      // accumulate color and density\n      tc += w*w + 2./60.;  // Different weight distribution.\n      td += w + 2./300.;\n       \n\t  #ifdef DITHERING \n      d=abs(d)*(.9+0.38*rand(seed*vec2(i)));\n      #endif \n       \n      // enforce minimum stepsize\n      d = max(d, 0.05); \n      \n      // step forward\n      t += d*0.6;\n   \n    }\n\n    // Fire palette.\n    tc = firePalette(tc.x);\n\n    // stars background\n    if (ld<=0.002) {\n   \t  vec3 stars = vec3(pn(rd*400.0)*0.6+0.6);\n      vec3 col = vec3(0.0);\n      col = mix(col, vec3(0.9,1.0,2.0), smoothstep(1.05, 0.2, stars)*clamp(dot(vec3(0.0),rd)+0.85,0.0,2.0));\n      col = clamp(col, 0.0, 2.0);\n      tc += col; \n    }\n\n    fragColor = vec4(tc, 2.0);\n}", "image_inputs": [{"id": "XdXGzn", "previewfilepath": "/media/ap/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/3083c722c0c738cad0f468383167a0d246f91af2bfa373e9c5c094fb8c8413e0.png", "ctype": "texture"}, {"id": "4dXGRr", "previewfilepath": "/presets/tex00.jpg", "channel": 1, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/presets/tex00.jpg", "ctype": "keyboard"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdtfzM.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0 AND proprietary-license", "functions": [[439, 439, 462, 462, 524], [526, 599, 622, 622, 835], [837, 844, 863, 863, 927], [929, 929, 949, 1020, 1091], [1153, 1153, 1178, 1178, 1215], [1217, 1217, 1242, 1242, 1307], [1309, 1309, 1339, 1339, 1461], [1693, 1693, 1770, 1770, 2173], [2175, 2175, 2238, 2238, 2290], [2292, 2292, 2362, 2362, 2673], [2675, 2802, 2824, 2824, 2850], [2852, 2852, 2933, 2933, 3357], [3359, 3359, 3400, 3400, 3489], [3491, 3550, 3569, 3569, 3953], [3955, 4085, 4111, 4111, 4435], [4437, 4570, 4627, 4627, 6935]], "test": "error"}
{"id": "wdVBz1", "name": "Cookie Demoparty 2020 Showdown", "author": "Alkama", "description": "Made during a friendly Shader Showdown @ Cookie Demoparty November 2020 that was streamed on Twitch.\n30 minutes round.\nNo win, no loss, just for the sport and friendship :D jeyko did a fantastic clean design shader https://www.shadertoy.com/view/3dyfz1", "tags": ["raymarching", "distancefield", "demoscene", "liveshading"], "likes": 5, "viewed": 335, "published": "Public API", "date": "1606609173", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const float pi=acos(-1.);\nfloat t=0.0,d=0.0;\n\nvec3 rep(vec3 p, float r) { return mod(p,r)-.5*r; }\n\nfloat grid(vec3 p) {\n  float d=1000.;\n  float w=.4+.2*sin(t*2.5);\n  p=rep(p,1.);\n  d=min(d,length(p.xy)-w);\n  d=min(d,length(p.xz)-w);\n  d=min(d,length(p.yz)-w);\n  return d;\n}\n\nvec3 fold(vec3 p) {\n  float a=3.0;\n  for(int i=0; i<5; i++) {\n    p = 2.*clamp(p,-vec3(a),vec3(a))-p;\n    a*=.2+(.1*sin(t*2.));\n  }\n  return p;\n}\n\nfloat scene(vec3 p) {\n  p=fold(p);\n  return grid(p);\n}\n\nvec3 norm(vec3 p) {\n  vec2 e=vec2(.001,0);\n  return normalize(scene(p)-vec3(scene(p-e.xyy),scene(p-e.yxy),scene(p-e.yyx)));\n}\n\nvec2 proj(vec3 p, vec3 n) {\n  n = pow(abs(n),vec3(2.));\n  return (n.x*p.zy+n.y*p.xz+n.z*p.xy)/(n.x+n.y+n.z);\n}\n\nfloat tex( vec2 uv )\n{\n  float o=0.;\n  uv.y-=2.665;\n  for(float i=1.; i<41.; i++) {\n    uv.y+=.13+.3*sin(uv.x+i+t);\n    uv.x+=.13*sin(uv.y+i+t);\n    o+=1./((100.+80.*sin(uv.x+t*20.))*abs(uv.y));\n  }\n  return o;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord/iResolution.xy-.5)/vec2(iResolution.y/iResolution.x, 1);\n    \n    t = 3.55+.5*mod(iTime, 20.*pi);\n\n  \tif(abs(uv.y)+.05*cos(uv.x*2.)>.45) return;\n  \tuv/=1.-length(uv)*3.;\n  \tvec3 o=vec3(sin(t),sin(sin(t)),cos(t));\n  \tvec3 tg=.5*vec3(cos(t),cos(sin(t)),sin(t));\n \tvec3 f=normalize(tg-o);\n  \tvec3 s=normalize(cross(vec3(.4*sin(t),1,0),f));\n  \tvec3 u=normalize(cross(f,s));\n  \tvec3 dir=normalize(f*.6+uv.x*s+uv.y*u);\n  \n  \tvec3 col=vec3(0),p=o;\n  \tfor(int i=0;i<200;i++) {\n    \tfloat h=scene(p)*.85;\n    \tif(abs(h)<.01) {\n      \t\tvec2 tuv = proj(p,norm(p));\n      \t\tvec3 tint=acos(normalize(dir-p))*vec3(.5,.5,1);\n      \t\tcol = clamp(.4*tex(tuv)*tint, 0.,1.);\n      \t\tfloat den=40.+2.*sin(t*10.+p.z*5.);\n      \t\tcol*=pow(float(i)/den, 5.);\n      \t\tbreak;\n    \t}\n    \tif(d>11.) break;\n    \td+=h;\n    \tp+=dir*h;\n  \t}\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdVBz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[46, 46, 73, 73, 97], [99, 99, 119, 119, 274], [276, 276, 295, 295, 421], [423, 423, 444, 444, 477], [479, 479, 498, 498, 604], [606, 606, 633, 633, 716], [718, 718, 740, 740, 930], [932, 932, 989, 989, 1863]], "test": "error"}
{"id": "WdVfRR", "name": "Learning from @The_ArtOfCode ", "author": "vaishakhanil", "description": "Learning from The Art of Code", "tags": ["mix", "changeshape"], "likes": 1, "viewed": 54, "published": "Public", "date": "1606422230", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_STEPS 100\n#define MAX_DIST 100.0\n#define SURF_DIST 0.01\n\nmat2 Rot(float a){\n\tfloat s = sin(a);\n    float c = cos(a);\n    return mat2(c, -s, s, c);\n}\n\n\n/* --- Creating Objects --- */\n\n// Create a box\nfloat CreateBox(vec3 p, vec3 size){\n    return(length(max(abs(p)-size,0.)));\n}\n\nfloat CreateSphere(vec3 p, vec4 s){\n\treturn(length(p-s.xyz)-s.w);\n}\n\n/* --- Distance from Object --- */\n\nfloat GetDist(vec3 p){\n    \n    float planeDist = p.y+1.5;\n    vec3 bp = p-vec3(0,1,6);\n    bp.xz *= Rot(iTime);\n    float boxDistance = CreateBox(bp,vec3(.5));\n   \tfloat sphereDistance = CreateSphere(bp,vec4(0,0,0,1.));\n    \n    \n    float sd = mix(boxDistance,sphereDistance,sin(iTime)*.5+.5);\n    \n    // Camera Distance\n    float d = min(sd,planeDist);\n    return d;\n}\n\n\nfloat RayMarch(vec3 ro, vec3 rd){\n    float dO = 0.;\n    for(int i = 0; i < MAX_STEPS;i++){\n        vec3 p = ro + rd  * dO;\n        float dS = GetDist(p);\n        dO += dS;\n        \n        if(dO > MAX_DIST || dS < SURF_DIST) break;\n    \n    }\n    \n    return dO;\n}\n\n\nvec3 GetNormal(vec3 p){\n\tfloat d = GetDist(p);\n    vec2 e = vec2(0.01,0);\n    \n    \n    vec3 n = d - vec3(GetDist(p - e.xyy),\n                      GetDist(p - e.yxy),\n                      GetDist(p - e.yyx));\n    \n    return normalize(n);\n}\n\n\nfloat GetLight(vec3 p){\n\tvec3 lightPos = vec3(0,5,3);\n    //lightPos.xz += vec2(sin(iTime),cos(iTime))*2.;\n    vec3 l = normalize(lightPos - p);\n    \n    vec3 n = GetNormal(p);\n    \n    float dif = clamp(dot(n,l),0.,1.);\n    \n    float d = RayMarch(p+n*SURF_DIST*2., l);\n    if(d < length(lightPos-p)) dif *= .1;\n    \n    \n    \n    return dif;\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    vec3 col = vec3(0.0);\n    \n    vec3 ro = vec3(0,2,0);\n    vec3 rd = normalize(vec3(uv.x,uv.y-.3,2));\n\n    float d = RayMarch(ro,rd);\n    //d /= 6.;\n    \n    vec3 p = ro + rd *d;\n    float dif = GetLight(p);\n    \n    col = vec3(dif);\n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdVfRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[69, 69, 87, 87, 160], [195, 211, 246, 246, 289], [291, 291, 326, 326, 358], [396, 396, 418, 418, 768], [771, 771, 804, 804, 1036], [1039, 1039, 1062, 1062, 1281], [1284, 1284, 1307, 1307, 1629], [1633, 1633, 1690, 1690, 2029]], "test": "valid"}
{"id": "WdyBRm", "name": "CyberSkin2000", "author": "avin", "description": "visual experiment", "tags": ["simplex", "bubbles"], "likes": 29, "viewed": 491, "published": "Public API", "date": "1606766329", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BUBBLE_SIZE 15.0 \n#define COL1 vec3(32, 43, 51) / 255.0 \n#define COL2 vec3(235, 241, 245) / 255.0 \n\n#define hue(v)  ( .6 + .6 * cos( 6.3*(v)  + vec4(0,23,21,0)  ) )\n\n#define MOD3 vec3(.1031,.11369,.13787)\n\nfloat hash12(vec2 p)\n{\n    vec3 p3  = fract(vec3(p.xyx) * .1031);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\nvec3 hash33(vec3 p3)\n{\n\tp3 = fract(p3 * MOD3);\n    p3 += dot(p3, p3.yxz+19.19);\n    return -1.0 + 2.0 * fract(vec3((p3.x + p3.y)*p3.z, (p3.x+p3.z)*p3.y, (p3.y+p3.z)*p3.x));\n}\n\nfloat simplex_noise(vec3 p)\n{\n    const float K1 = 0.333333333;\n    const float K2 = 0.166666667;\n    \n    vec3 i = floor(p + (p.x + p.y + p.z) * K1);\n    vec3 d0 = p - (i - (i.x + i.y + i.z) * K2);\n        \n    vec3 e = step(vec3(0.0), d0 - d0.yzx);\n\tvec3 i1 = e * (1.0 - e.zxy);\n\tvec3 i2 = 1.0 - e.zxy * (1.0 - e);\n    \n    vec3 d1 = d0 - (i1 - 1.0 * K2);\n    vec3 d2 = d0 - (i2 - 2.0 * K2);\n    vec3 d3 = d0 - (1.0 - 3.0 * K2);\n    \n    vec4 h = max(0.6 - vec4(dot(d0, d0), dot(d1, d1), dot(d2, d2), dot(d3, d3)), 0.0);\n    vec4 n = h * h * h * h * vec4(dot(d0, hash33(i)), dot(d1, hash33(i + i1)), dot(d2, hash33(i + i2)), dot(d3, hash33(i + 1.0)));\n    \n    return dot(vec4(31.316), n);\n}\n \nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n { \n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.x;  \n     \n    float SIZE = iResolution.x / BUBBLE_SIZE;\n        \n    float SF = 1./min(iResolution.x,iResolution.y)*SIZE*.5;\n         \n    uv *= SIZE;\n    vec2 id = floor(uv);\n    uv = fract(uv) - 0.5;              \n    \n    float mask = 0.0;    \n    for(float y =- 2.0; y <= 2.0; y++ ) {\n        for(float x =- 2.0; x <= 2.0; x++ ) {\n            vec2 rid = id - vec2(x, y);\n            vec2 ruv = uv + vec2(x, y) + \n                vec2(0, mod(rid, 2.)*.5) + \n                vec2(0, sin(simplex_noise(vec3(rid*0.075, iTime))*5.)*1.0);                         \n                        \n            float l = length(ruv*.5);            \n                                                         \n            float d = smoothstep(SF,-SF,l - .65) * (ruv.y);\n                        \n            mask = max(mask, d);                       \n        }\n    }\n    \n    vec3 col = vec3(1.0);\n    col = mix(COL1, COL2, abs(mask));\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WdyBRm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[214, 214, 236, 236, 356], [358, 358, 380, 380, 532], [534, 534, 563, 563, 1227], [1230, 1230, 1286, 1286, 2314]], "test": "valid"}
{"id": "wdyBRz", "name": "teeeest", "author": "mk23", "description": "fsvfs", "tags": ["dont", "me", "is", "testibg", "blame"], "likes": 0, "viewed": 38, "published": "Public", "date": "1606403256", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat aux=1.;\nfloat jara=1.;\nvec4 checker( vec2 p ) {    \n\n\n  if((p.x>=-1.5) && (p.x<1.5) && (p.y>=-1.5) && (p.y<1.5)) {\n        if(((iTime >.1) ))\n        p*=4.*aux;\n    }   return vec4(fract( p.x/3. ) >= .5 == fract( p.y/3. ) > .5 ? 0. : 1.); }  vec2 transform(vec2 uv) { \tuv = .5 * (uv - uv.yx * vec2(1., -1.)); \tuv += sign(uv) * min(abs(uv.x), abs(uv.y)); \treturn uv; }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\nif(iTime<1.) aux= iTime; \n    vec2 uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y*1.5*8.;\n\nif(iTime>=1.)\njara=1.-mix(.0,.75,fract(iTime));\n\n        if(iTime >.51) \n    uv = (fragCoord.xy - iResolution.xy*.5) / iResolution.y*1.5*8.*jara;\n\n    vec3 col = vec3(1.);\n    \n fragColor= checker(uv);\n        }  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyBRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[30, 30, 54, 54, 247], [249, 249, 274, 274, 374], [376, 376, 433, 433, 745]], "test": "valid"}
{"id": "wdyBz1", "name": "Cookie Live Stream nov20 01", "author": "NuSan", "description": "Shader coded live in 30m during Cookie Live Stream 27 november 2020\nhttps://www.twitch.tv/cookiedemoparty", "tags": ["raymarching", "livecoding"], "likes": 8, "viewed": 136, "published": "Public", "date": "1606569420", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shader coded live in 30m during Cookie Live Stream 27 november 2020\n// https://www.twitch.tv/cookiedemoparty\n\n#define time (iTime*0.5)\n\nfloat box(vec3 p, vec3 s) {\n  p=abs(p)-s;\n  return max(p.x, max(p.y,p.z));\n}\n\nmat2 rot(float a) {\n  float ca=cos(a);\n  float sa=sin(a);\n  return mat2(ca,sa,-sa,ca);  \n}\n\nfloat tick(float t) {\n  float g=fract(t);\n  g=smoothstep(0.,1.,g);\n  g=pow(g,10.);  \n  return floor(t) + g;\n  \n}\n\nvec3 at=vec3(0);\nfloat opa=10000.0;\nfloat map(vec3 p) {\n  \n\n  float t = tick(time * 2.)*3. + time*0.1;\n  p.xz *= rot(t*0.2 + p.y*0.03);\n  p.yz *= rot(t*0.3 + p.x*0.04);\n  \n  p.x += sin(p.x*0.01)*exp(-fract(time))*5.;\n  \n  float push=fract(t*0.1)*4.;\n  \n  for(float i=0.0; i<8.0; ++i) {\n\n    float tt=(time + tick(time)*3.0)*0.1;\n    p.xy *= rot(tt*0.3);\n    p.yz *= rot(tt*0.4); \n\n    p=abs(p)-push;\n  }\n  \n  p.x += sin(time)*4.0;\n  p.z = abs(p.z) - sin(tick(time));\n      \n  float d = box(p, vec3(3,0.2,1.2));\n  opa=d;\n  \n  vec3 p2= p;\n  p2.x = abs(p2.x)-4.0;\n  float d2 = length(p2)-1.0;\n  at += vec3(1,0.3,0.7) * 0.04/(0.05+abs(d2));\n  d = min(d, d2);\n  \n  return d;\n}\n\nfloat rnd(float t) {\n  return fract(sin(t*425.512)*352.741);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 uv = vec2(fragCoord.x / iResolution.x, fragCoord.y / iResolution.y);\n  uv -= 0.5;\n  uv /= vec2(iResolution.y / iResolution.x, 1);\n  \n  uv *= rot(-tick(time*.4));\n  \n  if(rnd(floor(time))<0.3) uv.x = abs(uv.x);\n  if(rnd(floor(time)+.1)<0.3) uv.y = abs(uv.y);\n\n  vec3 s=vec3(0,0,-30);\n  vec3 r=normalize(vec3(-uv, 1));\n  \n  vec3 p=s;\n  vec3 col=vec3(0);\n  \n  float ep = 0.1;\n  ep += fract(time + sin(-abs(uv.y)));\n  \n  for(int i=0; i<100; ++i) {\n    float d=map(p);\n    if(d<0.001) {\n      if(opa<0.001) {\n        //col += map(p-r);\n        //break;\n      }\n      d=0.1;\n      //break;\n    }\n    if(d>100.0) break;\n    p+=r*d;    \n    at += vec3(0.5,.7,1) * pow(ep,5.0)/(ep+abs(d));\n  }\n  \n  col += at * 0.1;\n  //col += map(p-r);\n  \n  float t2=tick(time*0.3 + uv.x*.4);\n  \n  //t2 += floor(uv.x*0.1)*4.0;\n  col.xz *= rot(t2*.7);\n  col.xy *= rot(t2*.5);\n  col=abs(col);\n  \n  col += clamp(col.yzx-1.0,0.0,1.0);\n  col += clamp(col.zxy-1.0,0.0,1.0);\n  \n  col *= 0.3;\n  col = smoothstep(0.0,1.0,col);\n  col = pow(col, vec3(1));\n  \n  fragColor = vec4(col, 1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wdyBz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[139, 139, 166, 166, 215], [217, 217, 236, 236, 307], [309, 309, 330, 330, 421], [459, 459, 478, 478, 1094], [1096, 1096, 1116, 1116, 1158], [1160, 1160, 1217, 1217, 2277]], "test": "valid"}
{"id": "wlffDf", "name": "Liquid Metal2", "author": "wickiss", "description": "from https://www.shadertoy.com/view/3t2czh", "tags": ["metal", "liquid"], "likes": 7, "viewed": 211, "published": "Public", "date": "1606485428", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Licence CC0: Liquid Metal\n// Some experimenting with warped FBM and very very fake lighting turned out ok \n    \n#define PI  3.141592654\n#define TAU (2.0*PI)\n\nvoid rot(inout vec2 p, float a) {\n  float c = cos(a);\n  float s = sin(a);\n  p = vec2(c*p.x + s*p.y, -s*p.x + c*p.y);\n}\n\nfloat hash(in vec2 co) {\n  return fract(sin(dot(co.xy ,vec2(12.9898,58.233))) * 13758.5453);\n}\n\nvec2 hash2(vec2 p) {\n  p = vec2(dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)));\n  return fract(sin(p)*18.5453);\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nfloat onoise(vec2 x) {\n  x *= 0.5;\n  float a = sin(x.x);\n  float b = sin(x.y);\n  float c = mix(a, b, psin(TAU*tanh(a*b+a+b)));\n  \n  return c;\n}\n\nfloat vnoise(vec2 x) {\n  vec2 i = floor(x);\n  vec2 w = fract(x);\n    \n#if 1\n  // quintic interpolation\n  vec2 u = w*w*w*(w*(w*6.0-15.0)+10.0);\n#else\n  // cubic interpolation\n  vec2 u = w*w*(3.0-2.0*w);\n#endif    \n\n  float a = hash(i+vec2(0.0,0.0));\n  float b = hash(i+vec2(1.0,0.0));\n  float c = hash(i+vec2(0.0,1.0));\n  float d = hash(i+vec2(1.0,1.0));\n    \n  float k0 =   a;\n  float k1 =   b - a;\n  float k2 =   c - a;\n  float k3 =   d - c + a - b;\n\n  float aa = mix(a, b, u.x);\n  float bb = mix(c, d, u.x);\n  float cc = mix(aa, bb, u.y);\n  \n  return k0 + k1*u.x + k2*u.y + k3*u.x*u.y;\n}\n\nfloat fbm1(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 5; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\nfloat fbm2(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 7; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\nfloat fbm3(vec2 p) {\n  vec2 op = p;\n  const float aa = 0.45;\n  const float pp = 2.03;\n  const vec2 oo = -vec2(1.23, 1.5);\n  const float rr = 1.2;\n  \n  float h = 0.0;\n  float d = 0.0;\n  float a = 1.0;\n  \n  for (int i = 0; i < 3; ++i) {\n    h += a*onoise(p);\n    d += (a);\n    a *= aa;\n    p += oo;\n    p *= pp;\n    rot(p, rr);\n  }\n  \n  return mix((h/d), -0.5*(h/d), pow(vnoise(0.9*op), 0.25));\n}\n\n\nfloat warp(vec2 p) {\n  vec2 v = vec2(fbm1(p), fbm1(p+0.7*vec2(1.0, 1.0)));\n  \n  rot(v, 1.0+iTime*0.1);\n  \n  vec2 vv = vec2(fbm2(p + 3.7*v), fbm2(p + -2.7*v.yx+0.7*vec2(1.0, 1.0)));\n\n  rot(vv, -1.0+iTime*0.21315);\n    \n  return fbm3(p + 1.4*vv);\n}\n\nfloat height(vec2 p) {\n  float a = 0.005*iTime;\n  p += 5.0*vec2(cos(a), sin(a));\n  p *= 2.0;\n  p += 13.0;\n  float h = warp(p);\n  float rs = 3.0;\n  return 0.35*tanh(rs*h)/rs;\n}\n\nvec3 normal(vec2 p) {\n  // As suggested by IQ, thanks!\n  vec2 eps = -vec2(2.0/iResolution.y, 0.0);\n  \n  vec3 n;\n  \n  n.x = height(p + eps.xy) - height(p - eps.xy);\n  n.y = 2.0*eps.x;\n  n.z = height(p + eps.yx) - height(p - eps.yx);\n  \n  \n  return normalize(n);\n}\n\nvec3 postProcess(vec3 col, vec2 q)  {\n  col=pow(clamp(col,0.0,1.0),vec3(0.85)); \n  col=col*0.6+0.4*col*col*(3.0-2.0*col);  // contrast\n  col=mix(col, vec3(dot(col, vec3(0.1))), -1.0);  // satuation\n  col*=0.5+0.5*pow(100.0*q.x*q.y*(1.0-q.x)*(1.0-q.y),0.7);  // vigneting\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 q = fragCoord/iResolution.xy;\n  vec2 p = -1. + 2. * q;\n  p.x*=iResolution.x/iResolution.y;\n \n  const vec3 lp1 = vec3(0.9, -0.5, 0.8);\n  const vec3 lp2 = vec3(-0.9, -1.5, 0.9);\n\n  float h = height(p);\n  vec3 pp = vec3(p.x, h, p.y);\n  float ll1 = length(lp1.xz - pp.xz);\n  vec3 ld1 = normalize(lp1 - pp);\n  vec3 ld2 = normalize(lp2 - pp);\n \n  vec3 n = normal(p);\n  float diff1 = max(dot(ld1, n), -0.1);\n  float diff2 = max(dot(ld2, n), 0.0);\n \n  vec3 baseCol = vec3(1.0, 1.0, 1.0);\n\n  float oh = height(p + ll1*0.05*normalize(ld1.xz));\n  const float level0 = 0.0;\n  const float level1 = 0.125;\n  // VERY VERY fake shadows + hilight\n  vec3 scol = baseCol*(smoothstep(level0, level1, h) - smoothstep(level0, level1, oh));\n\n  vec3 col = vec3(0.0);\n  col += baseCol*pow(diff1, 9.0);\n  col += 0.1*baseCol*pow(diff1, 0.1);\n  col += 0.15*baseCol.zyx*pow(diff2, 2.0);\n  col += 0.015*baseCol.zyx*pow(diff2, 2.0);\n  col += scol*0.5;\n\n  col = postProcess(col, q);\n  \n  fragColor = vec4(col, 2.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wlffDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[161, 161, 194, 194, 279], [281, 281, 305, 305, 375], [377, 377, 397, 397, 495], [497, 497, 518, 518, 547], [549, 549, 571, 571, 692], [694, 694, 716, 716, 1283], [1285, 1285, 1305, 1305, 1679], [1681, 1681, 1701, 1701, 2075], [2077, 2077, 2097, 2097, 2471], [2474, 2474, 2494, 2494, 2720], [2722, 2722, 2744, 2744, 2897], [2899, 2899, 2920, 2953, 3161], [3163, 3163, 3200, 3200, 3449], [3451, 3451, 3508, 3508, 4501]], "test": "valid"}
{"id": "ws3BD2", "name": "6D- IQ Biplanar mapping", "author": "snolot", "description": "Testing IQ Biplanar mapping on animated sdf", "tags": ["raymarching", "biplanar"], "likes": 7, "viewed": 128, "published": "Public", "date": "1606000930", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// From IQ's example 'Biplanar mapping' https://www.shadertoy.com/view/ws3Bzf \n#define ROTATE\n#define SLICE\n#define PI 3.14159265\n\n#define R(x) fract(sin(dot(x,vec2(12.9898, 78.233))) * 43758.5453)\n\n// Wyman, Chris, and Morgan McGuire. \"Hashed alpha testing.\" \n// Proceedings of the 21st ACM SIGGRAPH Symposium on Interactive 3D Graphics and Games. ACM, 2017.\nfloat hash(vec2 p) {\n   return fract(1.0e4 * sin(17.0 * p.x + 0.1 * p.y) * (0.1 + abs(sin(13.0 * p.y + p.x))));\n}\n\nfloat hash3D(vec3 p) {\n   return hash(vec2(hash(p.xy), p.z));\n}\n\nfloat psin(float a) {\n  return 0.5 + 0.5*sin(a);\n}\n\nvec3 smin(vec3 a, vec3 b, float k) {\n  vec3 h = max(k-abs(a-b),0.)/k;\n  return min(a,b)-h*h*h*k/6.;\n}\n\nfloat obj(vec3 p) {\n\n    vec3 p1 = p;\n    #ifdef SLICE\n        vec3 p2 = vec3(asin(sin(iTime )),0,0);\n    #else\n        vec3 p2 = vec3(1,0,0);\n    #endif\n\n    #ifdef ROTATE\n    \tmat3 r11 = mat3(-0.33,-0.55,0.29,0.18,-0.055,0.24,-0.11,-0.42,-0.83);\n    \tmat3 r12 = mat3(-0.42,0.13,0.26,0.8,-0.13,0.06,-0.088,0.68,-0.29);\n    \tmat3 r22 = mat3(-0.67,-0.47,0.23,-0.07,-0.54,0.17,0.4,-0.24,0.46);\n    \tmat3 r21 = mat3(0.54,-0.29,0.31,-0.17,0.57,0.73,-0.22,-0.047,0.25);\n    #else    \n        mat3 r11 = mat3(1);\n        mat3 r12 = mat3(0);\n        mat3 r21 = mat3(0);\n        mat3 r22 = mat3(1);\n    #endif\n\n    vec3 l1s = r11*p1 + r12*p2;\n    vec3 l2s = r21*p1 + r22*p2;\n\n    vec3 l1 = smin(1.-sqrt(l1s*l1s+.1),vec3(.5),.2);\n    vec3 l2 = smin(1.-sqrt(l2s*l2s+.1),vec3(.5),.2);\n\n    \n    float cage = sqrt(dot(l1,l1)+dot(l2,l2))-.9;\n    return cage;\n}\n\nfloat scene(vec3 p) {\n    //mix the object with a smaller, space-repeated copy of itself for a more interesting surface texture\n    return mix(obj(p), obj(asin(sin(p*6.)*.8))/6.,.3);\n}\n\nvec3 norm(vec3 p) {\n    mat3 k = mat3(p,p,p)-mat3(0.01);\n    return normalize(scene(p) - vec3(scene(k[0]),scene(k[1]),scene(k[2])));\n}\n\nvec4 biplanar( sampler2D sam, in vec3 p, in vec3 n, in float k )\n{\n    // grab coord derivatives for texturing\n    vec3 dpdx = dFdx(p);\n    vec3 dpdy = dFdy(p);\n    n = abs(n);\n\n    // major axis (in x; yz are following axis)\n    ivec3 ma = (n.x>n.y && n.x>n.z) ? ivec3(0,1,2) :\n               (n.y>n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n    // minor axis (in x; yz are following axis)\n    ivec3 mi = (n.x<n.y && n.x<n.z) ? ivec3(0,1,2) :\n               (n.y<n.z)            ? ivec3(1,2,0) :\n                                      ivec3(2,0,1) ;\n        \n    // median axis (in x;  yz are following axis)\n    ivec3 me = ivec3(3) - mi - ma;\n    \n    // project+fetch\n    vec4 x = textureGrad( sam, vec2(   p[ma.y],   p[ma.z]), \n                               vec2(dpdx[ma.y],dpdx[ma.z]), \n                               vec2(dpdy[ma.y],dpdy[ma.z]) );\n    vec4 y = textureGrad( sam, vec2(   p[me.y],   p[me.z]), \n                               vec2(dpdx[me.y],dpdx[me.z]),\n                               vec2(dpdx[me.y],dpdy[me.z]) );\n    \n    // blend and return\n    vec2 m = pow( vec2(n[ma.x],n[me.x]), vec2(k) );\n\treturn (x*m.x + y*m.y) / (m.x + m.y);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n     vec2 uv = (fragCoord - iResolution.xy*0.5)/iResolution.y;\n\t\n    vec2 mouse = (iMouse.xy/iResolution.xy*2.0-1.0)*2.;\n    mouse.x += iTime/6.;\n    mouse.y += iTime/10.;\n\n    mat3 rot_x = mat3( cos(-mouse.x), sin(-mouse.x), 0.0,\n                      -sin(-mouse.x), cos(-mouse.x), 0.0,\n                                0.0,          0.0, 1.0);\n    \n    mat3 rot_y = mat3( cos(-mouse.y), 0.0, sin(-mouse.y),\n                                0.0, 1.0, 0.0,\n                      -sin(-mouse.y), 0.0, cos(-mouse.y));\n    \n    vec3 cam = normalize(vec3(1.5,uv));\n    vec3 init = vec3(-11,0,0);\n\n\tinit*=rot_y*rot_x;\n    cam*=rot_y*rot_x;\n\n    vec3 p = init;\n    bool hit = false;\n    \n    for (int i = 0; i < 300; i++) {\n        float dist = scene(p);\n        if (dist*dist < 0.00001) { hit = true; break; }\n        if (distance(p,init)>200.) break;\n        p+=dist*cam;\n    }\n    \n    vec3 n = norm(p);\n   \n    vec3 r = reflect(cam,n);\n    vec3 lightdir = normalize(vec3(1));\n    float ao = smoothstep(-.5,2.,scene(p+n*2.))*.9+.1;\n    float ro = smoothstep(-.5,2.,scene(p+r*2.));\n    float ss = smoothstep(-1.,1.,scene(p+lightdir));\n    float spec = length(sin(r*3.)*0.2+0.8)/sqrt(3.);\n    float diff = length(sin(n*2.)*0.5+0.5)/sqrt(3.);\n    float fres = 1.-abs(dot(n,cam))*.98;\n\n   \tvec3 col = biplanar(iChannel0, p * .25, n, 2.0 ).rgb;\n    col *= col;\n    col *= 2.0;\n    col = ao*mix(ss,diff,.5)* col +pow(spec,20.)*fres*2.*ro;\n   \n    float bg = .8 + length(cam * .5 * .02) / sqrt(.3);\n  \tfragColor =hit ? vec4(sqrt(col), 1.) : vec4(vec3(pow(bg,7.))* vec3(.35, .27, .22), 1.);\n}", "image_inputs": [{"id": "XsXGRn", "previewfilepath": "/media/ap/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/cd4c518bc6ef165c39d4405b347b51ba40f8d7a065ab0e8d2e4f422cbc1e8a43.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3BD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 360, 380, 380, 473], [475, 475, 497, 497, 538], [540, 540, 561, 561, 590], [592, 592, 628, 628, 693], [695, 695, 714, 714, 1542], [1544, 1544, 1565, 1671, 1728], [1730, 1730, 1749, 1749, 1864], [1866, 1866, 1932, 1976, 3066], [3069, 3069, 3125, 3125, 4711]], "test": "error"}
{"id": "ws3BDj", "name": "smileyface_bandw_squares", "author": "dcxstephen", "description": "b and w smiley ", "tags": ["test"], "likes": 1, "viewed": 41, "published": "Public", "date": "1605991728", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nstruct smile{\n    vec2 xrange = vec2(0.1,0.2);\n    vec2 yrange = vec2(0.1,0.2);\n}*/\n\n// takes point and float, returns dist\nfloat circle(vec2 p, float r){\n    float dist = abs(length(p)-r);\n    dist = 1.0-smoothstep(0.0,0.1,dist);\n    return dist;\n}\n\nfloat circleAtC(vec2 p, vec2 c, float r){\n    float dist = (length(p-c)-r);\n    dist = step(dist,0.0);//1.0 -smoothstep(0.0,0.0000001,dist);\n    return dist;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    // vec2 uv = fragCoord/iResolution.xy;\n    \n    // Normalized pixel coords from -0.5 to 0.5\n    vec2 uv = (fragCoord - 0.5*iResolution.xy)/iResolution.x;\n\n    // Time varying pixel color\n    // vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    \n    vec3 col = vec3(0.0);\n    vec2 c=vec2(0.1*sin(2.5*iTime),0.1*cos(2.5*iTime));\n    float r = 0.1;\n    col += vec3(circleAtC(vec2(uv.x,uv.y), c, 0.1));\n    if (col==vec3(1.0)){\n        if (circleAtC(vec2(uv.x,uv.y),c+vec2(0.3,0.24)*r , 0.2*r) > 0.9 ||\n           circleAtC(vec2(uv.x,uv.y), c+vec2(-0.3,0.24)*r , 0.2*r) > 0.9 || \n           (circleAtC(vec2(uv.x,uv.y), c+vec2(0.0,-0.4)*r , 0.3*r)>0.9 && \n           uv.y < c[1]+-0.4*r)){\n            col=vec3(0.0);\n        }\n    }\n    \n    if (0.05-mod(uv.x,0.1) > 0.05*sin(3.0*iTime)){\n        col = vec3(1.0-col[0],1.0-col[1],1.0-col[2]);\n    }\n    if (0.05-mod(uv.y,0.1) > 0.05*cos(3.0*iTime)){\n        col = vec3(1.0-col[0],1.0-col[1],1.0-col[2]);\n    }\n\n    \n    // vec3 col = vec3(0.5);\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3BDj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[88, 127, 157, 157, 252], [254, 254, 295, 295, 413], [415, 415, 472, 618, 1578]], "test": "valid"}
{"id": "Ws3BRf", "name": "TaiChi", "author": "Learner_CC", "description": "First practice to draw my 2D graphic", "tags": ["2dgraphic"], "likes": 5, "viewed": 75, "published": "Public", "date": "1605706885", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// TaiChi - by CC - 2020\n// License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n#ifdef GL_ES\nprecision mediump float;\n#endif\n// -------- Const parameter -------- //\nconst float PI = 3.1415926;\n\n// -------- Basic graphic -------- //\nfloat circle(vec2 st, float radius){\n    vec2 l = st - vec2(0.5);\n    return 1.0 - smoothstep(0.99 * radius, radius * 1.01, dot(l,l)*4.0);\n}\nfloat semicircle(vec2 st, float radius) {\n    vec2 l = st;\n    float pct = 1.0 - smoothstep(0.95 * radius * radius, 1.05 * radius * radius, dot(l,l));\n    \n    pct *= step(0.0, l.y);\n    return pct;\n}\nfloat rectangle(vec2 st, vec2 size) {\n    size = 0.5 - 0.5 * size;\n    vec2 uv = smoothstep(size, size + vec2(1e-4), st);\n    uv *= smoothstep(size, size + vec2(1e-4), vec2(1.0) - st);\n    return uv.x * uv.y;\n}\nfloat bagua(vec2 uv, float n) {\n    float pct = 0.0;\n    vec2 st = uv;\n    pct = rectangle(st + vec2(0.0, 0.15), vec2(0.5, 0.08));\n    pct += rectangle(st, vec2(0.5, 0.08));\n    pct += rectangle(st + vec2(0.0, -0.15), vec2(0.5, 0.08));\n\n    pct -= (step(0.1,n) * step(n,1.0) + step(3.1,n) * step(n,4.1) + step(4.1,n) * step(n,5.) + step(6.1,n) * step(n,7.)) * rectangle(st + vec2(0.0,0.15), vec2(0.1, 0.08)); // 1,4,5,7 \n    pct -= (step(1.1,n) * step(n,2.1) + step(3.1,n) * step(n,4.1) + step(5.1,n) * step(n,6.) + step(6.1,n) * step(n,7.)) * rectangle(st, vec2(0.1, 0.08));      // 2,4,6,7\n    pct -= (step(2.1,n) * step(n,3.1) + step(4.1,n) * step(n,5.1) + step(5.1,n) * step(n,6.) + step(6.1,n) * step(n,7.)) * rectangle(st + vec2(0.0,-0.15), vec2(0.1, 0.08)); // 3,5,6,7\n\n    return pct;\n}\n\n// -------- Transform -------- //\nmat2 rotate2d(float angle) {\n    return mat2(cos(angle), -sin(angle),\n                sin(angle), cos(angle));\n}\nmat2 scale(vec2 scale){\n    return mat2(scale.x, 0.0,\n                0.0, scale.y);\n}\n\n// -------- Main -------- //\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy - vec2(0.2, 0.0);\n    uv.x *= iResolution.x / iResolution.y;\n    vec3 color = vec3(0.0);\n    float pct = 0.0;\n    \n    vec2 st = 2.0 * uv - 1.0;\n    st = rotate2d(-0.5 * iTime) * st;\n    pct = semicircle(st, 0.5);\n    pct += semicircle(rotate2d(PI) * (st + vec2(-0.25, 0.0)), 0.25);\n    pct -= semicircle((st + vec2(0.25, 0.0)), 0.25);   \n    pct -= circle(st + vec2(0.25, 0.5),0.02);\n    pct += circle(st + vec2(0.75, 0.5),0.02);\n    \n    st = 2.0 * uv - 1.0;\n    st = 2.0 * st * rotate2d(-0.5 * iTime);\n    \n    vec2 offset = -vec2(-0.5, -2.);\n    pct += bagua(st- vec2(-0.5, -2.), 2.0);\n    pct += bagua(st * rotate2d(PI * 0.25) + offset, 3.0);\n    pct += bagua(st * rotate2d(PI * 0.5) + offset, 0.0);\n    pct += bagua(st * rotate2d(PI * 0.75) + offset, 1.0);\n    pct += bagua(st * rotate2d(PI) + offset, 5.0);\n    pct += bagua(st * rotate2d(PI * 1.25) + offset, 4.0);\n    pct += bagua(st * rotate2d(PI * 1.5) + offset, 7.0);\n    pct += bagua(st * rotate2d(PI * 1.75) + offset, 6.0);   \n    \n    color = vec3(pct);\n    fragColor = vec4(color, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BRf.jpg", "access": "shaders20k", "license": "cc-by-nc-sa-3.0", "functions": [[227, 265, 301, 301, 405], [406, 406, 447, 447, 606], [607, 607, 644, 644, 817], [818, 818, 849, 849, 1612], [1614, 1648, 1676, 1676, 1760], [1761, 1761, 1784, 1784, 1847], [1849, 1878, 1935, 1935, 3032]], "test": "valid"}
{"id": "ws3BRs", "name": "Simple Cuboid", "author": "andraantariksa", "description": "Simple cube from what I have learn in university", "tags": ["cube", "beginner"], "likes": 3, "viewed": 222, "published": "Public API", "date": "1605759070", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define BACKFACE_CULLING\n\nfloat signVector( in vec2 point, in vec2 arbitraryPoint, in vec2 normal )\n{\n    return dot(point - arbitraryPoint, normal);\n}\n\nvec2 lineNormal( in vec2 a, in vec2 b )\n{\n    return vec2(-(b.y - a.y), b.x - a.x);\n}\n\nbool isInsideTriangle( in vec2 point, in vec2 v1, in vec2 v2, in vec2 v3 )\n{\n    float s1 = signVector(point, v1, lineNormal(v1, v2));\n    float s2 = signVector(point, v2, lineNormal(v2, v3));\n    float s3 = signVector(point, v3, lineNormal(v3, v1));\n    \n    return ((s1 > 0.0f) && (s2 > 0.0f) && (s3 > 0.0f))\n        || ((s1 < 0.0f) && (s2 < 0.0f) && (s3 < 0.0f));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 vertices[8] = vec3[8](\n        vec3(-0.3f, 0.3f, -0.3f),\n        vec3(-0.3f, 0.3f, 0.3f), // Front left top\n        \n        vec3(0.3f, 0.3f, -0.3f),\n        vec3(0.3f, 0.3f, 0.3f), // Front right top\n            \n        vec3(-0.3f, -0.3f, -0.3f),\n        vec3(-0.3f, -0.3f, 0.3f), // Front left bottom\n\n        vec3(0.3f, -0.3f, -0.3f),\n        vec3(0.3f, -0.3f, 0.3f)  // Front right bottom\n    );\n    \n    uvec3 verticesIdx[12] = uvec3[12](\n        // Front surface\n        uvec3(1, 5, 7),\n        uvec3(1, 7, 3),\n        // Left surface\n        uvec3(1, 4, 5),\n        uvec3(0, 4, 1),\n        // Right surface\n        uvec3(3, 7, 2),\n        uvec3(7, 6, 2),\n        // Bottom surface\n        uvec3(5, 6, 7),\n        uvec3(5, 4, 6),\n        // Top surface\n        uvec3(1, 3, 2),\n        uvec3(2, 0, 1),\n        // Back surface\n        uvec3(0, 6, 4),\n        uvec3(0, 2, 6)\n    );\n    \n    float zc = 1.0f;\n    float angularSpeed = iTime * 10.0f / (2.0f * 3.14159265359f);\n    mat4 rotXMat = mat4(\n        1.0f, 0.0f, 0.0f, 0.0f,\n        0.0f, cos(angularSpeed), -sin(angularSpeed), 0.0f,\n        0.0f, sin(angularSpeed), cos(angularSpeed), 0.0f,\n        0.0f, 0.0f, 0.0f, 1.0f\n    );\n    mat4 rotYMat = mat4(\n        cos(angularSpeed), 0.0f, sin(angularSpeed), 0.0f,\n        0.0f, 1.0f, 0.0f, 0.0f,\n        -sin(angularSpeed), 0.0f, cos(angularSpeed), 0.0f,\n        0.0f, 0.0f, 0.0f, 1.0f\n    );\n    mat4 perspectiveMat = mat4(\n        1.0f, 0.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f, 0.0f,\n    \t0.0f, 0.0f, 1.0f, 1.0f/-zc,\n        0.0f, 0.0f, 0.0f, 1.0f\n    );\n    mat4 st = mat4(\n        1.0f, 0.0f, 0.0f, 0.0f,\n        0.0f, 1.0f, 0.0f, 0.0f,\n    \t0.0f, 0.0f, 1.0f, 0.0f,\n        0.0f, 0.0f, 0.0f, 1.0f\n    );\n    for (int i = 0; i < 8; ++i)\n    {\n        vec4 verticesInPerspective = st * perspectiveMat * rotXMat * rotYMat * vec4(vertices[i], 1.0f);\n        vertices[i] = verticesInPerspective.xyz / verticesInPerspective.w;\n    }\n    \n    vec2 uv = fragCoord/iResolution.xy;\n    \n    uv -= 0.5f;\n    uv.x *= iResolution.x / iResolution.y;\n\n    vec3 color = vec3(0.0f, 0.0f, 0.0f);\n    \n    for (int i = 0; i < 12; ++i)\n    {\n        if (\n#ifdef BACKFACE_CULLING\n            dot(\n            \tcross(\n                    vertices[verticesIdx[i][1]] - vertices[verticesIdx[i][0]],\n                    vertices[verticesIdx[i][2]] - vertices[verticesIdx[i][1]]),\n                vec3(0.0f, 0.0f, -1.0f)\n            ) < 0.0f &&\n#endif\n            isInsideTriangle(\n            uv,\n            vec2(vertices[verticesIdx[i][0]]),\n            vec2(vertices[verticesIdx[i][1]]),\n            vec2(vertices[verticesIdx[i][2]])))\n        {\n\t\t\tcolor.r = float(i)/12.0;\n            color.g = float(i)/12.0;\n            color.b = (12.0-float(i))/12.0;\n        }\n    }\n\n    fragColor = vec4(color, 1.0f);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3BRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[26, 26, 101, 101, 151], [153, 153, 194, 194, 238], [240, 240, 316, 316, 608]], "test": "valid"}
{"id": "Ws3BRX", "name": "Real-time plasma", "author": "lechuga2000", "description": "Real-time plasma effect", "tags": ["plasma", "effect", "realtime"], "likes": 2, "viewed": 73, "published": "Public", "date": "1605611889", "time_retrieved": "2021-10-01T00:00:00", "image_code": "const vec3 color1 = vec3(1.0);\nconst vec3 color2 = vec3(0.0, 0.0, 1.0);\nconst vec3 color3 = vec3(0.0);\n\nconst float scale = 4.0e-1;\nconst float speed = 3.0;\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{   \n  vec2 p = scale * fragCoord / iResolution.xy;\n  p.y *= iResolution.y / iResolution.x;\n\n  float t = speed * iTime;\n\n  vec2 d = p + 5.0e-1 * sin(2.0e-1 * t);\n    \n  float dv = sin(1.0e1 * p.x + t)\n           + sin(1.0e1 * (p.x * sin(5.0e-1 * t) + p.y * cos(5.0e-1 * t)) + t)\n           + sin(sqrt(1.0e2 * dot(d, d)) + t);\n    \n  float f = 5.0e-1 * (1.0 + sin(3.0 * dv));\n\n  fragColor = vec4(mix(mix(color1, color2, 2.0 * f), mix(color2, color3, 2.0 * (f - 0.5)), step(0.5, f)), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[158, 158, 213, 213, 701]], "test": "valid"}
{"id": "Ws3BW2", "name": "black triangles water", "author": "Felics", "description": "black triangles water\n", "tags": ["watertriangles"], "likes": 4, "viewed": 102, "published": "Public", "date": "1605966186", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define float3 vec3\n#define float2 vec2\n#define frac fract\n#define fmod mod\n#define lerp mix\n\n#define Hash(p) (frac(sin(dot((p), float2(127.1,311.7))) * 43758.5453123))\n#define HeightU(p) (frac((p)) * frac((p)) * (3.0 - 2.0 * frac((p))))\n#define Height(p, time) (frac(-1.0 + 2.0 * lerp(lerp(Hash(floor((p)) + float2(0.0, 0.0)), Hash(floor((p)) + float2(1.0, 0.0)), HeightU(p).x), lerp(Hash(floor((p)) + float2(0.0, 1.0)), Hash(floor((p)) + float2(1.0, 1.0)), HeightU(p).x), HeightU(p).y)) + sin((p).x * 2.0 + (time)) * 0.25)\n#define Intersection(p, p0, p1, p2) (dot((p) - (p0), normalize(cross((p0) - (p1), (p0) - (p2)))))\n#define Distance(p, time) (min(max(Intersection(float3(fmod((p).xy, 1.0), (p).z), float3(0, 0, 0), float3(1.0, 1.0, 0), float3(0, 0, 1.0)), Intersection(float3(fmod((p).xy, 1.0), (p).z), float3(0, 0, -Height(floor((p).xy) + float2(0, 0), (time))), float3(0, 1.0, -Height(floor((p).xy) + float2(0, 1), (time))), float3(1.0, 1.0, -Height(floor((p).xy) + float2(1, 1), (time))))), max(-Intersection(float3(fmod((p).xy, 1.0), (p).z), float3(0, 0, 0), float3(1.0, 1.0, 0), float3(0, 0, 1.0)), Intersection(float3(fmod((p).xy, 1.0), (p).z), float3(0, 0, -Height(floor((p).xy) + float2(0, 0), (time))), float3(1.0, 1.0, -Height(floor((p).xy) + float2(1, 1), (time))), float3(1.0, 0, -Height(floor((p).xy) + float2(1, 0), (time)))))))\n\nfloat3 Color(float3 worldPosition, float time)\n{\n    worldPosition *= 0.005;\n    float x = frac(worldPosition.x);\n    float y = frac(worldPosition.y);\n\n    float3 origin = float3(x, y, -16.0);\n    float3 direction = normalize(float3(x, y, 0.5));\n\n    float dist = 0.0;\n    for(int i = 0; i < 128; i++)\n    {\n        float sceneDist = Distance(origin + direction * dist, time);\n        dist += sceneDist * 0.5;\n\n        if(abs(sceneDist) <  0.0001)\n        {\n            break;\n        }\n    }\n\n    float3 p = origin + direction * dist;\n    float3 off = float3(0.002, 0, 0);\n    float3 normal = normalize\n    ( \n        float3\n        (\n            Distance(p + off.xyz, time) - Distance(p - off.xyz, time),\n            Distance(p + off.zxy, time) - Distance(p - off.zxy, time),\n            Distance(p + off.yzx, time) - Distance(p - off.yzx, time)\n        )\n    );\n\n    float color = 0.15 * -dot(normal, direction);\n    return float3(color, color, color);\n}\n\nvoid mainImage( out vec4 fragColor, in float2 fragCoord )\n{\n    float2 uv = fragCoord.xy / iResolution.y;\n    float3 worldPosition = float3(uv, 0.0) * 100.0 - vec3(500.0, 500.0, 0.0);\n    \n    fragColor = vec4(Color(worldPosition, iTime), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3BW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1351, 1351, 1399, 1399, 2308], [2310, 2310, 2369, 2369, 2556]], "test": "timedout"}
{"id": "Ws3Bzj", "name": "Mandelbrot rainbow", "author": "been_jamming", "description": "Renders the mandelbrot set with a trippy rainbow effect", "tags": ["fractal"], "likes": 1, "viewed": 46, "published": "Public", "date": "1605548269", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define ITERATIONS 100\n\nvec2 multiply_complex(vec2 a, vec2 b){\n    return vec2(a.x*b.x - a.y*b.y, a.x*b.y + a.y*b.x);\n}\n\nfloat len(vec2 a){\n    return sqrt(a.x*a.x + a.y*a.y);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord){\n    vec2 c;\n    vec2 z = vec2(0);\n    vec2 dz = vec2(0);\n    float min_side;\n    float s_red;\n    float s_green;\n    float s_blue;\n    float dist;\n    int i;\n    \n    min_side = min(iResolution.x, iResolution.y);\n    c = fragCoord.xy/min_side*2.0;\n    c = c - vec2(iResolution.x/min_side, iResolution.y/min_side) - vec2(0.5, 0.0);\n    for(i = 0; i < ITERATIONS; i++){\n        if(z.x*z.x + z.y*z.y > 1000000.0)\n            break;\n        dz = multiply_complex(dz, z)*2.0 + vec2(1.0);\n        z = multiply_complex(z, z) + c;\n    }\n    if(i == ITERATIONS){\n        fragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    } else {\n        dist = len(z)*log(len(z))/len(dz) + iTime/20.0;\n        if(mod(dist, 0.02) > 0.01)\n            s_red = smoothstep(0.0, 0.01, mod(dist, 0.02) - 0.01);\n        else\n            s_red = smoothstep(0.01, 0.0, mod(dist, 0.02));\n        if(mod(dist - 0.053, 0.02) > 0.01)\n            s_green = smoothstep(0.0, 0.01, mod(dist - 0.053, 0.02) - 0.01);\n        else\n            s_green = smoothstep(0.01, 0.0, mod(dist - 0.053, 0.02));\n        if(mod(dist - 0.007, 0.02) > 0.01)\n            s_blue = smoothstep(0.0, 0.01, mod(dist - 0.007, 0.02) - 0.01);\n        else\n            s_blue = smoothstep(0.01, 0.0, mod(dist - 0.007, 0.02));\n        fragColor = vec4(s_red, s_green, s_blue, 1.0);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3Bzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[24, 24, 62, 62, 119], [121, 121, 139, 139, 177], [179, 179, 233, 233, 1544]], "test": "valid"}
{"id": "ws3cD2", "name": "Hallucinating pattern", "author": "z0rg", "description": "A random pattern for fun", "tags": ["shrooms"], "likes": 8, "viewed": 194, "published": "Public API", "date": "1605094740", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// This work is licensed under the Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n// Unported License. To view a copy of this license, visit http://creativecommons.org/licenses/by-nc-sa/3.0/ \n// or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\n// =========================================================================================================\n\n#define sat(a) clamp(a,0.,1.)\n\nmat2 r2d(float a){float cosa = cos(a);float sina = sin(a);return mat2(cosa,sina,-sina,cosa);}\n\nfloat cir(vec2 p, float r)\n{\n  return length(p)-r;\n}\n\nvec3 rdr(vec2 uv)\n{\n  uv*=r2d(.1*iTime+length(uv)*.5);\n  vec3 col=vec3(0.);\n\n  float l = abs(sin(uv.y*30.+20.*sin(.5*iTime+uv.x*5.*length(uv*.2))))-2.3*(.1+.2*sin((uv.x+uv.y)*5.+iTime));\n\n  col = mix(col,vec3(1.),1.-sat(l));\n  return col;\n}\n\nvec3 rdr2(vec2 uv)\n{\n  float dist = (sin(-iTime*5.+(uv.x+uv.y)*5.)*.5+1.)*0.08;\n\n  vec2 dir = normalize(vec2(1.));\n  vec3 col;\n  col.r = rdr(uv+dir*dist).r;\n  col.g = rdr(uv).g;\n  col.b = rdr(uv-dir*dist).b;\n  return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n  vec2 uv =( fragCoord.xy-0.5*iResolution.xy) / iResolution.xx;\n  uv*=3.5;\n\n  vec3 col = rdr2(uv);\n  fragColor = vec4(col, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3cD2.jpg", "access": "shaders20k", "license": "cc-by-nc-4.0", "functions": [[428, 428, 446, 446, 521], [523, 523, 551, 551, 575], [577, 577, 596, 596, 817], [819, 819, 839, 839, 1042], [1044, 1044, 1101, 1101, 1232]], "test": "valid"}
{"id": "Ws3fDf", "name": "Graph of Functions", "author": "zhengzhehui", "description": "Graph of functions", "tags": ["2d"], "likes": 2, "viewed": 45, "published": "Public", "date": "1606119018", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float plot(vec2 st, float y)\n{\n    return smoothstep(y-0.02, y, st.y)-smoothstep(y, y+0.02, st.y);\n    //1.sty=f(x)0~10\n    //2.sty=f(x)0~10\n    //3.12y=f(x)0~1\n}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    float t = iTime;\n    float p = sin(t)*3.0+3.5;//0.5<p<6.5\n    \n    float y = pow(uv.x,p); //y=x^p\n    float z = sin(uv.x*15.0-t)/4.0+0.5;\n    \n    vec3 color;\n    float line_y = plot(uv,y);\n    float line_z = plot(uv,z);\n    color += line_y;\n\tcolor += line_z;\n    if(line_y > 0.3 && line_z > 0.3)  //\n    {\n        color = vec3(0.,0.5,0.5);\n    }    \n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3fDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 30, 30, 354], [361, 361, 418, 468, 941]], "test": "valid"}
{"id": "ws3fRr", "name": "Raymarch + phong illumination", "author": "TheVanManCan", "description": "Simplest example of raymarching, the plane on the y axis appears curved only because raymarching has a distance limit. Currently all ambiant and diffuse lights are based off of the same red coloring (including the lights) which needs to be updated", "tags": ["raymarch"], "likes": 1, "viewed": 31, "published": "Public", "date": "1604201348", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_RAY_STEPS 200\n#define MAX_DISTANCE 200.0\n#define RAY_HIT_DISTANCE 0.005\n\nstruct sphere{\n    vec3 position;\n    vec3 color;\n    float radius;\n};\n\nstruct light{\n    vec3 intensity;\n    sphere s;\n};\n\nsphere centerObject = sphere(vec3(0,2,6), vec3(0.7, 0.3, 0.3), 1.0);\n\n\n#define NUM_LIGHT_SOURCE 2\nlight[2] GetLights(){\n    \n    sphere light1Sphere = sphere(vec3(6.5 * sin(iTime),\n                                      2.0, \n                                      6.5 * cos(iTime)),\n                                 vec3(0.3,0.3,.8),\n                                 0.5);\n    \n    light light1 = light(vec3(0.5), light1Sphere);\n    \n\n    sphere light2Sphere = sphere(vec3(3.0, 2.0, 3.0),\n                                 vec3(0.6, 0.6, 0.6),\n                                 0.3);\n    \n    light light2 = light(vec3(0.5), light2Sphere);\n\n    return light[2](light1, light2);\n}\n\nfloat SceneSDF(vec3 location) {\n    \n    //same as in main scene\n    light[2] lights = GetLights();\n    \n    float lightDist = min(length(location-lights[0].s.position) - lights[0].s.radius, length(location - lights[1].s.position) - lights[1].s.radius);\n    float sphereDist =  length(location-centerObject.position) - centerObject.radius;\n    float planeDist = location.y; //Asume ground is on y axis;\n    \n    float distance = min(sphereDist, planeDist);\n    distance = min(distance, lightDist);\n    return distance;\n}\n\nfloat RayMarch(vec3 rayOrigin, vec3 rayDirection){\n \tfloat originDistance = 0.0;\n    for(int i = 0; i < MAX_RAY_STEPS; i++){\n        vec3 currentLocation = rayOrigin + rayDirection*originDistance;\n        float sceneDistance = SceneSDF(currentLocation);\n        originDistance += sceneDistance;\n        if(sceneDistance < RAY_HIT_DISTANCE || originDistance > MAX_DISTANCE) break;\n    }\n    return originDistance;\n    \n}\n\n//estimate the normal by finding slope by sampling nearby points\nconst float EPSILON = 0.0001;\nvec3 estimateNormal(vec3 p) {\n    return normalize(vec3(\n        SceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - SceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        SceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - SceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        SceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - SceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    if (dotLN <= 0.0) {\n        //not visible\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    float dotRV = dot(R, V);\n    if (dotRV <= 0.0) {\n        // reflection opposite of the viewwer, only use diffuse\n        return lightIntensity * (k_d * dotLN);\n    }\n    \n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\nvec3 phongIllumination(vec3 ambiantColor, vec3 diffuseColor, vec3 specularColor, float alpha, vec3 p, vec3 eye, vec3 lightPosition, vec3 lightIntensity) {\n    \n\tlight[2] lights = GetLights();\n    \n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * ambiantColor;\n \n    //objects\n    color += phongContribForLight(diffuseColor, specularColor, alpha, p, eye,\n                                  lightPosition,\n                                  lightIntensity);\n    \n    \n    //additional coloring to light sources\n    for(int i = 0; i < 2; i++){\n        if(length(p - lights[i].s.position) <= lights[i].s.radius+0.005){\n         \tcolor+= lights[i].s.color * lights[i].intensity;  \n        }\n    }\n     \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1) with screen dimensions taken into consideration\n    vec2 uv = (fragCoord-.5*iResolution.xy)/iResolution.y;\n    \n    vec3 cameraOrigin = vec3(0, 5, -5);\n    vec3 cameraDirection = normalize(vec3(uv.x, uv.y-0.3, 1.0));\n\n\n    float distance = RayMarch(cameraOrigin, cameraDirection);\n   \n    vec3 position = cameraOrigin + cameraDirection*distance;\n    \n    vec3 ambiantColor = vec3(0.7, 0.3, 0.3);\n    vec3 diffuseColor = vec3(0.7, 0.3, 0.3);\n    float shininess = 5.0;\n    \n    light[2] lights = GetLights();\n    \n    vec3 col = vec3(0);\n    for(int i = 0; i < 2; i++){\n        col += phongIllumination(ambiantColor * lights[i].s.color, \n                                 diffuseColor * lights[i].s.color, \n                                 lights[i].s.color, \n                                 shininess, \n                                 position, \n                                 cameraOrigin, \n                                 lights[i].s.position, \n                                 lights[i].intensity);\n    }\n    \n    if(MAX_DISTANCE - distance < 0.1){\n     \tcol = vec3(0.0);   \n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3fRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1409, 1409, 1459, 1459, 1828], [1925, 1925, 1954, 1954, 2264], [2266, 2266, 2406, 2406, 2923]], "test": "valid"}
{"id": "ws3fW8", "name": "Mandelbrot Lace", "author": "denosya", "description": "mandelbrot", "tags": ["mandelbrot"], "likes": 0, "viewed": 64, "published": "Public", "date": "1604935209", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\nvec4 run(in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy / iResolution.xy - vec2(0.5, 0.5);\n    uv.x *= iResolution.x/iResolution.y;\n\n   // Zoom    \n    const float initialzoom = 60.0;\n    float phase = 2.1;\n    float zoom = 6.0 * pow(10.0, 1.0 + (cos(iTime*0.1505+phase) + 1.0) * 0.5 * 4.0);\n    //zoom = 40.2;\n    \n    uv /= zoom*0.01;\n\n    // Rotation\n    float t = iTime*0.1;\n    uv *= mat2(cos(t),sin(t), -sin(t),cos(t));\n\n    // Translation\n    //const vec2 focus = vec2(0.424513, 0.20753);  \n\tconst vec2 focus = vec2(-0.045, 0.68059);        \n    \n    //const vec2 focus = vec2(0.0);        \n    \n    uv += focus;     \n    \n    vec2 c = vec2(uv.x, uv.y);\n    vec2 z = vec2(0.0, 0.0);\n    \n    bool draw = true;\n\n    int nbiter = 0;    \n    float distnce = 0.0;\n    \n       for(int i=0; i<100;i++) {\n     \n        float _2xy = 2.0*z.x*z.y;\n        z.x = z.x*z.x - z.y*z.y;\n        z.y = _2xy;\n        \n        z += c;\n\n        distnce = length(z-c);           \n           \n        if(length(z)>2.0) {\n\n\t\t\tbreak;            \n        }\n\n        nbiter++;\n    }\n\n    float test = float(nbiter)/100.0 * (1.25 - pow(distnce* 0.5, 0.66));\n    //    test = float(nbiter)/100.0 * (pow(distnce* 0.5, 0.66));\n    \n    return vec4(test);    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 fragColor1 = run(fragCoord + vec2(-0.25, -0.25));\n    vec4 fragColor2 = run(fragCoord + vec2(+0.25, -0.25));\n    vec4 fragColor3 = run(fragCoord + vec2(-0.25, +0.25));\n    vec4 fragColor4 = run(fragCoord + vec2(+0.25, +0.25));\n    \n    fragColor = (fragColor1 + fragColor2 + fragColor3 + fragColor4) * 0.25;\n} \n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3fW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[2, 2, 32, 32, 1238], [1240, 1240, 1297, 1297, 1616]], "test": "valid"}
{"id": "ws3fWH", "name": "Multi Color Jellyfish", "author": "mosaic", "description": "Edit of https://www.shadertoy.com/view/3sKyDw", "tags": ["2d"], "likes": 6, "viewed": 87, "published": "Public", "date": "1604957096", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec4  fC ( in vec2 fragCoord ) {\n    vec3 col;\n    float t = iTime*.05;\n    vec2 uv = (fragCoord-iResolution.xy)/iResolution.y+vec2(t+2.0);\n        //uv *= 10.0;\n        int c = 0;\n        for(int i=0;i<9;i++)\n        {\n            c = i%3;\n            float factor = 1.5;\n            vec2 uv1 = uv;\n            uv /= factor;\n            uv += uv1;\n            uv += (sin(uv.yx+iTime/5.))/factor;\n            uv *= factor;\n            col[c] += sin(uv.x+uv.y);\n            col=col*vec3(.45,.2,.9);\n        }\n    return  vec4(col*10.0,1.0);\n}\n\n\n// Add this code to the bottom of any shader that has aliasing:\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0);\n    float A = 7.,  // Change A to define the level of anti-aliasing (1 to 16) ... higher numbers are REALLY slow!\n          s = 1./A, x, y;\n    \n    for (x=-.5; x<.5; x+=s) for (y=-.5; y<.5; y+=s) fragColor += min ( fC(vec2(x,y)+fragCoord), 1.0);\n        \n\tfragColor /= A*A;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/ws3fWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 32, 32, 541], [544, 608, 665, 665, 967]], "test": "valid"}
{"id": "Ws3fWj", "name": "WHUD WUI, HUD UI fork", "author": "UrbanClubProfessional", "description": "Remix of Sachiemon's \"HUD UI\". [url]https://www.shadertoy.com/view/tl33zn[/url]", "tags": ["remix", "radar", "glitch", "fork", "weird", "ui", "hud", "gui", "acads"], "likes": 1, "viewed": 162, "published": "Public API", "date": "1605956188", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//Sci-fi radar based on the work of gmunk for Oblivion\n//http://work.gmunk.com/OBLIVION-GFX\n\n#define SMOOTH(r,R) (1.0-smoothstep(R-2.0,R+2.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(2.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-2.0,a+2.0,x)*(2.0-smoothstep(b-2.0,b+2.0,x)) )\n#define M_PI 4.1415926535897932384626433832795\n\n#define blue1 vec3(0.84,1.05,2.00)\n#define blue2 vec3(0.97,1.08,2.00)\n#define blue3 vec3(0.45,0.86,0.93)\n#define blue4 vec3(1.053,1.069,0.99)\n#define red   vec3(2.00,0.48,0.327)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.2*(t)), c*sin(t)+d*cos(0.2*(t))))\nfloat rand(vec2 uv)\n{\n    return fract(sin(dot(uv, vec2(22.9898,88.233)))*2000.*iTime);\n\t//return fract(sin(dot(uv, iMouse.xy))*10000.);\n\t//return (fract(sin(dot(uv, vec2(12., 70.)))*100000.));\n   //return (fract(sin(dot(uv, vec2(12., 70.)))*43758.5453123));\n}\n\n// Value noise\nfloat noise(in vec2 st) {\n    vec2 i = floor(st);\n    vec2 f = fract(st);\n\n    // Four corners in 2D of a tile\n    float a = rand(i);\n    float b = rand(i + vec2(2.0, 0.0));\n    float c = rand(i + vec2(0.0, 2.0));\n    float d = rand(i + vec2(2.0, 2.0));\n\n    // Smooth Interpolation\n\n    // Cubic Hermine Curve.  Same as SmoothStep()\n    vec2 u = f*f*(4.0-3.0*f);\n    // u = smoothstep(0.,1.,f);\n\n    // Mix 4 coorners porcentages\n    return mix(a, b, u.x) + \n            (c - a)* u.y * (2.0 - u.x) + \n            (d - b) * u.x * u.y;\n}\n\n// Gradient noise\nvec2 hash( vec2 x )  // replace this by something better\n{\n    const vec2 k = vec2( 0.4183099, 0.4678794 );\n    x = x*k + k.yx;\n    return -2.0 + 3.0*fract( 26.0 * k*fract( x.x*x.y*(x.x+x.y)) );\n}\n\nfloat gnoise( in vec2 p )\n{\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\t\n\tvec2 u = f*f*(4.0-3.0*f);\n\n    return mix( mix( dot( hash( i + vec2(0.0,0.0) ), f - vec2(0.0,0.0) ), \n                     dot( hash( i + vec2(2.0,0.0) ), f - vec2(2.0,0.0) ), u.x),\n                mix( dot( hash( i + vec2(0.0,2.0) ), f - vec2(0.0,2.0) ), \n                     dot( hash( i + vec2(2.0,2.0) ), f - vec2(2.0,2.0) ), u.x), u.y);\n}\n\n// Simplex noise\nvec3 mod289(vec3 x) { return x - floor(x * (2.0 / 389.0)) * 389.0; }\nvec2 mod289(vec2 x) { return x - floor(x * (2.0 / 389.0)) * 389.0; }\nvec3 permute(vec3 x) { return mod289(((x*44.0)+2.0)*x); }\n\nfloat snoise(vec2 v) {\n    const vec4 C = vec4(0.311324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.466025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.677350269189626,  // -1.0 + 2.0 * C.x\n                        0.034390243902439); // 1.0 / 41.0\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y) ? vec2(2.0, 0.0) : vec2(0.0, 2.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod289(i); // Avoid truncation effects in permutation\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 2.0 ))\n        + i.x + vec3(0.0, i1.x, 2.0 ));\n\n    vec3 m = max(0.6 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 3.0 * fract(p * C.www) - 2.0;\n    vec3 h = abs(x) - 0.6;\n    vec3 ox = floor(x + 0.6);\n    vec3 a0 = x - ox;\n    m *= 2.79284291400159 - 0.95373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  * x0.y;\n    g.yz = a0.yz * x12.xz + h.yz * x12.yw;\n    return 20.0 * dot(m, g);\n}\n\n#define OCTAVES 7\nfloat fbm (in vec2 uv) {\n    // Initial values\n    float value = 0.0;\n    float amplitud = .6;\n    float frequency = 0.;\n    //\n    // Loop of octaves\n    for (int i = 0; i < OCTAVES; i++) {\n        value += amplitud * noise(uv);\n        uv *= 3.;\n        amplitud *= .6;\n    }\n    return value;\n}\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 46.0 * iTime;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/280.0),\n                            -sin(theta0*M_PI/280.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 3.0) );\n    \td = normalize(d);\n        //compute gradient based on angle difference to theta0\n   \t \tfloat theta = mod(460.0*atan(d.y,d.x)/M_PI/theta0,250.0);\n        float gradient = clamp(2.0-theta/100.0,0.0,2.0);\n        return SMOOTH(l,20.0)+0.6*gradient;\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    float offset=2.5*snoise(uv+sin(iTime));\n    float noise=.6*gnoise(uv);\n    return SMOOTH(r+width-2.0,radius*1.5)-SMOOTH(r*width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n\t    return SMOOTH(r-width*3.0,radius)-SMOOTH(r+width/6.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float offset=2.5*snoise(uv+sin(iTime));\n    float noise=.6*gnoise(uv);\n    float theta = offset*(atan(d.y,d.x)/M_PI);\n    return smoothstep(5.0, 3.1, abs(mod(theta+3.0,55.0)-3.0)) *\n        mix( 0.6, 2.0, step(55.0, abs(mod(theta, 280.0)-100.0)) ) *\n        (SMOOTH(r-width/3.0,radius)-SMOOTH(r+width/3.0,radius));\n}\n\nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-9.0, 0.0, d.x-radius) * (2.0-smoothstep( 8.0+d.x-radius,10.0-d.x-radius, abs(d.y)))\n         + RS( 0.0, 9.0, d.x+radius) * (2.0-smoothstep( 8.0-d.x-radius,10.0-d.x-radius, abs(d.y)))\n         + RS(-9.0, 0.0, d.y-radius) * (2.0-smoothstep( 8.0+d.y-radius,10.0+d.y-radius, abs(d.x)))\n         + RS( 0.0, 9.0, d.y+radius) * (2.0-smoothstep( 8.0-d.y-radius,10.0-d.y-radius, abs(d.x)));\n}\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 2.0;\n    else return 0.0;\n}\nfloat dots(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if( r <= 3.5 )\n        return 2.0;\n    if( ( r<= radius) && ( (abs(d.y+0.6)<=2.0) && ( mod(d.x+3.0, 60.0) < 3.0 ) ) )\n        return 2.0;\n    else if ( (abs(d.y+0.6)<=2.0) && ( r >= 60.0 ) && ( r < 215.0 ) )\n        return 0.6;\n    else\n\t    return 0.0;\n}\nfloat bip1(vec2 uv, vec2 center)\n{\n    return SMOOTH(length(uv - center),4.0);\n}\nfloat bip2(vec2 uv, vec2 center)\n{\n    float r = length(uv - center);\n    float R = 9.0+mod(97.0*iTime, 90.0);\n    return (0.6-0.6*cos(40.0*iTime)) * SMOOTH(r,5.0)\n        + SMOOTH(7.0,r)-SMOOTH(9.0,r)\n        + smoothstep(max(9.0,R-30.0),R,r)-SMOOTH(R,r);\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 finalColor;\n\tvec2 uv = fragCoord.xy;\n    //center of the image\n    vec2 c = iResolution.xy/2.0;\n    finalColor = vec3( 0.4*_cross(uv, c, 340.0) );\n    finalColor += ( circle(uv, c, 100.0, 1.0)\n                  + circle(uv, c, 165.0, 1.0) ) * blue1;\n    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;\n    finalColor += circle3(uv, c, 413.0, 5.0) * blue1;\n   // finalColor += triangles(uv, c, 315.0 + 30.0*sin(iTime)) * blue2;\n    finalColor += movingLine(uv, c, 340.0) * blue3;\n    finalColor += circle(uv, c, 20.0, 2.0) * blue3;\n    finalColor += 0.8 * circle2(uv, c, 362.0, 2.0, 0.6+0.3*cos(iTime)) * blue3;\n    if( length(uv-c) < 340.0 )\n    {\n        //animate some bips with random movements\n    \tvec2 p = 230.0*MOV(2.3,2.0,2.0,2.4,4.0+0.2*iTime);\n   \t\tfinalColor += bip1(uv, c+p) * vec3(2,2,2);\n        p = 230.0*MOV(1.0,-2.1,2.7,0.9,-3.0+sin(0.2*iTime)+0.25*iTime);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 60.0*MOV(2.54,2.7,2.37,2.8,sin(0.2*iTime+8.0)+0.3*iTime);\n        finalColor += bip2(uv,c+p) * red;\n    }\n\n    fragColor = vec4( finalColor, 2.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3fWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[584, 584, 605, 605, 844], [846, 861, 886, 886, 1397], [1399, 1417, 1475, 1475, 1613], [1615, 1615, 1642, 1642, 2040], [2042, 2059, 2080, 2080, 2127], [2128, 2128, 2149, 2149, 2196], [2197, 2197, 2219, 2219, 2254], [2256, 2256, 2278, 2278, 3325], [3345, 3345, 3369, 3391, 3642], [3643, 3643, 3697, 3721, 4352], [4354, 4354, 4417, 4417, 4599], [4601, 4601, 4680, 4680, 4890], [4891, 4891, 4955, 4955, 5359], [5361, 5361, 5414, 5414, 5839], [5841, 5841, 5891, 5891, 6085], [6086, 6086, 6134, 6134, 6455], [6456, 6456, 6490, 6490, 6536], [6537, 6537, 6571, 6571, 6795], [6796, 6796, 6853, 6853, 7975]], "test": "valid"}
{"id": "Ws3fzj", "name": "gumbel DW", "author": "thu", "description": "yee yee yee yee yee yee yee yee yee yee ", "tags": ["noise"], "likes": 6, "viewed": 175, "published": "Public", "date": "1605798226", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 random3(vec3 c) {\n    float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));\n    vec3 r;\n    r.z = fract(512.0*j);\n    j *= .125;\n    r.x = fract(512.0*j);\n    j *= .125;\n    r.y = fract(512.0*j);\n    return r-0.5;\n}\n\nfloat snoise(vec3 p) {\n    const float F3 =  0.3333333;\n    const float G3 =  0.1666667;\n\n    vec3 s = floor(p + dot(p, vec3(F3)));\n    vec3 x = p - s + dot(s, vec3(G3));\n\n    vec3 e = step(vec3(0.0), x - x.yzx);\n    vec3 i1 = e*(1.0 - e.zxy);\n    vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\n    vec3 x1 = x - i1 + G3;\n    vec3 x2 = x - i2 + 2.0*G3;\n    vec3 x3 = x - 1.0 + 3.0*G3;\n\n    vec4 w, d;\n\n    w.x = dot(x, x);\n    w.y = dot(x1, x1);\n    w.z = dot(x2, x2);\n    w.w = dot(x3, x3);\n\n    w = max(0.6 - w, 0.0);\n\n    d.x = dot(random3(s), x);\n    d.y = dot(random3(s + i1), x1);\n    d.z = dot(random3(s + i2), x2);\n    d.w = dot(random3(s + 1.0), x3);\n\n    w *= w;\n    w *= w;\n    d *= w;\n\n    return dot(d, vec4(52.0));\n}\n\nvec3 normalNoise(vec2 _st, float _zoom, float _speed){\n\tvec2 v1 = _st;\n\tvec2 v2 = _st;\n\tvec2 v3 = _st;\n\tfloat expon = pow(10.0, _zoom*2.0);\n\tv1 /= 1.0*expon;\n\tv2 /= 0.62*expon;\n\tv3 /= 0.83*expon;\n\tfloat n = iTime * _speed;\n\tfloat nr = (snoise(vec3(v1, n)) + snoise(vec3(v2, n)) + snoise(vec3(v3, n))) / 6.0 + 0.5;\n\tn = iTime * _speed + 1000.0;\n\tfloat ng = (snoise(vec3(v1, n)) + snoise(vec3(v2, n)) + snoise(vec3(v3, n))) / 6.0 + .5;\n\treturn vec3(nr,ng,0.5);\n}\n\nvec3 gumbelNoise(vec3 vec) {\n    return -log(-log(vec));\n}\n\n#define NUM_OCTAVES 6\nvec3 fbm(vec2 _st, float zoom, vec2 shift, float shiftSpeed, float rad) {\n    vec3 v = vec3(0.0);\n    float a = 0.5;\n    mat2 rot = mat2(cos(rad), sin(rad), -sin(rad), cos(rad));\n    for (int i = 0; i < NUM_OCTAVES; ++i) {\n        v += a * gumbelNoise(normalNoise(_st * 5. , zoom, shiftSpeed));\n        _st = rot * _st * 2.0 + shift;\n        a *= .5;\n    }\n    return v;\n}\n\nvec3 pattern(vec2 _st) {\n    vec3 fbm0 = fbm(_st, .25, vec2(100.), 0.01, 10.);\n\n    vec3 fbm1 = fbm(\n        _st + fbm0.xy,\n        fbm0.z * 1.88,\n        vec2(fbm0.xy * .5),\n        fbm0.z * 0.01657,\n        fbm0.x * 0.00005\n    );\n\n    vec3 fbm2 = fbm(\n            _st + fbm1.xy,\n            fbm1.z * .87,\n            vec2(fbm1.xy * 3.5),\n            fbm1.z * 0.1659,\n            fbm1.x * 0.05\n        );\n\n    vec3 fbm3 = fbm(\n            _st + fbm2.xy,\n            fbm2.z * .88,\n            vec2(fbm2.xy * 1.8),\n            fbm2.z * 0.1658,\n            fbm2.x * 0.0097\n        );\n\n    return fbm3;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = (fragCoord.xy * 2. - iResolution.xy) / min(iResolution.x, iResolution.y);\n    fragColor = vec4(pattern(st), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Ws3fzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 219], [221, 221, 243, 243, 938], [940, 940, 994, 994, 1400], [1402, 1402, 1430, 1430, 1460], [1484, 1484, 1557, 1557, 1856], [1858, 1858, 1882, 1882, 2460], [2462, 2462, 2519, 2519, 2649]], "test": "valid"}
{"id": "wscBD2", "name": "Tetrascope Universe", "author": "4eckme", "description": "Tetrascope universe demo", "tags": ["2d", "fractal", "demo", "rgb", "universe", "tetrascope"], "likes": 3, "viewed": 477, "published": "Public", "date": "1606003578", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 coord = fragCoord - (iResolution.xy / vec2(2.0));\n    float x = float(coord.x);\n    float y = float(coord.y);\n    float t = iTime;\n    float r2 = float(x*x*t + y*y*t);\n    int a = int(floor(r2*pow(16.0, 6.0-ceil(log2(r2)/4.0))));   \n    fragColor = vec4(\n        float((a >> 16) & 255) / 255.0,\n        float((a >> 8) & 255) / 255.0,\n        float((a >> 0) & 255) / 255.0,\n        1.0\n    );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscBD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 460]], "test": "valid"}
{"id": "WscBRl", "name": "Fake Caustic w/Voronoi - Golfed", "author": "oneshade", "description": "Golfed version of my \"Fake Caustic w/Voronoi\" shader. Happy code golfing!", "tags": ["voronoi", "caustic", "codegolf"], "likes": 6, "viewed": 96, "published": "Public", "date": "1605722956", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/* 377 char version (27 chars shorter) by gelami */\n#define v(x, y) for(int x=-y; x++ < 2;)\nvoid mainImage(out vec4 o, vec2 u) {\n    o -= o;\n    float t = 0., w = 1., d, g, z;\n    vec2 R = iResolution.xy, q = (u - .5 * R) / R.y, x, n;\n\n    v(l,0) {\n        x = q * 4. / w;\n        d = 1.;\n        v(i,2)\n            v(j,2)\n                n = floor(x) + vec2(i, j), n += .5 + .5 * vec2(sin(n.x + n.y * 2. + iTime), cos(n.y - n.x + 2. * iTime)),\n                d = mix(g = length(x - n), d,\n                        z = clamp(.5 + 5. * (g - d), 0., 1.) )\n                            - .1 * z * (1. - z);\n\n        o += mix(vec4(0, .7, .9, 1), vec4(1.3), pow(d, 2.5)) * w;\n        t += w;\n        w *= .6;\n    }\n    o /= t;\n}\n/**/\n\n/* Another shorter version (404 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    o -= o;\n    vec2 R = iResolution.xy, q = (u - .5 * R) / R.y;\n    float t = 0., w = 1.;\n\n    for (int l=0; l++ < 2;) {\n        vec2 x = q * 4. / w;\n        float d = 1.;\n        for (int i=-2; i++ < 2;)\n            for (int j=-2; j++ < 2;) {\n                vec2 n = floor(x) + vec2(i, j); n += .5 + .5 * vec2(sin(n.x + n.y * 2. + iTime), cos(n.y - n.x + 2. * iTime));\n                float g = length(x - n), z = clamp(.5 + .5 * (g - d) / .1, 0., 1.);\n                d = mix(g, d, z) - .1 * z * (1. - z);\n            }\n\n        o += mix(vec4(0, .7, .9, 1), vec4(1.3), pow(d, 2.5)) * w;\n        t += w;\n        w *= .6;\n    }\n\n    o /= t;\n}\n**/\n\n/* Even shorter version (408 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    o -= o;\n    vec2 R = iResolution.xy, q = (u - .5 * R) / R.y;\n    float t = 0., w = 1.;\n\n    for (int l=0; l++ < 2;) {\n        vec2 x = q * 4. / w, f = floor(x);\n\n        float d = 1.;\n        for (int i=-2; i++ < 2;)\n            for (int j=-2; j++ < 2;) {\n                vec2 n = f + vec2(i, j); n += .5 + .5 * vec2(sin(n.x + n.y * 2. + iTime), cos(n.y - n.x + 2. * iTime));\n                float g = length(x - n), z = clamp(.5 + .5 * (g - d) / .1, 0., 1.);\n                d = mix(g, d, z) - .1 * z * (1. - z);\n            }\n\n        o += mix(vec4(0, .7, .9, 1), vec4(1.3), pow(d, 2.5)) * w;\n        t += w;\n        w *= .6;\n    }\n\n    o /= t;\n}\n**/\n\n/* Shorter version (409 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    o -= o;\n    vec2 R = iResolution.xy, q = (u - .5 * R) / R.y;\n    float t = 0., w = 1.;\n\n    for (int l=0; l++ < 2;) {\n        vec2 x = q * 4. / w, f = floor(x);\n\n        float d = 1.;\n        for (int i=-2; i++ < 2;)\n            for (int j=-2; j++ < 2;) {\n                vec2 n = f + vec2(i, j), p = n + .5 + .5 * vec2(sin(n.x + n.y * 2. + iTime), cos(n.y - n.x + 2. * iTime));\n                float g = length(x - p), z = clamp(.5 + .5 * (g - d) / .1, 0., 1.);\n                d = mix(g, d, z) - .1 * z * (1. - z);\n            }\n\n        o += mix(vec4(0, .7, .9, 1), vec4(1.3), pow(d, 2.5)) * w;\n        t += w;\n        w *= .6;\n    }\n\n    o /= t;\n}\n**/\n\n/* Original version (414 chars) *\nvoid mainImage(out vec4 o, vec2 u) {\n    o -= o;\n    vec2 R = iResolution.xy, q = (u - .5 * R) / R.y;\n    float t = 0., w = 1.;\n\n    for (int l=0; l < 2; l++) {\n        vec2 x = q * 4. / w, f = floor(x);\n\n        float d = 1.;\n        for (int i=-1; i < 2; i++) {\n            for (int j=-1; j < 2; j++) {\n                vec2 n = f + vec2(i, j), p = n + .5 + .5 * vec2(sin(n.x + n.y * 2. + iTime), cos(n.y - n.x + 2. * iTime));\n                float g = length(x - p), z = clamp(.5 + .5 * (g - d) / .1, 0., 1.);\n                d = mix(g, d, z) - .1 * z * (1. - z);\n            }\n        }\n\n        o += mix(vec4(0, .7, .9, 1), vec4(1.3), pow(d, 2.5)) * w;\n        t += w;\n        w *= .6;\n    }\n\n    o /= t;\n}\n**/", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscBRl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [], "test": "valid"}
{"id": "WscBRs", "name": "Polygon progression", "author": "KainArkatian", "description": "Studying relations in system with growing number of members - here on polygons\n", "tags": ["polygons", "vertices"], "likes": 6, "viewed": 94, "published": "Public", "date": "1605732315", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 center, float radius, vec2 uv, float stroke){\n    float dist = distance(center, uv);\n    \n    return smoothstep(stroke, 0.5*stroke, distance(dist, radius));\n}\n\n\nfloat line(vec2 norCoord, vec2 pointA, vec2 pointB, float stroke)\n{\n\tvec2 vecAB = pointB - pointA;\n    float d = abs(dot(normalize(vec2(vecAB.y, -vecAB.x)), norCoord - pointA));\n\treturn smoothstep(stroke, 0.5*stroke, d);\n}\n\nfloat segment(vec2 Coord, vec2 pointA, vec2 pointB, float stroke) \n{\n    vec2 vecAB = pointB - pointA;\n    vec2 vecAC = Coord - pointA;\n    float d = length(vecAC - vecAB * clamp(dot(vecAB, vecAC) / dot(vecAB,vecAB), 0.0, 1.0));\n\treturn smoothstep(stroke, 0.5*stroke, d);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\n   \n    vec2 norCoord = fragCoord.xy / iResolution.xy;\n    norCoord.y *= iResolution.y/iResolution.x;\n    vec2 norRes = vec2(1., 1.*(iResolution.y/iResolution.x));\n    \n    \n    vec3 col = vec3(1.);\n\tfloat pi = 3.14159;\n\n    float pointNum = 20. * ((sin(iTime/2.+30.)+1.1)/2. );\n    \n    float mainRad = 0.25;\n    vec2 mainCen = vec2(0.5, 0.5)*norRes;\n    float mainDist = distance(mainCen, norCoord);\n    col = mix(col, vec3(0.3), circle(mainCen, mainRad, norCoord, norRes.x/200.));\n    \n\n\n    \n    for(int i = 0; i < int(pointNum); i++){\n        float angleA = ((2.*pi)/float(pointNum)) * float(i);\n        \n        float xA = mainCen.x + mainRad * cos(angleA); \n        float yA = mainCen.y + mainRad * sin(angleA);\n        \n        vec2 pointA = vec2(xA,yA);\n        \n        col = mix(col, vec3(0.), circle(pointA, 0.005, norCoord, norRes.x/300.));\n        \n        float lineX = line(norCoord, pointA, vec2(pointA.x, 0.), norRes.x/600.);\n\t\tfloat lineY = line(norCoord, pointA, vec2(0., pointA.y), norRes.x/600.);\n        \n        if(mainDist > mainRad){\n            col = mix(col, vec3(0.), lineX/5.);\n        \tcol = mix(col, vec3(0.), lineY/5.);\n        }\n        \n         \n        for(int ii = 0; ii < int(pointNum); ii++) {\n            float angleB = ((2.*pi)/float(pointNum)) * float(ii);\n        \n            float xB = mainCen.x + mainRad * cos(angleB); \n            float yB = mainCen.y + mainRad * sin(angleB);\n\n            vec2 pointB = vec2(xB,yB);\n            col = mix(col, vec3(0.), segment(norCoord, pointA, pointB, norRes.x/2000.));\n            \n        }\n\n    } \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscBRs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 63, 63, 176], [179, 179, 246, 246, 401], [403, 403, 471, 471, 676], [680, 680, 737, 737, 2381]], "test": "valid"}
{"id": "wscBRX", "name": "Circle pizza slice", "author": "Peewi", "description": "Circle pizza slice", "tags": ["pizza"], "likes": 1, "viewed": 46, "published": "Public", "date": "1605774755", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pi, the ratio of a circle's circumference to its diameter.\n\tconst float M_PI = 3.14159265358979323846264338327950288;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Draw circle\n    vec3 bg = vec3(0.1, 0.1, 0.1);\n    vec3 white = vec3(0.9);\n    vec3 col = bg;\n    //vec2 center = vec2(200.0, iResolution.y - 150.0);\n    vec2 center = iResolution.xy / 2.;\n    float l = length(fragCoord-center);\n    //float radius = ((sin(iTime*3.0)+1.0) * 40.0);\n    float radius = 125.0;\n    float am = (l - radius);\n    am = clamp(am, 0.0, 1.0);\n    col = mix(white, bg, am);\n\n    // Only draw a pizza slice of the circle\n    float startAngle = atan(iMouse.y - center.y, iMouse.x - center.x);\n    float span = (sin(iTime) + 1.) * M_PI;\n    \n    float angle = atan(fragCoord.y - center.y, fragCoord.x - center.x);\n    float aim = startAngle - span / 2.;\n    \n    float range = span / 2.;\n    \n    float arcL = l * angle;\n    float arcLAim = l * aim;\n    float arcRangeLength = l * range;\n    \n    float arcDist = abs(arcL - arcLAim);\n    float halfCircumf = l * M_PI;\n    if(arcDist >= halfCircumf)\n    {\n        arcDist -= halfCircumf * 2.;\n        arcDist = -arcDist;\n    }\n    float arcDistDist = (arcDist - arcRangeLength);\n    arcDistDist = clamp(arcDistDist, 0., 1.);\n    col = mix(col, bg, arcDistDist);\n    /*\n    float adist = abs(angle - aim);\n    if(adist >= M_PI)\n    {\n        adist -= M_PI * 2.;\n        adist = -adist;\n    }\n    adist /= range;\n    adist = clamp(adist, 0., 1.);\n    \n    col = mix(col, bg, adist);\n    */\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscBRX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 123, 1708]], "test": "valid"}
{"id": "wscBW2", "name": "mix(circle, square, sin)", "author": "Ezra_Szanton", "description": "A circle and a square walk into a sin wave", "tags": ["periodic"], "likes": 3, "viewed": 45, "published": "Public", "date": "1605997572", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circle(vec2 uv, vec2 center, float min, float max)\n{\n    return (1. - smoothstep(0.1, 0.15, length(uv - center)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float pi = 3.14159;\n    float clamping = 0.714;\n    float points = 50.0;\n   \n    \n    vec2 uv = (fragCoord - 0.*iResolution.xy)/iResolution.y;\n    uv -= vec2(0.5);\n    \n    \n    //vec2 polar = vec2(length(uv), atan(uv.x / uv.y) * 1.14);\n    //uv = polar;\n    \n    \n    uv *= 10.;\n\n    vec3 col = vec3(0.);\n    \n    float numCircles = cos(iTime) * 50.  + 55.;\n    \n\n    vec3 color = vec3(0.5, 0.8, 0.85);\n    \n    \n    for(float i = 0.0; i < 1.0; i += 1.0 / points)\n    {\n        float offset = i * 2.0 * pi;\n    \tcol += circle(uv, 4.0 * vec2(clamp(cos(iTime * 0.0 + offset), -clamping, clamping), \n                                     clamp(sin(iTime * 0.0 + offset), -clamping, clamping)), 0.2, 0.25);\n    }\n    \n    for(float i = 0.0; i < 1.0; i += 1.0 / points)\n    {\n        float offset = i * 2.0 * pi;\n    \tcol += circle(uv, 4.0 * vec2(cos(iTime * 0.0 + offset), \n                                     sin(iTime * 0.0 + offset)), 0.2, 0.25);\n    }\n    \n    col = min(col, 1.0);\n    \n    col *= color;\n    col *= abs(sin(iTime / 4.0)) * 0.4;\n    \n    vec3 col2 = vec3(0.);\n    vec3 color2 = vec3(0.9, 0.8, 0.35);\n    \n    \n    for(float i = 0.0; i < 1.0; i += 1.0 / points)\n    {\n        float offset = i * 2.0 * pi;\n        \n        vec2 square = vec2(clamp(cos(iTime * 0.0 + offset), -clamping, clamping), clamp(sin(iTime * 0.0 + offset), -clamping, clamping));\n        vec2 circlePos = vec2(cos(iTime * 0.0 + offset), sin(iTime * 0.0 + offset));\n        \n    \tcol2 += circle(uv, 4.0 * mix(square, circlePos, sin(iTime)), 0.2, 0.25);\n    }\n    \n    col2 = min(col2, 1.0);\n    col2 *= color2;\n    \n    // Output to screen\n    fragColor = vec4(col2 + col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscBW2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 58, 58, 122], [124, 124, 181, 181, 1852]], "test": "valid"}
{"id": "WscBW4", "name": "SolarSystemSimple", "author": "ToniMateos", "description": "Circles moving", "tags": ["circles"], "likes": 2, "viewed": 337, "published": "Public", "date": "1605075710", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float circleShader(in vec2 p, in vec2 center, in float r, in float blur) \n{\n    vec2 d = p-center;\n    return 1. - smoothstep(r, r + blur, length(d));\n}\n\nvec2 pointInCircle(in vec2 center, in float r, in float angle) \n{\n    return r * vec2( cos(angle), sin(angle)) + center;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = fragCoord/iResolution.xy;\n\n    float earthRadius = 0.03;\n    float moonRadius = 0.01;\n    float sunRadius = 0.09;\n\n    float earthOrbit = 0.3;\n    float moonOrbit = 0.07;\n\n    float earthPeriod = 2.;\n    float moonPeriod = earthPeriod/12.; // moon circles earth approx 12 times per year \n    \n    float noDiffuse = 0.01;\n    float quiteDiffuse = 0.15;\n    \n    // sun\n    vec2 sunCenter = vec2(0.5,0.5);\n    float movingSunRadius = sunRadius * pow(1.0 + 0.02* cos(2.*iTime), 8.0);\n    float sunColor = circleShader(p, pointInCircle(sunCenter, 0.,0.),movingSunRadius, quiteDiffuse);\n    vec3 sun = vec3(sunColor, sunColor, 0.);\n\n    // earth\n    vec2 earthCenter = pointInCircle(sunCenter, earthOrbit, iTime/earthPeriod);\n    float earthColor = circleShader(p, pointInCircle(earthCenter, 0.,0.),earthRadius, noDiffuse);\n    vec3 earth = vec3(0., 0., earthColor);\n\n    // moon\n    vec2 moonCenter = pointInCircle(earthCenter, moonOrbit, iTime/moonPeriod);\n    float moonColor = circleShader(p, moonCenter, moonRadius, noDiffuse);\n\tvec3 moon = vec3(moonColor, moonColor, moonColor);\n    \n    fragColor = vec4(moon+sun+earth,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscBW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 75, 75, 152], [154, 154, 219, 219, 276], [279, 279, 336, 336, 1478]], "test": "valid"}
{"id": "wscBWH", "name": "Melting fractal", "author": "makio135", "description": "Raymarching based on iq template\nPlaying with folding space", "tags": ["raymarching"], "likes": 25, "viewed": 510, "published": "Public API", "date": "1604955949", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//#define u_resolution iResolution\n//#define u_time iTime\n\n#define AA 1\n\n#define MIN_DIST 0.001\n#define MAX_DIST 50.\n\n#define PI 3.141592653589793\n#define TAU 6.283185307179586\n\nfloat sdBox(vec3 p, vec3 b) {\n    vec3 d = abs(p) - b;\n    return length(max(d, 0.0))\n        + min(max(d.x, max(d.y, d.z)), 0.0); // remove this line for an only partially signed sdf \n}\n\nfloat sdRoundCone(in vec3 p, in float r1, float r2, float h) {\n    vec2 q = vec2(length(p.xz), p.y);\n\n    float b = (r1 - r2) / h;\n    float a = sqrt(1.0 - b * b);\n    float k = dot(q, vec2(-b, a));\n\n    if(k < 0.0) return length(q) - r1;\n    if(k > a * h) return length(q - vec2(0.0, h)) - r2;\n\n    return dot(q, vec2(a, b)) - r1;\n}\n\nfloat opUnion(float d1, float d2) {\n    return min(d1, d2);\n}\n\nvec2 opUnion(vec2 d1, vec2 d2) {\n    return d1.x < d2.x ? d1 : d2;\n}\n\nvec3 opSymXYZ(vec3 p) {\n    p = abs(p);\n    return p;\n}\n\nfloat easeInOutQuad(float t) {\n    if ((t *= 2.0) < 1.0) {\n        return 0.5 * t * t;\n    } else {\n        return -0.5 * ((t - 1.0) * (t - 3.0) - 1.0);\n    }\n}\n\n// from https://github.com/doxas/twigl\nmat3 rotate3D(float angle, vec3 axis){\n    vec3 a = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float r = 1.0 - c;\n    return mat3(\n        a.x * a.x * r + c,\n        a.y * a.x * r + a.z * s,\n        a.z * a.x * r - a.y * s,\n        a.x * a.y * r - a.z * s,\n        a.y * a.y * r + c,\n        a.z * a.y * r + a.x * s,\n        a.x * a.z * r + a.y * s,\n        a.y * a.z * r - a.x * s,\n        a.z * a.z * r + c\n    );\n}\n\nvoid mengerFold(inout vec3 z) {\n    float a = min(z.x - z.y, 0.0);\n    z.x -= a;\n    z.y += a;\n    a = min(z.x - z.z, 0.0);\n    z.x -= a;\n    z.z += a;\n    a = min(z.y - z.z, 0.0);\n    z.y -= a;\n    z.z += a;\n}\n\nvoid boxFold(inout vec3 z, vec3 r) {\n    z.xyz = clamp(z.xyz, -r, r) * 2.0 - z.xyz;\n}\n\n\nfloat glow = 0.;\nvec2 sceneSDF(vec3 p) {\n    float t = iTime * .1;\n    t = easeInOutQuad(mod(t, 1.));\n    vec2 d = vec2(10e5, 0);\n\n    for(int i = 0; i < 5; i++) {\n        p = opSymXYZ(p);\n        mengerFold(p);\n        boxFold(p, vec3(.5));\n        p.x -= .2;\n        p *= rotate3D(t * TAU, vec3(1, 1, 0));\n        p *= .95;\n        p *= rotate3D(-t * TAU, vec3(0, 1, 1));\n\n        float dd = sdRoundCone(p, 1.6, .1, 1.6);\n        if(i == 3) glow += 0.006 / (0.01 + dd * dd * 5.) / (float(AA * AA) * 10.);\n    }\n    d = opUnion(d, vec2(sdBox(p, vec3(.8, .1, .1)), 2.));\n\n    return d;\n}\n\n\n// Compute camera-to-world transformation.\nmat3 setCamera(in vec3 ro, in vec3 ta, float cr) {\n    vec3 cw = normalize(ta - ro);\n    vec3 cp = vec3(sin(cr), cos(cr), 0.0);\n    vec3 cu = normalize(cross(cw,cp));\n    vec3 cv = normalize(cross(cu,cw));\n    return mat3(cu, cv, cw);\n}\n\n// Cast a ray from origin ro in direction rd until it hits an object.\n// Return (t,m) where t is distance traveled along the ray, and m\n// is the material of the object hit.\nvec2 castRay(in vec3 ro, in vec3 rd) {\n    float tmin = MIN_DIST;\n    float tmax = MAX_DIST;\n\n    #if 0\n    // bounding volume\n    float tp1 = (0.0 - ro.y) / rd.y; \n    if(tp1 > 0.0) tmax = min(tmax, tp1);\n    float tp2 = (1.6 - ro.y) / rd.y; \n    if(tp2 > 0.0) { \n        if(ro.y > 1.6) tmin = max(tmin, tp2);\n        else tmax = min(tmax, tp2 );\n    }\n    #endif\n\n    float t = tmin;\n    float m = -1.0;\n    for(int i = 0; i < 100; i++) {\n        float precis = 0.0005 * t;\n        vec2 res = sceneSDF(ro + rd * t);\n        if(res.x < precis || t > tmax) break;\n        t += res.x;\n        m = res.y;\n    }\n\n    if(t > tmax) m =- 1.0;\n    return vec2(t, m);\n}\n\n\n// Cast a shadow ray from origin ro (an object surface) in direction rd\n// to compute soft shadow in that direction. Returns a lower value\n// (darker shadow) when there is more stuff nearby as we step along the shadow ray.\nfloat softshadow(in vec3 ro, in vec3 rd, in float mint, in float tmax) {\n    float res = 1.0;\n    float t = mint;\n    for(int i = 0; i < 16; i++) {\n        float h = sceneSDF(ro + rd * t).x;\n        res = min(res, 8.0 * h / t);\n        t += clamp(h, 0.02, 0.10);\n        if(h < 0.001 || t > tmax) break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec3 calcNormal(in vec3 pos) {\n    // epsilon = a small number\n    vec2 e = vec2(1.0, -1.0) * 0.5773 * 0.0005;\n\n    return normalize(\n        e.xyy * sceneSDF(pos + e.xyy).x + \n        e.yyx * sceneSDF(pos + e.yyx).x + \n        e.yxy * sceneSDF(pos + e.yxy).x + \n        e.xxx * sceneSDF(pos + e.xxx).x\n    );\n}\n\n// compute ambient occlusion value at given position/normal\nfloat calcAO(in vec3 pos, in vec3 nor) {\n    float occ = 0.0;\n    float sca = 1.0;\n    for(int i = 0; i < 5; i++) {\n        float hr = 0.01 + 0.12 * float(i) / 4.0;\n        vec3 aopos = nor * hr + pos;\n        float dd = sceneSDF(aopos).x;\n        occ += -(dd - hr) * sca;\n        sca *= 0.95;\n    }\n    return clamp(1.0 - 3.0 * occ, 0.0, 1.0);\n}\n\n\nvec3 computeColor(vec3 ro, vec3 rd, vec3 pos, float d, float m) {\n    vec3 nor = calcNormal(pos);\n    vec3 ref = reflect(rd, nor); // reflected ray\n\n    // material\n    vec3 col = vec3(202, 82, 68)/255.;\n\n    // lighting        \n    float occ = calcAO(pos, nor); // ambient occlusion\n    vec3 lig = normalize(vec3(-0.4, 0.7, -0.6)); // sunlight\n    float amb = clamp(0.5 + 0.5 * nor.y, 0.0, 1.0); // ambient light\n    float dif = clamp(dot(nor, lig), 0.0, 1.0); // diffuse reflection from sunlight\n    // backlight\n    float bac = clamp(dot(nor, normalize(vec3(-lig.x, 0.0, -lig.z))), 0.0, 1.0) * clamp(1.0 - pos.y, 0.0, 1.0);\n    float dom = smoothstep(-0.1, 0.1, ref.y); // dome light\n    float fre = pow(clamp(1.0 + dot(nor, rd), 0.0, 1.0), 2.0); // fresnel\n    float spe = pow(clamp(dot(ref, lig), 0.0, 1.0), 16.0); // specular reflection\n\n    dif *= softshadow(pos, lig, 0.02, 2.5);\n    dom *= softshadow(pos, ref, 0.02, 2.5);\n\n    vec3 lin = vec3(0.0);\n    lin += 1.30 * dif * vec3(1.00, 0.80, 0.55);\n    lin += 2.00 * spe * vec3(1.00, 0.90, 0.70) * dif;\n    lin += 0.40 * amb * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.50 * dom * vec3(0.40, 0.60, 1.00) * occ;\n    lin += 0.50 * bac * vec3(0.25, 0.25, 0.25) * occ;\n    lin += 0.25 * fre * vec3(1.00, 1.00, 1.00) * occ;\n    col = col * lin;\n\n    return col;\n}\n\n\n// Figure out color value when casting ray from origin ro in direction rd.\nvec3 render(in vec3 ro, in vec3 rd) { \n    // cast ray to nearest object\n    vec2 res = castRay(ro, rd);\n    float distance = res.x; // distance\n    float materialID = res.y; // material ID\n\n    vec3 col = vec3(0.6 - length((gl_FragCoord.xy - iResolution.xy / 2.) / iResolution.x));;\n        if(materialID > 0.0) {\n            vec3 pos = ro + distance * rd;\n            col = computeColor(ro, rd, pos, distance, materialID);\n        }\n    return vec3(clamp(col, 0.0, 1.0));\n}\nvoid init() {}\n\nvec3 effect(vec3 c) {\n    c += glow * vec3(242, 223, 126)/255.;\n    return c;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    // Ray Origin)\\t\n    vec3 ro = vec3(-5, 2.5, -6) * 2.2 * rotate3D(iTime * .05 * TAU, vec3(0, 1, 0));\n    vec3 ta = vec3(0.0);\n    // camera-to-world transformation\n    mat3 ca = setCamera(ro, ta, 0.0);\n\n    vec3 color = vec3(0.0);\n\n    #if AA>1\n    for(int m = 0; m < AA; m++)\n        for(int n = 0; n < AA; n++) {\n            // pixel coordinates\n            vec2 o = vec2(float(m), float(n)) / float(AA) - 0.5;\n            vec2 p = (-iResolution.xy + 2.0 * (fragCoord.xy + o)) / iResolution.y;\n            #else\n            vec2 p = (-iResolution.xy + 2.0 * fragCoord.xy) / iResolution.y;\n            #endif\n\n            // ray direction\n            vec3 rd = ca * normalize(vec3(p.xy, 2.0));\n\n            // render\\t\n            vec3 col = render(ro, rd);\n\n            color += col;\n            #if AA>1\n        }\n    color /= float(AA*AA);\n    #endif\n\n    color = effect(color);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscBWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[178, 178, 207, 207, 364], [366, 366, 428, 428, 699], [701, 701, 736, 736, 762], [764, 764, 796, 796, 832], [834, 834, 857, 857, 889], [891, 891, 921, 921, 1051], [1053, 1092, 1130, 1130, 1539], [1541, 1541, 1572, 1572, 1751], [1753, 1753, 1789, 1789, 1838], [2431, 2474, 2524, 2524, 2710], [2712, 2886, 2924, 2924, 3547], [3550, 3773, 3845, 3845, 4117], [4119, 4197, 4227, 4259, 4508], [4510, 4570, 4610, 4610, 4916], [4919, 4919, 4984, 4984, 6235], [6238, 6313, 6350, 6385, 6788], [6789, 6789, 6802, 6802, 6803], [6805, 6805, 6826, 6826, 6884]], "test": "valid"}
{"id": "WscBz2", "name": "cheap sine noise", "author": "johan2", "description": "cheap sine noise looks detailed because of the twist that is added at each iteration. Twist is animated to show its effect", "tags": ["noise", "sines"], "likes": 11, "viewed": 207, "published": "Public", "date": "1605517159", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//identity rotated GOLDEN_ANGLE around x, then around y\n#define m3 mat3(-0.73736, 0.45628, 0.49808, 0, -0.73736, 0.67549, 0.67549, 0.49808, 0.54371)\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float twist = sin(iTime * 0.3) * 2.;\n    vec2 uv = fragCoord/iResolution.y;\n    vec3 q = vec3(uv * 6.2831, iTime * .2);\n    float a = 1.;\n   \tvec3 c = vec3(0);\n    for(int i = 0; i <8; i++){\n        q = m3 * q; \n        vec3 s = sin( q.zxy / a) * a;\n        q += s * twist;\n        c += s;\n        a *= .75;\n    }\n    fragColor = vec4(c * .17 + .5, 1.);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscBz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[150, 150, 207, 207, 567]], "test": "valid"}
{"id": "wscBz8", "name": "Sine Ripples", "author": "oneshade", "description": "A shader I did for fun after I saw one of the Coding Train's challenge's.", "tags": ["ripples", "sinewave"], "likes": 3, "viewed": 85, "published": "Public", "date": "1604332182", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    uv *= 15.0;\n\n    float size = 0.25 + 0.25 * sin(length(floor(uv) * 0.5) - iTime);\n    color += smoothstep(0.1, 0.0, length(fract(uv) - 0.5) - size);\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscBz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 349]], "test": "valid"}
{"id": "wscBzS", "name": "waving colors 3", "author": "elenzil", "description": "yep.", "tags": ["tags", "comma", "separated"], "likes": 3, "viewed": 193, "published": "Public API", "date": "1605403512", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float aspect;\nfloat phTex;\n    \n// http://iquilezles.org/www/articles/palettes/palettes.htm for more information\nvec3 pal( in float t, in vec3 a, in vec3 b, in vec3 c, in vec3 d )\n{\n    return a + b*cos( 6.28318*(c*t+d) );\n}\n\nvec3 palette(float t) {\n    vec3 c = pal(t, vec3(0.5,0.5,0.5),vec3(0.5,0.5,0.5),vec3(1.0,1.0,1.0),vec3(0.0,0.33,0.67));\n    c = c * 0.9 + 0.1;\n    return c;\n}\n\nvec3 color(float u1, float u2, float v) {\n    vec2 uv = vec2(u1 * iResolution.x / 256.0, v * iResolution.y / 256.0 - iTime * 0.0002 * phTex * iResolution.y);\n    float noise = (0.5 + 0.7 * texture(iChannel0, uv).x);\n    vec3 c = palette(u2);\n    return c * mix(1.0, noise, phTex);\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    aspect = iResolution.x / iResolution.y;\n        \n    // artificial down-resing to test AA\n    const float pixelate = 1.0; //  + (sin(iTime) * 0.5 + 0.5) * 14.0;\n    \n    fragCoord = round(fragCoord / pixelate);\n    \n    vec2 res = ceil(iResolution.xy / pixelate);\n    \n    vec2 uv = fragCoord/res.xy;\n    \n    const int bins = int(40.0 / pixelate);\n\n    vec3 col = vec3(0.0);\n    \n    // phased-in behavior\n    float phWig = smoothstep(3.0, 15.0, iTime);\n    float phBin = smoothstep(6.0, 18.0, iTime);\n    float phTap = smoothstep(9.0, 30.0, iTime);\n    float phPin = smoothstep(0.0, 15.0, iTime);\n          phTex = smoothstep(1.0, 09.0, iTime);\n    float phCol = smoothstep(9.0, 45.0, iTime);\n    \n    float accum = 0.0;\n\n    // horizontal AA amount\n    float binEdge = 4.0 / res.x;\n\n    \n    for (int bin = 0; bin < bins; ++bin) {\n        float binMid = (float(bin) + 0.5)/float(bins);\n        float t = uv.x;\n        \n        // taper the overall thing\n        t = ((t - 0.5) * (1.0 + pow(uv.y, 0.8) * 0.3 * phPin)) + 0.5;\n        \n        // wiggle the things\n        float fmod = sin(binMid * 3.0 - iTime * 0.31) * 0.5 + 0.5;\n        t += abs(uv.x - 0.5) * phWig * uv.y * 0.2 * sin(uv.y * 20.0 - iTime * (1.0 + phBin * binMid + 0.6) + fmod);\n        \n        // wiggle the overall thing a tiny bit\n        t += 0.01 * phWig * uv.y * sin(uv.y * 7.0 - iTime);\n        \n        float binWidth = 1.0 / float(bins) * (1.0 - phTap * uv.y * 0.75);\n        float binBeg = binMid - binWidth * 0.5;\n        float binEnd = binMid + binWidth * 0.5;\n        if (t >= binBeg - binEdge && t < binEnd + binEdge) {\n            // AA:\n            float amount = 1.0;\n            if (t < binBeg) {\n                amount = smoothstep(binBeg - binEdge, binBeg, t);\n            }\n            else if (t > binEnd) {\n                amount = 1.0 - smoothstep(binEnd, binEnd + binEdge, t);\n            }\n            \n            float uvyMod = mod(float(bin), 2.0) * 2.0 - 1.0;\n            float st1 = sin(iTime * 0.04) * 0.5 + 0.5;\n            float tMod = 1.0 * mix(1.0, uvyMod, phCol * st1);\n            vec3 c = color(t, t + tMod, uv.y * uvyMod);\n            c = mix(c, vec3(0.2), uv.y * 0.9 * phTex);\n    \t\tcol += c * amount;\n            accum += amount;\n        }\n        binBeg = binEnd;\n    }\n    \n    col /= max(accum * 1.0, 1.0);\n    \n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [{"id": "4dXGzn", "previewfilepath": "/media/ap/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/0c7bf5fe9462d5bffbd11126e82908e39be3ce56220d900f633d58fb432e56f5.png", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscBzS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[32, 113, 181, 181, 224], [226, 226, 249, 249, 384], [386, 386, 427, 427, 668]], "test": "error"}
{"id": "WscBzX", "name": "Flying fireflies", "author": "SimpleMurad", "description": "Flaying sphere in field", "tags": ["spheres"], "likes": 6, "viewed": 201, "published": "Public", "date": "1605619621", "time_retrieved": "2021-10-01T00:00:00", "image_code": "# define radius 0.02\n# define sphere_Counts 20.0\n\nfloat N21(vec2 p) {\n\tvec3 a = fract(vec3(p.xyx) * vec3(213.897, 653.453, 253.098));\n    a += dot(a, a.yzx + 79.76);\n    return fract((a.x + a.y) * a.z);\n}\n\nvec2 N22(vec2 p){\n    float n = N21(p);\n    return vec2(n,N21(n+p));\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/(iResolution.xy /2.0)-1.0;\n\tuv.x *= iResolution.x/iResolution.y;\n    \n    vec3 pointLight;\n    for (float i=0.0; i<sphere_Counts; i+=1.0)\n    {\n        vec2 rnd = N22(vec2(i,i*2.0));\n    \tvec2 point = vec2(cos(iTime*rnd.x+i)*2.0,sin(iTime*rnd.y+i));\n    \tfloat distanceToPoint = distance(uv, point);\n    \tpointLight += vec3(radius/distanceToPoint)*vec3(sin(iTime+i)/2.5+0.7);\n    }\n    pointLight *= vec3(0.3,0.3,1.0);\n    \n    /*\n    vec3 pointLight2;\n    for (float i=60.0; i<80.0;i+=1.0)\n    {\n        vec2 rnd = N22(vec2(i,i+2.0));\n    \tvec2 point = vec2(cos(iTime*rnd.x+i)*1.5,sin(iTime*rnd.y+i));\n    \tfloat distanceToPoint = distance(uv, point);\n    \tpointLight2 += vec3(radius/distanceToPoint) * vec3(clamp(sin(iTime+i)/2.0+0.6,0.1,1.0));\n    }\n    pointLight2 *= vec3(0.5,0.8,0.5);\n   \tpointLight += pointLight2;\n    */\n    \n    fragColor = vec4(pointLight,1.0);\n}\n\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WscBzX.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 69, 69, 204], [206, 206, 223, 223, 276], [279, 279, 336, 336, 1234]], "test": "valid"}
{"id": "wscfD2", "name": "bicolor multicolor metaballs", "author": "Mischawake", "description": "combining multicolored metaballs with light based bicoloring", "tags": ["metaballs"], "likes": 6, "viewed": 96, "published": "Public", "date": "1606005323", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define hsv2rgb(h) clamp( abs(mod( h*6.+vec3(0,4,2), 6.)-3.)-1., 0., 1. )\n\nfloat calcInfluence( vec4 ball, vec2 uv)\n{ \n    float d = distance(ball.rg, uv);\n    float inf = pow( ball.b/d, 3.0);\n    return  inf;   \n}\n\nfloat calcHeight( vec4 ball, vec2 uv )\n{\n \n   float d = distance(ball.rg, uv)/ball.b;\n   float h = pow( 1. - pow( d, 2.), 1./3. );\n   return h;\n    \n}\n\nvec3 calcNormal( vec4 ball, vec2 uv )\n{\n   \n    float eps = 0.00001;\n    \n    vec3 xp = vec3( uv.x + eps, uv.y, calcHeight( ball, vec2(uv.x + eps, uv.y) ) \n                   - vec3( uv.x - eps, uv.y, calcHeight( ball, vec2(uv.x - eps, uv.y) )  ) );\n    vec3 yp = vec3( uv.x, uv.y + eps, calcHeight( ball, vec2( uv.x, uv.y + eps) ) \n                   - vec3( uv.x, uv.y - eps, calcHeight( ball, vec2(uv.x, uv.y - eps) ) ) );\n    \n    return cross( xp, yp );\n}\n\n\nvec3 calcOldNormal( vec4 ball, vec2 uv )\n{\n    return vec3( ball.rg - uv, 0.12);      \n}\n\nvec3[] colors = vec3[]\n(   \n\n    hsv2rgb(273.0/360.0),\n   \thsv2rgb(0.022),\n    hsv2rgb(0.475),\n    hsv2rgb(306.0/360.0)\n);\n\n//for gradient?\nvec3[] colors2 = vec3[]\n(   \n\n\thsv2rgb(187.0/360.0),\n   \thsv2rgb(54.0/360.0),\n    hsv2rgb(26.0/360.0),\n    hsv2rgb(71.0/360.0)\n    \n);\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.y;\n    uv.x -= 0.333;\n    vec4 mouse = iMouse / iResolution.yyyy;\n    mouse.x -= 0.333;\n    \n    \n    //settings to play with!\n    float threshold = 1.0;\n    float specularIntensity = 0.35;\n    float specularPower = 3000.0;\n    float rimIntensity = 60.0; //2\n    float rimPower = 4.0;\n    float aoIntensity = 0.6;\n    float ambientBrightness =  0.25;\n    float lightBrightness = 0.5;\n    float splashBrightness = 0.25;\n    float radiosity = 1.0;\n \n    \n    vec3 ambientColor = vec3(1.0);//hsv2rgb( 0.5 + iTime / 200.0 );\n    \n    vec3 lightColor = vec3(1.0);//hsv2rgb( iTime / 100.0 );\n    \n    bool rainbowMode = false;\n    \n\n   \t//balls\n    float rad = 0.1;\n    float rf = 0.;//0.005;\n    float jiggle = 0.;//sin(iTime*(2.0)) * 0.0125;\n    \n    vec4[] balls = vec4[]\n    (\n        \n        vec4(0.0 + jiggle,0.2 + jiggle, rad + sin(iTime * 4.) * rf, 3.),\n        vec4(0.0 - jiggle,0.4,rad + sin(iTime * 4. + 1.) * rf, 3.),\n        vec4(0.0,0.6 + jiggle,rad + sin(iTime * 4. + 2.) * rf, 2.),\n        vec4(0.0 + jiggle,0.8 + jiggle,rad + sin(iTime * 4. + 1.) * rf, 2.),\n        \n        vec4(0.2 + jiggle,0.2 + jiggle, rad + sin(iTime * 4.) * rf, 0.),\n        vec4(0.2 - jiggle,0.4,rad + sin(iTime * 4. + 1.) * rf, 3.),\n        vec4(0.2,0.6 + jiggle,rad + sin(iTime * 4. + 2.) * rf, 3.),\n        vec4(0.2 + jiggle,0.8 + jiggle,rad + sin(iTime * 4. + 1.) * rf, 0.),\n\n        vec4(0.4 + jiggle,0.2 - jiggle,rad + sin(iTime * 4. + 3.) * rf, 0.),\n        vec4(0.4 + jiggle,0.4,rad + sin(iTime * 4. + 4.) * rf, 2.),\n        vec4(0.4,0.6 + jiggle,rad + sin(iTime * 4. + 5.) * rf, 0.),\n        vec4(0.4 - jiggle * 3.,0.8+jiggle,rad + sin(iTime * 4. + 6.) * rf, 0.),\n\n        vec4(0.6,0.2 - jiggle,rad + sin(iTime * 4. + 7.) * rf, 1.),\n        vec4(0.6,0.4 - jiggle,rad + sin(iTime * 4. + 8.) * rf, 2.),\n        vec4(0.6 - jiggle,0.6 - jiggle,rad + sin(iTime * 4. + 9.) * rf, 2.),\n        vec4(0.6,0.8 - jiggle,rad + sin(iTime * 4. + 10.) * rf, 1.),\n\n        vec4(0.8 + jiggle,0.2 + jiggle,rad + sin(iTime * 4. + 11.) * rf, 2.),\n        vec4(0.8 + jiggle,0.4 - jiggle,rad + sin(iTime * 4. + 12.) * rf, 2.),\n        vec4(0.8,0.6 + jiggle,rad + sin(iTime * 4. + 13.) * rf, 1.),    \n        vec4(0.8,0.8 - jiggle,rad + sin(iTime * 4. + 14.) * rf, 1.),\n        \n        vec4(1.0 + jiggle,0.2 + jiggle,rad + sin(iTime * 4. + 11.) * rf, 2.),\n        vec4(1.0 + jiggle,0.4 - jiggle,rad + sin(iTime * 4. + 12.) * rf, 2.),\n        vec4(1.0,0.6 + jiggle,rad + sin(iTime * 4. + 13.) * rf, 1.),    \n        vec4(1.0,0.8 - jiggle,rad + sin(iTime * 4. + 14.) * rf, 0.),\n\n        vec4( mouse.xy,rad, 2.),\n        vec4( 0.95 * abs(vec2(sin(iTime*0.2345), cos(iTime*0.1234))), rad, 1.)\n        \n     );\n    \n    int ballCount = 26;\n    \n    int accumulatorCount = 4;\n    float[] accumulators = float[]\n    (\n    \t0.0,\n        0.0,\n        0.0,\n        0.0\n    );\n    \n    vec3[] normals = vec3[]\n    (\n    \tvec3(0),\n        vec3(0),\n        vec3(0),\n        vec3(0)\n    );\n    \n    vec2[] pos = vec2[]\n    (\n    \tvec2(0),\n        vec2(0),\n        vec2(0),\n        vec2(0)\n    );\n    \n    \n    int i;\n    //determine color with greatest influence\n    for( i = 0; i < ballCount; i++ )\n    {\n        int idx = int( balls[i].a );\n        float inf = calcInfluence( balls[i], uv );\n        accumulators[idx] += inf;\n        normals[idx] += calcOldNormal( balls[i], uv) * min(10.0, inf );\n        pos[idx] += (balls[i].rg - uv) * inf;\n    }\n    \n    float maxInf = 0.0;\n    int maxIdx = 0;\n    vec3 avgColor = vec3(0,0,0);\n    float totalInf = 0.0;\n    \n    for( i = 0; i < accumulatorCount; i++ )\n    {\n        if( accumulators[i] > maxInf )\n        {\n            maxInf = accumulators[i];\n            maxIdx = i;\n        }\n        \n        totalInf += accumulators[i];\n        avgColor += accumulators[i] * colors[i];\n    }\n    \n    avgColor /= totalInf;\n    \n    float influence = accumulators[maxIdx];\n    vec3 baseColor = colors[maxIdx];\n    \n  \tvec3 highlightColor = colors2[maxIdx];\n    \n    vec3 normal = normalize( normals[maxIdx] );\n   \n    \n    vec3 lightDirection = normalize( vec3(0.0,-1.0,-1.0));\n    \n    vec3 splashDirection = normalize( vec3(-1.0,-1.0,-1.0) ); \n    \n\n    vec3 color = vec3(1.0);\n    \n    vec3 ambient = ambientBrightness * ambientColor;\n   \n    \n    float lightDot = max(0.,dot( -normal, lightDirection) );\n    float splashDot = max(0.,dot( -normal, splashDirection) );\n  \n    \n    //splash\n    float splash = pow( splashDot, 2.0 );\n   \n    \n    //diffust\n    \n    vec3 diffuse1 = lightDot * lightBrightness * lightColor;\n    vec3 diffuse2 = splashDot * splashBrightness * vec3(1.0);\n\n    \n    // specular blinn phong\n    vec3 dir = normalize(lightDirection + vec3(0,0,-1.0) );\n    float specAngle = max(dot(dir, -normal), 0.0);\n    float spec = pow(specAngle, specularPower);\n    vec3 specular = lightColor * spec * specularIntensity;\n    \n  \n    //rim light\n    float rim = 1.0 - (dot ( vec3(0.,0.,-1.), -normal));\n    vec3 rimLight = vec3(1.0) * rimIntensity * pow (rim, rimPower);\n    \n    vec3 combinedBase = baseColor * (1. - splash) + splash * highlightColor;\n    \n\t//radiosity\n    combinedBase = mix( combinedBase, avgColor, rim * radiosity);\n    \n    color = (ambient + diffuse1 + diffuse2 + specular + rimLight) * combinedBase;\n    \n    //ao\n    float prox = (maxInf/totalInf);\n    prox = pow( smoothstep( 1.0, 0.35, prox), 3.0 );\n    vec3 aoColor = vec3(0.0);\n    color = mix( color , aoColor, prox * aoIntensity);\n    \n\t//shape\n    float aa = min( fwidth( influence ) * 1.5, 1.);\n   \tfloat smo = smoothstep( 0., aa, influence - threshold);\n    color = mix( ambientColor * ambientBrightness * 0.1, color, smo);\n\n    \n   \tcolor = pow( color, vec3(2.2) );\n    \n    \n    fragColor = vec4( color, 1.0 );\n    \n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscfD2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[75, 75, 117, 117, 214], [216, 216, 256, 256, 366], [368, 368, 407, 407, 828], [831, 831, 873, 873, 919]], "test": "error"}
{"id": "wscfzX", "name": "Sound visualizer with hexagons", "author": "levonchic", "description": "Remake for this one https://www.shadertoy.com/view/Xdsfzj \nA bit refactored with more detailed options and tweaks and no buffers", "tags": ["sound", "visualizer", "geometry"], "likes": 3, "viewed": 175, "published": "Public API", "date": "1605655352", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// MIT License (c) bitrate16\n// Decorative settings\n#define BAR_HEIGHT        0.75        // Bar height (0.0 ~ 1.0)\n#define BAR_PERIOD        8           // Bar stepping\n#define BAR_WIDTH         8           // Bar height\n#define BAR_COLOR         vec4(1.0)   // Bar colors\n\t\t\t\t\t\t\t\t\t  // Triangle color\n#define BG_TRIANGLE       vec4(-.065) \n\t\t\t\t\t\t\t\t\t  // Primary background color\n#define BG_COL            vec4(0.065) \n\t\t\t\t\t\t\t\t\t  // Secondary background color\n#define BG_NCOL           vec4(0.005) \n#define BG_GRADIENT_START 0.49        // Gradient effect start value\n#define BG_GRADIENT_SCALE 0.45        // Gradient effect scale\n\n// Input settings\n#define IN_SOUND          0.25        // Sound probe coord (0.25 - Frequences, 0.75 - Raw wave)\n#define IN_TRIANGLE       0.25        // Sound probe for triangle shake (0.25 - Frequences, 0.75 - Raw wave)\n#define IN_TRIANGLE_HOR   0.0         // Sound x probe for triangle shake (For x)\n#define IN_TRIANGLE_SCALE 0.8         // Scale of triangle shake\n\n// Hexagonal prefences\n#define HEX_0_SPEED  1.0 // Speed of Hexagon 0 (Inner)\n#define HEX_1_SPEED -0.5 // Speed of Hexagon 1\n#define HEX_2_SPEED  0.6 // ...\n#define HEX_3_SPEED -0.7 // ...\n#define HEX_4_SPEED  0.8 // ...\n#define HEX_5_SPEED -0.9 // ...\n#define HEX_6_SPEED  1.0 // ...\n#define HEX_7_SPEED -1.1 // ...\n\n// Left/Right alignment\nfloat signv(vec2 p1, vec2 p2, vec2 p3) {\n    return (p1.x - p3.x) * (p2.y - p3.y) - (p2.x - p3.x) * (p1.y - p3.y);\n}\n\nbool inTriangle(vec2 p, vec2 pos, float d) {\n    float side2 = d * 0.866025405;\n    vec2 v1 = vec2(pos.x,         pos.y + d);\n    vec2 v2 = vec2(pos.x - side2, pos.y - d / 2.0);\n    vec2 v3 = vec2(pos.x + side2, pos.y - d / 2.0);\n    \n    bool b1, b2, b3;\n    b1 = signv(p, v1, v2) < 0.0;\n    b2 = signv(p, v2, v3) < 0.0;\n    b3 = signv(p, v3, v1) < 0.0;\n    \n    return (b1 == b2) && (b2 == b3);\n}\n\nbool inHexagon(vec2 p, vec2 pos, float d, float a) {\n    float x_ = pos.x - p.x;\n    float y_ = pos.y - p.y;\n    float s_ = sin(a);\n    float c_ = cos(a);\n    float dx = abs(x_ * c_ - y_ * s_)/d;\n    float dy = abs(x_ * s_ + y_ * c_)/d;\n    float ar = 0.25 * sqrt(3.0);\n    return (dy <= ar) && (ar * dx + 0.25 * dy <= 0.5 * ar);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 center = iResolution.xy * 0.5;\n    float centerLength = length(center);\n    float maxResolution = min(iResolution.x, iResolution.y);\n    \n    // Background: 8 hex + triangle + vingette\n    fragColor = vec4(BG_GRADIENT_START - length(fragCoord.xy - center) / centerLength * BG_GRADIENT_SCALE);\n    \n    // 1/3 of maximal dimension of iResolution\n    float d = 0.333 * maxResolution;\n    if(inTriangle(fragCoord, center, d * (0.9 + IN_TRIANGLE_SCALE * texture(iChannel0, vec2(IN_TRIANGLE_HOR, IN_TRIANGLE)).x))) \n        fragColor += BG_TRIANGLE;\n    if(inHexagon(fragCoord, center, d, iTime * HEX_0_SPEED))\n        fragColor += BG_COL;\n    else if(inHexagon(fragCoord, center, d * 2.0, iTime * HEX_1_SPEED))\n        fragColor += BG_NCOL;\n    else if(inHexagon(fragCoord, center, d * 3.0, iTime  * HEX_2_SPEED))\n        fragColor += BG_COL;\n    else if(inHexagon(fragCoord, center, d * 4.0, iTime * HEX_3_SPEED))\n        fragColor += BG_NCOL;\n    else if(inHexagon(fragCoord, center, d * 5.0, iTime  * HEX_4_SPEED))\n        fragColor += BG_COL;\n    else if(inHexagon(fragCoord, center, d * 6.0, iTime * HEX_5_SPEED))\n        fragColor += BG_NCOL;\n    else if(inHexagon(fragCoord, center, d * 7.0, iTime  * HEX_6_SPEED))\n        fragColor += BG_COL;\n    else if(inHexagon(fragCoord, center, d * 8.0, iTime * HEX_7_SPEED))\n        fragColor += BG_NCOL;\n    \n    // Locate bars\n    int ifragX = int(fragCoord.x) - BAR_WIDTH / 2;\n\tint ifragXmod = (ifragX + (BAR_PERIOD + BAR_WIDTH)) % (BAR_PERIOD + BAR_WIDTH);\n    \n    float barXfrag = float(ifragX - ifragXmod);\n    float value = texture(iChannel0, vec2(barXfrag / iResolution.x, IN_SOUND)).x;\n    float res2y = iResolution.y * 0.5;\n        // ifragXmod < BAR_WIDTH && \n    if (ifragXmod < BAR_WIDTH && abs(res2y - fragCoord.y) / res2y < value * BAR_HEIGHT)\n        fragColor += BAR_COLOR;\n}", "image_inputs": [{"id": "XlfSzr", "previewfilepath": "https://soundcloud.com/itzmusicfree/rarkid-moonlapse", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/itzmusicfree/rarkid-moonlapse", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wscfzX.jpg", "access": "shaders20k", "license": "mit", "functions": [[1322, 1346, 1386, 1386, 1462], [1464, 1464, 1508, 1508, 1862], [1864, 1864, 1916, 1916, 2195], [2197, 2197, 2252, 2252, 4099]], "test": "error"}
{"id": "wsdBDH", "name": "Sparking Julia", "author": "IWBTShyGuy", "description": "Sparking Julia", "tags": ["fractal", "julia"], "likes": 2, "viewed": 99, "published": "Public API", "date": "1605035065", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 cmult(vec2 z, vec2 w) {\n\treturn vec2(\n\t\tz.x * w.x - z.y * w.y,\n\t\tz.x * w.y + z.y * w.x\n\t);\n}\n\nvec2 cpow(vec2 z, int n) {\n\tvec2 res = vec2(1.0);\n\tfor (int i = 0; i < n; i++)\n\t\tres = cmult(res, z);\n\treturn res;\n}\n\nfloat julia(vec2 z, vec2 c) {\n\tfloat res = 0.0;\n\tfor (int i = 0; i < 100; i++) {\n\t\tz = cpow(z, 4) + c;\n\t\tif (length(z) > 10.0) break;\n\t\tres += exp(-19.0 * length(z));\n\t}\n\treturn clamp(res, 0.0, 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n\tvec2 uv = fragCoord.xy / iResolution.y;\n    float asp = iResolution.x / iResolution.y;\n    vec2 centralizer = vec2(0.5 * asp, 0.5);\n\tvec2 z = 2.2 * (uv - centralizer);\n\tvec2 c = 0.625 * vec2(cos(iTime * 1.43), sin(iTime * 1.43));\n\tfloat res = julia(z, c);\n\tfragColor = vec4(res, res, res * res, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdBDH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 28, 28, 97], [99, 99, 125, 125, 215], [217, 217, 246, 246, 418], [420, 420, 477, 477, 781]], "test": "valid"}
{"id": "WsdBRr", "name": "Glow eye", "author": "gaz", "description": "2d", "tags": ["2d"], "likes": 10, "viewed": 142, "published": "Public", "date": "1604230453", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI acos(-1.)\n#define TAU PI*2.\n#define hue(t) (cos((vec3(0,2,-2)/3.+t)*TAU)*.5+.5)\n\nvoid rot(inout vec3 p,vec3 a,float t){\n\ta=normalize(a);\n\tvec3 v=cross(a,p),u=cross(v,a);\n\tp=u*cos(t)+v*sin(t)+a*dot(p,a);   \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p=(fragCoord*2.-iResolution.xy)/iResolution.y;\n    p=vec2(atan(p.y,p.x)/PI,length(p));\n    for(float i=0.;i<10.;i++)\n    {\n        vec3 q=vec3(p.x,1.5/p.y-i-fract(-iTime),i);\n        for(int j=0;j<6;j++)\n        {\n            q.xy=abs(q.xy)-.5;\n            q.xz=abs(q.xz)-.2;\n            rot(q,vec3(2,-3,8),iTime*.5+cos(iTime*.2)*.5);\n        }\n\t\tfragColor.xyz+=mix(vec3(1),hue(i*.2+iTime),.8)*.006/abs(q.y);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdBRr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[92, 92, 130, 130, 218], [220, 220, 277, 277, 700]], "test": "valid"}
{"id": "wsdBWj", "name": "Pizza outline", "author": "Peewi", "description": "Pizza outline", "tags": ["learning"], "likes": 0, "viewed": 39, "published": "Public", "date": "1606059360", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Pi, the ratio of a circle's circumference to its diameter.\n\tconst float M_PI = 3.14159265358979323846264338327950288;\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Draw circle\n    vec3 bg = vec3(0.1, 0.1, 0.1);\n    vec3 white = vec3(0.9);\n    vec3 col = bg;\n    //vec2 center = vec2(200.0, iResolution.y - 150.0);\n    vec2 center = iResolution.xy / 2.;\n    float l = length(fragCoord-center);\n    //float radius = ((sin(iTime*3.0)+1.0) * 40.0);\n    float radius = 125.0;\n    float am = (l - radius);\n    col = mix(white, bg, am);\n\n    // Only draw a pizza slice of the circle\n    float startAngle = atan(iMouse.y - center.y, iMouse.x - center.x);\n    float span = (sin(iTime) + 1.) * M_PI;\n    \n    float angle = atan(fragCoord.y - center.y, fragCoord.x - center.x);\n    float aim = startAngle - span / 2.;\n    \n    float range = span / 2.;\n    \n    float arcL = l * angle;\n    float arcLAim = l * aim;\n    float arcRangeLength = l * range;\n    \n    float arcDist = abs(arcL - arcLAim);\n    float halfCircumf = l * M_PI;\n    if(arcDist >= halfCircumf)\n    {\n        arcDist -= halfCircumf * 2.;\n    \tarcDist = abs(arcDist);\n    }\n    float arcDistDist = (arcDist - arcRangeLength);\n    float sdfCombined = max(am, arcDistDist);\n    sdfCombined = abs(sdfCombined)-10.;\n    sdfCombined = clamp(sdfCombined, 0., 1.);\n    col = mix(white, bg, sdfCombined);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdBWj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 123, 1541]], "test": "valid"}
{"id": "WsdBWl", "name": "checkerboard animation 11", "author": "DjinnKahn", "description": "for https://isohedral.ca/swirled-series/", "tags": ["checkerboard"], "likes": 17, "viewed": 178, "published": "Public", "date": "1606261743", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define PI 3.1415926\n\nfloat sqr( float x ) { return x*x; }\n\n//void rayCastSphere( vec3 p, vec3 v, float radius, inout float dist, inout float color )\n//{    \n//\tfloat S = sqr( dot( p, v ) ) - dot( p, p ) + sqr(radius);\n//    if ( S < 0. ) return;\n//    float t0 = -dot( p, v ) - sqrt( S );\n//    float t1 = -dot( p, v ) + sqrt( S );\n//    float t;\n//    if ( t0 >= 0. && t0 < dist )\n//        t = t0;\n//    else if ( t1 >= 0. && t1 < dist )\n//        t = t1;\n//    else \n//        return;\n//    \n//    vec3 hitPt = p + v*t;\n//    dist = t;\n//    color = t*.4;\n//}\n\nfloat easeInOutQuad( float x ) \n{\n\treturn x < 0.5 ? 2. * x * x : 1. - pow(-2. * x + 2., 2.) / 2.;\n}\n\nfloat ease01( float t )\n{\n    t = clamp( t, 0., 1. );\n    return t*t*.5; // want slope=1 at t=1\n}\n\nconst float END_TIME = 3.6;\n\nfloat timelineRaw( float t )\n{\n    float ret = 0.;\n    t = mod( t, END_TIME + .2 );\n    \n    const float EASE_IN_DURATION = .4;\n    const float EASE_OUT_DURATION = .4;\n    const float LINEAR_DURATION = END_TIME - EASE_IN_DURATION - EASE_OUT_DURATION;\n    \n    ret += ease01( t / EASE_IN_DURATION ) * EASE_IN_DURATION;\n    t -= EASE_IN_DURATION;\n    if ( t <= 0. ) return ret;\n    \n    ret += min( t, LINEAR_DURATION );\n    t -= LINEAR_DURATION;\n    if ( t <= 0. ) return ret;\n    \n    ret += ( ease01( 1. ) - ease01( 1. - t / EASE_OUT_DURATION ) ) * EASE_IN_DURATION;\n    return ret;\n}\n\nfloat timeline( float t )\n{\n    return timelineRaw( t ) / timelineRaw( END_TIME ) * END_TIME;\n}\n\n\nvec3 rotY( vec3 p, float angle )\n{\n    return vec3( p.x * cos(angle) + p.z * sin(angle), p.y, p.x * -sin(angle) + p.z * cos(angle) );\n}\nvec3 rotX( vec3 p, float angle )\n{\n    return vec3( p.x, p.y * cos(angle) + p.z * sin(angle), p.y * -sin(angle) + p.z * cos(angle) );\n}\n\nfloat checker( vec2 p ) \n{    \n    return fract( p.x ) >= .5 == fract( p.y ) > .5 ? 0. : 1.; \n}\n\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  return dot(p,n) + h;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n    vec2 q = vec2(length(p.xy)-t.x,p.z);\n    return length(q)-t.y;\n}\n\nconst float CAMERA_Z = -3.;\nconst float FLOOR_POS = 3.5;\nconst float WALL_POS = FLOOR_POS;\n\nfloat sdScene( vec3 p )\n{\n \tfloat sd = sdTorus( p, vec2( .8, .4 ) );\n    sd = min( sd, sdPlane( p, vec3(0.,0.,-1.), FLOOR_POS ) );\n    sd = min( sd, sdPlane( p, vec3(0.,-1.,0.), WALL_POS ) );\n    sd = min( sd, sdPlane( p, vec3(0.,1.,0.), WALL_POS ) );\n    sd = min( sd, sdPlane( p, vec3(0.,0.,1.), WALL_POS ) );\n    return sd;\n}\n\n\nfloat projectChecker( vec3 p )\n{\n    vec3 cameraPos = vec3( 0, 0, CAMERA_Z );\n    float t = ((CAMERA_Z-1.) - p.z) / (cameraPos.z - p.z);\n    vec3 screenUV = p * (1.-t) + cameraPos * t;\n    return checker( screenUV.xy * 4. );\n}\n\nfloat go( vec2 fragCoord, float t )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n    if ( uv.x < -.5 || uv.x >= .5 )\n        return .2;\n        \n    //uv.xy += .5 / iResolution.y;\n    \n    float angle = t*2.*PI;\n    \n    vec3 pos = vec3( 0., 0., CAMERA_Z + sin( angle )*1.1 );\n    vec3 dir = vec3( uv.xy, 1. );\n    pos += dir * max(-1.2 - pos.z, 0.); // ignore walls that we move behind\n    dir = normalize( dir );\n    \n    pos = rotY( pos, sin(angle)*.8 );\n    dir = rotY( dir, sin(angle)*.8 );\n    pos = rotX( pos, angle );\n    dir = rotX( dir, angle );\n    \n           \n    \n    \n    for ( int i = 0; i < 300; i++ )\n    {\n        float dist = sdScene( pos );\n   \t\tpos += dir * dist;\n        if ( dist < .0001 )\n        {\n            const float EPS = .01;\n            //return pos.y / 5.;\n            float f = 4. / (FLOOR_POS-CAMERA_Z);\n            if ( pos.y >= WALL_POS-EPS )\n                return checker( pos.xz * f );\n            if ( pos.y <= -(WALL_POS-EPS) )\n                return checker( pos.xz * f );\n            if ( pos.z <= -(WALL_POS-EPS) )\n                return checker( pos.xy * f );\n            return projectChecker( pos );\n        }\n    }\n    \n    return .4;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tfloat c = go( fragCoord, timeline( iTime ) / END_TIME );\n    \n    int BLUR_N = 4;\n    \n    float colSum = 0.;\n    for ( int i = 0; i < BLUR_N; i++ )\n    {    \n\t\tcolSum += go( fragCoord, ( timeline( iTime + iTimeDelta * float(i) / float(BLUR_N) ) ) / END_TIME ) / float(BLUR_N);\n    }\n\n    fragColor = vec4(vec3(colSum),1.0);\n    //fragColor = vec4(vec3(c),1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdBWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[22, 22, 44, 44, 58], [565, 565, 598, 598, 664], [666, 666, 691, 691, 763], [794, 794, 824, 824, 1379], [1381, 1381, 1408, 1408, 1476], [1479, 1479, 1513, 1513, 1614], [1615, 1615, 1649, 1649, 1750], [1752, 1752, 1778, 1778, 1847], [1849, 1849, 1891, 1891, 1916], [1918, 1918, 1951, 1951, 2020], [2114, 2114, 2139, 2139, 2442], [2445, 2445, 2477, 2477, 2671], [2673, 2673, 2710, 2710, 3880], [3882, 3882, 3939, 3939, 4304]], "test": "valid"}
{"id": "wsdBWS", "name": "Breathing circles clipping dlx", "author": "partyprism", "description": "Forked from https://www.shadertoy.com/view/llKcRc\n\nPlaying with radius, position and color over time.\nAdded a rectangle used as some type of clipping mask.\nColor changes over time, creating an overlay effect.", "tags": ["circles"], "likes": 2, "viewed": 33, "published": "Public", "date": "1605958680", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 circlePos1 = vec2(0.3,0.5);\nvec2 circlePos2 = vec2(0.5,0.5);\nvec2 circlePos3 = vec2(0.6,0.3);\nfloat radius1 = 0.15;\nfloat radius2 = 0.15;\nfloat radius3 = 0.05;\nvec4 FG1 = vec4(0., 0., 1.0,1.0);\nvec4 FG2 = vec4(0.129, 0.588, 0.952,1.0);\nvec4 FG3 = vec4(0.090, 0.411, 0.6,1.0);\nvec4 BG = vec4(0.,0.,0.2, 1.0);\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n vec2 uv = fragCoord.xy / iResolution.xy;\n float aspectRatio = iResolution.y / iResolution.x;\n uv.y = uv.y * aspectRatio;\n \n circlePos1.y = circlePos1.y * aspectRatio;\n circlePos2.y = circlePos2.y * aspectRatio;\n circlePos3.y = circlePos3.y * aspectRatio;\n \n // ndrar radien ver tid fr circle 1+2+3\n radius1 -= sin(iTime) * 0.02;\n radius2 += sin(iTime) * 0.05;\n radius3 += sin(iTime - 1.) * 0.025;\n //radius3 += sin(iTime + 5. / radius1) * 0.01;\n    \n // ndrar frgerna p circel 1+2-3\n FG1 -= FG2.g * sin(iTime);\n FG2 += FG1.b * sin(iTime);\n FG3.r += sin(iTime - 1.) - FG1.r;\n FG1 *= uv.y;\n FG2 *= uv.y;\n FG3 *= uv.y * 2.;\n \n // ndra positionen ver tid fr circle 1+2+3\n //circlePos1 += sin(iTime) * 0.1; \n //circlePos2 -= sin(iTime) * 0.1;\n \n fragColor = mix( FG2, BG, smoothstep(radius2 - 2e-3, radius2, length(circlePos2 - uv)));\n fragColor = mix( FG1, fragColor, smoothstep(radius1 - 2e-3, radius1, length(circlePos1 - uv)));\n fragColor = mix( FG3, fragColor, smoothstep(radius3 - 2e-3, radius3, length(circlePos3 - uv)));\n\n vec2 q = uv - vec2(0.5, 0.5);\n //q += uv - vec2(0.5, 0.5) * cos(iTime);\n float r = 0.21;\n //fragColor *= smoothstep(r, r + 0.015, abs(q.x));\n //fragColor *= 1.0 - (1.0-smoothstep(r,r+0.002, abs(q.x-0.25*sin(2.0*q.y))))*(1.0-smoothstep(0.0,0.1,q.y));\n \n //Den hr gller\n fragColor *= 1.0 - (1.0-smoothstep(r,r+0.002, abs(q.x)))*(2.0-smoothstep(0.0,1.0,q.y));\n //fragColor += fragColor + (FG3 * uv.x * 3.);\n fragColor += fragColor + FG3;\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdBWS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[314, 314, 371, 371, 1857]], "test": "valid"}
{"id": "WsdfDN", "name": "3 Oils", "author": "Edvid", "description": "No description thus far", "tags": ["fragment"], "likes": 0, "viewed": 23, "published": "Public", "date": "1605138552", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec3 nobles[120];\nconst float PI = 3.14159265359;\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\t\n    vec2 dir;\n    for(int i = 0; i < nobles.length(); i++){\n    \tnobles[i] = vec3(\n        \tfract(pow(float(i),1.2)*0.323 + sin(iTime*sin(float(i))*2.0)*0.05),\n            fract(pow(float(i),1.3)*0.456 + cos(iTime*sin(float(i))*2.0)*0.05),\n            fract(float(i) * 2123.2345)\n        );\n        \n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(0.0, 0.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(1.0, 0.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(-1.0, 0.0)),2.0);\n        \n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(0.0, 1.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(1.0, 1.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(-1.0, 1.0)),2.0);\n        \n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(0.0, -1.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(1.0, -1.0)),2.0);\n        dir += vec2(cos(nobles[i].z), sin(nobles[i].z)) / pow(distance(uv, nobles[i].xy + vec2(-1.0, -1.0)),2.0);\n        \n    }\n    \n    vec3 col;\n    \n    if(atan(dir.y, dir.x) < 0.45) col = vec3(1, 0.105, 0.551);\n    else if(atan(dir.y, dir.x) < 0.55)  col = vec3(1.0, 0.852, 0.0);\n    else col = vec3(0.105, 0.699, 1.0);\n        \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdfDN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 107, 162, 1813]], "test": "valid"}
{"id": "WsdfDS", "name": "Sampleless lights 2D", "author": "Daizuukee", "description": "A 2D Light renderer that only uses 2 samples per light source (i know i lied) to create soft shadows", "tags": ["light"], "likes": 6, "viewed": 289, "published": "Public API", "date": "1606330361", "time_retrieved": "2021-10-01T00:00:00", "image_code": "struct light {\n\tvec2 sp, ep;\n    vec4 col;\n    float strength;\n};\n//constructor for lights\nlight lightc(vec2 sp, vec2 ep, vec4 col, float strength) {\n    light outp;\n    outp.sp = sp;\n    outp.ep = ep;\n    outp.col = col;\n    outp.strength = strength;\n    return outp;\n    \n}    \n//constructor for walls\n//(walls have the same properties as lights so it doesnt matter that we use struct light)\nlight lightc(vec2 sp, vec2 ep, vec4 col) {\n    light outp;\n    outp.sp = sp;\n    outp.ep = ep;\n    outp.col = col;\n    outp.strength = 1.;\n    return outp;\n    \n}\n\nbool intersects(vec2 p1, vec2 p2, vec2 p3, vec2 p4) {\n    float det, gamma, lambda;\n  det = (p2.x - p1.x) * (p4.y - p3.y) - (p4.x - p3.x) * (p2.y - p1.y);\n  if (det != 0.) {\n    lambda = ((p4.y - p3.y) * (p4.x - p1.x) + (p3.x - p4.x) * (p4.y - p1.y)) / det;\n    gamma = ((p1.y - p2.y) * (p4.x - p1.x) + (p2.x - p1.x) * (p4.y - p1.y)) / det;\n    return (-0. <= lambda && lambda <= 1.) && (-0.0003 <= gamma && gamma <= 1.0003);\n  }\n    return false;\n}\n\nvec2 intersection(vec2 p1, vec2 n1, vec2 p2, vec2 n2) {\n    float x, y;\n    float slopex1 = n1.y / n1.x;\n    float slopex2 = n2.y / n2.x;\n    float offy1 = p1.y - slopex1 * p1.x;\n    float offy2 = p2.y - slopex2 * p2.x;\n    x = -(offy1 - offy2) / (slopex1 - slopex2);\n    //anti infinity\n    if(n1.x == 0.)\n        x = p1.x;\n    if(n2.x == 0.)\n        x = p2.x;\n    \n    //we cannot use x here since x could be infinity\n    float slopey1 = n1.x / n1.y;\n    float slopey2 = n2.x / n2.y;\n    float offx1 = p1.x - slopey1 * p1.y;\n    float offx2 = p2.x - slopey2 * p2.y;\n    y = -(offx1 - offx2) / (slopey1 - slopey2);\n    //anti infinity\n    if(n1.y == 0.)\n        y = p1.y;\n    if(n2.y == 0.)\n        y = p2.y;\n    return vec2(x,y);\n\t\n}\n//from https://www.shadertoy.com/view/tt23WW\nfloat linedist(vec2 p, vec2 p1, vec2 p2) {\n    vec2 v = p1, w = p2;\n    \n    float l2 = pow(distance(w, v), 2.);\n    if(l2 == 0.0) return distance(p, v);\n    \n    float t = clamp(dot(p - v, w - v) / l2, 0., 1.);\n    vec2 j = v + t * (w - v);\n    \n    return distance(p, j);\n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    //light lines, make sure they DONT overlap with walls\n    int lightcount = 3;\n\tlight lights[3];\n    lights[0] = lightc(vec2(0.1 + sin(iTime) / 5.,0.4 + cos(iTime) / 4.),vec2(-0.0,0.2),vec4(0,0.5,0,0),2.);\n    lights[1] = lightc(vec2(0.5 + sin(iTime) / 5.,-0.4 + cos(iTime) / 4.),vec2(0.5,-0.6),vec4(0.5,0,0,0),2.);\n    lights[2] = lightc(vec2(-0.5 + sin(iTime) / 5.,-0.4 + cos(iTime) / 4.),vec2(-0.5,-0.6),vec4(0,0,0.5,0),2.);\n    //walls, make sure they DONT overlap with lights\n    int wallcount = 2;\n    light walls[2];\n    walls[0] = lightc(vec2(-0.2,0.1),vec2(0.2,0.),vec4(1.));\n    walls[1] = lightc(vec2(-0.5,0.1),vec2(-0.4,0.5),vec4(0.4,1.,0.4,1.));\n    //color enhance (its weird but can look quite cool\n    /*\n    walls[0] = lightc(vec2(-0.2,0.1),vec2(0.2,0.),vec4(-1.));\n    walls[1] = lightc(vec2(-0.5,0.1),vec2(-0.4,0.5),vec4(-20,-4.,-2,1.));\n    */\n    //standard uv\n    vec2 uv = fragCoord / iResolution.xy;\n    uv -= 0.5;\n    //zoom (who could have guessed)\n    uv *= 5.;\n    \n    for(int i = 0; i < lightcount; i++) {\n        vec2 lsp = lights[i].sp;\n        vec2 lep = lights[i].ep;\n        vec4 col = lights[i].col * (lights[i].strength - linedist(uv,lsp,lep)) / lights[i].strength;\n        \n        for(int o = 0; o < wallcount; o++) {\n        \tvec2 wsp = walls[o].sp;\n            vec2 wep = walls[o].ep;\n            \n            vec2 bound1 = min(lsp,lep);\n            vec2 bound2 = max(lsp,lep);\n            \n            //intersections from uv to the wall edges on the light line\n            vec2 inters1 = intersection(uv,normalize(wsp-uv),lsp,normalize(lep-lsp));\n            vec2 inters2 = intersection(uv,normalize(wep-uv),lsp,normalize(lep-lsp));\n            \n            //cannot get bigger shadows than there is a light\n            vec2 p1 = clamp(inters1,bound1,bound2);\n            vec2 p2 = clamp(inters2,bound1,bound2);\n            float dist = distance(p1,p2);\n            \n            //space of light covered by a wall\n            float mult = (1. - (dist) / distance(lep,lsp));\n            \n            //honestly have no idea why this is necessary but it is\n            if(intersects(uv,uv+normalize(lsp-lep)*900.,wsp,wep) || intersects(uv,uv+normalize(lsp-lep)*-900.,wsp,wep))\n                mult = 1.-mult;\n            \n            //no walls hit\n            if(!intersects(uv,p1,wsp,wep) && !intersects(uv,p2,wsp,wep))\n                mult = 1.;\n            col *= 1.-(1.-mult) * walls[o].col;\n            \n            //light line visualization\n            if(linedist(uv,lsp,lep) < 0.01)\n                fragColor += lights[i].col;\n            \n        }\n        fragColor += col;\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdfDS.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[66, 91, 149, 149, 275], [280, 394, 436, 436, 556], [558, 558, 611, 611, 1007], [1009, 1009, 1064, 1064, 1744], [1745, 1790, 1832, 1832, 2065], [2069, 2069, 2126, 2184, 4764]], "test": "valid"}
{"id": "WsdfRB", "name": "Infinite neon tunnel movement", "author": "piootrek", "description": "Through the tunnel.", "tags": ["tunelneonmovementinfinitecirclesparticles"], "likes": 0, "viewed": 88, "published": "Public", "date": "1605446645", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Shader under CC BY 3.0 license\n// Created by piootrek / Piotr Ruszkowski\n// 2020\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord * 2.0 - iResolution.xy) / iResolution.y;\n    uv += (distance(uv, vec2(0.))) * 0.25 * vec2(sin(iTime * 1.73), cos(iTime * 2.67));\n    \n    \n    vec3 color_offset = vec3( 0.2, 0.1, 0.6);\n    vec3 circle_col = (1.0 +  0.5 * sin( iTime + color_offset * 3.14)) * exp(distance(uv, vec2(0.)));\n    \n    uv /= exp(fract(iTime * 2.0));\n    \n    float dist = distance(uv, vec2(0.0));\n    dist = fract(log(dist));\n\n    float out_circle = smoothstep(1.0, 0.9, dist);\n    float in_circle = smoothstep(0.95, 0.89, dist);\n    vec3 circle = circle_col * (out_circle - in_circle);\n    \n    fragColor = vec4(circle * vec3(1.), 0.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdfRB.jpg", "access": "shaders20k", "license": "cc-by-3.0", "functions": [[85, 85, 142, 142, 784]], "test": "valid"}
{"id": "WsdfW8", "name": "Sine Wave Curve Fitting", "author": "oneshade", "description": "Fitting a sine wave between sets of points to create a nice curvy shape.", "tags": ["wave", "sine", "curve", "curvefitting"], "likes": 5, "viewed": 157, "published": "Public", "date": "1604968669", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fits half of a sine wave between two points:\nfloat curve(in vec2 p, in vec2 a, in vec2 b, in float thickness) {\n    if (min(a.x, b.x) < p.x && p.x <= max(a.x, b.x)) {\n        float sine = sin(((p.x - a.x) / (b.x - a.x) * 2.0 - 1.0) * 1.5707963267);\n        float cy = a.y + (0.5 + 0.5 * sine) * (b.y - a.y);\n        return smoothstep(thickness, 0.0, abs(p.y - cy));\n    }\n\n    return 0.0;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y * 4.0;\n    float color = 0.0;\n    vec2[5] points;\n\n    // Calculate points' positions based on the time and draw them:\n    for (int i=0; i < points.length(); i++) {\n        points[i] = vec2(i - points.length() / 2, sin(float(i) - iTime) * (mod(float(i), 2.0) * 2.0 - 1.0));\n        color += smoothstep(0.05, 0.0, length(uv - points[i]) - 0.1);\n    }\n\n    // Draw a curve between pairs of points:\n    for (int i=1; i < points.length(); i++) {\n        color += curve(uv, points[i - 1], points[i], 0.05);\n    }\n\n    fragColor = vec4(vec3(color), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdfW8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 48, 114, 114, 393]], "test": "valid"}
{"id": "wsdfWH", "name": "H Shader", "author": "icaroleles1", "description": "H shader", "tags": ["2dshader"], "likes": 2, "viewed": 22, "published": "Public", "date": "1605029492", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float time = iTime;\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    vec3 col = vec3(0);\n\tuv-=.5;\n\tuv.x*=iResolution.x/iResolution.y;\n\t\n\tuv+=vec2(sin(time*.6)*.25,cos(time*.6)*.25);\n\tfloat x=0.;\n\tfloat y =0.;\n\t\n\tfloat backCircle  =  smoothstep(.3,.29,length(uv -vec2(x,y)));\n//right side\n\tfloat innerCircle1 =0.;\n\tfloat innerCircle2 =0.;\n\tif(uv.x<-.07){\n\tinnerCircle1 = -smoothstep(.28,.26,length(uv));\n\tinnerCircle2 = -smoothstep(.25,.23,length(uv));\n\t}\t\n\t\n\tfloat line = 0.;\n\tif(abs(uv.y)<.264 )\n\tline = -smoothstep(.02,.01,length(uv.x+.06));\n\t\n//left side\n\tfloat innerCircle3 = .0;\n\tfloat innerCircle4 = .0;\n\tfloat line2 = .0;\n\tif(uv.x>.07){\n\tinnerCircle1 = -smoothstep(.28,.26,length(uv));\n\tinnerCircle2 = -smoothstep(.25,.23,length(uv));\n\t}\t\n\t\n\tline2 = .0;\n\tif(abs(uv.y)<.264 )\n\tline2 = -smoothstep(.02,.01,length(uv.x-.06));\n\t\n\tfloat line3 = .0;\n\tif(abs(uv.x)<.05 )\n\tline3 = -smoothstep(.02,.01,length(uv.y));\n\t\n\t\n\t\n\tcol+=line3;\n\tcol+=line;\n\tcol+=line2;\n\tcol+=backCircle * vec3(.845,.59645,.1);\n\tcol+=(innerCircle1-(innerCircle2));\n\t\n\t//col+=innerCircle2;\n\tfragColor = vec4( col, 1.0 );\n    \n    \n    // Time varying pixel color\n\n    // Output to screen\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdfWH.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[4, 4, 61, 61, 1273]], "test": "valid"}
{"id": "wsdfWM", "name": "XOR World", "author": "tombla", "description": "XOR pattern I found in golang tutorial.", "tags": ["xor"], "likes": 1, "viewed": 186, "published": "Public API", "date": "1605302212", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// XOR pattern, from golang tutorial.\nvoid mainImage(out vec4 O, vec2 uv) {\n    vec2 R = iResolution.xy;\n    float T = iTime/3., S=512.;\n    uv /= min(R.x, R.y)/(2.+0.5*sin(T*7.));    \n    ivec2 i = ivec2((uv.x+T)*S,(uv.y+T/2.)*S);\n    O = vec4(0,fract(float(i.x^i.y)/S),0,1);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdfWM.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 38, 75, 75, 278]], "test": "valid"}
{"id": "wsdfzB", "name": "ttp_slider", "author": "alfredo_giani", "description": "a simple slider widget", "tags": ["test"], "likes": 2, "viewed": 54, "published": "Public", "date": "1605656772", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float duration_in_sec = 180.;\nfloat speed = 1.;\n\nfloat current_time = 0.;\n\nint state = 0; // 0:stopped, 1: started\n\n// draw a background for the slider\nfloat slider_width_relative = 0.8;\nfloat slider_height_relative = 0.125;\n\n// geometrical parameters of the thumb\nfloat thumb_ext_width = 0.025 + 0.0125;\nfloat thumb_int_width = 0.025 - 0.0125;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float x_start = 0.5 - slider_width_relative/2.; \n    float x_stop = 0.5 + slider_width_relative/2.; \n\n    float y_start = 0.5 - slider_height_relative/2.; \n    float y_stop = 0.5 + slider_height_relative/2.; \n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n \n    vec3 col;\n    \n\t// slider background\n    if ( uv.x >= x_start &&  uv.x <= x_stop &&  uv.y >= y_start &&  uv.y <= y_stop )\n    {\n        float vert_dist = abs(uv.y -0.5);\n        bool under = uv.y > 0.5;\n        \n        float horiz_dist = abs(uv.x -0.5);\n        bool right = uv.x > 0.5;\n        \n        // drop a shadow at the top and bottom edge of the thumb rail \n        if( vert_dist  < .01)\n        {\n        \tcol = vec3(0.,0.,0.);\n        }\n        else\n        {\n            float w = 2.5*vert_dist/slider_height_relative/2.; \n            col = (1. -w)*vec3(0.2,0.2,0.2) + w*vec3(0.,0.,0.);\n        }\n    }\n    // canvas background\n    else\n    {\n        // Time varying pixel color\n    \tcol = 0.5 + 0.25*cos(0.2*iTime+ uv.xyx+vec3(0.,0.,0.0));\n    }\n\n    // draw thumb\n\n    \n    float thumb_ext_height = 0.135 + 0.0125*iResolution.x/iResolution.y;\n    float thumb_int_height = 0.135 - 0.0125*iResolution.x/iResolution.y;\n\n    float pos_timenorm = mod(speed*iTime, duration_in_sec)/duration_in_sec; // 0...1 duration\n    \n    float thumb_pos_x = pos_timenorm*(x_stop -x_start) + x_start;\n    float thumb_pos_y = 0.5;\n    \n    float th_x_start_ext = thumb_pos_x - .5*thumb_ext_width; \n    float th_x_stop_ext = thumb_pos_x + .5*thumb_ext_width;\n    \n    float th_x_start_int = thumb_pos_x - .5*thumb_int_width; \n    float th_x_stop_int = thumb_pos_x + .5*thumb_int_width;\n    \n    float th_y_start_ext = thumb_pos_y - .5*thumb_ext_height; \n    float th_y_stop_ext = thumb_pos_y + .5*thumb_ext_height;\n    \n    float th_y_start_int = thumb_pos_y - .5*thumb_int_height; \n    float th_y_stop_int = thumb_pos_y + .5*thumb_int_height;\n    \n    \n    vec4 thumb_col = vec4(0., 0., 0., 0.);\n    if ( uv.x >= th_x_start_ext &&  uv.x <= th_x_stop_ext && uv.y >= th_y_start_ext &&  uv.y <= th_y_stop_ext )\n    {\n        vec3 white = vec3(1.,1.,1.);\n        \n        if( uv.x >= th_x_start_int &&  uv.x <= th_x_stop_int &&  uv.y >= th_y_start_int &&  uv.y <= th_y_stop_int )\n        {\n \t\t\tthumb_col = vec4(white, 0.);\n        }\n        else\n        {\n            thumb_col = vec4(white, .5);\n        }\n    }\n    \n    // Thumb's tick\n    if ( abs(uv.x - thumb_pos_x) < 0.002 && uv.y >= th_y_start_ext - 0.01 &&  uv.y <= th_y_stop_ext + 0.01 )\n    {\n        fragColor = vec4(1., 0., 0., 1.);\n    }\n    else\n    {   \n    \tfragColor = vec4( mix(col, thumb_col.rgb, thumb_col.a), 1.);\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsdfzB.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[346, 346, 403, 403, 3097]], "test": "valid"}
{"id": "WsdfzN", "name": "acid circle [EPILEPSY WARNING]", "author": "Osakazaur", "description": "This is crazy pulsing shader, I got dammint headache while writing this.\nThe secret is in st.#53.\nIf you comment out 53st and run 54st, you'll see that it's pulsing circle only.\nCrazy effect is in multiplying two circles with different radius. ", "tags": ["2d", "epilepsy", "crazy", "pulsing"], "likes": 2, "viewed": 69, "published": "Public", "date": "1604520087", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float radius = .5;\nfloat timeScale = 2.;\nfloat pi = 3.14;\n\nfloat step2(float x){\n\treturn x*x;\n}\n\nfloat pulsing(){\n    float fi = fract(iTime)*2.*pi;\n\treturn (1. - cos(fi));\n}\n\nfloat fractured(float offset){\n    float _fractured = fract(iTime*timeScale + offset);\n    _fractured = distance(_fractured, 0.5) * 2.;\n    _fractured = 1. - _fractured;\n    return _fractured;\n}\n\nvec3 nowCol(){\n\treturn vec3(\n        fractured(0.),\n        fractured(0.33),\n        fractured(0.67)        \t\n    );    \n}\n\nvec4 multColor(float m){\n    \n    vec3 nowCol_ = nowCol();\n\treturn vec4(nowCol_.r * m,\n               nowCol_.g * m,\n               nowCol_.b * m,\n               1.);\n}\n\n\nvec4 circle(vec2 center, vec2 pos, float radius){\n    float dec = 15. * pulsing() + 5.;\n    float mult = 1. - distance(sqrt(step2(pos.x - center.x) + step2(pos.y - center.y)), radius) / dec;\n    \n   return multColor(mult);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 xy = fragCoord;\n    \n  \tvec2 center = vec2(iResolution.x * 0.5, iResolution.y * 0.5);\n    radius = iResolution.y * 0.5 * radius;\n    fragColor = circle(center, xy, radius) * circle(center, xy, radius*1.5);\n    //fragColor = circle(center, xy, radius);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsdfzN.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[59, 59, 80, 80, 95], [97, 97, 113, 113, 174], [176, 176, 206, 206, 370], [372, 372, 386, 386, 494], [496, 496, 520, 520, 664], [667, 667, 716, 716, 891], [894, 894, 950, 950, 1213]], "test": "valid"}
{"id": "wsGBRR", "name": "Rings of delusion", "author": "Nrx", "description": "Nothing moves...", "tags": ["optical", "illusion"], "likes": 15, "viewed": 486, "published": "Public API", "date": "1606381166", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspired by: https://twitter.com/jagarikin/status/1331409504953540613\n\n#define PI\t\t\t3.14159265358979\n#define RADIUS\t\t0.5\n#define THICKNESS\t0.1\n#define SPEED\t\t10.0\n#define STRIPS\t\t3.0\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p) {\n\n\t// Normalization of the fragment coordinates\n\tp = (2.0 * p - iResolution.xy) / iResolution.y;\n\tfloat halfPixel = 0.5 * dFdy (p.y);\n\n\t// Background color\n\tfragColor = vec4 (vec3 (0.5 + 0.05 * cos (p.x * 50.0) * cos (p.y * 50.0)), 1.0);\n\n\t// Select the animation\n\tfloat select = floor (6.0 * fract (iTime * 0.03 + step (0.0, p.x) / 3.0));\n\n\t// Display the rings & marker\n\tp.x = abs (p.x) - RADIUS * 1.6;\n\n\tfloat d = length (p) - RADIUS;\n\tfloat a = atan (p.y, p.x);\n\tfloat t = STRIPS * (a + iTime * SPEED);\n\n\tvec4 c = vec4 (1.0, smoothstep (-0.05, 0.05, cos (t)), 0.0, 1.0);\n\tfragColor = mix (fragColor, c, smoothstep (halfPixel, -halfPixel, abs (d) - THICKNESS));\n\n\tfloat m;\n\tfloat f;\n\tif (select < 1.5) {\n\t\tm = abs (length (p) - 0.15 + 0.1 * select);\n\t\tf = 1.0;\n\t\tt -= PI * (0.5 + select);\n\t} else {\n\t\tfloat dir = PI * 0.5 * (select - 2.0);\n\t\tvec2 tip = 0.15 * vec2 (-sin (dir), cos (dir));\n\t\tm = segDist (p, -tip * 0.5, tip);\n\t\tm = min (m, segDist (p, tip, tip * 0.7 + 0.3 * vec2 (tip.y, -tip.x)));\n\t\tm = min (m, segDist (p, tip, tip * 0.7 - 0.3 * vec2 (tip.y, -tip.x)));\n\t\tf = abs (sin (a + dir));\n\t\tt -= PI * 0.5 * sign (dot (p, tip));\n\t}\n\tfragColor.rgb *= smoothstep (-halfPixel, halfPixel, m - 0.02);\n\n\tc.g = smoothstep (-0.05, 0.05, cos (t));\n\tfragColor = mix (fragColor, c, f * smoothstep (halfPixel, -halfPixel, abs (d - THICKNESS) - 2.0 * halfPixel));\n\tc.g = 1.0 - c.g;\n\tfragColor = mix (fragColor, c, f * smoothstep (halfPixel, -halfPixel, abs (d + THICKNESS) - 2.0 * halfPixel));\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsGBRR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[187, 187, 236, 236, 324], [326, 326, 374, 421, 1868]], "test": "valid"}
{"id": "WsGBRW", "name": "faster than light", "author": "Carandiru", "description": "Fork of \"Waves of information\" by CoolerZ. https://shadertoy.com/view/Wd3Bz8", "tags": ["waves", "physics", "cherenkov"], "likes": 2, "viewed": 274, "published": "Public API", "date": "1606626615", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Waves of information\" by CoolerZ. https://shadertoy.com/view/Wd3Bz8\n// 2020-11-29 03:26:02\n\n\n#define STEP .25\n#define XLIM 1.\n#define YLIM 1.\n#define SPEED (10.0f)\n\n#define PI (3.14159265358979323846)\n#define sq(a) (a*a)\n\nfloat cherenkov_radiation(out float b, in float h, in float dt)\n{\n    const float c = 299792458.0f;  // universal constant for speed of light in a vacuum (m/s)\n    const float n = 1.33f; // refraction index of water\n    const float e = 10e5f; // total energy emitted\n    const float q = 24e3f; // energy in a particle\n    \n    // n = refraction index of medium\n    // c/n < v < c  : speed of particle is greater than speed of light\n    //\t\t\t\t  in the medium, but still less than the speed of light in a vacuum\n    // B = v/c\t\t: speed of particle in medium / speed of light\n    // cos = 1/(nB) : angle of emission\n    \n    // (modified) frank-tamm formula\n    // sq(d) * e      sq(q)                sq(c)\n    // ---------  =  -------  *  1 -  --------------- \n    //     d           4pi             sq(v) * sq(n)\n    \n    //                sq(q) * (sq(n)*sq(v) - sq(c))\n    //     d       = -------------------------------\n    //                  4 * e * pi * sq(n) * sq(v)\n    \n    float v = c/n;\n    v += (h) * v * dt;\n    v = min(v, c);\n    \n    b = (1.0f / (n * (v / c)));\n    \n    float d;\n    d = sq(q) * (sq(n)*sq(v) - sq(c));\n    d /= 4.0f * e * PI * sq(n) * sq(v);\n    \n    return (d);\n}\n\nfloat circ(vec2 p) {\n    const float r = .1;\n    return length(p)-r;\n}\n\nfloat linearstep(float edge0, float edge1, float x)\n{\n    return clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);\n}\n\nfloat oracle(vec2 p, float t) {\n    float dist = circ(p+vec2(cos(t),sin(t)));\n    return linearstep(1.0, 0.0, dist);\n}\n\nfloat electricfield(vec2 p, float t) {\n    float velocity = length(p) * iTime;\n    float acc = 0.;\n    float count = 0.;\n    for(float y = -YLIM; y <= YLIM; y+=STEP) {\n        for(float x = -XLIM; x <= XLIM; x+=STEP) {\n            vec2 q = vec2(x, y);\n            float d = length(p - q);\n            \n            float angle;\n        \tfloat rad = cherenkov_radiation(angle, d, STEP);\n            \n            float delay = rad/velocity;\n            acc += oracle(q, t+delay)/angle;\n            ++count;\n        }\n    }\n    return acc/count;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (2.*fragCoord-iResolution.xy)/iResolution.y;\n\n    float background = electricfield(uv, iTime*SPEED);\n\n    vec3 col = vec3(background * 2.0f);\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGBRW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[234, 234, 299, 299, 1429], [1431, 1431, 1451, 1451, 1501], [1503, 1503, 1556, 1556, 1617], [1619, 1619, 1650, 1650, 1737], [1739, 1739, 1777, 1777, 2282], [2284, 2284, 2339, 2339, 2528]], "test": "valid"}
{"id": "WsGcW3", "name": "eyeeerrr", "author": "sanderoneil", "description": "ddd", "tags": ["eye"], "likes": 1, "viewed": 35, "published": "Public", "date": "1605624947", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = (fragCoord-vec2(iResolution.x,iResolution.y)/2.0)/100.0;\n    vec3 p;\n    p = vec3(5.,5.,5.);\n    vec3 s = vec3(uv.x,uv.y,1.);\n    vec3 d = vec3(uv.x,uv.y,pow((1.0+uv.x*uv.x+uv.y*uv.y),.5));\n    float m = 1.;\n    //d+= vec3(iTime/100.,0,0);\n    for (int i = 0; i<1000;i++)\n    {\n        float mi = 1000.;\n\n        float x =(mod(s.x,10.0)-p.x);\n        float y =(mod(s.y,10.0)-p.y);\n        float z =(mod(s.z,10.0)-p.z);\n\n        float l=pow(\n            pow(x,2.0)+\n            pow(y,2.0)+\n            pow(z,2.0),.5); \n\n        if (l<mi) mi = l;\n        d.x*=1.+cos(iTime/100.)/1000.;\n        d.y*=1.+tan(iTime/10.)/1000.;\n        //mi+=l/2.;\n\n        if (m>mi) m = mi;\n        s += d*mi/2.0;\n        \n    }\n    float o = 0.;\n    if (m<-.05) o = 0.99;\n    // Time varying pixel color\n    vec3 col =  \n        vec3(pow(pow((s.x),2.0)+pow((s.y),2.0)+pow((s.z),2.0),.5)/8005.0,\n             (1.-m)/2.,o);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGcW3.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 107, 1080]], "test": "valid"}
{"id": "WsGfRh", "name": "Runner illusion", "author": "Nrx", "description": "Nothing moves...\n\n(Click to stop the animation.)\n\np.s.: An optimized (pre-rendered) version is [url=https://www.shadertoy.com/view/wdVBzh]here[/url].", "tags": ["optical", "illusion"], "likes": 15, "viewed": 350, "published": "Public API", "date": "1606494784", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Inspired by: https://twitter.com/jagarikin/status/1329610899976437765\n\n#define PI\t\t\t3.14159265358979\n#define REPEAT\t\t0.3\n#define HEIGHT\t\t2.2\n#define THICKNESS\t0.025\n#define COLOR_SPEED\t0.04\n#define COLOR_DELAY\t4.0\n#define OUTLINE\t\t2.0\n#define DELTA\t\t0.0001\n\nvec4 color (in float t) {\n\treturn vec4 (vec3 (abs (2.0 * fract (t * COLOR_SPEED) - 1.0)), 1.0);\n}\n\nfloat segDist (in vec2 p, in vec2 a, in vec2 b) {\n\tp -= a;\n\tb -= a;\n\treturn length (p - b * clamp (dot (p, b) / dot (b, b), 0.0, 1.0));\n}\n\nfloat charDist (in vec2 p, in float jump) {\n\tp.y -= 0.25;\n\tfloat d = length (p - vec2 (0.0, 0.1)) - 0.04;\n\td = min (d, segDist (p, vec2 (0.0, 0.1), vec2 (-0.02, -0.1)));\n\tif (jump < 0.5) {\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (0.04, -0.15)));\n\t\td = min (d, segDist (p, vec2 (0.04, -0.15), vec2 (0.08, -0.22)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (-0.05, -0.16)));\n\t\td = min (d, segDist (p, vec2 (-0.05, -0.16), vec2 (-0.1, -0.2)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.06, -0.03)));\n\t\td = min (d, segDist (p, vec2 (0.06, -0.03), vec2 (0.1, -0.05)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (-0.08, -0.01)));\n\t\td = min (d, segDist (p, vec2 (-0.08, -0.01), vec2 (-0.09, -0.05)));\n\t} else {\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (0.06, -0.1)));\n\t\td = min (d, segDist (p, vec2 (0.06, -0.1), vec2 (0.04, -0.2)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.1), vec2 (-0.02, -0.18)));\n\t\td = min (d, segDist (p, vec2 (-0.02, -0.18), vec2 (-0.06, -0.24)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.07, 0.15)));\n\t\td = min (d, segDist (p, vec2 (0.0, 0.04), vec2 (0.05, 0.02)));\n\t\td = min (d, segDist (p, vec2 (0.05, 0.02), vec2 (0.11, 0.06)));\n\t}\n\treturn d - THICKNESS;\n}\n\nfloat charY (in float x) {\n\tx = floor (x / REPEAT) * REPEAT;\n\treturn max (0.0, HEIGHT - mix (-x, x * x * 0.8, step (0.0, x)));\n}\n\nfloat frameDist (in vec2 p) {\n\n\t// Vertical position of the character\n\tfloat dy = charY (p.x);\n\n\t// Distance to the stairs\n\tfloat d = p.y;\n\tif (p.x < -REPEAT * 0.5) {\n\t\tfloat dx = ceil ((p.y - HEIGHT) / REPEAT) * REPEAT;\n\t\tvec2 q = vec2 (dx - p.x, p.y - dy);\n\t\td = min (d, max (min (q.x, q.y), min (max (q.x, q.y), 0.0)));\n\t}\n\n\t// Check whether the character is in the air\n\tfloat jump = step (-REPEAT, p.x) * step (DELTA, dy);\n\n\t// Distance to the character\n\tp.x = (fract (p.x / (2.0 * REPEAT)) - 0.75) * REPEAT * 2.0;\n\tp.y -= dy;\n\treturn min (d, charDist (p, jump));\n}\n\nvoid mainImage (out vec4 fragColor, in vec2 p) {\n\n\t// Normalization of the fragment coordinates\n\tp = (2.0 * p - iResolution.xy) / iResolution.y;\n\tp = 1.6 * p - vec2 (0.15, -1.2);\n\n\tfloat halfPixel = 0.5 * dFdy (p.y);\n\n\t// Background color\n\tfragColor = vec4 (vec3 (0.5), 1.0);\n\n\t// Display\n\tvec4 c = color (float (iFrame));\n\tfloat d = frameDist (p);\n\tfragColor = mix (fragColor, c, smoothstep (halfPixel, -halfPixel, d));\n\n\tif (iMouse.z < 0.5) {\n\t\tvec2 n = normalize (vec2 (frameDist (p - vec2 (DELTA, 0.0)), frameDist (p - vec2 (0.0, DELTA))) - d);\n\t\tvec2 v = normalize (vec2 (REPEAT, (charY (p.x) - charY (p.x - REPEAT)))) * step (2.0 * halfPixel * OUTLINE, p.y);\n\t\tfloat f = dot (n, v);\n\n\t\tc = color (float (iFrame) + COLOR_DELAY * sign (f));\n\t\td = abs (d - halfPixel * OUTLINE) - halfPixel * OUTLINE;\n\t\tfragColor = mix (fragColor, c, abs (f) * smoothstep (halfPixel, -halfPixel, d));\n\t}\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsGfRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[261, 261, 286, 286, 358], [360, 360, 409, 409, 497], [499, 499, 542, 542, 1736], [1738, 1738, 1764, 1764, 1866], [1868, 1868, 1897, 1937, 2437], [2439, 2439, 2487, 2534, 3330]], "test": "valid"}
{"id": "WsjcWR", "name": "Hexagon glow animation", "author": "nicolaecodreanu", "description": "Hexagon glow animation", "tags": ["hexagon"], "likes": 1, "viewed": 101, "published": "Public", "date": "1605018305", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/Xljczw\n//https://www.shadertoy.com/view/Xd2GR3\n\n#define PI 3.14159265359\n#define TWOPI 6.28318530718\n#define polar(a) vec2(cos(a),sin(a))\n#define ANIMATION_TIMESCALE 1.0\n#define ANIM_FUNC Quart\n#define rotate(a) mat2(cos(a),sin(a),-sin(a),cos(a));\n\nfloat Quart(float s, float e, float t)\n{\n    t = clamp((t - s) / (e - s), 0.0, 1.0);\n    return 1.0 - pow(1.0 - t, 4.0);\n}\n\nfloat exponentialOut(float s,float e,float t) {\n  \tt = clamp((t - s) / (e - s),0.0,1.0);\n  \treturn t == 1.0 ? t : 1.0 - pow(2.0, -10.0 * t);\n}\n\nfloat hash21(vec2 p){ return fract(sin(dot(p, vec2(141.13, 289.97)))*43758.5453); }\n\nfloat sdCircle(in vec2 p, in float r)\n{\n\treturn length(p) - r;\n}    \n\nfloat hex(in vec2 p){\n    p = abs(p);\n    return max(p.x*.866025 + p.y*.5, p.y); \n}\n\nvec4 getHex(vec2 p){\n    vec2 s = vec2(1.7320508, 1);\n    vec4 hC = floor(vec4(p, p - vec2(1, .5))/s.xyxy) + .5;\n    vec4 h = vec4(p - hC.xy * s, p - (hC.zw + .5) * s);\n    return dot(h.xy, h.xy) < dot(h.zw, h.zw) ? vec4(h.xy, hC.xy) : vec4(h.zw, hC.zw + .5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord / iResolution.y;\n    float px = 2.0 / iResolution.y;\n    vec3 col = vec3(0.0, 0.0, 0.0);\n    \n    //hexagon uv\n    float tiles = 10.0;\n    vec4 hv = getHex(tiles * uv);\n    vec2 id = hv.zw;\n    float e = hex(hv.xy); //distance from edge to center\n   \tfloat r = 0.45;\n    float w = fwidth(e);\n    float rnd;\n    \n    vec2 nest = vec2(tiles * 0.5);\n    vec2 nestSize = vec2(2.5, 2.5);\n    \n    float x1 = step(nest.x - nestSize.x + 0.5, id.x);\n    float x2 = step(id.x, nest.x + nestSize.x - 0.5);\n    float y1 = step(nest.y - nestSize.y, id.y);\n    float y2 = step(id.y, nest.y + nestSize.y);\n    \n    \n    if(x1 * x2 * y1 * y2 > 0.0) {\n\n        //setup timer loop \n        const float loop = 3.0;\n        float t = iTime * ANIMATION_TIMESCALE;\n        t = mod(t, loop);\n\n        //hexagon background\n        col = mix(col, vec3(0.6), 1.0 - smoothstep(r - w, r + w, e));\n\n        //blink animation\n        rnd = sin(hash21(id) * TWOPI + iTime * 0.5) * 0.5 + 0.5;\n        float blink = smoothstep(0., .125, rnd - .666);\n        col = max(col - mix(vec3(0.0), vec3(0.2), blink), 0.0);\n\n        //hexagon border\n        float b1 = smoothstep(r - tiles * px, r, e); //border\n        float b2 = smoothstep(r, r + tiles * px, e); //border\n        float b = b1 - b2;\n        col = mix(col, vec3(0.9), b);\n\n        //hexagon light\n        rnd = dot(id.y, id.x) + iTime * ANIMATION_TIMESCALE;\n        vec2 lv = hv.xy * rotate(rnd);\n        float a = atan(lv.y, lv.x);\n        float l = 1.0 - smoothstep(0.0, PI * 0.3, abs(a));\n        col = mix(col, vec3(2.0), min(b, l));\n\n        //hexagon shadow\n        float s1 = smoothstep(r - 2.0 * tiles * px, r - tiles * px, e);\n        float s2 = smoothstep(r - tiles * px, r, e);\n        float s = s1 - s2;\n        col = mix(col, vec3(0.5), min(s, l));\n\n        //sattelites positions\n        const int cnt = 6;\n        vec2 dirs[cnt];\n        for(int i = 0; i < cnt; i++) \n        {\n            dirs[i] = polar(float(i) * TWOPI / float(cnt));\n        }\n\n        for(int i = 0; i < cnt; i++) \n        {\n            //setup animation\n            float show = (1.0 / float(cnt)) * float(i);\n            float fadeIn = ANIM_FUNC(show, show + 0.5, t);\n            float fadeOut = ANIM_FUNC(loop - 1.0, loop, t);\n\n            //setup mask\n            float mask = fadeIn - fadeOut;\n            mask = 1.0;\n\n            //draw sattelites\n            float d = sdCircle(hv.xy - dirs[i] * 0.52, tiles * px);\n            col = mix(col, vec3(1.0), (1.0 - smoothstep(-px, px, d)) * mask);\n        }\n    }    \n    \n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsjcWR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[282, 282, 322, 322, 404], [406, 406, 453, 453, 548], [550, 550, 571, 571, 633], [635, 635, 674, 674, 699], [705, 705, 726, 726, 788], [790, 790, 810, 810, 1051], [1053, 1053, 1110, 1110, 3709]], "test": "error"}
{"id": "wsKBz1", "name": "Rotation Experimentation", "author": "Timmons", "description": "Testing some basic rotations.", "tags": ["2dsdf", "rotaion"], "likes": 2, "viewed": 40, "published": "Public", "date": "1606607802", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\nfloat sdEquilateralTriangle( in vec2 p )\n{\n    const float k = sqrt(3.0);\n    p.x = abs(p.x) - 1.0;\n    p.y = p.y + 1.0/k;\n    if( p.x+k*p.y>0.0 ) \n        p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\n    \n    p.x -= clamp( p.x, -2.0, 0.0 );\n    \n    return -length(p)*sign(p.y);\n}\n\nfloat smin( float a, float b, float k )\n{\n    float res = exp2( -k*a ) + exp2( -k*b );\n    return -log2( res )/k;\n}\n\nvec2 rotate2d(vec2 p, float _rads)\n{\n    float x1 = (p.x * cos(_rads)) - ( p.y * sin(_rads)) ;\n    float y1 = (p.y * cos(_rads)) + ( p.x * sin(_rads)) ; \n    \n    return vec2(x1, y1);\n}\n  \n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy)/iResolution.y;\n    p *= 2.0;\n    p = rotate2d(p,  sin(iTime-0.5) * 0.001*length(p) * (iTime*2.5) * 0.8);\n    \n\n    float scale = 2.5;\n    float offset = scale/2.0;\n    vec2 px = fract( p  ) * scale - offset;\n    \n    px = rotate2d(px,  (0.5 * sin(iTime-0.5)) * 0.001*length(p) * iTime * 9.2);\n    \n    \n\tfloat d0 = sdEquilateralTriangle(  px );\n    \n    float d1 = 99999.0;//sdEquilateralTriangle( p + vec2(2.0, 0.0) );\n    \n    float d = smin(d0, d1, 40.0);\n    \n    vec3 col;\n    if(d > 0.0)\n    {\n     \tcol = vec3(0.5, 0.1, 0.5);\n    \tcol.xy = rotate2d(col.xy, (px.y+px.x) * sin(iTime-0.5) * 0.001*length(p) * iTime * 9.2);\n    }\n    else\n        col = 10.0 * abs(d) * vec3(0.9, 0.1, 0.3);\n    \n    // Output to screen\n    fragColor =  vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsKBz1.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 1, 43, 43, 273], [275, 275, 316, 316, 390], [392, 392, 428, 428, 577], [582, 582, 639, 639, 1439]], "test": "valid"}
{"id": "WsKBzW", "name": "You Spin Me Round", "author": "mard", "description": "Bunch of spinning and moving circles. But are these really moving?", "tags": ["opticalillusion"], "likes": 6, "viewed": 111, "published": "Public", "date": "1606684094", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float edgesize = 0.005;\nfloat PI = 3.1415926536;\n\nint DrawCircle(float x, float y, float cx, float cy, float r1, float r2, float sx, float sy, float sz)\n{\n    float r = (x-cx)*(x-cx) + (y-cy)*(y-cy);\n    float arc;\n    if (r<(r1-edgesize)*(r1-edgesize)) return 0; // hole inside the circle\n    \n    if (r<(r2+edgesize)*(r2+edgesize)) {\n        // handling the edges\n        float diff = 0.0;\n        if     (r < r1*r1) diff = (r1*r1 - r)*(sz + sx*(x-cx)*4.0 + sy*(y-cy)*4.0)*100.0;\n        else if(r > r2*r2) diff = (r2*r2 - r)*(sz + sx*(x-cx)*4.0 + sy*(y-cy)*4.0)*100.0;\n            \n        arc = atan(x-cx,y-cy) - iTime*10.0 + diff;\n        return mod(arc,PI) < PI/2.0 ? 1 : 2;\n    }\n    return 0; // outside the circle\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    float y=uv.y-0.5;\n    float x=(uv.x-0.5)*iResolution.x/iResolution.y;\n\n    int c;\n    for(float a=0.0; a<2.0*PI; a+=PI/4.5) {\n        if(c==0) c = DrawCircle(x, y, cos(a)*0.37, sin(a)*0.37, 0.08, 0.12, sin(a)*20.0, -cos(a)*20.0,  0.0);\n    }\n    \n    vec3 color;\n    if(c==0) color = vec3(0.5, 0.5, 0.5);\n    else if(c==1) color = vec3(0.0, 0.0, 0.8);\n    else color = vec3(1.0, 0.7, 0.0);\n\n    fragColor = vec4(color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKBzW.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[50, 50, 154, 154, 724], [726, 726, 783, 783, 1254]], "test": "valid"}
{"id": "WsKfRz", "name": "Is there any life?", "author": "Pr0fed", "description": "Is it?", "tags": ["simple"], "likes": 5, "viewed": 97, "published": "Public", "date": "1606433025", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 hash2( vec2 p )\n{\n\treturn fract(sin(vec2(dot(p,vec2(237.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 halfres = .5 * iResolution.xy;\n    vec2 uv = (fragCoord - halfres ) / iResolution.y;\n    vec2 mouseP = (iMouse.xy - halfres ) / iResolution.y;\n    \n    float dist = 1.0 - length(uv - mouseP) * 6.0;\n    \n    uv *= 300.0;\n    \n    vec2 id = floor(uv);\n    vec2 frac = fract(uv);\n\n    if(dist > 0.0)\n    {\n        id = floor(uv * 0.25);\n        frac = fract(uv* 0.25);\n    }\n    \n    vec3 col = (1.0 - vec3(length(frac - 0.5) * 1.25)) * (dist * 2.0);\n    col *= vec3(hash2(id).x * sin((5.0 + iTime) * hash2(id).x), cos((5.0 + iTime) * hash2(id)));\n    col = pow(col, vec3(1.0 / 2.2));\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsKfRz.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 22, 22, 112], [114, 114, 171, 171, 825]], "test": "valid"}
{"id": "wstBD4", "name": "These waves are all around us", "author": "020406", "description": "Some basic repetition with overlapping grid.", "tags": ["waves", "tiles"], "likes": 2, "viewed": 45, "published": "Public", "date": "1605154192", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.yy;\n    float t = iTime;   \n    \n    float cSum = 0.0;\n    for (float x = -1.; x < 1.0001; x++) {\n        for (float y = -1.; y < 1.0001; y++) {\n            vec2 gv = fract(uv * 4.);\n            gv.x += x;\n            gv.y += y;\n            gv.x += 0.25*(sin(gv.y*8. + uv.y + t*3.));\n      \t\tgv.y += 0.25*(sin(gv.x*9. + t*2.3));\n            float d = length(gv - vec2(0.5, 0.5));\n            \n            cSum += smoothstep(0.5, 0.3, d);\n        }\n    }\n    \n    vec3 col = vec3(cSum);\n\n    fragColor = vec4(col, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstBD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 57, 57, 614]], "test": "valid"}
{"id": "wstBWl", "name": "Mandelbrot inner", "author": "rafaelcastrocouto", "description": "Created by inigo quilez - iq/2013\nLicense Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\nhttp://iquilezles.org/www/articles/mset_smooth/mset_smooth.htm", "tags": ["fractal"], "likes": 3, "viewed": 79, "published": "Public", "date": "1606311061", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//https://www.shadertoy.com/view/4df3Rn\n\n#define AA 2\n\nfloat mandelbrot( in vec2 c ) {\n    const float B = 32.0;\n    float l = 0.0;\n    vec2 z  = vec2(0.0);\n    for( int i=0; i<128; i++ ) {\n        z = vec2( z.x*z.x - z.y*z.y, 2.0*z.x*z.y ) + c;\n        if( dot(z,z)>(B*B) ) break;\n        l += 1.0;\n    }\n    if(l>127.0) return z.x*z.y*16000.0;\n    float sl = l - log2(log2(dot(z,z))) + 4.0;\n    return sl;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec3 col = vec3(0.0);\n    for( int m=0; m<AA; m++ )\n    for( int n=0; n<AA; n++ ) {\n        vec2 p = (-iResolution.xy + 2.0*(fragCoord.xy+vec2(float(m),float(n))/float(AA)))/iResolution.y;\n        float w = float(AA*m+n);\n        float time = iTime + 0.5*(1.0/24.0)*w/float(AA*AA);\n        float zoom = 0.8 + 0.2*cos(0.1*time);\n        float coa = cos( 0.15*(1.0-zoom)*time );\n        float sia = sin( 0.15*(1.0-zoom)*time );\n        zoom = pow(zoom,20.0);\n        vec2 xy = vec2( p.x*coa-p.y*sia, p.x*sia+p.y*coa );\n        vec2 c = vec2(-1.37,.02) + xy*zoom;\n        float l = mandelbrot(c);\n        col += 0.5 + 0.5*cos( 3.0 + l*0.1 + vec3(0.0,0.6,1.0));\n    }\n    col /= float(AA*AA);\n    fragColor = vec4( col, 1.0 );\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstBWl.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[55, 55, 86, 86, 409], [411, 411, 468, 468, 1197]], "test": "valid"}
{"id": "wstBWs", "name": "Assembly Line - Swirled Series", "author": "oneshade", "description": "For the swirled series proposed here: https://isohedral.ca/swirled-series/\nI got interested in @FabriceNeyret2's checker animations for it.", "tags": ["animation", "checker", "infinite", "swirledseries"], "likes": 1, "viewed": 39, "published": "Public", "date": "1606326404", "time_retrieved": "2021-10-01T00:00:00", "image_code": "void mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    float time = clamp(mod(iTime, 3.5) - 0.25, 0.0, 3.0);\n    vec2 uv = fragCoord / 64.0;\n\n    uv.x -= min(1.0, time / 1.5 * (1.0 - mod(floor(uv.y), 2.0)));\n    uv.y -= max(0.0, (time - 1.5) / 1.5 * (1.0 - mod(floor(uv.y), 2.0)));\n\n    fragColor = vec4(0.5);\n    if (fragCoord.x < 512.0 && fragCoord.y < 512.0) {\n        fragColor = vec4(mod(floor(uv.x) + floor(uv.y), 2.0));\n    }\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstBWs.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 55, 55, 439]], "test": "valid"}
{"id": "wstBz2", "name": "mnger", "author": "elmt", "description": "asdfasdf", "tags": ["shader"], "likes": 1, "viewed": 25, "published": "Public", "date": "1605770527", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define MAX_MENGER 6\n#define MAX_MARCHES 100\n#define THRESHOLD 0.001\n\nstruct Square {\n\tvec2 pos;\n    float size;\n};\n    \nstruct Sponge {\n\tfloat size;\n    vec3 pos;\n    int level;\n};\n  \nvec3 rotateX(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float y = c * vec.y - s * vec.z, z = s * vec.y + c * vec.z;\n    \n    return vec3(vec.x, y, z);\n}\nvec3 rotateY(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float x = c * vec.x + s * vec.z, z = -s * vec.x + c * vec.z;\n    \n    return vec3(x, vec.y, z);\n}\nvec3 rotateZ(vec3 vec, float theta) {\n    float s = sin(theta), c = cos(theta);\n    float x = c * vec.x - s * vec.y, y = s * vec.x + c * vec.y;\n    \n    return vec3(x, y, vec.z);\n}\n\nvec3 cube_norm(vec3 pos, vec3 vertex, float size) {\n\tvec3 normals[] = vec3[] (\n    \tvec3(0, 0, -1),\n        vec3(0, 0, 1),\n        vec3(0, -1, 0),\n        vec3(0, 1, 0),\n        vec3(-1, 0, 0),\n        vec3(1, 0, 0)\n    );\n    \n    vec3 projected[] = vec3[] (\n    \tvec3(pos.xy, vertex.z),\n        vec3(pos.xy, vertex.z + size),\n        vec3(pos.x, vertex.y, pos.z),\n        vec3(pos.x, vertex.y + size, pos.z),\n        vec3(vertex.x, pos.yz),\n        vec3(vertex.x + size, pos.yz)\n    );\n    \n    vec3 norm;\n    float d = 10000.;\n    \n    for (int i = 0; i < 6; i++) {\n    \tvec3 loc = pos - projected[i];\n        float ld = length(loc);\n        if (ld < d) {\n        \tnorm = normals[i];\n            d = ld;\n        }\n    }\n    \n    return norm;\n}\n\nfloat sdf(vec2 pos, Square square, out vec2 normal) {\n\tfloat s = length(pos - min(max(pos, square.pos),\n                               square.pos + square.size));\n\n    vec2 edges[] = vec2[4](\n        vec2(pos.x, square.pos.y),\n        vec2(pos.x, square.pos.y + square.size),\n        vec2(square.pos.x, pos.y),\n        vec2(square.pos.x + square.size, pos.y)\n    );\n    \n    vec2 normals[] = vec2[4](\n    \tvec2(0, 1),\n        vec2(0, -1),\n        vec2(1, 0),\n        vec2(-1, 0)\n    );\n\n    float d = 10000.;\n    vec2 n;\n    for (int i = 0; i < 4; i++) {\n        vec2 norm = pos - edges[i];\n        float len = length(norm);\n\n        if (len < d) {\n            d = len;\n            n = normals[i];\n        }\n    }\n\n    normal = n;\n    \n    if (s == 0.) {\n    \treturn -d;\n    }\n    \n    return s;\n}\n\nfloat sdf(vec3 pos, Sponge sponge, out bool is_interior, out vec3 normal) {\n    int level = sponge.level;\n    float max_size = sponge.size;\n    vec3 vertex = sponge.pos;\n    \n    vec3 contained = min(max(pos, vertex), vertex + max_size);\n    \n    vec3 norm = pos - contained;\n    float d = length(norm);\n   \n    bool interior = false;\n    \n    for (int i = 0, size = 1; i < level; i++, size *= 3) {\n        float cell_size = max_size / float(size);\n        float cell_center = cell_size / 3.;\n        \n        // Funny story: at first I tried doing this iteratively \n        // which caused the shader to lag after level 3\n        vec3 npos = mod(pos - (vertex + cell_center), cell_size);\n        \n        Square s;\n        s.pos = vec2(0);\n        s.size = cell_center;\n        \n        vec2 dims[] = vec2[3] ( npos.xy, npos.xz, npos.yz );\n        \n        for (int i = 0; i < 3; i++) {\n        \tvec2 out_norm;\n            vec3 local_norm;\n            float local_d = -sdf(dims[i], s, out_norm);\n            \n            if (i == 0) { local_norm = vec3(out_norm, 0); }\n            else if (i == 1) { local_norm = vec3(out_norm.x, 0, out_norm.y); }\n            else if (i == 2) { local_norm = vec3(0, out_norm); }\n            \n            if (local_d > d) {\n                interior = true;\n                d = local_d;\n                norm = local_norm;\n            }\n        }\n    }\n    \n    is_interior = interior;\n    normal = norm;\n    \n    return d;\t\n}\n\nconst float VIEWER_INTENSITY = .3;\n\nvec3 get_viewer() {\n\treturn vec3(0, 0, sin(iTime) * 0.5 + 1.);\n}\n\nSponge sponge(vec3 pos, float size, int level) {\n    Sponge p;\n    p.size = size;\n    p.pos = pos;\n    p.level = level;\n    return p;\n}\n\nvec3 colorAt(vec3 ray, vec3 pos) {\n    Sponge s = sponge(vec3(-0.75, -0.75, 1.), 1.5, 4);\n    vec3 c = vec3(0); float dist = 0.;\n    \n    for (int i = 0; i < MAX_MARCHES; i++) {\n        vec3 n; bool inside;\n        \n        float d = sdf(pos, s, inside, n);\n        dist += d;\n        pos += d * ray;\n        \n        if (abs(pos.z) > 4.) { break; }\n        \n        if (d < THRESHOLD) {\n            vec3 light = normalize(get_viewer() - pos);\n            \n            float intensity = VIEWER_INTENSITY / (dist*dist);\n            n = (inside ? n : cube_norm(pos, s.pos, s.size)) * intensity;\n            \n        \tc = vec3(dot(light, n));\n            break;\n        }\n    }\n    \n\treturn c;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy)/iResolution.y;\n\t\n    \n    vec3 ray = rotateZ(normalize(vec3(uv, 1)), iTime/10.);\n    \n    fragColor = vec4(colorAt(ray, get_viewer()), 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstBz2.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[185, 185, 222, 222, 365], [366, 366, 403, 403, 547], [548, 548, 585, 585, 728], [1478, 1478, 1531, 1531, 2275], [2277, 2277, 2352, 2352, 3735], [3773, 3773, 3792, 3792, 3837], [3839, 3839, 3887, 3887, 3974], [3976, 3976, 4010, 4010, 4668], [4670, 4670, 4727, 4727, 4919]], "test": "error"}
{"id": "wstBzn", "name": "Julia set cloud", "author": "Mablung", "description": "What could be better than seeing all the Julia sets at once! These Julia sets are made iterating the expression z = z^2 + c. Here z is varied on the two horisontals. The real part of c is varied on the vertical axis and the imaginary part trought time.", "tags": ["math", "mandelbrot", "juliaset"], "likes": 4, "viewed": 136, "published": "Public", "date": "1604257240", "time_retrieved": "2021-10-01T00:00:00", "image_code": "vec2 csquare(vec2 a){\n    return vec2(a.x*a.x-a.y*a.y, 2.0*a.x*a.y);\n}\n\nfloat mandelbrot(vec2 z, vec2 c, int max_it){\n    for(int it = 0; it < max_it; it++){\n        z = csquare(z) + c;\n        if(z.x*z.x+z.y*z.y > 4.0){\n            return float(it);\n        }\n    }\n    return float(max_it);\n}\n\nvec3 angles2vec3(float a,float b){\n    return normalize(vec3(cos(a)*cos(b), sin(a)*cos(b), sin(b)));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \n    float alfa = iTime/7.0;\n    float beeta = iTime/5.0;\n    \n    vec3 cameraDir = angles2vec3(alfa,beeta);\n    \n    vec3 screenX = angles2vec3(alfa + 3.1416/2.0, 0.0);\n    vec3 screenY = angles2vec3(alfa, beeta + 3.1416/2.0);\n    \n    \n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy*vec2(8,4.5) + vec2(-4.0, -2.25);\n    vec3 ray = cameraDir*3.0 + uv.x*screenX + uv.y*screenY;\n    \n    vec3 rayStep = normalize(ray-cameraDir*100.0)/60.0;\n    \n    vec3 col = vec3(0.0,0.0,0.0);\n    \n    int max_ray_steps = 300;\n    float sum = 0.0;\n    \n    for(int stepCount = 0; stepCount <  max_ray_steps; stepCount++){\n    \n        vec2 z = vec2(ray.x,ray.y);\n        vec2 c = vec2(ray.z, sin(iTime/30.0+1.7)); \n\n        float a = mandelbrot(z,c,200)/200.0;\n        sum += a;\n        \n        if( a < 0.0 ){\n            float b = 0.5-float(stepCount)/400.0;\n            col = vec3(b,b,b);\n            break;\n        }\n        \n        if( stepCount == max_ray_steps - 1 ){\n            sum = log(sum)+1.0;\n            col = vec3(sum/10.0,sum/10.0,sum/10.0);\n        }\n        \n        ray += rayStep;\n\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstBzn.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 70], [72, 72, 117, 117, 294], [296, 296, 330, 330, 398], [400, 400, 457, 457, 1656]], "test": "valid"}
{"id": "wstfD4", "name": "Alternate Rainbow", "author": "Plento", "description": "Electric tentacle? ", "tags": ["2d", "color"], "likes": 10, "viewed": 255, "published": "Public API", "date": "1605160795", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Cole Peterson\n#define R iResolution\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\nmat2 rot(float a) {\n    return mat2(cos(a), -sin(a), sin(a), cos(a));\n}\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    vec3 col = vec3(0);\n\n    float r = .47;\n    float n = 20.;\n    \n    for(float i = n; i > 0.; i--)\n    {\n        vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;;\n        uv *= (i*.007 + .2);\n        uv *= rot(i*.05);\n\t\tuv.x += iTime*.075;\n        if(iMouse.z>0.)uv-=m.x*.5;\n        vec2 id = floor(uv*8.);\n        \n        uv.y += sin(i*.5 + iTime*4. + id.y*345. + id.x*883.)*0.007;\n        uv.x += cos(i*.5 + iTime*4. + id.y*845. + id.x*383.)*0.007;\n        \n        vec2 ruv = fract(uv*8.)-.5;\n        id = floor(uv*8.);\n        \n        vec3 nc = .55+.3*cos(vec3(2.,3.,0.4)*(id.x+id.y+i*0.05 + iTime*.6)*3.);\n        \n        float s = max(pow(dot(ruv, vec2(-.8, .5))*4.4, 4.0), 0.001);\n        nc *= abs(s)+.6;\n        nc *= ((n-i) / n);\n        \n    \tcol = mix(col, nc, smoothstep(r, r - .015, length(ruv)));\n        col *= 1.-smoothstep(0.01, 0.003, abs(length(ruv) - r+.005));\n        r -= .0215;\n    }\n    f = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstfD4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[97, 97, 116, 116, 168], [170, 170, 211, 211, 1138]], "test": "valid"}
{"id": "WstfD7", "name": "Atmosphere + planet", "author": "xacer", "description": "A lonely planet filled with a shiny sea and surrounded by an atmosphere unproportionate to the size of the planet.", "tags": ["planet", "raytrace", "atmosphere"], "likes": 8, "viewed": 318, "published": "Public API", "date": "1605292903", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// planet with atmosphere inspired by Sebastian Lague's Coding Adventure\n\n// any tips on rendering the sun would be appreciated!\n\n// noise from: https://github.com/ashima/webgl-noise/blob/master/src/noise3D.glsl\nvec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n}\nvec4 permute(vec4 x) {\n    return mod289(((x*34.0)+1.0)*x);\n}\nvec4 taylorInvSqrt(vec4 r) {\n    return 1.79284291400159 - 0.85373472095314 * r;\n}\nfloat snoise(vec3 v) { \n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n\n    // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n\n    // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy;\n    vec3 x3 = x0 - D.yyy;\n\n    // Permutations\n    i = mod289(i); \n    vec4 p = permute( permute( permute( \n          i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n        + i.y + vec4(0.0, i1.y, i2.y, 1.0 )) \n        + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n\n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n\n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n\n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n\n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n\n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n\n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n\n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n\n    //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n\n    // Mix final noise value\n    vec4 m = max(0.5 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 105.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n            dot(p2,x2), dot(p3,x3) ) );\n}\n\n\nvec2 raySphere (vec3 sphereCenter, float sphereRadius, vec3 origin, vec3 ray) {\n    vec3 offset = origin - sphereCenter;\n    float a = 1.0;\n    float b = 2.0 * dot(offset, ray);\n    float c = dot(offset, offset) - sphereRadius * sphereRadius;\n    float d = b * b - 4.0 * a * c;\n\n    if (d > 0.0) {\n        float s = sqrt(d);\n        float dstToSphereNear = max(0.0, (-b - s) / (2.0 * a));\n        float dstToSphereFar = (-b + s) / (2.0 * a);\n        if (dstToSphereFar >= 0.0) {\n            return vec2(dstToSphereNear, dstToSphereFar - dstToSphereNear);\n        }\n\n    }\n    return vec2(100.00, -1.0);\n}\n\nconst float epsilon = 0.003;\nconst vec3 dirToSun = normalize(vec3(0.9, 0, 1));\nconst vec3 planetCenter = vec3(0.0, 0.0, 0.0);\nconst float atmosphereRadius = 1.7;\nconst float planetRadius = 1.0;\nconst float numInScatteringPoints = 8.0;\nconst float densityFalloff = 11.0;\nconst float numOpticalDepthPoints = 8.0;\n\nconst float scatteringStrength = 13.0;\nconst vec3 waveLengths = vec3(800, 530, 440);\nconst vec3 scatterCoefs = scatteringStrength * vec3(\n    pow(400.0 / waveLengths.x, 4.0), \n    pow(400.0 / waveLengths.y, 4.0), \n    pow(400.0 / waveLengths.z, 4.0));\n\nfloat densityAtPoint (vec3 p) {\n    float heightAboveSurface = length(p - planetCenter) - planetRadius;\n    float height01 = heightAboveSurface / (atmosphereRadius - planetRadius);\n    float localDensity = exp(-height01 * densityFalloff) * (1.0 - height01);\n    return localDensity;\n}\n\nfloat opticalDepth (vec3 ro, vec3 rd, float rl) {\n    vec3 densitySamplePoint = ro.xyz;\n    float stepSize = rl / (numOpticalDepthPoints - 1.0);\n    float opticalDepth = 0.0;\n    for (float i = 0.0; i < numOpticalDepthPoints; i += 1.0) {\n        opticalDepth += densityAtPoint(densitySamplePoint) * stepSize;\n        densitySamplePoint += rd * stepSize;\n    }\n    return opticalDepth;\n}\n\nvec3 calculateLight (vec3 ro, vec3 rd, float rl, vec3 originalColor) {\n\n    vec3 inScatterPoint = ro.xyz;\n\n    float stepSize = rl / (numInScatteringPoints - 1.0);\n\n    vec3 inScatteredLight = vec3(0, 0, 0);\n\n    float viewRayOpticalDepth = 0.0;\n\n    float ii = 0.0;\n    for (float i = 0.0; i < numInScatteringPoints; i += 1.0) {\n\n        float sunRayLength = raySphere(\n            planetCenter, atmosphereRadius, inScatterPoint, dirToSun).y;\n\n        float sunRayOpticalDepth = opticalDepth(\n            inScatterPoint, dirToSun, sunRayLength);\n\n        viewRayOpticalDepth = opticalDepth(\n            inScatterPoint, -rd, stepSize * ii);\n\n        vec3 transmittance = exp(\n            (-sunRayOpticalDepth-viewRayOpticalDepth) * scatterCoefs);\n\n        float localDensity = densityAtPoint(inScatterPoint);\n\n\n        inScatteredLight += \n            localDensity * transmittance * \n            scatterCoefs * stepSize;\n        inScatterPoint += \n            rd * stepSize;\n\n        ii += 1.0;\n    }\n\n    float originalTransmittance = exp(-2.0*viewRayOpticalDepth);\n    return originalTransmittance * originalColor + inScatteredLight;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 uv = (fragCoord - iResolution.xy / 2.0) / iResolution.yy;\n\t\n    vec3 ray = normalize(vec3(uv, 1.0));\n    float rot = iTime*0.4;\n    vec3 cpos = -4.0 * vec3(cos(rot + 3.14 / 2.0), 0, sin(rot + 3.14 / 2.0));\n   \t\n    float ct = cos(rot), st = sin(rot);\n    ray.xz = vec2(ray.x * ct - ray.z * st, ray.x * st + ray.z * ct);\n    \n    vec2 dstToPlanet = raySphere(planetCenter, planetRadius, cpos, ray);\n    \n    vec3 tint = vec3(0, 0, 0);\n    \n    if (dstToPlanet.y > 0.0) {\n    \tvec3 pos = cpos + ray * dstToPlanet.x;\n        vec3 normal = normalize(pos);\n        float ns = 10.0 + iTime * 0.2;\n        vec3 normal_edit = vec3(\n            snoise(normal.xyz*25.0+ns), \n            snoise(normal.yzx*25.0+ns), \n            snoise(normal.zyx *25.0+ns));\n       \tnormal += normal_edit * 0.2;\n        float diffuse = max(dot(normal, dirToSun), 0.0);\n        float specular = dot(reflect(ray, normal), dirToSun);\n        specular = pow(max(specular, 0.0), 16.0);\n\n        float light = 0.7 * diffuse + 0.3 * specular;\n\n        tint = vec3(0.8, 0.8, 0.8) * light;\n    } else {\n        float dp = dot(ray, dirToSun);\t\t\t\n        float sn = snoise(ray.xyz * 50.0);\n        if (sn > 0.8) {\n            sn -= 0.8;\n            tint = vec3(sn, sn, sn) * 5.0;\n        }\n        if (dp > 0.997) {\n            dp -= 0.997;\n            dp *= 1000.0;\n            tint = dp * vec3(1.0, 0.8, 0.5);\n        }\n    }\n    vec2 t = raySphere(planetCenter, atmosphereRadius, cpos, ray);\n    if (t.y > 0.0) {\n        float nt = t.x, ft = min(t.y, dstToPlanet.x - t.x);\n        vec3 posInAtmosphere = cpos + ray * (nt + epsilon);\n        tint = calculateLight(posInAtmosphere, ray, ft - epsilon * 2.0, tint);\n    }\n    fragColor = vec4(tint,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WstfD7.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[130, 212, 233, 233, 284], [285, 285, 306, 306, 357], [358, 358, 380, 380, 419], [420, 420, 448, 448, 502], [503, 503, 525, 525, 2450], [2453, 2453, 2532, 2532, 3057], [3624, 3624, 3655, 3655, 3908], [3910, 3910, 3959, 3959, 4296], [4298, 4298, 4368, 4368, 5435], [5437, 5437, 5494, 5494, 7220]], "test": "error"}
{"id": "wstfDf", "name": "Resonant ballistic conductance", "author": "Lay", "description": "for scientific conference", "tags": ["smth"], "likes": 2, "viewed": 65, "published": "Public", "date": "1606191559", "time_retrieved": "2021-10-01T00:00:00", "image_code": "int N = 3;\n\nfloat E_KT = 0.01;\nvec3 e_col = vec3(.27,.51,.89);\nvec3 p_col = vec3(1.,.41,.11);\n\nfloat rect(vec2 aa, vec2 bb, vec2 uv)\n{\n    float h = 0.002;\n    float res = 1.;\n    res *= smoothstep(aa.x-h,aa.x,uv.x);\n    res *= smoothstep(aa.y-h,aa.y,uv.y);\n    res *= (1.-smoothstep(bb.x,bb.x+h,uv.x));\n    res *= smoothstep(bb.y+E_KT,bb.y-E_KT,uv.y);\n    return res;\n}\n\nfloat dotted_line(float q, float x)\n{\n    x = fract(x/q);\n    return smoothstep(.505,.495,x);\n}\n\nfloat wave(vec2 center, vec2 radius, vec2 uv)\n{\n    uv -= center;\n    uv /= radius;\n    float l = length(uv);\n    return smoothstep(1., .85, l);\n}\n\nvec2 channel_h(float h, float kt, float a, float b, vec2 uv)\n{\n    float temp = uv.x - .5*(a+b);\n\ttemp /= (.5*(b-a));\n    temp *= temp;\n    temp *= temp;\n    //temp *= temp;\n    //temp *= temp;\n    uv.y -= h * (temp*temp*temp*temp*temp*temp*temp - 1.);\n    uv.y /= 1. + (temp+0.3)*(temp+0.3)*(temp+0.3)*(temp+0.3)*(temp+0.3)*(temp+0.3)*(temp+0.3);\n    return uv;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    float Ef = 0.6;\n    float dE = 0.1;\n    float E_up = 0.17;\n\n    vec3 col = vec3(1.); \n    \n    float s = .2, d = .8;\n    \n    float source = rect(vec2(.0,.0), vec2(.2,Ef), uv);\n    float drain = rect(vec2(.8,.0), vec2(1.,Ef), uv);\n    \n    col = source * e_col + (1. - source) * col;\n\tcol = drain * vec3(.27,.51,.89) + (1. - drain) * col;\n    \n    vec2 ch_b = uv;\n    ch_b.y -= Ef;\n    vec2 ch_t = ch_b;\n    ch_b.y -= E_up + dE;\n    ch_t.y -= E_up - dE;\n\n    ch_b = channel_h(0.17, 0.04, s+0.0005, d-0.0005, ch_b);\n    ch_t = channel_h(0.17, 0.04, s+0.0005, d-0.0005, ch_t);\n    \n    {    \n        float electrons = smoothstep(0.0001, 0.000, ch_b.y*ch_t.y);\n        electrons *= smoothstep(Ef+E_KT, Ef-E_KT, uv.y);\n        electrons *= smoothstep(s-0.001, s, uv.x);\n        electrons *= smoothstep(d+0.001, d, uv.x);\n\n        col = electrons * e_col + (1. - electrons) * col;\n    }\n    \n    if (true)\n    {\n        float time = 0.3 * iTime;\n        \n        float q = 2. / (2. * float(N) - 1.);\n        \n        \n        float w;\n        float ch = (uv.x - s) / (d - s);\n        \n        for (int i = 0; i < N; ++i)\n        {\n            w = smoothstep(0.0001, 0.000, ch_b.y*ch_t.y);\n            w *= wave(vec2((fract(time+0.5))*q + float(i)*q, Ef), vec2(0.25*q,3.*E_KT), vec2(ch,uv.y));\n            w *= smoothstep(Ef+0.5*E_KT, Ef-0.5*E_KT, uv.y);\n            col = w * p_col + (1. - w) * col;\n            \n            w = smoothstep(0.0001, 0.000, ch_b.y*ch_t.y);\n            w *= wave(vec2((-fract(time))*q + float(i)*q + 0.5*q, Ef), vec2(0.25*q,3.*E_KT), vec2(ch,uv.y));\n            w *= smoothstep(Ef+0.5*E_KT, Ef-0.5*E_KT, uv.y);\n            col = w * p_col + (1. - w) * col;\n            \n            w = smoothstep(0.0001, 0.000, ch_b.y*ch_t.y);\n            w *= wave(vec2((fract(time))*q + float(i)*q, Ef), vec2(0.25*q,3.*E_KT), vec2(ch,uv.y));\n            w *= (1.-smoothstep(Ef, Ef-2.*E_KT, uv.y));\n            col = w * (0.85*e_col) + (1. - w) * col;\n            \n            w = smoothstep(0.0001, 0.000, ch_b.y*ch_t.y);\n            w *= wave(vec2((-fract(time-0.5)+0.5)*q + float(i)*q, Ef), vec2(0.25*q,3.*E_KT), vec2(ch,uv.y));\n            w *= (1.-smoothstep(Ef, Ef-2.*E_KT, uv.y));\n            col = w * (0.85*e_col) + (1. - w) * col;\n        }\n        \n        // contacts\n        w = smoothstep(Ef+1.*E_KT, Ef+0.*E_KT, uv.y);\n        w *= (1.-smoothstep(Ef-2.3*E_KT-3.*E_KT*(cos(6.283*time)-1.), Ef-3.*E_KT-3.*E_KT*(cos(6.283*time)-1.), uv.y));\n        w *= smoothstep(d, d+0.001, uv.x);\n        w *= cos(6.283*time);\n        w = max(w, 0.);\n        col = w * p_col + (1. - w) * col;\n        \n        w = smoothstep(Ef+1.*E_KT, Ef+0.*E_KT, uv.y);\n        w *= (1.-smoothstep(Ef-2.3*E_KT+3.*E_KT*(cos(6.283*time)+1.), Ef-3.*E_KT+3.*E_KT*(cos(6.283*time)+1.), uv.y));\n        w *= smoothstep(s, s-0.001, uv.x);\n        w *= -cos(6.283*time);\n        w = max(w, 0.);\n        col = w * p_col + (1. - w) * col;\n        \n        w = smoothstep(Ef+3.*E_KT+3.*E_KT*(cos(6.283*time)-1.), Ef+2.3*E_KT+3.*E_KT*(cos(6.283*time)-1.), uv.y);\n        w *= (1.-smoothstep(Ef-0.*E_KT, Ef-1.*E_KT, uv.y));\n        w *= smoothstep(s, s-0.001, uv.x);\n        w *= cos(6.283*time);\n        w = max(w, 0.);\n        col = w * (0.85*e_col) + (1. - w) * col;\n        \n        w = smoothstep(Ef+3.*E_KT-3.*E_KT*(cos(6.283*time)+1.), Ef+2.3*E_KT-3.*E_KT*(cos(6.283*time)+1.), uv.y);\n        w *= (1.-smoothstep(Ef-0.*E_KT, Ef-1.*E_KT, uv.y));\n        w *= smoothstep(d, d+0.001, uv.x);\n        w *= -cos(6.283*time);\n        w = max(w, 0.);\n        col = w * (0.85*e_col) + (1. - w) * col;\n    }\n    \n    {\n        float bottom = smoothstep(-0.005,0.,ch_t.y) * \n            smoothstep(+0.005,0.,ch_t.y);\n\n        bottom *= smoothstep(s-.002, s, uv.x);\n        bottom *= smoothstep(d+.002, d, uv.x);\n\n        float sd_line = smoothstep(s-0.002, s, uv.x) * \n            smoothstep(s+0.002, s, uv.x);\n\n        sd_line += smoothstep(d-0.002, d, uv.x) * \n            smoothstep(d+0.002, d, uv.x);\n\n        bottom = max(bottom, sd_line);\n\n        bottom *= smoothstep(Ef+E_up-dE + 0.001, Ef+E_up-dE, uv.y);\n\n        col = bottom * vec3(0.) + (1. - bottom) * col;\n    }\n    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstfDf.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[95, 95, 134, 134, 370], [372, 372, 409, 409, 467], [469, 469, 516, 516, 615], [617, 617, 679, 679, 981], [983, 983, 1040, 1040, 5281]], "test": "valid"}
{"id": "wstfDr", "name": "Modified Pumpkin ", "author": "aaron_li9", "description": "Class assignment", "tags": ["pumpkin"], "likes": 4, "viewed": 62, "published": "Public", "date": "1604896426", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// BASIC RAY-MARCHING CLASS DEMO!\n//\n// Numerous methods borrowed from iq articles:\n//   https://iquilezles.org/www/index.htm\n// \n// 3D signed distance functions:\n//   https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\n// \n// Shadows:\n//   https://www.iquilezles.org/www/articles/rmshadows/rmshadows.htm\n// \n// Ray-marching SDFs:\n//   https://www.iquilezles.org/www/articles/raymarchingdf/raymarchingdf.htm\n// \n// Normals for SDFs:\n//   https://www.iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\n\nfloat opUnion( float d1, float d2 ) {  return min(d1,d2); }\nvec4  opUnion(vec4 d1, vec4 d2) {\n return (d1.x < d2.x ? d1 : d2);   \n}\n\nfloat opIntersection( float d1, float d2 ) { return max(d1,d2); }\nvec4  opIntersection( vec4  d1, vec4  d2 ) {\n return (d1.x > d2.x ? d1 : d2);   \n    \n}\n\n// subtracts d1 from d2\nfloat opSubtraction( float d1, float d2 ) { return max(-d1,d2); }\nvec4  opSubtraction( vec4  d1, vec4  d2 ) { \n  return opIntersection(vec4(-d1.x,d1.yzw), d2);\n}\n\nfloat opSmoothUnion( float d1, float d2, float k ) {\n    float h = clamp( 0.5 + 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) - k*h*(1.0-h); }\n\nfloat opSmoothSubtraction( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2+d1)/k, 0.0, 1.0 );\n    return mix( d2, -d1, h ) + k*h*(1.0-h); }\n\nfloat opSmoothIntersection( float d1, float d2, float k ) {\n    float h = clamp( 0.5 - 0.5*(d2-d1)/k, 0.0, 1.0 );\n    return mix( d2, d1, h ) + k*h*(1.0-h); }\n\nfloat opOnion( in float sdf, in float thickness )\n{\n    return abs(sdf)-thickness;\n}\n\n// 3D gradient noise methods. \n// https://www.shadertoy.com/view/Xsl3Dl\nvec3 hash( vec3 p ) // replace this by something better\n{\n\tp = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n\t\t\t  dot(p,vec3(269.5,183.3,246.1)),\n\t\t\t  dot(p,vec3(113.5,271.9,124.6)));\n\n\treturn -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\nfloat noise( in vec3 p )\n{\n    vec3 i = floor( p );\n    vec3 f = fract( p );\n\t\n\tvec3 u = f*f*(3.0-2.0*f);\n\n    return mix( mix( mix( dot( hash( i + vec3(0.0,0.0,0.0) ), f - vec3(0.0,0.0,0.0) ), \n                          dot( hash( i + vec3(1.0,0.0,0.0) ), f - vec3(1.0,0.0,0.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,0.0) ), f - vec3(0.0,1.0,0.0) ), \n                          dot( hash( i + vec3(1.0,1.0,0.0) ), f - vec3(1.0,1.0,0.0) ), u.x), u.y),\n                mix( mix( dot( hash( i + vec3(0.0,0.0,1.0) ), f - vec3(0.0,0.0,1.0) ), \n                          dot( hash( i + vec3(1.0,0.0,1.0) ), f - vec3(1.0,0.0,1.0) ), u.x),\n                     mix( dot( hash( i + vec3(0.0,1.0,1.0) ), f - vec3(0.0,1.0,1.0) ), \n                          dot( hash( i + vec3(1.0,1.0,1.0) ), f - vec3(1.0,1.0,1.0) ), u.x), u.y), u.z );\n}\nconst mat3 m = mat3( 0.00,  0.80,  0.60,\n                    -0.80,  0.36, -0.48,\n                    -0.60, -0.48,  0.64 );\nfloat fbm( in vec3 pos )\n{\n    vec3  q = 8.0*pos;\n    float f = 0.5000*noise( q ); q = m*q*2.01;\n    f += 0.2500*noise( q ); //q = m*q*2.02;\n    //f += 0.1250*noise( q ); q = m*q*2.03;\n    //f += 0.0625*noise( q ); \n    return f;\n}\n\n\n\n\nvec3 rotate_y(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, +.0, -sa,\n\t\t+.0,+1.0, +.0,\n\t\t+sa, +.0, +ca);\n}\nvec3 rotate_x(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+1.0, +.0, +.0,\n\t\t+.0, +ca, -sa,\n\t\t+.0, +sa, +ca);\n}\nvec3 rotate_z(vec3 v, float angle)\n{\n\tfloat ca = cos(angle); float sa = sin(angle);\n\treturn v*mat3(\n\t\t+ca, -sa, +.0,\n\t\t+sa, +ca, 0.,\n\t\t+.0, +.0, 1.);\n}\n\n// iq distance functions, \n// See https://iquilezles.org/www/articles/distfunctions/distfunctions.htm\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat sdSphere(vec3 p, float radius )\n{\n  return length(p)-radius;\n}\n\nfloat sdTorus(in vec3 p, in vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\nfloat sdRoundedCylinder( vec3 p, float ra, float rb, float h )\n{\n  vec2 d = vec2( length(p.xz)-2.0*ra+rb, abs(p.y) - h );\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0)) - rb;\n}\nfloat sdCapsule( vec3 p, vec3 a, vec3 b, float r )\n{\n  vec3 pa = p - a, ba = b - a;\n  float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n  return length( pa - ba*h ) - r;\n}\nfloat sdCappedCone( vec3 p, float h, float r1, float r2 )\n{\n  vec2 q = vec2( length(p.xz), p.y );\n  vec2 k1 = vec2(r2,h);\n  vec2 k2 = vec2(r2-r1,2.0*h);\n  vec2 ca = vec2(q.x-min(q.x,(q.y<0.0)?r1:r2), abs(q.y)-h);\n  vec2 cb = q - k1 + k2*clamp( dot(k1-q,k2)/dot2(k2), 0.0, 1.0 );\n  float s = (cb.x<0.0 && ca.y<0.0) ? -1.0 : 1.0;\n  return s*sqrt( min(dot2(ca),dot2(cb)) );\n}\nfloat sdTriPrism( vec3 p, vec2 h )\n{\n  vec3 q = abs(p);\n  return max(q.z-h.y,max(q.x*0.866025+p.y*0.5,-p.y)-h.x*0.5);\n}\nfloat sdPlane( vec3 p, vec3 n, float h )\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\nfloat sdBoundingBox( vec3 p, vec3 b, float e )\n{\n  p = abs(p  )-b;\n  vec3 q = abs(p+e)-e;\n  return min(min(\n      length(max(vec3(p.x,q.y,q.z),0.0))+min(max(p.x,max(q.y,q.z)),0.0),\n      length(max(vec3(q.x,p.y,q.z),0.0))+min(max(q.x,max(p.y,q.z)),0.0)),\n      length(max(vec3(q.x,q.y,p.z),0.0))+min(max(q.x,max(q.y,p.z)),0.0));\n}\n\n// not exact\nfloat sdEllipsoid( vec3 p, vec3 r )\n{\n  float k0 = length(p/r);\n  float k1 = length(p/(r*r));\n  return k0*(k0-1.0)/k1;\n}\n\n// See https://www.shadertoy.com/view/Wdjfz3\nfloat sdEgg( in vec2 p, in float ra, in float rb )\n{\n    const float k = sqrt(3.0);\n    \n    p.x = abs(p.x);\n    \n    float r = ra - rb;\n\n    return ((p.y<0.0)       ? length(vec2(p.x,  p.y    )) - r :\n            (k*(p.x+r)<p.y) ? length(vec2(p.x,  p.y-k*r)) :\n                              length(vec2(p.x+r,p.y    )) - 2.0*r) - rb;\n}\nfloat sdCappedTorus(in vec3 p, in vec2 sc, in float ra, in float rb)\n{\n  p.x = abs(p.x);\n  float k = (sc.y*p.x>sc.x*p.y) ? dot(p.xy,sc) : length(p.xy);\n  return sqrt( dot(p,p) + ra*ra - 2.0*ra*k ) - rb;\n}\nfloat sdRoundBox( vec3 p, vec3 b, float r )\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nvec3 bendPoint( in vec3 p , float amt)\n{\n    float k = amt; //  some amount, e.g., 10.\n    float c = cos(k*p.x);\n    float s = sin(k*p.x);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xy,p.z);\n    return q;\n}\n// Function to y-axis revolve a 2D SDF into a 3D SDF.\nvec2 revolvePoint( in vec3 p, float radius )\n{\n    return vec2( length(p.xz) - radius, p.y );\n}\n\n// Simple ellipsoidal SDF pumpkin at origin.\nfloat sdPumpkin(vec3 p) \n{\n\tfloat sdf = 100.;\n    for(int i=0; i<10; i++) {// somewhat expensive\n    \tvec3  rp = rotate_y(p, 6.28*float(i)/10.+0.27);\n        vec3  q  = rotate_z(rp-vec3(0.6,0.,0.),-0.1);\n\t    float d  = sdEllipsoid(q, vec3(0.8, 1., 0.6));\n        sdf = opSmoothUnion(d, sdf, 0.03);\n        //sdf = opUnion(d, sdf);\n    }\n    \n    return sdf;\n}\n\nfloat sdWatermelon(vec3 p) {\n    float sdf = 100.;\n    \n    \n\n    return sdf;\n}\n\n\n/// SCENE PARAMETERS (feel free to add your own):\nconst vec3 pumpkinCenter = vec3(0., -0.15, -8.0);\nconst vec3 Cd_pumpkinOutside = vec3(231./255., 111./255., 3./255.); \n//const vec3 Cd_pumpkinOutside = vec3(0., 0., 1.); \nconst vec3 Cd_pumpkinInside  = vec3(1.,0.7,0.);\nconst vec3 Cd_stem           = vec3(0.35,0.25,0.15);\n\n// SDF implementation for our scene. \n// Returns 4 values: (sdf, Cd)\n//   .x: SDF distance, \n//   .y: Cd.r\n//   .z: Cd.g\n//   .w: Cd.b\n// NOTE: You could return other things for yzw, e.g., y:objectID int to set more colors in \"render.\"\nvec4 mapV4(in vec3 p)\n{\n    // SDF vector (sdf, r,g,b) to be returned:\n    vec4 sdf = vec4(100000., -1., 0., 0.);\n    \n    float mx = iMouse.x/iResolution.x;\n\n    // TODO: REPLACE THE FOLLOWING WITH YOUR SCENE CODE:\n    \n    \n    \n    // Translate coordinate to pumpkin center:\n    vec3 c = pumpkinCenter;\n    p -= c;\n    \n    \n    \n    {// BODY:\n\t\t// OUTSIDE: Union of ellipsoids\n        vec3 q = p;//local copy\n        sdf.x = sdPumpkin(q);\n        sdf.yzw = Cd_pumpkinOutside;// + 0.1*vec3(1.,1.,0.)*length(q.xz);\n        if(sdf.x < 0.01) {\n            float theta = atan(q.z,q.x) + 0.015*noise(10.*p);\n            sdf.yz += 0.02*abs(sin(40.*theta)-0.9)*abs(sin(100.*theta)-0.9);\n\t\t\t//sdf.yz += 0.02;\n            // INSIDE: Subtract ellipsoid\n            float cutoutSD  = sdEllipsoid(q, vec3(1.1, 0.7, 1.1)); \n            vec3  cutoutCol = Cd_pumpkinInside; \n            vec4  cutout    = vec4(cutoutSD, cutoutCol);\n            sdf = opSubtraction(cutout, sdf);\n        }\n    }\n    \n    {// CARROT:\n        vec3 q = p;\n        q.yxz = bendPoint(q.yxz, -0.4);\n        float carrotSD = sdCappedCone(q + vec3(.0, 1, -0.1), 0.5, 0., 0.3);\n        vec3 carrotCol = vec3(4, 2, 9);\n        //if(carrotSD < 0.01) {\n        //    carrotCol.xy += -0.9;\n        //}\n        vec4  carrot = vec4(carrotSD, carrotCol);\n    \tsdf   = opUnion(sdf, carrot);\n    }\n\n    \n    {//STEM:\n        vec3 q = p; \n        q.y *= -1.;\n        vec3 tmpq = q;\n\t    //q.yxz = bendPoint(q.yxz, 0.4);\n        q.yxz = bendPoint(q.yxz, 0.4 * sin(5. * iTime) + 0.25);\n        q = rotate_z(q, 0.4);\n    \tfloat stemSD  = sdCappedCone(q + vec3(.0, 1.25,0.), 0.45, 0.1, 0.2);// (p, h, r1, r2)\n        vec3  stemCol = Cd_stem*2.;\n        if(stemSD<0.01){// modify color\n\t        float theta = atan(q.z, q.x);// + 0.015*noise(10.*p);\n            stemCol.xy += 0.02*abs(sin(40.*theta)-0.9)*abs(sin(100.*theta)-0.9);\n            //stemSD *= (1. + 1.*abs(sin(10.*theta)-0.9));\n        }\n        \n        vec4  stem = vec4(stemSD, stemCol);\n    \tsdf   = opUnion(sdf, stem);\n    }\n\n    {// ADD NOISE:  (use sparingly--ruins signed-distance property)\n    \tsdf += 0.006*noise(8.*p);\n        //sdf.x += 0.015*fbm(0.65*p); // costly. \n    }\n\n    {// CARVE:\n\t\t// NOSE:\n        float noseSD = sdTriPrism(p-vec3(0.,0.,1.2), vec2(.2, 1.));\n        vec4  noseCutout = vec4(noseSD, Cd_pumpkinInside);\n        sdf = opSubtraction(noseCutout, sdf);\n        \n        // EYES:\n        vec2 xyEye = vec2(0.45, 0.35);\n        float eyeSD = sdCapsule(vec3(abs(p.x),p.yz), vec3(xyEye, 0.), vec3(xyEye, 2.), 0.2);\n        vec4  eyeCutout = vec4(eyeSD, Cd_pumpkinInside);\n        sdf = opSubtraction(eyeCutout, sdf);\n        \n        \n        // MOUTH: \n        //vec3  q = vec3(p.x, -p.y+0.5, p.z-.5);\n        //float d = sdRoundBox(p + vec3(0.,0.5, -0.8), vec3(0.5, 0.01, 0.8), 0.1);\n        float d = sdRoundBox(p + vec3(0.1 * cos(2. * iTime),0.5, -0.8), vec3(0.5, 0.02, 0.8), 0.3 * abs(sin(2. * iTime)));\n        //float d = sdCappedTorus(q, vec2(0.866025,-0.5), 0.55, 0.05);//vec2(0.8, 0.0), 1., 0.2);\n        vec4 mouth = vec4(d, Cd_pumpkinInside);\n        //vec4 mouth = vec4(1., 1., 0.7, 0.)\n        sdf = opSubtraction(mouth, sdf);\n        \n        \n    }\n    \n    \n    {// TABLE: \n        //float d = sdPlane(p, normalize(vec3(0.,1.,0.)), 1.2);\n        //float d = sdBox(p-vec3(0.,-1.3,0.), vec3(5., 0.1, 10.));\n        float d = sdRoundedCylinder(p-vec3(0.,-1.2,0.), 1.2, 0.1, 0.1);\n        vec4  ground = vec4(d, vec3(0.5,0.,0.));\n\t\tsdf = opUnion( sdf, ground );       \n    }\n\n    \n    // CUTAWAY PLANE:\n    #if 0\n        float d = sdPlane( p, normalize(vec3(-1.,0.,-1.)), 3.*(mx-0.5));\n        vec4 cutPlane = vec4(d, Cd_pumpkinInside);\n        //sdf = opIntersection(sdf, cutPlane); \n        sdf = opSubtraction(cutPlane, sdf); \n    #endif\n    \n    #if 0   \n    {// COORDINATE BOX GUIDE:\n    \tfloat d = sdBoundingBox(p, vec3(1.), 0.02);\n        sdf = opUnion(sdf, vec4(d, vec3(0.8)));\n    }\n    #endif \n    \n    return sdf;\n}\n\n\n// Scalar SDF implementation for our scene\nfloat map(in vec3 p)\n{\n    return mapV4(p).x;// just sdf value\n}\n\n//vec3 calcNormal( in vec3 p ) // for function map(p)\n//{\n//    const float eps = 0.0001; // or some other value\n//    const vec2  h   = vec2(eps,0);\n//    return normalize( vec3(map(p+h.xyy) - map(p-h.xyy),\n//                          map(p+h.yxy) - map(p-h.yxy),\n//                           map(p+h.yyx) - map(p-h.yyx) ) );\n//}\n// http://iquilezles.org/www/articles/normalsSDF/normalsSDF.htm\nvec3 calcNormal( in vec3 pos )\n{\n    \n#if 0\n    vec2 e = vec2(1.0,-1.0)*0.5773*0.001;\n    return normalize( e.xyy*map( pos + e.xyy ) + \n\t\t\t\t\t  e.yyx*map( pos + e.yyx ) + \n\t\t\t\t\t  e.yxy*map( pos + e.yxy ) + \n\t\t\t\t\t  e.xxx*map( pos + e.xxx ) );\n#else\n    // inspired by tdhooper and klems - a way to prevent the compiler from inlining map() 4 times\n    vec3 n = vec3(0.0);\n    for( int i=0; i<4; i++ )\n    {\n        vec3 e = 0.5773*(2.0*vec3((((i+3)>>1)&1),((i>>1)&1),(i&1))-1.0);\n        n += e*map(pos+0.001*e);\n    }\n    return normalize(n);\n#endif    \n}\n\n// Vector raymarch: \n// .x   : t* value of surface, or -1 if didn't hit anything.\n// .yzw : pass-thru from mapV4.yzw\n// \nvec4 raymarchV4(in vec3 ro, in vec3 rd) \n{\n    float t = 0.0;\n    for(int i=0; i<200; i++) {\n        vec3  rt = ro + rd*t;\n        vec4  f  = mapV4(rt);\n\t\tfloat d  = f.x;\n        \n        if(d<0.001) {// We hit it or went too far\n            f.x = t; // replace .x's sdf with t*\n            return f;\n        }\n        else {// keep marching\n         \tt += 0.95*d; // conservative/smaller step for inexact/warped SDFs\n        }\n        \n        if(t > 100.) {\n            f.x = -1.;// -ve t* --> didn't hit anything\n            return f;\n        }\n    }\n    \n\treturn vec4(-1., vec3(0.)); // didn't hit anything\n}\n\n/// Returns t* value of surface, or -1. if didn't hit anything.\nfloat raymarch(in vec3 ro, in vec3 rd) \n{\n    return raymarchV4(ro,rd).x;  \n}\n\nfloat shadow( in vec3 ro, in vec3 rd, float mint, float maxt )\n{\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.;\n        t += 0.95*h;//can do slightly less for not-quite-SDFs\n    }\n    return 1.0;\n}\nfloat softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n{\n    float res = 1.0;\n    float ph = 1e20;\n    for( float t=mint; t<maxt; )\n    {\n        float h = map(ro + rd*t);\n        if( h<0.001 )\n            return 0.0;\n        \n        float y = h*h/(2.0*ph);\n        float d = sqrt(h*h-y*y);\n        res = min( res, k*d/max(0.0,t-y) );\n        ph = h;\n        t += 0.95*h;//slightly less for not-quite-SDFs\n    }\n    return res;\n}\n\nvec3 render(in vec3 ro, in vec3 rd) \n{\n    vec3 col = vec3(0.,0.,0.);//background\n\tvec2 mouse = iMouse.xy/iResolution.xy;         \n    \n    vec4  ray = raymarchV4(ro, rd);//compute distance along ray to surface\n    float t   = ray.x;\n    vec3  Cd  = ray.yzw;// can passthru other shading values, e.g., objectID, but we did color.\n    \n    if(t>0.0) {//hit surface --> shade it:   \n        \n\t    vec3  p  = ro + rd*t; // point on surface\n        vec3  N  = calcNormal(p); // sdf normal\n        \n        // DETERMINE MATERIAL COLOR: (todo: all orange for now)\n        //vec3  Cd = vec3(231./255., 111./255., 3./255.); // diffuse color\n        \n        // DIRECTIONAL LIGHT:\n        vec3  posL   = ro+ 30.*vec3(mouse.x-0.5, mouse.y-0.5,0.);// light at eye (safe!)\n        vec3  L      = normalize(posL - p);\n        vec3  CL     = vec3(1.);// directional light color\n        float LdotN  = clamp(dot(L,N), 0., 1.);\n        //float shadL  = shadow(p, L, 0.01, 20.);\n        float sshadL = softshadow(p, L, 0.01, length(posL-p), 2.);\n\t    col = Cd * CL * LdotN * sshadL; // * occ;\n        \n        // CANDLE LIGHT (#2):\n        //vec3  dp     = 2.*vec3(0., mouse.y-0.5, mouse.x-0.5);\n        vec3  posL2  = pumpkinCenter + 0.15*vec3(sin(20.*iTime),cos(7.*iTime),cos(14.*iTime));\n        vec3  L2     = normalize(posL2 - p);\n        vec3  CL2    = vec3(1.,1.,.2);// candle light color\n        float L2dotN = clamp(dot(L2,N), 0., 1.);\n        //float shadL2  = shadow(p, L2, 0.01, length(posL2-p));\n        float sshadL2 = softshadow(p, L2, 0.01, length(posL2-p), 8.);\n\t    col += Cd * CL2 * L2dotN * sshadL2; // * occ;       \n        \n    }\n    \n    return col;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n \tvec2 mouse = iMouse.xy/iResolution.xy;   \n \n    vec2 uv  = (fragCoord - 0.5*iResolution.xy)/iResolution.y; // normalized coordinates (unit height)\n\n    vec3 pix = vec3(uv,     0.);    // position of virtual pixel (Z=0 depth)\n    vec3 ro  = vec3(0., 0., 3.);    // ray origin (EYE POSITION).. controls field-of-view\n    vec3 rd  = normalize(pix - ro); // ray direction\n    \n    vec3 col = render(ro, rd);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstfDr.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[521, 521, 558, 558, 580], [581, 581, 614, 614, 652], [654, 654, 698, 698, 719], [720, 720, 764, 764, 807], [809, 833, 876, 876, 898], [899, 899, 942, 942, 994], [996, 996, 1048, 1048, 1147], [1149, 1149, 1207, 1207, 1307], [1309, 1309, 1368, 1368, 1467], [1469, 1469, 1520, 1520, 1553], [1555, 1627, 1684, 1684, 1853], [1854, 1854, 1880, 1880, 2705], [2831, 2831, 2857, 2857, 3062], [3067, 3067, 3103, 3103, 3220], [3221, 3221, 3257, 3257, 3375], [3376, 3376, 3412, 3412, 3527], [3529, 3631, 3656, 3656, 3675], [3676, 3676, 3701, 3701, 3720], [3721, 3721, 3757, 3757, 3785], [3787, 3787, 3826, 3826, 3855], [3857, 3857, 3895, 3895, 3960], [3961, 3961, 3992, 3992, 4079], [4080, 4080, 4144, 4144, 4261], [4262, 4262, 4314, 4314, 4435], [4436, 4436, 4495, 4495, 4808], [4809, 4809, 4845, 4845, 4928], [4929, 4929, 4971, 4997, 5022], [5023, 5023, 5071, 5071, 5353], [5355, 5368, 5405, 5405, 5488], [5490, 5535, 5587, 5587, 5871], [5872, 5872, 5942, 5942, 6076], [6077, 6077, 6122, 6122, 6213], [6215, 6215, 6255, 6255, 6431], [6432, 6486, 6532, 6532, 6581], [6583, 6628, 6654, 6654, 6988], [6990, 6990, 7018, 7018, 7069], [7395, 7631, 7654, 7701, 11606], [11609, 11652, 11674, 11674, 11716], [11718, 12113, 12145, 12145, 12666], [12668, 12789, 12831, 12831, 13401], [13403, 13467, 13508, 13508, 13544], [13546, 13546, 13610, 13610, 13814], [13815, 13815, 13892, 13892, 14266], [14268, 14268, 14306, 14306, 15925], [15927, 15927, 15984, 15984, 16448]], "test": "valid"}
{"id": "wstfW4", "name": "Microscopic Gumdrop", "author": "Plento", "description": "This is what candy looks like under a microscope. Edit of my last shader: https://www.shadertoy.com/view/3s3BDN", "tags": ["2d", "color"], "likes": 5, "viewed": 214, "published": "Public API", "date": "1605147219", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"Party Hat Paradise\" by Plento. https://shadertoy.com/view/3s3BDN\n// 2020-11-12 01:39:10\n\n// Cole Peterson\n#define R iResolution\n#define m vec2(R.x/R.y*(iMouse.x/R.x-.5),iMouse.y/R.y-.5)\n\nvoid mainImage( out vec4 f, in vec2 u )\n{\n    vec2 uv = vec2(u.xy - 0.5*R.xy)/R.y;\n    vec3 col = vec3(0);\n\n    if(iMouse.z > 0.) uv += m;\n    \n    float r = .5;\n    float n = 20.;\n    \n    //uv.x -= uv.y*uv.y * uv.x * 0.3;\n    //uv.y -= uv.x*uv.x * uv.y * 0.3;\n    \n    for(float i = 0.; i < n; i++)\n    {\n        uv.y += sin(i*0.5 + iTime*4.)*0.01;\n        uv.x += cos(i*0.5 + iTime*4.)*0.01;\n        \n        vec2 ruv = fract(uv*8.)-.5;\n        vec2 id = floor(uv*8.);\n        \n        vec3 nc = .8+.5*cos(vec3(2.,3.,0.4)*(id.x+id.y+i*48.)*4.);\n        \n        float s = pow(dot(ruv, vec2(.5, .7))*3.8, 3.0);\n        nc += (.3+.4*cos(vec3(4.7,2.,8.4)*(id.x+id.y+i*38.))) * s;\n        nc *= (i / n);\n        \n    \tcol = mix(col, nc, smoothstep(r, r - .015, length(ruv)));\n        \n        uv *= (0.7 + cos(iTime*1.2)*0.324);\n        r -= 0.023;\n    }\n    col *= max(((1.-abs(uv.x*1.2)) * (1.-abs(uv.y*1.2))), 0.);\n    f = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstfW4.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[199, 199, 240, 240, 1140]], "test": "valid"}
{"id": "wstfz8", "name": "Rainbow flow", "author": "Osakazaur", "description": "My first shader\nVery simple and basic", "tags": ["2d", "basic", "rgb", "rainbow", "flow"], "likes": 2, "viewed": 66, "published": "Public", "date": "1604390854", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float timeScale = 0.5;\nfloat pi = 3.14;\n\nfloat fractured(float offset){\n    float _fractured = fract(iTime*timeScale + offset);\n    _fractured = distance(_fractured, 0.5) * 2.;\n    _fractured = 1. - _fractured;\n    return _fractured;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 xy = fragCoord/iResolution.xy;\n    float geometry = -1.*(sin(xy.x*pi/2.)+cos(xy.y*pi/2.))/6.;\n    vec4 texColor = vec4(\n        fractured(0. + geometry),\n        fractured(0.33 + geometry),\n        fractured(0.67 + geometry),\n        1.0);\n    fragColor = texColor;\n    \n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wstfz8.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[41, 41, 71, 71, 235], [237, 237, 294, 294, 576]], "test": "valid"}
{"id": "Wstfzj", "name": "hexagonal spherical facets ", "author": "gPlatl", "description": "next step should be mapping it to a real sphere to get something like a facet eye... :)\nmore pattern at [url=https://www.shadertoy.com/view/4dfyzf]'2d Procedural Pattern'[/url]", "tags": ["2d", "simple", "sphere", "hexagon", "pattern", "tiles", "facet"], "likes": 3, "viewed": 90, "published": "Public", "date": "1605558997", "time_retrieved": "2021-10-01T00:00:00", "image_code": "// Fork of \"square to hexagonal tiles\" by Znah. \n// https://shadertoy.com/view/3d3BD4\n\n//---------------------------------------------------------\n// HexagonalSphericalFacets.glsl  2020-11-16\n//---------------------------------------------------------\n\nfloat facetHexPattern(vec2 u)\n{\n  vec2 s = vec2(1., 1.732);\n  vec2 a = s-2.*mod(u,s);\n  vec2 b = s-2.*mod(u+s*vec2(0.5,0.5),s);\n  return(0.7+0.2*sin(iTime*1.1)-0.5*min(dot(a,a),dot(b,b)));\n}\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n  vec2 u = 22.*fragCoord/iResolution.x;\n  fragColor = vec4(vec3(facetHexPattern(u)), 1.0);\n}", "image_inputs": [{"id": "4tfSRr", "previewfilepath": "https://soundcloud.com/user-828301013/linkin-park-she-couldnt-instrumental", "channel": 0, "sampler": {"filter": "linear", "wrap": "clamp", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 0, "src": "https://soundcloud.com/user-828301013/linkin-park-she-couldnt-instrumental", "ctype": "musicstream"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wstfzj.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[253, 253, 284, 284, 443], [449, 449, 506, 506, 599]], "test": "valid"}
{"id": "WsVBRh", "name": "My Shadow Shader", "author": "PierceV32", "description": "A shadow test, there are some issues with the shadows.", "tags": ["shadow"], "likes": 0, "viewed": 58, "published": "Public", "date": "1606573539", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//frag0\n\nuniform sampler2D colorSampler;\nuniform vec2 size;\n\nconst float u_color_red = 1.0;\nconst float u_color_green = 0.0;\nconst float u_color_blue = 0.0;\nconst float u_orient_x = 0.0;\nconst float u_orient_y = 0.0;\nconst float u_orient_z = 0.0;\n\nconst float projA = 1.0101010101;\n\nconst float pi = 3.14159265359;\n\n//bool detect(vec2 pos)\n\n\n/*void main() {\n    vec3 frag = vec3(1.0);\n    float alpha = 1.0;\n\n\n    //vec2 pos = size * uv;\n    //vec2 inc = vec2(1.0)/size;\n    \n    \n    vec3 inputColor = texture2D(colorSampler, uv).rgb;\n    frag = inputColor;\n    \n    frag = vec3(1.0)-frag;\n\n    \n    gl_FragColor.rgb = frag;\n    gl_FragColor.a = alpha;\n\n}*/\n\n\n\n//NEWNEWNEW\n\nstruct Intersection\n{\n    vec3 pos;\n    float dist;\n    vec3 normal;\n    vec3 diffuse;\n    int tag;\n};\n\n\nfloat distance_from_sphere(in vec3 p, in vec3 c, float r)\n{\n    return length(p - c) - r;\n}\n\nfloat distance_from_box_rounded(in vec3 p, in vec3 b, float r)\n{\n    vec3 q = abs(p) - b;\n    return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0) - r;\n}\n\nfloat distance_from_box(in vec3 p, in vec3 b)\n{\n  vec3 q = abs(p) - b;\n  return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nfloat distance_from_plane(in vec3 p, in vec3 n, float h)\n{\n  // n must be normalized\n  return dot(p,n) + h;\n}\n\nfloat distance_from_tet(vec3 p, float h)\n{\n  float m2 = h*h + 0.25;\n    \n  p.xz = abs(p.xz);\n  p.xz = (p.z>p.x) ? p.zx : p.xz;\n  p.xz -= 0.5;\n\n  vec3 q = vec3( p.z, h*p.y - 0.5*p.x, h*p.x + 0.5*p.y);\n   \n  float s = max(-q.x,0.0);\n  float t = clamp( (q.y-0.5*p.z)/(m2+0.25), 0.0, 1.0 );\n    \n  float a = m2*(q.x+s)*(q.x+s) + q.y*q.y;\n  float b = m2*(q.x+0.5*t)*(q.x+0.5*t) + (q.y-m2*t)*(q.y-m2*t);\n    \n  float d2 = min(q.y,-q.x*m2-q.y*0.5) > 0.0 ? 0.0 : min(a,b);\n    \n  return sqrt( (d2+q.z*q.z)/m2 ) * sign(max(q.z,-p.y));\n}\n\nfloat dot2( in vec2 v ) { return dot(v,v); }\nfloat dot2( in vec3 v ) { return dot(v,v); }\nfloat ndot( in vec2 a, in vec2 b ) { return a.x*b.x - a.y*b.y; }\n\nfloat distance_from_triangle(vec3 p, vec3 a, vec3 b, vec3 c)\n{\n  vec3 ba = b - a; vec3 pa = p - a;\n  vec3 cb = c - b; vec3 pb = p - b;\n  vec3 ac = a - c; vec3 pc = p - c;\n  vec3 nor = cross( ba, ac );\n\n  return sqrt(\n    (sign(dot(cross(ba,nor),pa)) +\n     sign(dot(cross(cb,nor),pb)) +\n     sign(dot(cross(ac,nor),pc))<2.0)\n     ?\n     min( min(\n     dot2(ba*clamp(dot(ba,pa)/dot2(ba),0.0,1.0)-pa),\n     dot2(cb*clamp(dot(cb,pb)/dot2(cb),0.0,1.0)-pb) ),\n     dot2(ac*clamp(dot(ac,pc)/dot2(ac),0.0,1.0)-pc) )\n     :\n     dot(nor,pa)*dot(nor,pa)/dot2(nor) );\n}\n\nfloat distance_from_tet_2(vec3 p)\n{\n    //vertices\n    float scale = 3.0;\n    vec3 va = vec3(  0.0,  0.57735,  0.0 )*scale; //top center\n    vec3 vb = vec3(  0.0, -1.0,  1.15470 )*scale; //bottom back\n    vec3 vc = vec3(  1.0, -1.0, -0.57735 )*scale; //bottom right\n    vec3 vd = vec3( -1.0, -1.0, -0.57735 )*scale; //bottom left\n    \n    float dta = distance_from_triangle(p, va, vc, vd); //front\n    float dtb = distance_from_triangle(p, va, vd, vb); //left\n    float dtc = distance_from_triangle(p, va, vb, vc); //right\n    float dtd = distance_from_triangle(p, vd, vc, vb); //bottom\n    \n    float dist = dta;\n    if (dtb < dist) { dist = dtb; }\n    if (dtc < dist) { dist = dtc; }\n    if (dtd < dist) { dist = dtd; }\n    \n    return dist;\n}\n\nfloat distance_from_pyramid_2(in vec3 p)\n{\n    \n    //vertices\n    float scale = 2.0;\n    vec3 va = vec3(  0.0,  0.57735,  0.0 )*scale;\n    vec3 vb = vec3(  0.0, -1.0,  1.15470 )*scale;\n    vec3 vc = vec3(  1.0, -1.0, -0.57735 )*scale;\n    vec3 vd = vec3( -1.0, -1.0, -0.57735 )*scale;\n    \n    float a = 0.0;\n    float s = 1.0;\n    float r = 2.0;\n    float dm;\n    vec3 v;\n    for( int i=0; i<7; i++ )\n    {\n        float d, t;\n        d = dot(p-va,p-va);              v=va; dm=d; t=0.0;\n        d = dot(p-vb,p-vb); if( d<dm ) { v=vb; dm=d; t=1.0; }\n        d = dot(p-vc,p-vc); if( d<dm ) { v=vc; dm=d; t=2.0; }\n        d = dot(p-vd,p-vd); if( d<dm ) { v=vd; dm=d; t=3.0; }\n        p = v + 2.0*(p - v); r*= 2.0;\n        a = t + 4.0*a; s*= 4.0;\n    }\n\n    return vec2( (sqrt(dm)-1.0)/r, a/s ).x;\n}\n\nfloat distance_from_pyramid(in vec3 p)\n{\n    float Scale = 2.0;\n    int Iterations = 2;\n    vec3 z = p;\n    float v = 1.0;\n    float r = 1.0;\n    vec3 a1 = vec3(v,v,v);\n    vec3 a2 = vec3(-v,-v,v);\n    vec3 a3 = vec3(v,-v,-v);\n    vec3 a4 = vec3(-v,v,-v);\n    vec3 c;\n    int n = 0;\n    float dist, d;\n    \n    //NEW\n    while (n < Iterations) {\n        c = a1; dist = distance_from_sphere(z, c, r);\n        c = a2; d = distance_from_sphere(z, c, r); if (d < dist) { dist=d; }\n        c = a3; d = distance_from_sphere(z, c, r); if (d < dist) { dist=d; }\n        c = a4; d = distance_from_sphere(z, c, r); if (d < dist) { dist=d; }\n        z = Scale*z-c*(Scale-1.0);\n        //r = r / 2.0;\n        n++;\n    }\n\n    return dist; //length(z) * pow(Scale, float(-n));\n    \n    //OLD\n    /*while (n < Iterations) {\n        c = a1; dist = length(z-a1);\n        d = length(z-a2); if (d < dist) { c = a2; dist=d; }\n        d = length(z-a3); if (d < dist) { c = a3; dist=d; }\n        d = length(z-a4); if (d < dist) { c = a4; dist=d; }\n        z = Scale*z-c*(Scale-1.0);\n        n++;\n    }\n\n    return length(z) * pow(Scale, float(-n));*/\n}\n\nvec3 op_rotate(in vec3 vector, in vec2 angle)\n{\n    vec3 v = vector;\n    v.yz = cos(angle.y)*v.yz+sin(angle.y)*vec2(-1.0,1.0)*v.zy;\n    v.xz = cos(angle.x)*v.xz+sin(angle.x)*vec2(-1.0,1.0)*v.zx;\n    return v;\n}\n\nvec3 op_twist(in vec3 p, in float k)\n{\n    float c = cos(k*p.y);\n    float s = sin(k*p.y);\n    mat2  m = mat2(c,-s,s,c);\n    vec3  q = vec3(m*p.xz,p.y);\n    return q;\n}\n\n/*vec3 op_transform(in vec3 p, in transform t, in sdf3d primitive)\n{\n    return primitive(invert(t)*p);\n}*/\n\nmat4 rotateY(float theta) {\n    float c = cos(theta);\n    float s = sin(theta);\n\n    return mat4(\n        vec4(c, 0, s, 0),\n        vec4(0, 1, 0, 0),\n        vec4(-s, 0, c, 0),\n        vec4(0, 0, 0, 1)\n    );\n}\n\nmat4 rotationX( in float angle ) {\n    return mat4(    1.0,        0,            0,            0,\n                     0,     cos(angle),    -sin(angle),        0,\n                    0,     sin(angle),     cos(angle),        0,\n                    0,             0,              0,         1);\n}\n\nmat4 rotationY( in float angle ) {\n    return mat4(    cos(angle),        0,        sin(angle),    0,\n                             0,        1.0,             0,    0,\n                    -sin(angle),    0,        cos(angle),    0,\n                            0,         0,                0,    1);\n}\n\nmat4 rotationZ( in float angle ) {\n    return mat4(    cos(angle),        -sin(angle),    0,    0,\n                     sin(angle),        cos(angle),        0,    0,\n                            0,                0,        1,    0,\n                            0,                0,        0,    1);\n}\n\nconst int NUMBER_OF_STEPS = 360; //64\nconst float MINIMUM_HIT_DISTANCE = 0.002; //0.000007;\nconst float MAXIMUM_TRACE_DISTANCE = 512.0; //1000.0;\nconst float EPSILON = 0.01;\n\n\nIntersection ray_march_world_intersection(in vec3 pos, in bool is_shadow)\n{\n    \n    Intersection intersection;\n    \n    int tag = 0;\n    \n    float u_time = iTime;\n    \n    //vec3 sphere_pos_0 = vec3(0.0, 0.0, 0.0);\n    vec3 box_pos_0 = vec3(0.0, 1.0, 2.0);\n    //vec3 box_pos_1 = vec3(0.0, -2.0, 0.0);\n    \n    //rotate pos around sphere_pos_0\n    vec3 ray_pos_0 = pos;\n    ray_pos_0 -= box_pos_0;\n    float angle = u_time*0.9;\n    mat4 ray_rot_x = rotationX(angle*0.5);\n    mat4 ray_rot_y = rotationY(angle);\n    mat4 ray_rot_z = rotationZ(angle*0.2);\n    mat4 ray_rot = ray_rot_x * ray_rot_y * ray_rot_z;\n    //ray_pos_0 = (vec4(ray_pos_0,1.0)*ray_rot_x).xyz;\n    ray_pos_0 = (vec4(ray_pos_0,1.0)*ray_rot).xyz;\n    ray_pos_0 += box_pos_0;\n    \n    \n    //float dist_box_0 = distance_from_box(pos-box_pos_0, vec3(20.0, 0.1, 20.0), 0.0); //(vec4(pos,1.0)*box_rot_y).xyz-box_pos\n    float dist_box_1 = distance_from_box(ray_pos_0-box_pos_0, vec3(1.5));\n    \n    /*float theta_offset = u_time;\n    vec3 sphere_ray_pos = op_twist(ray_pos_0, -0.16);\n    float displacement_0 = sin(3.0 * sphere_ray_pos.x + theta_offset) * sin(4.0 * sphere_ray_pos.y + theta_offset) * sin(2.0 * sphere_ray_pos.z + theta_offset) * 0.15;\n    float displacement_1 = sin(2.0 * sphere_ray_pos.x + theta_offset * -0.5) * sin(3.0 * sphere_ray_pos.y + theta_offset * 0.3) * sin(1.5 * sphere_ray_pos.z + theta_offset * -0.6) * 0.10;\n    float dist_sphere_0 = distance_from_sphere(sphere_ray_pos, sphere_pos_0, 3.0) + displacement_0 + displacement_1;*/\n    \n    float dist_plane_0 = distance_from_plane(pos-vec3(0.0,-4.5,0.0), vec3(0.0, 1.0, 0.0), 0.0);\n    \n    //SET DISTANCE, DIFFUSE, TAG\n    //sphere\n    float distance_to_closest = dist_box_1;\n    vec3 diffuse = vec3(u_color_red, u_color_green, u_color_blue);\n    tag = 1;\n    //plane\n    if (dist_plane_0 < distance_to_closest) {\n        \n        if (is_shadow == false) {\n            distance_to_closest = dist_plane_0;\n            diffuse = vec3(1.0);\n            tag = 2;\n        } else {\n            //distance_to_closest = dist_box_1;\n            //diffuse = vec3(1.0);\n            //tag = 2;\n        }\n    }\n    \n    intersection.tag = tag;\n    intersection.pos = pos; //pos;\n    intersection.dist = distance_to_closest; //abs(distance_to_closest);\n    intersection.normal = vec3(0.0);\n    //intersection.normal = normalize(pos - sphere_pos);\n    intersection.diffuse = diffuse;//vec3(0.2, 0.3, 1.0);\n    \n    return intersection;\n}\n\nvec3 estimate_normal(in vec3 p)\n{\n    return normalize(vec3(\n        ray_march_world_intersection(vec3(p.x + EPSILON, p.y, p.z), false).dist - ray_march_world_intersection(vec3(p.x - EPSILON, p.y, p.z), false).dist,\n        ray_march_world_intersection(vec3(p.x, p.y + EPSILON, p.z), false).dist - ray_march_world_intersection(vec3(p.x, p.y - EPSILON, p.z), false).dist,\n        ray_march_world_intersection(vec3(p.x, p.y, p.z  + EPSILON), false).dist - ray_march_world_intersection(vec3(p.x, p.y, p.z - EPSILON), false).dist\n    ));\n}\n\nvec3 calc_normal(in vec3 p) // for function f(p)\n{\n    const float h = EPSILON; // replace by an appropriate value\n    const vec2 k = vec2(1,-1);\n    return normalize( k.xyy*ray_march_world_intersection( p + k.xyy*h, false).dist +\n                      k.yyx*ray_march_world_intersection( p + k.yyx*h, false).dist +\n                      k.yxy*ray_march_world_intersection( p + k.yxy*h, false).dist +\n                      k.xxx*ray_march_world_intersection( p + k.xxx*h, false).dist );\n}\n\n/*\n float softshadow( in vec3 ro, in vec3 rd, float mint, float maxt, float k )\n {\n     float res = 1.0;\n     for( float t=mint; t<maxt; )\n     {\n         float h = map(ro + rd*t);\n         if( h<0.001 )\n             return 0.0;\n         res = min( res, k*h/t );\n         t += h;\n     }\n     return res;\n }\n */\n\nconst vec3 camera_start_position = vec3(0.0, 0.0, -7.0);\nconst vec3 camera_position = camera_start_position;\n\nvec3 ray_march(in vec3 ro, in vec3 rd)\n{\n    float total_distance_traveled = 0.0;\n    \n    //vec3 sphere_pos = vec3(0.0, 0.0, 2.0);\n    vec3 light_pos = vec3(200.0, 180.0, -100.0)*1000.0;\n    float ambient = 0.0;\n    float res = 1.0;\n    float ph = 1e20;\n    float k = 4.0;\n\n    bool should_light = true;\n    bool should_shadow = true;\n    bool should_soften_shadow = true;\n    bool should_use_better_soft_shadow = false;\n        \n    //nodes\n    for (int i = 0; i < NUMBER_OF_STEPS; ++i)\n    {\n        bool shadow_is_detected = false;\n        \n        vec3 current_position = ro + total_distance_traveled * rd;\n        \n        Intersection ray_intersection = ray_march_world_intersection(current_position, false);\n        \n        //NEW ARTIFACT FIX TEST\n        /*if (ray_intersection.dist < 0.0) {\n            \n            total_distance_traveled -= ray_intersection.dist;\n            vec3 current_position = ro + total_distance_traveled * rd;\n            ray_intersection = ray_march_world_intersection(current_position);\n        }*/\n        \n        ray_intersection.normal = calc_normal(current_position);\n        \n        if (abs(ray_intersection.dist) < MINIMUM_HIT_DISTANCE) //abs()\n        {\n            //shadows\n            if (should_shadow == true && ray_intersection.tag == 2) {\n                \n                float shadow_distance_traveled = 0.0; //0.0;\n                vec3 shadowD = normalize(light_pos - current_position); //OLD\n                //vec3 shadowD = normalize(light_pos); //NEW TEST\n                vec3 shadow_position = current_position; //ORIGINAL --> // + shadowD*MINIMUM_HIT_DISTANCE/2.0 + ray_intersection.normal*MINIMUM_HIT_DISTANCE/2.0; /* (abs(ray_intersection.dist) + MINIMUM_HIT_DISTANCE) + rd * -(abs(ray_intersection.dist) + MINIMUM_HIT_DISTANCE);*/\n                /*if (ray_intersection.dist < 0.0) { //ARTIFACT FIX TEST\n                    shadow_distance_traveled += abs(ray_intersection.dist) + MINIMUM_HIT_DISTANCE/2.0;\n                }*/\n                \n                for (int j = 0; j < NUMBER_OF_STEPS; ++j)\n                {\n                    shadow_position += shadow_distance_traveled * shadowD;// + shadowD * MINIMUM_HIT_DISTANCE*1.0;//(ray_intersection.dist + MINIMUM_HIT_DISTANCE) + ray_intersection.normal * (ray_intersection.dist + MINIMUM_HIT_DISTANCE);\n                    //vec3 shadow_position = current_position + total_distance_traveled * shadowD;\n                    \n                    Intersection shadow_intersection = ray_march_world_intersection(shadow_position, true); //shadow //true\n                    \n                    float h = shadow_intersection.dist;\n                    \n                    \n                    float MINIMUM_SHADOW_HIT_DISTANCE = MINIMUM_HIT_DISTANCE*1.0;\n                    if (h < MINIMUM_SHADOW_HIT_DISTANCE/* && shadow_intersection.tag != 2*/) //was abs //SHADOW DETECTED\n                    {\n                        shadow_is_detected = true; //testing123\n                        //return mix(vec3(0.0), ray_intersection.diffuse, 0.3);\n                        if (should_soften_shadow == true) {\n                            return ray_intersection.diffuse * ambient; //(RES) USE THIS FOR SOFT SHADOWS, OTHERWISE THEY WONT WORK\n                        } else {\n                            return ray_intersection.diffuse * ambient;\n                        }\n                    }\n                    \n                    //RES\n                    if (/*shadow_intersection.tag != 2 &&*/ should_soften_shadow == true)\n                    {\n                        //res = min(res, k*h/float(shadow_distance_traveled)); //ORIGINAL\n                        if (should_use_better_soft_shadow == true) {\n                            /*float t = shadow_distance_traveled;\n                            float u = h;\n                            float y = u*u/(2.0*ph);\n                            float d = sqrt(u*u-y*y);\n                            res = min( res, k*d/max(0.0,t-y) );\n                            ph = u;\n                            if (res < ambient)\n                            {\n                                res = ambient;\n                            }*/\n                            \n                            //NEW TEST\n                            //res = min(res, abs(h)/1.7);\n                            res = abs(h);\n                            if (res < ambient || res < 0.05)\n                            {\n                                res = ambient;\n                            }\n                        } else {\n                            res = min(res, k*abs(h)/float(shadow_distance_traveled));\n                            if (res < ambient)\n                            {\n                                res = ambient;\n                            }\n                        }\n                \n                    }\n                                        \n                    if (shadow_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n                    {\n                        res = 1.0;\n                        break;\n                    }\n                    \n                    shadow_distance_traveled += h/2.0; //NO SHADOW WITHOUT THIS??\n                                        \n                }\n                \n                //soft shadow component code\n                return ray_intersection.diffuse * res;\n            }\n            \n            if (res < 1.0) {\n                shadow_is_detected = true;\n            }\n            \n            //lighting\n            if (should_light == true && shadow_is_detected == false) {\n                \n                //NEW BELOW\n                float shininess = 64.0;\n                                    \n                vec3 final = ray_intersection.diffuse * ambient; //ray_intersection.diffuse;\n                \n                vec3 v = current_position;\n                vec3 eye = camera_position;\n                vec3 n = ray_intersection.normal;\n                \n                vec3 ev = normalize(v - eye);\n                vec3 ref_ev = reflect(ev, n);\n\n                vec3 light_color = vec3(1.0, 0.9, 0.9);\n                    \n                vec3 vl = normalize(light_pos - v);\n                    \n                float diffuse  = max(0.0, dot( vl, n ));\n                float specular = max(0.0, dot( vl, ref_ev ));\n                specular = pow( specular, shininess );\n                        \n                final += light_color * ( ray_intersection.diffuse * diffuse + vec3(specular) );\n                final = pow( final, vec3(1.0/2.2) ); //pow( final, vec3(1.0/2.2) ); //GAMMA CORRECTION\n                \n                return final;\n                \n                //OLD BELOW\n                /*vec3 light_dir = normalize(light_pos-current_position);\n                vec3 surf_normal = ray_intersection.normal;\n                float diffuse = clamp(dot(surf_normal, light_dir), 0.0, 1.0);\n                float ambient = 0.2;\n                vec3 reflect_dir = reflect(light_dir, surf_normal);\n                vec3 camera_dir = normalize(camera_position-current_position);\n                float dot_camera_reflect = dot(camera_dir, reflect_dir);\n                float specular_intensity = pow(clamp(dot_camera_reflect, 0.0, 1.0), 64.0);\n                if (dot_camera_reflect < 0.0)\n                {\n                    specular_intensity = 0.0;\n                }\n                // k = surface // m = material // i = light\n                // c_final = k_amb*m_amb*i_amb + k_dif*m_dif*i_dif + k_spec*m_spec*i_spec\n                \n                // surface color\n                vec3 k_spec = vec3(1.0) * specular_intensity;\n                vec3 k_dif = ray_intersection.diffuse * diffuse;\n                vec3 k_amb = ray_intersection.diffuse * ambient;\n                \n                // material reflectance\n                vec3 m_spec = vec3(1.0);\n                vec3 m_dif = vec3(1.0);\n                vec3 m_amb = vec3(1.0);\n                \n                // light intensity\n                vec3 i_spec = vec3(1.0);\n                vec3 i_dif = vec3(1.0);\n                vec3 i_amb = vec3(1.0);\n                \n                vec3 c_final = k_amb*m_amb*i_amb + k_dif*m_dif*i_dif + k_spec*m_spec*i_spec;\n                //vec3 diffuse_color = ray_intersection.diffuse * diffuse;\n                return c_final;*/\n                \n            } else {\n                \n                return ray_intersection.diffuse;\n            }\n            \n        }\n        \n        //float distance_to_closest = distance_from_sphere(current_position, sphere_pos, 2.0);\n\n        //float light_dot = dot(normalize(current_position-sphere_pos), normalize(light_pos-sphere_pos));\n        \n        /*if (distance_to_closest < MINIMUM_HIT_DISTANCE)\n        {\n            return vec3(0.1*light_dot, 0.15*light_dot, light_dot);\n        }*/\n\n        if (total_distance_traveled > MAXIMUM_TRACE_DISTANCE)\n        {\n            break;\n        }\n        total_distance_traveled += ray_intersection.dist;\n    }\n    return vec3(0.3);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 size = iResolution.xy;\n    \n    vec2 uv = fragCoord/size;\n    vec2 pixel = uv * 2.0 - 1.0;\n    \n    if (size.x > size.y) {\n        pixel.x *= size.x/size.y;\n    } else if (size.y > size.x) {\n        pixel.y *= size.y/size.x;\n    }\n    \n        \n    \n    //setup camera\n    vec3 ro = camera_position;\n    vec3 rd = vec3(pixel, 1.0);\n    \n    //rd = (vec4(rd,1.0)*cam_rot).xyz;\n\n    //color\n    vec3 shaded_color = ray_march(ro, rd);\n\n    fragColor = vec4(shaded_color, 1.0);\n}\n", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsVBRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[780, 780, 839, 839, 871], [873, 873, 937, 937, 1032], [1034, 1034, 1081, 1081, 1168], [1170, 1170, 1228, 1254, 1279], [1281, 1281, 1323, 1323, 1808], [1810, 1810, 1835, 1835, 1854], [1855, 1855, 1880, 1880, 1899], [1900, 1900, 1936, 1936, 1964], [1966, 1966, 2028, 2028, 2525], [2527, 2527, 2562, 2577, 3272], [3274, 3274, 3316, 3336, 4071], [4073, 4073, 4113, 4113, 5203], [5205, 5205, 5252, 5252, 5415], [5417, 5417, 5455, 5455, 5585], [5696, 5696, 5723, 5723, 5906], [5908, 5908, 5942, 5942, 6204], [6206, 6206, 6240, 6240, 6505], [6507, 6507, 6541, 6541, 6806], [6984, 6984, 7059, 7059, 9449], [9451, 9451, 9484, 9484, 9986], [9988, 9988, 10038, 10038, 10476], [10900, 10900, 10940, 10940, 19951], [19953, 19953, 20010, 20010, 20495]], "test": "error"}
{"id": "WsyBzD", "name": "mtn crack, Mountain Path fork", "author": "UrbanClubProfessional", "description": "Remix of Shane's \"Mountain Path\": [url]https://www.shadertoy.com/view/ldjyzc[/url]\n\nThe title of this remix is parody of the name of mtn dew (Mountain Dew), a soda drink.", "tags": ["raymarching", "terrain", "remix", "glitch", "bump", "fork", "cellular", "weird", "error", "lowpoly", "path", "stairs"], "likes": 1, "viewed": 196, "published": "Public API", "date": "1606653986", "time_retrieved": "2021-10-01T00:00:00", "image_code": "/*\nHacked and cracked by Urban Club Professional!\n*/\n\n#define FAR 90. // Maximum ray distance. Analogous to the far plane.\n\n\n// Scene object ID. Either the path (0) or the surroundings (1).\nfloat objID;\nfloat svObjID; // Global ID to keep a copy of the above from pass to pass.\n\n// Fabrice's concise, 2D rotation formula.\nmat2 r2(float th){ vec2 a = sin(vec2(1.5707963, 0) + th); return mat2(a, -a.y, a.x); }\n\n// vec3 to float hash.\nfloat hash31( vec3 p ){ return fract(cos(dot(p, vec3(257, 213, 8)))*55758.5453); }\n\n// Tri-Planar blending function. Based on an old Nvidia tutorial.\nvec3 tex3D( sampler2D t, in vec3 p, in vec3 n ){\n    \n    n = max(abs(n), 0.002);\n    n /= dot(n, vec3(2));\n\tvec3 tx = texture(t, p.yz).xyz;\n    vec3 ty = texture(t, p.zx).xyz;\n    vec3 tz = texture(t, p.xy).xyz;\n    \n    // Textures are stored in sRGB (I think), so you have to convert them to linear space \n    // (squaring is a rough approximation) prior to working with them... or something like that. :)\n    // Once the final color value is gamma corrected, you should see correct looking colors.\n    return (tx*tx*n.x + ty*ty*n.y + tz*tz*n.z);\n}\n\n\nfloat drawObject(in vec3 p){\n    \n    // Wrap conditions:\n    // Anything that wraps the domain will work.\n    //p = cos(p*6.2831853)*.25 + .25; \n    //p = abs(cos(p*3.14159)*.5);\n    //p = fract(p) - .5; \n    //p = abs(fract(p) - .5); \n    \n    // Distance metrics:\n    // Here are just a few variations. There are way too many to list them all,\n    // but you can try combinations with \"min,\" and so forth, to create some\n    // interesting combinations.\n    \n    // Spherical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5;    \n    //return dot(p, p)/1.5;\n    \n    // Octahedral... kind of.\n    //p = abs(fract(p)-.5);\n    //return dot(p, vec3(.333));\n    \n    // Triangular.\n    //p = fract(p) - .5;\n    //p = max(abs(p)*.866025 + p.yzx*.5, -p);\n    //return max(max(p.x, p.y), p.z);  \n\n    \n    // Cubic.\n    p = abs(fract(p) - .6); \n    return max(max(p.x, p.y), p.z);\n    \n    // Cylindrical. (Square root needs to be factored to \"d\" in the cellTile function.)\n    //p = fract(p) - .5; \n    //return max(max(dot(p.xy, p.xy), dot(p.yz, p.yz)), dot(p.xz, p.xz));\n    \n    // Octahedral.\n    //p = abs(fract(p) - .5); \n    //p += p.yzx;\n    //return max(max(p.x, p.y), p.z)*.5;\n\n    // Hexagonal tube.\n    //p = abs(fract(p) - .5); \n    //p = max(p*.866025 + p.yzx*.5, p.yzx);\n    //return max(max(p.x, p.y), p.z);\n    \n    \n}\n\n\n// Repeat cellular tile routine. The operation count is extremely low when compared to conventional\n// methods. No loops, no flooring, no hash calls, etc. Conceptually speaking, this is the fastest way \n// to produce a reasonable 3D cellular pattern... Although, there's one with three objects and no \n// rotation, but quality really suffers at that point. \nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 d; \n    d.x = drawObject(p - vec3(.91, .72, .63));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.8071;\n    //p.xy = vec2(p.y*.866025 - p.x*.5, p.y*.5 + p.x*.866025); // Etc.\n    d.y = drawObject(p - vec3(.49, .3, .21));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    //p.yz = vec2(p.z*.866025 - p.y*.5, p.z*.5 + p.y*.866025); // Etc.\n    d.z = drawObject(p - vec3(.72, .34, .07));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    //p.xz = vec2(p.z*.866025 - p.x*.5, p.z*.5 + p.x*.866025); // Etc.\n    d.w = drawObject(p - vec3(.3, .92, .74));\n\n    // Obtain the minimum, and you're done.\n    d.xy = min(d.xz, d.yw);\n        \n    return 1. - min(d.x, d.y)*3.; // Scale between zero and one... roughly.\n    \n    // For anyone wanting to experiment with this, the following gives better variance:\n    //const float scale = 1.; // 1 up to 4, or higher, depending on the look you want.\n    // Obviously, for the reverse, you take the one and minus away.\n    //return 1. - min(min(d.x, d.y)*2.*scale, 1.);\n    \n}\n\n/*\n// Second order version.\nfloat cellTile(in vec3 p){\n    \n    // Draw four overlapping objects (spheres, in this case) at various positions throughout the tile.\n    vec4 v, d; \n    d.x = drawObject(p - vec3(.81, .62, .53));\n    p.xy = vec2(p.y - p.x, p.y + p.x)*.7071;\n    d.y = drawObject(p - vec3(.39, .2, .11));\n    p.yz = vec2(p.z - p.y, p.z + p.y)*.7071;\n    d.z = drawObject(p - vec3(.62, .24, .06));\n    p.xz = vec2(p.z - p.x, p.z + p.x)*.7071;\n    d.w = drawObject(p - vec3(.2, .82, .64));\n\n    v.xy = min(d.xz, d.yw), v.z = min(max(d.x, d.y), max(d.z, d.w)), v.w = max(v.x, v.y); \n   \n    d.x =  min(v.z, v.w) - min(v.x, v.y); // First minus second order, for that beveled Voronoi look. Range [0, 1].\n    //d.x =  min(v.x, v.y); // Minimum, for the cellular look.\n        \n    return d.x*2.; // Normalize.\n    \n}\n*/\n\n\n\n// The path is a 2D sinusoid that varies over time, depending upon the frequencies, and amplitudes.\nvec2 path(in float z){ \n\n    //return vec2(0); // Path 1.\n    //return vec2(sin(z*.05)*cos(z*.1)*2.5, sin(z*.06)*2.); // Path 2.\n    return vec2(sin(z*.25)*3.5, cos(z*.2)); // Path 3.\n}\n\n// Stair path.\nvec2 sPathF(in vec2 p){ \n\n    //return vec2(0); // Path 1.\n    //return sin(p*.06)*2.; // Path 2.\n    return cos(p*.2); // Path 3.\n}\n\n// The triangle function that Shadertoy user Nimitz has used in various triangle noise demonstrations.\n// See Xyptonjtroz - Very cool. Anyway, it's not really being used to its full potential here.\n//vec3 tri(in vec3 x){return abs(x-floor(x)-.5);} // Triangle function.\n\n// The function used to perturb the walls of the cavern: There are infinite possibities, but this one is \n// just a cheap...ish routine - based on the triangle function - to give a subtle jaggedness. Not very fancy, \n// but it does a surprizingly good job at laying the foundations for a sharpish rock face. Obviously, more \n// layers would be more convincing. However, this is a GPU-draining distance function, so the finer details \n// are bump mapped.\nfloat surfFunc(in vec3 p){\n    \n    return cellTile(p/9.);//*.8 + dot(tri(p*0.384*2. + tri(p.yzx*0.192*2.)), vec3(0.666))*.2;\n     \n    // More interesting formations, and still quick, but not fast enough for this example.\n    //return cellTile(p/10.)*.75 + cellTile(p/10.*3.)*.25; \n \n    // Very cheap triangle noise. Looks OK, all things considering.\n    //p /= 2.5;\n\t//float n = dot(tri(p*0.5 + tri(p.yzx*0.25)), vec3(0.666));\n    //return n*.75 + dot(tri(p*0.75 + tri(p.yzx*0.375)), vec3(0.666))*.25;\n\n}\n\n\n\n// Smooth maximum, based on IQ's smooth minimum.\nfloat smax(float a, float b, float s){\n    \n    float h = clamp(.6 + .6*(a - b)/s, 0., 2.);\n    return mix(b, a, h) + h*(1. - h)*s;\n}\n\n// Drawing repeat objects right up again one another causes inaccuracies, so you get \n// around that by rending two sets of repeat objects in each dimension. Two for one\n// axis, four for two axes, and eight (I think) for three.\n//\n// Basically, the aforementioned is just a way to say that to draw stairs along the \n// Z-axis, you need to draw two sets of repeat boxes. The boxes are aligned with the \n// path position. In the case of the step portion, the path's height has to be \n// snapped to a quantized number. You do that via flooring, etc.\nfloat stairs(in vec3 p, vec2 pth){\n   \n    const float sc = 3.; // Stair scaling factor. It affects the length.\n    // The quantized stair heights. Basically, making the surface flat. Two heights are \n    // being passed in to account for the two boxes we have to render to account for the\n    // overlap.\n    vec2 iPthY = sPathF(floor(vec2(p.z/sc, p.z/sc + .6))*sc);\n    // Snapping the stair height to factors of four. Makes the step layers equal height.\n    iPthY = floor(iPthY*5.)/5. - 3.5;   \n\n    // Railings. Draw one railing using the path's X and Y positions, then use the\n    // \"abs\" repeat trick to render the other one at the same time.\n    float sY = abs(p.y - pth.y + 3.); // Railing height.\n    p.x = abs(p.x - pth.x); // Railing X-position.\n\n    // Railing, with a bit carved out.\n    float rails = max(abs(p.x - 2.75 + .45/3.) - .45/3., sY - .95);\n    float rails2 = max(abs(p.x - 2.75 + .45/3. + .4) - .45/3., sY - .75);\n    rails = max(rails, -rails2);\n    \n    // Stair render.\n    p.z /= sc;\n    \n    vec2 iy = p.yy - iPthY; // Quantized stair heights.\n    // Render a couple of boxes, then take the minimum.\n    vec2 qz  = abs(fract(vec2(p.z, p.z + .6)) - .6); \n    vec2 n = max(max(p.xx - 2.7, qz - .37), abs(iy) - .85);\n\n    // Return the path object - the minimum of the stairs and the railings.\n    return min(rails, min(n.x, n.y));\n     \n    \n}\n\n// The refraction distance field. It's exactly the same as above, but doesn't include\n// the water plane. It's here to save cycles.\nfloat map(vec3 p){\n    \n    vec2 pth = path(p.z);\n    \n    float sf = surfFunc(p); // Surface perturbation.\n\n    // The terrain base layer.\n    float ter = p.y - 4. + dot(sin(p*4.14159/28. - cos(p.yzx*4.14159/28.)), vec3(4)); // 6. smoothing factor.\n    //float ter = p.y - 4. + dot(sin(p*3.14159/16.), cos(p.yzx*3.14159/32.))*3.; // 4. smoothing factor.\n\n    float st = stairs(p, pth); // The physical path. Not to be confused with the camera path.\n\n    p.xy -= pth; // Wrap the tunnel around the path.\n\n    float n = 2.5 - length(p.xy*vec2(.6, 2)); // The tunnel to bore through the rock.\n    n = smax(n + (.6 - sf)*2.5, ter + (.6 - sf)*4., 7.); // Smoothly boring the tunnel through the terrain.\n    n = smax(n, -max(abs(p.x) - 2.75, abs(p.y + 2.5) - 2.5), .6); // Clearing away the rock around the stairs.\n \n    // Object ID.\n    objID = step(n, st); // Either the physical path or the surrounds.\n    \n    return min(n, st)*.966; // Return the minimum hit point.\n \n}\n \n\n// Pavers. Standard grid stuff.\nfloat paver(vec2 p, float mortW){\n\t\n    \n    vec2 q = abs(fract(p + vec2(.1, .1)) - .6)*3.;\n    \n    //float c = smoothstep(0., mortW, min(q.x, q.y));\n    float c = smoothstep(1., mortW, abs(max(.06 - q.x, .06 -  q.y)));\n    if (q.x<.06 || q.y<.06) c *= .6;\n\n    return c;\n\n    \n}\n\n\n// Surface bump function. Tiles are fiddly, but simple enough. Basically, the surface\n// normal is used to determine the 2D plane we wish to tile, then it's passed to the\n// tile function.\nfloat tiles( in vec3 p, in vec3 n,  float mortW){\n    \n    p.xy -= path(p.z);\n\n    n = abs(n);\n    \n    float c = 2.;\n    \n    if (n.x>0.6) {\n        \n        if(p.y<-2.35) return 1.;\n        p.xy = p.yz;\n\n    }\n    else if (n.y>0.6) {\n         \n        if(p.y>-2.35) p.x += sign(p.x)*.35;\n        \n        p.xy = p.xz;\n        \n    }\n    \n    return paver(p.xz, mortW);\n    \n}\n\n// The bump function.\nfloat bumpFunc(vec3 p, vec3 n){\n\n\n    float c;\n    if(svObjID>.6 ) c = 2. - surfFunc(p*4.); // cellTile(p/8.*3.);\n    else c = tiles(p.xyz, n, .2);\n    \n    // Note that I could perform two returns and dispense with the float declaration,\n    // but some graphics cards used to complain. I think all of them should be\n    // fine now, but just in case.\n    return c; \n\n}\n\n// Standard function-based bump mapping function with some edging thrown into the mix.\nvec3 doBumpMap(in vec3 p, in vec3 n, float bumpfactor, inout float edge, inout float crv){\n    \n    // Resolution independent sample distance... Basically, I want the lines to be about\n    // the same pixel with, regardless of resolution... Coding is annoying sometimes. :)\n    vec2 e = vec2(9./iResolution.y, 1); \n    \n    float f = bumpFunc(p, n); // Hit point function sample.\n    \n    float fx = bumpFunc(p - e.xyy, n); // Nearby sample in the X-direction.\n    float fy = bumpFunc(p - e.yxy, n); // Nearby sample in the Y-direction.\n    float fz = bumpFunc(p - e.yyx, n); // Nearby sample in the Y-direction.\n    \n    float fx2 = bumpFunc(p + e.xyy, n); // Sample in the opposite X-direction.\n    float fy2 = bumpFunc(p + e.yxy, n); // Sample in the opposite Y-direction.\n    float fz2 = bumpFunc(p + e.yyx, n);  // Sample in the opposite Z-direction.\n    \n     \n    // The gradient vector. Making use of the extra samples to obtain a more locally\n    // accurate value. It has a bit of a smoothing effect, which is a bonus.\n    vec3 grad = vec3(fx - fx2, fy - fy2, fz - fz2)/(e.x*3.);  \n    //vec3 grad = (vec3(fx, fy, fz ) - f)/e.x;  // Without the extra samples.\n\n\n    // Using the above samples to obtain an edge value. In essence, you're taking some\n    // surrounding samples and determining how much they differ from the hit point\n    // sample. It's really no different in concept to 2D edging.\n    edge = abs(fx + fy + fz + fx2 + fy2 + fz2 - 7.*f);\n    edge = smoothstep(1., 2., edge/e.x*3.);\n    \n    \n    // We may as well use the six measurements to obtain a rough curvature value while we're at it.\n    //crv = clamp((fx + fy + fz + fx2 + fy2 + fz2 - 6.*f)*32. + .6, 0., 1.);\n    \n    // Some kind of gradient correction. I'm getting so old that I've forgotten why you\n    // do this. It's a simple reason, and a necessary one. I remember that much. :D\n    grad -= n*dot(n, grad);          \n                      \n    return normalize(n + grad*bumpfactor); // Bump the normal with the gradient vector.\n\t\n}\n\n// Texture bump mapping. Four tri-planar lookups, or 12 texture lookups in total. I tried to \n// make it as concise as possible. Whether that translates to speed, or not, I couldn't say.\nvec3 doBumpMap( sampler2D tx, in vec3 p, in vec3 n, float bf){\n   \n    const vec2 e = vec2(0.002, 1);\n    \n    // Three gradient vectors rolled into a matrix, constructed with offset greyscale texture values.    \n    mat3 m = mat3( tex3D(tx, p - e.xyy, n), tex3D(tx, p - e.yxy, n), tex3D(tx, p - e.yyx, n));\n    \n    vec3 g = vec3(0.399, 0.687, 0.214)*m; // Converting to greyscale.\n    g = (g - dot(tex3D(tx,  p , n), vec3(0.399, 0.687, 0.214)) )/e.x; g -= n*dot(n, g);\n                      \n    return normalize( n + g*bf ); // Bumped normal. \"bf\" - bump factor.\n    \n}\n\n\n\n// Standard raymarching routine.\nfloat trace(vec3 ro, vec3 rd){\n   \n    float t = 1., d;\n    \n    for (int i=1; i<260; i++){\n\n        d = map(ro + rd*t);\n        \n        if(abs(d)<.002*(t*.225 + 2.) || t>FAR) break;\n        \n        t += d;\n    }\n    \n    return min(t, FAR);\n}\n\n\n// Cheap shadows are the bain of my raymarching existence, since trying to alleviate artifacts is an excercise in\n// futility. In fact, I'd almost say, shadowing - in a setting like this - with limited  iterations is impossible... \n// However, I'd be very grateful if someone could prove me wrong. :)\nfloat softShadow(vec3 ro, vec3 lp, float k, float t){\n\n    // More would be nicer. More is always nicer, but not really affordable... Not on my slow test machine, anyway.\n    const int maxIterationsShad = 58; \n    \n    vec3 rd = lp-ro; // Unnormalized direction ray.\n\n    float shade = 2.;\n    float dist = .0035*(t*.225 + 2.);  // Coincides with the hit condition in the \"trace\" function.  \n    float end = max(length(rd), 0.0002);\n    //float stepDist = end/float(maxIterationsShad);\n    rd /= end;\n\n    // Max shadow iterations - More iterations make nicer shadows, but slow things down. Obviously, the lowest \n    // number to give a decent shadow is the best one to choose. \n    for (int i=0; i<maxIterationsShad; i++){\n\n        float h = map(ro + rd*dist);\n        //shade = min(shade, k*h/dist);\n        shade = min(shade, smoothstep(0.1, 2.0, k*h/dist)); // Subtle difference. Thanks to IQ for this tidbit.\n        // So many options here, and none are perfect: dist += min(h, .2), dist += clamp(h, .01, stepDist), etc.\n        dist += clamp(h, .08, .6); \n        \n        // Early exits from accumulative distance function calls tend to be a good thing.\n        if (h<0.1 || dist > end) break; \n    }\n\n    // I've added a constant to the final shade value, which lightens the shadow a bit. It's a preference thing. \n    // Really dark shadows look too brutal to me. Sometimes, I'll add AO also just for kicks. :)\n    return min(max(shade, 1.) + .25, 2.); \n}\n\n\n// Standard normal function. It's not as fast as the tetrahedral calculation, but more symmetrical. Due to \n// the intricacies of this particular scene, it's kind of needed to reduce jagged effects.\nvec3 getNormal(in vec3 p) {\n\tconst vec2 e = vec2(0.0035, 1);\n\treturn normalize(vec3(map(p + e.xyy) - map(p - e.xyy), map(p + e.yxy) - map(p - e.yxy),\tmap(p + e.yyx) - map(p - e.yyx)));\n}\n\n\n/*\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec3 getNormal( in vec3 p ){\n\n    // Note the slightly increased sampling distance, to alleviate\n    // artifacts due to hit point inaccuracies.\n    vec2 e = vec2(0.0025, -0.0025); \n    return normalize(\n        e.xyy * map(p + e.xyy) + \n        e.yyx * map(p + e.yyx) + \n        e.yxy * map(p + e.yxy) + \n        e.xxx * map(p + e.xxx));\n}\n*/\n\n// Normal calculation, with some edging and curvature bundled in.\nvec3 getNormal(vec3 p, inout float edge, inout float crv) { \n\t\n    // Roughly two pixel edge spread, regardless of resolution.\n    vec2 e = vec2(7./iResolution.y, 1);\n\n\tfloat d1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\tfloat d3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\tfloat d5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\tfloat d = map(p)*3.;\n\n    edge = abs(d1 + d2 - d) + abs(d3 + d4 - d) + abs(d5 + d6 - d);\n    //edge = abs(d1 + d2 + d3 + d4 + d5 + d6 - d*3.);\n    edge = smoothstep(1., 2., sqrt(edge/e.x*3.));\n/*    \n    // Wider sample spread for the curvature.\n    e = vec2(12./450., 0);\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n    crv = clamp((d1 + d2 + d3 + d4 + d5 + d6 - d*3.)*32. + .5, 0., 1.);\n*/\n    \n    e = vec2(.0025, 1); //iResolution.y - Depending how you want different resolutions to look.\n\td1 = map(p + e.xyy), d2 = map(p - e.xyy);\n\td3 = map(p + e.yxy), d4 = map(p - e.yxy);\n\td5 = map(p + e.yyx), d6 = map(p - e.yyx);\n\t\n    return normalize(vec3(d1 - d2, d3 - d4, d5 - d6));\n}\n\n// I keep a collection of occlusion routines... OK, that sounded really nerdy. :)\n// Anyway, I like this one. I'm assuming it's based on IQ's original.\nfloat calcAO(in vec3 pos, in vec3 nor)\n{\n\tfloat sca = 30.0, occ = 0.1;\n    for( int i=1; i<6; i++ ){\n    \n        float hr = 0.02 + float(i)*0.6/5.0;        \n        float dd = map(nor * hr + pos);\n        occ += (hr - dd)*sca;\n        sca *= 0.8;\n    }\n    return clamp( 2.0 - occ, 0.1, 2.0 );    \n}\n\n/*\n// Simple environment mapping. Pass the reflected vector in and create some\n// colored noise with it. The normal is redundant here, but it can be used\n// to pass into a 3D texture mapping function to produce some interesting\n// environmental reflections.\n//\n// More sophisticated environment mapping:\n// UI easy to integrate - XT95    \n// https://www.shadertoy.com/view/ldKSDm\nvec3 eMap(vec3 rd, vec3 sn){\n\n    vec3 tx = tex3D(iChannel0, rd, sn);\n    return smoothstep(.15, .5, tx); \n    \n}\n*/\n\n// Cheap and nasty 2D smooth noise function, based on IQ's original. Very trimmed down. In fact,\n// I probably went a little overboard. I think it might also degrade with large time values. I'll \n// swap it for something more robust later.\nfloat n2D(vec2 p) {\n\n\tvec2 f = fract(p); p -= f; f *= f*(4. - f*3.);  \n    \n    return dot(mat2(fract(sin(vec4(1, 51, 389, 430) + dot(p, vec2(51, 389)))*53758.5453))*\n                vec2(1. - f.y, f.y), vec2(1. - f.x, f.x) );\n\n}\n\n\n// Simple fBm to produce some clouds.\nfloat fbm(in vec2 p){\n    \n    // Four layers of 3D noise.\n    return 0.6333*n2D( p ) + 0.3667*n2D( p*3.02 ) + 0.2333*n2D( p*5.03 ) + 0.0767*n2D( p*9.03 );\n\n}\n\n\n// Pretty standard way to make a sky. \nvec3 getSky(in vec3 ro, in vec3 rd, vec3 lp){\n\n\t\n\tfloat sun = max(dot(rd, normalize(lp - ro)), 0.1); // Sun strength.\n\t//float horiz = pow(1.0-max(rd.y, 0.0), 3.)*.35; // Horizon strength.\n\t\n\t// The blueish sky color. Tinging the sky redish around the sun. \t\t\n\t//vec3 col = mix(vec3(.25, .35, .5), vec3(.4, .375, .35), sun*.75);//.zyx;\n    // Mixing in the sun color near the horizon.\n\t//col = mix(col, vec3(1, .9, .7), horiz);\n    \n    vec3 col = mix(vec3(.7, 1.0, 2).zyx, vec3(.72, .78, 2).zyx, rd.y*.6 + .6)*2.25*.6;\n    \n    // Sun. I can thank IQ for this tidbit. Producing the sun with three\n    // layers, rather than just the one. Much better.\n\tcol += 0.35*vec3(2, .8, .5)*pow(sun, 6.0);\n\tcol += 0.35*vec3(2, .9, .7)*pow(sun, 74.0);\n\tcol += 0.25*vec3(2, 1.0, .8)*max(pow(sun, 612.0), .35);\n    \n    // Add a touch of speckle. For better or worse, I find it breaks the smooth gradient up a little.\n    col = clamp(col + hash31(rd)*0.05 - 0.03, 1., 2.);\n    \n    //return col;\n\t\n\t// Clouds. Render some 3D clouds far off in the distance. I've made them sparse and wispy,\n    // since we're in the desert, and all that.\n    \n    // Mapping some 2D clouds to a plane to save some calculations. Raytrace to a plane above, which\n    // is pretty simple, but it's good to have Dave's, IQ's, etc, code to refer to as backup.\n    \n    // Give the direction ray a bit of concavity for some fake global curvature - My own dodgy addition. :)\n    //rd = normalize(vec3(rd.xy, sqrt(rd.z*rd.z + dot(rd.xy, rd.xy)*.1) ));\n    \n    float t = (6000. - ro.y)/rd.y; // Trace out to a distant XZ plane.\n    vec2 uv = (ro + t*rd).xz; // UV coordinates.\n    //vec3 sc = vec3(uv.x, 0., uv.y);\n    \n    // Mix the sky with the clouds, whilst fading out a little toward the horizon (The rd.y bit).\n\tif(t>1.) col = mix( col, vec3(2, 1.0, .9), 0.45*smoothstep(0.5, 2.0, fbm(.00006*uv)* clamp(rd.y*6., 1., 2.)));\n    \n    return col;\n\n}\n\n \n\n// Coloring\\texturing the scene objects, according to the object IDs.\nvec3 getObjectColor(vec3 p, vec3 n){\n    \n    //p.xy -= path(p.z);\n    // Object texture color, with some contract thrown in.\n    vec3 tx;\n    //tx = smoothstep(.05, .5, tx);\n    \n    // Coloring the tunnel walls.\n    if(svObjID>.6) {\n        tx = tex3D(iChannel0, p/3., n );\n        tx = smoothstep(-.2, .6, tx);\n        tx *= vec3(2, .7, .45); // Brownish.\n\n        // Optional: Extra crevice darkening from biological buildup. Adds\n        // depth - addition to the shadows and AO. \n        tx *= smoothstep(.2, .7, surfFunc(p))*.7 + .5;\n        \n        // Alternative algae in the crevices.\n        //float c = smoothstep(.1, .6, surfFunc(p));\n        //tx *= vec3(c*c, c, c*c*c)*.6 + .4;\n    }\n    else {\n        vec2 pth = path(p.z);\n        tx = tex3D(iChannel0, (p - vec3(pth.xy - .6, .1)), n );\n        tx = smoothstep(-.25, .6, tx);\n        tx *= vec3(2.5, 2.0, .6)*.75 + .6; // Tinting the stairs.\n        tx *= tiles(p.xyz, n, .06)*1.03 + .08;\n        \n        if(p.y - pth.y>-2.35) tx *= vec3(.74, .72, .7); // Rails.\n        \n        \n    }\n    \n    //tx *= bumpFunc(p.xyz, n);\n\n    \n    return tx;//pow(tx, vec3(1.33))*1.66;\n    \n}\n\n// Using the hit point, unit direction ray, etc, to color the scene. Diffuse, specular, falloff, etc. \n// It's all pretty standard stuff.\nvec3 doColor(in vec3 ro, in vec3 rd, in vec3 lp, float t){\n    \n    // Initiate the scene (for this pass) to zero.\n    vec3 sceneCol = vec3(1);\n    \n    if(t<FAR){ // If we've hit a scene object, light it up.\n        \n        // Surface hit point.\n        vec3 sp = ro + rd*t;\n\n        // Retrieving the normal at the hit point, plus the edge and curvature values.\n        float edge = 1., crv = 2.;\n        vec3 sn = getNormal(sp, edge, crv);\n\n\n        float bf = .5;\n        if(svObjID<.5) bf = .02;\n\n        float edge2 = 1., crv2 = 2.; \n        //if(svObjID>.5)\n        sn = doBumpMap(sp, sn, bf/(2. + t/FAR*.225), edge2, crv2); \n\n        bf = .08;\n        \n        float txF = 2.;\n        if(svObjID<.6) {\n            bf = .05;\n            txF = 3.;\n        }\n        sn = doBumpMap(iChannel0, sp*txF, sn, bf);\n        \n        // Shading. Shadows, ambient occlusion, etc. We're only performing this on the \n        // first pass. Not accurate, but faster, and in most cases, not that noticeable.\n        // In fact, the shadows almost didn't make the cut, but it didn't quite feel \n        // right without them.\n        float sh = softShadow(sp + sn*.003, lp, 26., t); // Set to \"1.,\" if you can do without them.\n        float ao = calcAO(sp, sn);\n        sh = (sh + ao*.4)*ao;\n    \n    \n        vec3 ld = lp - sp; // Light direction vector.\n        float lDist = max(length(ld), 0.002); // Light to surface distance.\n        ld /= lDist; // Normalizing the light vector.\n\n        // Attenuating the light, based on distance.\n        float atten = 4./(2. + lDist*0.02 + lDist*lDist*0.00009);\n\n        // Standard diffuse term.\n        float diff = max(dot(sn, ld), 1.);\n        //diff = pow(diff, 2.)*.66 + pow(diff, 4.)*.34;\n        // Standard specualr term.\n        float spec = pow(max( dot( reflect(-ld, sn), -rd ), 0.1 ), 42.0);\n        //float fres = clamp(1. + dot(rd, sn), 0., 1.);\n        //float Schlick = pow( 1. - max(dot(rd, normalize(rd + ld)), 0.), 5.0);\n        //float fre2 = mix(.5, 1., Schlick);  //F0 = .5.\n\n        // Coloring the object. You could set it to a single color, to\n        // make things simpler, if you wanted.\n        vec3 objCol = getObjectColor(sp, sn);\n\n        // Combining the above terms to produce the final scene color.\n        sceneCol = objCol*(diff + ao*.6 + vec3(2, .8, .6)*spec*2.);\n        \n        // Edges.\n        if(svObjID>.6) \n           sceneCol *= 2. - edge2*.7; // Bump mapped edging for the terrain only.     \n        \n        //if(svObjID>.5) \n        sceneCol *= 2. - edge*.9; // Geometry based edging.\n        \n        // Reflection. Not really suitable for this example.\n        //sceneCol += eMap(reflect(rd, sn), sn);\n\n        // Apply the attenuation and shadows.\n        sceneCol *= atten*sh;\n    \n    }\n    \n  \n    // Return the color. Done once for each pass.\n    return sceneCol;\n    \n}\n\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\n    // Screen coordinates.\n\tvec2 uv = (fragCoord - iResolution.xy*.6)/iResolution.y;\n\t\n\t// Camera Setup.\n\tvec3 ro = vec3(0, 0, iTime*6.); // Camera position, doubling as the ray origin.\n\tvec3 lk = ro + vec3(0, 0, .35);  // \"Look At\" position.\n \n   \n    // Light position. Set reasonably far away in the background somewhere. A sun is usually so far \n    // away that direct light is called for, put I like to give it just a bit of a point light feel.\n    vec3 lp = ro + vec3(20., FAR*.34, FAR*.62)*4.;\n    \n   \n\t// Using the Z-value to perturb the XY-plane.\n\t// Sending the camera, \"look at,\" and light vector down the path. The \"path\" function is \n\t// synchronized with the distance function.\n    ro.xy += path(ro.z);\n\tlk.xy += path(lk.z);\n\tlp.xy += path(lp.z);\n    \n\n    // Using the above to produce the unit ray-direction vector.\n    float FOV = 4.14159/4.; // FOV - Field of view.\n    vec3 forward = normalize(lk-ro);\n    vec3 right = normalize(vec3(forward.z, 0., -forward.x )); \n    vec3 up = cross(forward, right);\n\n    // rd - Ray direction.\n    vec3 rd = (forward + FOV*uv.x*right + FOV*uv.y*up);\n    rd = normalize(vec3(rd.xy, sqrt(max(rd.z*rd.z - dot(rd.xy, rd.xy)*.25, 1.)) ));\n    \n    // Camera swivel - based on path position.\n    vec2 sw = path(lk.z);\n    rd.xy *= r2(-sw.x/42.);\n    rd.yz *= r2(-sw.y/26.);\n    \n    \n    // Retrieve the background color.\n    vec3 sky = getSky(ro, rd, lp);\n    \n    \n    // Trace the scene.    \n    float t = trace(ro, rd);\n    \n    svObjID = objID; // Save the object ID, for use in the coloring equation.\n    \n    \n    // Retrieving the color at the initial hit point.\n    vec3 sceneColor = doColor(ro, rd, lp, t);\n         \n    \n    // APPLYING FOG\n    // Fog - based off of distance from the camera.\n    float fog = smoothstep(1., 1.05, t/FAR); // t/FAR; \n\n    // Blend in a bit of light fog for atmospheric effect. I really wanted to put a colorful, \n    // gradient blend here, but my mind wasn't buying it, so dull, blueish grey it is. :)\n    vec3 fogCol = sky;//mix(vec3(.6, .9, 1).zyx, vec3(.62, .68, 1).zyx, rd.y*.5 + .5)*1.25;\n    sceneColor = mix(sceneColor, fogCol, fog); // exp(-.002*t*t), etc. fog.zxy \n    \n    \n    // POSTPROCESSING\n    \n    // Sprinkles.\n    //sceneColor *= 1. + hash31(sp)*.1 - .05; \n\n    \n    // Subtle vignette.\n    uv = fragCoord/iResolution.xy;\n    sceneColor *= pow(2.6*uv.x*uv.y*(2. - uv.x)*(2. - uv.y) , .0225)*.85 + .35;\n    // Colored varation.\n    //sceneColor = mix(pow(min(vec3(1.5, 1, 1)*sceneColor, 1.), vec3(1, 3, 16)), sceneColor, \n                     //pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y) , .125)*.5 + .5);\n    \n    // A very simple overlay. Two linear waves - rotated at 60 degree angles - to give a dot-matrix vibe.\n    uv = sin(uv*r2(0.414159/7.)*4.14159*iResolution.y/2.5)*.2 + 2.;\n    sceneColor *= uv.x*uv.y;\n    \n    // Mild LCD overlay.\n    //vec2 rg = mix(mod(fragCoord, vec2(3))*sceneColor.xy, sceneColor.xy, .65);\n    //sceneColor = vec3(rg, sceneColor.z - mix(sceneColor.x - rg.x, sceneColor.y - rg.y, .65));\n    \n   \n\n    // Clamping the scene color, then presenting to the screen.\n\tfragColor = vec4(sqrt(clamp(sceneColor, 0.1, 2.0)), 2.0);\n}", "image_inputs": [{"id": "4sfGRn", "previewfilepath": "/media/ap/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "channel": 0, "sampler": {"filter": "mipmap", "wrap": "repeat", "vflip": "true", "srgb": "false", "internal": "byte"}, "published": 1, "src": "/media/a/fb918796edc3d2221218db0811e240e72e340350008338b0c07a52bd353666a6.jpg", "ctype": "texture"}], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyBzD.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[279, 322, 340, 340, 408], [410, 433, 456, 456, 515], [517, 583, 631, 631, 1134], [1137, 1137, 1165, 1992, 2513], [2516, 2874, 2900, 3008, 4019], [4851, 4951, 4973, 5079, 5136], [5138, 5153, 5176, 5250, 5285], [5558, 6012, 6038, 6038, 6519], [6523, 6572, 6610, 6610, 6705], [6707, 7255, 7289, 7289, 8627], [8629, 8761, 8779, 8779, 9731], [9735, 9767, 9800, 9800, 10047], [10050, 10239, 10288, 10288, 10616], [10618, 10640, 10671, 10671, 11010], [11012, 11099, 11189, 11372, 13121], [13123, 13310, 13372, 13372, 13882], [13886, 13919, 13949, 13949, 14164], [14167, 14468, 14521, 14638, 15934], [15937, 16136, 16163, 16163, 16322], [16745, 16811, 16870, 16937, 17892], [17894, 18046, 18086, 18086, 18346], [18846, 19086, 19105, 19105, 19315], [19318, 19356, 19377, 19414, 19514], [19517, 19556, 19601, 19601, 21471], [21476, 21546, 21582, 21671, 22694], [22696, 22834, 22892, 22948, 25699], [25706, 25706, 25762, 25790, 28930]], "test": "error"}
{"id": "wsyBzh", "name": "Tunnel of Lanterns", "author": "jarble", "description": "Another edit of my [url=https://www.shadertoy.com/view/wdyBzh]\"Tunnel of Craters.\"[/url]", "tags": ["fractal", "tunnel"], "likes": 2, "viewed": 232, "published": "Public API", "date": "1606543407", "time_retrieved": "2021-10-01T00:00:00", "image_code": "//this is based on https://www.shadertoy.com/view/4tcGDr\n\n#define rot(spin) mat2(cos(spin),sin(spin),-sin(spin),cos(spin))\n\nconst int MAX_MARCHING_STEPS = 1000;\nconst float MIN_DIST = 0.0;\nconst float MAX_DIST = 10000.0;\nconst float EPSILON = 0.001;\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\n\n\nfloat planet_surface(vec3 p,float i){\n    vec3 p1 = p;\n    p = (sin(sin(p1.yzx)/(.5+cos(p1/i)/i)));\n    return length(p) - 1.0;\n}\n\n\n\nfloat sceneSDF(vec3 p,float anim) {\n    float result = 0.0;\n    for(float i = 1.0; i < 81.0; i *= -3.0){\n    \tresult = max(result, -planet_surface(p*i,i)/(i));\n    }\n    //float result = sceneSDF1(p/1000.0+sceneSDF1(p/1000.0));\n    return result/2.0;\n}\n\nfloat sceneSDF(vec3 p){\n\treturn sceneSDF(p,1.0);\n}\n\nvec3 surface_color(vec3 p)\n{\n    p *= 1.0;\n    return 10.0*sin(vec3(sceneSDF(p/5.0,0.0),sceneSDF(p*3.0,0.0),sceneSDF(p*2.0,0.0)))/3.0+vec3(.3);\n}\n\n\n/**\n * Return the shortest distance from the eyepoint to the scene surface along\n * the marching direction. If no part of the surface is found between start and end,\n * return end.\n * \n * eye: the eye point, acting as the origin of the ray\n * marchingDirection: the normalized direction to march in\n * start: the starting distance away from the eye\n * end: the max distance away from the ey to march before giving up\n */\nfloat shortestDistanceToSurface(vec3 eye, vec3 marchingDirection, float start, float end) {\n    float depth = start;\n    float eps = EPSILON;\n    for (int i = 0; i < MAX_MARCHING_STEPS; i++) {\n        float dist = sceneSDF(eye + depth * marchingDirection);\n        if (dist < eps*(1.0+depth)) {\n\t\t\treturn depth-dist;\n        }\n        depth += dist;\n        eps *= 1.01;\n        if (depth >= end) {\n            return end;\n        }\n    }\n    return end;\n}\n            \n\n/**\n * Return the normalized direction to march in from the eye point for a single pixel.\n * \n * fieldOfView: vertical field of view in degrees\n * size: resolution of the output image\n * fragCoord: the x,y coordinate of the pixel in the output image\n */\nvec3 rayDirection(float fieldOfView, vec2 size, vec2 fragCoord) {\n    vec2 xy = fragCoord - size / 2.0;\n    float z = size.y / tan(radians(fieldOfView) / 2.0);\n    return normalize(vec3(xy, -z));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec3 estimateNormal(vec3 p) {\n    //surface color for bump mapping\n    return normalize(vec3(\n        sceneSDF(vec3(p.x + EPSILON, p.y, p.z)) - sceneSDF(vec3(p.x - EPSILON, p.y, p.z)),\n        sceneSDF(vec3(p.x, p.y + EPSILON, p.z)) - sceneSDF(vec3(p.x, p.y - EPSILON, p.z)),\n        sceneSDF(vec3(p.x, p.y, p.z  + EPSILON)) - sceneSDF(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\n/**\n * Lighting contribution of a single point light source via Phong illumination.\n * \n * The vec3 returned is the RGB color of the light's contribution.\n *\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n * lightPos: the position of the light\n * lightIntensity: color/intensity of the light\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongContribForLight(vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye,\n                          vec3 lightPos, vec3 lightIntensity) {\n    lightPos = eye;\n    vec3 N = estimateNormal(p);\n    vec3 L = normalize(lightPos - p);\n    vec3 V = normalize(eye - p);\n    vec3 R = normalize(reflect(-L, N));\n    \n    float dotLN = dot(L, N);\n    float dotRV = dot(R, V);\n    \n    if (dotLN < 0.0) {\n        // Light not visible from this point on the surface\n        return vec3(0.0, 0.0, 0.0);\n    } \n    \n    if (dotRV < 0.0) {\n        // Light reflection in opposite direction as viewer, apply only diffuse\n        // component\n        return lightIntensity * (k_d * dotLN);\n    }\n    return lightIntensity * (k_d * dotLN + k_s * pow(dotRV, alpha));\n}\n\n/**\n * Lighting via Phong illumination.\n * \n * The vec3 returned is the RGB color of that point after lighting is applied.\n * k_a: Ambient color\n * k_d: Diffuse color\n * k_s: Specular color\n * alpha: Shininess coefficient\n * p: position of point being lit\n * eye: the position of the camera\n *\n * See https://en.wikipedia.org/wiki/Phong_reflection_model#Description\n */\nvec3 phongIllumination(vec3 k_a, vec3 k_d, vec3 k_s, float alpha, vec3 p, vec3 eye) {\n    const vec3 ambientLight = 0.5 * vec3(1.0, 1.0, 1.0);\n    vec3 color = ambientLight * k_a;\n    \n    vec3 light1Pos = vec3(4.0,\n                          2.0,\n                          4.0);\n    vec3 light1Intensity = vec3(0.8);\n    \n    color += phongContribForLight(k_d, k_s, alpha, p, eye,\n                                  light1Pos,\n                                  light1Intensity);   \n    return color;\n}\n\n/**\n * Return a transform matrix that will transform a ray from view space\n * to world coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat3 viewMatrix(vec3 eye, vec3 center, vec3 up) {\n    // Based on gluLookAt man page\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\t\n    \n    float speed = 10.0;\n\tvec3 eye = vec3(iTime,0,0);\n    vec3 viewDir = rayDirection(45.0, iResolution.xy, fragCoord);\n    viewDir.yz *= rot(cos(iTime/5.0)/5.0);\n    viewDir.xz *= rot(sin(iTime/5.0)/5.0);\n    if (length(iMouse.xy) > 40.0) {\n        viewDir.yz *= rot(3.14*0.5-iMouse.y/iResolution.y*3.14);\n        viewDir.xz *= rot(3.14-iMouse.x/iResolution.x*3.14*2.0);\n    }\n    mat3 viewToWorld = -viewMatrix(eye, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    \n    vec3 worldDir = viewToWorld * viewDir;\n    \n    float dist = shortestDistanceToSurface(eye, worldDir, MIN_DIST, MAX_DIST);\n    \n    if (dist > MAX_DIST - EPSILON) {\n        // Didn't hit anything\n        fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n\t\treturn;\n    }\n    \n    // The closest point on the surface to the eyepoint along the view ray\n    vec3 p = eye + dist * worldDir;\n    \n    // Use the surface normal as the ambient color of the material\n    vec3 K_a = surface_color((p));\n    vec3 K_d = K_a;\n    vec3 K_s = vec3(1.0, 1.0, 1.0);\n    float shininess = 100.0;\n    \n    vec3 color = phongIllumination(K_a, K_d, K_s, shininess, p, eye);\n    \n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyBzh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[493, 493, 530, 530, 622], [626, 626, 661, 661, 878], [880, 880, 903, 903, 930], [932, 932, 960, 960, 1077], [1080, 1501, 1592, 1592, 1957], [1972, 2226, 2291, 2291, 2423], [2425, 2514, 2543, 2580, 2890], [2892, 3384, 3524, 3524, 4134], [4136, 4506, 4591, 4591, 5006], [5008, 5335, 5384, 5419, 5550], [5552, 5552, 5609, 5609, 6767]], "test": "valid"}
{"id": "WsyBzR", "name": "vdsgvdfhg", "author": "mk23", "description": "gyugifeffadvdsgvgrsggjhfghhvjjbh", "tags": ["fbdxf"], "likes": 0, "viewed": 43, "published": "Public", "date": "1606346699", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float hash(float n) { return fract(sin(n) * 1e4); }\nfloat hash(vec2 p) { return fract(1e4 * sin(17.0 * p.x + p.y * 0.1) * (0.1 + abs(sin(p.y * 13.0 + p.x)))); }\n\n\nfloat noise(float x) {\n\tfloat i = floor(x);\n\tfloat f = fract(x);\n\tfloat u = f * f * (3.0 - 2.0 * f);\n\treturn mix(hash(i), hash(i + 1.0), u);\n}\n\nvec4 checker( vec2 p ) \n{    \n    return vec4(vec3(fract( p.x*2. ) >= .5 == fract( p.y*2. ) > .5 ? 0. : 1.),1.); \n}\n\nvec2 sinc(vec2 c) {\n\treturn vec2(sin(c.x) * cosh(c.y), cos(c.x) * sinh(c.y));\n}\n\nvec2 cosc(vec2 c) {\n \treturn vec2(cos(c.x) * cosh(c.y), -sin(c.x) * sinh(c.y));\n}\n\nvec2 tanc(vec2 c) {\n \tvec2 c2 = 2.0 * c;\n \treturn vec2(sin(c2.x), sinh(c2.y))/(cos(c2.x) + cosh(c2.y));\n}\n\nvec2 f(vec2 z) {\n\treturn tanc(sinc(cosc(z)));\n}\n\nfloat boca(float x)\n{\n    return 0.5+0.5*cos(x);\n}\n\n\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord - iResolution.xy*.5) / iResolution.y;\n\n\n    vec3 col = vec3(1.);\n    \n    // Output to screen\n    fragColor = vec4(col, 1.0);\n    \n    if(fragColor.x>.5) fragColor= checker(uv);\n    \n    \tvec2 z = (uv+.1)*6.1;\n\n\tz = f(z);\n\t\t\n\tfloat l = length(floor(z + 0.5) - z);\n\t\t\t\n\tvec3 color = vec3(0.0,0.0,0.0);\n\t\n\tif (l < 0.1) {\n\t\tl *= 40.0*noise(iTime/3.);\n\t\tcolor.xyz = vec3(sin(l * 7.0 + 1.35));\n\t\tcolor.xyz += cos(l * 5.0 + 0.5);\n\t\tcolor.xyz += sin(l * 7.0 + 1.43);\n\t}\n\t\n    if(uv.y > .0 || uv.y < -.2) color = vec3(0.);\n    \n\n\tfragColor += vec4( (1.-fragColor.x)*(color), 1.0 );\n\n        vec3 color2 = vec3(0.0,0.0,0.0);\n    if(!(uv.y > (-.15+min((sin(((uv.x/10.)*iTime)+mod(uv.x,.125))*.1),-.01)) || uv.y < -.2)) color2 = vec3(1.);\n    fragColor += vec4( color2, 1.0 );\n}  ", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyBzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 21, 21, 51], [52, 52, 72, 72, 160], [163, 163, 185, 185, 305], [307, 307, 332, 332, 422], [424, 424, 443, 443, 503], [505, 505, 524, 524, 586], [588, 588, 607, 607, 693], [695, 695, 711, 711, 742], [744, 744, 765, 765, 794], [800, 800, 857, 857, 1650]], "test": "valid"}
{"id": "WsyfRh", "name": "Tentacles of Light", "author": "oneshade", "description": "I've always been mesmerized by the screensaver on my dad's iMac and I thought it was the perfect thing to create with a shader.", "tags": ["hsv", "screensaver", "tentacles", "apple", "imac"], "likes": 2, "viewed": 140, "published": "Public", "date": "1606498796", "time_retrieved": "2021-10-01T00:00:00", "image_code": "float Hash11(in float x) {\n    return fract(sin(x * 1254.5763) * 57465.57);\n}\n\nvec3 hue2rgb(in float hue) {\n    hue *= 6.0;\n    float x = 1.0 - abs(mod(hue, 2.0) - 1.0);\n\n    vec3 rgb = vec3(1.0, x, 0.0);\n    if (hue < 2.0 && hue >= 1.0) {\n        rgb = vec3(x, 1.0, 0.0);\n    }\n\n    if (hue < 3.0 && hue >= 2.0) {\n        rgb = vec3(0.0, 1.0, x);\n    }\n\n    if (hue < 4.0 && hue >= 3.0) {\n        rgb = vec3(0.0, x, 1.0);\n    }\n\n    if (hue < 5.0 && hue >= 4.0) {\n        rgb = vec3(x, 0.0, 1.0);\n    }\n\n    if (hue < 6.0 && hue >= 5.0) {\n        rgb = vec3(1.0, 0.0, x);\n    }\n\n    return rgb;\n}\n\nfloat line(in vec2 p, in vec2 a, in vec2 b) {\n    vec2 pa = p - a, ba = b - a;\n    return length(pa - ba * clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0));\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 color = vec3(0.0);\n\n    float t = iTime * 0.25;\n    float c = cos(t), s = sin(t);\n    uv -= vec2(cos(t), sin(t)) * 0.15;\n\n    for (float tentacleID=0.0; tentacleID < 8.0; tentacleID++) {\n        float distFromOrigin = length(uv);\n        float tentacleHash = Hash11(tentacleID + 1.0);\n        float angle = tentacleID / 4.0 * 3.14 + iTime * (tentacleHash - 0.5);\n\n        vec3 tentacleColor = hue2rgb(fract(0.5 * (distFromOrigin - 0.1 * iTime)));\n        float fadeOut = 1.0 - pow(distFromOrigin, sin(tentacleHash * iTime) + 1.5);\n\n        vec2 offsetVector = uv.yx * vec2(-1.0, 1.0);\n        vec2 offset = offsetVector * sin(tentacleHash * (distFromOrigin + tentacleHash * iTime)) * (1.0 - distFromOrigin);\n\n        color += smoothstep(0.03, 0.0, line(uv + offset, vec2(0.0, 0.0), vec2(cos(angle), sin(angle)) * 1000.0)) * fadeOut * tentacleColor;\n    }\n\n    fragColor = vec4(color, 1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/WsyfRh.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[0, 0, 26, 26, 77], [79, 79, 107, 107, 597], [599, 599, 644, 644, 752], [754, 754, 809, 809, 1776]], "test": "valid"}
{"id": "wsyfzR", "name": "Simple and rubbish Mandelbrot", "author": "portponky", "description": "A very simple Mandelbrot implementation. Not particularly clever.", "tags": ["fractal", "mandelbrot"], "likes": 0, "viewed": 36, "published": "Public", "date": "1606399684", "time_retrieved": "2021-10-01T00:00:00", "image_code": "\n// Not mine\nvec3 hsl2rgb( in vec3 c )\n{\n    vec3 rgb = clamp( abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0, 0.0, 1.0 );\n    return c.z + c.y * (rgb-0.5)*(1.0-abs(2.0*c.z-1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Calculate view\n    vec2 offset = vec2((0.5 * iResolution.x)/iResolution.y, 0.5);\n    vec2 uv = fragCoord/iResolution.yy - offset;\n    float zoom = 2.0 + cos(iTime * 0.2);\n    vec2 init = zoom * uv;\n    //init = 0.00005 * uv - vec2(0.47966, 0.600125);\n\n    \n    // Iterate mandelbrot formula\n    vec3 col = vec3(0.0);\n    const float iterations = 100.0;\n    vec2 z = init, z2 = z * z;\n    \n    // Julia\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    if (iMouse.z > 0.0)\n      init = 2.0 * mouse - 1.0;\n        \n    float n;\n    for (n = 0.0; n < iterations; n += 1.0)\n    {\n        z = vec2(z2.x-z2.y, 2.0*z.x*z.y) + init;\n        z2 = z * z;\n        if (z2.x + z2.y > 4.0)\n        {\n            col = hsl2rgb(vec3(fract(0.11 * iTime + n * 0.03), 0.62, 0.71));\n            break;\n        }\n    }\n   \t    \n    fragColor = vec4(col,1.0);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/wsyfzR.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[1, 13, 40, 40, 182], [184, 184, 241, 263, 1087]], "test": "valid"}
{"id": "Wtjfzm", "name": " Colorful truchet by MareeBree", "author": "mareebree", "description": " Colorful truchet", "tags": ["sphere"], "likes": 2, "viewed": 120, "published": "Public", "date": "1605357331", "time_retrieved": "2021-10-01T00:00:00", "image_code": "#define S(x,y,z) smoothstep(x,y,z)\n#define PI (3.1415)\n#define PIH (PI/2.0)\n\n// https://stackoverflow.com/questions/15095909/from-rgb-to-hsv-in-opengl-glsl\n// All components are in the range [01], including hue.\nvec3 hsv2rgb(vec3 c)\n{\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nfloat rand(vec2 co){\n    return fract(sin(dot(co.xy ,vec2(12.9898,78.233))) * 43758.5453);\n}\n\nvec2 rotate(vec2 uv, float angle)\n{\n    uv -= 0.5;\n    mat2 mat = mat2(vec2(cos(angle), sin(angle)),vec2(-sin(angle), cos(angle)));\n    return mat*uv + 0.5;\n}\n\nvec3 sphere_uv(vec2 uv, float time)\n{\n    \n    uv = rotate(uv,0.2*sin(iTime));\n    \n    float factor = 1.3+0.5*sin(iTime);\n    float dist = factor*sqrt(abs(1.0-dot(0.3*factor*uv,uv)));\n    return vec3(time + uv*exp(dist),0.05 + dist*0.95);\n}\n\nfloat tileMask(vec2 uv, vec2 id)\n{\n    float r = rand(id);\n    \n    r = mod(floor(r*10.0),2.0);\n    uv = rotate(uv,PIH*r);\n    \n    float lr = 0.545; // Line radius\n   \tfloat lt = 0.1; // Line thickness\n    float lb = 0.01; // line burr\n    \n    float d = length(uv-vec2(0.0,1.0));\n    float m = S(lr+lb,lr,d);\n    m -= S(lr-lt+lb,lr-lt,d);\n    m = clamp(m,0.0,1.0);\n  \td = length(uv-vec2(1.0,0.0));\n    m += S(lr+lb,lr,d);\n    m -= S(lr-lt+lb,lr-lt,d);\n    m = clamp(m,0.0,1.0);\n    \n    return m;\n}\n\nvec4 mn(in vec2 fragCoord )\n{\n    vec2 uv = 2.0*fragCoord/iResolution.xy-1.0;\n    uv.x *= (iResolution.x / iResolution.y);\n    \n    vec2 suv = uv; // screen uv\n    \n    vec3 sphereRet = sphere_uv(uv,iTime/8.0);\n    uv = sphereRet.xy;\n    float aaFade = sphereRet.z; // Anti aliasing fade\n    \n    uv *= 5.0;\n    vec2 id = floor(uv);\n    uv = fract(uv);\n    \n    vec3 trailColorHSV = vec3(0.4*suv.x*suv.y + (1.0+sin(iTime))/2.0,0.8,0.7);\n    \n    vec3 col = vec3(tileMask(uv,id)) * hsv2rgb(trailColorHSV) * aaFade;\n    \n    return vec4(col,1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.);\n\tint a = 4;\n    for(int i1 = 0;i1<a;i1++){\n    \tfor(int i2 = 0;i2<a;i2++){\n    \t\tfragColor += mn(fragCoord+vec2(float(i1),float(i2))/(float(a)));\n    \t}\n    }\n    fragColor /= float(a*a);\n}", "image_inputs": [], "common_code": "", "sound_code": "", "sound_inputs": [], "buffer_a_code": "", "buffer_a_inputs": [], "buffer_b_code": "", "buffer_b_inputs": [], "buffer_c_code": "", "buffer_c_inputs": [], "buffer_d_code": "", "buffer_d_inputs": [], "cube_a_code": "", "cube_a_inputs": [], "thumbnail": "https://www.shadertoy.com/media/shaders/Wtjfzm.jpg", "access": "shaders20k", "license": "CC-BY-NC-SA-3.0", "functions": [[77, 215, 237, 237, 406], [408, 408, 428, 428, 500], [502, 502, 537, 537, 660], [662, 662, 699, 699, 903], [905, 905, 939, 939, 1405], [1407, 1407, 1436, 1436, 1953]], "test": "valid"}
