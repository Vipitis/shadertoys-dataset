{"input_both": ["//=====================================================\n\nfloat map( in vec3 p )\n{\n    // triangle\t\n    vec3 q = p - vec3( 0.0, 0.0, 0.0 );\n    vec3 r = vec3( 0.0, 0.0, 0.0 );\n    vec3 s = vec3( 0.0, 0.0, 0.0 );\n    vec3 t = vec3( 0.0, 0.0, 0.0 );\n    vec3 u = vec3( 0.0, 0.0, 0.0 );\n    vec3 v = vec3( 0.0, 0.0, 0.0 );\n    vec3 w = vec3( 0.0, 0.0, 0.0 );\n    vec3 x = vec3( 0.0, 0.0, 0.0 );\n    vec3 y = vec3( 0.0, 0.0, 0.0 );\n    vec3 z = vec3( 0.0, 0.0, 0.0 );\n    vec3 a = vec3( 0.0, 0.0, 0.0 );\n    vec3 b = vec3( 0.0, 0.0, 0.0 );\n    vec3 c = vec3( 0.0, 0.0, 0.0 );\n    vec3 d = vec3( 0.0, 0.0, 0.0 );\n    vec3 e = vec3( 0.0, 0.0, 0.0 );\n    vec3 f = vec3( 0.0, 0.0, 0.0 );\n    vec3 g = vec3( 0.0, 0.0, 0.0 );\n    vec3 h = vec3( 0.0, 0.0, 0.0 );\n    vec3 i = vec3( 0.0, 0", "// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    //p += (1.0/p.y)*0.6;\n\n    // Rotate, but only the part that is on the side of rotDir\n    vec3 rotDir = vec3(0.0, 1.0, 0.0);\n    float rot = sin(p.x*0.01)*0.01;\n    rotDir = rotate(rotDir, rot);\n\n    // Rotate the whole thing\n    p = rotate(p, rot);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    // Move the whole thing\n    p.xz += vec2(0.0, 0.0);\n\n    //"], "input_comment": ["//=====================================================\n\nfloat map( in vec3 p )\n{\n    float a = p.x*p.x + p.y*p.y;\n    float b = p.x*p.x + p.z*p.z;\n    return sqrt( a + b );\n}\n\n//=====================================================\n\nfloat", "// This is the big money function that makes the crazy fractally shape\nfloat DistanceToObject(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat"], "input_docstring": ["float map( in vec3 p )\n{\n    // triangle\t\n    vec3 q = p - vec3( 0.5 );\n    vec3 r = vec3( 0.5 );\n    vec3 s = vec3( 0.5 );\n    vec3 t = vec3( 0.5 );\n    vec3 u = vec3( 0.5 );\n    vec3 v = vec3( 0.5 );\n    vec3 w = vec3( 0.5 );\n    vec3 x = vec3( 0.5 );\n    vec3 y = vec3( 0.5 );\n    vec3 z = vec3( 0.5 );\n\n    // triangle\t\n    vec3 a = p - vec3( 0.5 );\n    vec3 b = vec3( 0.5 );\n    vec3 c = vec3( 0.5 );\n    vec3 d = vec3( 0.5 );\n    vec3 e = vec3( 0.5 );\n    vec3 f = vec3( 0.5 );\n    vec3 g = vec3( 0.5 );\n    vec3 h = vec3( 0.5 );\n    vec3 i = vec3( 0.5 );\n    vec3 j = vec3( 0.5 );\n    vec3 k = vec3( 0.5 );\n    vec3 l = vec3( 0.5 );\n    vec3 m = vec3( 0.5 );\n    vec3 n = vec3( 0.5 );\n    vec3 o = vec3( 0.5 );\n    vec3 p = vec3( 0.5 );\n    vec3 q = vec3( 0.5 );\n    vec3 r = vec3( 0.5 );\n    vec3 s = vec3( 0.5 );\n    vec3 t = vec3( 0.5 );\n    vec3", "float DistanceToObject(vec3 p)\n{\n    //p += (1.0/p.y)*0.6;\n\n    // Rotate, but only the part that is on the side of rotDir\n    vec3 rotDir = vec3(0.0, 1.0, 0.0);\n    float rot = dot(p, rotDir);\n    p = p - rotDir * rot;\n\n    // Rotate, but only the part that is on the side of rotDir\n    vec3 rotDir2 = vec3(0.0, 0.0, 1.0);\n    float rot2 = dot(p, rotDir2);\n    p = p - rotDir2 * rot2;\n\n    // Rotate, but only the part that is on the side of rotDir\n    vec3 rotDir3 = vec3(1.0, 0.0, 0.0);\n    float rot3 = dot(p, rotDir3);\n    p = p - rotDir3 * rot3;\n\n    // Rotate, but only the part that is on the side of rotDir\n    vec3 rotDir4 = vec3(0.0, 0.0, 0.0);\n    float rot4 = dot(p, rotDir4);\n    p = p - rotDir4 * rot4;\n\n    // Rotate, but only the part that is on the side of rotDir\n    vec3 rotDir5 = vec3(0.0, 0.0, 0.0);\n    float rot5 = dot(p, rotDir5);\n    p = p - rotDir5 * rot5;\n\n    // Rotate, but only the part that is on the side of rotDir\n    vec3 rotDir6 = vec3(0.0, 0.0, 0.0);\n    float rot6 = dot(p, rotDir6);\n    p = p - rotDir6 * rot6;\n\n    // Rotate, but only the part that is on the side of rotDir\n    vec3 rotDir7 = vec3(0.0, 0.0, 0.0);\n   "], "input_none": ["float map( in vec3 p )\n{\n    return p.x*p.x + p.y*p.y + p.z*p.z;\n}\n\nvoid main()\n{\n    vec3 p = vec3(gl_FragCoord.xy, 0.0);\n    vec3 d = vec3(0.0);\n    float t = 0.0;\n    float dt = 0.0;\n    float tmax = 100.0;\n    float eps = 0.0001;\n    float eps2 = 0.00001;\n    float dtmax = 0.001;\n    float dtmin = 0.0001;\n    float dtmin2 = 0.00001;\n    float dtmin3 = 0.000001;\n    float dtmin4 = 0.0000001;\n    float dtmin5 = 0.00000001;\n    float dtmin6 = 0.000000001;\n    float dtmin7 = 0.0000000001;\n    float dtmin8 = 0.00000000001;\n    float dtmin9 = 0.000000000001;\n    float dtmin10 = 0.0000000000001;\n    float dtmin11 = 0.00000000000001;\n    float dtmin12 = 0.000000000000001;\n    float dtmin13 = 0.0000000000000001;\n    float dtmin14 = 0.00000000000000001;\n    float dtmin15 = 0.000000000000000001;\n    float dtmin16 = 0.0000000000000000001;\n    float dt", "float DistanceToObject(vec3 p)\n{\n    float d = length(p);\n    return d;\n}\n\nfloat"]}