{"input_docstring-67b": ["\n\treturn cos( a );\n}\n\nfloat", "\n    //vec3 rotDir = vec3(0.0, 1.0, 0.0);\n    //vec3 rotAxis = normalize(cross(rotDir, vec3(0.0, 0.0, 1.0)));\n    //float rotAngle = -0.5*PI;\n    //p = p*mat3(rotAngle, rotAxis);\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.xz *= mat2(cos(0.5*PI), sin(0.5*PI), -sin(0.5*PI), cos(0.5*PI));\n\n    //p.", "\n\tglowCounter = glowCounter + 1.0;\n\n\t// Get the distance to the voxel\n\tfloat d = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d2 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d3 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d4 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d5 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d6 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d7 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d8 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d9 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d10 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d11 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d12 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d13 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d14 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d15 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d16 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d17 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d18 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d19 = length(p) - 0.5;\n\n\t// Get the distance to the sphere\n\tfloat d", "\n\tglowCounter = glowCounter + 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", " coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Get the time\n\tfloat time = iTime;\n\n\t// Get the mouse position\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// Get the aspect ratio\n\tfloat aspect = iResolution.x / iResolution.y;\n\n\t// Get the pixel size\n\tvec2 pixelSize = 1.0 / iResolution.xy;\n\n\t// Get the screen size\n\tvec2 screenSize = iResolution.xy;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1.0 / screenSize;\n\n\t// Get the screen aspect ratio\n\tfloat screenAspect = screenSize.x / screenSize.y;\n\n\t// Get the screen pixel size\n\tvec2 screenPixelSize = 1", "\n\tvec4 colors[4];\n\tcolors[0] = vec4(0.0, 0.0, 1.0, 1.0);\n\tcolors[1] = vec4(0.0, 1.0, 0.0, 1.0);\n\tcolors[2] = vec4(1.0, 1.0, 0.0, 1.0);\n\tcolors[3] = vec4(1.0, 0.0, 0.0, 1.0);\n\n\tfloat steps[4];\n\tsteps[0] = 0.0;\n\tsteps[1] = 0.25;\n\tsteps[2] = 0.5;\n\tsteps[3] = 1.0;\n\n\tvec4 color1 = mix(colors[0], colors[1], smoothstep(steps[0], steps[1], x));\n\tvec4 color2 = mix(colors[1], colors[2], smoothstep(steps[1], steps[2], x));\n\tvec4 color3 = mix(colors[2], colors[3], smoothstep(steps[2], steps[3], x));\n\n\treturn mix(color1, color2, smoothstep(steps[1], steps[2], x));\n}\n\nvoid main()\n{\n\tvec2 uv = gl_FragCoord.xy / resolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tp.x *= resolution.x / resolution.y;\n\n\tfloat a = atan(p.y, p.x);\n\tfloat r = length(p);\n\tfloat f = cos(a * 12.0) * pow(r, 2.0) + 0.5;\n\n\tgl_FragColor = gradient(f);\n}\n", "\n\tvec4 color = texture(colorGradient, vec2(d, 0.0));\n\t\n\t// lookup in normal gradient\n\tvec3 normal = texture(normalGradient, vec2(d, 0.0)).rgb;\n\t\n\t// lookup in specular gradient\n\tfloat specular = texture(specularGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in emissive gradient\n\tvec3 emissive = texture(emissiveGradient, vec2(d, 0.0)).rgb;\n\t\n\t// lookup in opacity gradient\n\tfloat opacity = texture(opacityGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in roughness gradient\n\tfloat roughness = texture(roughnessGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in metallic gradient\n\tfloat metallic = texture(metallicGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in ambient occlusion gradient\n\tfloat ambientOcclusion = texture(ambientOcclusionGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmission = texture(transmissionGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmissionRoughness = texture(transmissionRoughnessGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmissionIOR = texture(transmissionIORGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmissionAnisotropy = texture(transmissionAnisotropyGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmissionSpecular = texture(transmissionSpecularGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat transmissionMetallic = texture(transmissionMetallicGradient, vec2(d, 0.0)).r;\n\t\n\t// lookup in transmission gradient\n\tfloat", " up\n    float t = (rayDir.y + 1.0) * 0.5;\n    t = clamp(t, 0.0, 1.0);\n    t = t * t * (3.0 - 2.0 * t);\n\n    // sun color\n    vec3 sunColor = vec3(1.0, 0.9, 0.8);\n\n    // sky color\n    vec3 skyColor = vec3(0.0, 0.0, 0.0);\n\n    // mix the two colors\n    return mix(skyColor, sunColor, t);\n}\n\nvoid main()\n{\n    // get the ray direction\n    vec3 rayDir = normalize(v_texCoord.xyz);\n\n    // get the sun direction\n    vec3 sunDir = normalize(vec3(0.0, 1.0, 0.0));\n\n    // get the color\n    vec3 color = GetEnvColor2(rayDir, sunDir);\n\n    // output the color\n    out_color = vec4(color, 1.0);\n}\n", "\n    float t = mod ( time, 6.0 ) - 2.0;\n\n    // if t is negative, we're before the curve\n    if ( t < 0.0 )\n        return 0.0;\n\n    // if t is greater than 2.0, we're after the curve\n    if ( t > 2.0 )\n        return 0.0;\n\n    // if t is between 0.0 and 2.0, we're in the curve\n    return 1.0;\n}\n\nvoid main ( void )\n{\n    // get the texture coordinates\n    vec2 coords = gl_TexCoord[0].st;\n\n    // get the current pixel\n    vec4 pixel = texture2D ( texture, coords );\n\n    // get the current pixel's color\n    vec3 color = pixel.rgb;\n\n    // get the current pixel's alpha\n    float alpha = pixel.a;\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2125, 0.7154, 0.0721 ) );\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2125, 0.7154, 0.0721 ) );\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2125, 0.7154, 0.0721 ) );\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2125, 0.7154, 0.0721 ) );\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2125, 0.7154, 0.0721 ) );\n\n    // get the current pixel's luminance\n    float luminance = dot ( color, vec3 ( 0.2", "\n    float t = mod ( time, 10.0 ) - 2.0;\n    if ( t < 0.0 ) t += 10.0;\n\n    // the curve is a sine wave with a period of 10.0\n    float x = coords.x - 0.5;\n    float y = coords.y - 0.5;\n    float r = sqrt ( x * x + y * y );\n    float a = atan ( y, x );\n    float s = sin ( 10.0 * a );\n    float f = s * r;\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a );\n\n    // the curve is a sine wave with a period of 10.0\n    float f = sin ( 10.0 * a", "\n    float t = mod ( time, 5.0 ) - 1.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n\n    // the curve is a quadratic function of the form\n    // y = a * x^2 + b * x + c\n    float a = 0.0;\n    float b = 0", " by changing the value of the variable\n    float speed = 0.001;\n    \n    //change the color of the animation by changing the value of the variable\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    \n    //change the size of the animation by changing the value of the variable\n    float size = 0.001;\n    \n    //change the shape of the animation by changing the value of the variable\n    float shape = 0.001;\n    \n    //change the position of the animation by changing the value of the variable\n    float position = 0.001;\n    \n    //change the rotation of the animation by changing the value of the variable\n    float rotation = 0.001;\n    \n    //change the scale of the animation by changing the value of the variable\n    float scale = 0.001;\n    \n    //change the opacity of the animation by changing the value of the variable\n    float opacity = 0.001;\n    \n    //change the color of the animation by changing the value of the variable\n    float color2 = vec3(0.0, 0.0, 0.0);\n    \n    //change the size of the animation by changing the value of the variable\n    float size2 = 0.001;\n    \n    //change the shape of the animation by changing the value of the variable\n    float shape2 = 0.001;\n    \n    //change the position of the animation by changing the value of the variable\n    float position2 = 0.001;\n    \n    //change the rotation of the animation by changing the value of the variable\n    float rotation2 = 0.001;\n    \n    //change the scale of the animation by changing the value of the variable\n    float scale2 = 0.001;\n    \n    //change the opacity of the animation by changing the value of the variable\n    float opacity2 = 0.001;\n    \n    //change the color of the animation by changing the value of the variable\n    float color3 = vec3(0.0, 0.0, 0.0);\n    \n    //change the size of the animation by changing", "\n    float n = p.x + p.y + p.z + iTime * 0.1;\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin(n);\n\n    // The \"n\" variable is then passed through a sine function, which \n    // distorts the noise.\n    n = sin", "\n    // p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\n    // Slower, but more evenly disperses things.\n    p = p*127.1 + p.yx*269.5;\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nvec", "vec2 grid = floor(p);\n    //vec2 grid_offset = vec2(37.0, 17.0);\n    //float grid_id = dot(grid, grid_offset);\n    \n    //vec2 grid_offset_2 = vec2(1.0, 1.0);\n    //float grid_id_2 = dot(grid, grid_offset_2);\n    \n    //vec2 grid_offset_3 = vec2(1.0, 0.0);\n    //float grid_id_3 = dot(grid, grid_offset_3);\n    \n    //vec2 grid_offset_4 = vec2(0.0, 1.0);\n    //float grid_id_4 = dot(grid, grid_offset_4);\n    \n    //vec2 grid_offset_5 = vec2(0.0, 0.0);\n    //float grid_id_5 = dot(grid, grid_offset_5);\n    \n    //vec2 grid_offset_6 = vec2(1.0, 1.0);\n    //float grid_id_6 = dot(grid, grid_offset_6);\n    \n    //vec2 grid_offset_7 = vec2(1.0, 0.0);\n    //float grid_id_7 = dot(grid, grid_offset_7);\n    \n    //vec2 grid_offset_8 = vec2(0.0, 1.0);\n    //float grid_id_8 = dot(grid, grid_offset_8);\n    \n    //vec2 grid_offset_9 = vec2(0.0, 0.0);\n    //float grid_id_9 = dot(grid, grid_offset_9);\n    \n    //vec2 grid_offset_10 = vec2(1.0, 1.0);\n    //float grid_id_10 = dot(grid, grid_offset_10);\n    \n    //vec2 grid_offset_11 = vec2(1.0, 0.0);\n    //float grid_id_11 = dot(grid, grid_offset_1", "\n    vec2 cell = floor(p);\n    // Get the position of the cell in the space.\n    vec2 cell_pos = cell * 0.5;\n    // Get the position of the cell in the space.\n    vec2 cell_pos_1 = cell * 0.5 + 0.5;\n    // Get the position of the cell in the space.\n    vec2 cell_pos_2 = cell * 0.5 + vec2(0.5, 0.0);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_3 = cell * 0.5 + vec2(0.0, 0.5);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_4 = cell * 0.5 + vec2(0.5, 0.5);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_5 = cell * 0.5 + vec2(0.25, 0.25);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_6 = cell * 0.5 + vec2(0.75, 0.25);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_7 = cell * 0.5 + vec2(0.25, 0.75);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_8 = cell * 0.5 + vec2(0.75, 0.75);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_9 = cell * 0.5 + vec2(0.5, 0.5);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_10 = cell * 0.5 + vec2(0.5, 0.5);\n    // Get the position of the cell in the space.\n    vec2 cell_pos_11 = cell * 0.5 +", "\n  vec3 color = vec3(0.0,0.0,0.0);\n\n  // get the normal\n  vec3 normal = getNormal( rayHitInfo );\n\n  // get the position\n  vec3 position = getPosition( rayHitInfo );\n\n  // get the material\n  Material material = getMaterial( rayHitInfo );\n\n  // get the light\n  Light light = getLight();\n\n  // get the ambient\n  vec3 ambient = material.ambient;\n\n  // get the diffuse\n  vec3 diffuse = material.diffuse;\n\n  // get the specular\n  vec3 specular = material.specular;\n\n  // get the shininess\n  float shininess = material.shininess;\n\n  // get the light position\n  vec3 lightPosition = light.position;\n\n  // get the light color\n  vec3 lightColor = light.color;\n\n  // get the light attenuation\n  vec3 lightAttenuation = light.attenuation;\n\n  // get the light direction\n  vec3 lightDirection = normalize( lightPosition - position );\n\n  // get the view direction\n  vec3 viewDirection = normalize( eyePosition - position );\n\n  // get the halfway direction\n  vec3 halfwayDirection = normalize( lightDirection + viewDirection );\n\n  // get the diffuse factor\n  float diffuseFactor = max( dot( normal, lightDirection ), 0.0 );\n\n  // get the specular factor\n  float specularFactor = pow( max( dot( normal, halfwayDirection ), 0.0 ), shininess );\n\n  // get the attenuation factor\n  float attenuationFactor = 1.0 / ( lightAttenuation.x + lightAttenuation.y * length( lightPosition - position ) + lightAttenuation.z * length( lightPosition - position ) * length( lightPosition - position ) );\n\n  // get the color\n  color = ambient + attenuationFactor * ( diffuse * diffuseFactor + specular * specularFactor ) * lightColor;\n\n  // return the color\n", "\n    vec2 res = vec2(0.0);\n\n    // distance to the sphere\n    float d = length(p) - 1.0;\n\n    // distance to the plane\n    float d2 = p.y;\n\n    // distance to the box\n    float d3 = length(max(abs(p.xz) - vec2(0.5), 0.0));\n\n    // distance to the torus\n    float d4 = length(vec2(length(p.xz) - 0.5, p.y)) - 0.1;\n\n    // distance to the union\n    float d5 = min(d, min(d2, min(d3, d4)));\n\n    // distance to the intersection\n    float d6 = max(d, max(d2, max(d3, d4)));\n\n    // distance to the subtraction\n    float d7 = max(d, -d2);\n\n    // distance to the smooth union\n    float d8 = min(d, d2);\n\n    // distance to the smooth intersection\n    float d9 = max(d, d2);\n\n    // distance to the smooth subtraction\n    float d10 = max(d, -d2);\n\n    // distance to the smooth union\n    float d11 = min(d, d2);\n\n    // distance to the smooth intersection\n    float d12 = max(d, d2);\n\n    // distance to the smooth subtraction\n    float d13 = max(d, -d2);\n\n    // distance to the smooth union\n    float d14 = min(d, d2);\n\n    // distance to the smooth intersection\n    float d15 = max(d, d2);\n\n    // distance to the smooth subtraction\n    float d16 = max(d, -d2);\n\n    // distance to the smooth union\n    float d17 = min(d, d2);\n\n    // distance to the smooth intersection\n    float d18 = max(d, d2);\n\n    // distance to the smooth subtraction\n    float d19 = max(d, -d2);\n\n    // distance to the", "\n\tfloat t = 0.0;\n\tfloat d = 0.0;\n\tfloat m = 0.0;\n\tfloat p = 0.0;\n\tfloat eps = 0.001;\n\tfloat maxd = 100.0;\n\tfloat precis = 0.001;\n\t\n\t// marching loop\n\tfor(int i = 0; i < 100; i++)\n\t{\n\t\t// get the distance to the scene\n\t\td = map(ro + rd * t);\n\t\t\n\t\t// if the distance is smaller than the precision, we are done\n\t\tif(d < precis || t > maxd) break;\n\t\t\n\t\t// march along the ray\n\t\tt += d;\n\t}\n\t\n\t// if we are close enough to the surface, return the color\n\tif(d < precis)\n\t{\n\t\t// get the normal\n\t\tvec3 n = calcNormal(ro + rd * t);\n\t\t\n\t\t// get the color\n\t\tvec3 col = getColor(ro + rd * t, n);\n\t\t\n\t\t// return the color\n\t\treturn vec2(t, col);\n\t}\n\t\n\t// if we are not close enough to the surface, return the background color\n\treturn vec2(t, vec3(0.0));\n}\n\nvoid main()\n{\n\t// get the screen position\n\tvec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\t// get the ray direction\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\t\n\t// get the ray origin\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\t\n\t// cast the ray\n\tvec2 res = castRay(ro, rd);\n\t\n\t// get the distance\n\tfloat t = res.x;\n\t\n\t// get the color\n\tvec3 col = res.y;\n\t\n\t// set the fragment color\n\tgl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec4 res = vec4(0.0);\n\n    // distance to the scene\n    float d = sdScene(p);\n\n    // if the distance is less than the threshold, we are inside the scene\n    if (d < EPSILON)\n    {\n        // get the normal\n        vec3 n = calcNormal(p);\n\n        // get the material\n        res = getMaterial(n);\n    }\n\n    return res;\n}\n\n// ray marching\nvec", "\n    float t = 0.0;\n    float d = 0.0;\n    float m = 0.0;\n    float m2 = 0.0;\n    float m3 = 0.0;\n    float m4 = 0.0;\n    float m5 = 0.0;\n    float m6 = 0.0;\n    float m7 = 0.0;\n    float m8 = 0.0;\n    float m9 = 0.0;\n    float m10 = 0.0;\n    float m11 = 0.0;\n    float m12 = 0.0;\n    float m13 = 0.0;\n    float m14 = 0.0;\n    float m15 = 0.0;\n    float m16 = 0.0;\n    float m17 = 0.0;\n    float m18 = 0.0;\n    float m19 = 0.0;\n    float m20 = 0.0;\n    float m21 = 0.0;\n    float m22 = 0.0;\n    float m23 = 0.0;\n    float m24 = 0.0;\n    float m25 = 0.0;\n    float m26 = 0.0;\n    float m27 = 0.0;\n    float m28 = 0.0;\n    float m29 = 0.0;\n    float m30 = 0.0;\n    float m31 = 0.0;\n    float m32 = 0.0;\n    float m33 = 0.0;\n    float m34 = 0.0;\n    float m35 = 0.0;\n    float m36 = 0.0;\n    float m37 = 0.0;\n    float m38 = 0.0;\n    float m39 = 0.0;\n    float m40 = 0.0;\n    float m41 = 0.0;\n    float m42 = 0.0;\n    float m43 = 0.0;\n    float m44 = 0.0;\n    float m45 = 0.0;\n    float m46 = 0.", "\n    vec3 wp = p * u_worldMatrix;\n    vec3 wpDiff = wp - u_worldPosition;\n    // normal diff\n    vec3 nDiff = oN - u_worldNormal;\n    // normal diff in world space\n    vec3 wnDiff = normalize(mat3(u_worldMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vnDiff = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff2 = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff2 = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff3 = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff3 = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff4 = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff4 = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff5 = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff5 = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff6 = normalize(mat3(u_viewMatrix) * nDiff);\n    // normal diff in view space\n    vec3 vpDiff6 = normalize(mat3(u_viewMatrix) * wpDiff);\n    // normal diff in view space\n    vec3 vnDiff7 = normalize(mat3(u_view", "\n    float x = p.x * 12.9898 + p.y * 78.233 + p.z * 45.5432;\n    float y = p.x * 37.4545 + p.y * 23.3745 + p.z * 89.234;\n    float z = p.x * 19.3745 + p.y * 99.4567 + p.z * 14.987;\n    \n    // Get the fractional part of the numbers\n    float s = mod(x, 1.0);\n    float t = mod(y, 1.0);\n    float u = mod(z, 1.0);\n    \n    // Get the integer part of the numbers\n    int i = int(floor(x));\n    int j = int(floor(y));\n    int k = int(floor(z));\n    \n    // Get the vectors\n    vec3 v1 = vec3(i, j, k);\n    vec3 v2 = vec3(i + 1, j, k);\n    vec3 v3 = vec3(i, j + 1, k);\n    vec3 v4 = vec3(i + 1, j + 1, k);\n    vec3 v5 = vec3(i, j, k + 1);\n    vec3 v6 = vec3(i + 1, j, k + 1);\n    vec3 v7 = vec3(i, j + 1, k + 1);\n    vec3 v8 = vec3(i + 1, j + 1, k + 1);\n    \n    // Get the dot products\n    float d1 = dot(v1, p);\n    float d2 = dot(v2, p);\n    float d3 = dot(v3, p);\n    float d4 = dot(v4, p);\n    float d5 = dot(v5, p);\n    float d6 = dot(v6, p);\n    float d7 = dot(v7, p);\n    float d8 = dot", "\n\t//pR(rayDir.xz, sin(-t * 1.));\n\t//pR(rayDir.xy, sin(-t * 1.));\n\n\tvec3 color = vec3(0.);\n\tfloat weight = 1.;\n\tfloat weightSum = 0.;\n\tfloat weightSum2 = 0.;\n\tfloat weightSum3 = 0.;\n\tfloat weightSum4 = 0.;\n\tfloat weightSum5 = 0.;\n\tfloat weightSum6 = 0.;\n\tfloat weightSum7 = 0.;\n\tfloat weightSum8 = 0.;\n\tfloat weightSum9 = 0.;\n\tfloat weightSum10 = 0.;\n\tfloat weightSum11 = 0.;\n\tfloat weightSum12 = 0.;\n\tfloat weightSum13 = 0.;\n\tfloat weightSum14 = 0.;\n\tfloat weightSum15 = 0.;\n\tfloat weightSum16 = 0.;\n\tfloat weightSum17 = 0.;\n\tfloat weightSum18 = 0.;\n\tfloat weightSum19 = 0.;\n\tfloat weightSum20 = 0.;\n\tfloat weightSum21 = 0.;\n\tfloat weightSum22 = 0.;\n\tfloat weightSum23 = 0.;\n\tfloat weightSum24 = 0.;\n\tfloat weightSum25 = 0.;\n\tfloat weightSum26 = 0.;\n\tfloat weightSum27 = 0.;\n\tfloat weightSum28 = 0.;\n\tfloat weightSum29 = 0.;\n\tfloat weightSum30 = 0.;\n\tfloat weightSum31 = 0.;\n\tfloat weightSum32 = 0.;\n\tfloat weightSum33 = 0.;\n\tfloat weightSum34 = 0.;\n\tfloat weightSum35 = 0.;\n\tfloat weightSum36 = 0.;\n\tfloat weightSum37 = 0.;\n\tfloat weightSum38 = 0.;\n\tfloat weightSum39 = 0.;\n\tfloat weightSum40 = 0.;\n\tfloat weightSum41 = 0.;\n\tfloat weightSum42 = 0.;\n\tfloat weightSum43 = 0.;\n\tfloat weightSum44 = 0.;\n\tfloat weightSum45 = 0.;\n\tfloat weightSum46 = 0.;\n\tfloat weight", "\n    vec2 AB = B - A;\n    vec2 AC = coords - A;\n    vec2 AB_normal = vec2(-AB.y, AB.x);\n    vec2 AC_normal = vec2(-AC.y, AC.x);\n\n    // calculate distance from line segment\n    float distance = dot(AC, AB_normal) / length(AB);\n\n    // calculate distance from line segment\n    float distance_normal = dot(AC_normal, AB_normal) / length(AB);\n\n    // calculate distance from line segment\n    float distance_normal_abs = abs(distance_normal);\n\n    // calculate distance from line segment\n    float distance_abs = abs(distance);\n\n    // calculate distance from line segment\n    float distance_abs_normal = abs(distance_normal);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs = abs(distance_normal_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs = abs(distance_abs_normal_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs = abs(distance_abs_normal_abs_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs_abs = abs(distance_abs_normal_abs_abs_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs_abs_abs = abs(distance_abs_normal_abs_abs_abs_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs_abs_abs_abs = abs(distance_abs_normal_abs_abs_abs_abs_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs_abs_abs_abs_abs = abs(distance_abs_normal_abs_abs_abs_abs_abs_abs);\n\n    // calculate distance from line segment\n    float distance_abs_normal_abs_abs_abs_abs_abs_abs_abs_abs = abs(distance_abs_normal", "\n     float dot = dot(start, end);\n     // Clamp it to be in the range of Acos()\n     // This may be unnecessary, but floating point\n     // precision can be a fickle mistress.\n     dot = clamp(dot, -1.0, 1.0);\n     // Acos(dot) returns the angle between start and end,\n     // And multiplying that by percent returns the angle between\n     // start and the final result.\n     float theta = acos(dot)*percent;\n     vec2 RelativeVec = normalize(end - start*dot);\n     return ((start*cos(theta)) + (RelativeVec*sin(theta)));\n}\n\nvoid main()\n{\n    vec2 start = vec2(0.0, 0.0);\n    vec2 end = vec2(1.0, 1.0);\n    vec2 result = slerp(start, end, 0.5);\n    gl_FragColor = vec4(result, 0.0, 1.0);\n}\n", "\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 camPos = vec3(0.0, 0.0, 1.0);\n    vec3 camTarget = vec3(0.0, 0.0, 0.0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camDir));\n    vec3 camUp = normalize(cross(camDir, camRight));\n    vec3 camCenter = camPos + camDir;\n    vec3 rayDir = normalize(camCenter + uv.x * camRight + uv.y * camUp);\n\n    // set up our scene\n    vec3 lightPos = vec3(0.0, 0.0, 1.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 ambientColor = vec3(0.1, 0.1, 0.1);\n    vec3 diffuseColor = vec3(0.5, 0.5, 0.5);\n    vec3 specularColor = vec3(1.0, 1.0, 1.0);\n    float specularPower = 10.0;\n\n    // set up our raymarching\n    float maxDist = 100.0;\n    float minDist = 0.001;\n    float dist = maxDist;\n    vec3 pos = camPos;\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    // raymarching loop\n    for (int i = 0; i < 100; i++) {\n        dist = sceneSDF(pos);\n        if (dist < minDist) {\n            break;\n        }\n        pos +=", "\n    //\n    //e = a + e * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b - a)\n    //\n    //e = a", " and forth\n    float t = (rayDir.y + 1.0) * 0.5;\n    t = t * t * t * (t * (6.0 * t - 15.0) + 10.0);\n    return mix(vec3(0.0), vec3(0.0, 0.0, 0.05), t);\n}\n\nvec", "\n    // The ball-roller is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.", "^2\n\t// => t^2*dir.x^2 + 2*t*dir.x*org.x + org.x^2 + t^2*dir.y^2 + 2*t*dir.y*org.y + org.y^2 = 0.5^2\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 = 0.5^2\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.5^2 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.25 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.25 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.25 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.25 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x*org.x + dir.y*org.y) + org.x^2 + org.y^2 - 0.25 = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + 2*t*(dir.x", "\n    vec3 q = p - s.xyz;\n    float k = s.w;\n    float h = length(q) - k;\n    float d = max(h, dot(q, r));\n    return d;\n}\n\nfloat", "\n    float x = p.x * 12.9898 + p.y * 78.233 + p.z * 45.5432;\n    float y = p.x * 37.4545 + p.y * 23.3745 + p.z * 89.234;\n    float z = p.x * 19.3745 + p.y * 99.4567 + p.z * 14.987;\n    \n    // Get the fractional part of the numbers\n    float s = mod(x, 1.0);\n    float t = mod(y, 1.0);\n    float u = mod(z, 1.0);\n    \n    // Get the integer part of the numbers\n    int i = int(floor(x));\n    int j = int(floor(y));\n    int k = int(floor(z));\n    \n    // Get the vectors\n    vec3 v1 = vec3(i, j, k);\n    vec3 v2 = vec3(i + 1, j, k);\n    vec3 v3 = vec3(i, j + 1, k);\n    vec3 v4 = vec3(i + 1, j + 1, k);\n    vec3 v5 = vec3(i, j, k + 1);\n    vec3 v6 = vec3(i + 1, j, k + 1);\n    vec3 v7 = vec3(i, j + 1, k + 1);\n    vec3 v8 = vec3(i + 1, j + 1, k + 1);\n    \n    // Get the dot products\n    float d1 = dot(v1, p);\n    float d2 = dot(v2, p);\n    float d3 = dot(v3, p);\n    float d4 = dot(v4, p);\n    float d5 = dot(v5, p);\n    float d6 = dot(v6, p);\n    float d7 = dot(v7, p);\n    float d8 = dot", "\n    float d = length(p) - 0.5;\n    \n    // The shape is a circle.\n    return d;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n    \n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    \n    // Draw the shape.\n    float d = drawShape(uv - 0.5);\n    \n    // The shape is a circle.\n    col = vec3(d);\n    \n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "\n    // fz - Change in \"f\" in in the Z-direction.\n    //\n    // df - Change in \"f\" in in the X-direction.\n    // dg - Change in \"f\" in in the Y-direction.\n    // dh - Change in \"f\" in in the Z-direction.\n    //\n    // dfx - Change in \"df\" in in the X-direction.\n    // dfy - Change in \"df\" in in the Y-direction.\n    // dfz - Change in \"df\" in in the Z-direction.\n    //\n    // dgx - Change in \"dg\" in in the X-direction.\n    // dgy - Change in \"dg\" in in the Y-direction.\n    // dgz - Change in \"dg\" in in the Z-direction.\n    //\n    // dhx - Change in \"dh\" in in the X-direction.\n    // dhy - Change in \"dh\" in in the Y-direction.\n    // dhz - Change in \"dh\" in in the Z-direction.\n    //\n    // dfxdx - Change in \"dfx\" in in the X-direction.\n    // dfxdy - Change in \"dfx\" in in the Y-direction.\n    // dfxdz - Change in \"dfx\" in in the Z-direction.\n    //\n    // dfydx - Change in \"dfy\" in in the X-direction.\n    // dfydy - Change in \"dfy\" in in the Y-direction.\n    // dfydz - Change in \"dfy\" in in the Z-direction.\n    //\n    // dfzdx - Change in \"dfz\" in in the X-direction.\n    // dfzdy - Change in \"dfz\" in in the Y-direction.\n    // dfzdz - Change in \"dfz\" in in the Z-direction.\n    //\n    // dgxdx - Change in \"dgx\" in in the X-direction.\n    // dgxdy - Change in \"dgx\" in in the Y-direction.\n    // dgxdz - Change in \"dgx\" in in the Z-direction.\n    //\n    //", "\n    //vec2 n = vec2(0.0);\n    //n.x = p.x + p.y * 157.0;\n    //n.y = p.y + p.x * 157.0;\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract(sin(n) * 159.5453);\n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 157.0);\n    //return fract", "\n  vec3 l = normalize(vec3(1.0, 1.0, 1.0));\n  vec3 h = normalize(l + normalize(vec3(0.0, 0.0, 1.0)));\n  float ndotl = max(dot(n, l), 0.0);\n  float ndoth = max(dot(n, h), 0.0);\n  float spec = pow(ndoth, 10.0);\n  vec3 color = vec3(0.5, 0.5, 0.5) * ndotl + vec3(1.0, 1.0, 1.0) * spec;\n\n  // ambient light\n  color += vec3(0.1, 0.1, 0.1);\n\n  return color;\n}\n\nvoid main()\n{\n  vec3 p = vec3(gl_FragCoord.xy / resolution.xy, 0.0);\n  vec3 n = normal(p);\n  vec3 color = shade(p, n);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n    Ray ray = createRay(fragCoord);\n    //creates a color object\n    vec3 color = vec3(0.0);\n    //creates a distance object\n    float distance = INFINITY;\n    //creates a hit object\n    Hit hit;\n    //creates a sphere object\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n    //creates a plane object\n    Plane plane = Plane(vec3(0.0, 1.0, 0.0), 0.0);\n    //creates a triangle object\n    Triangle triangle = Triangle(vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    //creates a box object\n    Box box = Box(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    //creates a cylinder object\n    Cylinder cylinder = Cylinder(vec3(0.0, 0.0, 0.0), 1.0, 1.0);\n    //creates a cone object\n    Cone cone = Cone(vec3(0.0, 0.0, 0.0), 1.0, 1.0);\n    //creates a torus object\n    Torus torus = Torus(vec3(0.0, 0.0, 0.0), 1.0, 1.0);\n    //creates a torus knot object\n    TorusKnot torusKnot = TorusKnot(vec3(0.0, 0.0, 0.0), 1.0, 1.0, 1.0);\n    //creates a torus knot object\n    TrefoilKnot trefoilKnot = TrefoilKnot(vec3(0.0, 0.0, 0.0), 1.0", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = ve", "\n    float ka = 0.0055;\n    float kd = 0.7;\n    float ks = 0.3;\n    float sh = 16.0;\n\n    // raymarch\n    float t = march(ro, rd);\n\n    // if march failed, return background color\n    if (t > MAX_DIST) return vec3(0.0);\n\n    // get the surface normal\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // get the material color\n    vec3 col = vec3(0.8, 0.9, 1.0);\n\n    // ambient\n    vec3 amb = ka * col;\n\n    // diffuse\n    vec3 lig = normalize(vec3(1.0, 1.0, 1.0));\n    float dif = kd * max(dot(nor, lig), 0.0);\n    vec3 difCol = dif * col;\n\n    // specular\n    vec3 ref = reflect(rd, nor);\n    float spe = ks * pow(max(dot(ref, lig), 0.0), sh);\n    vec3 speCol = spe * vec3(1.0, 1.0, 1.0);\n\n    // combine\n    vec3 lin = amb + difCol + speCol;\n\n    // fog\n    float fogAmount = exp(-0.0005 * t * t);\n    vec3 fogCol = vec3(0.5, 0.6, 0.7);\n    vec3 col2 = mix(fogCol, lin, fogAmount);\n\n    // return\n    return vec3(col2);\n}\n\nvoid main()\n{\n    // get the ray direction\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3", "\n    return length(p) - rad;\n}\n\nfloat", "\n    float d = p.y;\n    float e = length(p.xz) - param.x;\n    float f = length(p.xz - vec2(param.y, 0.0)) - param.z;\n    float g = length(p.xz - vec2(param.y, param.z)) - param.x;\n    float h = length(p.xz - vec2(0.0, param.z)) - param.x;\n    d = max(d, -e);\n    d = max(d, -f);\n    d = max(d, -g);\n    d = max(d, -h);\n    return d;\n}\n\nfloat", "\n    float d = p.y;\n    float d2 = length(p.xz) - param.x;\n    float d3 = length(p.xz) - param.y;\n    float d4 = length(p.xz) - param.z;\n    float d5 = length(p.xz) - param.w;\n    float d6 = length(p.xz) - param.y;\n    float d7 = length(p.xz) - param.z;\n    float d8 = length(p.xz) - param.w;\n    float d9 = length(p.xz) - param.z;\n    float d10 = length(p.xz) - param.w;\n    float d11 = length(p.xz) - param.w;\n    float d12 = length(p.xz) - param.w;\n    float d13 = length(p.xz) - param.w;\n    float d14 = length(p.xz) - param.w;\n    float d15 = length(p.xz) - param.w;\n    float d16 = length(p.xz) - param.w;\n    float d17 = length(p.xz) - param.w;\n    float d18 = length(p.xz) - param.w;\n    float d19 = length(p.xz) - param.w;\n    float d20 = length(p.xz) - param.w;\n    float d21 = length(p.xz) - param.w;\n    float d22 = length(p.xz) - param.w;\n    float d23 = length(p.xz) - param.w;\n    float d24 = length(p.xz) - param.w;\n    float d25 = length(p.xz) - param.w;\n    float d26 = length(p.xz) - param.w;\n    float d27 = length(p.xz) - param.w;\n    float d28 = length(p.xz) - param.", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = ve", "\n    float ka = 0.005;\n    float kd = 0.005;\n    float ks = 0.005;\n    float kr = 0.005;\n    float kt = 0.005;\n    float kf = 0.005;\n    float ka2 = 0.005;\n    float kd2 = 0.005;\n    float ks2 = 0.005;\n    float kr2 = 0.005;\n    float kt2 = 0.005;\n    float kf2 = 0.005;\n    float ka3 = 0.005;\n    float kd3 = 0.005;\n    float ks3 = 0.005;\n    float kr3 = 0.005;\n    float kt3 = 0.005;\n    float kf3 = 0.005;\n    float ka4 = 0.005;\n    float kd4 = 0.005;\n    float ks4 = 0.005;\n    float kr4 = 0.005;\n    float kt4 = 0.005;\n    float kf4 = 0.005;\n    float ka5 = 0.005;\n    float kd5 = 0.005;\n    float ks5 = 0.005;\n    float kr5 = 0.005;\n    float kt5 = 0.005;\n    float kf5 = 0.005;\n    float ka6 = 0.005;\n    float kd6 = 0.005;\n    float ks6 = 0.005;\n    float kr6 = 0.005;\n    float kt6 = 0.005;\n    float kf6 = 0.005;\n    float ka7 = 0.005;\n    float kd7 = 0.005;\n    float ks7 = 0.005;\n    float kr7 = 0.00", "\n    p = mat2(0.70710678118654757, -0.70710678118654757, 0.70710678118654757, 0.70710678118654757) * p;\n    // diamond.x = diamond.x * 0.57735026918962573;\n    // diamond.y = diamond.y * 0.57735026918962573;\n    // diamond.z = diamond.z * 0.57735026918962573;\n    // diamond.w = diamond.w * 0.57735026918962573;\n    // diamond.x = diamond.x * 0.57735026918962573;\n    // diamond.y = diamond.y * 0.57735026918962573;\n    // diamond.z = diamond.z * 0.57735026918962573;\n    // diamond.w = diamond.w * 0.57735026918962573;\n    // diamond.x = diamond.x * 0.57735026918962573;\n    // diamond.y = diamond.y * 0.57735026918962573;\n    // diamond.z = diamond.z * 0.57735026918962573;\n    // diamond.w = diamond.w * 0.57735026918962573;\n    // diamond.x = diamond.x * 0.57735026918962573;\n    //", "\n    // so that the background is not transformed.\n    vec3 background = vec3(0.0);\n    background += sin(uv.x * 10.0) * sin(uv.y * 10.0) * 0.05;\n    background += sin(uv.x * 10.0) * 0.05;\n    background += sin(uv.y * 10.0) * 0.05;\n    \n    // The main pattern.\n    vec3 pattern = vec3(0.0);\n    pattern += sin(uv.x * 10.0) * sin(uv.y * 10.0) * 0.05;\n    pattern += sin(uv.x * 10.0) * 0.05;\n    pattern += sin(uv.y * 10.0) * 0.05;\n    \n    // The main pattern, but with a different color.\n    vec3 pattern2 = vec3(0.0);\n    pattern2 += sin(uv.x * 10.0) * sin(uv.y * 10.0) * 0.05;\n    pattern2 += sin(uv.x * 10.0) * 0.05;\n    pattern2 += sin(uv.y * 10.0) * 0.05;\n    \n    // The main pattern, but with a different color.\n    vec3 pattern3 = vec3(0.0);\n    pattern3 += sin(uv.x * 10.0) * sin(uv.y * 10.0) * 0.05;\n    pattern3 += sin(uv.x * 10.0) * 0.05;\n    pattern3 += sin(uv.y * 10.0) * 0.05;\n    \n    // The main pattern, but with a different color.\n    vec3 pattern4 = vec3(0.0);\n    pattern4 += sin(uv.x * 10.0) * sin(uv.y * 10.0) * 0.0", "\n\tfloat d = sdSphere( pos, 1.0 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 2.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, -2.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 2.0, 0.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, -2.0, 0.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 2.0, 0.0, 0.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( -2.0, 0.0, 0.0 ), 1.0 ), 0.5 );\n\treturn d;\n}\n\nvec", "\n\tvec3 light = vec3( 0.0 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, 0.5, 0.5 );\n\tlight += vec3( 0.5, ", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(dot(p,vec2(127.1,311.", "\n    // 0.0    0.0   |    0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float aa = a * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaa = aa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaa = aaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaa = aaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaa = aaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaa = aaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaa = aaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaa = aaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaa = aaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaa = aaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaa = aaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaa = aaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaa = aaaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaaa = aaaaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaaaa = aaaaaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaaaaa = aaaaaaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaaaaaa = aaaaaaaaaaaaaaaaa * 1.0;\n    //Increase Activity Level For Better Performance\n    float aaaaaaaaaaaaaaaaaaa = aaaaaaaaaaaaaaaaaa * 1.0;\n    //Increase", "\n    float d = length(p.xz) - r;\n    // How far inside or outside the cylinder the point is, along the height\n    float t = abs(p.y) - h;\n    // Return the smallest distance to the cylinder\n    return min(max(d, t), 0.0) + length(max(vec2(d, t), 0.0));\n}\n\nfloat", "\n    float t = iTime * 0.5;\n    mat3 rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n    p = rot * p;\n\n    // Slowly spin the whole scene\n    t = iTime * 0.5;\n    rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n    p = rot * p;\n\n    // Slowly spin the whole scene\n    t = iTime * 0.5;\n    rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n    p = rot * p;\n\n    // Slowly spin the whole scene\n    t = iTime * 0.5;\n    rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n    p = rot * p;\n\n    // Slowly spin the whole scene\n    t = iTime * 0.5;\n    rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );\n    p = rot * p;\n\n    // Slowly spin the whole scene\n    t = iTime * 0.5;\n    rot = mat3(\n        cos(t), 0.0, sin(t),\n        0.0, 1.0, 0.0,\n        -sin(t), 0.0, cos(t)\n    );", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat3(s, u, -f);\n}\n\nmat", "\n    float n = snoise(p);\n    n = n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*", "\n    //but the color is based on the distance to the nearest point\n    //in the set.\n    //The distance is calculated using the distance function\n    //and the color is calculated using the color function.\n    //The color function is a simple linear interpolation between\n    //two colors.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //The distance function is a simple distance function.\n    //", "\n    // The \"w\" parameter is the \"width\" of the pattern.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n    // The \"p\" parameter is the input coordinate.\n", "\n    float r = length(p.xz);\n    float h = p.y;\n    \n    // The bump function.\n    float bump = sin(r*10.0)*sin(h*10.0);\n    \n    // The bump function is multiplied by a smoothstep function.\n    // This is a function that smoothly goes from 0 to 1 as the\n    // distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    // as the distance from the origin goes from 0 to 1.\n    // The smoothstep function is a function that goes from 0 to 1\n    //", "\n    //\n    // view_inv: inverse of the view matrix\n    // proj_inv: inverse of the projection matrix\n    // viewp_inv: inverse of the view-projection matrix\n    // scr_pt: screen coordinates of a point\n    //\n    // Returns: vec4(world_pt, 0)\n\n    vec4 scr_pt_hom = vec4(scr_pt, 0.0, 1.0);\n    vec4 viewp_pt = viewp_inv * scr_pt_hom;\n    viewp_pt /= viewp_pt.w;\n    vec4 world_pt = view_inv * viewp_pt;\n    return world_pt;\n}\n\nvec", "\n    rounded = min(rounded, 1.0);\n\n    // Get the distance to the line.\n    float dist = LineDist(uv, pA, pB);\n\n    // Get the distance to the rounded end caps.\n    float capDist = min(LineDist(uv, pA, pB), LineDist(uv, pB, pA));\n    capDist = min(capDist, LineDist(uv, pA, pB));\n\n    // Get the distance to the dash.\n    float dashDist = LineDist(uv, pA, pB);\n    dashDist = min(dashDist, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist2 = LineDist(uv, pA, pB);\n    dashDist2 = min(dashDist2, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist3 = LineDist(uv, pA, pB);\n    dashDist3 = min(dashDist3, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist4 = LineDist(uv, pA, pB);\n    dashDist4 = min(dashDist4, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist5 = LineDist(uv, pA, pB);\n    dashDist5 = min(dashDist5, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist6 = LineDist(uv, pA, pB);\n    dashDist6 = min(dashDist6, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist7 = LineDist(uv, pA, pB);\n    dashDist7 = min(dashDist7, LineDist(uv, pB, pA));\n\n    // Get the distance to the dash.\n    float dashDist8 = LineDist(uv, pA, pB);\n    dashDist8 = min(dashDist8, LineDist(uv,", "\n  vec3 l = normalize(vec3(1.0, 1.0, 1.0));\n  vec3 h = normalize(l + vec3(0.0, 0.0, 1.0));\n  float ndotl = max(dot(n, l), 0.0);\n  float ndoth = max(dot(n, h), 0.0);\n  float spec = pow(ndoth, 10.0);\n  vec3 color = vec3(0.5, 0.5, 0.5) * ndotl + vec3(1.0, 1.0, 1.0) * spec;\n\n  // ambient light\n  color += vec3(0.1, 0.1, 0.1);\n\n  return color;\n}\n\nvoid main()\n{\n  vec3 p = vec3(gl_FragCoord.xy / resolution.xy, 0.0);\n  vec3 n = normalize(vec3(0.0, 0.0, 1.0));\n  vec3 color = Shade(p, n);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n\tvec3 m = 1.0 / rd;\n\tvec3 n = m * ro;\n\tvec3 k = abs( m ) * rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\tif( tN > tF || tF < 0.0 ) return vec2( -1.0 );\n\treturn vec2( tN, tF );\n}\n\n// ray-sphere intersection\nfloat", "          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          ___          _", "\n\treturn vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y);\n}\n\nvec", "\n    vec3 pa2 = pa - ro;\n    vec3 pb2 = pb - ro;\n    vec3 ba = pb2 - pa2;\n    vec3 oa = ro - pa2;\n    vec3 ob = ro - pb2;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float bard2 = bard*bard;\n    float baoa2 = baoa*baoa;\n    float rard2 = ra*ra*bard2;\n    float rard22 = rard2*rard2;\n    float rard222 = rard22*rard22;\n    float rard222_baba = rard222/baba;\n    float rard222_baba_bard = rard222_baba*bard;\n    float rard222_baba_bard2 = rard222_baba*bard2;\n    float rard222_baba_bard2_baoa = rard222_baba_bard2*baoa;\n    float rard222_baba_bard2_baoa2 = rard222_baba_bard2*baoa2;\n    float rard222_baba_bard2_baoa2_baba = rard222_baba_bard2_baoa2/baba;\n    float rard222_baba_bard2_baoa2_baba_bard = rard222_baba_bard2_baoa2_baba*bard;\n    float rard222_baba_bard2_baoa2_baba_bard2 = rard222_baba_bard2_baoa2_baba*bard2;\n    float rard222_baba_bard2_baoa2_baba_bard2_baoa = rard222_baba_", "\n\n\tfloat d = length(P-U);\n\tO = vec4(C, smoothstep(r,r-1.,d));\n}\n\nvoid sphere(inout vec4 O, vec2 U, vec2 P, float r, vec3 C, float s) { // O, U, pos, radius, color, smoothness\n\t\n // vec2 R = iResolution.xy, M = (2.*iMouse.xy-R)/R.y;\n // P = P + (P-M)*smoothstep(.9,.0,length(P-M)); // mouse repeal spheres \n // U = U + (U-M)*smoothstep(.9,.0,length(U-M)); // mouse repeal pixels\n\n\tfloat d = length(P-U);\n\tO = vec4(C, smoothstep(r,r-s,d));\n}\n\nvoid sphere(inout vec4 O, vec2 U, vec2 P, float r, vec3 C, float s, float a) { // O, U, pos, radius, color, smoothness, alpha\n\t\n // vec2 R = iResolution.xy, M = (2.*iMouse.xy-R)/R.y;\n // P = P + (P-M)*smoothstep(.9,.0,length(P-M)); // mouse repeal spheres \n // U = U + (U-M)*smoothstep(.9,.0,length(U-M)); // mouse repeal pixels\n\n\tfloat d = length(P-U);\n\tO = vec4(C, smoothstep(r,r-s,d)*a);\n}\n\nvoid sphere(inout vec4 O, vec2 U, vec2 P, float r, vec3 C, float s, float a, float t) { // O, U, pos, radius, color, smoothness, alpha, time\n\t\n // vec2 R = iResolution.xy, M = (2.*iMouse.xy-R)/R.y;\n // P = P + (P-M)*smoothstep(.9,.0,length(P-M)); // mouse repeal spheres \n // U = U", "\n    p.xz *= mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05 * sin(10.0 * p.xz);\n    p.xz *= 1.0 + 0.05", "\n    float scale = (1.0 - layerID) * 0.5;\n    float scale2 = scale * scale;\n    float scale4 = scale2 * scale2;\n    float scale8 = scale4 * scale4;\n    float scale16 = scale8 * scale8;\n    float scale32 = scale16 * scale16;\n    float scale64 = scale32 * scale32;\n    float scale128 = scale64 * scale64;\n    float scale256 = scale128 * scale128;\n    float scale512 = scale256 * scale256;\n    float scale1024 = scale512 * scale512;\n    float scale2048 = scale1024 * scale1024;\n    float scale4096 = scale2048 * scale2048;\n    float scale8192 = scale4096 * scale4096;\n    float scale16384 = scale8192 * scale8192;\n    float scale32768 = scale16384 * scale16384;\n    float scale65536 = scale32768 * scale32768;\n    float scale131072 = scale65536 * scale65536;\n    float scale262144 = scale131072 * scale131072;\n    float scale524288 = scale262144 * scale262144;\n    float scale1048576 = scale524288 * scale524288;\n    float scale2097152 = scale1048576 * scale1048576;\n    float scale4194304 = scale2097152 * scale2097152;\n    float scale8388608 = scale4194304 * scale4194304;\n    float scale16777216 = scale8", "\n    p = p*1.15;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p*0.5;\n    \n    // Scale the tile to a square.\n    p = p", "\n\n    // \u043f\u043e\u0432\u043e\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u043f\u043e \u043e\u0441\u0438 X\n    currentRayPosition.yz = rotate(currentRayPosition.yz, iTime);\n\n    // \u043f\u043e\u0432\u043e\u0440\u0430\u0447\u0438\u0432\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u043f\u043e \u043e\u0441\u0438 Z\n    currentRayPosition.xy = rotate(currentRayPosition.xy, iTime);\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043b\u0435\u0432\u043e\n    currentRayPosition.x -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043f\u0440\u0430\u0432\u043e\n    currentRayPosition.x += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u0432\u0435\u0440\u0445\n    currentRayPosition.y += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043b\u0435\u0432\u043e\n    currentRayPosition.x -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043f\u0440\u0430\u0432\u043e\n    currentRayPosition.x += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u0432\u0435\u0440\u0445\n    currentRayPosition.y += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043b\u0435\u0432\u043e\n    currentRayPosition.x -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043f\u0440\u0430\u0432\u043e\n    currentRayPosition.x += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u0432\u0435\u0440\u0445\n    currentRayPosition.y += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043b\u0435\u0432\u043e\n    currentRayPosition.x -= 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043f\u0440\u0430\u0432\u043e\n    currentRayPosition.x += 0.5;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u0432\u0435\u0440\u0445\n    currentRayPosition.", "\n    float flameDistance = abs(currentRayPosition.y);\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint2 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint3 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint4 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint5 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint6 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint7 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint8 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0431\u043b\u0438\u0436\u0430\u0439\u0448\u0435\u0439 \u0442\u043e\u0447\u043a\u0438\n    float distanceToPoint9 = distance(currentRayPosition, vec3(0.0, 0.0, 0.0));\n\n   ", "\n    float sf = 1.0;\n    \n    // Smoothing factor.\n    float s = sf * sm;\n    \n    // Return the fractal value.\n    return fract(x * s);\n}\n\nfloat", "\n    //\n    // p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n    //           dot(p,vec3(269.5,183.3,246.1)),\n    //           dot(p,vec3(113.5,271.9,124.6)));\n\n    // This is a nice, fast, and simple hash, but it's not quite as nice as the one above.\n    // p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n    //           dot(p,vec3(269.5,183.3,246.1)),\n    //           dot(p,vec3(113.5,271.9,124.6)));\n\n    // This is a nice, fast, and simple hash, but it's not quite as nice as the one above.\n    // p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n    //           dot(p,vec3(269.5,183.3,246.1)),\n    //           dot(p,vec3(113.5,271.9,124.6)));\n\n    // This is a nice, fast, and simple hash, but it's not quite as nice as the one above.\n    // p = vec3( dot(p,vec3(127.1,311.7, 74.7)),\n    //           dot(p,vec3(269.5,183.3,246.1)),\n    //           dot(p,vec3(113.5,271.9,124.6)));\n\n    // This is a nice, fast, and simple hash, but it's not quite as nice as the one above.\n    // p = vec3( dot(p,vec3(127.1,311.7, ", "\n    vec3 s = vec3(1.0, 1.0, 1.0) / 3.0;\n    vec3 f = fract(p * s);\n    vec3 i = floor(p * s);\n\n    // Determining the first vertice.\n    float n = dot(i, vec3(0.0, 0.0, 1.0));\n    float a = dot(i, vec3(0.0, 1.0, 0.0));\n    float b = dot(i, vec3(1.0, 0.0, 0.0));\n    float c = dot(i, vec3(1.0, 1.0, 1.0));\n\n    // Determining the second vertice.\n    float k0 = n;\n    float k1 = a - n;\n    float k2 = b - n;\n    float k3 = c - n;\n    float k4 = a + b - k1 - k2;\n    float k5 = a + c - k1 - k3;\n    float k6 = b + c - k2 - k3;\n    float k7 = a + b + c - k0 - k1 - k2 - k3;\n\n    // Determining the noise value.\n    float n0 = k0;\n    float n1 = k1 + f.x;\n    float n2 = k2 + f.y;\n    float n3 = k3 + f.z;\n    float n4 = k4 + f.x + f.y;\n    float n5 = k5 + f.x + f.z;\n    float n6 = k6 + f.y + f.z;\n    float n7 = k7 + f.x + f.y + f.z;\n\n    // Determining the final noise value.\n    float n8 = n0;\n    n8 = mix(n8, n1, f.x);\n    n8 = mix(n8, n2, f.y);\n    n8 = mix(n8, n3, f.z);\n    n8 = mix(n8, n4, f", "\n    float n = snoise(p);\n    \n    // The color.\n    vec3 c = vec3(n);\n    \n    // The final color.\n    return vec4(c, 1.0);\n}\n\nvoid main(){\n    // The pixel coordinates.\n    vec2 p = gl_FragCoord.xy / u_resolution.xy;\n    \n    // The final color.\n    vec4 c = func(p);\n    \n    // Output the final color.\n    gl_FragColor = c;\n}", " and radius\n  vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n  float balloonRadius = 1.0;\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length( currentRayPosition - balloonPosition );\n  \n  // Then we calculate the distance from the current ray position to the balloon position\n  float distanceToBalloon = length", "\n\tvec3 m = 1.0 / rd;\n\tvec3 n = m * ro;\n\tvec3 k = abs( m ) * rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\n\t// return the intersection t value\n\tif( tN > tF || tF < 0.0 ) return vec4( -1.0 );\n\n\treturn vec4( tN, tF, tN / ( tN - tF ), tF / ( tN - tF ) );\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    vec3 s = vec3(1.0, 1.0, 1.0) - 1.5 * abs(p);\n    vec3 t = s * s * s;\n    vec3 f = s * t;\n    \n    // Calculating the gradients at the vertices.\n    vec3 g0 = vec3(0.0, 0.0, 0.0);\n    vec3 g1 = vec3(0.0, 0.0, 0.0);\n    vec3 g2 = vec3(0.0, 0.0, 0.0);\n    vec3 g3 = vec3(0.0, 0.0, 0.0);\n    \n    // Calculating the gradients at the vertices.\n    g0 = vec3(0.0, 0.0, 0.0);\n    g1 = vec3(0.0, 0.0, 0.0);\n    g2 = vec3(0.0, 0.0, 0.0);\n    g3 = vec3(0.0, 0.0, 0.0);\n    \n    // Calculating the gradients at the vertices.\n    g0 = vec3(0.0, 0.0, 0.0);\n    g1 = vec3(0.0, 0.0, 0.0);\n    g2 = vec3(0.0, 0.0, 0.0);\n    g3 = vec3(0.0, 0.0, 0.0);\n    \n    // Calculating the gradients at the vertices.\n    g0 = vec3(0.0, 0.0, 0.0);\n    g1 = vec3(0.0, 0.0, 0.0);\n    g2 = vec3(0.0, 0.0, 0.0);\n    g3 = vec3(0.0, 0.0, 0.0);\n    \n    // Calculating the gradients at the vertices.\n    g", "\n vec2 pa=p-a, ba=b-a;\n float h=clamp(dot(pa,ba)/dot(ba,ba),0.,1.);\n return c*(1.-h)+c*h*2.;\n}\n\nvoid main(void)\n{\n\tvec2 p = (gl_FragCoord.xy * 2.0 - RENDERSIZE.xy) / min(RENDERSIZE.x, RENDERSIZE.y);\n\tvec3 c = vec3(0);\n\t\n\tvec2 a = vec2(0.5,0.5);\n\tvec2 b = vec2(0.5,0.5);\n\t\n\tfloat t = TIME;\n\t\n\ta.x = sin(t) * 0.5 + 0.5;\n\ta.y = cos(t) * 0.5 + 0.5;\n\t\n\tb.x = sin(t + 1.0) * 0.5 + 0.5;\n\tb.y = cos(t + 1.0) * 0.5 + 0.5;\n\t\n\tc = lineAOc(p,a,b,c);\n\t\n\tgl_FragColor = vec4(c,1.0);\n}", "\n    for(int i = 0; i < 100; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(length(z) > 2.0){\n            return float(i)/100.0;\n        }\n    }\n    return 1.0;\n}\n\nvoid main(){\n    vec2 c = vec2(gl_FragCoord.x/1000.0, gl_FragCoord.y/1000.0);\n    vec2 z = vec2(0.0, 0.0);\n    float m = mandelbrot(c, z);\n    gl_FragColor = vec4(m, m, m, 1.0);\n}", "\n    vec3 z = normalize(focusPoint - cam);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n\n    return mat4(\n        x.x, x.y, x.z, 0.0,\n        y.x, y.y, y.z, 0.0,\n        z.x, z.y, z.z, 0.0,\n        0.0, 0.0, 0.0, 1.0\n    ) * translate(-cam);\n}\n\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main(){\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    vec3 col = vec3(0.0);\n    float t = u_time * 0.5;\n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n    float d = abs(a - t);\n    float f = cos(d * 10.0);\n    float g = sin(d * 10.0);\n    float b = sin(d * 10.0);\n    float c = cos(d * 10.0);\n    float e = sin(d * 10.0);\n    float h = cos(d * 10.0);\n    float i = sin(d * 10.0);\n    float j = cos(d * 10.0);\n    float k = sin(d * 10.0);\n    float l = cos(d * 10.0);\n    float m = sin(d * 10.0);\n    float n = cos(d * 10.0);\n    float o = sin(d * 10.0);\n    float p = cos(d * 10.0);\n    float q = sin(d * 10.0);\n    float r = cos(d * 10.0);\n    float s = sin(d * 10.0);\n    float t = cos(d * 10.0);\n    float u = sin(d * 10.0);\n    float v = cos(d *", "\n    p = mod(p, 2.0);\n    p = abs(p - 1.0);\n    \n    // Get the distance to the closest edge.\n    float d = min(p.x, p.y);\n    \n    // Get the distance to the closest corner.\n    d = min(d, length(p));\n    \n    // Get the distance to the closest edge in the direction of the pattern.\n    d = min(d, abs(p.x - w) + abs(p.y - w));\n    \n    // Get the distance to the closest corner in the direction of the pattern.\n    d = min(d, length(p - vec2(w, w)));\n    \n    // Return the distance to the closest edge in the direction of the pattern.\n    return d;\n}\n\nfloat", "\n    return (x - a) / (b - a);\n}\n\nfloat", "\n    float dist = distance(xy, vec2(0.0, 0.0));\n    float dist2 = distance(xy, vec2(0.0, 0.0));\n    float dist3 = distance(xy, vec2(0.0, 0.0));\n    float dist4 = distance(xy, vec2(0.0, 0.0));\n    float dist5 = distance(xy, vec2(0.0, 0.0));\n    float dist6 = distance(xy, vec2(0.0, 0.0));\n    float dist7 = distance(xy, vec2(0.0, 0.0));\n    float dist8 = distance(xy, vec2(0.0, 0.0));\n    float dist9 = distance(xy, vec2(0.0, 0.0));\n    float dist10 = distance(xy, vec2(0.0, 0.0));\n    float dist11 = distance(xy, vec2(0.0, 0.0));\n    float dist12 = distance(xy, vec2(0.0, 0.0));\n    float dist13 = distance(xy, vec2(0.0, 0.0));\n    float dist14 = distance(xy, vec2(0.0, 0.0));\n    float dist15 = distance(xy, vec2(0.0, 0.0));\n    float dist16 = distance(xy, vec2(0.0, 0.0));\n    float dist17 = distance(xy, vec2(0.0, 0.0));\n    float dist18 = distance(xy, vec2(0.0, 0.0));\n    float dist19 = distance(xy, vec2(0.0, 0.0));\n    float dist20 = distance(xy, vec2(0.0, 0.0));\n    float dist21 = distance(xy, vec2(0.0, 0.0));\n    float dist22 = distance(xy, vec2(0.0", "\n vec2 o1 = vec2(0.0,1.0);\n vec2 o2 = vec2(1.0,0.0);\n vec2 o3 = vec2(0.0,-1.0);\n vec2 o4 = vec2(-1.0,0.0);\n // random offsets of neighbors (clockwise starting north)\n vec2 o5 = vec2(0.0,1.0);\n vec2 o6 = vec2(1.0,0.0);\n vec2 o7 = vec2(0.0,-1.0);\n vec2 o8 = vec2(-1.0,0.0);\n // random offsets of neighbors (clockwise starting north)\n vec2 o9 = vec2(0.0,1.0);\n vec2 o10 = vec2(1.0,0.0);\n vec2 o11 = vec2(0.0,-1.0);\n vec2 o12 = vec2(-1.0,0.0);\n // random offsets of neighbors (clockwise starting north)\n vec2 o13 = vec2(0.0,1.0);\n vec2 o14 = vec2(1.0,0.0);\n vec2 o15 = vec2(0.0,-1.0);\n vec2 o16 = vec2(-1.0,0.0);\n // random offsets of neighbors (clockwise starting north)\n vec2 o17 = vec2(0.0,1.0);\n vec2 o18 = vec2(1.0,0.0);\n vec2 o19 = vec2(0.0,-1.0);\n vec2 o20 = vec2(-1.0,0.0);\n // random offsets of neighbors (clockwise starting north)\n vec2 o21 = vec2(0.0,1.0);\n vec2 o22 = vec2(1.0,0.0);\n vec2 o23 = vec2(0.0,-", "\n //f+=.05*sin(p.z*5.);\n //f+=.05*cos(p.z*5.);\n return f;\n}\n\nfloat", ", but it works\n    float r = c.r;\n    float g = c.g;\n    float b = c.b;\n    float max = max(r, max(g, b));\n    float min = min(r, min(g, b));\n    float delta = max - min;\n    float hue = 0.0;\n    if(delta > 0.0){\n        if(max == r){\n            hue = (g - b) / delta;\n        }else if(max == g){\n            hue = 2.0 + (b - r) / delta;\n        }else{\n            hue = 4.0 + (r - g) / delta;\n        }\n        hue *= 60.0;\n        if(hue < 0.0){\n            hue += 360.0;\n        }\n    }\n    float sat = (max > 0.0)? (delta / max) : 0.0;\n    return vec3(hue, sat, max);\n}\n\nvec", "\n  vec3 d=abs(p)-s;\n  return vec4(min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)),1.0,1.0,1.0);\n}\n\nvec", "\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5", "\n    float dist = distScene(pos);\n    int matrIndex = int(mod(dist, 7.0));\n    Material mat = materials[matrIndex];\n    return mat;\n}\n\nvec", "\n    const vec3 a = vec3(2.51f, 0.03f, 2.43f);\n    const vec3 b = vec3(0.34f, 0.94f, 0.14f);\n    const vec3 c = vec3(-1.65f, 2.50f, 0.15f);\n    const vec3 d = vec3(1.67f, -0.39f, 0.52f);\n    const vec3 e = vec3(-0.60f, 0.04f, 0.15f);\n    return (x * (a * x + b)) / (x * (c * x + d) + e);\n}\n\nvec", "\n    p.x -= 1.0;\n    \n    // The scene is a sphere.\n    // The sphere is centered at the origin.\n    // The radius is 1.0.\n    // The distance to the sphere is the distance to the surface.\n    float d = length(p) - 1.0;\n    \n    // The color of the sphere is red.\n    // The color is a vec3, with each component being a float between 0.0 and 1.0.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n    // The color is the same for all points on the surface of the sphere.\n", "\n    float d = length(p) - 1.0;\n    float r = 0.1;\n    float s = smoothstep(r, r - 0.01, d);\n    return mat(s, vec3(1.0));\n}\n\nmat", "\n    mat2 m = mat2 ( 0.80,  0.60, -0.60,  0.80 );\n    float f = 0.0;\n    f += 0.5000 * noise ( p ); p = m * p * 2.02;\n    f += 0.2500 * noise ( p ); p = m * p * 2.03;\n    f += 0.1250 * noise ( p ); p = m * p * 2.01;\n    f += 0.0625 * noise ( p );\n    return f / 0.9375;\n}\n\nvoid mainImage ( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 p = ( 2.0 * fragCoord - iResolution.xy ) / iResolution.y;\n    float t = iTime * 0.5;\n    vec2 q = p + vec2 ( cos ( t ), sin ( t ) );\n    float f = fbm ( q * 0.5 );\n    vec3 col = vec3 ( f );\n    fragColor = vec4 ( col, 1.0 );\n}", "\n    \n    // The first point is the cell point, which is wrapped to the cell.\n    vec2 cell = floor(p);\n    vec2 cellPoint = cell + vec2(0.5);\n    \n    // The second point is the cell point rotated 90 degrees.\n    vec2 cellPointRotated = cellPoint.yx;\n    \n    // The third point is the cell point rotated 180 degrees.\n    vec2 cellPointRotated180 = cellPoint.yx * vec2(-1.0, 1.0);\n    \n    // The fourth point is the cell point rotated 270 degrees.\n    vec2 cellPointRotated270 = cellPoint.yx * vec2(1.0, -1.0);\n    \n    // The fifth point is the cell point rotated 360 degrees.\n    vec2 cellPointRotated360 = cellPoint.yx * vec2(-1.0, -1.0);\n    \n    // The sixth point is the cell point rotated 45 degrees.\n    vec2 cellPointRotated45 = cellPoint.yx * vec2(1.0, 1.0);\n    \n    // The seventh point is the cell point rotated 135 degrees.\n    vec2 cellPointRotated135 = cellPoint.yx * vec2(-1.0, 1.0);\n    \n    // The eighth point is the cell point rotated 225 degrees.\n    vec2 cellPointRotated225 = cellPoint.yx * vec2(1.0, -1.0);\n    \n    // The ninth point is the cell point rotated 315 degrees.\n    vec2 cellPointRotated315 = cellPoint.yx * vec2(-1.0, -1.0);\n    \n    // The tenth point is the cell point rotated 45 degrees.\n    vec2 cellPointRotated45 = cellPoint.yx * vec2(1.0, 1.0);\n    \n    // The eleventh point is the cell", "\n return u.x*m.y-u.y*m.x;\n}\n\nfloat", "\n return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),dot(m,u)>0.);//branchless\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 m = vec2(0.5,0.5);\n    float d = ils(uv,m);\n    fragColor = vec4(d,d,d,1.0);\n}", "\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-", "\n  v2 c(v1 U){\n    v2 c(v1 U){\n      v2 c(v1 U){\n        v2 c(v1 U){\n          v2 c(v1 U){\n            v2 c(v1 U){\n              v2 c(v1 U){\n                v2 c(v1 U){\n                  v2 c(v1 U){\n                    v2 c(v1 U){\n                      v2 c(v1 U){\n                        v2 c(v1 U){\n                          v2 c(v1 U){\n                            v2 c(v1 U){\n                              v2 c(v1 U){\n                                v2 c(v1 U){\n                                  v2 c(v1 U){\n                                    v2 c(v1 U){\n                                      v2 c(v1 U){\n                                        v2 c(v1 U){\n                                          v2 c(v1 U){\n                                            v2 c(v1 U){\n                                              v2 c(v1 U){\n                                                v2 c(v1 U){\n                                                  v2 c(v1 U){\n                                                    v2 c(v1 U){\n                                                      v2 c(v1 U){\n                                                        v2 c(v1 U){\n                                                          v2 c(v1 U){\n                                                            v2 c(v1 U){\n                                                              v2 c(v1 U){\n                                                                v2 c(v1 U){\n                                                                  v2 c(v1 U){\n                                                                    v2 c(v1 U){\n                                                                      v2 c(v1 U){\n                                                                        v2 c(v1 U){\n                                                                          v2 c(v1 U){\n                                                                            v2 c(v1 U){\n                                                                              v2 c(v1 U){\n                                                                                v2 c(v1 U){\n                                                                                  v2 c(v1 U){\n                                                                                    v2 c(v1 U){\n                                                                                      v2 c(v1 U){\n                                                                                        v2 c(v1 U){\n                                                                                          v2 c(v1 U){\n                                                                                            v2 c(v1 U){\n                                                                                              v2 c(v1 U){\n                                                                                                v2 c(v1 U){\n                                                                                                  v2 c(", "\n  v2 c(v1 U){\n    v2 c(v1 U){\n      v2 c(v1 U){\n        v2 c(v1 U){\n          v2 c(v1 U){\n            v2 c(v1 U){\n              v2 c(v1 U){\n                v2 c(v1 U){\n                  v2 c(v1 U){\n                    v2 c(v1 U){\n                      v2 c(v1 U){\n                        v2 c(v1 U){\n                          v2 c(v1 U){\n                            v2 c(v1 U){\n                              v2 c(v1 U){\n                                v2 c(v1 U){\n                                  v2 c(v1 U){\n                                    v2 c(v1 U){\n                                      v2 c(v1 U){\n                                        v2 c(v1 U){\n                                          v2 c(v1 U){\n                                            v2 c(v1 U){\n                                              v2 c(v1 U){\n                                                v2 c(v1 U){\n                                                  v2 c(v1 U){\n                                                    v2 c(v1 U){\n                                                      v2 c(v1 U){\n                                                        v2 c(v1 U){\n                                                          v2 c(v1 U){\n                                                            v2 c(v1 U){\n                                                              v2 c(v1 U){\n                                                                v2 c(v1 U){\n                                                                  v2 c(v1 U){\n                                                                    v2 c(v1 U){\n                                                                      v2 c(v1 U){\n                                                                        v2 c(v1 U){\n                                                                          v2 c(v1 U){\n                                                                            v2 c(v1 U){\n                                                                              v2 c(v1 U){\n                                                                                v2 c(v1 U){\n                                                                                  v2 c(v1 U){\n                                                                                    v2 c(v1 U){\n                                                                                      v2 c(v1 U){\n                                                                                        v2 c(v1 U){\n                                                                                          v2 c(v1 U){\n                                                                                            v2 c(v1 U){\n                                                                                              v2 c(v1 U){\n                                                                                                v2 c(v1 U){\n                                                                                                  v2 c(", "\n    return a - dot(a, b) * b;\n}\n\nvec", "\n\tfloat a = acos(dot(A, B));\n\tfloat b = acos(dot(B, C));\n\tfloat c = acos(dot(C, A));\n\n\t//calculate area of spherical triangle\n\tfloat area = a + b + c;\n\n\t//calculate probability of each triangle edge\n\tfloat pA = a / area;\n\tfloat pB = b / area;\n\tfloat pC = c / area;\n\n\t//calculate probability of each triangle edge\n\tfloat p1 = pA / (pA + pB + pC);\n\tfloat p2 = pB / (pA + pB + pC);\n\tfloat p3 = pC / (pA + pB + pC);\n\n\t//calculate probability of each triangle edge\n\tfloat p12 = p1 + p2;\n\tfloat p23 = p2 + p3;\n\tfloat p31 = p3 + p1;\n\n\t//calculate probability of each triangle edge\n\tfloat p123 = p12 + p3;\n\tfloat p231 = p23 + p1;\n\tfloat p312 = p31 + p2;\n\n\t//calculate probability of each triangle edge\n\tfloat p1231 = p123 + p1;\n\tfloat p2312 = p231 + p2;\n\tfloat p3123 = p312 + p3;\n\n\t//calculate probability of each triangle edge\n\tfloat p12312 = p1231 + p2;\n\tfloat p23123 = p2312 + p3;\n\tfloat p31231 = p3123 + p1;\n\n\t//calculate probability of each triangle edge\n\tfloat p123123 = p12312 + p3;\n\tfloat p231231 = p23123 + p1;\n\tfloat p312312 = p31231 + p2;\n\n\t//calculate probability of each triangle edge\n\tfloat p1231231 = p123123 + p1;\n\tfloat p2", "\n  v2 c(v1 U){\n    v2 c(v1 U){\n      v2 c(v1 U){\n        v2 c(v1 U){\n          v2 c(v1 U){\n            v2 c(v1 U){\n              v2 c(v1 U){\n                v2 c(v1 U){\n                  v2 c(v1 U){\n                    v2 c(v1 U){\n                      v2 c(v1 U){\n                        v2 c(v1 U){\n                          v2 c(v1 U){\n                            v2 c(v1 U){\n                              v2 c(v1 U){\n                                v2 c(v1 U){\n                                  v2 c(v1 U){\n                                    v2 c(v1 U){\n                                      v2 c(v1 U){\n                                        v2 c(v1 U){\n                                          v2 c(v1 U){\n                                            v2 c(v1 U){\n                                              v2 c(v1 U){\n                                                v2 c(v1 U){\n                                                  v2 c(v1 U){\n                                                    v2 c(v1 U){\n                                                      v2 c(v1 U){\n                                                        v2 c(v1 U){\n                                                          v2 c(v1 U){\n                                                            v2 c(v1 U){\n                                                              v2 c(v1 U){\n                                                                v2 c(v1 U){\n                                                                  v2 c(v1 U){\n                                                                    v2 c(v1 U){\n                                                                      v2 c(v1 U){\n                                                                        v2 c(v1 U){\n                                                                          v2 c(v1 U){\n                                                                            v2 c(v1 U){\n                                                                              v2 c(v1 U){\n                                                                                v2 c(v1 U){\n                                                                                  v2 c(v1 U){\n                                                                                    v2 c(v1 U){\n                                                                                      v2 c(v1 U){\n                                                                                        v2 c(v1 U){\n                                                                                          v2 c(v1 U){\n                                                                                            v2 c(v1 U){\n                                                                                              v2 c(v1 U){\n                                                                                                v2 c(v1 U){\n                                                                                                  v2 c(", "\n    \n    // The tube is a circle with a radius of 0.5.\n    // The tube is centered at the origin.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n    // The tube is oriented along the y-axis.\n    // The tube is oriented along the z-axis.\n    // The tube is oriented along the x-axis.\n", "\n    float r = 0.1;\n\n    // Torus parameters.\n    float R = 0.5;\n    float r1 = 0.2;\n\n    // Torus equation.\n    float d = length(vec2(length(p.xz) - R, p.y)) - r1;\n\n    // Torus normal.\n    vec3 n = normalize(vec3(p.x, p.y, p.z));\n\n    return vec4(d, n);\n}\n\n// Torus with a hole.\nvec", "\n    vec3 id = floor(p);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos = mod(p, 1.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos2 = mod(p, 2.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos3 = mod(p, 3.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos4 = mod(p, 4.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos5 = mod(p, 5.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos6 = mod(p, 6.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos7 = mod(p, 7.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos8 = mod(p, 8.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos9 = mod(p, 9.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos10 = mod(p, 10.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos11 = mod(p, 11.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos12 = mod(p, 12.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos13 = mod(p, 13.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos14 = mod(p, 14.0);\n    \n    // Get the position of the cell in the grid.\n    vec3 pos15 = mod(p, 15.0);\n    \n    // Get the position of the", "\n    float t = 0., d;\n    \n    // Loop through the ray marching steps.\n    for(int i = 0; i < 100; i++){\n        \n        // Get the distance to the scene.\n        d = map(o + r * t);\n        \n        // If the distance is less than the minimum distance, return the current ray distance.\n        if(d < 0.001){\n            return t;\n        }\n        \n        // Increment the ray distance.\n        t += d;\n    }\n    \n    // Return the maximum ray distance.\n    return 100.;\n}\n\nvec", "\n    float s = 0.0;\n    float tt = 0.0;\n    for(int i = 0; i < 10; i++){\n        tt += t;\n        s += exp(-k*tt);\n    }\n    return s;\n}\n\nfloat", "\n    float eps =.0001 * (1.0 / t);\n    \n    // The derivative of the function is the gradient of the function.\n    // The gradient is the direction of the steepest ascent.\n    // The normal is the direction of the steepest descent.\n    // The normal is the negative of the gradient.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    // The normal is the unit vector perpendicular to the tangent plane.\n    //", "\n    vec3 w = vec3(dot(p3, m[0]), dot(p3, m[1]), dot(p3, m[2]));\n    // normalize weights\n    w = normalize(w);\n    // scale weights by triangle area\n    w *= t.x;\n    // return barycentric coordinates\n    return vec4(w, 1.0 - w.x - w.y);\n}\n\nvoid main() {\n    // get the current pixel\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    // get the current pixel's position in world space\n    vec3 p = texture(u_position, uv).xyz;\n    // get the current pixel's normal in world space\n    vec3 n = texture(u_normal, uv).xyz;\n    // get the current pixel's color\n    vec3 c = texture(u_color, uv).xyz;\n\n    // get the current pixel's position in view space\n    vec4 p_view = u_view * vec4(p, 1.0);\n    // get the current pixel's normal in view space\n    vec4 n_view = u_view * vec4(n, 0.0);\n\n    // get the current pixel's position in clip space\n    vec4 p_clip = u_projection * p_view;\n    // get the current pixel's normal in clip space\n    vec4 n_clip = u_projection * n_view;\n\n    // get the current pixel's position in ndc space\n    vec4 p_ndc = p_clip / p_clip.w;\n    // get the current pixel's normal in ndc space\n    vec4 n_ndc = n_clip / n_clip.w;\n\n    // get the current pixel's position in screen space\n    vec4 p_screen = p_ndc * 0.5 + 0.5;\n    // get the current pixel's normal in screen space\n    vec4 n_screen = n_ndc * 0.5 + 0", "\n    vec4 hexCenters = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(p.x) + int(p.y) * 10;\n    \n    // The hexagon centers are stored in a 2D array, so we need to calculate the index of the\n    // hexagon center we're looking for.\n    int index = int(", "\n    vec2 uv = vec2(df_truchet(p, dir), atan(p.y, p.x) / 3.1415926535897932384626433832795);\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is a 0-1 distance field, so we need to scale it up\n    // to a 0-2 distance field.\n    uv *= 2.0;\n    \n    // The Truchet distance field is", "\n    q.x += sin(q.y * 0.01 + iTime * 0.01) * 0.01;\n    q.y += cos(q.x * 0.01 + iTime * 0.01) * 0.01;\n    \n    // Polar conversion\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    \n    // The actual animation. You perform that after polar conversion.\n    a += r * 0.01;\n    \n    // Convert back to cartesian\n    q.x = r * cos(a);\n    q.y = r * sin(a);\n    \n    // Return the distance to the center\n    return length(q);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 q = fragCoord.xy / iResolution.xy;\n    q.x *= iResolution.x / iResolution.y;\n    \n    float d = getPolarCoord(q, 0.0);\n    \n    fragColor = vec4(d, d, d, 1.0);\n}", "\n    vec3 w = vec3(dot(p3, n[0]), dot(p3, n[1]), dot(p3, n[2]));\n    // normalize weights\n    w = normalize(w);\n    // scale weights by distance to triangle plane\n    w *= dot(t, w);\n    // return barycentric coordinates\n    return vec4(w, 1.0 - w.x - w.y);\n}\n\nvec", ".\n  if (abs(r.w) < 0.000001 && abs(p.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(r.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(p.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(q.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(r.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(p.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(q.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(r.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(p.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(q.w) < 0.000001) {\n    return 0.0;\n  }\n\n  // If the line is at infinity, we can ignore it.\n  if (abs(r.w) < 0.00", "\n    // The first tile is a square with a diagonal line.\n    // The second tile is a square with a diagonal line.\n    // The third tile is a square with a diagonal line.\n    // The fourth tile is a square with a diagonal line.\n    // The fifth tile is a square with a diagonal line.\n    // The sixth tile is a square with a diagonal line.\n    // The seventh tile is a square with a diagonal line.\n    // The eighth tile is a square with a diagonal line.\n    // The ninth tile is a square with a diagonal line.\n    // The tenth tile is a square with a diagonal line.\n    // The eleventh tile is a square with a diagonal line.\n    // The twelfth tile is a square with a diagonal line.\n    // The thirteenth tile is a square with a diagonal line.\n    // The fourteenth tile is a square with a diagonal line.\n    // The fifteenth tile is a square with a diagonal line.\n    // The sixteenth tile is a square with a diagonal line.\n    // The seventeenth tile is a square with a diagonal line.\n    // The eighteenth tile is a square with a diagonal line.\n    // The nineteenth tile is a square with a diagonal line.\n    // The twentieth tile is a square with a diagonal line.\n    // The twenty-first tile is a square with a diagonal line.\n    // The twenty-second tile is a square with a diagonal line.\n    // The twenty-third tile is a square with a diagonal line.\n    // The twenty-fourth tile is a square with a diagonal line.\n    // The twenty-fifth tile is a square with a diagonal line.\n    // The twenty-sixth tile is a square with a diagonal line.\n    // The twenty-seventh tile is a square with a diagonal line.\n    // The twenty-eighth tile is a square with a diagonal line.\n    // The twenty-ninth tile is a square with a diagonal line.\n    // The thirty-first tile is a square with a diagonal line.\n    // The thirty-second tile is a square with a diagonal line.\n    // The thirty-third tile is a square with a diagonal line.\n    // The thirty-fourth tile is a square with a diagonal", "\n\tvec2 w = max(abs(ddx), abs(ddy));\n\t// analytical integral (box filter)\n\tvec2 i = 2.0*(p*p + (w*w)/12.0);\n\t// fractional part\n\treturn i.x + i.y - 0.5*w.x*w.y;\n}\n\nfloat", "\n    vec2 h = n + f;\n\n    // find the closest point\n    float d = dot( f, f );\n    float e = dot( n, n );\n    float g = dot( h, h );\n\n    // find the closest point\n    if( d < e ) {\n        if( e < g ) {\n            mr = n;\n            mg = f;\n            return d;\n        }\n        else {\n            mr = h;\n            mg = f;\n            return e;\n        }\n    }\n    else {\n        if( d < g ) {\n            mr = f;\n            mg = h;\n            return d;\n        }\n        else {\n            mr = h;\n            mg = n;\n            return e;\n        }\n    }\n}\n\nfloat", "\n    vec2 p0 = vec2(0.0,0.0);\n    vec2 p1 = vec2(1.0,0.0);\n    vec2 p2 = vec2(1.0,1.0);\n    vec2 p3 = vec2(0.0,1.0);\n\n    vec2 p01 = mix(p0,p1,t);\n    vec2 p12 = mix(p1,p2,t);\n    vec2 p23 = mix(p2,p3,t);\n    vec2 p30 = mix(p3,p0,t);\n\n    vec2 p012 = mix(p01,p12,t);\n    vec2 p123 = mix(p12,p23,t);\n    vec2 p230 = mix(p23,p30,t);\n\n    vec2 p0123 = mix(p012,p123,t);\n    vec2 p1230 = mix(p123,p230,t);\n\n    return mix(p0123,p1230,t);\n}\n\nvec", "\n    // -Patricio 2015, 2016\n    //\n    // Also, it passes the second test in:\n    //   http://www.jcgt.org/published/0009/03/01/\n    //\n    // Thanks to I\u00f1igo Quiles for the tidbit that helped me figure out how to do this.\n    // Thanks to Fabrice Neyret for cleaning up the offsets and the derivative equations.\n    //\n    // If you're interested, you can check out my other hash functions at:\n    //   http://www.iquilezles.org/www/articles/hashing/hashing.htm\n\n    // const highp vec2 OFFSET = vec2(26.0, 161.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const highp vec2 OFFSET = vec2(161.0, 269.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const highp vec2 OFFSET = vec2(113.0, 311.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const highp vec2 OFFSET = vec2(269.0, 193.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const highp vec2 OFFSET = vec2(193.0, 269.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const highp vec2 OFFSET = vec2(113.0, 193.0);\n    // const highp vec2 PRIME = vec2(19.0, 239.0);\n\n    // const", "\n    // Visit http://www.nevads.com/ for more details.\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(123.34, 345.45));\n    // p += dot(p, p + 23.45);\n    // return fract(p.x * p.y);\n\n    // p = fract(p * vec2(", "\n    float a = length(p1 - p0);\n    float b = length(p2 - p1);\n    float c = length(p0 - p2);\n    \n    // Angles.\n    float A = acos((b*b + c*c - a*a) / (2.0*b*c));\n    float B = acos((a*a + c*c - b*b) / (2.0*a*c));\n    float C = acos((a*a + b*b - c*c) / (2.0*a*b));\n    \n    // Centroid.\n    vec2 cent = (p0*sin(A) + p1*sin(B) + p2*sin(C)) / sin(A + B + C);\n    \n    return cent;\n}\n\nvoid main() {\n    vec2 p0 = vec2(0.0, 0.0);\n    vec2 p1 = vec2(1.0, 0.0);\n    vec2 p2 = vec2(0.0, 1.0);\n    \n    vec2 cent = inCent(p0, p1, p2);\n    \n    gl_FragColor = vec4(cent, 0.0, 1.0);\n}\n", "\n    float a = length(p0 - p1);\n    float b = length(p1 - p2);\n    float c = length(p2 - p0);\n\n    // Angle A.\n    float A = acos((b*b + c*c - a*a) / (2.0*b*c));\n\n    // Angle B.\n    float B = acos((a*a + c*c - b*b) / (2.0*a*c));\n\n    // Angle C.\n    float C = acos((a*a + b*b - c*c) / (2.0*a*b));\n\n    // Radius.\n    float r = a*b*c / (4.0*sin(A)*sin(B)*sin(C));\n\n    // Area.\n    float S = a*b*sin(C)/2.0;\n\n    // Circumference.\n    float C1 = a + b + c;\n\n    // Circumference in radians.\n    float C2 = C1*r;\n\n    // Area in radians.\n    float S2 = S*r*r;\n\n    return S2/C2;\n}\n\nvoid main() {\n    vec2 p0 = vec2(0.0, 0.0);\n    vec2 p1 = vec2(1.0, 0.0);\n    vec2 p2 = vec2(0.0, 1.0);\n\n    float r = inCentRad(p0, p1, p2);\n\n    gl_FragColor = vec4(vec3(r), 1.0);\n}\n", "\n   vec3 p1 = vec3(h1, 1.0);\n   vec3 p2 = vec3(h2, 1.0);\n   vec3 p3 = vec3(h3, 1.0);\n\n   // Computes normal of the triangle.\n   vec3 n = normalize(cross(p2 - p1, p3 - p1));\n\n   // Computes distance from the origin to the plane.\n   float d = dot(n, p1);\n\n   // Computes distance from the origin to the plane.\n   return d;\n}\n\nfloat", "\n    vec2 v0 = vec2(0.0, 0.0);\n    vec2 v1 = vec2(1.0, 0.0);\n    vec2 v2 = vec2(0.0, 1.0);\n    \n    // The number of iterations is the number of triangles we're going to generate.\n    // The number of triangles is 2^(n-2)\n    int n = int(log2(float(NUM_ITERATIONS)));\n    \n    // The number of vertices is 3^n\n    int numVertices = 3;\n    for(int i = 0; i < n; i++){\n        numVertices *= 3;\n    }\n    \n    // The number of triangles is 2^(n-2)\n    int numTriangles = numVertices / 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3;\n    \n    // The number of vertices is 3^n\n    int numVertices = numTriangles * 3", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    //set background color\n    vec3 col = vec3(0.0);\n\n    //draw a circle\n    float d = length(uv - vec2(0.5, 0.5));\n    if (d < 0.25) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n\n    //output to screen\n    fragColor = vec4(col, 1.0);\n}", "\n    //vec2 n = vec2(0.0);\n    //n.x = p.x + p.y * 157.0;\n    //n.y = p.y + p.x * 157.0;\n    //return fract(sin(n) * 159.543);\n    \n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 500.0);\n    //n = vec2( dot(n, vec2(127.1, 311.7)), dot(n, vec2(269.5, 183.3)) );\n    //return fract(sin(n) * 43758.5453);\n    \n    \n    // This is another good one.\n    //vec2 n = p + vec2(0.0, 500.0);\n    //n = vec2( dot(n, vec2(0.0, 127.1)), dot(n, vec2(269.5, 183.3)) );\n    //return fract(sin(n) * 43758.5453);\n    \n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 500.0);\n    //n = vec2( dot(n, vec2(127.1, 311.7)), dot(n, vec2(269.5, 183.3)) );\n    //return fract(sin(n) * 43758.5453);\n    \n    \n    // This is a good one.\n    //vec2 n = p + vec2(0.0, 500.0);\n    //n = vec2( dot(n, vec2(0.0, 127.1)), dot(n, vec2(269.5, 183.3)) );\n    //return fract(sin(n) * ", "\n    /////////////////////////////////\n    //\n    // Compute the intersection of the given ray with the given sphere.\n    //\n    // If the ray intersects the sphere, return true and set t to the\n    // distance along the ray at which the intersection occurs.\n    //\n    // If the ray does not intersect the sphere, return false.\n    //\n    // If the ray intersects the sphere, set hitPos to the position of the\n    // intersection point and set hitNormal to the normal at the intersection\n    // point.\n    //\n    // Note: The sphere is defined by its center and radius.\n    //\n    // Note: The ray is defined by its origin and direction.\n    //\n    // Note: The intersection point is defined by the ray's origin plus the\n    // distance along the ray times the ray's direction.\n    //\n    // Note: The normal at the intersection point is defined by the vector\n    // from the intersection point to the sphere's center.\n    //\n    // Note: The ray's direction is normalized.\n    //\n    // Note: The ray's origin is not necessarily inside the sphere.\n    //\n    // Note: The ray's origin is not necessarily outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily on the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is not necessarily inside or outside the sphere.\n    //\n    // Note: The ray's origin is", "\n    /////////////////////////////////\n    //\n    // This function should return true if the given ray intersects the given sphere.\n    //\n    // The ray is defined by a point and a direction.\n    // The sphere is defined by a center and a radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius of the sphere.\n    //", "\n    float tmin = 1000000.0;\n    hasHit = false;\n    for( int i = 0; i < NUM_OBJECTS; i++ ) \n    {\n        float t = objects[i].Intersect( ray );\n        if( t > 0.0 ) \n        {\n            hasHit = true;\n            if( t < tmin ) \n            {\n                tmin = t;\n                hitPos = ray.origin + ray.direction * t;\n                hitNormal = objects[i].GetNormal( hitPos );\n                k_rg = objects[i].k_rg;\n            }\n        }\n    }\n    return k_rg;\n}\n\nvec", "\n    vec2 p01 = p1 - p0;\n    vec2 p12 = p2 - p1;\n    vec2 p012 = p12 - p01;\n    vec2 p0121 = p12 - p01;\n    vec2 p0122 = p12 - p01;\n    vec2 p0123 = p12 - p01;\n    vec2 p0124 = p12 - p01;\n    vec2 p0125 = p12 - p01;\n    vec2 p0126 = p12 - p01;\n    vec2 p0127 = p12 - p01;\n    vec2 p0128 = p12 - p01;\n    vec2 p0129 = p12 - p01;\n    vec2 p01210 = p12 - p01;\n    vec2 p01211 = p12 - p01;\n    vec2 p01212 = p12 - p01;\n    vec2 p01213 = p12 - p01;\n    vec2 p01214 = p12 - p01;\n    vec2 p01215 = p12 - p01;\n    vec2 p01216 = p12 - p01;\n    vec2 p01217 = p12 - p01;\n    vec2 p01218 = p12 - p01;\n    vec2 p01219 = p12 - p01;\n    vec2 p01220 = p12 - p01;\n    vec2 p01221 = p12 - p01;\n    vec2 p01222 = p12 - p01;\n    vec2 p01223 = p12 - p01;\n    vec2 p01224 = p", "\n    vec3 p01 = p1 - p0;\n    vec3 p12 = p2 - p1;\n    vec3 p23 = p3 - p2;\n    vec3 p30 = p0 - p3;\n\n    // normals\n    vec3 n01 = normalize( p01 );\n    vec3 n12 = normalize( p12 );\n    vec3 n23 = normalize( p23 );\n    vec3 n30 = normalize( p30 );\n\n    // tangents\n    vec3 t01 = normalize( p01 - n01 * dot( p01, n01 ) );\n    vec3 t12 = normalize( p12 - n12 * dot( p12, n12 ) );\n    vec3 t23 = normalize( p23 - n23 * dot( p23, n23 ) );\n    vec3 t30 = normalize( p30 - n30 * dot( p30, n30 ) );\n\n    // binormals\n    vec3 b01 = normalize( cross( n01, t01 ) );\n    vec3 b12 = normalize( cross( n12, t12 ) );\n    vec3 b23 = normalize( cross( n23, t23 ) );\n    vec3 b30 = normalize( cross( n30, t30 ) );\n\n    // compute AABB\n    vec3 min = p0;\n    vec3 max = p0;\n\n    for( int i = 0; i < 3; i++ )\n    {\n        float d0 = dot( p0, b01 );\n        float d1 = dot( p1, b01 );\n        float d2 = dot( p2, b01 );\n        float d3 = dot( p3, b01 );\n\n        min[i] = min( min[i], min( min( d0, d1 ), min( d2, d3 ) ) );\n        max[i] = max( max[", "\n    const float PI = 3.1415926535897932384626433832795;\n    const float TWO_PI = 6.283185307179586476925286766559;\n    const float HALF_PI = 1.5707963267948966192313216916398;\n    const float INV_PI = 0.31830988618379067153776752674503;\n    const float INV_TWO_PI = 0.15915494309189533576888376337251;\n    const float INV_HALF_PI = 0.63661977236758134307553505349006;\n    const float SQRT_TWO = 1.4142135623730950488016887242097;\n    const float SQRT_THREE = 1.7320508075688772935274463415059;\n    const float SQRT_TWO_PI = 2.506628274631000502415765284811;\n    const float SQRT_HALF_PI = 1.2533141373155002512078826424055;\n    const float SQRT_INV_TWO_PI = 0.7978845608028653558798921198687;\n    const float SQRT_INV_TWO", "\n    return 0.5 - cos( k * PI ) / 2.0; // EaseInOut\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n\n    float t = iTime;\n    float t2 = t * 0.5;\n    float t3 = t * 0.25;\n\n    float p = sin( t * 0.5 ) * 0.5 + 0.5;\n    float p2 = sin( t * 0.25 ) * 0.5 + 0.5;\n    float p3 = sin( t * 0.125 ) * 0.5 + 0.5;\n\n    float k = uv.x;\n    float k2 = uv.y;\n    float k3 = uv.x + uv.y;\n\n    float e = easing( k );\n    float e2 = easing( k2 );\n    float e3 = easing( k3 );\n\n    col.r = e;\n    col.g = e2;\n    col.b = e3;\n\n    col.r *= p;\n    col.g *= p2;\n    col.b *= p3;\n\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod(i, 289.0);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n        dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (4", "\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\tvec3 col = vec3(0.0);\n\t\n\tcol.r = uv.x;\n\tcol.g = uv.y;\n\tcol.b = 0.5 + 0.5*sin(iTime);\n\t\n\tfragColor = vec4(col,1.0);\n}", "\n    coord = (coord - res / 2.0) / res.y;\n\n    // Scale the coordinate to the size of the screen.\n    coord *= res.y;\n\n    return coord;\n}\n\nvoid main()\n{\n    // Get the resolution of the screen.\n    vec2 res = vec2(textureSize(u_texture, 0));\n\n    // Get the coordinate of the current pixel.\n    vec2 coord = space(res, gl_FragCoord.xy);\n\n    // Get the color of the current pixel.\n    vec4 color = texture(u_texture, gl_FragCoord.xy / res);\n\n    // Get the color of the pixel to the left.\n    vec4 left = texture(u_texture, (gl_FragCoord.xy + vec2(-1.0, 0.0)) / res);\n\n    // Get the color of the pixel to the right.\n    vec4 right = texture(u_texture, (gl_FragCoord.xy + vec2(1.0, 0.0)) / res);\n\n    // Get the color of the pixel above.\n    vec4 up = texture(u_texture, (gl_FragCoord.xy + vec2(0.0, 1.0)) / res);\n\n    // Get the color of the pixel below.\n    vec4 down = texture(u_texture, (gl_FragCoord.xy + vec2(0.0, -1.0)) / res);\n\n    // Get the color of the pixel above and to the left.\n    vec4 up_left = texture(u_texture, (gl_FragCoord.xy + vec2(-1.0, 1.0)) / res);\n\n    // Get the color of the pixel above and to the right.\n    vec4 up_right = texture(u_texture, (gl_FragCoord.xy + vec2(1.0, 1.0)) / res);\n\n    // Get the color of the pixel below and to the left.\n    vec4 down_", "\n    const vec3 k = vec3(0.001, 0.005, 0.01);\n\n    // derivatives\n    vec2 dx = vec2(dFdx(p.x), dFdx(p.y));\n    vec2 dy = vec2(dFdy(p.x), dFdy(p.y));\n\n    // gradient\n    vec2 g = vec2(dx.x + dy.x, dx.y + dy.y);\n\n    // normalize\n    float l = length(g);\n    if (l > 0.0)\n        g /= l;\n\n    // filter kernel\n    float f = exp(-k.x*l*l) - exp(-k.y*l*l);\n\n    // compute box filter average value and subtract it\n    float avg = exp(-k.z*l*l);\n    return f - avg;\n}\n\nfloat", "\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\nvec", "\n    // p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\n    // Slower, but more evenly disperses things.\n    p = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\nfloat", "\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3(\n        map(p+h.xyy) - map(p-h.xyy),\n        map(p+h.yxy) - map(p-h.yxy),\n        map(p+h.yyx) - map(p-h.yyx) ) );\n}\n\n// Raymarching\nfloat", "\n    return fract( sin( dot( q.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat", "\n    // width = 0 -> angle = 0\n    float angle = width * 2.0 * PI;\n    float r = radius * 0.5;\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r6 = r4 * r2;\n    float r8 = r4 * r4;\n    float r10 = r8 * r2;\n    float r12 = r8 * r4;\n    float r14 = r12 * r2;\n    float r16 = r12 * r4;\n    float r18 = r16 * r2;\n    float r20 = r16 * r4;\n    float r22 = r20 * r2;\n    float r24 = r20 * r4;\n    float r26 = r24 * r2;\n    float r28 = r24 * r4;\n    float r30 = r28 * r2;\n    float r32 = r28 * r4;\n    float r34 = r32 * r2;\n    float r36 = r32 * r4;\n    float r38 = r36 * r2;\n    float r40 = r36 * r4;\n    float r42 = r40 * r2;\n    float r44 = r40 * r4;\n    float r46 = r44 * r2;\n    float r48 = r44 * r4;\n    float r50 = r48 * r2;\n    float r52 = r48 * r4;\n    float r54 = r52 * r2;\n    float r56 = r52 * r4;\n    float r58 = r56 * r2;\n    float r60 = r56 * r4;\n    float r62 = r60 * r2;\n    float r64 = r60 * r4;\n    float r66 = r64 * r2;\n    float r68 = r64 * r4;\n    float r70 = r68", "\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod(i, 289.0);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n        dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (4", "\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\t\n\t// get the distance to the center\n\tfloat d = length(uv);\n\t\n\t// get the angle\n\tfloat a = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d2 = length(uv);\n\t\n\t// get the angle\n\tfloat a2 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d3 = length(uv);\n\t\n\t// get the angle\n\tfloat a3 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d4 = length(uv);\n\t\n\t// get the angle\n\tfloat a4 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d5 = length(uv);\n\t\n\t// get the angle\n\tfloat a5 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d6 = length(uv);\n\t\n\t// get the angle\n\tfloat a6 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d7 = length(uv);\n\t\n\t// get the angle\n\tfloat a7 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d8 = length(uv);\n\t\n\t// get the angle\n\tfloat a8 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d9 = length(uv);\n\t\n\t// get the angle\n\tfloat a9 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d10 = length(uv);\n\t\n\t// get the angle\n\tfloat a10 = atan(uv.y, uv.x);\n\t\n\t// get the distance to the center\n\tfloat d11 = length(uv);\n\t\n\t// get the angle\n\t", "\n    vec3 s = vec3(10, 10, 10);\n\n    // Integer part, scaled and offset so that value is always positive.\n    vec3 a = floor(mod(p, s)) * (1.0 / s);\n\n    // Fractional part for interpolation\n    vec3 f = fract(p);\n\n    // Sine interpolation\n    float n = sin(dot(a, vec3(7, 157, 113)));\n\n    // Linear interpolation\n    return mix(mix(mix(hash31(n + dot(a, vec3(0, 0, 1))), hash31(n + dot(a, vec3(1, 0, 1))), f.x),\n                   mix(hash31(n + dot(a, vec3(0, 1, 1))), hash31(n + dot(a, vec3(1, 1, 1))), f.x), f.y),\n               mix(mix(hash31(n + dot(a, vec3(0, 0, 0))), hash31(n + dot(a, vec3(1, 0, 0))), f.x),\n                   mix(hash31(n + dot(a, vec3(0, 1, 0))), hash31(n + dot(a, vec3(1, 1, 0))), f.x), f.y), f.z);\n}\n\nfloat", "\n\tsp = p;\n\tsp.x = atan(sp.x, sp.z);\n\tsp.y = asin(sp.y);\n\tsp.x = sp.x * 0.5 * M_PI;\n\tsp.y = sp.y * 0.5 * M_PI;\n\n\t// Apply the inverse log-spherical map\n\ttp = sp;\n\ttp.x = cos(tp.x) * sin(tp.y);\n\ttp.y = sin(tp.x) * sin(tp.y);\n\ttp.z = cos(tp.y);\n\n\t// Apply the inverse log-spherical map\n\trp = tp;\n\trp.x = atan(rp.x, rp.z);\n\trp.y = asin(rp.y);\n\trp.x = rp.x * 0.5 * M_PI;\n\trp.y = rp.y * 0.5 * M_PI;\n\n\t// Apply the forward log-spherical map\n\tsp = rp;\n\tsp.x = cos(sp.x) * sin(sp.y);\n\tsp.y = sin(sp.x) * sin(sp.y);\n\tsp.z = cos(sp.y);\n\n\t// Apply the inverse log-spherical map\n\ttp = sp;\n\ttp.x = atan(tp.x, tp.z);\n\ttp.y = asin(tp.y);\n\ttp.x = tp.x * 0.5 * M_PI;\n\ttp.y = tp.y * 0.5 * M_PI;\n\n\t// Apply the forward log-spherical map\n\tsp = tp;\n\tsp.x = cos(sp.x) * sin(sp.y);\n\tsp.y = sin(sp.x) * sin(sp.y);\n\tsp.z = cos(sp.y);\n\n\t// Apply the inverse log-spherical map\n\trp = sp;\n\trp.x = atan(rp.x, rp.z);\n\trp.y = asin(rp.y);\n\trp.x = rp.x", "\n    float y = sin(u_Time * 0.5) * 0.5 + 0.5;\n    float r = cos(u_Time * 0.5) * 0.5 + 0.5;\n    vec3 s = vec3(0.0, y, 0.0);\n    float d = length(p - s) - r;\n    \n    //distance to plane\n    float d2 = p.y;\n    \n    //return the minimum distance\n    return vec2(min(d, d2), 0.0);\n}\n\n//raymarching function\nvec", "\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec", "\n\tvec2 p1 = p;\n\tvec2 p2 = p;\n\tvec2 p3 = p;\n\tvec2 p4 = p;\n\tvec2 p5 = p;\n\tvec2 p6 = p;\n\tvec2 p7 = p;\n\tvec2 p8 = p;\n\tvec2 p9 = p;\n\tvec2 p10 = p;\n\tvec2 p11 = p;\n\tvec2 p12 = p;\n\tvec2 p13 = p;\n\tvec2 p14 = p;\n\tvec2 p15 = p;\n\tvec2 p16 = p;\n\tvec2 p17 = p;\n\tvec2 p18 = p;\n\tvec2 p19 = p;\n\tvec2 p20 = p;\n\tvec2 p21 = p;\n\tvec2 p22 = p;\n\tvec2 p23 = p;\n\tvec2 p24 = p;\n\tvec2 p25 = p;\n\tvec2 p26 = p;\n\tvec2 p27 = p;\n\tvec2 p28 = p;\n\tvec2 p29 = p;\n\tvec2 p30 = p;\n\tvec2 p31 = p;\n\tvec2 p32 = p;\n\tvec2 p33 = p;\n\tvec2 p34 = p;\n\tvec2 p35 = p;\n\tvec2 p36 = p;\n\tvec2 p37 = p;\n\tvec2 p38 = p;\n\tvec2 p39 = p;\n\tvec2 p40 = p;\n\tvec2 p41 = p;\n\tvec2 p42 = p;\n\tvec2 p43 = p;\n\tvec2 p44 = p;\n\tvec2 p45 = p;\n\tvec2 p46 = p;\n\tvec2 p47 = p;\n\tvec2 p48 = p;\n\tvec2 p49 = p;\n\tvec2 p50 = p;\n\tvec2 p51 = p;\n\tvec2 p52 = p;\n", "\n    mat3 rot = getRotationMatrix(box.rotation);\n\n    // get the position of the box in the world\n    vec3 boxPos = box.position;\n\n    // get the position of the vertex in the box's local space\n    vec3 localPos = pos - boxPos;\n\n    // rotate the vertex into the box's local space\n    localPos = rot * localPos;\n\n    // get the position of the vertex in the world space\n    pos = localPos + boxPos;\n\n    // get the distance from the vertex to the box's center\n    float dist = length(pos - boxPos);\n\n    // get the distance from the vertex to the box's edge\n    float edge = length(pos - boxPos) - box.size;\n\n    // return the distance from the vertex to the box's edge\n    return vec2(edge, dist);\n}\n\n// get the distance from the vertex to the box's edge\nfloat", "\n    pos.y = sin(pos.x * 0.5 + iTime * 0.5) * 0.5 + 0.5;\n\n    // return the distance to the sphere\n    return vec2(length(pos) - 0.5, 1.0);\n}\n\n// the distance function for the scene\nvec", "\n    vec2 res = vec2(1000000.0, -1.0);\n    res = min(res, sdBox(pos - vec3(0.0, 0.0, 0.0), vec3(1.0)));\n    res = min(res, sdBox(pos - vec3(2.0, 0.0, 0.0), vec3(1.0)));\n    res = min(res, sdBox(pos - vec3(4.0, 0.0, 0.0), vec3(1.0)));\n    res = min(res, sdBox(pos - vec3(6.0, 0.0, 0.0), vec3(1.0)));\n    res = min(res, sdBox(pos - vec3(8.0, 0.0, 0.0), vec3(1.0)));\n    return res;\n}\n\n// calculate the normal for a given point\nvec", "\n    vec3 rayDir = normalize(camDir + (fragCoord.x * u_camRight) + (fragCoord.y * u_camUp));\n    \n    // march the ray\n    vec3 marchPos = camPos;\n    float marchDist = 0.0;\n    float marchStep = 0.0;\n    float marchDistMax = 100.0;\n    float marchDistMin = 0.001;\n    float marchDistTotal = 0.0;\n    float marchDistPrev = 0.0;\n    float marchDistCurr = 0.0;\n    float marchDistNext = 0.0;\n    float marchDistDelta = 0.0;\n    float marchDistDeltaPrev = 0.0;\n    float marchDistDeltaCurr = 0.0;\n    float marchDistDeltaNext = 0.0;\n    float marchDistDeltaTotal = 0.0;\n    float marchDistDeltaTotalPrev = 0.0;\n    float marchDistDeltaTotalCurr = 0.0;\n    float marchDistDeltaTotalNext = 0.0;\n    float marchDistDeltaTotalTotal = 0.0;\n    float marchDistDeltaTotalTotalPrev = 0.0;\n    float marchDistDeltaTotalTotalCurr = 0.0;\n    float marchDistDeltaTotalTotalNext = 0.0;\n    float marchDistDeltaTotalTotalTotal = 0.0;\n    float marchDistDeltaTotalTotalTotalPrev = 0.0;\n    float marchDistDeltaTotalTotalTotalCurr = 0.0;\n    float marchDistDeltaTotalTotalTotalNext = 0.0;\n    float marchDistDeltaTotalTotalTotalTotal = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalPrev = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalCurr = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalNext = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalTotal = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalTotalPrev = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalTotalCurr = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalTotalNext = 0.0;\n    float marchDistDeltaTotalTotalTotalTotalTotalTotal = 0.", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\treturn vec2( tN, tF );\n}\n\nfloat", "\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\t\n\t// time varying pixel color\n\tvec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));\n\t\n\t// output to screen\n\tfragColor = vec4(col,1.0);\n}", "\n    return dot(pos, plane.normal) + plane.distance;\n}\n\nvec", " cell\n    vec3 i = floor(fx);\n    // grid cell corners\n    vec3 f = fract(fx);\n    // 3D grid cell corners\n    vec3 p = vec3(i.x + i.y*57.0 + 113.0*i.z,\n                  i.x + 113.0*i.y + 57.0*i.z,\n                  i.x + 57.0*i.y + 113.0*i.z);\n    // hash values at the corners\n    vec4 h = vec4(0.0, i.x + 113.0, i.x + 57.0, i.x) +\n             i.y + vec4(57.0, 57.0 + 113.0, 113.0, 113.0 + 1.0);\n    h = fract(sin(h) * 43758.5453);\n    // smooth interpolation weights\n    vec4 u = f * f * (3.0 - 2.0 * f);\n    // mix 4 coorners por grid cell\n    return mix(mix(mix(h.x, h.y, u.x), mix(h.z, h.w, u.x), u.y),\n               mix(mix(h.x, h.y, u.z), mix(h.z, h.w, u.z), u.y), u.w);\n}\n\nfloat", "\n    // and integer octaves\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function to generate the fractal\n    // we need to use a different function", "\n    p.x += sin(p.y*0.1)*0.05;\n    p.z += cos(p.y*0.1)*0.05;\n\n    // Capsule body\n    vec2 d = abs(vec2(length(p.xz)-2.0*r,p.y))-vec2(0.0,h);\n\n    // Capsule endcaps\n    float dc = length(max(vec2(d.x,d.y),0.0)) + min(max(d.x,d.y), 0.0);\n\n    // Capsule head\n    float dh = length(p.xz) - r;\n\n    return min(min(dc,dh),0.0) + length(max(vec2(dh,dc), 0.0));\n}\n\nfloat", "\n     p.xz += vec2(sin(iTime*0.5),cos(iTime*0.5))*0.5;\n     p.y += sin(iTime*0.5)*0.5;\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p.xz *= rotate2D(iTime*0.5);\n     p", "\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n  return normalize(vec3(\n    map(p + eps.xyy) - map(p - eps.xyy),\n    map(p + eps.yxy) - map(p - eps.yxy),\n    map(p + eps.yyx) - map(p - eps.yyx)\n  ));\n}\n\nfloat", "\n    return max(dot(n,l),0.0);\n}\n\nfloat", "\n    float a = dot(rd,rd);\n    float b = dot(rd,ro);\n    float c = dot(ro,ro) - ra*ra;\n    float d = b*b - a*c;\n    if( d<0.0 ) return -1.0;\n    d = sqrt(d);\n    float t1 = (-b-d)/a;\n    float t2 = (-b+d)/a;\n    if( t1>t2 ) {\n        float tmp = t1;\n        t1 = t2;\n        t2 = tmp;\n    }\n    if( t1<0.0 ) {\n        t1 = t2;\n        if( t1<0.0 ) return -1.0;\n    }\n    return t1;\n}\n\nfloat", "\n    vec2 w = fwidth(p) * 2.0;\n    // analytical integral (box filter)\n    vec2 a = abs(mod(p,w)-0.5*w) - 0.5*w;\n    // conservative integral (box filter)\n    vec2 b = max(sign(a),0.0);\n    // fraction inside box\n    float f = clamp( dot(b,dpdx) / dot(b,w), 0.0, 1.0 );\n    // conservative integral (triangle filter)\n    b = max(sign(a+vec2(0.5*w.x,0.0)),0.0);\n    // fraction inside triangle\n    f *= clamp( dot(b,dpdy) / dot(b,w), 0.0, 1.0 );\n    return f;\n}\n\nfloat", "\n    Sphere[0].Center.X = 0.0;\n    Sphere[0].Center.Y = 0.0;\n    Sphere[0].Center.Z = 0.0;\n    Sphere[0].Radius = 1.0;\n    Sphere[0].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[1].Center.X = -1.0;\n    Sphere[1].Center.Y = 0.0;\n    Sphere[1].Center.Z = 0.0;\n    Sphere[1].Radius = 1.0;\n    Sphere[1].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[2].Center.X = 1.0;\n    Sphere[2].Center.Y = 0.0;\n    Sphere[2].Center.Z = 0.0;\n    Sphere[2].Radius = 1.0;\n    Sphere[2].materialID = 0;\n\n    // Top bouncing sphere.\n    Sphere[3].Center.X = 0.0;\n    Sphere[3].Center.Y = 1.0;\n    Sphere[3].Center.Z = 0.0;\n    Sphere[3].Radius = 1.0;\n    Sphere[3].materialID = 0;\n\n    // Bottom bouncing sphere.\n    Sphere[4].Center.X = 0.0;\n    Sphere[4].Center.Y = -1.0;\n    Sphere[4].Center.Z = 0.0;\n    Sphere[4].Radius = 1.0;\n    Sphere[4].materialID = 0;\n\n    // Back bouncing sphere.\n    Sphere[5].Center.X = 0.0;\n    Sphere[5].Center.Y = 0.0;\n    Sphere[5].Center.Z = -1.0;\n    Sphere[5].Radius = 1.0;\n    Sphere[5].materialID = 0;\n\n    // Front bouncing sphere.\n    Sphere[6].Center.X = 0.0;\n    Sphere[6].Center.Y = 0.", "\n    //\n    // This function should return true if the given ray intersects the given sphere.\n    // If the ray intersects the sphere, then t should be set to the distance along the ray\n    // that the intersection occurs.\n    //\n    // If the ray intersects the sphere, then hitPos should be set to the position of the\n    // intersection point, and hitNormal should be set to the normal at the intersection point.\n    //\n    // If the ray does not intersect the sphere, then t should be set to -1.\n    //\n    // If the ray does not intersect the sphere, then hitPos and hitNormal should be set\n    // to any value.\n    //\n    // Hint: Remember that the equation of a sphere is given by (x-cx)^2 + (y-cy)^2 + (z-cz)^2 = r^2,\n    // where (x,y,z) are a point on the sphere, (cx,cy,cz) is the center of the sphere, and r is the\n    // radius of the sphere.\n    //\n    // Hint: Remember that the equation of a ray is given by P = O + t*D, where O is the origin of the ray,\n    // D is the direction of the ray, and t is a scalar.\n    //\n    // Hint: Remember that the dot product of two vectors is given by dot(u,v) = u.x*v.x + u.y*v.y + u.z*v.z.\n    //\n    // Hint: Remember that the cross product of two vectors is given by cross(u,v) = (u.y*v.z - u.z*v.y, u.z*v.x - u.x*v.z, u.x*v.y - u.y*v.x).\n    //\n    // Hint: Remember that the length of a vector is given by length(u) = sqrt(u.x^2 + u.y^2 + u.z^2).\n    //\n    // Hint: Remember that the normalize function returns a vector with the same direction as the input vector,\n    // but with a length of 1.\n    //\n   ", "\n    //\n    // This function should return true if the given ray intersects the given sphere.\n    //\n    // The ray is defined by a point and a direction.\n    // The sphere is defined by a center and a radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n    //\n    // The ray intersects the sphere if the distance between the ray and the sphere is less than the radius.\n", "\n    float tmin = 1000000.0;\n    hasHit = false;\n    for (int i = 0; i < num_objects; i++) \n    {\n        float t = objects[i].Intersect(ray);\n        if (t > 0.0) \n        {\n            hasHit = true;\n            if (t < tmin) \n            {\n                tmin = t;\n                hitPos = ray.origin + ray.direction * t;\n                hitNormal = objects[i].GetNormal(hitPos);\n                k_rg = objects[i].k_rg;\n            }\n        }\n    }\n    return k_rg;\n}\n\nvec", "\n    float tp = (0.0 - ro.y) / rd.y;\n    if( tp > 0.0 ) mint = max( mint, tp );\n\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<10; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvec", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec", "\n    vec3 camera_pos = start + dir * planet_radius;\n\n    // calculate the distance from the camera to the planet\n    float dist_to_planet = distance(camera_pos, planet_position);\n\n    // if the distance to the planet is less than the radius of the planet, then the camera is inside the planet\n    if (dist_to_planet < planet_radius) {\n        return scene_color;\n    }\n\n    // calculate the distance from the camera to the atmosphere\n    float dist_to_atmo = dist_to_planet - planet_radius;\n\n    // if the distance to the atmosphere is less than the radius of the atmosphere, then the camera is inside the atmosphere\n    if (dist_to_atmo < atmo_radius) {\n        return scene_color;\n    }\n\n    // calculate the distance from the camera to the atmosphere\n    float dist_to_atmo_end = dist_to_atmo - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo_end_end = dist_to_atmo_end - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo_end_end_end = dist_to_atmo_end_end - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo_end_end_end_end = dist_to_atmo_end_end_end - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo_end_end_end_end_end = dist_to_atmo_end_end_end_end - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo_end_end_end_end_end_end = dist_to_atmo_end_end_end_end_end - atmo_radius;\n\n    // calculate the distance from the camera to the end of the atmosphere\n    float dist_to_atmo", "\n    vec3 bent_normal = normalize(mix(surface_normal, light_dir, 0.1));\n\n    // calculate the skylight color\n    vec3 skylight_col = background_col * pow(max(dot(bent_normal, light_dir), 0.0), 1.0);\n\n    // calculate the skylight attenuation\n    float attenuation = max(dot(bent_normal, light_dir), 0.0);\n\n    // return the skylight color\n    return skylight_col * attenuation;\n}\n\n// calculate the skylight color\nvec", "\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // the distance to the nearest object\n    float dist = 1000000.0;\n    \n    // the normal of the nearest object\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    \n    // the position of the nearest object\n    vec3 pos_obj = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the nearest object\n    vec3 color_obj = vec3(0.0, 0.0, 0.0);\n    \n    // the material of the nearest object\n    int material_obj = 0;\n    \n    // the id of the nearest object\n    int id_obj = 0;\n    \n    // the id of the nearest object\n    int id_obj_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last_last_last_last_last = 0;\n    \n    // the id of the nearest object\n    int id_obj_last_last_last_last_last_last_last_last_", "\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    \n    // get the ray direction\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    \n    // get the ray origin\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    \n    // get the ray length\n    float rayLength = length(rayDir);\n    \n    // get the ray step\n    float rayStep = 0.01;\n    \n    // get the ray distance\n    float rayDistance = 0.0;\n    \n    // get the ray color\n    vec3 rayColor = vec3(0.0);\n    \n    // get the ray normal\n    vec3 rayNormal = vec3(0.0);\n    \n    // get the ray position\n    vec3 rayPosition = vec3(0.0);\n    \n    // get the ray direction\n    vec3 rayDirection = vec3(0.0);\n    \n    // get the ray distance\n    float rayDistance = 0.0;\n    \n    // get the ray color\n    vec3 rayColor = vec3(0.0);\n    \n    // get the ray normal\n    vec3 rayNormal = vec3(0.0);\n    \n    // get the ray position\n    vec3 rayPosition = vec3(0.0);\n    \n    // get the ray direction\n    vec3 rayDirection = vec3(0.0);\n    \n    // get the ray distance\n    float rayDistance = 0.0;\n    \n    // get the ray color\n    vec3 rayColor = vec3(0.0);\n    \n    // get the ray normal\n    vec3 rayNormal = vec3(0.0);\n    \n    // get the ray position\n    vec3 rayPosition = vec3(0.0);\n    \n    // get the ray direction\n    vec3 rayDirection = vec3(0.0);\n    \n    // get the ray distance\n    float rayDistance = 0.", "\n    vec3 s0_r0 = s0 - r0;\n    float b = dot(s0_r0, rd);\n    float c = dot(s0_r0, s0_r0) - sr * sr;\n    // Exit if r's origin outside s (c > 0) and r pointing away from s (b > 0)\n    if (c > 0.0 && b > 0.0) return -1.0;\n    float discr = b * b - c;\n    // A negative discriminant corresponds to ray missing sphere\n    if (discr < 0.0) return -1.0;\n    // Ray now found to intersect sphere, compute smallest t value of intersection\n    return -b - sqrt(discr);\n}\n\nfloat", "ialize the ray\n    vec3 rayPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n\n    //initialize the color\n    vec4 color = vec4(0.0);\n\n    //initialize the distance\n    float distance = 0.0;\n\n    //initialize the material\n    Material material;\n\n    //initialize the normal\n    vec3 normal;\n\n    //initialize the hit\n    bool hit = false;\n\n    //initialize the hit distance\n    float hitDistance = 0.0;\n\n    //initialize the hit position\n    vec3 hitPos;\n\n    //initialize the hit normal\n    vec3 hitNormal;\n\n    //initialize the hit material\n    Material hitMaterial;\n\n    //initialize the hit object\n    Object hitObject;\n\n    //initialize the hit object index\n    int hitObjectIndex = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex2 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex3 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex4 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex5 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex6 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex7 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex8 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex9 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex10 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex11 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex12 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex13 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex14 = -1;\n\n    //initialize the hit object index\n    int hitObjectIndex15 = -1", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", " ray\n    vec3 ray_path[MAX_RAY_PATH_LENGTH];\n    ray_path[0] = ray_origin;\n    int ray_path_length = 1;\n\n    // Initialize the ray color -\n    // the color of the sample ray\n    vec3 ray_color = vec3(0.0);\n\n    // Initialize the ray distance -\n    // the distance of the sample ray\n    float ray_distance = 0.0;\n\n    // Initialize the ray bounce -\n    // the number of bounces the sample ray has made\n    int ray_bounce = 0;\n\n    // Initialize the ray mask -\n    // the mask of the sample ray\n    int ray_mask = 0;\n\n    // Initialize the ray material -\n    // the material of the sample ray\n    int ray_material = 0;\n\n    // Initialize the ray normal -\n    // the normal of the sample ray\n    vec3 ray_normal = vec3(0.0);\n\n    // Initialize the ray position -\n    // the position of the sample ray\n    vec3 ray_position = ray_origin;\n\n    // Initialize the ray direction -\n    // the direction of the sample ray\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n\n    // Initialize the ray direction dot product -\n    // the dot product of the sample ray direction and the sample ray normal\n    float ray_direction_dot_product = 0.0;\n\n    // Initialize the ray direction dot product -\n    // the dot product of the sample ray direction and the sample ray normal\n    float ray_direction_dot_product_abs = 0.0;\n\n    // Initialize the ray direction dot product -\n    // the dot product of the sample ray direction and the sample ray normal\n    float ray_direction_dot_product_abs_inv = 0.0;\n\n    // Initialize the ray direction dot product -\n    // the dot product of the sample ray direction and the sample ray normal\n    float ray_direction_dot_product_abs_inv_sqr = 0.0;\n\n    // Initialize the ray direction dot product -\n    // the dot product of the sample", "\n    vec2 id = floor(p);\n    vec2 pos = fract(p);\n    \n    // Local cell index.\n    float i = id.x + id.y * 10.0;\n    \n    // Random offset.\n    vec2 offset = hash22(i);\n    \n    // Local cell coordinates.\n    vec2 pos0 = pos + offset - 0.5;\n    vec2 pos1 = pos + offset - vec2(1.0, 0.0) - 0.5;\n    vec2 pos2 = pos + offset - vec2(0.0, 1.0) - 0.5;\n    vec2 pos3 = pos + offset - vec2(1.0, 1.0) - 0.5;\n    \n    // Local cell values.\n    float v0 = value(pos0);\n    float v1 = value(pos1);\n    float v2 = value(pos2);\n    float v3 = value(pos3);\n    \n    // Smooth interpolation.\n    float sx = smoothstep(-0.2, 0.2, pos.x);\n    float sy = smoothstep(-0.2, 0.2, pos.y);\n    \n    // Interpolate between the local cells.\n    float vx0 = mix(v0, v1, sx);\n    float vx1 = mix(v2, v3, sx);\n    float vxy = mix(vx0, vx1, sy);\n    \n    return vec3(vxy, pos0, pos3 - pos0);\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 j = jigsaw(uv * 10.0);\n    gl_FragColor = vec4(j, 1.0);\n}\n", "\n    vec3 sphere_pos = vec3(0.0, 0.0, 0.0);\n    float sphere_radius = 1.0;\n\n    // calculate distance to sphere\n    float dist = length(p - sphere_pos) - sphere_radius;\n\n    return dist;\n}\n\nvec", "\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    // calculate the hash\n    vec4 hashx0, hashx1, hashy0, hashy1;\n    FAST32_hash_3D( Pi, hashx0, hashx1, hashy0, hashy1 );\n\n    // calculate the gradients\n    vec4 gradx0 = hashx0 - 0.49999;\n    vec4 gradx1 = hashx1 - 0.49999;\n    vec4 grady0 = hashy0 - 0.49999;\n    vec4 grady1 = hashy1 - 0.49999;\n\n    // normals\n    vec4 norm0 = inversesqrt( gradx0 * gradx0 + grady0 * grady0 + 1.0 );\n    vec4 norm1 = inversesqrt( gradx1 * gradx1 + grady1 * grady1 + 1.0 );\n\n    // mix normals\n    vec2 norm00 = vec2( gradx0.x, grady0.x ) * norm0.x;\n    vec2 norm10 = vec2( gradx1.x, grady1.x ) * norm1.x;\n    vec2 norm01 = vec2( gradx0.y, grady0.y ) * norm0.y;\n    vec2 norm11 = vec2( gradx1.y, grady1.y ) * norm1.y;\n    vec2 norm02 = vec2( gradx0.z, grady0.z ) * norm0.z;\n    vec2 norm12 = vec2( gradx1.z, grady1.z ) * norm1.z;\n    vec2 norm03 = vec2( gradx0.w, grady0.w ) * norm0.w;\n    vec2 norm13 = vec2( gradx1.w, grady1.w ) * norm1.w;\n\n    // compute the", "\n    float i = floor(x);\n    float f = fract(x);\n\n    // quintic interpolation\n    float u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    // noise\n    return mix(\n        mix(\n            hash(i+0.0),\n            hash(i+1.0),\n            u\n        ),\n        mix(\n            hash(i+1.0),\n            hash(i+2.0),\n            u\n        ),\n        f\n    );\n}\n\nfloat", "\n    float d = p.y;\n    float t = -(p.y + 1.0) / p.z;\n    if (t > 0.0) d = min(d, t);\n    t = (p.y - 1.0) / p.z;\n    if (t > 0.0) d = min(d, t);\n    t = -p.y / p.x;\n    if (t > 0.0) d = min(d, t);\n    t = p.y / p.x;\n    if (t > 0.0) d = min(d, t);\n    return vec2(d, 0.0);\n}\n\nvec", "\n    float d = sdBox(p, vec3(1.0));\n\n    // base\n    float d2 = sdBox(p, vec3(0.9));\n\n    // base hole\n    float d3 = sdBox(p, vec3(0.8));\n\n    // base hole\n    float d4 = sdBox(p, vec3(0.7));\n\n    // base hole\n    float d5 = sdBox(p, vec3(0.6));\n\n    // base hole\n    float d6 = sdBox(p, vec3(0.5));\n\n    // base hole\n    float d7 = sdBox(p, vec3(0.4));\n\n    // base hole\n    float d8 = sdBox(p, vec3(0.3));\n\n    // base hole\n    float d9 = sdBox(p, vec3(0.2));\n\n    // base hole\n    float d10 = sdBox(p, vec3(0.1));\n\n    // base hole\n    float d11 = sdBox(p, vec3(0.05));\n\n    // base hole\n    float d12 = sdBox(p, vec3(0.025));\n\n    // base hole\n    float d13 = sdBox(p, vec3(0.0125));\n\n    // base hole\n    float d14 = sdBox(p, vec3(0.00625));\n\n    // base hole\n    float d15 = sdBox(p, vec3(0.003125));\n\n    // base hole\n    float d16 = sdBox(p, vec3(0.0015625));\n\n    // base hole\n    float d17 = sdBox(p, vec3(0.00078125));\n\n    // base hole\n    float d18 = sdBox(p, vec3(0.000390625));\n\n    // base hole\n", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - pix - d;\n}\n\nfloat", "\n\tvec2 st = fragCoord;\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat d = distance(st,vec2(iMouse.x,iMouse.y));\n\t\n\tfloat r = d/100.0;\n\t\n\tcolor = vec3(r);\n\t\n\tfragColor = vec4(color,1.0);\n}", "\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.x + p.y;\n    // float hex = p.x - p.y;\n    \n    // Flat top and pointed top hexagons.\n    // float hex = p.", "\n    return (sin(ix*1600+iy*1600)+sin(ix*1600+iy*1600+136)+sin(ix*1600+iy*1600+272))/3;\n}\n\nfloat", "\n    p.xz = rotate2d( time * 0.5 ) * p.xz;\n\n    // map the sphere\n    p = map( p );\n\n    // get the color\n    return getColor( p );\n}\n\nvoid main()\n{\n    // get the ray direction\n    vec2 uv = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;\n    vec3 rayDir = normalize( vec3( uv.x, uv.y, 1.0 ) );\n\n    // raymarch\n    float t = raymarch( rayDir );\n\n    // get the color\n    vec3 color = getColor( rayDir * t );\n\n    // output\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n    p *= 1.0;\n    // rotate space\n    p = p * 0.5 + 0.5;\n    // scale space\n   ", "\n    return vec2(atan(z.y,z.x),length(z));\n}\n\nvec", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy - e.xzy;\n\t \n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3.xyz;\n\t vec3 x2 = x - i2 + 2.0*G3.xyz;\n\t vec3 x3 = x - 1.0 + 3.0*G3.xyz;\n\t \n\t /* calculate skewed coords and unskewed coords for 3d noise */\n\t vec3 s1 = s + s*s13;\n\t vec3 s2 = s1 + i1;\n\t vec3 s3 = s2 + i2;\n\t \n\t vec3 n1 = hash33(s1);\n\t vec3 n2 = hash33(s2);\n\t vec3 n3 = hash33(s3);\n\t \n\t /* calculate noise */\n\t vec3 d1 = x - x1;\n\t vec3 d2 = x - x2;\n\t vec3 d3 = x - x3;\n\t \n\t vec3 n = d1*dot(d1, vec3(n1.y, n2.y, n3.y)) + d2*dot(d2, vec3(n1.z, n2.z, n3.z)) + d3*dot(d3, vec3(n1.x, n2.x, n3.x));\n\t \n\t /* scale and return value */\n\t return 70.0*dot(n, vec3(1.0));\n}\n\nfloat", "\n    float d = sdBox( p, vec3( 1.0, 1.0, 1.0 ) );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 1.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 2.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 3.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 4.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 5.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 6.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 7.0 ), vec3( 1.0, 1.0, 1.0 ) ), 0.1 );\n    d = opSmoothUnion( d, sdBox( p + vec3( 0.0, 0.0, 8.0 ), vec3( 1.0, ", "\n    p.xz *= mat2( 0.95, 0.0, -0.0, 0.95 );\n    \n    // the distance to the tree\n    float d = length( p ) - 1.0;\n    \n    // the distance to the trunk\n    d = max( d, -p.y + 0.5 );\n    \n    // the distance to the leaves\n    d = min( d, length( p.xz - vec2( 0.0, 0.0 ) ) - 0.1 );\n    \n    return d;\n}\n\nvec", "\n    //float k = floor(rp.x*.5)*.25;\n    float k = floor(rp.x*.25)*.25;\n    //float k = floor(rp.x*.1)*.25;\n    //float k = floor(rp.x*.05)*.25;\n    //float k = floor(rp.x*.025)*.25;\n    //float k = floor(rp.x*.01)*.25;\n    //float k = floor(rp.x*.005)*.25;\n    //float k = floor(rp.x*.0025)*.25;\n    //float k = floor(rp.x*.001)*.25;\n    //float k = floor(rp.x*.0005)*.25;\n    //float k = floor(rp.x*.00025)*.25;\n    //float k = floor(rp.x*.0001)*.25;\n    //float k = floor(rp.x*.00005)*.25;\n    //float k = floor(rp.x*.000025)*.25;\n    //float k = floor(rp.x*.00001)*.25;\n    //float k = floor(rp.x*.000005)*.25;\n    //float k = floor(rp.x*.0000025)*.25;\n    //float k = floor(rp.x*.000001)*.25;\n    //float k = floor(rp.x*.0000005)*.25;\n    //float k = floor(rp.x*.00000025)*.25;\n    //float k = floor(rp.x*.0000001)*.25;\n    //float k = floor(rp.x*.00000005)*.25;\n    //float k = floor(rp.x*.000000025)*.25;\n    //float k = floor(rp.x*.00", "\n\treturn max(0.0, min(1.0, (end - d) / (end - start)));\n}\n\nvec", "\n    vec4 hexCenters = vec4(0.0, 0.0, 0.0, 0.0);\n    hexCenters.x = mod(floor(p.x / 2.0), 2.0);\n    hexCenters.y = mod(floor(p.y / 2.0), 2.0);\n    hexCenters.z = mod(floor(p.x / 2.0), 2.0);\n    hexCenters.w = mod(floor(p.y / 2.0), 2.0);\n    \n    // The hexagon ID is the unique hexagon center that is closest to the current point.\n    float hexID = hexCenters.x + hexCenters.y * 2.0 + hexCenters.z * 4.0 + hexCenters.w * 8.0;\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter = vec2(hexCenters.x, hexCenters.y);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter2 = vec2(hexCenters.z, hexCenters.w);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter3 = vec2(hexCenters.x, hexCenters.w);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter4 = vec2(hexCenters.z, hexCenters.y);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter5 = vec2(hexCenters.x, hexCenters.w);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current point.\n    vec2 hexCenter6 = vec2(hexCenters.z, hexCenters.y);\n    \n    // The hexagon center is the unique hexagon center that is closest to the current", "\n    float rnd = random(floor(p));\n    \n    // Two by two cell random value.\n    float rnd2 = random(floor(p)+1.0);\n    \n    // Two by two cell random value.\n    float rnd3 = random(floor(p)+vec2(1.0,0.0));\n    \n    // Two by two cell random value.\n    float rnd4 = random(floor(p)+vec2(1.0,1.0));\n    \n    // Two by two cell random value.\n    float rnd5 = random(floor(p)+vec2(0.0,1.0));\n    \n    // Two by two cell random value.\n    float rnd6 = random(floor(p)+vec2(1.0,2.0));\n    \n    // Two by two cell random value.\n    float rnd7 = random(floor(p)+vec2(2.0,1.0));\n    \n    // Two by two cell random value.\n    float rnd8 = random(floor(p)+vec2(2.0,2.0));\n    \n    // Two by two cell random value.\n    float rnd9 = random(floor(p)+vec2(2.0,0.0));\n    \n    // Two by two cell random value.\n    float rnd10 = random(floor(p)+vec2(0.0,2.0));\n    \n    // Two by two cell random value.\n    float rnd11 = random(floor(p)+vec2(2.0,3.0));\n    \n    // Two by two cell random value.\n    float rnd12 = random(floor(p)+vec2(3.0,2.0));\n    \n    // Two by two cell random value.\n    float rnd13 = random(floor(p)+vec2(3.0,3.0));\n    \n    // Two by two cell random value.\n    float rnd14 = random(floor(p)+vec2(3.0,0.0));\n    \n    // Two by two cell random value.\n    float rnd15 = random", "\n    float scale = iMouse.x / iResolution.x;\n\n    // Set color according to scale.\n    // If scale is 0.0, color is red.\n    // If scale is 1.0, color is blue.\n    // If scale is 0.5, color is green.\n    vec3 color = mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), scale);\n\n    // Set output color to color.\n    fragColor = vec4(color, 1.0);\n}", "\n    float theta = atan(pc.y, pc.x);\n    \n    //Solve for the distance of the polar coordinate\n    //(r = a+b*theta)\n    float r = sqrt(pc.x*pc.x + pc.y*pc.y);\n    \n    //Solve for the distance of the polar coordinate\n    //(r = a+b*theta)\n    float r2 = a + b*theta;\n    \n    //Return the difference between the two distances\n    return r - r2;\n}\n\nvoid main(){\n    \n    //Get the polar coordinate of the current pixel\n    vec2 pc = vec2(gl_FragCoord.x, gl_FragCoord.y);\n    \n    //Get the polar coordinate of the center of the screen\n    vec2 center = vec2(width/2.0, height/2.0);\n    \n    //Get the distance of the polar coordinate from the center\n    float dist = distance(pc, center);\n    \n    //Get the distance of the polar coordinate from the center\n    //(r = a+b*theta)\n    float r = sqrt(pc.x*pc.x + pc.y*pc.y);\n    \n    //Get the distance of the polar coordinate from the center\n    //(r = a+b*theta)\n    float r2 = a + b*atan(pc.y, pc.x);\n    \n    //Get the difference between the two distances\n    float diff = r - r2;\n    \n    //Get the difference between the two distances\n    float diff2 = checkOnSpiral(pc, a, b);\n    \n    //Get the difference between the two distances\n    float diff3 = checkOnSpiral(pc, a, b);\n    \n    //Get the difference between the two distances\n    float diff4 = checkOnSpiral(pc, a, b);\n    \n    //Get the difference between the two distances\n    float diff5 = checkOnSpiral(pc, a, b);\n    \n    //Get the difference between the two distances\n    float diff6 = checkOnSpiral(pc, a, b);\n    \n    //Get the difference", "\n    return smoothstep(pct-0.02, pct, st.y) - smoothstep(pct, pct+0.02, st.y);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 st = fragCoord.xy/iResolution.xy;\n    vec3 color = vec3(0.0);\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a dot\n    color = vec3(st.x,st.y,0.0);\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line\n    color = vec3(plot(st,0.5));\n    \n    // Plot a line", "\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/poincaretiling.php\n\n    // The following is a good place to start:\n    // http://www.malinc.se/noneuclidean/en/po", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float ia = floor(a/TWO_PI);\n    a -= ia*TWO_PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float b = atan(r, p.x);\n    float ib = floor(b/TWO_PI);\n    b -= ib*TWO_PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float c = atan(r, p.y);\n    float ic = floor(c/TWO_PI);\n    c -= ic*TWO_PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float d = atan(p.y, p.x);\n    float id = floor(d/TWO_PI);\n    d -= id*TWO_PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float e = atan(r, p.x);\n    float ie = floor(e/TWO_", "\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // Invert the mouse coordinates.\n    m = (m - 0.5) * 2.0;\n    \n    // Invert the mouse coordinates.\n    m.y *= -1.0;\n    \n    // Return the inverted mouse coordinates.\n    return m;\n}\n\n// 2D rotation matrix.\nmat", "\n\tvec3 lightPos0 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos1 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos2 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos3 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos4 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos5 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos6 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos7 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos8 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos9 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos10 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos11 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos12 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos13 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos14 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos15 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos16 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos17 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos18 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos19 =", "\n\tvec3 camPos = vec3(0.0, 0.0, 0.0);\n\tvec3 camDir = normalize(vec3(0.0, 0.0, 1.0));\n\tvec3 camUp = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 camSide = normalize(cross(camDir, camUp));\n\t\n\t// Camera\n\tvec3 rayDir = normalize(camSide * (fragCoord.x - 0.5 * iResolution.x) + camUp * (fragCoord.y - 0.5 * iResolution.y) + camDir * 1.0);\n\t\n\t// Raymarching\n\tfloat dist = 0.0;\n\tfloat maxDist = 100.0;\n\tfloat minDist = 0.001;\n\tfloat t = 0.0;\n\t\n\tfor (int i = 0; i < 100; i++) {\n\t\tvec3 pos = camPos + rayDir * dist;\n\t\tfloat d = map(pos);\n\t\tdist += d;\n\t\tif (d < minDist || dist > maxDist) break;\n\t}\n\t\n\t// Lighting\n\tvec3 lightPos = vec3(0.0, 0.0, 10.0);\n\tvec3 lightDir = normalize(lightPos - pos);\n\tfloat diffuse = max(dot(lightDir, normal), 0.0);\n\t\n\t// Output\n\tfragColor = vec4(diffuse, diffuse, diffuse, 1.0);\n}\n\nfloat", "\n  // Normalized pixel coordinates (from 0 to 1)\n  vec2 uv = fragCoord/iResolution.xy;\n\n  // Time varying pixel color\n  vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n  // Output to screen\n  fragColor = vec4(col,1.0);\n}", "\n    vec3 cube = mod(floor(hash * 255.0), 2.0) * 2.0 - 1.0;\n    \n    // Random vertex of a tetrahedron inside it\n    float choice = mod(hash * 4.0, 1.0);\n    float s = (choice < 0.25)? 1.0 : 0.0;\n    float t = (choice < 0.5)? 1.0 : 0.0;\n    float u = (choice < 0.75)? 1.0 : 0.0;\n    vec3 tetra = vec3(s, t, u);\n    \n    // Blend the two and renormalize\n    vec3 blend = cube + tetra;\n    blend *= inversesqrt(dot(blend, blend));\n    \n    return blend;\n}\n\nfloat", "\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector.\n    // This is a rotation that rotates the plane of the noise function\n    // to the plane of the input vector", "\n  float d = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the YZ plane\n  float d2 = length(p.yz) - 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d3 = length(p.xy) - 1.0;\n  // return the minimum distance\n  return min(d, min(d2, d3));\n}\n\nvec", "\n    // \ub9cc\uc57d \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \uc815\ud655\ud55c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub530\ub77c\uc11c \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud558\uc9c0 \uc54a\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud558\uc9c0 \uc54a\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud558\uc9c0 \uc54a\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud558\uc9c0 \uc54a\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\ufffd", "\n\tmat2 rot = mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n\t\n\t// Get the pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\t\n\t// Get the pixel color\n\tvec3 col = texture(iChannel0, uv).rgb;\n\t\n\t// Rotate the pixel coordinates\n\tuv = (uv - 0.5) * rot + 0.5;\n\t\n\t// Get the rotated pixel color\n\tvec3 col2 = texture(iChannel0, uv).rgb;\n\t\n\t// Mix the two colors\n\tcol = mix(col, col2, 0.5);\n\t\n\t// Output the color\n\tfragColor = vec4(col, 1.0);\n}", "-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos", "\n    vec3 targetDir = normalize( targetPos - ray.origin );\n    float targetDist = length( targetPos - ray.origin );\n    \n    float targetAngle = acos( dot( targetDir, ray.direction ) );\n    float targetAngle2 = targetAngle * targetAngle;\n    \n    float targetAngle3 = targetAngle2 * targetAngle;\n    float targetAngle4 = targetAngle3 * targetAngle;\n    float targetAngle5 = targetAngle4 * targetAngle;\n    \n    float targetAngle6 = targetAngle5 * targetAngle;\n    float targetAngle7 = targetAngle6 * targetAngle;\n    float targetAngle8 = targetAngle7 * targetAngle;\n    \n    float targetAngle9 = targetAngle8 * targetAngle;\n    float targetAngle10 = targetAngle9 * targetAngle;\n    float targetAngle11 = targetAngle10 * targetAngle;\n    \n    float targetAngle12 = targetAngle11 * targetAngle;\n    float targetAngle13 = targetAngle12 * targetAngle;\n    float targetAngle14 = targetAngle13 * targetAngle;\n    \n    float targetAngle15 = targetAngle14 * targetAngle;\n    float targetAngle16 = targetAngle15 * targetAngle;\n    float targetAngle17 = targetAngle16 * targetAngle;\n    \n    float targetAngle18 = targetAngle17 * targetAngle;\n    float targetAngle19 = targetAngle18 * targetAngle;\n    float targetAngle20 = targetAngle19 * targetAngle;\n    \n    float targetAngle21 = targetAngle20 * targetAngle;\n    float targetAngle22 = targetAngle21 * targetAngle;\n    float targetAngle23 = targetAngle22 * targetAngle;\n    \n    float targetAngle24 = targetAngle23 * targetAngle;\n    float targetAngle25 = targetAngle24 * targetAngle;\n    float", "\n    // p.y -= 1.;\n    // p.z -= 1.;\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.", "\n    float i = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n\n    // quintic interpolation\n    return mix(\n        mix(\n            mix(dot(hash(i + vec2(0.0, 0.0)), vec2(f, f), 1.0),\n                dot(hash(i + vec2(1.0, 0.0)), vec2(f - 1.0, f), 1.0), u),\n            mix(dot(hash(i + vec2(0.0, 1.0)), vec2(f, f - 1.0), 1.0),\n                dot(hash(i + vec2(1.0, 1.0)), vec2(f - 1.0, f - 1.0), 1.0), u),\n            u),\n        mix(\n            mix(dot(hash(i + vec2(0.0, 0.0)), vec2(f, f), 1.0),\n                dot(hash(i + vec2(1.0, 0.0)), vec2(f - 1.0, f), 1.0), u),\n            mix(dot(hash(i + vec2(0.0, 1.0)), vec2(f, f - 1.0), 1.0),\n                dot(hash(i + vec2(1.0, 1.0)), vec2(f - 1.0, f - 1.0), 1.0), u),\n            u),\n        u);\n}\n\nfloat", "s\n    vec2 v0 = p3 - p1;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = uv - p1;\n\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    float inverDeno = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * inverDeno;\n    float v = (dot00 * dot12 - dot01 * dot02) * inverDeno;\n\n    return (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Draw a triangle\n    if(in_triangle(vec2(0.2, 0.2), vec2(0.8, 0.2), vec2(0.5, 0.8), uv)){\n        col = vec3(1.0, 0.0, 0.0);\n    }\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "\n    float n = log(uv.x/start_radius)/log(1.5);\n    float n_int = floor(n);\n    float n_frac = n - n_int;\n    \n    //Find the closest hexagon\n    if(n_frac < 0.5){\n        n_int -= 1.0;\n    }\n    \n    //Find the center of the closest hexagon\n    float r = start_radius * pow(1.5, n_int);\n    float theta = atan(uv.y, uv.x);\n    float x = r * cos(theta);\n    float y = r * sin(theta);\n    \n    return int(n_int);\n}\n\nvec", ".\n    //The points are then rotated and translated to the\n    //current hexagon.\n    \n    //The current hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next hexagon is defined by the circumradius\n    //and the rotation.\n    \n    //The next", ".\n    //\n    //The distance between the points is the circumradius of the hexagon.\n    //\n    //The angle between the points is 30 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon is 60 degrees.\n    //\n    //The angle between the points and the center of the hexagon", "\n    float k = exp(-d);\n    float x = exp(dot(U, U) / 2.0);\n    return x * k / (2.0 * 3.1415926535897932384626433832795);\n}\n\nfloat", "'s implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash2(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash3(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash4(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash5(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash6(uint n)\n{\n    //", "\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    // time\n    float t = iTime;\n\n    // color\n    vec3 col = vec3(0.0);\n\n    // loop\n    for (float i = 0.0; i < 10.0; i++) {\n        // position\n        vec2 pos = vec2(sin(t * 0.1 + i * 0.1), cos(t * 0.1 + i * 0.1));\n\n        // distance\n        float d = length(uv - pos);\n\n        // color\n        col += vec3(1.0 / d);\n    }\n\n    // output\n    fragColor = vec4(col, 1.0);\n}", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n  float epsilon = 0.0001;\n  // calculate the normal\n  return normalize(\n    vec3(\n      calcHeight(pos + vec3(epsilon, 0.0, 0.0)) - calcHeight(pos - vec3(epsilon, 0.0, 0.0)),\n      calcHeight(pos + vec3(0.0, epsilon, 0.0)) - calcHeight(pos - vec3(0.0, epsilon, 0.0)),\n      calcHeight(pos + vec3(0.0, 0.0, epsilon)) - calcHeight(pos - vec3(0.0, 0.0, epsilon))\n    )\n  );\n}\n\nvoid main() {\n  // calculate the normal\n  vec3 normal = calcNormal(v_position);\n  // calculate the light\n  vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n  // calculate the diffuse\n  float diffuse = max(dot(normal, light), 0.0);\n  // calculate the ambient\n  float ambient = 0.1;\n  // calculate the final color\n  vec3 color = vec3(diffuse + ambient);\n  // set the final color\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n  vec2 t = castRay(ro, rd);\n  vec3 col = vec3(0.0);\n  if (t.x > 0.0) {\n    vec3 pos = ro + t.x * rd;\n    vec3 nor = calcNormal(pos);\n    col = calcColor(pos, nor);\n  }\n  return col;\n}\n\nvoid main() {\n  vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n  vec3 ro = vec3(0.0, 0.0, 1.0);\n  vec3 rd = normalize(vec3(uv, -1.0));\n  vec3 col = render(ro, rd);\n  gl_FragColor = vec4(col, 1.0);\n}\n", "\n    float epsilon = 0.0001;\n    // calculate the normal\n    return normalize(vec3(\n        calcHeight(pos + vec3(epsilon, 0, 0)) - calcHeight(pos - vec3(epsilon, 0, 0)),\n        calcHeight(pos + vec3(0, epsilon, 0)) - calcHeight(pos - vec3(0, epsilon, 0)),\n        calcHeight(pos + vec3(0, 0, epsilon)) - calcHeight(pos - vec3(0, 0, epsilon))\n    ));\n}\n\nvoid main() {\n    // calculate the normal\n    vec3 normal = calcNormal(position);\n    // calculate the light\n    vec3 light = normalize(vec3(1, 1, 1));\n    // calculate the color\n    vec3 color = vec3(0.5, 0.5, 0.5) * max(dot(normal, light), 0.0);\n    // set the color\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec2 t = castRay(ro, rd);\n    vec3 col = vec3(0.0);\n    if (t.x > 0.0) {\n        vec3 pos = ro + t.x * rd;\n        vec3 nor = calcNormal(pos);\n        vec3 ref = reflect(rd, nor);\n        col = calcColor(pos, nor);\n        col = mix(col, vec3(0.8, 0.9, 1.0), 1.0-exp(-0.0001*t.x*t.x*t.x));\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 ro = vec3(0.0, 0.0, 2.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, -1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 color = texture(texture_diffuse1, p.xz).rgb;\n    //normal map\n    vec3 normal = texture(texture_normal1, p.xz).rgb;\n    //normal = normal * 2.0 - 1.0;\n    normal = normalize(normal * 2.0 - 1.0);\n    return normal;\n}\n\nvoid main()\n{\n    //vec3 normal = normalize(fs_in.Normal);\n    vec3 normal = estimateNormal(fs_in.FragPos);\n    vec3 viewDir = normalize(viewPos - fs_in.FragPos);\n    vec3 reflectDir = reflect(-viewDir, normal);\n    vec3 specular = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 ambient = vec3(0.0);\n    vec3 specularColor = vec3(0.0);\n    vec3 diffuseColor = vec3(0.0);\n    vec3 ambientColor = vec3(0.0);\n    vec3 color = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 halfwayDir = vec3(0.0);\n    float specularStrength = 0.0;\n    float shininess = 0.0;\n    float diffuseStrength = 0.0;\n    float ambientStrength = 0.0;\n    float attenuation = 0.0;\n    float distance = 0.0;\n    float specularIntensity = 0.0;\n    float diffuseIntensity = 0.0;\n    float ambientIntensity = 0.0;\n    float specularFactor = 0.0;\n    float diffuseFactor = 0.0;\n    float ambientFactor = 0.0;\n    float specularFactor2 = 0.0;\n    float diffuseFactor2 = 0.0;\n    float ambientFactor2 = 0.0;\n    float spec", "\n    return fract( sin( dot( q.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n}\n\nfloat", "els\n\tvec2 texel = vec2( 16.0 / 1024.0, 16.0 / 1024.0 );\n\tvec2 uv = vec2( mod( float( i ), 16.0 ) * texel.x, floor( float( i ) / 16.0 ) * texel.y );\n\tvec2 uv2 = uv + texel;\n\tvec2 uv3 = uv + texel * 2.0;\n\tvec2 uv4 = uv + texel * 3.0;\n\tvec2 uv5 = uv + texel * 4.0;\n\tvec2 uv6 = uv + texel * 5.0;\n\tvec2 uv7 = uv + texel * 6.0;\n\tvec2 uv8 = uv + texel * 7.0;\n\tvec2 uv9 = uv + texel * 8.0;\n\tvec2 uv10 = uv + texel * 9.0;\n\tvec2 uv11 = uv + texel * 10.0;\n\tvec2 uv12 = uv + texel * 11.0;\n\tvec2 uv13 = uv + texel * 12.0;\n\tvec2 uv14 = uv + texel * 13.0;\n\tvec2 uv15 = uv + texel * 14.0;\n\tvec2 uv16 = uv + texel * 15.0;\n\n\tvec4 texel0 = texture2D( texture, uv );\n\tvec4 texel1 = texture2D( texture, uv2 );\n\tvec4 texel2 = texture2D( texture, uv3 );\n\tvec4 texel3 = texture2D( texture, uv4 );\n\tvec4 texel4 = texture2D( texture, uv5 );\n\tvec4 texel5 = texture2D( texture, uv6", "\n    p.x = abs(p.x);\n\n    // scale\n    p *= ab;\n\n    // ellipse\n    vec2 d = p - ab;\n    float a = dot(d,d);\n    float b = a/dot(ab,ab);\n    float c = sqrt(a*b);\n    float e = sqrt(b);\n    float f = c/e;\n    float g = atan(d.y,d.x);\n    float h = (135.0/180.0)*3.1415926535897932384626433832795;\n    float i = abs(g-h)/3.1415926535897932384626433832795;\n    float j = clamp(i,0.0,1.0);\n    float k = c*(1.0+cos(j*3.1415926535897932384626433832795-h));\n    float l = sqrt(a)*k;\n    float m = dot(d,d)*(1.0/dot(ab,ab));\n    float n = sqrt(m);\n    float o = n*(0.5+0.5*cos(g/2.0));\n    float q = l-o;\n    float r = sqrt(dot(p,p));\n    float s = q/r;\n    float t = atan(p.y,p.x);\n    float u = mod(t+3.1415926535897932384626433832795,6.283185307179586476925286766559)/3.1415926535897932384626433832795;\n    float v = clamp(", "\n    vec4 p4 = fract(vec4(p) *.1031);\n    p4 += dot(p4, p4.wzxy + 33.33);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    color = vec3(uv,0.5+0.5*sin(iTime));\n\n    // Output to screen\n    fragColor = vec4(color,1.0);\n}", "\n    float t = 0.0;\n    float tmin = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float cx = cos(rotation.x);\n    float sx = sin(rotation.x);\n    float cy = cos(rotation.y);\n    float sy = sin(rotation.y);\n    float cz = cos(rotation.z);\n    float sz = sin(rotation.z);\n\n    // Calculate the Rotation Matrix\n    return mat3(\n        cy*cz, cy*sz*sx - cx*sz, cy*sz*cx + sx*sz,\n        sx*sy*cz + cx*sz, cx*cz - sx*sy*sz, -cx*sy*sz + sx*cz,\n        -cx*sy*cz + sx*sz, cx*sz + sx*sy*cz, cx*cy\n    );\n}\n\nvec", "\n    rayori = rayori - camera;\n    // Normalize the Ray\n    raydir = normalize(raydir);\n    // Set the initial distance to 0\n    float dist = 0.0;\n    // Set the initial color to 0\n    vec3 color = vec3(0.0);\n    // Set the initial normal to 0\n    vec3 normal = vec3(0.0);\n    // Set the initial hit to false\n    bool hit = false;\n    // Set the initial hit distance to 0\n    float hitdist = 0.0;\n    // Set the initial hit normal to 0\n    vec3 hitnormal = vec3(0.0);\n    // Set the initial hit color to 0\n    vec3 hitcolor = vec3(0.0);\n    // Set the initial hit material to 0\n    vec3 hitmaterial = vec3(0.0);\n    // Set the initial hit texture to 0\n    vec3 hittexture = vec3(0.0);\n    // Set the initial hit texture color to 0\n    vec3 hittexturecolor = vec3(0.0);\n    // Set the initial hit texture normal to 0\n    vec3 hittexturenormal = vec3(0.0);\n    // Set the initial hit texture material to 0\n    vec3 hittexturematerial = vec3(0.0);\n    // Set the initial hit texture texture to 0\n    vec3 hittexturetexture = vec3(0.0);\n    // Set the initial hit texture texture color to 0\n    vec3 hittexturetexturecolor = vec3(0.0);\n    // Set the initial hit texture texture normal to 0\n    vec3 hittexturetexturenormal = vec3(0.0);\n    // Set the initial hit texture texture material to 0\n    vec3 hittexturetexturematerial = vec3(0.0);\n    // Set the initial hit texture texture texture to 0\n    vec3 hittexturetexturetexture = vec3(0.0);\n    // Set the initial hit texture texture texture color to 0\n", "\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Direction of the Ray\n    vec3 rayDir = normalize(vec3(uv, 1.0));\n    // Calculate the Position of the Ray\n    vec3", "\n    vec3 pos = rayori;\n    float dist = 0.0;\n    float totaldist = 0.0;\n    float t = 0.0;\n    float maxdist = 100.0;\n    float eps = 0.001;\n    float maxsteps = 100.0;\n    float steps = 0.0;\n    float hit = 0.0;\n    float id = 0.0;\n    float d = 0.0;\n    float s = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n    float a = 0.0;\n    float f = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float c = 0.0;\n    float dd = 0.0;\n    float ee = 0.0;\n    float ff = 0.0;\n    float gg = 0.0;\n    float hh = 0.0;\n    float ii = 0.0;\n    float jj = 0.0;\n    float kk = 0.0;\n    float ll = 0.0;\n    float mm = 0.0;\n    float nn = 0.0;\n    float oo = 0.0;\n    float pp = 0.0;\n    float qq = 0.0;\n    float rr = 0.0;\n    float ss = 0.0;\n    float tt = 0.0;\n    float uu = 0.0;\n    float vv = 0.0;\n    float ww = 0.0;\n    float xx = 0.0;\n    float yy = 0.0;\n    float zz = 0.0;\n    float aa = 0.", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv.x *= iResolution.x / iResolution.y;\n    uv = uv * 2.0 - 1.0;\n    uv.x *= iResolution.x / iResolution.y;\n    float seed = uv.x + uv.y * 1000.0;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + iTime;\n    seed = seed * 1000.0;\n    seed = floor(seed);\n    seed = seed / 1000.0;\n    seed = seed * 1000.0;\n    seed = seed + i", "\n    float borderFade = min(coord.x, 1.0 - coord.x);\n    borderFade = min(borderFade, min(coord.y, 1.0 - coord.y));\n\n    // Calculate ray position\n    float rayPos = travelRate * frequency * iTime;\n    rayPos = fract(rayPos);\n\n    // Calculate ray strength\n    float rayStrength = maxStrength * (1.0 - borderFade);\n    rayStrength *= smoothstep(rayPos - 0.01, rayPos, coord.x);\n    rayStrength *= smoothstep(rayPos, rayPos + 0.01, coord.x);\n\n    return rayStrength;\n}\n\nvec", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n//this is a 4-edge version of edge2\n//e1 is the edge that is closest to the point\n//e2 is the edge that is furthest from the point\n//e3 is the edge that is closest to the point, but not e1\n//e4 is the edge that is furthest from the point, but not e2\n//p is the point\n//d is the direction of the ray\n//e1, e2, e3, e4 are the edges\n//this is a 4-edge version of edge2\n//e1 is the edge that is closest to the point\n//e2 is the edge that is furthest from the point\n//e3 is the edge that is closest to the point, but not e1\n//e4 is the edge that is furthest from the point, but not e2\n//p is the point\n//d is the direction of the ray\n//e1, e2, e3, e4 are the edges\n//this is a 4-edge version of edge2\n//e1 is the edge that is closest to the point\n//e2 is the edge that is furthest from the point\n//e3 is the edge that is closest to the point, but not e1\n//e4 is the edge that is furthest from the point, but not e2\n//p is the point\n//d is the direction of the ray\n//e1, e2, e3, e4 are the edges\n//this is a 4-edge version of edge2\n//e1 is the edge that is closest to the point\n//e2 is the edge that is furthest from the point\n//e3 is the edge that is closest to the point, but not e1\n//e4 is the edge that is furthest from the point, but not e2\n//p is the point\n//d is the direction of the ray\n//e1, e2, e3, e4 are the edges\n//this is a 4-edge version of edge2\n//e1 is the edge that is closest to the point\n//e2 is the edge that is furthest from the point\n//e3 is the edge that is closest to the point, but not e1\n//e4 is the edge that is furthest from", "\n    //return color / (color + vec3(1.0));\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 - exp(-color * 1.0);\n    //return 1.0 -", "\n    vec2 pa = p-a;\n    vec2 ba = b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n\n    // compute point and normal\n    vec2 c = a + h*ba;\n    vec2 n = vec2(ba.y,-ba.x);\n\n    // compute distance\n    return length(pa-h*ba)*sign(pa.x*ba.y-pa.y*ba.x-w1*n.x*pa.x+w1*n.y*pa.y);\n}\n\nfloat", "\n    uv = (uv - 0.5) * mat2( 1.0, 0.0, -0.707, 0.707 );\n\n    //get the distance to the center\n    float d = length( uv );\n\n    //get the angle of the uv\n    float a = atan( uv.y, uv.x );\n\n    //get the distance to the edge\n    float e = abs( d - 0.5 );\n\n    //get the distance to the edge\n    float f = abs( d - 0.5 ) * 2.0;\n\n    //get the distance to the edge\n    float g = abs( d - 0.5 ) * 3.0;\n\n    //get the distance to the edge\n    float h = abs( d - 0.5 ) * 4.0;\n\n    //get the distance to the edge\n    float i = abs( d - 0.5 ) * 5.0;\n\n    //get the distance to the edge\n    float j = abs( d - 0.5 ) * 6.0;\n\n    //get the distance to the edge\n    float k = abs( d - 0.5 ) * 7.0;\n\n    //get the distance to the edge\n    float l = abs( d - 0.5 ) * 8.0;\n\n    //get the distance to the edge\n    float m = abs( d - 0.5 ) * 9.0;\n\n    //get the distance to the edge\n    float n = abs( d - 0.5 ) * 10.0;\n\n    //get the distance to the edge\n    float o = abs( d - 0.5 ) * 11.0;\n\n    //get the distance to the edge\n    float p = abs( d - 0.5 ) * 12.0;\n\n    //get the distance to the edge\n    float q = abs( d - 0.5 ) * 13.0;\n\n    //get the distance to the edge\n    float r = abs( d - 0.5 ) * 14.0;\n\n   ", "\n    vec3 colA = vec3(0.0,0.0,0.0);\n    vec3 colB = vec3(1.0,1.0,1.0);\n    return mix( colA, colB, falloff ) + rnd;\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime;\n    float tt = t * 0.1;\n\n    vec3 col = vec3(0.0);\n\n    float falloff = 0.0;\n    vec3 rnd = vec3(0.0);\n\n    for( int i=0; i<10; i++ )\n    {\n        float f = float(i);\n        float tt2 = tt + f * 0.1;\n        float a = f * 0.1;\n        float s = sin( tt2 ) * 0.5 + 0.5;\n        float c = cos( tt2 ) * 0.5 + 0.5;\n        vec2 r = vec2( c, s );\n        vec2 q = p + r * a;\n        float d = length( q );\n        falloff += ( 1.0 - d ) * ( 1.0 - d );\n        rnd += pulse( d, vec3(0.0) );\n    }\n\n    col = pulse( falloff, rnd );\n\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    vec2 uv = fragCoord/iResolution.x; //x-fov\n\n    // Output to screen\n    fragColor = texture(iChannel0, uv);\n}", "\n   vec3 q = vec3(vec2(p), p*p);\n   q = mod(q, 289.0);\n   return fract(q*vec3(41.0, 289.0, 151.0));\n}\n\nvec", "\n  //  return x - x*x*x/3 + x*x*x*x*x/5;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x*x/11;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x*x/11 + x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x/13;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x*x/11 + x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x/13 - x*x*x*x*x*x*x*x*x*x*x*x*x", "\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(col, vec3(0.4545));\n  //  col = pow(", "\n    vec3 d = abs(p) - 1.0;\n    float insideDistance = min(max(d.x, max(d.y, d.z)), 0.0);\n    float outsideDistance = length(max(d, 0.0));\n    return insideDistance + outsideDistance;\n}\n\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"], "input_docstring": ["\n\treturn cos( a );\n}\n\nfloat", "\n    vec3 rotated = Rotate(p, rotDir);\n\n    // Scale to the size of the object\n    vec3 scaled = rotated * scale;\n\n    // Translate to the center of the object\n    vec3 translated = scaled + center;\n\n    // Get the distance to the object\n    float dist = length(translated);\n\n    return dist;\n}\n\nvoid main()\n{\n    // Get the position of the pixel\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    // Get the position of the pixel in world space\n    vec3 p = vec3(uv * 2.0 - 1.0, 1.0);\n\n    // Get the distance to the object\n    float dist = DistanceToObject(p);\n\n    // Get the color of the object\n    vec3 color = GetColor(dist);\n\n    // Set the color of the pixel\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n\tfloat glow = max(0.0, glowCounter - 0.001);\n\n\t// Calculate the distance to the voxel\n\tfloat d = length(p - voxelPos);\n\n\t// Calculate the distance to the voxel's center\n\tfloat dc = length(p - voxelCenter);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de = length(p - voxelEdge);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc2 = length(p - voxelCorner);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de2 = length(p - voxelEdge2);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc3 = length(p - voxelCorner2);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de3 = length(p - voxelEdge3);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc4 = length(p - voxelCorner3);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de4 = length(p - voxelEdge4);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc5 = length(p - voxelCorner4);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de5 = length(p - voxelEdge5);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc6 = length(p - voxelCorner5);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de6 = length(p - voxelEdge6);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc7 = length(p - voxelCorner6);\n\n\t// Calculate the distance to the voxel's edge\n\tfloat de7 = length(p - voxelEdge7);\n\n\t// Calculate the distance to the voxel's corner\n\tfloat dc8 = length", "\n\tvec3 glow = vec3(0.0);\n\tfloat glowIntensity = 0.0;\n\n\t// Update the distance to the scene\n\tfloat dist = 1000000.0;\n\n\t// Update the position of the point\n\tP = p;\n\n\t// Update the distance to the scene\n\tdist = length(p);\n\n\t// Update the glow intensity\n\tglowIntensity = (1.0 - dist) * 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", " position in the screen\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\n\t// Get the fragment position in the world\n\tvec3 pos = vec3(p * 2.0 - 1.0, 1.0);\n\n\t// Get the ray direction\n\tvec3 rayDir = normalize(vec3(p * 2.0 - 1.0, 1.0));\n\n\t// Get the ray origin\n\tvec3 rayOrigin = vec3(0.0);\n\n\t// Get the ray color\n\tvec3 rayColor = vec3(0.0);\n\n\t// Get the ray depth\n\tfloat rayDepth = 0.0;\n\n\t// Get the ray distance\n\tfloat rayDistance = 0.0;\n\n\t// Get the ray normal\n\tvec3 rayNormal = vec3(0.0);\n\n\t// Get the ray material\n\tfloat rayMaterial = 0.0;\n\n\t// Get the ray material color\n\tvec3 rayMaterialColor = vec3(0.0);\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal2 = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth2 = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance2 = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal3 = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth3 = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance3 = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal4 = vec3(0.0);\n\n\t// Get the ray material depth\n\tfloat rayMaterialDepth4 = 0.0;\n\n\t// Get the ray material distance\n\tfloat rayMaterialDistance4 = 0.0;\n\n\t// Get the ray material normal\n\tvec3 rayMaterialNormal5 = ve", "\n\tstatic const float c[4] = { 0.0f, 0.0f, 0.0f, 0.0f };\n\treturn vec4(c[0], c[1], c[2], c[3]);\n}\n\n//src/main.cpp\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n#include <cassert>\n#include <cctype>\n#include <cstdint>\n#include <cstdarg>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstddef>\n#include <cstdint>\n#include <cstd", "\n\tvec4 color = texture(color_map, vec2(d, 0.5));\n\t\n\t// apply gamma correction\n\tcolor.rgb = pow(color.rgb, vec3(1.0/2.2));\n\t\n\treturn color;\n}\n\nvoid main()\n{\n\tfloat d = texture(depth_map, v_texcoord).r;\n\t\n\tvec4 color = shade(d);\n\t\n\tgl_FragColor = color;\n}\n", " and forth\n    float fade = clamp(0.5 - dot(rayDir, sunDir), 0.0, 1.0);\n    return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), fade);\n}\n\nvec", "\n    float t = ( coords.x - 2.0 ) / 2.0;\n    float a = sin( t * 3.1415926535897932384626433832795 );\n    return a;\n}\n\nvoid main()\n{\n    vec2 coords = ( gl_FragCoord.xy / resolution.xy ) * 2.0 - 1.0;\n    float d = distance( coords, vec2( 0.0 ) );\n    float a = atan( coords.y, coords.x );\n    float r = ( 1.0 - d ) * 0.5;\n    float h = ( 1.0 - d ) * 0.5;\n    float s = ( 1.0 - d ) * 0.5;\n    vec3 color = vec3( 0.0 );\n    color += vec3( 1.0, 0.0, 0.0 );\n    color += vec3( 0.0, 1.0, 0.0 );\n    color += vec3( 0.0, 0.0, 1.0 );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), h );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), s );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), r );\n    color *= mix( vec3( 1.0 ), vec3( 0.0 ), a );\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    float t = (coords.x - 2.0) / 4.0;\n    float a = sin(t) * 4.0 + 2.0;\n    float b = cos(t) * 4.0 + 2.0;\n    return sin(a) * sin(b);\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    float d = F(coords);\n    float a = atan(coords.y, coords.x);\n    float r = length(coords);\n    float t = (a + PI) / (2.0 * PI);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n    float z = d;\n    vec3 n = vec3(x, y, z);\n    vec3 l = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 v = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 h = normalize(v + l);\n    vec3 color = vec3(0.0);\n    color += vec3(0.5) * pow(max(0.0, dot(n, l)), 10.0);\n    color += vec3(0.5) * pow(max(0.0, dot(n, h)), 10.0);\n    color += vec3(0.5) * pow(max(0.0, dot(n, v)), 10.0);\n    color = pow(color, vec3(1.0 / 2.2));\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float t = ( coords.x - 1.0 ) / 3.0;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n", "\n    float speed = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float n = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100.0);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        n += a;\n        a *= 0.5;\n        p = rot * p * 2.0 + shift;\n        p = mod(p, 289.0) - 155.0;\n    }\n    return fract(sin(n) * 43758.5453);\n}\n\nfloat", "\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // p = p*p*(3.0-2.0*p.z);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // p = p*p*(3.0-2.0*p.z);\n    // p = p*p*(3.0-2.0*p.w);\n    // return p.yx;\n\n    // This is the original way, but it's not as nice as the other two.\n    // p = p*2.0-1.0;\n    // p = p*p*(3.0-2.0*p.x);\n    // p = p*p*(3.0-2.0*p.y);\n    // p = p*p*(3.0-2.0*p.z);\n    // p = p*p*(3.0-2.0*p.w);\n    // p = p*p*(3.0-2.0*p.", "\n    // This is a simplex grid implementation that is based on the\n    // work of John H. Curtis and John A. Henstridge.\n    //\n    // The grid is a 2D array of 3D vectors.  The grid is a 2D array\n    // of 3D vectors.  The grid is a 2D array of 3D vectors.  The\n    // grid is a 2D array of 3D vectors.  The grid is a 2D array of\n    // 3D vectors.  The grid is a 2D array of 3D vectors.  The grid\n    // is a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors.  The grid is a 2D array of 3D\n    // vectors.  The grid is a 2D array of 3D vectors.  The grid is\n    // a 2D array of 3D vectors", "\n    vec2 cell = floor(p);\n    vec2 cell_size = vec2(1.0);\n    vec2 cell_offset = vec2(0.5);\n\n    // Compute the distance from the cell center to the point.\n    vec2 dist = abs(p - cell + (0.5 - cell_offset)) - cell_size * 0.5;\n\n    // Compute the distance from the point to the closest edge of the cell.\n    vec2 closest_edge = min(dist, vec2(0.0));\n\n    // Compute the distance from the point to the closest corner of the cell.\n    vec2 closest_corner = min(closest_edge, min(dist.yx, dist.xy));\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist = min(closest_edge.x, closest_edge.y);\n\n    // Compute the distance from the point to the closest corner of the cell.\n    float closest_corner_dist = min(closest_corner.x, closest_corner.y);\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist_sq = closest_edge_dist * closest_edge_dist;\n\n    // Compute the distance from the point to the closest corner of the cell.\n    float closest_corner_dist_sq = closest_corner_dist * closest_corner_dist;\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist_sq_sq = closest_edge_dist_sq * closest_edge_dist_sq;\n\n    // Compute the distance from the point to the closest corner of the cell.\n    float closest_corner_dist_sq_sq = closest_corner_dist_sq * closest_corner_dist_sq;\n\n    // Compute the distance from the point to the closest edge of the cell.\n    float closest_edge_dist_cube = closest_edge_dist_sq_sq * closest_edge_dist;\n\n    // Compute the distance from the", "\n  // 0.0 - 1.0\n  // 0.0 - 255.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.", "\n    vec2 res;\n\n    // map the point to the unit cube\n    res.x = (p.x + 1.0) * 0.5;\n    res.y = (p.y + 1.0) * 0.5;\n\n    // map the point to the unit sphere\n    res.x = res.x * 2.0 - 1.0;\n    res.y = res.y * 2.0 - 1.0;\n\n    // map the point to the unit disk\n    if (res.x * res.x + res.y * res.y > 1.0)\n        discard;\n\n    // map the point to the unit disk\n    res.x = res.x * sqrt(1.0 - res.y * res.y);\n    res.y = res.y * sqrt(1.0 - res.x * res.x);\n\n    // map the point to the unit disk\n    res.x *= resolution;\n    res.y *= resolution;\n\n    return res;\n}\n\n// compute the ray direction\nvec", "\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 10000.0;\n\tfloat tmin2 = 0.0;\n\tfloat tmax2 = 10000.0;\n\tfloat tmin3 = 0.0;\n\tfloat tmax3 = 10000.0;\n\tfloat tmin4 = 0.0;\n\tfloat tmax4 = 10000.0;\n\tfloat tmin5 = 0.0;\n\tfloat tmax5 = 10000.0;\n\tfloat tmin6 = 0.0;\n\tfloat tmax6 = 10000.0;\n\tfloat tmin7 = 0.0;\n\tfloat tmax7 = 10000.0;\n\tfloat tmin8 = 0.0;\n\tfloat tmax8 = 10000.0;\n\tfloat tmin9 = 0.0;\n\tfloat tmax9 = 10000.0;\n\tfloat tmin10 = 0.0;\n\tfloat tmax10 = 10000.0;\n\tfloat tmin11 = 0.0;\n\tfloat tmax11 = 10000.0;\n\tfloat tmin12 = 0.0;\n\tfloat tmax12 = 10000.0;\n\tfloat tmin13 = 0.0;\n\tfloat tmax13 = 10000.0;\n\tfloat tmin14 = 0.0;\n\tfloat tmax14 = 10000.0;\n\tfloat tmin15 = 0.0;\n\tfloat tmax15 = 10000.0;\n\tfloat tmin16 = 0.0;\n\tfloat tmax16 = 10000.0;\n\tfloat tmin17 = 0.0;\n\tfloat tmax17 = 10000.0;\n\tfloat tmin18 = 0.0;\n\tfloat tmax18 = 10000.0;\n\tfloat tmin19 = 0.0;\n\tfloat tmax19", "\n    vec4 res;\n\n    // map the point to the unit cube\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit sphere\n    p.y = abs(p.y);\n\n    // map the point to the unit disk\n    if (p.x * p.x + p.y * p.y > 1.0)\n        return res;\n\n    // map the point to the unit square\n    p.x = abs(p.x);\n\n    // map the point to the unit rectangle\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y > 1.0)\n        return res;\n\n    // map the point to the unit circle\n    if (p.x * p.x + p.y * p.y < 1.0)\n        return res;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit circle\n    if (p.x * p.x + p.y * p.y < 1.0)\n        return res;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p", "\n    vec3 p = ro;\n    vec3 d = rd;\n    vec3 dp;\n    vec3 dp2;\n    vec3 dp3;\n    vec3 dp4;\n    vec3 dp5;\n    vec3 dp6;\n    vec3 dp7;\n    vec3 dp8;\n    vec3 dp9;\n    vec3 dp10;\n    vec3 dp11;\n    vec3 dp12;\n    vec3 dp13;\n    vec3 dp14;\n    vec3 dp15;\n    vec3 dp16;\n    vec3 dp17;\n    vec3 dp18;\n    vec3 dp19;\n    vec3 dp20;\n    vec3 dp21;\n    vec3 dp22;\n    vec3 dp23;\n    vec3 dp24;\n    vec3 dp25;\n    vec3 dp26;\n    vec3 dp27;\n    vec3 dp28;\n    vec3 dp29;\n    vec3 dp30;\n    vec3 dp31;\n    vec3 dp32;\n    vec3 dp33;\n    vec3 dp34;\n    vec3 dp35;\n    vec3 dp36;\n    vec3 dp37;\n    vec3 dp38;\n    vec3 dp39;\n    vec3 dp40;\n    vec3 dp41;\n    vec3 dp42;\n    vec3 dp43;\n    vec3 dp44;\n    vec3 dp45;\n    vec3 dp46;\n    vec3 dp47;\n    vec3 dp48;\n    vec3 dp49;\n    vec3 dp50;\n    ve", "\n    vec3 wp = (modelMatrix * vec4(p, 1.0)).xyz;\n    vec3 wo = (modelMatrix * vec4(oN, 0.0)).xyz;\n    vec3 wd = wp - wo;\n\n    // world pos diff\n    vec3 wp2 = (modelMatrix * vec4(p + wd, 1.0)).xyz;\n    vec3 wo2 = (modelMatrix * vec4(oN + wd, 0.0)).xyz;\n    vec3 wd2 = wp2 - wo2;\n\n    // world pos diff\n    vec3 wp3 = (modelMatrix * vec4(p + wd2, 1.0)).xyz;\n    vec3 wo3 = (modelMatrix * vec4(oN + wd2, 0.0)).xyz;\n    vec3 wd3 = wp3 - wo3;\n\n    // world pos diff\n    vec3 wp4 = (modelMatrix * vec4(p + wd3, 1.0)).xyz;\n    vec3 wo4 = (modelMatrix * vec4(oN + wd3, 0.0)).xyz;\n    vec3 wd4 = wp4 - wo4;\n\n    // world pos diff\n    vec3 wp5 = (modelMatrix * vec4(p + wd4, 1.0)).xyz;\n    vec3 wo5 = (modelMatrix * vec4(oN + wd4, 0.0)).xyz;\n    vec3 wd5 = wp5 - wo5;\n\n    // world pos diff\n    vec3 wp6 = (modelMatrix * vec4(p + wd5, 1.0)).xyz;\n    vec3 wo6 = (modelMatrix * vec4(oN + wd5, 0.0)).xyz;\n    vec3 wd6 = wp6 - wo6;\n\n    // world pos diff\n    vec3", "\n    float n = 0.0;\n    n += noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 p = vec3(uv, 0.0);\n    vec3 col = vec3(0.0);\n    \n    // The camera\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 ta = vec3(0.0, 0.0, -1.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    // The ray\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    // The raymarching\n    float t = 0.0;\n    float tmax = 100.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = noise3D(pos);\n        t += d;\n        if (t > tmax) break;\n    }\n    \n    // The color\n    col = vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 1.0) * (t / tmax);\n    col += vec3(1.0, 0", "\n\t//pR(rayDir.xz, sin(-t * 2.));\n\t//pR(rayDir.xy, sin(-t * 3.));\n\t//pR(rayDir.xz, sin(-t * 4.));\n\t//pR(rayDir.yz, sin(-t * 5.));\n\t//pR(rayDir.xy, sin(-t * 6.));\n\t//pR(rayDir.xz, sin(-t * 7.));\n\t//pR(rayDir.yz, sin(-t * 8.));\n\t//pR(rayDir.xy, sin(-t * 9.));\n\t//pR(rayDir.xz, sin(-t * 10.));\n\t//pR(rayDir.yz, sin(-t * 11.));\n\t//pR(rayDir.xy, sin(-t * 12.));\n\t//pR(rayDir.xz, sin(-t * 13.));\n\t//pR(rayDir.yz, sin(-t * 14.));\n\t//pR(rayDir.xy, sin(-t * 15.));\n\t//pR(rayDir.xz, sin(-t * 16.));\n\t//pR(rayDir.yz, sin(-t * 17.));\n\t//pR(rayDir.xy, sin(-t * 18.));\n\t//pR(rayDir.xz, sin(-t * 19.));\n\t//pR(rayDir.yz, sin(-t * 20.));\n\t//pR(rayDir.xy, sin(-t * 21.));\n\t//pR(rayDir.xz, sin(-t * 22.));\n\t//pR(rayDir.yz, sin(-t * 23.));\n\t//pR(rayDir.xy, sin(-t * 24.));\n\t//pR(rayDir.xz, sin(-t * 25.));\n\t//pR(rayDir.yz, sin(-t * 26.));\n\t//pR(rayDir.xy, sin(-t * 27.));\n\t//pR(rayDir.x", "\n    vec2 box = vec2(abs(A.x - B.x), abs(A.y - B.y));\n    // calculate the distance from the box center to the line\n    float line_dist = distance(coords, vec2(0.5 * (A.x + B.x), 0.5 * (A.y + B.y)));\n    // calculate the height of the line\n    float line_height = height * line_dist / box.x;\n    // calculate the y axis of the line\n    float line_y = coords.y - line_height;\n    // calculate the x axis of the line\n    float line_x = coords.x;\n    // calculate the distance from the line to the box center\n    float line_dist_to_box = distance(vec2(0.5 * (A.x + B.x), 0.5 * (A.y + B.y)), vec2(line_x, line_y));\n    // calculate the height of the line\n    float line_height_to_box = height * line_dist_to_box / box.x;\n    // calculate the y axis of the line\n    float line_y_to_box = line_y - line_height_to_box;\n    // calculate the x axis of the line\n    float line_x_to_box = line_x;\n    // calculate the distance from the line to the box center\n    float line_dist_to_box_2 = distance(vec2(0.5 * (A.x + B.x), 0.5 * (A.y + B.y)), vec2(line_x_to_box, line_y_to_box));\n    // calculate the height of the line\n    float line_height_to_box_2 = height * line_dist_to_box_2 / box.x;\n    // calculate the y axis of the line\n    float line_y_to_box_2 = line_y_to_box - line_height_to_box_2;\n    // calculate the x axis of the line\n    float line_x_to_box_2 = line_x_to_box;\n    //", "\n     float dot = dot(start, end);\n     // If the dot is 1, the vectors are the same.\n     if (dot > 0.9999)\n     {\n          return end;\n     }\n     // If the dot is -1, the vectors are opposite.\n     if (dot < -0.9999)\n     {\n          return -end;\n     }\n     // If the dot is 0, the vectors are parallel.\n     if (dot == 0)\n     {\n          return vec2(0, 0);\n     }\n     // Compute the angle between the vectors.\n     float angle = acos(dot);\n     // Compute the sin of the angle.\n     float sin = sin(angle);\n     // Compute the ratio of the sin of the angle.\n     float ratio = sin / sin(angle);\n     // Compute the cross product.\n     vec2 cross = cross(start, end);\n     // Compute the cross product.\n     vec2 result = cross * ratio;\n     // Compute the dot product.\n     float dot2 = dot(start, result);\n     // If the dot is 1, the vectors are the same.\n     if (dot2 > 0.9999)\n     {\n          return result;\n     }\n     // If the dot is -1, the vectors are opposite.\n     if (dot2 < -0.9999)\n     {\n          return -result;\n     }\n     // If the dot is 0, the vectors are parallel.\n     if (dot2 == 0)\n     {\n          return vec2(0, 0);\n     }\n     // Compute the angle between the vectors.\n     float angle2 = acos(dot2);\n     // Compute the sin of the angle.\n     float sin2 = sin(angle2);\n     // Compute the ratio of the sin of the angle.\n     float ratio2 = sin2 / sin(angle2);\n     // Compute the cross product.\n     vec2 cross2 = cross(start, result);\n     // Compute the cross product.\n     vec2 result2 = cross2 * ratio2;\n     // Compute the", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 1.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    vec3 rd = normalize( p.x*uu + p.y*vv + 1.6*ww );\n\n    // raymarch\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    for( int i=0; i<100; i++ )\n    {\n        vec3 pos = ro + t*rd;\n        float d = map( pos );\n        t += d;\n        if( t>tmax || d<tmin ) break;\n    }\n\n    // lighting\n    vec3 light = vec3(0.0,0.0,1.0);\n    vec3 n = normal( pos );\n    vec3 l = normalize( light - pos );\n    vec3 v = normalize( -pos );\n    float dif = max( dot( n, l ), 0.0 );\n    vec3 col = vec3( dif );\n\n    // tone mapping\n    col = pow( col, vec3( 1.0/2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0/2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0/2.2 ) );\n\n    //", "\n    //\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b", " and forth\n    float fade = (1.0 - abs(rayDir.y)) * 0.5;\n    return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), fade);\n}\n\nvec", "\n    // The cylinder is a circle with a radius of 1.\n    // The space is a box with a width of 2.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is subdivided into 1000 points.\n    // The space is centered at the origin.\n    // The space is", "^2\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.z + dir.z) / dir.z;\n\tnear = t;\n\tfar = t;\n\treturn true;\n}\n\nbool sphere(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// quadratic x^2 + y^2 + z^2 = 0.5^2 => (org.x + t*dir.x)^2 + (org.y + t*dir.y)^2 + (org.z + t*dir.z)^2 = 0.5^2\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.x + dir.x) / dir.x;\n\tnear = t;\n\tfar = t;\n\treturn true;\n}\n\nbool plane(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.x + dir.x) / dir.x;\n\tnear = t;\n\tfar = t;\n\treturn true;\n}\n\nbool triangle(vec3 org, vec3 dir, out float near, out float far)\n{\n\t// t = -(org.x + dir.x) / dir.x^2\n\t// t = -(org.y + dir.y) / dir.y^2\n\t// t = -(org.z + dir.z) / dir.z^2\n\tfloat t = -(org.x + dir.x) /", "\n    vec3 q = p - s.xyz;\n    vec3 qx = q.xzy;\n    vec3 qy = q.yzx;\n    vec3 qz = q.zxy;\n    vec3 qw = q.wxy;\n    vec3 qx2 = qx*2.0;\n    vec3 qy2 = qy*2.0;\n    vec3 qz2 = qz*2.0;\n    vec3 qw2 = qw*2.0;\n    vec3 qx3 = qx*3.0;\n    vec3 qy3 = qy*3.0;\n    vec3 qz3 = qz*3.0;\n    vec3 qw3 = qw*3.0;\n    vec3 qx4 = qx*4.0;\n    vec3 qy4 = qy*4.0;\n    vec3 qz4 = qz*4.0;\n    vec3 qw4 = qw*4.0;\n    vec3 qx5 = qx*5.0;\n    vec3 qy5 = qy*5.0;\n    vec3 qz5 = qz*5.0;\n    vec3 qw5 = qw*5.0;\n    vec3 qx6 = qx*6.0;\n    vec3 qy6 = qy*6.0;\n    vec3 qz6 = qz*6.0;\n    vec3 qw6 = qw*6.0;\n    vec3 qx7 = qx*7.0;\n    vec3 qy7 = qy*7.0;\n    vec3 qz7 = qz*7.0;\n    vec3 qw7 = qw*7.0;\n    vec3 qx8 = qx*8.0;\n    vec3 qy8 = qy*8.0;\n    vec3 qz8 = qz*8.0;\n    vec3 qw8 = qw*8", "\n    float n = 0.0;\n    n += noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 p = vec3(uv, 0.0);\n    vec3 col = vec3(0.0);\n    \n    // The camera\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 ta = vec3(0.0, 0.0, -1.0);\n    vec3 ww = normalize(ta - ro);\n    vec3 uu = normalize(cross(vec3(0.0, 1.0, 0.0), ww));\n    vec3 vv = normalize(cross(ww, uu));\n    \n    // The ray\n    vec3 rd = normalize(p.x * uu + p.y * vv + 2.0 * ww);\n    \n    // The raymarching\n    float t = 0.0;\n    float tmax = 100.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 pos = ro + t * rd;\n        float d = noise3D(pos);\n        t += d;\n        if (t > tmax) break;\n    }\n    \n    // The color\n    col = vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 1.0) * (t / tmax);\n    col += vec3(1.0, 0", "\n    float d = distance(p, vec2(0.5, 0.5));\n    \n    // The circle's radius.\n    float r = 0.2;\n    \n    // The circle's thickness.\n    float t = 0.01;\n    \n    // The circle's thickness, squared.\n    float t2 = t * t;\n    \n    // The circle's thickness, squared.\n    float d2 = d * d;\n    \n    // The circle's thickness, squared.\n    float r2 = r * r;\n    \n    // The circle's thickness, squared.\n    float d4 = d2 * d2;\n    \n    // The circle's thickness, squared.\n    float r4 = r2 * r2;\n    \n    // The circle's thickness, squared.\n    float d8 = d4 * d4;\n    \n    // The circle's thickness, squared.\n    float r8 = r4 * r4;\n    \n    // The circle's thickness, squared.\n    float d16 = d8 * d8;\n    \n    // The circle's thickness, squared.\n    float r16 = r8 * r8;\n    \n    // The circle's thickness, squared.\n    float d32 = d16 * d16;\n    \n    // The circle's thickness, squared.\n    float r32 = r16 * r16;\n    \n    // The circle's thickness, squared.\n    float d64 = d32 * d32;\n    \n    // The circle's thickness, squared.\n    float r64 = r32 * r32;\n    \n    // The circle's thickness, squared.\n    float d128 = d64 * d64;\n    \n    // The circle's thickness, squared.\n    float r128 = r64 * r64;\n    \n    // The circle's thickness, squared.\n    float d256 = d128 * d128;\n    \n    // The circle's thickness,", "\n    // fz - Change in \"f\" in in the Z-direction.\n    //\n    // bumpFactor - The amount of bump mapping to apply.\n    //\n    // sn - The normal of the surface at the point sp.\n    // snx - Change in \"sn\" in in the X-direction.\n    // sny - Change in \"sn\" in in the Y-direction.\n    // snz - Change in \"sn\" in in the Z-direction.\n    //\n    // sp - The point at which the bump mapping is being applied.\n    // spx - Change in \"sp\" in in the X-direction.\n    // spy - Change in \"sp\" in in the Y-direction.\n    // spz - Change in \"sp\" in in the Z-direction.\n    //\n    // bump - The bump mapping result.\n    //\n    // The following is the bump mapping formula.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpFactor * (snx * spx + sny * spy + snz * spz)\n    //\n    // The following is the bump mapping formula, with the bumpFactor applied.\n    //\n    // bump = f + bumpF", "\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2.0-1.0;\n    // return fract(sin(dot(p,vec2(12.9898,78.233)))*43758.5453);\n    \n    // This is the best method I've found.\n    // p = p*2", "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 reflect_dir = reflect(-light_dir, n);\n  vec3 ambient = vec3(0.1, 0.1, 0.1) * vec3(0.5, 0.5, 0.5);\n  vec3 diffuse = vec3(0.5, 0.5, 0.5) * vec3(0.5, 0.5, 0.5);\n  vec3 specular = vec3(0.5, 0.5, 0.5) * vec3(0.5, 0.5, 0.5);\n  float specular_strength = 0.5;\n  float specular_intensity = 0.5;\n  float diffuse_intensity = 0.5;\n  float attenuation = 1.0;\n  float distance = length(light - p);\n  float attenuation_factor = 1.0 / (attenuation * distance * distance);\n  float diffuse_factor = max(dot(light_dir, n), 0.0);\n  float specular_factor = pow(max(dot(view_dir, reflect_dir), 0.0), 32);\n  vec3 color = ambient * attenuation_factor;\n  color += diffuse * diffuse_factor * diffuse_intensity * attenuation_factor;\n  color += specular * specular_factor * specular_strength * specular_intensity * attenuation_factor;\n  return color;\n}\n\nvoid main()\n{\n  vec3 p = vec3(gl_FragCoord.x, gl_FragCoord.y, 0.0);\n  vec3 n = normal(p);\n  vec3 color = shade(p, n);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n    Ray ray = Ray(vec3(0.0), vec3(0.0, 0.0, 1.0));\n    ray.origin = vec3(0.0);\n    ray.direction = normalize(vec3(0.0, 0.0, 1.0));\n\n    //creats a sphere object\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n\n    //creats a material object\n    Material material = Material(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0);\n\n    //creats a light object\n    Light light = Light(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0);\n\n    //creats a camera object\n    Camera camera = Camera(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.", "\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(rd, vec3(0.0, 1.0, 0.0));\n    t = clamp(t, 0.0, 1.0);\n    sky = mix(sky, par, t);\n    return sky;\n}\n\nvec", "i\n    float k = 1.0;\n    float k2 = 1.0;\n    float k3 = 1.0;\n    float k4 = 1.0;\n    float k5 = 1.0;\n    float k6 = 1.0;\n    float k7 = 1.0;\n    float k8 = 1.0;\n    float k9 = 1.0;\n    float k10 = 1.0;\n    float k11 = 1.0;\n    float k12 = 1.0;\n    float k13 = 1.0;\n    float k14 = 1.0;\n    float k15 = 1.0;\n    float k16 = 1.0;\n    float k17 = 1.0;\n    float k18 = 1.0;\n    float k19 = 1.0;\n    float k20 = 1.0;\n    float k21 = 1.0;\n    float k22 = 1.0;\n    float k23 = 1.0;\n    float k24 = 1.0;\n    float k25 = 1.0;\n    float k26 = 1.0;\n    float k27 = 1.0;\n    float k28 = 1.0;\n    float k29 = 1.0;\n    float k30 = 1.0;\n    float k31 = 1.0;\n    float k32 = 1.0;\n    float k33 = 1.0;\n    float k34 = 1.0;\n    float k35 = 1.0;\n    float k36 = 1.0;\n    float k37 = 1.0;\n    float k38 = 1.0;\n    float k39 = 1.0;\n    float k40 = 1.0;\n    float k41 = 1.0;\n    float k42 = 1.0;\n    float k43 = 1.0;\n    float k44 = 1.0;\n    float k45 = 1.0;\n    float k46 = 1.0;\n    float k47 = 1.0;\n    float k", "\n    return length(p) - rad;\n}\n\nfloat", "\n    vec3 fp = floor(p);\n    vec3 cp = ceil(p);\n\n    // distance to the nearest point\n    vec3 d0 = p - fp;\n    vec3 d1 = cp - p;\n\n    // interpolate between the two points\n    return mix(mix(d0.x, d0.y, d0.z), mix(d1.x, d1.y, d1.z), smoothstep(0.0, 1.0, param.x));\n}\n\n// ------------------------------------------------------------\n// 2D Fractal Brownian Motion\n// ------------------------------------------------------------\n\nfloat", "\n    vec3 floor = floor(p);\n    vec3 ceiling = floor + vec3(1.0);\n\n    // get the distance to the floor and ceiling\n    vec3 dist_floor = p - floor;\n    vec3 dist_ceiling = ceiling - p;\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge = min(dist_floor, dist_ceiling);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner = min(dist_to_edge, min(dist_floor.yzx, dist_floor.zxy));\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_2 = min(dist_ceiling, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_2 = min(dist_to_edge_2, min(dist_ceiling.yzx, dist_ceiling.zxy));\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_3 = min(dist_to_corner_2, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_3 = min(dist_to_edge_3, dist_to_corner);\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_4 = min(dist_to_corner_3, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_4 = min(dist_to_edge_4, dist_to_corner);\n\n    // get the distance to the nearest edge\n    vec3 dist_to_edge_5 = min(dist_to_corner_4, dist_to_corner);\n\n    // get the distance to the nearest corner\n    vec3 dist_to_corner_5 = min(dist_to_edge_5, dist_to_corner);\n\n    // get the distance to the nearest edge\n    vec3 dist_to_", "\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(par, rd);\n    if (t > 0.0)\n    {\n        sky = par * t;\n    }\n    return sky;\n}\n\nvec", "\n    float k = 1.0;\n    float k2 = 1.0;\n    float k3 = 1.0;\n    float k4 = 1.0;\n    float k5 = 1.0;\n    float k6 = 1.0;\n    float k7 = 1.0;\n    float k8 = 1.0;\n    float k9 = 1.0;\n    float k10 = 1.0;\n    float k11 = 1.0;\n    float k12 = 1.0;\n    float k13 = 1.0;\n    float k14 = 1.0;\n    float k15 = 1.0;\n    float k16 = 1.0;\n    float k17 = 1.0;\n    float k18 = 1.0;\n    float k19 = 1.0;\n    float k20 = 1.0;\n    float k21 = 1.0;\n    float k22 = 1.0;\n    float k23 = 1.0;\n    float k24 = 1.0;\n    float k25 = 1.0;\n    float k26 = 1.0;\n    float k27 = 1.0;\n    float k28 = 1.0;\n    float k29 = 1.0;\n    float k30 = 1.0;\n    float k31 = 1.0;\n    float k32 = 1.0;\n    float k33 = 1.0;\n    float k34 = 1.0;\n    float k35 = 1.0;\n    float k36 = 1.0;\n    float k37 = 1.0;\n    float k38 = 1.0;\n    float k39 = 1.0;\n    float k40 = 1.0;\n    float k41 = 1.0;\n    float k42 = 1.0;\n    float k43 = 1.0;\n    float k44 = 1.0;\n    float k45 = 1.0;\n    float k46 = 1.0;\n    float k47 = 1.0;\n    float k4", "\n    float r = atan(p.y, p.x) + PI/2;\n    float a = atan(diamond.y, diamond.x);\n    float d = abs(r - a);\n    if (d > PI/2) d = PI - d;\n    return d;\n}\n\nfloat", "\n    // to avoid the need for a separate texture.\n    vec3 color = vec3(0.0);\n    color += texture(iChannel0, uv).rgb;\n    color += texture(iChannel1, uv).rgb;\n    color += texture(iChannel2, uv).rgb;\n    color += texture(iChannel3, uv).rgb;\n    color += texture(iChannel4, uv).rgb;\n    color += texture(iChannel5, uv).rgb;\n    color += texture(iChannel6, uv).rgb;\n    color += texture(iChannel7, uv).rgb;\n    color += texture(iChannel8, uv).rgb;\n    color += texture(iChannel9, uv).rgb;\n    color += texture(iChannel10, uv).rgb;\n    color += texture(iChannel11, uv).rgb;\n    color += texture(iChannel12, uv).rgb;\n    color += texture(iChannel13, uv).rgb;\n    color += texture(iChannel14, uv).rgb;\n    color += texture(iChannel15, uv).rgb;\n    color += texture(iChannel16, uv).rgb;\n    color += texture(iChannel17, uv).rgb;\n    color += texture(iChannel18, uv).rgb;\n    color += texture(iChannel19, uv).rgb;\n    color += texture(iChannel20, uv).rgb;\n    color += texture(iChannel21, uv).rgb;\n    color += texture(iChannel22, uv).rgb;\n    color += texture(iChannel23, uv).rgb;\n    color += texture(iChannel24, uv).rgb;\n    color += texture(iChannel25, uv).rgb;\n    color += texture(iChannel26, uv).rgb;\n    color += texture(iChannel27, uv).rgb;\n    color += texture(iChannel28, uv).rgb;\n   ", "\n\tfloat d = 1000000.0;\n\t\n\t//...add objects here...\n\t\n\treturn d;\n}\n\n// --------------------------------------------------------\n// \n// \tMain\n// \n// --------------------------------------------------------\n\nvoid main()\n{\n\tvec3 pos = vec3(0.0);\n\t\n\tfloat d = dist_field( pos );\n\t\n\tgl_FragColor = vec4( d );\n}\n", "\n\tvec3 light = vec3( 0.0 );\n\tvec3 diffuse = vec3( 0.0 );\n\tvec3 specular = vec3( 0.0 );\n\tvec3 ambient = vec3( 0.0 );\n\tvec3 halfV = normalize( eye + v );\n\tfloat shininess = 10.0;\n\tfloat attenuation = 1.0;\n\tfloat spotlight = 0.0;\n\tfloat spotlight_cutoff = 0.0;\n\tfloat spotlight_outercutoff = 0.0;\n\tfloat spotlight_constant = 0.0;\n\tfloat spotlight_linear = 0.0;\n\tfloat spotlight_quadratic = 0.0;\n\tfloat spotlight_cutoff_cos = 0.0;\n\tfloat spotlight_outercutoff_cos = 0.0;\n\tfloat spotlight_constant_cos = 0.0;\n\tfloat spotlight_linear_cos = 0.0;\n\tfloat spotlight_quadratic_cos = 0.0;\n\tfloat spotlight_cutoff_cos_cos = 0.0;\n\tfloat spotlight_outercutoff_cos_cos = 0.0;\n\tfloat spotlight_constant_cos_cos = 0.0;\n\tfloat spotlight_linear_cos_cos = 0.0;\n\tfloat spotlight_quadratic_cos_cos = 0.0;\n\tfloat spotlight_cutoff_cos_cos_cos = 0.0;\n\tfloat spotlight_outercutoff_cos_cos_cos = 0.0;\n\tfloat spotlight_constant_cos_cos_cos = 0.0;\n\tfloat spotlight_linear_cos_cos_cos = 0.0;\n\tfloat spotlight_quadratic_cos_cos_cos = 0.0;\n\tfloat spotlight_cutoff_cos_cos_cos_cos = 0.0;\n\tfloat spotlight_outercutoff_cos_cos_cos_cos = 0.0;\n\tfloat spotlight_constant_cos_cos_cos_cos = 0.0;\n\tfloat spotlight_linear_cos_cos_cos_cos = 0.0;", "\n    //return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n\n    // This is the original, but it's a bit slower.\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat", "\n    // 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float aa = a;\n    //Increase Activity Level For Better Performance\n    float aa2 = aa*aa;\n    //Increase Activity Level For Better Performance\n    float aa3 = aa*aa2;\n    //Increase Activity Level For Better Performance\n    float aa4 = aa*aa3;\n    //Increase Activity Level For Better Performance\n    float aa5 = aa*aa4;\n    //Increase Activity Level For Better Performance\n    float aa6 = aa*aa5;\n    //Increase Activity Level For Better Performance\n    float aa7 = aa*aa6;\n    //Increase Activity Level For Better Performance\n    float aa8 = aa*aa7;\n    //Increase Activity Level For Better Performance\n    float aa9 = aa*aa8;\n    //Increase Activity Level For Better Performance\n    float aa10 = aa*aa9;\n    //Increase Activity Level For Better Performance\n    float aa11 = aa*aa10;\n    //Increase Activity Level For Better Performance\n    float aa12 = aa*aa11;\n    //Increase Activity Level For Better Performance\n    float aa13 = aa*aa12;\n    //Increase Activity Level For Better Performance\n    float aa14 = aa*aa13;\n    //Increase Activity Level For Better Performance\n    float aa15 = aa*aa14;\n    //Increase Activity Level For Better Performance\n    float aa16 = aa*aa15;\n    //Increase Activity Level For Better Performance\n    float aa17 = aa*aa16;\n    //Increase Activity Level For Better Performance\n    float aa18 = aa*aa17;\n    //Increase Activity Level For Better Performance\n    float aa19 = aa*aa18;\n    //Increase Activity Level For Better Performance\n    float aa20 = aa*aa19;\n    //Increase Activity Level For Better Performance\n    float aa21 = aa*aa20;\n   ", "\n    float d = length(p.xz) - r;\n    // How far along the cylinder the point is, vertically\n    float a = p.y;\n    // If the point is inside the cylinder, return the distance to the\n    // nearest point on the cylinder. If the point is outside the cylinder,\n    // return the distance to the nearest point on the cylinder's top or\n    // bottom.\n    return max(d, -a + h);\n}\n\nfloat", "\n    float t = iGlobalTime * 0.001;\n    p.xz *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    p.y *= 0.5;\n\n    // SDF of the scene\n    float sdf = sceneSDF(p);\n\n    // Add some noise to the scene\n    sdf += noise(p * 10.0) * 0.01;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 100.0) * 0.001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 1000.0) * 0.0001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 10000.0) * 0.00001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 100000.0) * 0.000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 1000000.0) * 0.0000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 10000000.0) * 0.00000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 100000000.0) * 0.000000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 1000000000.0) * 0.0000000001;\n\n    // Add some more noise to the scene\n    sdf += noise(p * 10000000000.0) * 0.00000000001;\n\n    // Add some more noise to the scene\n    sdf += noise", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    mat3 m = mat3(s.x, u.x, f.x,\n                  s.y, u.y, f.y,\n                  s.z, u.z, f.z);\n\n    return m * mat3(1, 0, 0,\n                    0, 1, 0,\n                    -eye.x, -eye.y, -eye.z);\n}\n\nvoid main() {\n    vec3 eye = vec3(0.0, 0.0, 1.0);\n    vec3 center = vec3(0.0, 0.0, 0.0);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n\n    mat3 viewMatrix = viewMatrix(eye, center, up);\n\n    vec3 lightPos = vec3(0.0, 0.0, 1.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    vec3 color = vec3(0.0, 0.0, 0.0);\n\n    vec3 normal = normalize(inNormal);\n    vec3 lightDir = normalize(lightPos - inPosition);\n    vec3 viewDir = normalize(eye - inPosition);\n\n    float diffuse = max(dot(normal, lightDir), 0.0);\n    vec3 diffuseColor = diffuse * lightColor;\n\n    vec3 reflectDir = reflect(-lightDir, normal);\n    float specular = pow(max(dot(viewDir, reflectDir), 0.0), 32.0);\n    vec3 specularColor = specular * lightColor;\n\n    color = (diffuseColor + specularColor) * inColor;\n\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float t = (p.x+p.y+p.z)*0.0001;\n    return t;\n}\n\nvoid main() {\n    vec3 p = vec3(0.0);\n    p.x = tweaknoise(p);\n    p.y = tweaknoise(p);\n    p.z = tweaknoise(p);\n    gl_FragColor = vec4(p, 1.0);\n}\n", "\n    //I'm not sure if this is the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not sure if it's the best way to do it, but it works\n    //I'm not", "\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat", "\n    vec3 q = p;\n    q.xz *= mat2(1.0, 0.0, 0.0, 1.0);\n    q.y *= mat2(1.0, 0.0, 0.0, 1.0);\n    return q;\n}\n\n// This is the bump function that I'm using. It's a bit more complex than\n// the standard cylindrical mapping, but it's much more accurate.\nvec", "\n    // scr_pt is in screen space, and is in range [0,1]x[0,1].\n    // view_inv is the inverse of the view matrix.\n    // proj_inv is the inverse of the projection matrix.\n    // viewp_inv is the inverse of the view projection matrix.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera position to\n    // scr_pt.\n    //\n    // The ray is defined as the vector from the camera", "\n    float r = length(pA - pB);\n    r = min(r, rounded);\n\n    // Get the distance from the line to the point.\n    float d = distance(pA, uv);\n\n    // If the distance is less than the thickness, it's on the line.\n    if (d < thick.x) {\n        return 1.0;\n    }\n\n    // If the distance is greater than the thickness, it's not on the line.\n    if (d > thick.y) {\n        return 0.0;\n    }\n\n    // If the distance is between the thickness and the rounded radius, it's on the line.\n    if (d > thick.x && d < thick.y) {\n        return 1.0 - smoothstep(thick.x, thick.y, d);\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d < thick.y) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d < thick.x) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d < rounded) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d > thick.x) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d > thick.y) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it's not on the line.\n    if (d > rounded && d > rounded) {\n        return 0.0;\n    }\n\n    // If the distance is between the rounded radius and the thickness, it", "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 half_dir = normalize(light_dir + view_dir);\n  float diffuse = max(0.0, dot(n, light_dir));\n  float specular = pow(max(0.0, dot(n, half_dir)), 16.0);\n  return vec3(diffuse, diffuse, diffuse) * vec3(0.5, 0.5, 0.5) + vec3(0.5, 0.5, 0.5) * specular;\n}\n\nvoid main()\n{\n  vec3 n = normalize(normal);\n  vec3 p = vec3(position);\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  for (int i = 0; i < num_lights; i++)\n  {\n    color += Shade(p, n);\n  }\n  color = clamp(color, 0.0, 1.0);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n\tvec3 bmin = cen - rad;\n\tvec3 bmax = cen + rad;\n\tvec3 tmin = (bmin - ro) / rd;\n\tvec3 tmax = (bmax - ro) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(t1.x, max(t1.y, t1.z));\n\tfloat t3 = min(t2.x, min(t2.y, t2.z));\n\tfloat tN = max(t0, t3);\n\tfloat tF = min(t2.x, t2.y);\n\tfloat tB = max(t1.y, t1.z);\n\tfloat tL = min(t1.x, t1.z);\n\tfloat tH = max(t1.y, t1.z);\n\tfloat tS = max(t2.y, t2.z);\n\tfloat tFar = max(tF, tB);\n\tfloat tNear = min(tL, tS);\n\tfloat t = max(tN, tNear);\n\tif( t > tFar )\n\t\treturn vec2( -1.0 );\n\treturn vec2( t, tNear );\n}\n\n// ray-sphere intersection\nvec", "\n    float wave = (sin(x * a) + sin(x * b)) / 2;\n    return wave;\n}\n\nfloat", "\n\treturn vec2(a.x*b.x, a.y*b.y);\n}\n\nvec", "\n    vec3 ab = pb - pa;\n    vec3 abn = normalize( ab );\n    // center the cylinder\n    vec3 ca = pa + abn * 0.5;\n    // distance to cylinder\n    float d = length( rd - ca );\n    // cylinder radius\n    float r = length( pb - pa ) * 0.5;\n    // cylinder height\n    float h = length( pb - pa ) * 0.5;\n    // cylinder normal\n    vec3 n = normalize( pb - pa );\n    // cylinder normal\n    vec3 nn = normalize( n );\n    // cylinder normal\n    vec3 nn2 = normalize( nn );\n    // cylinder normal\n    vec3 nn3 = normalize( nn2 );\n    // cylinder normal\n    vec3 nn4 = normalize( nn3 );\n    // cylinder normal\n    vec3 nn5 = normalize( nn4 );\n    // cylinder normal\n    vec3 nn6 = normalize( nn5 );\n    // cylinder normal\n    vec3 nn7 = normalize( nn6 );\n    // cylinder normal\n    vec3 nn8 = normalize( nn7 );\n    // cylinder normal\n    vec3 nn9 = normalize( nn8 );\n    // cylinder normal\n    vec3 nn10 = normalize( nn9 );\n    // cylinder normal\n    vec3 nn11 = normalize( nn10 );\n    // cylinder normal\n    vec3 nn12 = normalize( nn11 );\n    // cylinder normal\n    vec3 nn13 = normalize( nn12 );\n    // cylinder normal\n    vec3 nn14 = normalize( nn13 );\n    // cylinder normal\n    vec3 nn15 = normalize( nn14 );\n    // cylinder normal\n    vec3 nn16 = normalize( nn15 );\n    // cylinder normal\n    vec3 nn17 = normalize( nn16 );\n    // cylinder normal\n    vec3 nn", "\n\n\tfloat d = length(P-U);\n\tfloat a = smoothstep(r,r+.001,d);\n\tO.xyz = mix(O.xyz,C,a);\n}\n\nvoid mainImage(out vec4 O, in vec2 U) {\n\n\tvec2 R = iResolution.xy, M = (2.*iMouse.xy-R)/R.y;\n\tvec2 P = (2.*U-R)/R.y;\n\t\n\tvec3 C = vec3(0.);\n\t\n\tsphere(O,U,P,0.001,vec3(1.,0.,0.));\n\tsphere(O,U,P,0.002,vec3(0.,1.,0.));\n\tsphere(O,U,P,0.003,vec3(0.,0.,1.));\n\tsphere(O,U,P,0.004,vec3(1.,1.,0.));\n\tsphere(O,U,P,0.005,vec3(1.,0.,1.));\n\tsphere(O,U,P,0.006,vec3(0.,1.,1.));\n\tsphere(O,U,P,0.007,vec3(1.,1.,1.));\n\t\n\tO.xyz = mix(O.xyz,C,smoothstep(.9,.0,length(P-M)));\n}\n\nvoid main() {\n\tmainImage(O,U);\n}\n", "\n    float d = dot(p, p) * 100.0;\n    p.x += sin(d) * 0.01;\n    p.y += cos(d) * 0.01;\n    p.z += sin(d) * 0.01;\n\n    // map the scene\n    p = p * 0.5 + 0.5;\n    p.x = p.x * 2.0 - 1.0;\n    p.y = p.y * 2.0 - 1.0;\n    p.z = p.z * 2.0 - 1.0;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.5;\n    p.y = p.y * 0.5 + 0.5;\n    p.z = p.z * 0.5 + 0.5;\n\n    // map the scene\n    p = p * 2.0 - 1.0;\n    p.x = p.x * 0.5 + 0.", "\n    vec2 grid = floor(p);\n    vec2 f = fract(p);\n\n    // We need to scale the grid coordinates by the scale factor.\n    vec2 scale = vec2(1.0, 1.0);\n    scale.x = (grid.x + f.x) * scale.x;\n    scale.y = (grid.y + f.y) * scale.y;\n\n    // We need to scale the layer ID by the scale factor.\n    float scaleID = layerID * scale.x;\n\n    // We need to scale the layer ID by the scale factor.\n    float scaleDec = layerID * scale.y;\n\n    return vec3(scale.x, scale.y, scaleDec);\n}\n\n// This function will be used to draw the grid.\nvec", "\n    float scale = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u0430\u043c\u044f\n    float distance = length(currentRayPosition.xz) - 1.0;\n\n    // \u0435\u0441\u043b\u0438 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u043f\u043b\u0430\u043c\u044f \u043c\u0435\u043d\u044c\u0448\u0435 0.001, \u0442\u043e \u043f\u043b\u0430\u043c\u044f \u0432\u044b\u043b\u0435\u0442\u0430\u0435\u0442\n    if (distance < 0.001)\n        return 1.0;\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u043f\u043b\u0430\u043c\u044f\n    float k = (1.0 - distance / 1.0) * (1.0 - distance / 1.0) * (1.0 - distance / 1.0) * (1.0 - distance / 1.0);\n\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    vec3 color = vec3(0.0);\n    color.r = k * 0.5;\n    color.g = k * 0.5;\n    color.b = k * 0.5;\n\n    // \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    return color;\n}\n\nvoid main()\n{\n    // \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u043a\u043e\u043e\u0440\u0434\u0438\u043d\u0430\u0442\u044b \u0442\u043e\u0447\u043a\u0438 \u0432 \u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u0441\u0442\u0432\u0435\n    vec3 currentRayPosition = vec3(gl_FragCoord.xy, 0.0);\n\n    // \u043f\u043e\u043b\u0443\u0447\u0430\u0435\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    vec3 color = flame(currentRayPosition);\n\n    // \u0432\u044b\u0432\u043e\u0434\u0438\u043c \u0446\u0432\u0435\u0442 \u043f\u043b\u0430\u043c\u044f\n    gl_FragColor = vec4(color, 1.0);\n}", "\n    float flameDistance = abs(scene(currentRayPosition));\n    // \u0435\u0441\u043b\u0438 \u043f\u043b\u0430\u043c\u044f \u043d\u0430\u0445\u043e\u0434\u0438\u0442\u0441\u044f \u0432 \u043f\u0440\u0435\u0434\u0435\u043b\u0430\u0445 \u0441\u0446\u0435\u043d\u044b, \u0442\u043e \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0446\u0432\u0435\u0442\n    if (flameDistance < 0.001)\n    {\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0446\u0432\u0435\u0442\n        vec3 color = vec3(0.0, 0.0, 0.0);\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0441\u0432\u0435\u0442\u043b\u0435\u043d\u0438\u044f\n        float lightIntensity = 0.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float shadowIntensity = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float specularIntensity = 0.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionIntensity = 0.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio2 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio3 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio4 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio5 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio6 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio7 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u043a\u043e\u044d\u0444\u0444\u0438\u0446\u0438\u0435\u043d\u0442 \u0434\u043b\u044f \u0442\u0435\u043d\u0438\n        float refractionRatio8 = 1.0;\n        // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c", "\n    float s = sm;\n    \n    // The fractal function.\n    float f = fract(x);\n    \n    // The fractal function.\n    float f2 = f * f;\n    \n    // The fractal function.\n    float f3 = f2 * f;\n    \n    // The fractal function.\n    float f4 = f3 * f;\n    \n    // The fractal function.\n    float f5 = f4 * f;\n    \n    // The fractal function.\n    float f6 = f5 * f;\n    \n    // The fractal function.\n    float f7 = f6 * f;\n    \n    // The fractal function.\n    float f8 = f7 * f;\n    \n    // The fractal function.\n    float f9 = f8 * f;\n    \n    // The fractal function.\n    float f10 = f9 * f;\n    \n    // The fractal function.\n    float f11 = f10 * f;\n    \n    // The fractal function.\n    float f12 = f11 * f;\n    \n    // The fractal function.\n    float f13 = f12 * f;\n    \n    // The fractal function.\n    float f14 = f13 * f;\n    \n    // The fractal function.\n    float f15 = f14 * f;\n    \n    // The fractal function.\n    float f16 = f15 * f;\n    \n    // The fractal function.\n    float f17 = f16 * f;\n    \n    // The fractal function.\n    float f18 = f17 * f;\n    \n    // The fractal function.\n    float f19 = f18 * f;\n    \n    // The fractal function.\n    float f20 = f19 * f;\n    \n    // The fractal function.\n    float f21 = f20 * f;\n    \n    // The fractal function.\n    float f22 = f21 * f;\n    \n    // The fractal function.\n    float f23 = f22 *", "\n\n    // p = p * 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\n    // Determine the first vertice.\n    vec3 q = p - f;\n\n    // Determine the first vertice.\n    vec4 w = mix(mix(mix(dot(q, vec3(1.0, 57.0, 113.0)),\n                        dot(q, vec3(57.0, 113.0, 17.0)),\n                        f.y),\n                    mix(dot(q, vec3(113.0, 57.0, 17.0)),\n                        dot(q, vec3(17.0, 113.0, 57.0)),\n                        f.y),\n                    f.z),\n               mix(mix(dot(q, vec3(57.0, 17.0, 113.0)),\n                        dot(q, vec3(17.0, 57.0, 113.0)),\n                        f.z),\n                   mix(dot(q, vec3(113.0, 17.0, 57.0)),\n                       dot(q, vec3(17.0, 113.0, 57.0)),\n                       f.z),\n                   f.x),\n               f.x);\n\n    // Determine the first vertice.\n    return mix(mix(mix(w.x, w.y, f.x), w.z, f.y), w.w, f.z);\n}\n\nfloat", "\n    float n = 0.0;\n    \n    // The frequency.\n    float f = 1.0;\n    \n    // The amplitude.\n    float a = 1.0;\n    \n    // The number of octaves.\n    int o = 1;\n    \n    // The persistence.\n    float p = 0.5;\n    \n    // The offset.\n    float of = 0.0;\n    \n    // The scale.\n    float s = 1.0;\n    \n    // The number of iterations.\n    int i = 0;\n    \n    // The total value.\n    float t = 0.0;\n    \n    // The total value.\n    float t2 = 0.0;\n    \n    // The total value.\n    float t3 = 0.0;\n    \n    // The total value.\n    float t4 = 0.0;\n    \n    // The total value.\n    float t5 = 0.0;\n    \n    // The total value.\n    float t6 = 0.0;\n    \n    // The total value.\n    float t7 = 0.0;\n    \n    // The total value.\n    float t8 = 0.0;\n    \n    // The total value.\n    float t9 = 0.0;\n    \n    // The total value.\n    float t10 = 0.0;\n    \n    // The total value.\n    float t11 = 0.0;\n    \n    // The total value.\n    float t12 = 0.0;\n    \n    // The total value.\n    float t13 = 0.0;\n    \n    // The total value.\n    float t14 = 0.0;\n    \n    // The total value.\n    float t15 = 0.0;\n    \n    // The total value.\n    float t16 = 0.0;\n    \n    // The total value.\n    float t17 = 0.0;\n    \n    // The total value.\n    float t18 = 0.0;\n    \n    // The total value.\n    float t19 = 0.0;\n    \n    // The total value.\n    float", "\n  vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon radius\n  float balloonRadius = 0.05;\n  \n  // Then we define our balloon height\n  float balloonHeight = 0.05;\n  \n  // Then we define our balloon width\n  float balloonWidth = 0.05;\n  \n  // Then we define our balloon depth\n  float balloonDepth = 0.05;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial = 0.0;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial = 0.0;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial = 0.0;\n  \n  // Then we define our balloon texture\n  vec3 balloonTexture = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 0.0, 0.0, 0.", "\n\tvec3 tmin = (rad - ro) / rd;\n\tvec3 tmax = (rad + ro) / rd;\n\n\t// find the largest entering t value first\n\tvec3 t1 = max(tmin, tmax);\n\tvec3 t2 = min(tmin, tmax);\n\n\t// find the smallest exiting t value\n\tvec3 tmin2 = max(t2, t1);\n\tvec3 tmax2 = min(t2, t1);\n\n\t// find the largest entering t value first\n\tvec3 t3 = max(tmin2, tmax2);\n\tvec3 t4 = min(tmin2, tmax2);\n\n\t// find the smallest exiting t value\n\tvec3 tmin3 = max(t4, t3);\n\tvec3 tmax3 = min(t4, t3);\n\n\t// find the largest entering t value first\n\tvec3 t5 = max(tmin3, tmax3);\n\tvec3 t6 = min(tmin3, tmax3);\n\n\t// find the smallest exiting t value\n\tvec3 tmin4 = max(t6, t5);\n\tvec3 tmax4 = min(t6, t5);\n\n\t// find the largest entering t value first\n\tvec3 t7 = max(tmin4, tmax4);\n\tvec3 t8 = min(tmin4, tmax4);\n\n\t// find the smallest exiting t value\n\tvec3 tmin5 = max(t8, t7);\n\tvec3 tmax5 = min(t8, t7);\n\n\t// find the largest entering t value first\n\tvec3 t9 = max(tmin5, tmax5);\n\tvec3 t10 = min(tmin5, tmax5);\n\n\t// find the smallest exiting t value\n\tvec3 tmin6 = max(t10, t9);\n\tvec3 tmax6 = min(t10, t9);\n\n\t// find the largest entering t value first\n\tvec3 t11 = max(tmin6, tmax6);\n\tvec3 t12 = min(tmin6, tmax6);\n\n\t// find the", "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    \n    // Determining the first vertice.\n    vec3 q = p - f;\n    \n    // Determining the first vertice.\n    vec4 w = mix(mix(mix(dot(q, vec3(1.0, 57.0, 21.0)),\n                        dot(q, vec3(57.0, 159.0, 23.0)),\n                        f.y),\n                    mix(dot(q, vec3(73.0, 91.0, 3.0)),\n                        dot(q, vec3(27.0, 19.0, 153.0)),\n                        f.y),\n                    f.z),\n               mix(mix(dot(q, vec3(17.0, 103.0, 7.0)),\n                        dot(q, vec3(13.0, 99.0, 15.0)),\n                        f.y),\n                   dot(q, vec3(83.0, 11.0, 89.0)),\n                   f.z),\n               f.x);\n    \n    // Determining the first vertice.\n    return mix(w.x, w.y, w.z);\n}\n\nfloat", "\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monoch", "\n    //Use a for loop to make sure the loop is executed at least once.\n    for(int i = 0; i < 100; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(length(z) > 2.0){\n            return vec4(i, 0.0, 0.0, 1.0);\n        }\n    }\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvoid main(){\n    vec2 c = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec4 color = mandelbrot(c, c);\n    gl_FragColor = vec4(color.xyz, 1.0);\n}\n", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n\n    //we need to create the matrix\n    mat4 mat = mat4(x.x, x.y, x.z, 0.0,\n                    y.x, y.y, y.z, 0.0,\n                    z.x, z.y, z.z, 0.0,\n                    0.0, 0.0, 0.0, 1.0);\n\n    return mat;\n}\n\nvec", "\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z*mix(vec3(1.0),clamp(rgb+vec3(0.0,1.0,1.0),0.0,1.0),c.y);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy / resolution.xy);\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= resolution.x / resolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float t = time * 0.005;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float h = atan(p.y, p.x) / (2.0 * 3.1415926535897932384626433832795);\n    vec3 hsv = vec3(h, s, c);\n    vec3 rgb = hsv2rgb(hsv);\n\n    col = mix(col, rgb, 0.5);\n\n    gl_FragColor = vec4(col, 1.0);\n}", "\n    float d = w / 2.0;\n    float x = floor(p.x / d);\n    float y = floor(p.y / d);\n    float xf = fract(p.x / d);\n    float yf = fract(p.y / d);\n    float xd = x + xf;\n    float yd = y + yf;\n    float xd2 = xd + xf;\n    float yd2 = yd + yf;\n    float xd3 = xd + xf + xf;\n    float yd3 = yd + yf + yf;\n    float xd4 = xd + xf + xf + xf;\n    float yd4 = yd + yf + yf + yf;\n    float xd5 = xd + xf + xf + xf + xf;\n    float yd5 = yd + yf + yf + yf + yf;\n    float xd6 = xd + xf + xf + xf + xf + xf;\n    float yd6 = yd + yf + yf + yf + yf + yf;\n    float xd7 = xd + xf + xf + xf + xf + xf + xf;\n    float yd7 = yd + yf + yf + yf + yf + yf + yf;\n    float xd8 = xd + xf + xf + xf + xf + xf + xf + xf;\n    float yd8 = yd + yf + yf + yf + yf + yf + yf + yf;\n    float xd9 = xd + xf + xf + xf + xf + xf + xf + xf + xf;\n    float yd9 = yd + yf + yf + yf + yf + yf + yf + yf + yf;\n    float xd10 = xd + xf + xf + xf + xf + xf + xf + xf + xf + xf;\n    float yd10 = yd", "\n    if (a == b)\n        return 0.0f;\n\n    // clamp x to be between a and b\n    if (x < a)\n        x = a;\n    else if (x > b)\n        x = b;\n\n    // calculate the step\n    float step = (x - a) / (b - a);\n\n    // return the step\n    return step;\n}\n\n//src/math/vec2.h\n#pragma once\n\n#include <math.h>\n\nstruct vec2\n{\n    float x, y;\n\n    vec2() : x(0.0f), y(0.0f) {}\n    vec2(float x, float y) : x(x), y(y) {}\n\n    vec2 operator+(const vec2& v) const\n    {\n        return vec2(x + v.x, y + v.y);\n    }\n\n    vec2 operator-(const vec2& v) const\n    {\n        return vec2(x - v.x, y - v.y);\n    }\n\n    vec2 operator*(const vec2& v) const\n    {\n        return vec2(x * v.x, y * v.y);\n    }\n\n    vec2 operator/(const vec2& v) const\n    {\n        return vec2(x / v.x, y / v.y);\n    }\n\n    vec2 operator*(float s) const\n    {\n        return vec2(x * s, y * s);\n    }\n\n    vec2 operator/(float s) const\n    {\n        return vec2(x / s, y / s);\n    }\n\n    vec2 operator-() const\n    {\n        return vec2(-x, -y);\n    }\n\n    vec2& operator+=(const vec2& v)\n    {\n        x += v.x;\n        y += v.y;\n        return *this;\n    }\n\n    vec2& operator-=(const vec2& v)\n    {\n        x -= v", "\n    float dist = sampleFunc(xy);\n\n    // if the distance is less than the curve, then the pixel is on the curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\nvoid main()\n{\n    // get the xy coordinates of the pixel\n    vec2 xy = gl_FragCoord.xy / resolution;\n\n    // get the color of the pixel\n    vec4 baseCol = texture(tex, xy);\n\n    // draw the curve\n    drawFunc(baseCol, xy, curveCol);\n\n    // write the color to the framebuffer\n    gl_FragColor = baseCol;\n}\n", "\n float x = p.x + cos(j*2.0*3.1415926535897932384626433832795)*0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n //f+=.05*sin(p.z*5.);\n //f+=.05*cos(p.w*5.);\n //return f;\n //return f*f;\n //return f*f*f;\n //return f*f*f*f;\n //return f*f*f*f*f;\n //return f*f*f*f*f*f;\n //return f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f;\n //return f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*f*", "\n    return vec3(c.r, c.g, c.b);\n}\n\nvec", "\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox(p,s);\n //return sdBox", "\n //return sdSuperprim(p,s,r);\n //}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    //int matrIndex = int(mod(", "\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    return clamp(x * (2.51 * x + 0.04), vec3(0.0), vec3(1.0));\n}\n\nvec", "\n    p.z -= 10.0;\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    vec3 v = normalize(p - cameraPos);\n    vec3 r = normalize(cross(vec3(0.0, 1.0, 0.0), v));\n    vec3 u = cross(v, r);\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    vec3 c = cameraPos + v;\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    vec3 rd = normalize(p - c);\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    float t = 0.0;\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    for (int i = 0; i < 100; i++) {\n        vec3 p = c + rd * t;\n        float d = map(p);\n        t += d;\n    }\n    \n    // The camera is at (0,0,0) and looks at (0,0,1)\n    return t;\n}\n\n// The camera is at (0,0,0) and looks at (0,0,1)\nfloat", "\n    float r = 0.5;\n    vec3 p2 = p - vec3(0.0, 0.0, 0.0);\n    float d = length(p2);\n    if (d < r) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    //plane\n    vec3 n = vec3(0.0, 1.0, 0.0);\n    float t = dot(p2, n) / dot(p2, n);\n    if (t < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n    return p2 - n * t;\n}\n\nvoid main() {\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 d = vec3(0.0, 0.0, 0.0);\n    vec3 c = vec3(0.0, 0.0, 0.0);\n    vec3 l = vec3(0.0, 0.0, 0.0);\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 f = vec3(0.0, 0.0, 0.0);\n    vec3 b = vec3(0.0, 0.0, 0.0);\n    vec3 s = vec3(0.0, 0.0, 0.0);\n    vec3 t = vec3(0.0, 0.0, 0.0);\n    vec3 u = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    vec3", "\n    mat2 m = mat2( 0.8, -0.6, 0.6, 0.8 );\n    // scale and bias the point\n    p = p * 2.0 - 1.0;\n    p.x *= m.x;\n    p.y *= m.y;\n    // add in the axial bias\n    p.x += fbm( p + vec2( 0.0, 0.0 ) );\n    p.y += fbm( p + vec2( 0.0, 0.0 ) );\n    // return the noise value\n    return fbm( p );\n}\n\nfloat", "\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point is the wrapped point, the second is the unwrapped point.\n    vec2 p1 = p;\n    vec2 p2 = p;\n    \n    // The first point", "\n return dot(u,m);\n}\n\nfloat", "\n return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n}\n\nfloat", ".\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2 u, vec4 m){\n //vec2 d=m.xy;vec2 e=m.zw;//2 points to define a line.\n //c.g=min(length(u-d),length(u-e))-.1;//draw 2 points.\n //return c;\n //}\n //vec4 sd2l(vec2", "\n /*O*/\n return v1;\n}\n\nint", "\n /*O*/\n return v1;\n}\n\nint", "\n    return cross(a, b);\n}\n\nvec", "\n\tfloat alpha = acos(dot(normalize(A), normalize(B)));\n\tfloat beta = acos(dot(normalize(B), normalize(C)));\n\tfloat gamma = acos(dot(normalize(C), normalize(A)));\n\n\t//calculate the coordinates of the point on the sphere\n\tvec3 p = vec3(cos(alpha) * cos(beta) * cos(gamma) + Xi1, cos(alpha) * cos(beta) * sin(gamma) + Xi2, sin(alpha) * cos(beta) + sin(gamma));\n\n\t//calculate the pdf of the point on the sphere\n\twPdf = (1.0 / (4.0 * PI)) * (1.0 - cos(alpha) * cos(beta) * cos(gamma)) / (p.x * p.x + p.y * p.y + p.z * p.z);\n\n\t//calculate the direction of the point on the sphere\n\tw = normalize(p);\n}\n\nvoid main() {\n\t//calculate the coordinates of the point on the sphere\n\tvec3 w;\n\tfloat wPdf;\n\tsampleSphericalTriangle(vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), uv.x, uv.y, w, wPdf);\n\n\t//calculate the pdf of the point on the sphere\n\tfloat pdf = (1.0 / (4.0 * PI)) * (1.0 - w.x * w.x - w.y * w.y - w.z * w.z) / (w.x * w.x + w.y * w.y + w.z * w.z);\n\n\t//calculate the cosine of the angle between the normal and the direction of the point on the sphere\n\tfloat cosTheta = dot(w, normalize(normal));\n\n\t//calculate the cosine of the angle between the normal and the direction of the point on the sphere\n\tfloat cosPhi = dot(w, normalize(vec3(0.0", "\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n\nv2 c(v1 U){\n /*In*/\n /*Out*/\n return v1;\n}\n", "\n    \n    // The tube is a 1D function, so we can use the \"fract\" function to get the fractional part of the x coordinate.\n    float t = fract(p.x);\n    \n    // The tube is a 2D function, so we can use the \"fract\" function to get the fractional part of the y coordinate.\n    float t2 = fract(p.y);\n    \n    // The tube is a 3D function, so we can use the \"fract\" function to get the fractional part of the z coordinate.\n    float t3 = fract(p.z);\n    \n    // The tube is a 4D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t4 = fract(p.w);\n    \n    // The tube is a 5D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t5 = fract(p.w);\n    \n    // The tube is a 6D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t6 = fract(p.w);\n    \n    // The tube is a 7D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t7 = fract(p.w);\n    \n    // The tube is a 8D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t8 = fract(p.w);\n    \n    // The tube is a 9D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t9 = fract(p.w);\n    \n    // The tube is a 10D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t10 = fract(p.w);\n    \n    // The tube is a 11D function, so we can use the \"fract\" function to get the fractional part of the w coordinate.\n    float t1", "\n    float tubeWidth = 0.005;\n\n    // Tube height.\n    float tubeHeight = 0.005;\n\n    // Tube radius.\n    float tubeRadius = 0.005;\n\n    // Tube thickness.\n    float tubeThickness = 0.005;\n\n    // Tube offset.\n    float tubeOffset = 0.005;\n\n    // Tube offset.\n    float tubeOffset2 = 0.005;\n\n    // Tube offset.\n    float tubeOffset3 = 0.005;\n\n    // Tube offset.\n    float tubeOffset4 = 0.005;\n\n    // Tube offset.\n    float tubeOffset5 = 0.005;\n\n    // Tube offset.\n    float tubeOffset6 = 0.005;\n\n    // Tube offset.\n    float tubeOffset7 = 0.005;\n\n    // Tube offset.\n    float tubeOffset8 = 0.005;\n\n    // Tube offset.\n    float tubeOffset9 = 0.005;\n\n    // Tube offset.\n    float tubeOffset10 = 0.005;\n\n    // Tube offset.\n    float tubeOffset11 = 0.005;\n\n    // Tube offset.\n    float tubeOffset12 = 0.005;\n\n    // Tube offset.\n    float tubeOffset13 = 0.005;\n\n    // Tube offset.\n    float tubeOffset14 = 0.005;\n\n    // Tube offset.\n    float tubeOffset15 = 0.005;\n\n    // Tube offset.\n    float tubeOffset16 = 0.005;\n\n    // Tube offset.\n    float tubeOffset17 = 0.005;\n\n    // Tube offset.\n    float tubeOffset18 = 0.005;\n\n    // Tube offset.\n    float tubeOffset19 = 0.005;\n\n    // Tube offset.\n    float tubeOffset20 = 0.005;\n\n    // Tube offset", "\n    int gID_int = int(gID);\n    \n    // The cubic grid cell is a 3x3x3 cube.\n    // The grid cell is divided into 8 sub-cells.\n    // The sub-cells are divided into 8 sub-sub-cells.\n    // The sub-sub-cells are divided into 8 sub-sub-sub-cells.\n    // The sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells are divided into 8 sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-sub-cells.\n    // The sub-sub-sub-sub-sub-sub-sub-sub-sub-sub", "\n    float t = 0., tmin = 1e10;\n    \n    // Ray position\n    vec3 p = o;\n    \n    // Ray direction\n    vec3 d = r;\n    \n    // Ray step size\n    float dt = 0.001;\n    \n    // Ray step size\n    float dp = 0.001;\n    \n    // Ray step size\n    float ddt = 0.001;\n    \n    // Ray step size\n    float ddp = 0.001;\n    \n    // Ray step size\n    float dddt = 0.001;\n    \n    // Ray step size\n    float ddddp = 0.001;\n    \n    // Ray step size\n    float ddddt = 0.001;\n    \n    // Ray step size\n    float dddddp = 0.001;\n    \n    // Ray step size\n    float ddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddddddp = 0.001;\n    \n    // Ray step size\n    float ddddddddddddddddt = 0.001;\n    \n    // Ray step size\n    float dddddddddddddddddp = 0.001;\n", "\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm", "\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using\n    // a mixture. I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting", "\n    vec3 w = m * p3;\n    vec3 w2 = w * w;\n    vec3 w3 = w2 * w;\n    vec3 w4 = w3 * w;\n    vec3 w5 = w4 * w;\n    vec3 w6 = w5 * w;\n    vec3 w7 = w6 * w;\n    vec3 w8 = w7 * w;\n    vec3 w9 = w8 * w;\n    vec3 w10 = w9 * w;\n    vec3 w11 = w10 * w;\n    vec3 w12 = w11 * w;\n    vec3 w13 = w12 * w;\n    vec3 w14 = w13 * w;\n    vec3 w15 = w14 * w;\n    vec3 w16 = w15 * w;\n    vec3 w17 = w16 * w;\n    vec3 w18 = w17 * w;\n    vec3 w19 = w18 * w;\n    vec3 w20 = w19 * w;\n    vec3 w21 = w20 * w;\n    vec3 w22 = w21 * w;\n    vec3 w23 = w22 * w;\n    vec3 w24 = w23 * w;\n    vec3 w25 = w24 * w;\n    vec3 w26 = w25 * w;\n    vec3 w27 = w26 * w;\n    vec3 w28 = w27 * w;\n    vec3 w29 = w28 * w;\n    vec3 w30 = w29 * w;\n    vec3 w31 = w30 * w;\n    vec3 w32 = w31 * w;\n    vec3 w33 = w32 * w;\n    vec3 w34 = w33 * w;\n    vec3 w35 = w34 * w;\n    vec3 w36", "\n    vec4 hex1 = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 hex2 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints2 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints3 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints4 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints5 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints6 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some calculations together.\n    vec4 hexagonPoints7 = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon points are stored in a \"vec4\" in order to group some", "\n    return df_truchet(p, dir) +.1;\n}\n\n// This is the main function that does the actual rendering.\n// It's a bit of a mess, but it's basically a loop over all pixels,\n// and for each pixel, it calls the raytracing function to get the color.\n// The raytracing function is a bit more complicated than I'd like, but it's\n// basically just a raytracing function that takes a ray, and returns the color\n// of the ray.\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    \n    // We're going to render a 2D image, so we need to convert the pixel coordinates\n    // to a 2D coordinate system.", "\n    float t = (q.x + q.y) * 0.5;\n    float r = (q.x - q.y) * 0.5;\n    \n    // Polar conversion.\n    float theta = atan2(r, t);\n    float phi = dir * theta;\n    \n    // Return the polar coordinates.\n    return vec2(phi, r);\n}\n\nvoid main()\n{\n    // Get the polar coordinates.\n    vec2 q = getPolarCoord(vUV, vDir);\n    \n    // Get the distance from the center.\n    float d = length(q);\n    \n    // Get the angle from the center.\n    float a = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a2 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a3 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a4 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a5 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a6 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a7 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a8 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a9 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a10 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a11 = atan(q.y, q.x);\n    \n    // Get the angle from the center.\n    float a12 = atan(q.y, q.x);\n    \n    // Get the angle from the", "\n    vec3 w = p3 - n[0];\n    float d00 = dot(w, n[0]);\n    float d01 = dot(w, n[1]);\n    float d02 = dot(w, n[2]);\n    float d11 = dot(w, n[1] - n[0]);\n    float d22 = dot(w, n[2] - n[0]);\n    float d33 = dot(w, n[2] - n[1]);\n    float inv_denom = 1.0 / (d00 * d11 * d22 + d01 * d12 * d20 + d02 * d10 * d21 - d00 * d12 * d21 - d01 * d10 * d22 - d02 * d11 * d20);\n    vec3 v = vec3(\n        (d11 * d33 - d01 * d23) * inv_denom,\n        (d02 * d23 - d03 * d12) * inv_denom,\n        (d01 * d13 - d03 * d11) * inv_denom\n    );\n    return v;\n}\n\nvec", ".\n  if (abs(r.w) < abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |p.w| and |r.w| >= |q.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(q.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |q.w| and |r.w| < |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) < abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |q.w| and |r.w| >= |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |p.w| and |r.w| < |q.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) < abs(q.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |p.w| and |r.w| < |q.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) < abs(q.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |q.w| and |r.w| >= |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| >= |q.w| and |r.w| >= |p.w| so we can ignore\n  // the line entirely.\n  if (abs(r.w) >= abs(p.w)) {\n    return 0.0;\n  }\n\n  // |r.w| < |p.", "\n    // The only difference is that the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n    // The tile is a square, so the tile is a square.\n   ", "\n\tfloat k00 = -0.25;\n\tfloat k10 =  0.25;\n\tfloat k01 = -0.25;\n\tfloat k11 =  0.25;\n\n\t// filter kernel derivatives\n\tfloat dk00 = -0.25;\n\tfloat dk10 =  0.25;\n\tfloat dk01 = -0.25;\n\tfloat dk11 =  0.25;\n\n\t// filter kernel derivatives\n\tfloat ddx0 = dk00 * ddx.x + dk10 * ddx.y;\n\tfloat ddx1 = dk01 * ddx.x + dk11 * ddx.y;\n\tfloat ddy0 = dk00 * ddy.x + dk10 * ddy.y;\n\tfloat ddy1 = dk01 * ddy.x + dk11 * ddy.y;\n\n\t// filter kernel derivatives\n\tfloat ddx2 = ddx0 * ddx0 + ddx1 * ddx1;\n\tfloat ddy2 = ddy0 * ddy0 + ddy1 * ddy1;\n\n\t// filter kernel derivatives\n\tfloat ddx3 = ddx2 * ddx2;\n\tfloat ddy3 = ddy2 * ddy2;\n\n\t// filter kernel derivatives\n\tfloat ddx4 = ddx3 * ddx3;\n\tfloat ddy4 = ddy3 * ddy3;\n\n\t// filter kernel derivatives\n\tfloat ddx5 = ddx4 * ddx4;\n\tfloat ddy5 = ddy4 * ddy4;\n\n\t// filter kernel derivatives\n\tfloat ddx6 = ddx5 * ddx5;\n\tfloat ddy6 = ddy5 * ddy5;\n\n\t// filter kernel derivatives\n\tfloat ddx7 = ddx6 * ddx6;\n\tfloat ddy7 = ddy6 * ddy6;\n\n\t// filter kernel derivatives\n\tfloat ddx8 = ddx7 * ddx7;\n\tfloat ddy8 = ddy7 * ddy7;\n\n\t// filter kernel derivatives\n\tfloat ddx9 = ddx8", "\n    vec2 p = floor( n );\n\n    // get the fractional part of the cell position\n    vec2 fp = fract( n );\n\n    // get the distance to the closest point\n    float d = distance( f, fp );\n\n    // get the distance to the farthest point\n    float d2 = distance( fp, vec2( 1.0 ) );\n\n    // get the distance to the closest point in the x direction\n    float dx = abs( fp.x - f.x );\n\n    // get the distance to the farthest point in the x direction\n    float dx2 = abs( fp.x - 1.0 );\n\n    // get the distance to the closest point in the y direction\n    float dy = abs( fp.y - f.y );\n\n    // get the distance to the farthest point in the y direction\n    float dy2 = abs( fp.y - 1.0 );\n\n    // get the distance to the closest point in the x direction\n    float dz = abs( fp.z - f.z );\n\n    // get the distance to the farthest point in the x direction\n    float dz2 = abs( fp.z - 1.0 );\n\n    // get the distance to the closest point in the y direction\n    float dw = abs( fp.w - f.w );\n\n    // get the distance to the farthest point in the y direction\n    float dw2 = abs( fp.w - 1.0 );\n\n    // get the distance to the closest point in the x direction\n    float dxy = abs( fp.xy - f.xy );\n\n    // get the distance to the farthest point in the x direction\n    float dxy2 = abs( fp.xy - vec2( 1.0 ) );\n\n    // get the distance to the closest point in the y direction\n    float dxyz = abs( fp.xyz - f.xyz );\n\n    // get the distance to the farthest point in the y direction\n    float dxyz2 = abs( fp.xyz - vec3( 1.0 ) );\n\n    // get the distance", "\n    return (1.0f - t) * p1 + t * p2;\n}\n\nvoid main()\n{\n    vec2 pos = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_2 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_3 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_4 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_5 = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_6 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_7 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_8 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_9 = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_10 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_11 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_12 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_13 = lerp_pos(gl_FragCoord.x / (float)width);\n    vec2 pos_14 = lerp_pos(gl_FragCoord.y / (float)height);\n    vec2 pos_15 = lerp_pos(gl_FragCoord.z / (float)width);\n    vec2 pos_16 = lerp_pos(gl_FragCoord.w / (float)height);\n\n    vec2 pos_17 =", "\n\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0 - vec2(1.0);\n    // p = p * 2.0", "\n\n    // This is a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's a good one to use, because it's a good one to use.\n    // It's", "\n    float a = length(p1 - p0);\n    float b = length(p2 - p1);\n    float c = length(p0 - p2);\n    \n    // Angles.\n    float alpha = acos((a*a + b*b - c*c) / (2.0 * a * b));\n    float beta = acos((b*b + c*c - a*a) / (2.0 * b * c));\n    float gamma = acos((c*c + a*a - b*b) / (2.0 * c * a));\n    \n    // Centroid.\n    vec2 cent = (p0 + p1 + p2) / 3.0;\n    \n    // Return.\n    return vec4(cent, alpha, beta, gamma);\n}\n\n// Compute the area of a triangle.\nfloat", "\n    float a = distance(p0, p1);\n    float b = distance(p1, p2);\n    float c = distance(p2, p0);\n\n    // Angles.\n    float alpha = acos((a*a + b*b - c*c) / (2.0 * a * b));\n    float beta = acos((b*b + c*c - a*a) / (2.0 * b * c));\n    float gamma = acos((c*c + a*a - b*b) / (2.0 * c * a));\n\n    // Radii.\n    float r1 = a * sin(alpha);\n    float r2 = b * sin(beta);\n    float r3 = c * sin(gamma);\n\n    // Area.\n    float s = (a + b + c) / 2.0;\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Circumference.\n    float c1 = r1 + r2 + r3;\n\n    // Return the area and circumference.\n    return vec2(area, c1);\n}\n\n// Returns the area and circumference of a triangle.\nvec", "\n   // Returns distance to paraboloid.\n   // h1, h2, h3 are the vertices of the triangle.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2, h3 are in the same plane.\n   // h1, h2", "\n    vec2 v0 = vec2(0.0, 0.0);\n    vec2 v1 = vec2(1.0, 0.0);\n    vec2 v2 = vec2(0.0, 1.0);\n    \n    vec2 v3 = vec2(0.0, 0.0);\n    vec2 v4 = vec2(1.0, 0.0);\n    vec2 v5 = vec2(0.0, 1.0);\n    \n    vec2 v6 = vec2(0.0, 0.0);\n    vec2 v7 = vec2(1.0, 0.0);\n    vec2 v8 = vec2(0.0, 1.0);\n    \n    vec2 v9 = vec2(0.0, 0.0);\n    vec2 v10 = vec2(1.0, 0.0);\n    vec2 v11 = vec2(0.0, 1.0);\n    \n    vec2 v12 = vec2(0.0, 0.0);\n    vec2 v13 = vec2(1.0, 0.0);\n    vec2 v14 = vec2(0.0, 1.0);\n    \n    vec2 v15 = vec2(0.0, 0.0);\n    vec2 v16 = vec2(1.0, 0.0);\n    vec2 v17 = vec2(0.0, 1.0);\n    \n    vec2 v18 = vec2(0.0, 0.0);\n    vec2 v19 = vec2(1.0, 0.0);\n    vec2 v20 = vec2(0.0, 1.0);\n    \n    vec2 v21 = vec2(0.0, 0.0);\n    vec2 v22 = vec2(1.0, 0.0);\n   ", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    //uv.x *= iResolution.x / iResolution.y;\n\n    //get the color of the pixel\n    vec3 color = vec3(0.0);\n    vec2 p = uv;\n    float t = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0", "\n    //return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n    \n    // This is the original method.\n    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat", "\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n", "\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n", "\n    // Return the hit point, normal, and color.\n    // If no hit, return black.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the", "\n    vec2 p01 = p0 - p1;\n    vec2 p12 = p1 - p2;\n    vec2 p20 = p2 - p0;\n\n    // midpoints\n    vec2 p012 = p01 + p12;\n    vec2 p120 = p12 + p20;\n    vec2 p201 = p20 + p01;\n\n    // distances\n    float d01 = length(p01);\n    float d12 = length(p12);\n    float d20 = length(p20);\n\n    // distances to midpoints\n    float d012 = length(p012);\n    float d120 = length(p120);\n    float d201 = length(p201);\n\n    // distances to extremes\n    float d012_ = d012 / d01;\n    float d120_ = d120 / d12;\n    float d201_ = d201 / d20;\n\n    // distances to midpoints\n    float d012_1 = d012_ * d012_;\n    float d120_1 = d120_ * d120_;\n    float d201_1 = d201_ * d201_;\n\n    // distances to extremes\n    float d012_2 = d012_1 * d012_;\n    float d120_2 = d120_1 * d120_;\n    float d201_2 = d201_1 * d201_;\n\n    // distances to midpoints\n    float d012_3 = d012_2 * d012_;\n    float d120_3 = d120_2 * d120_;\n    float d201_3 = d201_2 * d201_;\n\n    // distances to midpoints\n    float d012_4 = d012_3 * d012", "\n    vec3 min = min( p0, min( p1, min( p2, p3 ) ) );\n    vec3 max = max( p0, max( p1, max( p2, p3 ) ) );\n\n    // center\n    vec3 center = ( min + max ) * 0.5;\n\n    // radius\n    vec3 radius = max( abs( p0 - center ), abs( p1 - center ) );\n    radius = max( radius, abs( p2 - center ) );\n    radius = max( radius, abs( p3 - center ) );\n\n    return BezierAABB( center, radius );\n}\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\nBezierAABB BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in vec3 p4, in vec3 p5, in vec3 p6, in vec3 p7, in vec3 p8, in vec3 p9, in vec3 p10, in vec3 p11, in vec3 p12, in vec3 p13, in vec3 p14, in vec3 p15, in vec3 p16, in vec3 p17, in vec3 p18, in vec3 p19, in vec3 p20, in vec3 p21, in vec3 p22, in vec3 p23, in vec3 p24, in vec3 p25, in vec3 p26, in vec3 p27, in vec3 p28, in vec3 p29, in vec3 p30, in vec3 p31, in vec3 p32, in vec3 p33, in vec3 p34, in vec3 p35, in vec3 p36, in vec3 p37, in vec3 p38, in vec3 p39, in vec3 p40, in vec3 p41, in vec", "\n    const vec2 iResolution = vec2( 1280.0, 720.0 );\n    const float iTime = TIME;\n    const float iTimeDelta = TIME_DELTA;\n    const float iFrame = FRAME;\n    const float iFrameDelta = FRAME_DELTA;\n    const float iFrameCount = FRAME_COUNT;\n    const float iFrameCountDelta = FRAME_COUNT_DELTA;\n    const float iFrameCountMax = FRAME_COUNT_MAX;\n    const float iFrameCountMaxDelta = FRAME_COUNT_MAX_DELTA;\n    const float iFrameCountMaxMax = FRAME_COUNT_MAX_MAX;\n    const float iFrameCountMaxMaxDelta = FRAME_COUNT_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxMax = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX_MAX;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxMaxDelta = FRAME_COUNT_MAX_MAX_MAX_MAX_MAX_MAX_MAX_DELTA;\n    const float iFrameCountMaxMaxMaxMaxMaxMaxMaxMax = FR", "\n    return k * k * ( 3.0 - 2.0 * k ); // EaseInOut\n}\n\nfloat", "\n    vec2 F2 = vec2(1.0 / 3.0, 1.0 / 3.0) - v;\n\n    // Compute first coordinate\n    vec4 H = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute second coordinate\n    vec4 G = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute final noise\n    return mix(\n        mix(dot(H, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(H, vec2(2.0 / 3.0, 1.0 / 3.0)), step", "\n\tvec2 uv = fragCoord/iResolution.xy;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (from 0 to 1)\n\tvec2 p = (2.0 * uv) - 1.0;\n\t\n\t// Time varying pixel color\n\tvec3 col = vec3(0.0);\n\t\n\t// Normalized pixel coordinates (", "\n    coord -= vec2(0.5, 0.5);\n\n    // Scale the coordinate to the screen size.\n    coord *= res;\n\n    // Translate the coordinate to the center of the screen.\n    coord += vec2(0.5, 0.5);\n\n    return coord;\n}\n\nvec", "\n    vec2 f = vec2( 0.0 );\n    f.x = ( 1.0 - abs( p.x ) ) * 0.5;\n    f.y = ( 1.0 - abs( p.y ) ) * 0.5;\n    return f.x * f.y;\n}\n\nvoid main()\n{\n    vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / min( resolution.x, resolution.y );\n    vec2 q = p;\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tinc = 0.001;\n    float tinc2 = 0.0001;\n    float tinc3 = 0.00001;\n    float tinc4 = 0.000001;\n    float tinc5 = 0.0000001;\n    float tinc6 = 0.00000001;\n    float tinc7 = 0.000000001;\n    float tinc8 = 0.0000000001;\n    float tinc9 = 0.00000000001;\n    float tinc10 = 0.000000000001;\n    float tinc11 = 0.0000000000001;\n    float tinc12 = 0.00000000000001;\n    float tinc13 = 0.000000000000001;\n    float tinc14 = 0.0000000000000001;\n    float tinc15 = 0.00000000000000001;\n    float tinc16 = 0.000000000000000001;\n    float tinc1", "\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 rgb2hcv = rgb * 0.01f;\n    rgb2hcv = rgb2hcv * (1.0f / 12.92f) + vec3(0.055f);\n    rgb2hcv = pow(rgb2hcv, vec3(1.0f / 2.4f));\n    return rgb2hcv;\n}\n\nvec", "\n    //return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n\n    // Better, but doesn't disperse things quite as nicely.\n    return fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n}\n\nfloat", "\n    vec3 n = texture( iChannel0, p.yzx, 0.001 ).xyz;\n    n.xy *= 2.0;\n    return normalize( n - vec3( 0.5, 0.5, 0.5 ) );\n}\n\nvoid main()\n{\n    vec3 p = vec3( iResolution.xy * ( gl_FragCoord.xy / iResolution.xy ), 0.0 );\n    vec3 col = vec3( 0.0 );\n\n    vec3 ro = vec3( 0.0, 0.0, 0.0 );\n    vec3 ta = vec3( 0.0, 0.0, -1.0 );\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n    float dist = length( ta - ro );\n    ta = normalize( ta - ro ) * dist;\n\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross( ww, up ) );\n    vec3 vv = normalize( cross( uu, ww ) );\n\n    vec3 rd = normalize( p.x * uu + p.y * vv + dist * ww );\n\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n\n    for( int i = 0; i < 100; i++ )\n    {\n        vec3 pos = ro + rd * t;\n        vec3 nor = normal( pos );\n        float h = texture( iChannel0, pos.yzx, 0.0 ).x;\n        float dif = max( 0.0, dot( nor, normalize( vec3( 0.0, 1.0, 0.0 ) ) ) );\n        float amb = max( 0.0, dot( nor, uv_light ) ) * 0.5 + 0.5;\n        float spe = pow( max( 0.", "\n    return (float)q.x + (float)q.y * 1000000000.0;\n}\n\n// This is a simple hash function that is used to generate a random number.\n// It is not a good hash function, but it is good enough for our purposes.\n// You SHOULD replace this by something better. Again, Do Not Use in production.\nfloat", "\n    // width = 0.5 -> angle = PI\n    // width = 0.25 -> angle = PI/4\n    // width = 0.125 -> angle = PI/16\n    // width = 0.0625 -> angle = PI/32\n    // width = 0.03125 -> angle = PI/64\n    // width = 0.015625 -> angle = PI/128\n    // width = 0.0078125 -> angle = PI/256\n    // width = 0.00390625 -> angle = PI/512\n    // width = 0.001953125 -> angle = PI/1024\n    // width = 0.0009765625 -> angle = PI/2048\n    // width = 0.00048828125 -> angle = PI/4096\n    // width = 0.000244140625 -> angle = PI/8192\n    // width = 0.0001220703125 -> angle = PI/16384\n    // width = 0.00006103515625 -> angle = PI/32768\n    // width = 0.000030517578125 -> angle = PI/65536\n    // width = 0.0000152587890625 -> angle = PI/131072\n    // width = 0.00000762939453125 -> angle = PI/262144\n    // width = 0.000003814697265625 -> angle = PI/524288\n    // width = 0.000001907348632812", "\n    vec2 F2 = vec2(1.0 / 3.0, 1.0 / 3.0) - v;\n\n    // Compute first coordinate\n    vec4 H = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 1.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 1.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute second coordinate\n    vec4 G = mix(\n        mix(dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(1.0 / 3.0),\n        mix(dot(F2, vec2(2.0 / 3.0, 2.0 / 3.0)), dot(F2, vec2(1.0 / 3.0, 2.0 / 3.0)), step(v.x, 0.5)) * vec2(2.0 / 3.0),\n        step(v.x, 0.5)\n    );\n\n    // Compute final noise\n    return mix(\n        mix(dot(H, vec2(1.0 / 3.0, 1.0 / 3.0)), dot(H, vec2(2.0 / 3.0, 1.0 / 3.0)), step", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\t// get the color of the pixel\n\tvec4 color = texture(iChannel0, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color2 = texture(iChannel1, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color3 = texture(iChannel2, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color4 = texture(iChannel3, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color5 = texture(iChannel4, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color6 = texture(iChannel5, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color7 = texture(iChannel6, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color8 = texture(iChannel7, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color9 = texture(iChannel8, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color10 = texture(iChannel9, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color11 = texture(iChannel10, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color12 = texture(iChannel11, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color13 = texture(iChannel12, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color14 = texture(iChannel13, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color15 = texture(iChannel14, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color16 = texture(iChannel15, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color17 = texture(iChannel16, uv);\n\t\n\t// get the color of the pixel\n\tvec4 color18 =", "\n    float n = 0.0;\n    n += noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\nfloat", " to the position\n\tvec3 q = log(p);\n\t\n\t// Compute the spherical coordinates\n\tfloat r = length(q);\n\tfloat theta = atan(q.y, q.x);\n\tfloat phi = atan(q.z, length(q.xy));\n\t\n\t// Compute the cartesian coordinates\n\tvec3 s = vec3(sin(theta)*cos(phi), sin(phi), cos(theta)*cos(phi));\n\t\n\t// Compute the tangent and bitangent vectors\n\tvec3 t = normalize(cross(vec3(0.0, 1.0, 0.0), s));\n\tvec3 b = cross(s, t);\n\t\n\t// Compute the scale factor\n\tmul = exp(r);\n\t\n\t// Compute the texture coordinates\n\tsp = (q.xy + 1.0) * 0.5;\n\ttp = (q.z + 1.0) * 0.5;\n\trp = (q.xy + 1.0) * 0.5;\n\t\n\t// Compute the tangent space basis\n\tsp = sp * 2.0 - 1.0;\n\ttp = tp * 2.0 - 1.0;\n\trp = rp * 2.0 - 1.0;\n\t\n\t// Compute the tangent space basis\n\tsp = sp * mul;\n\ttp = tp * mul;\n\trp = rp * mul;\n}\n\n// Compute the normal at a given position\nvec", "\n    float y = sin(p.x) * cos(p.z);\n    float r = cos(p.x) * cos(p.z);\n    return vec2(length(p.xy - vec2(0.0, y)) - r, 0.0);\n}\n\nvec", "\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec", "\n\tvec2 p1 = p + vec2(aaSize, 0.0);\n\tvec2 p2 = p + vec2(aaSize, aaSize);\n\tvec2 p3 = p + vec2(0.0, aaSize);\n\tvec2 p4 = p + vec2(0.0, 0.0);\n\tvec2 p5 = p + vec2(-aaSize, 0.0);\n\tvec2 p6 = p + vec2(-aaSize, aaSize);\n\tvec2 p7 = p + vec2(-aaSize, -aaSize);\n\tvec2 p8 = p + vec2(0.0, -aaSize);\n\tvec2 p9 = p + vec2(aaSize, -aaSize);\n\tvec2 p10 = p + vec2(aaSize, -aaSize);\n\tvec2 p11 = p + vec2(aaSize, 0.0);\n\tvec2 p12 = p + vec2(aaSize, aaSize);\n\tvec2 p13 = p + vec2(0.0, aaSize);\n\tvec2 p14 = p + vec2(0.0, 0.0);\n\tvec2 p15 = p + vec2(-aaSize, 0.0);\n\tvec2 p16 = p + vec2(-aaSize, aaSize);\n\tvec2 p17 = p + vec2(-aaSize, -aaSize);\n\tvec2 p18 = p + vec2(0.0, -aaSize);\n\tvec2 p19 = p + vec2(aaSize, -aaSize);\n\tvec2 p20 = p + vec2(aaSize, -aaSize);\n\tvec2 p21 = p + vec2(aaSize, 0.0);\n\tvec2 p22 = p + vec2(aaSize, aaSize);\n\tvec2 p23 = p + vec2(0.0, aaSize);\n\tvec2 p24 = p + vec2(0.0, 0.0);\n", "\n    mat4 rot = mat4(1.0);\n    rot = rotate(rot, 0.0f, vec3(0.0f, 1.0f, 0.0f));\n    rot = rotate(rot, 0.0f, vec3(1.0f, 0.0f, 0.0f));\n\n    // get a translation matrix for our box's position\n    mat4 trans = mat4(1.0);\n    trans = translate(trans, pos);\n\n    // get the box's vertices\n    vec3 vertices[] = {\n        vec3(0.0f, 0.0f, 0.0f),\n        vec3(1.0f, 0.0f, 0.0f),\n        vec3(1.0f, 1.0f, 0.0f),\n        vec3(0.0f, 1.0f, 0.0f)\n    };\n\n    // get the box's normals\n    vec3 normals[] = {\n        vec3(0.0f, 0.0f, 1.0f),\n        vec3(0.0f, 0.0f, 1.0f),\n        vec3(0.0f, 0.0f, 1.0f),\n        vec3(0.0f, 0.0f, 1.0f)\n    };\n\n    // get the box's texture coordinates\n    vec2 texCoords[] = {\n        vec2(0.0f, 0.0f),\n        vec2(1.0f, 0.0f),\n        vec2(1.0f, 1.0f),\n        vec2(0.0f, 1.0f)\n    };\n\n    // get the box's indices\n    int indices[] = {\n        0, 1, 2,\n        2, 3, 0\n    };\n\n    // get the box's vertices\n    vec3 boxVertices[] = {\n        vec3(0.", "\n    float y = sin(pos.x) * 0.5 + 0.5;\n\n    // rotate the sphere around the x-axis\n    float x = pos.y * 0.5 + 0.5;\n\n    // rotate the sphere around the z-axis\n    float z = pos.z * 0.5 + 0.5;\n\n    return vec2(x, y);\n}\n\nvoid main() {\n\n    // get the position of the vertex\n    vec3 pos = position;\n\n    // get the position of the vertex in the sphere\n    vec2 spherePos = ourSphere(pos);\n\n    // get the position of the vertex in the cube\n    vec3 cubePos = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos2 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos3 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos4 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos5 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos6 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos7 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos8 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos9 = pos * 2.0 - 1.0;\n\n    // get the position of the vertex in the cube\n    vec3 cubePos10 = pos * 2.0 - 1.0;\n\n    // get", "\n    vec3 p = pos;\n    vec3 q = vec3(0.0, 0.0, 0.0);\n    vec3 r = vec3(0.0, 0.0, 0.0);\n    vec3 s = vec3(0.0, 0.0, 0.0);\n    vec3 t = vec3(0.0, 0.0, 0.0);\n    vec3 u = vec3(0.0, 0.0, 0.0);\n    vec3 v = vec3(0.0, 0.0, 0.0);\n    vec3 w = vec3(0.0, 0.0, 0.0);\n    vec3 x = vec3(0.0, 0.0, 0.0);\n    vec3 y = vec3(0.0, 0.0, 0.0);\n    vec3 z = vec3(0.0, 0.0, 0.0);\n\n    // test our shapes\n    if (p.x < -1.0) {\n        p.x = -1.0;\n    }\n    if (p.x > 1.0) {\n        p.x = 1.0;\n    }\n    if (p.y < -1.0) {\n        p.y = -1.0;\n    }\n    if (p.y > 1.0) {\n        p.y = 1.0;\n    }\n    if (p.z < -1.0) {\n        p.z = -1.0;\n    }\n    if (p.z > 1.0) {\n        p.z = 1.0;\n    }\n\n    // test our shapes\n    if (q.x < -1.0) {\n        q.x = -1.0;\n    }\n    if (q.x > 1.0) {\n        q.x = 1.0;\n    }\n    if (q.y < -1.0) {\n        q.y = -1.", "\n    vec3 rayDir = normalize(camDir + lightDir);\n    \n    // march along the ray until we hit something\n    vec3 rayPos = camPos;\n    float t = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 p = rayPos + rayDir * t;\n        float d = scene(p);\n        if (d < 0.001) {\n            break;\n        }\n        t += d;\n    }\n    \n    // calculate the color at the point of intersection\n    vec3 color = vec3(0.0);\n    if (t < 100.0) {\n        vec3 p = rayPos + rayDir * t;\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    \n    return color;\n}\n\nvoid main() {\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 camPos = vec3(0.0, 0.0, 10.0);\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec3 color = marchScene(fragCoord, camPos, camDir, lightDir);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n\tvec3 bmin = rad - ro;\n\tvec3 bmax = rad + ro;\n\tvec3 tmin = (bmin - rd) / rd;\n\tvec3 tmax = (bmax - rd) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(t1.x, max(t1.y, t1.z));\n\tfloat t3 = min(t2.x, min(t2.y, t2.z));\n\tfloat t = max(t0, t3);\n\tif (t < 0.0) return vec2(-1.0);\n\treturn vec2(t, t0);\n}\n\n// ray-sphere intersection\nvec", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t// sample the texture\n\tvec4 texColor = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor2 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor3 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor4 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor5 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor6 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor7 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor8 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor9 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor10 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor11 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor12 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor13 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor14 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor15 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor16 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor17 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor18 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec4 texColor19 = texture(iChannel0, uv);\n\n\t// sample the texture\n\tvec", "\n    return dot(plane.normal, pos - plane.position) / dot(plane.normal, plane.normal);\n}\n\nfloat", "Density = 0.0001;\n    // float n = perlin(ix, fx);\n    // return n;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return 0.0;\n    // return ", "\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors\n    // we also need to use integer coordinates\n    // to avoid floating point errors", "\n    float s = p.y - h;\n    float d = length(p.xz) - r;\n    return max(s, d);\n}\n\nfloat", "\n     p.xz *= mat2(1.0, 0.0, 0.0, 1.0);\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5;\n     p.y *= 0.5;\n     p.xz *= 0.5", "\n  // eps.yxy <=> vec3(0.  , 0.001, 0.   )\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n  // eps.yxy <=> vec3(0.  , 0.  , 0.001)\n ", "\n                                      //      v\n                                      //     /\n                                      //    /\n                                      //   /\n                                      //  /\n                                      // /\n                                      ///\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                      //\n                                     ", "\n    vec3 b = rd * ra - ro;\n    vec3 c = b * b - vec3( 1.0 );\n    vec3 d = sqrt( c );\n    vec3 t = -b - d;\n    vec3 t1 = -b + d;\n    float t0 = max( t.x, max( t.y, t.z ) );\n    float t1 = min( t.x, min( t.y, t.z ) );\n    float t2 = max( t1.x, t1.y );\n    float t3 = min( t1.x, t1.y );\n    float t4 = max( t2, t3 );\n    float t5 = min( t2, t3 );\n    float t6 = max( t4, t5 );\n    float t7 = min( t4, t5 );\n    float t8 = max( t6, t7 );\n    float t9 = min( t6, t7 );\n    float t10 = max( t8, t9 );\n    float t11 = min( t8, t9 );\n    float t12 = max( t10, t11 );\n    float t13 = min( t10, t11 );\n    float t14 = max( t12, t13 );\n    float t15 = min( t12, t13 );\n    float t16 = max( t14, t15 );\n    float t17 = min( t14, t15 );\n    float t18 = max( t16, t17 );\n    float t19 = min( t16, t17 );\n    float t20 = max( t18, t19 );\n    float t21 = min( t18, t19 );\n    float t22 = max( t20, t21 );\n    float t23 = min( t20, t21 );\n    float t24 = max( t22, t23 );\n    float t25 = min( t22, t23 );\n    float t26 =", "\n    float k = 0.0;\n    k += (1.0 - dpdx.x) * (1.0 - dpdx.y);\n    k += (1.0 - dpdy.x) * (1.0 - dpdy.y);\n    k += (1.0 + dpdx.x) * (1.0 + dpdx.y);\n    k += (1.0 + dpdy.x) * (1.0 + dpdy.y);\n    k *= 0.25;\n    return k;\n}\n\nfloat", "\n    Sphere[0].center.x = 0.0;\n    Sphere[0].center.y = 0.0;\n    Sphere[0].center.z = 0.0;\n    Sphere[0].radius = 1.0;\n    Sphere[0].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[1].center.x = -1.0;\n    Sphere[1].center.y = 0.0;\n    Sphere[1].center.z = 0.0;\n    Sphere[1].radius = 1.0;\n    Sphere[1].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[2].center.x = 1.0;\n    Sphere[2].center.y = 0.0;\n    Sphere[2].center.z = 0.0;\n    Sphere[2].radius = 1.0;\n    Sphere[2].materialID = 0;\n\n    // Top bouncing sphere.\n    Sphere[3].center.x = 0.0;\n    Sphere[3].center.y = 1.0;\n    Sphere[3].center.z = 0.0;\n    Sphere[3].radius = 1.0;\n    Sphere[3].materialID = 0;\n\n    // Bottom bouncing sphere.\n    Sphere[4].center.x = 0.0;\n    Sphere[4].center.y = -1.0;\n    Sphere[4].center.z = 0.0;\n    Sphere[4].radius = 1.0;\n    Sphere[4].materialID = 0;\n\n    // Back bouncing sphere.\n    Sphere[5].center.x = 0.0;\n    Sphere[5].center.y = 0.0;\n    Sphere[5].center.z = -1.0;\n    Sphere[5].radius = 1.0;\n    Sphere[5].materialID = 0;\n\n    // Front bouncing sphere.\n    Sphere[6].center.x = 0.0;\n    Sphere[6].center.y = 0.0;\n    Sphere", "\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n", "\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n    // TASK: FILL IN YOUR CODE HERE. //\n    ///////////////////////////////////////\n\n    ///////////////////////////////////////\n", "\n    // Return the hit point, normal, and color.\n    // If no hit, return black.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the color of the closest hit.\n    // If multiple hits, return the", "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // clamp intersection times\n    tmin = max( tmin, 0.0 );\n    tmax = min( tmax, tmax.x );\n\n    // ray-sphere intersection\n    float b = dot( ro, rd );\n    float c = dot( ro, ro ) - 1.0;\n    float h = b*b - c;\n    if( h < 0.0 ) return 0.0;\n    h = sqrt( h );\n    float t = -b - h;\n    if( t < tmin.x ) t = -b + h;\n    if( t > tmax.x ) return 0.0;\n\n    // shadow\n    float shadow = 0.0;\n    for( int i = 0; i < 10; i++ )\n    {\n        float ht = t + float( i ) * 0.1;\n        vec3 p = ro + ht * rd;\n        float d = texture( shadowMap, p.xy ).x;\n        shadow += max( 0.0, ht - d );\n    }\n    shadow /= 10.0;\n\n    // soft shadow\n    float attenuation = 1.0 - exp( -shadow * 0.001 );\n    return attenuation;\n}\n\nvoid main()\n{\n    // camera\n    vec3 ro = vec3( 0.0, 0.0, 10.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 up = vec3( 0.0, 1.0, 0.0 );\n", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0f - c;\n\n    return mat3(oc * axis.x * axis.x + c, oc * axis.x * axis.y - axis.z * s, oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s, oc * axis.y * axis.y + c, oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s, oc * axis.y * axis.z + axis.x * s, oc * axis.z * axis.z + c);\n}\n\nvec", "\n    vec3 offset = vec3(0.0, 0.0, 0.0);\n    offset.x = planet_position.x - start.x;\n    offset.y = planet_position.y - start.y;\n    offset.z = planet_position.z - start.z;\n\n    // the rayleigh scattering\n    vec3 rayleigh_scat = vec3(0.0, 0.0, 0.0);\n\n    // the mie scattering\n    vec3 mie_scat = vec3(0.0, 0.0, 0.0);\n\n    // the absorption\n    vec3 absorption = vec3(0.0, 0.0, 0.0);\n\n    // the ambient\n    vec3 ambient = vec3(0.0, 0.0, 0.0);\n\n    // the color of the ray\n    vec3 ray_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the light\n    vec3 light_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the atmosphere\n    vec3 atmo_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the planet\n    vec3 planet_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the sun\n    vec3 sun_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the background\n    vec3 background_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the sky\n    vec3 sky_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the moon\n    vec3 moon_color = vec3(0.0, 0.0, 0.0);\n\n    // the color of the moon\n    ve", "\n    vec3 light_dir_bend = normalize(light_dir + surface_normal * 0.001);\n\n    // calculate the cosine of the angle between the surface normal and the light direction\n    float cos_theta = dot(surface_normal, light_dir_bend);\n\n    // calculate the cosine of the angle between the surface normal and the view direction\n    float cos_alpha = dot(surface_normal, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_beta = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_gamma = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_delta = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_epsilon = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_zeta = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_prime = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_double = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_triple = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction and the view direction\n    float cos_theta_quadruple = dot(light_dir_bend, normalize(view_dir));\n\n    // calculate the cosine of the angle between the light direction", "\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // the ray direction\n    vec3 ray_dir = normalize(dir);\n    \n    // the ray origin\n    vec3 ray_origin = pos;\n    \n    // the ray origin\n    vec3 light_origin = vec3(0.0, 0.0, 0.0);\n    \n    // the ray direction\n    vec3 light_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // get the ray direction\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(p.xy, 2.0));\n    \n    // get the raymarching parameters\n    float t = 0.0;\n    float tmax = 100.0;\n    float tmin = 0.001;\n    float tinc = 0.001;\n    float tdec = 0.001;\n    float tmin_inc = 0.001;\n    float tmin_dec = 0.001;\n    float tmax_inc = 0.001;\n    float tmax_dec = 0.001;\n    float tmin_inc_dec = 0.001;\n    float tmax_inc_dec = 0.001;\n    float tmin_inc_dec_inc = 0.001;\n    float tmax_inc_dec_inc = 0.001;\n    float tmin_inc_dec_inc_dec = 0.001;\n    float tmax_inc_dec_inc_dec = 0.001;\n    float tmin_inc_dec_inc_dec_inc = 0.001;\n    float tmax_inc_dec_inc_dec_inc = 0.001;\n    float tmin_inc_dec_inc_dec_inc_dec = 0.001;\n    float tmax_inc_dec_inc_dec_inc_dec = 0.001;\n    float tmin_inc_dec_inc_dec_inc_dec_inc = 0.001;\n    float tmax_inc_dec_inc_dec_inc_dec_inc = 0.001;\n    float tmin_inc_dec_inc_dec_inc_dec_inc_", "\n\n    // Compute a\n    vec3 a = r0 - s0;\n\n    // Compute b\n    float b = dot(a, rd);\n\n    // Compute c\n    float c = dot(a, a) - sr * sr;\n\n    // Compute discriminant\n    float discriminant = b * b - c;\n\n    // If discriminant is negative, there are no real roots, so return -1.0\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n\n    // Compute the square root of the discriminant\n    float sqrtDiscriminant = sqrt(discriminant);\n\n    // Compute the smaller and larger root\n    float root1 = -b - sqrtDiscriminant;\n    float root2 = -b + sqrtDiscriminant;\n\n    // If root1 is negative, use root2 instead\n    if (root1 < 0.0) {\n        root1 = root2;\n    }\n\n    // Return the smaller root\n    return root1;\n}\n\n// Compute the intersection point of a ray and a sphere\nvec", "ialize variables\n    vec3 color = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightAmbient = vec3(0.0);\n    vec3 lightDiffuse = vec3(0.0);\n    vec3 lightSpecular = vec3(0.0);\n    vec3 lightSpotDir = vec3(0.0);\n    vec3 lightSpotColor = vec3(0.0);\n    vec3 lightSpotIntensity = vec3(0.0);\n    vec3 lightSpotAttenuation = vec3(0.0);\n    vec3 lightSpotAmbient = vec3(0.0);\n    vec3 lightSpotDiffuse = vec3(0.0);\n    vec3 lightSpotSpecular = vec3(0.0);\n    vec3 lightSpotSpotDir = vec3(0.0);\n    vec3 lightSpotSpotColor = vec3(0.0);\n    vec3 lightSpotSpotIntensity = vec3(0.0);\n    vec3 lightSpotSpotAttenuation = vec3(0.0);\n    vec3 lightSpotSpotAmbient = vec3(0.0);\n    vec3 lightSpotSpotDiffuse = vec3(0.0);\n    vec3 lightSpotSpotSpecular = vec3(0.0);\n    vec3 lightSpotSpotSpotDir = vec3(0.0);\n    vec3 lightSpotSpotSpotColor = vec3(0.0);\n    vec3 lightSpotSpotSpotIntensity = vec3(0.0);\n    vec3 lightSpotSpotSpotAttenuation =", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", " ray\n    ray_queue.push_back(ray_origin);\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray_origin = ray_origin;\n    vec3 sample_ray_target = ray_target;\n\n    // Initialize the sample ray -\n    // the ray that will be used to", "\n    vec2 cell = floor(p);\n    vec2 f = fract(p);\n    \n    // Local cell coordinates.\n    vec2 c = cell;\n    \n    // Local cell ID.\n    float cellID = cell.x + cell.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c2 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID2 = c2.x + c2.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c3 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID3 = c3.x + c3.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c4 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID4 = c4.x + c4.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c5 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID5 = c5.x + c5.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c6 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID6 = c6.x + c6.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c7 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID7 = c7.x + c7.y * 57.0;\n    \n    // Local cell coordinates.\n    vec2 c8 = c + vec2(f.x, f.y);\n    \n    // Local cell ID.\n    float cellID8 = c8.x + c8.y * 57.0;\n    ", "\n    vec3 sphere_center = vec3(0.0, 0.0, 0.0);\n    float sphere_radius = 1.0;\n\n    // calculate distance from sphere center\n    float dist = length(p - sphere_center) - sphere_radius;\n\n    return dist;\n}\n\n// calculate the color of the sphere\nvec", "\n    vec3 Pi = floor( P );\n    vec3 Pf = P - Pi;\n\n    // establish our 4 corners of the grid cell\n    vec3 P0 = Pi;\n    vec3 P1 = Pi + vec3( 1.0 );\n    vec3 P2 = Pi + vec3( 1.0, 1.0 );\n    vec3 P3 = Pi + vec3( 1.0, 1.0, 1.0 );\n\n    // establish our 4 values of the corners\n    vec3 P000 = P0;\n    vec3 P100 = P1;\n    vec3 P010 = P2;\n    vec3 P110 = P3;\n\n    // establish our 4 values of the corners\n    vec3 P001 = P0 + vec3( 1.0 );\n    vec3 P101 = P1 + vec3( 1.0 );\n    vec3 P011 = P2 + vec3( 1.0 );\n    vec3 P111 = P3 + vec3( 1.0 );\n\n    // establish our 4 values of the corners\n    vec3 P002 = P0 + vec3( 1.0, 1.0 );\n    vec3 P102 = P1 + vec3( 1.0, 1.0 );\n    vec3 P012 = P2 + vec3( 1.0, 1.0 );\n    vec3 P112 = P3 + vec3( 1.0, 1.0 );\n\n    // establish our 4 values of the corners\n    vec3 P003 = P0 + vec3( 1.0, 1.0, 1.0 );\n    vec3 P103 = P1 + vec3( 1.0, 1.0, 1.0 );\n    vec3 P013 = P2 + vec3( 1.0, 1.0, 1.0 );\n   ", "\n    float t = x * 10.0;\n    float s = sin(t);\n    float r = cos(t);\n    float b = sin(t*2.0);\n    float g = cos(t*2.0);\n    float a = sin(t*3.0);\n    float n = cos(t*3.0);\n    \n    // return\n    return (s+r+b+g+a+n)/6.0;\n}\n\nfloat", "\n    float x = p.x;\n    float y = p.y;\n    float z = p.z;\n    float t = (x + y + z) / 3.0;\n    float ground = (sin(t) + 1.0) / 2.0;\n    p.y -= ground;\n\n    // water\n    t = (x + y + z) / 3.0;\n    float water = (sin(t) + 1.0) / 2.0;\n    p.y += water;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // snow\n    t = (x + y + z) / 3.0;\n    float snow = (sin(t) + 1.0) / 2.0;\n    p.y += snow;\n\n    // rock\n    t = (x + y + z) / 3.0;\n    float rock = (sin(t) + 1.0) / 2.0;\n    p.y += rock;\n\n    // sand\n    t = (x + y + z) / 3.0;\n    float sand = (sin(t) + 1.0) / 2.0;\n    p.y += sand;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin(t) + 1.0) / 2.0;\n    p.y += grass;\n\n    // grass\n    t = (x + y + z) / 3.0;\n    float grass = (sin", " space to screen space\n    vec2 p2 = (p.xy / p.z) * 0.5 + 0.5;\n    // map to [-1, 1]\n    p2 = p2 * 2.0 - 1.0;\n    // map to [-0.5, 0.5]\n    p2 = p2 * 0.5 + 0.5;\n    return p2;\n}\n\nvoid main()\n{\n    vec2 p = map(gl_FragCoord.xy);\n    vec2 q = map(gl_FragCoord.xy + vec2(0.0, 1.0));\n    vec2 r = map(gl_FragCoord.xy + vec2(1.0, 0.0));\n    vec2 s = map(gl_FragCoord.xy + vec2(0.0, -1.0));\n    vec2 t = map(gl_FragCoord.xy + vec2(-1.0, 0.0));\n\n    vec2 d = fwidth(p);\n    vec2 e = fwidth(q);\n    vec2 f = fwidth(r);\n    vec2 g = fwidth(s);\n    vec2 h = fwidth(t);\n\n    vec2 i = smoothstep(d, d + e, p);\n    vec2 j = smoothstep(f, f + g, q);\n    vec2 k = smoothstep(h, h + i, r);\n    vec2 l = smoothstep(j, j + k, s);\n    vec2 m = smoothstep(l, l + m, t);\n\n    float n = max(max(m.x, m.y), max(l.x, l.y));\n    gl_FragColor = vec4(n);\n}\n", " from a to b\n    float t = (p.x - a.x) / (b.x - a.x);\n    if (t < 0.0) return 0.0;\n    if (t > 1.0) return 0.0;\n    float y = a.y + t * (b.y - a.y);\n    if (y < pix) return 0.0;\n    if (y > d - pix) return 0.0;\n    return 1.0;\n}\n\nfloat", "\n\t//st.x *= iResolution.x/iResolution.y;\n\tvec2 st = fragCoord/iResolution.xy;\n\tst.x *= iResolution.x/iResolution.y;\n\tvec2 p = st;\n\tfloat t = iGlobalTime;\n\tfloat a = 0.0;\n\tfloat b = 0.0;\n\tfloat c = 0.0;\n\tfloat d = 0.0;\n\tfloat e = 0.0;\n\tfloat f = 0.0;\n\tfloat g = 0.0;\n\tfloat h = 0.0;\n\tfloat i = 0.0;\n\tfloat j = 0.0;\n\tfloat k = 0.0;\n\tfloat l = 0.0;\n\tfloat m = 0.0;\n\tfloat n = 0.0;\n\tfloat o = 0.0;\n\tfloat p = 0.0;\n\tfloat q = 0.0;\n\tfloat r = 0.0;\n\tfloat s = 0.0;\n\tfloat t = 0.0;\n\tfloat u = 0.0;\n\tfloat v = 0.0;\n\tfloat w = 0.0;\n\tfloat x = 0.0;\n\tfloat y = 0.0;\n\tfloat z = 0.0;\n\tfloat aa = 0.0;\n\tfloat ab = 0.0;\n\tfloat ac = 0.0;\n\tfloat ad = 0.0;\n\tfloat ae = 0.0;\n\tfloat af = 0.0;\n\tfloat ag = 0.0;\n\tfloat ah = 0.0;\n\tfloat ai = 0.0;\n\tfloat aj = 0.0;\n\tfloat ak = 0.0;\n\tfloat al = 0.0;\n\tfloat am = 0.0;\n\tfloat an = 0.0;\n\tfloat ao = 0.0;\n\tfloat ap = 0.0;\n\tfloat aq = 0.0;\n\tfloat ar = 0.0;\n\tfloat as = 0.0;\n\tfloat at = 0.0;\n\tfloat au = 0.0;\n\tfloat av = 0.0;\n\tfloat", "\n    if(p.x < 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat bottom and pointed bottom hexagons.\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat left and pointed left hexagons.\n    if(p.x < 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    \n    // Flat right and pointed right hexagons.\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat center and pointed center hexagons.\n    if(p.x < 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y < 0.5){\n        return 0.0;\n    }\n    if(p.x < 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    if(p.x > 0.5 && p.y > 0.5){\n        return 0.0;\n    }\n    \n    // Flat center and pointed center hexagons.\n    if(p.x < ", "\n    return (sin(ix*iy*12453+136*pow(ix+15, iy%16)+sin(iy*1600)*1376+ix*656+iy*75)%1000)/1000;\n}\n\nfloat", "\n    vec3 p2 = rotate( p, vec3( 0.0, 0.0, 0.0 ) );\n\n    // map the solution space to the unit sphere\n    vec3 p3 = p2 / length( p2 );\n\n    // map the solution space to the unit cube\n    vec3 p4 = p3 * 0.5 + 0.5;\n\n    // map the solution space to the unit cube\n    vec3 p5 = p4 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p6 = p5 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p7 = p6 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p8 = p7 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p9 = p8 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p10 = p9 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p11 = p10 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p12 = p11 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p13 = p12 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p14 = p13 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p15 = p14 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p16 = p15 * 2.0 - 1.", "\n    return (p - 0.5) * 2.0;\n}\n\nfloat", "\n    return vec2(atan2(z.y,z.x),length(z));\n}\n\nvec", "\n    return (vec2){z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x};\n}\n\nvec", "\n\t vec3 s = p - vec3(floor(p));\n\t vec3 x = p - s;\n\t \n\t /* calculate i1, i2, and 1.0 - x */\n\t vec3 i1 = step(vec3(0.0), x);\n\t vec3 i2 = step(vec3(1.0), x);\n\t vec3 x3 = 1.0 - x;\n\t \n\t /* calculate T and four vertices of T */\n\t vec4 T = vec4(s, i1.x) + vec4(s, i2.x) + vec4(s, 1.0, i1.y) + vec4(s, 1.0, i2.y);\n\t vec3 v0 = vec3(T) / 4.0;\n\t vec3 v1 = v0 + vec3(i1.xyy, 0.0);\n\t vec3 v2 = v0 + vec3(i2.xyy, 0.0);\n\t vec3 v3 = v0 + vec3(1.0, i1.xyy);\n\t \n\t /* calculate w, the barycentric coordinates of p relative to T */\n\t vec3 w = x3 * (x3 * (x3 * v0) + i1.z * (x2 * v1 + x * v2)) + i2.z * (x3 * v3 + x * v0);\n\t \n\t /* return the dot product of w and n */\n\t return dot(w, vec3(0.57735026918962576450914878050195745564887086954052300113832952210791614262294101264442748062243388305015030054794086342643848110487108", " wave\n    float wave = sin( p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    // drop another wave\n    wave = sin( wave * 0.01 + p.x * 0.01 + p.y * 0.01 + p.z *", " in the final image\n    p.xz *= 0.5;\n    p.y *= 0.5;\n\n    // rotate the space\n    p = rotate( p, 0.01 );\n\n    // scale the space\n    p *= 0.5;\n\n    // add some noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0, 0.0, 0.001 );\n\n    // add some more noise\n    p += vec3( 0.0", "\n    //float k = floor(rp.y*.75)*.25;\n    //float k = floor(rp.z*.75)*.25;\n    //return k;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;\n    //return 0.0;", "\n\tfloat t = (end - d) / (end - start);\n\treturn clamp(t, 0.0, 1.0);\n}\n\n// \u30b9\u30af\u30ea\u30fc\u30f3\u5ea7\u6a19\u304b\u3089\u30ef\u30fc\u30eb\u30c9\u5ea7\u6a19\u306b\u5909\u63db\u3059\u308b\u3002\nvec", "\n    vec4 hex = vec4(0.0);\n    \n    // The hexagon center is the point that is closest to the current point.\n    if (p.x < p.y)\n    {\n        hex = vec4(p.x, p.y, 0.0, 0.0);\n    }\n    else\n    {\n        hex = vec4(p.y, p.x, 0.0, 1.0);\n    }\n    \n    // The hexagon center is unique, so we can use it to index into the hexagon array.\n    return hex;\n}\n\n// This function returns the hexagon center that is closest to the current point.\nvec", "\n    float x = fract(sin(dot(p,vec2(127.1,311.7)))*43758.5453);\n    float y = fract(sin(dot(p,vec2(269.5,183.3)))*23325.4236);\n    \n    // Four by four cell random value.\n    x += fract(sin(dot(p,vec2(113.1,325.4)))*43758.5453);\n    y += fract(sin(dot(p,vec2(271.5,181.3)))*23325.4236);\n    \n    // Eight by eight cell random value.\n    x += fract(sin(dot(p,vec2(137.1,321.7)))*43758.5453);\n    y += fract(sin(dot(p,vec2(281.5,189.3)))*23325.4236);\n    \n    // Sixteen by sixteen cell random value.\n    x += fract(sin(dot(p,vec2(117.1,311.7)))*43758.5453);\n    y += fract(sin(dot(p,vec2(269.5,183.3)))*23325.4236);\n    \n    // Thirty-two by thirty-two cell random value.\n    x += fract(sin(dot(p,vec2(137.1,321.7)))*43758.5453);\n    y += fract(sin(dot(p,vec2(281.5,189.3)))*23325.4236);\n    \n    // Sixty-four by sixty-four cell random value.\n    x += fract(sin(dot(p,vec2(117.1,311.7)))*43758.5453);\n    y += fract(sin(", "\n    float scale = (mouse.x - 0.5) / 0.5;\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    }\n    else if (scale < 0.0) {\n        color = vec3(0.0, 1.0, 0.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color2 = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0) {\n        color2 = vec3(0.0, 0.0, 1.0);\n    }\n    else if (scale < 0.0) {\n        color2 = vec3(0.0, 0.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color3 = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0) {\n        color3 = vec3(0.0, 1.0, 1.0);\n    }\n    else if (scale < 0.0) {\n        color3 = vec3(0.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse", " from the center\n    //of the spiral\n    float theta = acos(a/b);\n    \n    //Solve for the polar coordinate (r, theta)\n    //of the point pc\n    vec2 pcPolar = vec2(length(pc), theta);\n    \n    //Check if the point pc is on the spiral\n    if(pcPolar.x <= a && pcPolar.y <= b){\n        return 1.0;\n    }\n    else{\n        return 0.0;\n    }\n}\n\n//Check if the point pc is on the spiral\n//(a,b) = (a+b*theta, theta)\n//where theta is the angle between the x-axis and the\n//line from the center of the spiral to the point pc\nfloat", "\n    return smoothstep(0.0, 1.0, pct);\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\n    vec3 color = vec3(0.0);\n\n    float pct = plot(st, u_time);\n    color = mix(vec3(0.0), vec3(1.0), pct);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    //\n    // I'm not going to go into the details of the math here, but I'll say that\n    // the following is the formula for the distance from the center of the \n    // initial circle to the center of the circle that runs adjacent to the \n    // current domain edges.\n    //\n    // d = (r * sin(theta)) / sin(theta + pi/2)\n    //\n    // The following is the formula for the radius of the initial circle.\n    //\n    // r = (1 - cos(theta)) / sin(theta + pi/2)\n    //\n    // The following is the formula for the angle theta.\n    //\n    // theta = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.\n    //\n    // theta + pi/2 = acos((1 - cos(theta)) / sin(theta + pi/2))\n    //\n    // The following is the formula for the angle theta + pi/2.", "\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    //\n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't", "\n    vec2 mouse = vec2(mousePos.x, mousePos.y);\n    \n    // Mouse inversion.\n    vec2 mouseInversion = (p - mouse) * -1.0;\n    \n    // Return mouse inversion.\n    return mouseInversion;\n}\n\n// Mouse inversion.\nvec", "\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos2 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos3 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos4 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos5 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos6 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos7 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos8 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos9 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos10 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos11 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos12 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos13 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos14 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos15 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos16 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos17 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos18 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos19 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos20 =", "\n\tvec3 cameraPos = vec3(0.0, 0.0, 0.0);\n\tvec3 cameraTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 cameraUp = vec3(0.0, 1.0, 0.0);\n\tvec3 cameraRight = vec3(1.0, 0.0, 0.0);\n\tfloat cameraFov = 45.0;\n\tfloat cameraNear = 0.1;\n\tfloat cameraFar = 100.0;\n\n\t// Light Orientation\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 lightUp = vec3(0.0, 1.0, 0.0);\n\tvec3 lightRight = vec3(1.0, 0.0, 0.0);\n\tfloat lightFov = 45.0;\n\tfloat lightNear = 0.1;\n\tfloat lightFar = 100.0;\n\n\t// Lighting\n\tvec3 lightColor = vec3(1.0, 1.0, 1.0);\n\tvec3 lightAmbient = vec3(0.1, 0.1, 0.1);\n\tvec3 lightDiffuse = vec3(0.5, 0.5, 0.5);\n\tvec3 lightSpecular = vec3(0.5, 0.5, 0.5);\n\tfloat lightShininess = 10.0;\n\n\t// Material\n\tvec3 materialAmbient = vec3(0.1, 0.1, 0.1);\n\tvec3 materialDiffuse = vec3(0.5, 0.5, 0.5);\n\tvec3 materialSpecular = vec3(0.5, 0.5, 0.5);\n\tfloat materialShininess = 10.0;\n\n\t// Texture\n\tvec3 textureColor = vec3(0", "\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position of the fragment\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Compute the color of the fragment\n    vec3 color = vec3(0.0);\n\n    // Compute the position", " axis\n    float x = (hash - 0.5) * 2.0;\n    float y = (hash - 0.5) * 2.0;\n    float z = (hash - 0.5) * 2.0;\n    \n    // Random gradient of a cube, +/- 1 each axis\n    float gx = (hash - 0.5) * 2.0;\n    float gy = (hash - 0.5) * 2.0;\n    float gz = (hash - 0.5) * 2.0;\n    \n    // Return the gradient\n    return vec3(gx, gy, gz);\n}\n\n// Compute the dot product of a normal and a gradient\nfloat", "\n    vec3 Y = normalize(cross(X, vec3(0.0, 1.0, 0.0)));\n    vec3 Z = cross(Y, X);\n    \n    // Rotation matrix.\n    mat3 rot = mat3(\n        Y,\n        Z,\n        X\n    );\n    \n    // Skew transform.\n    mat3 skew = mat3(\n        0.0, 1.0, 0.0,\n        -1.0, 0.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot = skew * rot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot2 = skewRot * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot3 = skewRot2 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot4 = skewRot3 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot5 = skewRot4 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot6 = skewRot5 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot7 = skewRot6 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot8 = skewRot7 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot9 = skewRot8 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot10 = skewRot9 * skewRot;\n    \n    // Skew transform applied to the rotation matrix.\n    mat3 skewRot11 = skewRot10 * skewRot;\n    \n   ", "\n  float d = p.y;\n  // distance from the point `p` to the center of the Y plane\n  float d2 = p.x * p.x + p.z * p.z;\n  // distance from the point `p` to the center of the Y plane\n  float d3 = p.y * p.y;\n  // distance from the point `p` to the center of the XZ plane\n  float d4 = p.x * p.x + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d5 = p.x * p.x + p.y * p.y;\n  // distance from the point `p` to the center of the XZ plane\n  float d6 = p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d7 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d8 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d9 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d10 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d11 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d12 = p.x * p.x + p.y * p.y + p.z * p.z;\n  // distance from the point `p` to the center of the XZ plane\n  float d", "\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub41c\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub41c\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ud655\ud558\uac8c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\uc73c\uba74, \uc815\ufffd", "\n\tmat2 rot = mat2(cos(time), -sin(time), sin(time), cos(time));\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv = rot * uv;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\tvec3 col = vec3(0.0);\n\t\n\tfloat d = length(uv);\n\t\n\tfloat a = atan(uv.y, uv.x);\n\t\n\tfloat r = (d - 0.5) * 2.0;\n\t\n\tfloat t = time * 0.5;\n\t\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n\t\n\tfloat x = r * c;\n\tfloat y = r * s;\n\t\n\tfloat x2 = x * x;\n\tfloat y2 = y * y;\n\t\n\tfloat x3 = x2 * x;\n\tfloat y3 = y2 * y;\n\t\n\tfloat x4 = x3 * x;\n\tfloat y4 = y3 * y;\n\t\n\tfloat x5 = x4 * x;\n\tfloat y5 = y4 * y;\n\t\n\tfloat x6 = x5 * x;\n\tfloat y6 = y5 * y;\n\t\n\tfloat x7 = x6 * x;\n\tfloat y7 = y6 * y;\n\t\n\tfloat x8 = x7 * x;\n\tfloat y8 = y7 * y;\n\t\n\tfloat x9 = x8 * x;\n\tfloat y9 = y8 * y;\n\t\n\tfloat x10 = x9 * x;\n\tfloat y10 = y9 * y;\n\t\n\tfloat x11 = x10 * x;\n\tfloat y11 = y10 * y;\n\t\n\tfloat x12 = x11 * x;\n\tfloat y12 = y11 * y;\n\t\n\tfloat x13 = x12 * x;\n\tfloat y13 = y12 * y;\n\t\n\tfloat x", "-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos-AdditionalParams-Color-\n    //-Pos", "\n    vec3 lightPos = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 lightDir = normalize( lightPos - targetPos );\n    vec3 viewDir = normalize( ray.origin - targetPos );\n    vec3 halfDir = normalize( lightDir + viewDir );\n    \n    float NdotL = max( 0.0f, dot( lightDir, halfDir ) );\n    float NdotV = max( 0.0f, dot( lightDir, viewDir ) );\n    float NdotH = max( 0.0f, dot( lightDir, normalize( vec3( 0.0f, 1.0f, 0.0f ) ) ) );\n    \n    float NdotH2 = NdotH * NdotH;\n    float NdotH4 = NdotH2 * NdotH2;\n    float NdotH6 = NdotH4 * NdotH2;\n    float NdotH8 = NdotH6 * NdotH2;\n    \n    float NdotH10 = NdotH8 * NdotH2;\n    float NdotH12 = NdotH10 * NdotH2;\n    float NdotH14 = NdotH12 * NdotH2;\n    float NdotH16 = NdotH14 * NdotH2;\n    \n    float NdotH18 = NdotH16 * NdotH2;\n    float NdotH20 = NdotH18 * NdotH2;\n    float NdotH22 = NdotH20 * NdotH2;\n    float NdotH24 = NdotH22 * NdotH2;\n    \n    float NdotH26 = NdotH24 * NdotH2;\n    float NdotH28 = NdotH26 * NdotH2;\n    float NdotH30 = NdotH28 * NdotH2;\n    float NdotH32 = NdotH30 * NdotH2;\n    \n    float NdotH34 = NdotH3", "\n    // p.y -= 1.;\n    // p.z -= 1.;\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / ", "\n    float t = x * PI;\n    float s = sin(t);\n    float c = cos(t);\n    float r = fract(x);\n\n    // first octave\n    r = r * (1.0 + s * 0.5);\n\n    // second octave\n    r = r * (1.0 + s * 0.25);\n\n    // third octave\n    r = r * (1.0 + s * 0.125);\n\n    // fourth octave\n    r = r * (1.0 + s * 0.0625);\n\n    // fifth octave\n    r = r * (1.0 + s * 0.03125);\n\n    // sixth octave\n    r = r * (1.0 + s * 0.015625);\n\n    // seventh octave\n    r = r * (1.0 + s * 0.0078125);\n\n    // eighth octave\n    r = r * (1.0 + s * 0.00390625);\n\n    // ninth octave\n    r = r * (1.0 + s * 0.001953125);\n\n    // tenth octave\n    r = r * (1.0 + s * 0.0009765625);\n\n    // finaly\n    return r;\n}\n\nfloat", " to find the area of the triangle\n    float area = abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_uv = abs(uv.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_p1 = abs(p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_p2 = abs(p2.x * (p3.y - p1.y) + p3.x * (p1.y - p2.y) + p1.x * (p2.y - p3.y)) / 2.0;\n    \n    //Find the area of the triangle\n    float area_p3 = abs(p3.x * (p1.y - p2.y) + p1.x * (p2.y - p3.y) + p2.x * (p3.y - p1.y)) / 2.0;\n    \n    //If the area of the triangle is less than the area of the triangle\n    if(area < area_uv){\n        \n        //Return true\n        return true;\n    }\n    \n    //If the area of the triangle is less than the area of the triangle\n    if(area < area_p1){\n        \n        //Return true\n        return true;\n    }\n    \n    //If the area of the triangle is less than the area of the triangle\n    if(area < area_p2){\n        \n        //Return true\n        return true;\n    }\n    ", "\n    float n = log(start_radius) / log(1.5);\n    \n    //Find the closest hexagon to the given uv\n    //https://math.stackexchange.com/a/1001000\n    float closest_hex_radius = pow(1.5, n);\n    float closest_hex_angle = atan2(uv.y, uv.x) + (2.0 * M_PI) / 6.0;\n    vec2 closest_hex_uv = vec2(closest_hex_radius * cos(closest_hex_angle), closest_hex_radius * sin(closest_hex_angle));\n    \n    return closest_hex_uv;\n}\n\n//https://www.shadertoy.com/view/4djSRW\nvec", ".\n    //\n    //The rotation of the hexagon is determined by the\n    //rotation of the equilateral.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hexagon.\n    //\n    //The rotation of the equilateral is the rotation\n    //of the hexagon.\n    //\n    //The circumradius of the equilateral is the\n    //circumradius of the hex", ".\n    //\n    //The circumradius of the isosceles is the distance\n    //between the two points of the isosceles.\n    //\n    //The rotation of the isosceles is the angle between\n    //the two points of the isosceles.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //current hexagon.\n    //\n    //The isosceles is the hexagon that is closest to the\n    //next hexagon.\n    //\n    //The isosceles is the hexagon that", "\n    return exp(-d*d*U.x*U.x - d*d*U.y*U.y);\n}\n\nfloat", "'s implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 61) ^ (n >> 16);\n    n = n + (n << 3);\n    n = n ^ (n >> 4);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash2(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 72) ^ (n >> 27);\n    n = n + (n << 3);\n    n = n ^ (n >> 11);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash3(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 150) ^ (n >> 10);\n    n = n + (n << 3);\n    n = n ^ (n >> 21);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 15);\n    return n;\n}\n\nuint hash4(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    // https://github.com/hugoelias/hash-functions/blob/master/hash.c\n    n = (n ^ 28) ^ (n >> 8);\n    n = n + (n << 3);\n    n = n ^ (n >> 14);\n    n = n * 0x27d4eb2d;\n    n = n ^ (n >> 18);\n    return n;\n}\n\nuint hash5(uint n)\n{", "\n    vec2 center = vec2(0.5);\n    // distance from center\n    vec2 dist = fragCoord - center;\n    // distance from center squared\n    float distSq = dot(dist, dist);\n    // distance from center cubed\n    float distCubed = dot(dist, distSq);\n    // distance from center cubed squared\n    float distCubedSq = dot(dist, distCubed);\n    // distance from center cubed cubed\n    float distCubedCubed = dot(dist, distCubedSq);\n    // distance from center cubed cubed squared\n    float distCubedCubedSq = dot(dist, distCubedCubed);\n    // distance from center cubed cubed cubed\n    float distCubedCubedCubed = dot(dist, distCubedCubedSq);\n    // distance from center cubed cubed cubed squared\n    float distCubedCubedCubedSq = dot(dist, distCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed\n    float distCubedCubedCubedCubed = dot(dist, distCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed\n    float distCubedCubedCubedCubedCubed = dot(dist, distCubedCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed cubed\n    float distCubedCubedCubedC", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", " to avoid division by zero\n  vec3 epsilon = vec3(0.0001, 0.0001, 0.0001);\n  return normalize(\n      vec3(\n          f(pos + epsilon.xyy) - f(pos - epsilon.xyy),\n          f(pos + epsilon.yxy) - f(pos - epsilon.yxy),\n          f(pos + epsilon.yyx) - f(pos - epsilon.yyx)));\n}\n\nvoid main() {\n  vec3 pos = (gl_FragCoord.xyz / resolution.xyz) * 2.0 - 1.0;\n  vec3 dir = normalize(pos);\n  vec3 color = vec3(0.0);\n  float t = 0.0;\n  for (int i = 0; i < 100; i++) {\n    t += f(pos) * 0.5;\n    pos += dir * f(pos) * 0.5;\n  }\n  color = vec3(t);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n  vec3 p = ro;\n  float t = 0.0;\n  float tmin = 0.001;\n  float tmax = 1000.0;\n  for (int i = 0; i < 100; i++) {\n    vec3 pos = p;\n    vec3 nor = vec3(0.0);\n    float dis = 0.0;\n    for (int j = 0; j < 10; j++) {\n      vec3 dp = p - pos;\n      float d = length(dp);\n      if (d < tmin) {\n        break;\n      }\n      if (d > tmax) {\n        break;\n      }\n      dis += d;\n      p = pos + dp;\n      nor = normalize(p);\n    }\n    if (dis < tmax) {\n      t = dis;\n    }\n    if (t < tmin) {\n      break;\n    }\n    p = pos + nor * 0.01;\n  }\n  // get color at hit point\n  vec3 col = vec3(0.0);\n  if (t < tmax) {\n    vec3 pos = p;\n    vec3 nor = normalize(pos);\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 view = normalize(rd);\n    vec3 halfv = normalize(light + view);\n    float ndotl = max(0.0, dot(nor, light));\n    float ndoth = max(0.0, dot(nor, halfv));\n    float spec = pow(ndoth, 16.0);\n    col = vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, ", " to avoid division by zero\n    vec3 epsilon = vec3(0.0001, 0.0001, 0.0001);\n    return normalize(vec3(\n        f(pos + epsilon.xyy) - f(pos - epsilon.xyy),\n        f(pos + epsilon.yxy) - f(pos - epsilon.yxy),\n        f(pos + epsilon.yyx) - f(pos - epsilon.yyx)\n    ));\n}\n\nvoid main() {\n    vec3 pos = vec3(gl_FragCoord.xy, 0.0);\n    vec3 normal = calcNormal(pos);\n    vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 diffuse = max(0.0, dot(normal, lightDir)) * vec3(1.0, 1.0, 1.0);\n    vec3 specular = pow(max(0.0, dot(reflect(-lightDir, normal), viewDir)), 16.0) * vec3(1.0, 1.0, 1.0);\n    vec3 color = (diffuse + specular) * vec3(1.0, 1.0, 1.0);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec3 p = castRay(ro, rd);\n    // get normal at hit point\n    vec3 n = getNormal(p);\n    // get color at hit point\n    vec3 c = getColor(p);\n    // get light at hit point\n    vec3 l = getLight(p);\n    // get ambient color\n    vec3 a = getAmbient(p);\n    // get diffuse color\n    vec3 d = getDiffuse(p, l);\n    // get specular color\n    vec3 s = getSpecular(p, l, n);\n    // get final color\n    vec3 col = a + d + s;\n    // return final color\n    return col;\n}\n\nvoid main() {\n    // get ray direction\n    vec3 rd = normalize(vec3(uv, 1.0));\n    // get ray origin\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    // get color at ray origin\n    vec3 col = render(ro, rd);\n    // set color\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 color = texture(texture_diffuse1, p).rgb;\n    //surface normal for bump mapping\n    vec3 normal = texture(texture_normal1, p).rgb;\n    normal = normalize(normal * 2.0 - 1.0);\n    return normal;\n}\n\nvoid main()\n{\n    vec3 viewDir = normalize(viewPos - fragPos);\n    vec3 lightDir = normalize(lightPos - fragPos);\n    vec3 normal = estimateNormal(fragPos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 32.0);\n    vec3 specular = spec * lightColor;\n    vec3 ambient = lightColor * 0.1;\n    vec3 diffuse = lightColor * max(dot(normal, lightDir), 0.0);\n    vec3 result = (ambient + diffuse + specular) * color;\n    FragColor = vec4(result, 1.0);\n}", "\n    return (float)q.x + (float)q.y * 1000000000.0;\n}\n\n// This is a simple hash function that is used to generate a random number.\n// It is not a good hash function, but it is good enough for our purposes.\n// You SHOULD replace this by something better. Again, Do Not Use in production.\nfloat", "el grid\n\tvec2 texel = coord * 16.0;\n\tvec2 texel_floor = floor( texel );\n\tvec2 texel_frac = texel - texel_floor;\n\n\tvec2 texel_offset = vec2( 0.0, 0.0 );\n\ttexel_offset.x = texel_frac.x * 16.0;\n\ttexel_offset.y = texel_frac.y * 16.0;\n\n\tvec2 texel_offset_floor = floor( texel_offset );\n\tvec2 texel_offset_frac = texel_offset - texel_offset_floor;\n\n\tvec2 texel_offset_floor_texel = texel_offset_floor / 16.0;\n\tvec2 texel_offset_frac_texel = texel_offset_frac / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel = texel_offset_floor_texel / 16.0;\n\tvec2 texel_offset_frac_texel_texel = texel_offset_frac_texel / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel_texel = texel_offset_floor_texel_texel / 16.0;\n\tvec2 texel_offset_frac_texel_texel_texel = texel_offset_frac_texel_texel / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel_texel_texel = texel_offset_floor_texel_texel_texel / 16.0;\n\tvec2 texel_offset_frac_texel_texel_texel_texel = texel_offset_frac_texel_texel_texel / 16.0;\n\n\tvec2 texel_offset_floor_texel_texel_texel_texel_texel = texel_", "\n    p.x = abs(p.x);\n\n    // rotate\n    p.x = cos(p.y) * p.x + sin(p.y) * p.y;\n    p.y = -sin(p.y) * p.x + cos(p.y) * p.y;\n\n    // scale\n    p.x *= ab.x;\n    p.y *= ab.y;\n\n    // translate\n    p.x += ab.x * 0.5;\n    p.y += ab.y * 0.5;\n\n    return p;\n}\n\nvec", "\n    p = fmod(p, 1.0);\n    if (p < 0.0)\n        p += 1.0;\n    p *= 10000.0;\n    return vec3(p, p + 1.0, p + 2.0);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n\n    // Get the position of the fragment\n    vec2 position = fragCoord.xy / iResolution.xy;\n\n    // Get the position of the fragment in the screen\n    vec2 positionScreen = (position * 2.0) - 1.0;\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    // Get the position of the fragment in the world\n    vec3 positionWorld = vec3(positionScreen, 1.0);\n\n    //", "\n    vec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p2 = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 p3 = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 p4 = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 p5 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p6 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p7 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p8 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p9 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p10 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p11 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p12 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p13 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p14 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p15 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p16 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p17 =", "\n    float s = sin(rotation.x);\n    float c = cos(rotation.x);\n    float t = sin(rotation.y);\n    float ct = cos(rotation.y);\n    float n = sin(rotation.z);\n    float cn = cos(rotation.z);\n\n    // Create the Rotation Matrix\n    return mat3(\n        vec3(cn*ct, cn*s, -sn),\n        vec3(cn*t, cn*ct*t, -sn*s),\n        vec3(s*ct, s*t, cn)\n    );\n}\n\n//src/main.cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstring>\n#include <cstdio>\n#include <cassert>\n#include <cct", "\n    vec4 raypos = vec4(0.0, 0.0, 0.0, 1.0);\n    // raypos = vec4(raydir.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.0);\n    // raypos = vec4(rayori.xyz, 1.", "\n    vec3 rayDir = normalize(cameraPos - uv);\n\n    // Calculate the distance to the plane\n    float dist = dot(uv - cameraPos, planeNormal);\n\n    // Calculate the distance to the plane\n    float distToPlane = dist / length(planeNormal);\n\n    // Calculate the distance to the plane\n    float distToCamera = length(uv - cameraPos);\n\n    // Calculate the distance to the plane\n    float distToCameraSquared = distToCamera * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraCubed = distToCameraSquared * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraFourth = distToCameraCubed * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraFifth = distToCameraFourth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraSixth = distToCameraFifth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraSeventh = distToCameraSixth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraEighth = distToCameraSeventh * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraNinth = distToCameraEighth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraTenth = distToCameraNinth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraEleventh = distToCameraTenth * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraTwelfth = distToCameraEleventh * distToCamera;\n\n    // Calculate the distance to the plane\n    float distToCameraThirteenth = distToCameraTwelfth * distToCamera;\n\n    // Calcul", "\n    vec3 raypos = vec3(0.0, 0.0, 0.0);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set the Ray Origin\n    raypos = rayori;\n\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n\n    // Set", "\n    float seed = float(gl_FragCoord.x + gl_FragCoord.y);\n    float rng = rand(seed);\n\n    // Initialize variables\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    vec2 c = vec2(0.0);\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 10.0;\n    float tmin = 0.0;\n    float tstep = 0.001;\n    float tstep2 = 0.0001;\n    float tstep3 = 0.00001;\n    float tstep4 = 0.000001;\n    float tstep5 = 0.0000001;\n    float tstep6 = 0.00000001;\n    float tstep7 = 0.000000001;\n    float tstep8 = 0.0000000001;\n    float tstep9 = 0.00000000001;\n    float tstep10 = 0.000000000001;\n    float tstep11 = 0.0000000000001;\n    float tstep12 = 0.00000000000001;\n    float tstep13 = 0.000000000000001;\n    float tstep14 = 0.0000000000000001;\n    float tstep15 = 0.00000000000000001;\n    float tstep16 = 0.000000000000000001;\n    float tstep17 = 0.0000000000000000001;\n    float tstep18 = 0.", "\n    float fade = fadeOut(coord, frequency, travelRate);\n\n    // Get the distance from the center of the fragment\n    float dist = distance(coord, vec2(0.5));\n\n    // Get the strength of the fragment\n    float strength = maxStrength * fade;\n\n    // Return the strength of the fragment\n    return strength;\n}\n\nvoid main()\n{\n    // Get the coordinates of the fragment\n    vec2 coord = gl_FragCoord.xy;\n\n    // Get the strength of the fragment\n    float strength = rayValue(coord, 1.0, 0.001, 1.0);\n\n    // Set the color of the fragment\n    gl_FragColor = vec4(strength, strength, strength, 1.0);\n}\n", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n\tvec2 e12 = e1 - p;\n\tvec2 e23 = e2 - p;\n\tvec2 e34 = e3 - p;\n\tvec2 e41 = e4 - p;\n\tfloat d12 = dot(e12, e12);\n\tfloat d23 = dot(e23, e23);\n\tfloat d34 = dot(e34, e34);\n\tfloat d41 = dot(e41, e41);\n\tfloat d123 = dot(e12, e23);\n\tfloat d124 = dot(e12, e34);\n\tfloat d234 = dot(e23, e34);\n\tfloat d134 = dot(e13, e34);\n\tfloat d1234 = dot(e12, e34);\n\tfloat d12341 = dot(e12, e41);\n\tfloat d123412 = dot(e12, e23);\n\tfloat d1234123 = dot(e12, e34);\n\tfloat d12341234 = dot(e12, e41);\n\tfloat d2341234 = dot(e23, e34);\n\tfloat d23412341 = dot(e23, e41);\n\tfloat d34123412 = dot(e34, e41);\n\tfloat d341234123 = dot(e34, e23);\n\tfloat d3412341234 = dot(e34, e41);\n\tfloat d412341234 = dot(e41, e23);\n\tfloat d4123412341 = dot(e41, e34);\n\tfloat d41234123412 = dot(e41, e23);\n\tfloat d412341234123 = dot(e41,", "\n    return pow(color, vec3(2.2));\n}\n\nvec", "\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    vec2 bp = p-b;\n    float h = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n    float d = length(p-mix(a,b,h));\n\n    // return min(d,w1);\n    return min(d,w1);\n}\n\nfloat", "\n    uv = uv * 2.0 - 1.0;\n    uv.x *= TAU;\n    uv.y *= TAU;\n\n    //get the distance from the center\n    float d = length(uv);\n\n    //get the angle from the center\n    float a = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a2 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a3 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a4 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a5 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a6 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a7 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a8 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a9 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a10 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a11 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a12 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a13 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a14 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a15 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a16 = atan(uv.y, uv.x", "\n    //vec3 colC = vec3(0.0,0.0,0.0);\n    //vec3 colD = vec3(0.0,0.0,0.0);\n    //vec3 colE = vec3(0.0,0.0,0.0);\n    //vec3 colF = vec3(0.0,0.0,0.0);\n    //vec3 colG = vec3(0.0,0.0,0.0);\n    //vec3 colH = vec3(0.0,0.0,0.0);\n    //vec3 colI = vec3(0.0,0.0,0.0);\n    //vec3 colJ = vec3(0.0,0.0,0.0);\n    //vec3 colK = vec3(0.0,0.0,0.0);\n    //vec3 colL = vec3(0.0,0.0,0.0);\n    //vec3 colM = vec3(0.0,0.0,0.0);\n    //vec3 colN = vec3(0.0,0.0,0.0);\n    //vec3 colO = vec3(0.0,0.0,0.0);\n    //vec3 colP = vec3(0.0,0.0,0.0);\n    //vec3 colQ = vec3(0.0,0.0,0.0);\n    //vec3 colR = vec3(0.0,0.0,0.0);\n    //vec3 colS = vec3(0.0,0.0,0.0);\n    //vec3 colT = vec3(0.0,0.0,0.0);\n    //vec3 colU = vec3(0.0,0.0,0.0);\n    //vec3 colV = vec3(0.0,0.0,0.0);\n    //vec3 colW = vec3(0.0,0.0,0.0);\n    //vec3 colX =", "\n    vec2 uv = fragCoord/iResolution.xy; //x-fov\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n", "\n   p = fmod(p, 1.0);\n   if (p < 0.0) p += 1.0;\n   return vec3(p * 127.1, p * 311.7, p * 163.1);\n}\n\nfloat", "\n  //  return 1.0 - (pow(tanh(x), 2.0));\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0 - (pow(tanh(x), 2.0)) / 16.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0 - (pow(tanh(x), 2.0)) / 16.0 + (pow(tanh(x), 2.0)) / 32.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) / 2.0 - (pow(tanh(x), 2.0)) / 4.0 + (pow(tanh(x), 2.0)) / 8.0 - (pow(tanh(x), 2.0)) / 16.0 + (pow(tanh(x), 2.0)) / 32.0 - (pow(tanh(x), 2.0)) / 64.0;\n  //  return 1.0 - (pow(tanh(x), 2.0)) /", ".\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n", "\n    return length(max(abs(p) - 1.0, 0.0));\n}\n\n// Compute the signed distance field of the sphere\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"], "input_both-67b": ["\n\treturn max(0.0,cos( a ));\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) = 1, fsin(2/3) = -1\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat", "\n    p = p - rotDir*dot(p,rotDir);\n\n    // Rotate the whole thing\n    p = Rotate(p,rotAngle);\n\n    // Scale\n    p *= scale;\n\n    // Translate\n    p += translate;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p = p*p*p;\n\n    //p", "\n\tglowCounter = glowCounter + 1.0;\n\n\t// Get the distance to the voxel\n\tfloat d = length(p) - 0.5;\n\n\t// Return the distance\n\treturn d;\n}\n\n// Distance to the voxel\nfloat", "\n\tglowCounter = glowCounter + 1.0;\n\n\t// Distance to the scene\n\tfloat d = sdScene(p);\n\n\t// Color of the closest point\n\tP = vec3(0.0);\n\n\t// If the point is in the scene\n\tif (d < EPS) {\n\n\t\t// Get the color of the closest point\n\t\tP = getColor(p);\n\n\t\t// If the point is in the glow area\n\t\tif (d < GLOW_RADIUS) {\n\n\t\t\t// Add the glow\n\t\t\tP = P + glow(p);\n\t\t}\n\t}\n\n\t// Return the distance and the color\n\treturn vec2(d, P);\n}\n\n// Ray marching\nvec", " coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Get the mouse position\n\tvec2 mouse = iMouse.xy / iResolution.xy;\n\n\t// Get the time\n\tfloat time = iTime;\n\n\t// Get the aspect ratio\n\tfloat aspect = iResolution.x / iResolution.y;\n\n\t// Get the pixel size\n\tvec2 pixelSize = 1.0 / iResolution.xy;\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos2 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos3 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos4 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos5 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos6 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos7 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0);\n\n\t// Get the mouse position in the range of [-1, 1]\n\tvec2 mousePos8 = (mouse * 2.0 - 1.0) * vec2(aspect, 1.0", "\n\tvec4 colors[4];\n\tcolors[0] = vec4(0.0, 0.0, 0.0, 1.0);\n\tcolors[1] = vec4(0.0, 0.0, 1.0, 1.0);\n\tcolors[2] = vec4(0.0, 1.0, 0.0, 1.0);\n\tcolors[3] = vec4(1.0, 0.0, 0.0, 1.0);\n\n\tfloat x0 = floor(x);\n\tfloat x1 = x0 + 1.0;\n\tfloat w0 = x1 - x;\n\tfloat w1 = x - x0;\n\n\tvec4 c0 = colors[int(x0)];\n\tvec4 c1 = colors[int(x1)];\n\n\treturn c0 * w0 + c1 * w1;\n}\n\nvoid main()\n{\n\tvec4 color = gradient(v_color);\n\tgl_FragColor = color;\n}\n", "\n\tvec4 color = texture(colorGradient, d);\n\n\t// add ambient light\n\tcolor += ambient;\n\n\t// add diffuse light\n\tcolor += diffuse * max(dot(normal, lightDir), 0.0);\n\n\t// add specular light\n\tcolor += specular * pow(max(dot(reflect(-lightDir, normal), viewDir), 0.0), shininess);\n\n\treturn color;\n}\n\nvoid main()\n{\n\t// get the distance to the point\n\tfloat d = distance(position, cameraPos);\n\n\t// shade the point\n\tvec4 color = shade(d);\n\n\t// set the fragment color\n\tfragColor = color;\n}\n", " up to the top\n    float fade = (rayDir.y + 1.0) * 0.5;\n\n    // softbox\n    float dist = RayBox(rayDir, vec3(0.0), vec3(100.0), 0.0);\n\n    // 4 lights in a horizontal circle\n    float dist2 = RayBox(rayDir, vec3(0.0, 0.0, 10.0), vec3(10.0, 10.0, 10.0), 0.0);\n    float dist3 = RayBox(rayDir, vec3(0.0, 0.0, 20.0), vec3(10.0, 10.0, 10.0), 0.0);\n    float dist4 = RayBox(rayDir, vec3(0.0, 0.0, 30.0), vec3(10.0, 10.0, 10.0), 0.0);\n    float dist5 = RayBox(rayDir, vec3(0.0, 0.0, 40.0), vec3(10.0, 10.0, 10.0), 0.0);\n\n    // get the closest distance\n    float distClosest = min(dist, min(dist2, min(dist3, min(dist4, dist5))));\n\n    // if the ray hit the softbox, return the softbox color\n    if (distClosest == dist)\n    {\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    // if the ray hit the lights, return the light color\n    if (distClosest == dist2)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if (distClosest == dist3)\n    {\n        return vec3(1.0, 1.0, 1.0);\n    }\n    if (distClosest == dist4)\n    {\n        return vec3", "\n    float t = mod(time, 6.0);\n    if (t < 2.0 || t > 4.0)\n        return 0.0;\n\n    // the curve is a parabola\n    float x = coords.x;\n    float y = coords.y;\n    return (x - 2.0) * (x - 4.0) - y;\n}\n\n// the derivative of F(x,y)\nvec", "\n    float t = mod(time, 10.0);\n    if (t < 2.0 || t > 8.0)\n        return 0.0;\n\n    // the curve is a function of x and y\n    float x = coords.x;\n    float y = coords.y;\n\n    // the curve is a function of time\n    float tt = t - 2.0;\n\n    // the curve is a function of x and y\n    float xx = x - 0.5;\n    float yy = y - 0.5;\n\n    // the curve is a function of x and y\n    float xxx = xx * xx;\n    float yyy = yy * yy;\n\n    // the curve is a function of x and y\n    float xxxx = xxx * xxx;\n    float yyyy = yyy * yyy;\n\n    // the curve is a function of x and y\n    float xxxxx = xxxx * xxx;\n    float yyyyy = yyyy * yyy;\n\n    // the curve is a function of x and y\n    float xxxxxx = xxxxx * xx;\n    float yyyyyy = yyyyy * yy;\n\n    // the curve is a function of x and y\n    float xxxxxxx = xxxxxx * xx;\n    float yyyyyyy = yyyyyy * yy;\n\n    // the curve is a function of x and y\n    float xxxxxxxx = xxxxxxx * xx;\n    float yyyyyyyy = yyyyyyy * yy;\n\n    // the curve is a function of x and y\n    float xxxxxxxxx = xxxxxxxx * xx;\n    float yyyyyyyyy = yyyyyyyy * yy;\n\n    // the curve is a function of x and y\n    float xxxxxxxxxx = xxxxxxxxx * xx;\n    float yyyyyyyyyy = yyyyyyyyy * yy;\n\n    // the curve is a function of x and y\n    float xxxxxxxxxxx = xxxxxxxxxx * xx;\n    float yyyyyyyyyyy = yyyyyyyyyy * yy;\n\n   ", "\n    float t = mod(time, 5.0);\n    if (t < 1.0 || t > 4.0)\n        return 0.0;\n\n    // the curve is a function of x and y\n    float x = coords.x;\n    float y = coords.y;\n\n    // the curve is a function of t\n    float tt = t - 1.0;\n\n    // the curve is a function of x and y\n    float xx = x - 0.5;\n    float yy = y - 0.5;\n\n    // the curve is a function of t, x and y\n    float ttt = tt * tt * tt;\n    float xxx = xx * xx * xx;\n    float yyy = yy * yy * yy;\n\n    // the curve is a function of t, x, y and t^3 * x^3 * y^3\n    float f = ttt * xxx * yyy;\n\n    // the curve is a function of t, x, y and t^3 * x^3 * y^3\n    // and the value is between 0.0 and 1.0\n    return f * 0.5 + 0.5;\n}\n\n// the main function\nvoid main()\n{\n    // get the texture coordinates\n    vec2 coords = gl_TexCoord[0].st;\n\n    // get the texture value\n    float f = F(coords);\n\n    // set the output color\n    gl_FragColor = vec4(f, f, f, 1.0);\n}\n", " by changing the value of the variable\n    float time = iTime * 0.5;\n\n    //get the position of the pixel in the screen\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv2 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv3 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv4 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv5 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv6 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv7 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv8 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv9 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv10 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv11 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv12 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv13 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the screen\n    vec2 uv14 = fragCoord.xy / iResolution.xy;\n\n    //get the position of the pixel in the", "\n    vec3 q = p + vec3(0.0, 0.0, p.z * 0.00001);\n\n    // The time dialation is applied to the position and time frequencies.\n    float f = pow(2.0, 1.0 - 1.0 * u_time);\n    float g = pow(2.0, 1.0 - 1.0 * u_time);\n\n    // The noise is generated from the position and time frequencies.\n    float n = fbm(f * p);\n    float m = fbm(g * q);\n\n    // The noise is then returned.\n    return n + m;\n}\n\n//\n// Standard fBm function with some time dialation to give a parallax \n// kind of effect. In other words, the position and time frequencies \n// are changed at different rates from layer to layer.\n//\nfloat", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(", "\n    vec2 i = floor(p + (p.x + p.y) *.125);\n    vec2 x0 = i - (i.x + i.y) *.25;\n    vec2 g = step(vec2(.5), fract(abs(x0) + vec2(.5,.75)));\n    vec2 o = g.yx * g.x + g.xy * (1. - g.x);\n    vec2 d = p - x0 - (o -.5);\n    float h = dot(d, d);\n    \n    // Simplex grid stuff.\n    //\n    vec2 i1;\n    if(o.y < o.x) i1 = vec2(1., 0.);\n    else i1 = vec2(0., 1.);\n    vec2 x1 = x0 + i1;\n    vec2 g1 = step(vec2(.5), fract(abs(x1) + vec2(.5,.75)));\n    vec2 o1 = g1.yx * g1.x + g1.xy * (1. - g1.x);\n    vec2 d1 = p - x1 - (o1 -.5);\n    float h1 = dot(d1, d1);\n    \n    // Simplex grid stuff.\n    //\n    vec2 i2;\n    if(o1.y < o1.x) i2 = vec2(1., 0.);\n    else i2 = vec2(0., 1.);\n    vec2 x2 = x0 + i1 + i2;\n    vec2 g2 = step(vec2(.5), fract(abs(x2) + vec2(.5,.75)));\n    vec2 o2 = g2.yx * g2.x + g2.xy * (1. - g2.x);\n    vec2 d2 = p - x2 - (o2 -.5);\n    float h2 = dot(d2, d2);\n    \n    // Return the minimum distance.\n    //\n    return", "\n    vec2 cell = floor(p);\n    // Get the distance to the cell.\n    vec2 cell_dist = p - cell;\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev_prev_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev_prev_prev_prev_prev = vec2(0.0);\n    // Get the distance to the cell's neighbors.\n    vec2 cell_dist_neighbor_min_dist_prev_prev_prev_prev_prev_prev_prev_prev = vec2(0.0);\n    // Get the", "\n  vec3 color = vec3(0.0,0.0,0.0);\n\n  // get the position of the hit\n  vec3 hitPosition = eyePosition + rayDirection * rayHitInfo.x;\n\n  // get the normal of the hit\n  vec3 hitNormal = getNormal( hitPosition );\n\n  // get the material of the hit\n  Material material = getMaterial( hitPosition );\n\n  // get the light direction\n  vec3 lightDirection = normalize( vec3(1.0,1.0,1.0) );\n\n  // get the light color\n  vec3 lightColor = vec3(1.0,1.0,1.0);\n\n  // get the ambient color\n  vec3 ambientColor = vec3(0.1,0.1,0.1);\n\n  // get the diffuse color\n  vec3 diffuseColor = material.diffuseColor;\n\n  // get the specular color\n  vec3 specularColor = material.specularColor;\n\n  // get the specular exponent\n  float specularExponent = material.specularExponent;\n\n  // get the reflection color\n  vec3 reflectionColor = vec3(0.0,0.0,0.0);\n\n  // get the refraction color\n  vec3 refractionColor = vec3(0.0,0.0,0.0);\n\n  // get the refraction index\n  float refractionIndex = material.refractionIndex;\n\n  // get the refraction exponent\n  float refractionExponent = material.refractionExponent;\n\n  // get the reflection exponent\n  float reflectionExponent = material.reflectionExponent;\n\n  // get the reflection direction\n  vec3 reflectionDirection = reflect( rayDirection, hitNormal );\n\n  // get the refraction direction\n  vec3 refractionDirection = refract( rayDirection, hitNormal, refractionIndex );\n\n  // get the reflection ray hit info\n  vec2 reflectionRayHitInfo = rayMarch( hitPosition, reflectionDirection );\n\n  // get the refraction ray hit info\n  vec2 refractionRayHitInfo =", "\n    vec2 res = vec2(1000.0, 0.0);\n\n    // sphere\n    res = opU(res, vec2(length(p - vec3(0.0, 0.0, 0.0)) - 1.0, 1.0));\n\n    // plane\n    res = opU(res, vec2(p.y + 1.0, 2.0));\n\n    // box\n    res = opU(res, vec2(length(max(abs(p.xz) - vec2(1.0, 1.0), 0.0)) - 0.1, 3.0));\n\n    return res;\n}\n\n// ~~~~~~~ get normal\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec", "\n\tfloat tmin = 0.001;\n\tfloat tmax = 100.0;\n\tfloat t = tmin;\n\t\n\t// variables used to store the hit object's ID\n\tfloat id = -1.0;\n\t\n\t// variables used to store the hit object's position\n\tvec3 qhit = vec3(0.0);\n\t\n\t// variables used to store the hit object's normal\n\tvec3 nhit = vec3(0.0);\n\t\n\t// variables used to store the hit object's color\n\tvec3 chit = vec3(0.0);\n\t\n\t// variables used to store the hit object's material\n\tfloat mhit = 0.0;\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit2 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit3 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit4 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit5 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit6 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit7 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit8 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit9 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit10 = vec2(0.0);\n\t\n\t// variables used to store the hit object's texture\n\tvec2 thit11 = vec2(0.0);\n\t\n\t// variables used to store the hit object", "\n    vec4 res = vec4(0.0);\n\n    // distance to the closest object\n    float d = INFINITY;\n\n    // loop through all the objects\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        // get the distance to the object\n        float d_obj = objects[i].sdf(p);\n\n        // if the distance is less than the current closest distance\n        if (d_obj < d)\n        {\n            // update the closest distance\n            d = d_obj;\n\n            // get the color of the object\n            vec3 col = objects[i].color;\n\n            // if the object is a sphere\n            if (objects[i].type == SPHERE)\n            {\n                // get the normal of the sphere\n                vec3 n = normalize(p - objects[i].pos);\n\n                // get the light direction\n                vec3 l = normalize(vec3(1.0, 1.0, 1.0));\n\n                // get the ambient light\n                vec3 ambient = vec3(0.1, 0.1, 0.1);\n\n                // get the diffuse light\n                vec3 diffuse = vec3(0.5, 0.5, 0.5) * max(dot(n, l), 0.0);\n\n                // get the specular light\n                vec3 specular = vec3(1.0, 1.0, 1.0) * pow(max(dot(reflect(l, n), normalize(p - objects[i].pos)), 0.0), 10.0);\n\n                // get the final color\n                col = ambient + diffuse + specular;\n            }\n\n            // set the result to the color of the object\n            res = vec4(col, d);\n        }\n    }\n\n    // return the result\n    return res;\n}\n\n// ~~~~~~~ ray marching\n// input p --> is ray position\n// input d --> is ray direction\n// basically march along the ray until we hit something\n// outputs the distance to the object\n", "\n    float t = 0.0;\n    float mint = 0.0;\n    float maxt = 1000.0;\n    float precis = 0.001;\n    float maxd = 100.0;\n    float h = 1.0;\n    float tt = 0.0;\n    float id = 0.0;\n    float itter = 0.0;\n    float itterMax = 100.0;\n    float itterStep = 0.0;\n    float itterStepMax = 10.0;\n    float itterStepMin = 0.0;\n    float itterStepRatio = 0.0;\n    float itterStepRatioMax = 1.0;\n    float itterStepRatioMin = 0.0;\n    float itterStepRatioStep = 0.0;\n    float itterStepRatioStepMax = 1.0;\n    float itterStepRatioStepMin = 0.0;\n    float itterStepRatioStepRatio = 0.0;\n    float itterStepRatioStepRatioMax = 1.0;\n    float itterStepRatioStepRatioMin = 0.0;\n    float itterStepRatioStepRatioStep = 0.0;\n    float itterStepRatioStepRatioStepMax = 1.0;\n    float itterStepRatioStepRatioStepMin = 0.0;\n    float itterStepRatioStepRatioStepRatio = 0.0;\n    float itterStepRatioStepRatioStepRatioMax = 1.0;\n    float itterStepRatioStepRatioStepRatioMin = 0.0;\n    float itterStepRatioStepRatioStepRatioStep = 0.0;\n    float itterStepRatioStepRatioStepRatioStepMax = 1.0;\n    float itterStepRatioStepRatioStepRatioStepMin = 0.0;\n    float itterStepRatioStepRatioStepRatioStepRatio = 0.0;\n    float itterStepRatioStepRatioStepRatioStepRatioMax = 1.0;\n    float itterStepRatioStepRatioStepRatioStep", "s\n    vec3 diffs[4];\n    diffs[0] = vec3(0.0, 0.0, 0.0);\n    diffs[1] = vec3(0.0, 0.0, 0.0);\n    diffs[2] = vec3(0.0, 0.0, 0.0);\n    diffs[3] = vec3(0.0, 0.0, 0.0);\n\n    // world pos diffs\n    vec3 diffs2[4];\n    diffs2[0] = vec3(0.0, 0.0, 0.0);\n    diffs2[1] = vec3(0.0, 0.0, 0.0);\n    diffs2[2] = vec3(0.0, 0.0, 0.0);\n    diffs2[3] = vec3(0.0, 0.0, 0.0);\n\n    // world pos diffs\n    vec3 diffs3[4];\n    diffs3[0] = vec3(0.0, 0.0, 0.0);\n    diffs3[1] = vec3(0.0, 0.0, 0.0);\n    diffs3[2] = vec3(0.0, 0.0, 0.0);\n    diffs3[3] = vec3(0.0, 0.0, 0.0);\n\n    // world pos diffs\n    vec3 diffs4[4];\n    diffs4[0] = vec3(0.0, 0.0, 0.0);\n    diffs4[1] = vec3(0.0, 0.0, 0.0);\n    diffs4[2] = vec3(0.0, 0.0, 0.0);\n    diffs4[3] = vec3(0.0, 0.0, 0.0);\n\n    // world pos diffs\n    vec3 diffs5", "\n    vec3 s = vec3(7, 157, 113);\n    \n    // The dot product of the input and the stride.\n    float h = dot(p, s);\n    \n    // The fractional part of the dot product.\n    vec3 f = fract(vec3(h, h+1, h+2) * (1.0 / 31.0));\n    \n    // The fractional part of the dot product, raised to the power of 3.\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    \n    // The dot product of the input and the stride, modulo 289.\n    h = mod(h, 289.0);\n    \n    // The index of the first vector.\n    vec3 i = floor(h * (1.0 / 41.0));\n    \n    // The index of the second vector.\n    vec3 j = floor((h - i * 41.0) * (1.0 / 41.0));\n    \n    // The index of the third vector.\n    vec3 k = mod(i * 41.0 + j, 289.0);\n    \n    // The index of the fourth vector.\n    vec3 g = mod(k * 41.0, 7.0);\n    \n    // The index of the fifth vector.\n    vec3 l = mod(k * 41.0 + g, 289.0);\n    \n    // The index of the sixth vector.\n    vec3 m = mod(l * 41.0, 7.0);\n    \n    // The index of the seventh vector.\n    vec3 n = mod(l * 41.0 + m, 289.0);\n    \n    // The index of the eighth vector.\n    vec3 o = mod(n * 41.0, 7.0);\n    \n    // The index of the ninth vector.\n    vec3 q = mod(n * 41.0 + o, 289.", "\n\tvec3 col = vec3(0.);\n\tfloat t = 0.;\n\tfloat tmax = 1000.;\n\tfloat tmin = 0.001;\n\tfloat tstep = 0.01;\n\tfloat tstep2 = 0.001;\n\tfloat tstep3 = 0.0001;\n\tfloat tstep4 = 0.00001;\n\tfloat tstep5 = 0.000001;\n\tfloat tstep6 = 0.0000001;\n\tfloat tstep7 = 0.00000001;\n\tfloat tstep8 = 0.000000001;\n\tfloat tstep9 = 0.0000000001;\n\tfloat tstep10 = 0.00000000001;\n\tfloat tstep11 = 0.000000000001;\n\tfloat tstep12 = 0.0000000000001;\n\tfloat tstep13 = 0.00000000000001;\n\tfloat tstep14 = 0.000000000000001;\n\tfloat tstep15 = 0.0000000000000001;\n\tfloat tstep16 = 0.00000000000000001;\n\tfloat tstep17 = 0.000000000000000001;\n\tfloat tstep18 = 0.0000000000000000001;\n\tfloat tstep19 = 0.00000000000000000001;\n\tfloat tstep20 = 0.000000000000000000001;\n\tfloat tstep21 = 0.0000000000000000000", "\n    vec2 AB = B - A;\n    vec2 AB_normal = vec2(-AB.y, AB.x);\n    float AB_length = length(AB);\n    vec2 AB_normalized = AB / AB_length;\n    \n    // calculate distance from line segment\n    float dist = dot(AB_normal, coords - A);\n    dist = dist / AB_length;\n    \n    // calculate distance from line segment\n    float dist_from_line = abs(dist);\n    \n    // calculate distance from line segment\n    float dist_from_line_squared = dist_from_line * dist_from_line;\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped = clamp(dist_from_line_squared, 0.0, 1.0);\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped_inverted = 1.0 - dist_from_line_squared_clamped;\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped_inverted_squared = dist_from_line_squared_clamped_inverted * dist_from_line_squared_clamped_inverted;\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped_inverted_squared_inverted = 1.0 - dist_from_line_squared_clamped_inverted_squared;\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped_inverted_squared_inverted_squared = dist_from_line_squared_clamped_inverted_squared_inverted * dist_from_line_squared_clamped_inverted_squared_inverted;\n    \n    // calculate distance from line segment\n    float dist_from_line_squared_clamped_inverted_squared_inverted_squared_inverted = 1.0 - dist_from_line_squared_clamped_inverted_squared_inverted_squared;\n    \n    //", "\n     float dot = dot(start, end);\n     // Clamp it to be in the range of Acos()\n     // This may be unnecessary, but floating point\n     // precision can be a fickle mistress.\n     dot = clamp(dot, -1.0, 1.0);\n     // Acos(dot) returns the angle between start and end,\n     // And multiplying that by percent returns the angle between\n     // start and the final result.\n     float theta = acos(dot)*percent;\n     vec2 RelativeVec = normalize(end - start*dot);\n     // Adjust start and reflect it about the relative vector\n     return (start*cos(theta)) + (RelativeVec*sin(theta));\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec", "\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camTarget = vec3(0.0, 0.0, 1.0);\n    vec3 camUp = vec3(0.0, 1.0, 0.0);\n    float camFov = 45.0;\n    float camNear = 0.1;\n    float camFar = 100.0;\n    float camAspect = iResolution.x / iResolution.y;\n    mat4 camView = lookAt(camPos, camTarget, camUp);\n    mat4 camProj = perspective(camFov, camAspect, camNear, camFar);\n    mat4 camViewProj = camProj * camView;\n\n    // set up our ray\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec4 rayStart = vec4(camPos, 1.0);\n    vec4 rayDir = normalize(camViewProj * vec4(uv, 1.0, 0.0));\n\n    // set up our scene\n    vec3 sceneColor = vec3(0.0);\n    float sceneDist = 100000.0;\n    vec3 sceneNormal = vec3(0.0);\n    vec3 scenePos = vec3(0.0);\n    vec3 sceneColor2 = vec3(0.0);\n    float sceneDist2 = 100000.0;\n    vec3 sceneNormal2 = vec3(0.0);\n    vec3 scenePos2 = vec3(0.0);\n\n    // set up our sphere\n    vec3 spherePos = vec3(0.0, 0.0, 1.0);\n    float sphereRadius = 0.5;\n\n    // set up our plane\n    vec3 planePos = vec3(0.0, 0.0, 0.0);\n    vec3 planeNormal =", "\n    //\n    //e = a + e * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a + (ap dot ab) / (ab dot ab) * (b-a)\n    //\n    //e = a", " and forth\n    float t = (rayDir.y + 1.0) * 0.5;\n    t = t * t * t;\n\n    // make a softbox light\n    vec3 lightColor = vec3(1.0, 0.9, 0.8) * 10.0;\n    vec3 lightDir = vec3(0.0, 1.0, 0.0);\n    float lightDist = 10.0;\n    float lightAtten = 1.0 / (1.0 + 0.01 * lightDist * lightDist);\n    vec3 light = lightColor * lightAtten * max(0.0, dot(lightDir, rayDir));\n\n    // make a softbox shadow\n    float shadow = 1.0;\n    if (t < 0.99)\n    {\n        float shadowDist = RayMarch(rayDir * lightDist, 0.0, 1.0);\n        shadow = max(0.0, 1.0 - shadowDist / lightDist);\n    }\n\n    return light * shadow;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec", "\n    // The ball-roller is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.\n    // The hole is a cylinder with a hole in the middle.", "^2\n\t// => (org.x^2 + 2*org.x*t*dir.x + t^2*dir.x^2) + (org.y^2 + 2*org.y*t*dir.y + t^2*dir.y^2) = 0.5^2\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.y^2 - 0.5^2) = 0\n\t// => t^2*(dir.x^2 + dir.y^2) + t*(2*org.x*dir.x + 2*org.y*dir.y) + (org.x^2 + org.", "\n    vec3 q = abs(p) - s.xyz;\n    vec3 q2 = q - s.w;\n    vec3 q3 = q - s.w * 2.0;\n    vec3 q4 = q - s.w * 3.0;\n    // corner radius\n    vec3 r2 = r.xyz * r.xyz;\n    // bottom radius offset\n    vec3 r3 = r.xyz * r.w;\n    // corner distance\n    vec3 d = q * r2 + q2 * r3 + q3 * r.w + q4 * r.w;\n    // bottom distance\n    vec3 d2 = q * r.w + q2 * r.w + q3 * r.w + q4 * r.w;\n    // distance to the nearest corner\n    float dmin = min(min(d.x, d.y), d.z);\n    // distance to the nearest bottom\n    float dmin2 = min(min(d2.x, d2.y), d2.z);\n    // distance to the nearest side\n    float dmin3 = min(min(d.x + d.y, d.y + d.z), d.z + d.x);\n    // distance to the nearest corner\n    float dmin4 = min(min(d2.x + d2.y, d2.y + d2.z), d2.z + d2.x);\n    // distance to the nearest side\n    float dmin5 = min(min(d.x + d.y + d.z, d.y + d.z + d.x), d.z + d.x + d.y);\n    // distance to the nearest corner\n    float dmin6 = min(min(d2.x + d2.y + d2.z, d2.y + d2.z + d2.x), d2.z + d2.x + d2.y);\n    // distance to the nearest side\n    float dmin7 = min(min(d.x + d.y + d.z + d.w, d.y + d.z + d.", "\n    float x = p.x * 1.0;\n    float y = p.y * 1.0;\n    float z = p.z * 1.0;\n    \n    // The first part of the hash function.\n    float x1 = x * 1.0;\n    float y1 = y * 1.0;\n    float z1 = z * 1.0;\n    \n    // The second part of the hash function.\n    float x2 = x * 1.0;\n    float y2 = y * 1.0;\n    float z2 = z * 1.0;\n    \n    // The third part of the hash function.\n    float x3 = x * 1.0;\n    float y3 = y * 1.0;\n    float z3 = z * 1.0;\n    \n    // The fourth part of the hash function.\n    float x4 = x * 1.0;\n    float y4 = y * 1.0;\n    float z4 = z * 1.0;\n    \n    // The fifth part of the hash function.\n    float x5 = x * 1.0;\n    float y5 = y * 1.0;\n    float z5 = z * 1.0;\n    \n    // The sixth part of the hash function.\n    float x6 = x * 1.0;\n    float y6 = y * 1.0;\n    float z6 = z * 1.0;\n    \n    // The seventh part of the hash function.\n    float x7 = x * 1.0;\n    float y7 = y * 1.0;\n    float z7 = z * 1.0;\n    \n    // The eighth part of the hash function.\n    float x8 = x * 1.0;\n    float y8 = y * 1.0;\n    float z8 = z * 1.0;\n    \n    // The ninth part of the hash function.\n    float x9 = x * 1.0;\n    float y9 = y * 1.0;\n    float z9 = z * 1.0;", "\n    float d = dot(p,p);\n    \n    // The circle radius.\n    float r = 0.25;\n    \n    // The circle distance.\n    float c = d - r;\n    \n    // The circle distance squared.\n    float c2 = c*c;\n    \n    // The circle distance cubed.\n    float c3 = c2*c;\n    \n    // The circle distance to the power of 5.\n    float c5 = c3*c2;\n    \n    // The circle distance to the power of 7.\n    float c7 = c5*c2;\n    \n    // The circle distance to the power of 9.\n    float c9 = c7*c2;\n    \n    // The circle distance to the power of 11.\n    float c11 = c9*c2;\n    \n    // The circle distance to the power of 13.\n    float c13 = c11*c2;\n    \n    // The circle distance to the power of 15.\n    float c15 = c13*c2;\n    \n    // The circle distance to the power of 17.\n    float c17 = c15*c2;\n    \n    // The circle distance to the power of 19.\n    float c19 = c17*c2;\n    \n    // The circle distance to the power of 21.\n    float c21 = c19*c2;\n    \n    // The circle distance to the power of 23.\n    float c23 = c21*c2;\n    \n    // The circle distance to the power of 25.\n    float c25 = c23*c2;\n    \n    // The circle distance to the power of 27.\n    float c27 = c25*c2;\n    \n    // The circle distance to the power of 29.\n    float c29 = c27*c2;\n    \n    // The circle distance to the power of 31.\n    float c31 = c29*c2;\n    \n    // The circle distance to the power", "\n    // fz - Change in \"f\" in in the Z-direction.\n    //\n    // n - Normal vector\n    // nx - Change in \"n\" in in the X-direction.\n    // ny - Change in \"n\" in in the Y-direction.\n    // nz - Change in \"n\" in in the Z-direction.\n    //\n    // bumpFactor - The amount of bumpiness.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function of the position and normal.\n    //\n    // The bump function is a function", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    \n    // Slower, but more evenly disperses things.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n  vec3 l = normalize(light_pos - p);\n  float lambert = max(dot(n, l), 0.0);\n  vec3 diffuse = lambert * light_color;\n\n  // ambient\n  vec3 ambient = ambient_color;\n\n  // specular\n  vec3 v = normalize(camera_pos - p);\n  vec3 h = normalize(l + v);\n  float specular = pow(max(dot(n, h), 0.0), 16.0);\n  vec3 spec = specular * light_color;\n\n  return ambient + diffuse + spec;\n}\n\n// Ray marching\n// p : point,\n// d : direction\nfloat", "\n    Ray ray = createRay(fragCoord);\n    //creates a color object\n    vec3 color = vec3(0.0);\n    //creates a hit object\n    Hit hit = Hit(1000000.0);\n    //creates a sphere object\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n    //checks if the ray hits the sphere\n    if (intersectRaySphere(ray, sphere, hit))\n    {\n        //if it does, it sets the color to the normal of the sphere\n        color = hit.normal;\n    }\n    //sets the color of the fragment\n    fragColor = vec4(color, 1.0);\n}\n", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = ve", "\n    float ka = 0.005;\n    float kd = 0.7;\n    float ks = 0.3;\n    float shininess = 64.0;\n\n    // raymarch\n    float t = raymarch(ro, rd);\n\n    // if we hit something\n    if (t < MAX_DIST)\n    {\n        // get the position of the hit\n        vec3 pos = ro + rd * t;\n\n        // get the normal of the hit\n        vec3 nor = calcNormal(pos);\n\n        // get the color of the hit\n        vec3 col = vec3(0.0);\n\n        // get the light direction\n        vec3 lightDir = normalize(vec3(1.0, 1.0, 0.0));\n\n        // ambient\n        vec3 ambient = ka * vec3(1.0);\n\n        // diffuse\n        float diff = max(dot(nor, lightDir), 0.0);\n        vec3 diffuse = kd * diff * vec3(1.0);\n\n        // specular\n        vec3 reflectDir = reflect(-lightDir, nor);\n        float spec = pow(max(dot(rd, reflectDir), 0.0), shininess);\n        vec3 specular = ks * spec * vec3(1.0);\n\n        // combine\n        col = ambient + diffuse + specular;\n\n        // return the color\n        return col;\n    }\n\n    // if we didn't hit anything, return the background color\n    return vec3(0.0);\n}\n\nvoid main()\n{\n    // get the screen position\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n    // get the ray direction\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    // get the ray origin\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n\n    // get the color\n    ve", "\n    return length(p) - rad;\n}\n\n//box\nfloat", "\n    float d = p.y;\n    d = max(d, -p.y - param.y);\n\n    // walls\n    d = max(d, abs(p.x) - param.x);\n    d = max(d, abs(p.z) - param.z);\n\n    return d;\n}\n\n// scene normal\nvec", "\n    float d = min(p.y, -p.y);\n    // walls\n    d = min(d, p.x);\n    d = min(d, -p.x);\n    d = min(d, p.z);\n    d = min(d, -p.z);\n    // sphere\n    d = min(d, length(p - vec3(0.0, 0.0, 0.0)) - param.x);\n    return d;\n}\n\n// scene distance without light gathering\nfloat", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = vec3(0.075, 0.565,.03);\n    //vec3 par = ve", "\n    float ka = 0.005;\n    float kd = 0.7;\n    float ks = 0.3;\n    float sh = 10.0;\n\n    // get the normal\n    vec3 n = normal(ro + rd * ti);\n\n    // get the light direction\n    vec3 l = normalize(vec3(1.0, 1.0, 1.0));\n\n    // get the view direction\n    vec3 v = normalize(-ro);\n\n    // get the reflection direction\n    vec3 r = reflect(l, n);\n\n    // calculate the ambient, diffuse, and specular components\n    float amb = ka;\n    float dif = kd * max(dot(n, l), 0.0);\n    float spe = ks * pow(max(dot(r, v), 0.0), sh);\n\n    // calculate the final color\n    return vec3(amb + dif + spe);\n}\n\nvoid main()\n{\n    // get the ray origin and direction\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(v_texcoord, 1.0));\n\n    // get the intersection time\n    float ti = intersect(ro, rd);\n\n    // if the ray intersects the sphere, color it\n    if (ti > 0.0)\n    {\n        // get the color of the ray\n        vec3 col = rayColor(ro, rd, ti);\n\n        // output the color\n        out_color = vec4(col, 1.0);\n    }\n    else\n    {\n        // if the ray does not intersect the sphere, output a black color\n        out_color = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n", "\n    p = mat2(0.70710678118654757, -0.70710678118654757, 0.70710678118654757, 0.70710678118654757) * p;\n    p = abs(p);\n    return max(p.x, p.y) - diamond.z;\n}\n\n// 2D rotation matrix.\nmat", "\n    // so that the background is not transformed.\n    vec3 col = vec3(0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n    col += vec3(0.0, 0.0, 0.0);\n   ", "\n\tfloat d = sdSphere( pos, 1.0 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 2.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 4.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 6.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 8.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 10.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 12.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 14.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 16.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 18.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion( d, sdSphere( pos + vec3( 0.0, 0.0, 20.0 ), 1.0 ), 0.5 );\n\td = opSmoothUnion", "\n\tvec3 light1 = vec3( 1.0, 1.0, 1.0 );\n\tvec3 light2 = vec3( -1.0, 1.0, 1.0 );\n\tvec3 light3 = vec3( 1.0, -1.0, 1.0 );\n\tvec3 light4 = vec3( -1.0, -1.0, 1.0 );\n\tvec3 light5 = vec3( 1.0, 1.0, -1.0 );\n\tvec3 light6 = vec3( -1.0, 1.0, -1.0 );\n\tvec3 light7 = vec3( 1.0, -1.0, -1.0 );\n\tvec3 light8 = vec3( -1.0, -1.0, -1.0 );\n\n\tvec3 ambient = vec3( 0.1, 0.1, 0.1 );\n\tvec3 diffuse = vec3( 0.0, 0.0, 0.0 );\n\tvec3 specular = vec3( 0.0, 0.0, 0.0 );\n\n\tvec3 l1 = normalize( light1 - v );\n\tvec3 l2 = normalize( light2 - v );\n\tvec3 l3 = normalize( light3 - v );\n\tvec3 l4 = normalize( light4 - v );\n\tvec3 l5 = normalize( light5 - v );\n\tvec3 l6 = normalize( light6 - v );\n\tvec3 l7 = normalize( light7 - v );\n\tvec3 l8 = normalize( light8 - v );\n\n\tvec3 e = normalize( eye - v );\n\n\tfloat d1 = max( dot( n, l1 ), 0.0 );\n\tfloat d2 = max( dot( n, l2 ), 0.0 );\n\tfloat d3 = max( dot( n, l3 ), 0.0 );\n\tfloat d4 = max( dot( n, l4 ), 0.0 );\n\tfloat d5 = max( dot(", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // This is a good one.\n    // return fract(sin(", "\n    // 0.0    0.0000 |     0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float activity = a;\n    //Increase Activity Level For Better Performance\n    float activity2 = a;\n    //Increase Activity Level For Better Performance\n    float activity3 = a;\n    //Increase Activity Level For Better Performance\n    float activity4 = a;\n    //Increase Activity Level For Better Performance\n    float activity5 = a;\n    //Increase Activity Level For Better Performance\n    float activity6 = a;\n    //Increase Activity Level For Better Performance\n    float activity7 = a;\n    //Increase Activity Level For Better Performance\n    float activity8 = a;\n    //Increase Activity Level For Better Performance\n    float activity9 = a;\n    //Increase Activity Level For Better Performance\n    float activity10 = a;\n    //Increase Activity Level For Better Performance\n    float activity11 = a;\n    //Increase Activity Level For Better Performance\n    float activity12 = a;\n    //Increase Activity Level For Better Performance\n    float activity13 = a;\n    //Increase Activity Level For Better Performance\n    float activity14 = a;\n    //Increase Activity Level For Better Performance\n    float activity15 = a;\n    //Increase Activity Level For Better Performance\n    float activity16 = a;\n    //Increase Activity Level For Better Performance\n    float activity17 = a;\n    //Increase Activity Level For Better Performance\n    float activity18 = a;\n    //Increase Activity Level For Better Performance\n    float activity19 = a;\n    //Increase Activity Level For Better Performance\n    float activity20 = a;\n    //Increase Activity Level For Better Performance\n    float activity21 = a;\n    //Increase Activity Level For Better Performance\n    float activity22 = a;\n    //Increase Activity Level For Better Performance\n    float activity23 = a;\n    //Increase Activity Level For Better Performance\n    float activity24 = a;\n    //Increase Activity Level For Better Performance\n    float activity25 = a;\n    //Increase Activity Level For Better Performance\n    float activity26 = a;\n    //Increase Activity Level For Better Performance\n   ", ".\n    float d = length(p.xy) - r;\n    // How far up or down the point is, along the z-axis.\n    float z = abs(p.z) - h;\n    // Return the smallest distance to the cylinder.\n    return min(max(d, z), 0.0) + length(max(vec2(d, z), 0.0));\n}\n\n/**\n * Signed distance function for a box centered at the origin with the given dimensions.\n */\nfloat", "\n    p.yz *= rotate(iTime * 0.5);\n\n    // Add a sphere\n    float sphere = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n\n    // Add a plane\n    float plane = p.y + 1.0;\n\n    // Add a box\n    float box = length(max(abs(p) - vec3(1.0, 1.0, 1.0), 0.0));\n\n    // Add a torus\n    float torus = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // Add a cylinder\n    float cylinder = length(p.xz - vec2(0.0, 2.0)) - 0.5;\n\n    // Add a cone\n    float cone = length(p - vec3(0.0, 0.0, 2.0)) - 1.0;\n\n    // Add a torus knot\n    float knot = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // Add a sphere\n    float sphere2 = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n\n    // Add a plane\n    float plane2 = p.y + 1.0;\n\n    // Add a box\n    float box2 = length(max(abs(p) - vec3(1.0, 1.0, 1.0), 0.0));\n\n    // Add a torus\n    float torus2 = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // Add a cylinder\n    float cylinder2 = length(p.xz - vec2(0.0, 2.0)) - 0.5;\n\n    // Add a cone\n    float cone2 = length(p - vec3(0.0, 0.0, 2.0)) - 1.", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat3(\n        s.x, u.x, -f.x,\n        s.y, u.y, -f.y,\n        s.z, u.z, -f.z\n    );\n}\n\n/**\n * Return a transform matrix that will transform a ray from world space\n * to view coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat", "\n    float n = snoise(p);\n    n = n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*n*", "\n    //The only difference is that we are using a biomorph instead of a mandlebrot\n    //The biomorph is defined by the function z^2 + c\n    //Where c is the coordinate of the pixel\n    //z is the current value of the biomorph\n    //The biomorph is iterated until the magnitude of z is greater than 2\n    //or the maximum number of iterations is reached\n    //The color of the pixel is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of iterations\n    //The color is determined by the number of", "\n    // The \"w\" parameter is the \"width\" of the pattern.\n    p = mod(p, w);\n\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern for.\n    // The \"p\" parameter is the 2D point that we want to compute the Voronoi pattern", "\n    float r = length(p.xz);\n    float h = p.y;\n    \n    // The bump function.\n    return 1.0 - smoothstep(0.0, 0.01, abs(h) - 0.005 * r);\n}\n\n// The bump mapping function.\nfloat", "\n    //\n    // view_inv: inverse of the view matrix\n    // proj_inv: inverse of the projection matrix\n    // viewp_inv: inverse of the view-projection matrix\n    // scr_pt: screen coordinates of a point\n    //\n    // Returns:\n    //   vec4(0,0,0,0) if scr_pt is outside the viewport\n    //   vec4(0,0,0,1) if scr_pt is inside the viewport\n    //   vec4(x,y,z,1) if scr_pt is inside the viewport\n    //\n    // Note:\n    //   The returned vector is in world coordinates.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1 if the point is inside the viewport,\n    //   and 0 if the point is outside the viewport.\n    //\n    //   The returned vector is not normalized.\n    //   The w component is 1", "\n    rounded = min(rounded, thick.y);\n\n    // Get the distance from the line.\n    float dist = LineDist(uv, pA, pB, thick, rounded);\n\n    // Get the distance from the dash.\n    float dashDist = LineDist(uv, pA, pB, thick, thick.y);\n\n    // If the dash is on, then we want to subtract the dash from the line.\n    // If the dash is off, then we want to add the dash to the line.\n    // This is a simple way to do a subtract or add operation.\n    return dist - dashOn * dashDist;\n}\n\n// This is the same as the above, but it returns a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\n// Pass it UVs, line end points, line thickness (x is along the line and y is perpendicular),\n// How rounded the end points should be (0.0 is rectangular, setting rounded to thick.y will be circular),\n// dashOn is just 1.0 or 0.0 to turn on the dashed lines.\n// This function will make a signed distance field that says how far you are from the edge\n// of the line at any point U,V.\nfloat", "\n  vec3 lightPos = vec3(0.0, 10.0, 0.0);\n  vec3 lightDir = normalize(lightPos - p);\n  float diffuse = max(dot(n, lightDir), 0.0);\n  vec3 diffuseColor = vec3(0.8, 0.8, 0.8);\n  vec3 ambientColor = vec3(0.2, 0.2, 0.2);\n  vec3 diffuseLight = diffuse * diffuseColor;\n  vec3 ambientLight = ambientColor;\n  vec3 light = diffuseLight + ambientLight;\n\n  // ambient occlusion\n  float ao = texture(aoMap, p.xz * 0.01).r;\n  light *= ao;\n\n  return light;\n}\n\n// Ray marching\n// p : ray origin\n// d : ray direction\n// t : distance to intersection\n// n : normal at intersection\n// m : material at intersection\nbool RayMarch(vec3 p, vec3 d, out float t, out vec3 n, out Material m)\n{\n  t = 0.0;\n  for (int i = 0; i < MAX_STEPS; i++)\n  {\n    vec3 p = p + d * t;\n    float h = Map(p);\n    if (h < 0.001)\n    {\n      n = GetNormal(p);\n      m = GetMaterial(p);\n      return true;\n    }\n    t += h;\n    if (t > MAX_DIST)\n    {\n      return false;\n    }\n  }\n  return false;\n}\n\n// Ray marching\n// p : ray origin\n// d : ray direction\n// t : distance to intersection\n// n : normal at intersection\n// m : material at intersection\nbool RayMarch(vec3 p, vec3 d, out float t, out vec3 n, out Material m, out vec3 p2)\n{\n  t = 0.0;\n  for (int i = 0; i < MAX_STEPS; i++)\n  {", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\treturn vec2( tN, tF );\n}\n\n// ray-box intersection (simplified)\nvec", "          ___\n    float y = (x - a) / (b - a);                 //  /     \\      /     \\      /     \\      /     \\\n    y = y - floor(y);                           // /   ___  \\  /   ___  \\  /   ___  \\  /   ___  \\\n    y = y * 2;                                  // | /     \\ | | /     \\ | | /     \\ | | /     \\ |\n    y = y - 1;                                  // |/   ___  \\| |/   ___  \\| |/   ___  \\| |/   ___  \\\n    y = y * y;                                  // | | /     \\ | | | /     \\ | | | /     \\ | | | /     \\ |\n    y = y * y;                                  // | |/   ___  \\| | |/   ___  \\| | |/   ___  \\| | |/   ___  \\\n    y = y * y;                                  // | | | /     \\ | | | | /     \\ | | | | /     \\ | | | | /     \\ |\n    y = y * y;                                  // | | |/   ___  \\| | | |/   ___  \\| | | |/   ___  \\| | | |/   ___  \\\n    y = y * y;                                  // | | | | /     \\ | | | | | /     \\ | | | | | /     \\ | | | | | /     \\ |\n    y = y * y;                                  // | | | |/   ___  \\| | | | |/   ___  \\| | | | |/   ___  \\| | | | |/   ___  \\\n    y = y * y;                                  // | | | | | /     \\ | | | | | | /     \\ | | | | | | /     \\ | | | | | | /     \\ |\n    y = y * y;                                  // | | | | |/   ___  \\| | | | | |/   ___  \\| | | | | |/   ___  \\| | | | | |/   ___ ", "\n\treturn vec2(a.x*b.x-a.y*b.y, a.x*b.y+b.x*a.y);\n}\n\n// z * z\nvec", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float rdrd = dot(rd,rd);\n    float oaoa = dot(oa,oa);\n    float a = rdrd*baba - bard*bard;\n    float b = rdrd*baoa - bard*rdoa;\n    float c = baba*oaoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h<0.0 ) return vec4(-1.0);\n    float t = (-b - sqrt(h))/a;\n    if( t<0.0 ) return vec4(-1.0);\n    vec3  n = oaoa + t*bard*ba - oa;\n    float d = dot(n,n);\n    return vec4( t, n*inversesqrt(d) );\n}\n\n// ray-cone intersection (returns t and normal)\nvec", "\n\n\tvec2 p = P-U;\n\tfloat d = length(p);\n\t\n\tO = vec4(C, smoothstep(r,r-1.,d));\n}\n\nvoid main(void)\n{\n\tvec2 U = gl_FragCoord.xy;\n\tvec2 P = iMouse.xy;\n\t\n\tvec4 O = vec4(0.);\n\t\n\tsphere(O, U, P, 100., vec3(1.));\n\t\n\tgl_FragColor = O;\n}", "\n    p.xz *= rot(iTime * 0.5);\n    p.yz *= rot(iTime * 0.5);\n    p.xy *= rot(iTime * 0.5);\n\n    // add a sphere\n    float d = length(p) - 1.0;\n\n    // add a box\n    d = max(d, -box(p, vec3(0.5)));\n\n    // add a torus\n    d = max(d, -torus(p, vec2(0.5, 0.1)));\n\n    // add a cylinder\n    d = max(d, -cylinder(p, vec2(0.5, 0.1)));\n\n    // add a plane\n    d = max(d, p.y + 0.5);\n\n    return d;\n}\n\n// raymarching\nvec", "\n    float scale = float(N)/float(N-1);\n    float scale2 = scale*scale;\n    float scale3 = scale2*scale;\n    float scale4 = scale3*scale;\n    float scale5 = scale4*scale;\n    float scale6 = scale5*scale;\n    float scale7 = scale6*scale;\n    float scale8 = scale7*scale;\n    float scale9 = scale8*scale;\n    float scale10 = scale9*scale;\n    float scale11 = scale10*scale;\n    float scale12 = scale11*scale;\n    float scale13 = scale12*scale;\n    float scale14 = scale13*scale;\n    float scale15 = scale14*scale;\n    float scale16 = scale15*scale;\n    float scale17 = scale16*scale;\n    float scale18 = scale17*scale;\n    float scale19 = scale18*scale;\n    float scale20 = scale19*scale;\n    float scale21 = scale20*scale;\n    float scale22 = scale21*scale;\n    float scale23 = scale22*scale;\n    float scale24 = scale23*scale;\n    float scale25 = scale24*scale;\n    float scale26 = scale25*scale;\n    float scale27 = scale26*scale;\n    float scale28 = scale27*scale;\n    float scale29 = scale28*scale;\n    float scale30 = scale29*scale;\n    float scale31 = scale30*scale;\n    float scale32 = scale31*scale;\n    float scale33 = scale32*scale;\n    float scale34 = scale33*scale;\n    float scale35 = scale34*scale;\n    float scale36 = scale35*scale;\n    float scale37 = scale36*scale;\n    float scale38 = scale37*scale;\n    float scale39 = scale38*scale;\n    float scale40 = scale39*scale;\n    float scale41 = scale", "\n    p.x *= 1.0 + sin(p.y * 10.0) * 0.05;\n    p.y *= 1.0 + sin(p.x * 10.0) * 0.05;\n    \n    // The scale tiles are made of two sets of fans.\n    float fan1 = fan(p, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ", "\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c \u043f\u043b\u0430\u043c\u044f \u0432\u043d\u0438\u0437\n    currentRayPosition.y -= 1.0;\n\n    // \u0441\u043c\u0435\u0449\u0430\u0435\u043c", "\n    float flameDistance = length(currentRayPosition - flamePosition) - flameRadius;\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float wallDistance = sdBox(currentRayPosition, vec3(0.0), vec3(1.0));\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float sphereDistance = sdSphere(currentRayPosition, vec3(0.0), 0.5);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float planeDistance = sdPlane(currentRayPosition, vec3(0.0, 1.0, 0.0), vec3(0.0));\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float boxDistance = sdBox(currentRayPosition, vec3(-0.5), vec3(0.5));\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float cylinderDistance = sdCylinder(currentRayPosition, vec3(0.0), 0.5);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float coneDistance = sdCone(currentRayPosition, vec3(0.0), 0.5);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float torusDistance = sdTorus(currentRayPosition, vec3(0.0), 0.5, 0.1);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float capsuleDistance = sdCapsule(currentRayPosition, vec3(0.0), vec3(0.0, 0.0, 1.0), 0.5);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0442\u0435\u043d\u043a\u0438\n    float capsuleDistance2 = sdCapsule(currentRayPosition, vec3(0.0), vec3(0.0, 0.0, 1.0), 0.5);\n    // \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u043c \u0440\u0430\u0441\u0441\u0442\u043e\u044f", "\n    float sm2 = sm * sm;\n    \n    // Smoothing factor.\n    float sm3 = sm2 * sm;\n    \n    // Fractional part.\n    float fract = x - floor(x);\n    \n    // Smoothing factor.\n    float fract2 = fract * fract;\n    \n    // Smoothing factor.\n    float fract3 = fract2 * fract;\n    \n    // Smoothing factor.\n    float fract4 = fract2 * fract2;\n    \n    // Smoothing factor.\n    float fract5 = fract4 * fract;\n    \n    // Smoothing factor.\n    float fract6 = fract4 * fract2;\n    \n    // Smoothing factor.\n    float fract7 = fract6 * fract2;\n    \n    // Smoothing factor.\n    float fract8 = fract4 * fract4;\n    \n    // Smoothing factor.\n    float fract9 = fract8 * fract;\n    \n    // Smoothing factor.\n    float fract10 = fract8 * fract2;\n    \n    // Smoothing factor.\n    float fract11 = fract10 * fract2;\n    \n    // Smoothing factor.\n    float fract12 = fract8 * fract4;\n    \n    // Smoothing factor.\n    float fract13 = fract12 * fract2;\n    \n    // Smoothing factor.\n    float fract14 = fract12 * fract4;\n    \n    // Smoothing factor.\n    float fract15 = fract14 * fract2;\n    \n    // Smoothing factor.\n    float fract16 = fract12 * fract8;\n    \n    // Smoothing factor.\n    float fract17 = fract16 * fract2;\n    \n    // Smoothing factor.\n    float fract18 = fract16 * fract4;\n    \n    // Smoothing factor.\n    float fract19 = fract18 * fract2;\n    \n    // Smoothing factor.\n    float fract20 = fract16 * fract8;\n    \n    // Smoothing factor.\n    float fract21 = fract20 * fract2;\n    \n", "\n    //\n    // p = p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*p*", "\n    vec3 s = vec3(1.0, 1.0, 1.0) / 3.0;\n    vec3 f = fract(p * s);\n    vec3 i = floor(p * s);\n\n    // Determining the 4 vertices of the tetrahedron.\n    vec3 v0 = i;\n    vec3 v1 = i + vec3(1.0, 0.0, 0.0);\n    vec3 v2 = i + vec3(0.0, 1.0, 0.0);\n    vec3 v3 = i + vec3(0.0, 0.0, 1.0);\n\n    // Determining the 4 vertices of the tetrahedron's cube.\n    vec3 c0 = v0;\n    vec3 c1 = v1;\n    vec3 c2 = v2;\n    vec3 c3 = v3;\n\n    // Determining the 4 vertices of the tetrahedron's simplex.\n    vec3 s0 = v0;\n    vec3 s1 = v1;\n    vec3 s2 = v2;\n    vec3 s3 = v3;\n\n    // Determining the 4 vertices of the tetrahedron's simplex.\n    vec3 t0 = v0;\n    vec3 t1 = v1;\n    vec3 t2 = v2;\n    vec3 t3 = v3;\n\n    // Determining the 4 vertices of the tetrahedron's simplex.\n    vec3 u0 = v0;\n    vec3 u1 = v1;\n    vec3 u2 = v2;\n    vec3 u3 = v3;\n\n    // Determining the 4 vertices of the tetrahedron's simplex.\n    vec3 v0 = v0;\n    vec3 v1 = v1;\n    vec3 v2 = v2;\n    vec3 v3 = v3;\n\n    // Determining the 4 vertices of the tetrahedron's simple", "\n    float n = snoise(p);\n    \n    // The quantized value.\n    float q = floor(n*10.0)/10.0;\n    \n    // The tapered value.\n    float t = smoothstep(-0.1, 0.1, n);\n    \n    // The final value.\n    return q*t;\n}\n\n// The main function.\nvoid main(){\n    \n    // The pixel coordinates.\n    vec2 p = gl_FragCoord.xy;\n    \n    // The function value.\n    float f = func(p);\n    \n    // The final color.\n    vec3 c = vec3(f);\n    \n    // The output color.\n    gl_FragColor = vec4(c, 1.0);\n}\n", "\n  vec3 balloonPosition = vec3(0.0, 0.0, 0.0);\n  \n  // Then we define the radius of the balloon\n  float balloonRadius = 0.5;\n  \n  // Then we define the height of the balloon\n  float balloonHeight = 1.0;\n  \n  // Then we define the balloon color\n  vec3 balloonColor = vec3(1.0, 0.0, 0.0);\n  \n  // Then we define the balloon specular color\n  vec3 balloonSpecularColor = vec3(1.0, 1.0, 1.0);\n  \n  // Then we define the balloon specular power\n  float balloonSpecularPower = 10.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;\n  \n  // Then we define the balloon specular color\n  float balloonSpecularColor = 1.0;", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\t\n\t// return the intersection t value\n\tif( tN > tF ) return vec4(-1.0);\n\treturn vec4(tN, tF, tN, tF);\n}\n\n// ray box intersection by iq https://www.shadertoy.com/view/ld23DV\nvec", "\n    vec3 s = vec3(1.0, 1.0, 1.0) / 3.0;\n    vec3 f = fract(p * s);\n    vec3 i = floor(p * s);\n    \n    // Determining the 4 vertices of the tetrahedron.\n    vec3 v0 = i;\n    vec3 v1 = i + vec3(1.0, 0.0, 0.0);\n    vec3 v2 = i + vec3(0.0, 1.0, 0.0);\n    vec3 v3 = i + vec3(0.0, 0.0, 1.0);\n    \n    // Determining the 4 vertices of the tetrahedron's cube.\n    vec3 c0 = v0;\n    vec3 c1 = v1;\n    vec3 c2 = v2;\n    vec3 c3 = v3;\n    \n    // Determining the 4 vertices of the tetrahedron's cube's square.\n    vec3 q0 = c0;\n    vec3 q1 = c1;\n    vec3 q2 = c2;\n    vec3 q3 = c3;\n    \n    // Determining the 4 vertices of the tetrahedron's cube's square's triangle.\n    vec3 r0 = q0;\n    vec3 r1 = q1;\n    vec3 r2 = q2;\n    vec3 r3 = q3;\n    \n    // Determining the 4 vertices of the tetrahedron's cube's square's triangle's point.\n    vec3 a0 = r0;\n    vec3 a1 = r1;\n    vec3 a2 = r2;\n    vec3 a3 = r3;\n    \n    // Determining the 4 vertices of the tetrahedron's cube's square's triangle's point's \n    // fractional position.\n    vec3 b0 = a0;\n    vec3 b1 = a1", "\n //c=vec3(0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(0.5,0.5,0.5);//overwrite color with monochrome\n //c=vec3(", "\n    //Use a counter instead.\n    int i;\n    for(i=0; i<MAX_ITERATIONS; i++){\n        //Calculate the next iteration\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        //Check if the point is outside the circle with radius 2:\n        //(x*x+y*y) > 4\n        if(dot(z,z) > 4.0) break;\n    }\n    return float(i)/float(MAX_ITERATIONS);\n}\n\nvoid main() {\n    //Calculate the complex number for this pixel:\n    vec2 c = vec2(\n        (gl_FragCoord.x/float(width) - 0.5) * 4.0,\n        (gl_FragCoord.y/float(height) - 0.5) * 4.0\n    );\n    //Start the iteration at the origin\n    vec2 z = vec2(0.0, 0.0);\n    //Calculate the number of iterations\n    float m = mandelbrot(c, z);\n    //Output the number of iterations\n    gl_FragColor = vec4(vec3(m), 1.0);\n}\n", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n\n    //we need to create the translation matrix\n    mat4 translation = mat4(1.0);\n    translation[3] = vec4(-cam, 1.0);\n\n    //we need to create the rotation matrix\n    mat4 rotation = mat4(1.0);\n    rotation[0] = vec4(x, 0.0);\n    rotation[1] = vec4(y, 0.0);\n    rotation[2] = vec4(z, 0.0);\n\n    //we need to create the view matrix\n    return rotation * translation;\n}\n\n//projection matrix\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec", "\n    p = p * 2.0;\n    \n    // Get the integer part of the grid position.\n    vec2 i = floor(p);\n    \n    // Get the fractional part of the grid position.\n    vec2 f = fract(p);\n    \n    // Get the direction of the grid.\n    vec2 dir = vec2(1.0, 0.0);\n    \n    // Rotate the grid.\n    mat2 rot = mat2(dir.x, -dir.y, dir.y, dir.x);\n    \n    // Rotate the fractional part of the grid position.\n    f = rot * f;\n    \n    // Get the distance to the grid.\n    float d = dot(f, f);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f - dir, f - dir);\n    \n    // Get the distance to the center of the grid.\n    float dc = dot(f -", "\n    float t = (x - a) / (b - a);\n    t = clamp(t, 0.0, 1.0);\n    return t;\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat", "\n    float dist = func(xy.x);\n    // if distance is less than 0.001, draw the curve\n    if (dist < 0.001)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float threshold)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy.x);\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws explicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float threshold, float scale)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy.x);\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold)\n    {\n        baseCol = curveCol;\n    }\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold * scale)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws explicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float threshold, float scale, float offset)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy.x);\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold)\n    {\n        baseCol = curveCol;\n    }\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold * scale)\n    {\n        baseCol = curveCol;\n    }\n    // if distance is less than threshold, draw the curve\n    if (dist < threshold * scale + offset)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws explicit function of x defined in func", "\n vec2 n=vec2(0.0,1.0);\n vec2 ne=vec2(1.0,1.0);\n vec2 e=vec2(1.0,0.0);\n vec2 se=vec2(1.0,-1.0);\n vec2 s=vec2(0.0,-1.0);\n vec2 sw=vec2(-1.0,-1.0);\n vec2 w=vec2(-1.0,0.0);\n vec2 nw=vec2(-1.0,1.0);\n // get the value of the current pixel\n float c=texture2D(iChannel0,p).x;\n // get the value of the neighbors\n float nv=texture2D(iChannel0,p+n).x;\n float nev=texture2D(iChannel0,p+ne).x;\n float ev=texture2D(iChannel0,p+e).x;\n float sev=texture2D(iChannel0,p+se).x;\n float sv=texture2D(iChannel0,p+s).x;\n float swv=texture2D(iChannel0,p+sw).x;\n float wv=texture2D(iChannel0,p+w).x;\n float nwv=texture2D(iChannel0,p+nw).x;\n // get the difference of the current pixel and its neighbors\n float dc=c-nv;\n float dn=nv-nev;\n float de=ev-nev;\n float ds=sev-ev;\n float dse=sev-sv;\n float dsw=swv-sv;\n float dw=wv-swv;\n float dnw=nwv-wv;\n // get the average of the differences\n float d=(dc+dn+de+ds+dse+dsw+dw+dnw)/8.0;\n // get the sign of the average\n float s=sign(d);\n // get the absolute value of the average\n float a=abs(d);\n // get the jitter value\n float jv=j*a;\n // get", "\n //f+=.05*sin(p.y*5.);\n //f+=.05*cos(p.x*5.);\n //f+=.05*sin(p.x*5.+p.y*5.);\n //f+=.05*cos(p.x*5.+p.y*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p.z*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.+p.w*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p.z*5.+p.w*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.+p.w*5.+p.z*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p.z*5.+p.w*5.+p.z*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.+p.w*5.+p.z*5.+p.w*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p.z*5.+p.w*5.+p.z*5.+p.w*5.);\n //f+=.05*sin(p.x*5.+p.y*5.+p.z*5.+p.w*5.+p.z*5.+p.w*5.+p.x*5.);\n //f+=.05*cos(p.x*5.+p.y*5.+p", ", but it works\n    c.r = c.r*1.05-0.05;\n    c.g = c.g*0.95+0.05;\n    c.b = c.b*1.05-0.05;\n    return c;\n}\n\n//this is a very simple \"color space\" conversion,\n//it's not a true conversion, but it's close enough\n//for our purposes.\nvec", "\n  vec3 d=abs(p)-s;\n  return vec4(min(max(d.x,max(d.y,d.z)),0.0)+length(max(d,0.0)),1.0);\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec", "\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5,1.5,1.5,1.5);\n //vec4 s=vec4(1.5", "\n    float dist = distScene(pos, depth, steps);\n    int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    Material mat = materials[matrIndex];\n    return Material(matrIndex, mat.color, mat.reflectivity, mat.refractiveIndex, mat.transparency);\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float time)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    float dist = distScene(pos, depth, steps, time);\n    int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    Material mat = materials[matrIndex];\n    return Material(matrIndex, mat.color, mat.reflectivity, mat.refractiveIndex, mat.transparency);\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float time, vec3 camPos)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distSc", "\n    const float a = 2.51f;\n    const float b = 0.03f;\n    const float c = 2.43f;\n    const float d = 0.59f;\n    const float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\n// Tone mapping\nvec", "\n    p.z -= 1.0;\n    \n    // The number of iterations.\n    float n = 1.0;\n    \n    // The radius of the first circle.\n    float r = 1.0;\n    \n    // The radius of the next circle.\n    float r2 = 1.0;\n    \n    // The distance to the next circle.\n    float d = 1.0;\n    \n    // The distance to the next circle.\n    float d2 = 1.0;\n    \n    // The distance to the next circle.\n    float d3 = 1.0;\n    \n    // The distance to the next circle.\n    float d4 = 1.0;\n    \n    // The distance to the next circle.\n    float d5 = 1.0;\n    \n    // The distance to the next circle.\n    float d6 = 1.0;\n    \n    // The distance to the next circle.\n    float d7 = 1.0;\n    \n    // The distance to the next circle.\n    float d8 = 1.0;\n    \n    // The distance to the next circle.\n    float d9 = 1.0;\n    \n    // The distance to the next circle.\n    float d10 = 1.0;\n    \n    // The distance to the next circle.\n    float d11 = 1.0;\n    \n    // The distance to the next circle.\n    float d12 = 1.0;\n    \n    // The distance to the next circle.\n    float d13 = 1.0;\n    \n    // The distance to the next circle.\n    float d14 = 1.0;\n    \n    // The distance to the next circle.\n    float d15 = 1.0;\n    \n    // The distance to the next circle.\n    float d16 = 1.0;\n    \n    // The distance to the next circle.\n    float d17 = 1.0;\n    \n    // The distance to the next circle.\n    float d18 = 1.0;\n    \n    // The distance to the next circle.\n    float d19 = 1.0;\n    \n    // The distance to the next circle.", "\n    float d = sdSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    if (d < 0.0) {\n        return mat(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ", "\n    mat2 m = mat2( 0.80,  0.60, -0.60,  0.80 );\n\n    // initialize the fractal sum\n    float f = 0.0;\n\n    // octaves of noise\n    float amp = 0.5;\n    float freq = 4.0;\n    for ( int i=0; i<5; i++ ) {\n        // rotate the point\n        p = m * p * 2.02;\n\n        // add the noise\n        f += amp * noise( p );\n\n        // scale up the wavelenghts\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n\n    return f;\n}\n\nvoid main() {\n    // get the position of the fragment\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n\n    // get the noise value\n    float n = fbm( p * 10.0 );\n\n    // set the color\n    gl_FragColor = vec4( n, n, n, 1.0 );\n}\n", "\n    \n    // The first point is the wrapped cell point.\n    vec2 cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -= cell;\n    p = p.yx * mat2(0.809016994, -0.587785252, 0.587785252, 0.809016994);\n    \n    // The second point is the wrapped cell point.\n    cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -= cell;\n    p = p.yx * mat2(0.809016994, -0.587785252, 0.587785252, 0.809016994);\n    \n    // The third point is the wrapped cell point.\n    cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -= cell;\n    p = p.yx * mat2(0.809016994, -0.587785252, 0.587785252, 0.809016994);\n    \n    // The fourth point is the wrapped cell point.\n    cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -= cell;\n    p = p.yx * mat2(0.809016994, -0.587785252, 0.587785252, 0.809016994);\n    \n    // The fifth point is the wrapped cell point.\n    cell = floor(p) + vec2(0.5, 0.5);\n    \n    // Rotate space.\n    p -", "\n return u.x*m.y-u.y*m.x;\n}\n\n//return __signed distance of [u] to line trough [a] and [b], a and b must be normalized.\nfloat", "\n return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),dot(m,u)<0.);//branchless\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat", "\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-.1;//draw 1 point\n //c.g=length(u-d)-", "\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return U.x;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1", "\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n}", "\n    return a - dot(a, b) * b;\n}\n\nvec", "\n\tfloat alpha = acos(dot(A, B));\n\tfloat beta = acos(dot(B, C));\n\tfloat gamma = acos(dot(C, A));\n\n\t//calculate area of spherical triangle\n\tfloat area = alpha + beta + gamma - PI;\n\n\t//calculate probability of sampling each triangle\n\tfloat pA = alpha / area;\n\tfloat pB = beta / area;\n\tfloat pC = gamma / area;\n\n\t//sample spherical triangle\n\tfloat r1 = Xi1;\n\tfloat r2 = Xi2;\n\tfloat p = r1 * area;\n\tif (p < pA) {\n\t\tfloat cosTheta = (1.0 - r2) / (1.0 + r2);\n\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\tfloat phi = r2 * PI;\n\t\tw = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\t\twPdf = pA / area;\n\t} else if (p < pA + pB) {\n\t\tfloat cosTheta = (1.0 - r2) / (1.0 + r2);\n\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\tfloat phi = r2 * PI;\n\t\tw = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\t\twPdf = pB / area;\n\t} else {\n\t\tfloat cosTheta = (1.0 - r2) / (1.0 + r2);\n\t\tfloat sinTheta = sqrt(1.0 - cosTheta * cosTheta);\n\t\tfloat phi = r2 * PI;\n\t\tw = vec3(sinTheta * cos(phi), sinTheta * sin(phi), cosTheta);\n\t\twPdf = pC / area;\n\t}\n}\n\n//Function which does triangle sampling proportional to their solid angle.\n//You can find more information and pseudocode here:\n// * Stratified Sampling of Spherical Triangles. J Arvo - \u200e1995\n// *", "\n  v2 x;\n  x.x = U.x;\n  x.y = U.y;\n  return x;\n}\n\nv2 main(){\n  v1 a;\n  a.x = 1;\n  a.y = 2;\n  v2 b;\n  b = c(a);\n  return b;\n}\n", "\n    \n    // The tube is a square with a beveled edge.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with a radius of 0.25.\n    // The beveled edge is a square with", "\n    float w = 0.05;\n\n    // The tube is made of two cylinders.\n    vec3 q = p;\n    q.xz = mod(q.xz, 2.0*w) - w;\n    float d = length(q.xz) - w;\n    float d2 = length(p.xz) - 0.95;\n\n    // The bands are made of two cylinders.\n    vec3 q2 = p;\n    q2.xz = mod(q2.xz, 2.0*w) - w;\n    float d3 = length(q2.xz) - 0.02;\n    float d4 = length(p.xz) - 0.97;\n\n    // The bands are made of two cylinders.\n    vec3 q3 = p;\n    q3.xz = mod(q3.xz, 2.0*w) - w;\n    float d5 = length(q3.xz) - 0.04;\n    float d6 = length(p.xz) - 0.99;\n\n    // The bands are made of two cylinders.\n    vec3 q4 = p;\n    q4.xz = mod(q4.xz, 2.0*w) - w;\n    float d7 = length(q4.xz) - 0.06;\n    float d8 = length(p.xz) - 1.01;\n\n    // The bands are made of two cylinders.\n    vec3 q5 = p;\n    q5.xz = mod(q5.xz, 2.0*w) - w;\n    float d9 = length(q5.xz) - 0.08;\n    float d10 = length(p.xz) - 1.03;\n\n    // The bands are made of two cylinders.\n    vec3 q6 = p;\n    q6.xz = mod(q6.xz, 2.0*w) - w;\n    float d11 = length(q6", "\n    vec3 id = floor(p);\n    \n    // Distance to the grid cell.\n    float d = length(max(abs(p)-gID,0.0));\n    \n    // Blink effect.\n    float blink = sin(iTime*10.0);\n    blink = blink*blink*blink;\n    \n    // Return the distance.\n    return d*blink;\n}\n\n// Distance function for the scene.\nfloat", "\n    float t = 0., d;\n    \n    // Raymarching loop.\n    for(int i = 0; i < 128; i++){\n        \n        // Get the distance to the scene at the current ray position.\n        d = map(o + r * t);\n        \n        // If the distance is less than the minimum distance, return the current ray distance.\n        if(d < EPS){\n            //glow = float(i) / 128.;\n            return t;\n        }\n        \n        // Increment the ray distance.\n        t += d;\n    }\n    \n    // If the ray didn't hit anything, return a large value.\n    return 1000.;\n}\n\n// Calculate the normal at a given point in the scene.\nvec", "\n    const int N = 10;\n    float h = 0.001;\n    float d = 0.0;\n    float s = 0.0;\n    for(int i = 0; i < N; i++){\n        d = sdf(ro + h * lp);\n        s += k * d;\n        h += d;\n    }\n    return clamp(1.0 - s / t, 0.0, 1.0);\n}\n\n// The main function.\nvec", "\n    float e =.0005 * (1.0 / t);\n\n    // Calculate the normal.\n    vec3 n = vec3(0.0);\n    for( int i=ZERO; i<8; i++ )\n    {\n        vec3 eps = vec3(e,0.0,0.0);\n        eps.xy *= HASH12(p.xy);\n        vec3 v = vec3(\n            map(p+eps.xyy, edge, crv, t),\n            map(p+eps.yxy, edge, crv, t),\n            map(p+eps.yyx, edge, crv, t)\n        );\n        n += v - map(p, edge, crv, t);\n    }\n\n    return normalize(n);\n}\n\n// Calculate the normal, and also the edge and curvature values.\nvec", "\n    vec3 w = vec3(dot(p3, m[0]), dot(p3, m[1]), dot(p3, m[2]));\n    // normalize weights\n    w = w / (w.x + w.y + w.z);\n    // return barycentric coordinates\n    return vec4(w, 1.0 - w.x - w.y);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n    vec4 hex = vec4(0.0);\n    \n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons being the \n    // odd-numbered rows, and the second row being the even-numbered rows.\n    //\n    // The first row of hexagons is offset by 0.5 in the x direction, and the second row is offset\n    // by 1.0 in the x direction.\n    //\n    // The y direction is offset by 0.5 for the first row, and 1.0 for the second row.\n    //\n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons being the \n    // odd-numbered rows, and the second row being the even-numbered rows.\n    //\n    // The first row of hexagons is offset by 0.5 in the x direction, and the second row is offset\n    // by 1.0 in the x direction.\n    //\n    // The y direction is offset by 0.5 for the first row, and 1.0 for the second row.\n    //\n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons being the \n    // odd-numbered rows, and the second row being the even-numbered rows.\n    //\n    // The first row of hexagons is offset by 0.5 in the x direction, and the second row is offset\n    // by 1.0 in the x direction.\n    //\n    // The y direction is offset by 0.5 for the first row, and 1.0 for the second row.\n    //\n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons being the \n    // odd-numbered rows, and the second row being the even-numbered rows.\n    //\n    // The first row of hexagons is offset by 0.5 in the x direction, and the second row is offset\n    // by 1.0 in the x direction.\n    //\n    // The y direction is offset by 0.5 for the first row, and 1.", "\n    vec2 uv = vec2(df_truchet(p, dir), atan(p.y, p.x) / 3.1415926535897932384626433832795);\n    \n    // The Truchet distance field is a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.\n    // The Truchet distance field is also a 2D distance field, so we can use it as a mask.", "\n    q.x += sin(u_time * 0.5) * 0.05;\n    q.y += cos(u_time * 0.5) * 0.05;\n    \n    // Polar conversion.\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    \n    // The animation.\n    a += u_time * 0.5;\n    \n    // The color.\n    float c = cos(a * 10.0);\n    \n    // The color.\n    float f = smoothstep(0.0, 0.01, abs(r - 0.5 + c * 0.5));\n    \n    // The color.\n    return f;\n}\n\n// The main function.\nvoid main(){\n    \n    // The pixel.\n    vec2 q = gl_FragCoord.xy / u_resolution.xy;\n    \n    // The color.\n    float f = getPolarCoord(q, 1.0);\n    \n    // The color.\n    vec3 col = vec3(f);\n    \n    // The color.\n    gl_FragColor = vec4(col, 1.0);\n}", "\n    vec3 w = vec3(dot(p3, n[0]), dot(p3, n[1]), dot(p3, n[2]));\n    // normalize weights\n    w = w / (w.x + w.y + w.z);\n    // return barycentric coordinates\n    return vec4(w.x, w.y, w.z, 1.0 - w.x - w.y - w.z);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", ".\n  if (abs(r.w) < 1e-6 || abs(p.w) < 1e-6) {\n    return 0.0;\n  }\n  // The line is defined by the equation\n  //   r.x + t * (p.x - r.x) / r.w = q.x\n  //   r.y + t * (p.y - r.y) / r.w = q.y\n  //   r.z + t * (p.z - r.z) / r.w = q.z\n  //\n  // We can solve for t by substituting the above\n  // into the equation for the distance squared\n  //   (q.x - r.x)^2 + (q.y - r.y)^2 + (q.z - r.z)^2\n  //   = (p.x - r.x)^2 / r.w^2 + (p.y - r.y)^2 / r.w^2 + (p.z - r.z)^2 / r.w^2\n  //   + 2 * t * ((p.x - r.x) * (q.x - r.x) / r.w^2 + (p.y - r.y) * (q.y - r.y) / r.w^2 + (p.z - r.z) * (q.z - r.z) / r.w^2)\n  //\n  // We can solve for t by substituting the above\n  // into the equation for the distance squared\n  //   (q.x - r.x)^2 + (q.y - r.y)^2 + (q.z - r.z)^2\n  //   = (p.x - r.x)^2 / r.w^2 + (p.y - r.y)^2 / r.w^2 + (p.z - r.z)^2 / r.w^2\n  //   + 2 * t * ((p.x - r.x) * (q.x - r.x) / r.w^2 + (p.y - r.y) * (q", "\n    float t = floor(p.x) + floor(p.y);\n    float s = step(1.0, mod(t, 2.0));\n    \n    // The shadow.\n    float sh = s;\n    \n    // The line width.\n    float lW2 = lW * 0.5;\n    \n    // The line width.\n    float lW4 = lW2 * 0.5;\n    \n    // The line width.\n    float lW8 = lW4 * 0.5;\n    \n    // The line width.\n    float lW16 = lW8 * 0.5;\n    \n    // The line width.\n    float lW32 = lW16 * 0.5;\n    \n    // The line width.\n    float lW64 = lW32 * 0.5;\n    \n    // The line width.\n    float lW128 = lW64 * 0.5;\n    \n    // The line width.\n    float lW256 = lW128 * 0.5;\n    \n    // The line width.\n    float lW512 = lW256 * 0.5;\n    \n    // The line width.\n    float lW1024 = lW512 * 0.5;\n    \n    // The line width.\n    float lW2048 = lW1024 * 0.5;\n    \n    // The line width.\n    float lW4096 = lW2048 * 0.5;\n    \n    // The line width.\n    float lW8192 = lW4096 * 0.5;\n    \n    // The line width.\n    float lW16384 = lW8192 * 0.5;\n    \n    // The line width.\n    float lW32768 = lW16384 * 0.5;\n    \n    // The line width.\n    float lW65536 = lW32768 * 0.", "\n\tvec2 w = max(abs(ddx), abs(ddy));\n\t// analytical integral (box filter)\n\tvec2 i = 2.0*(p*p + (w*w - 0.25))/w;\n\t// x(t) = (i0 + 0.5*i1)*t + 0.5*(i0 - i1)\n\treturn (i.x + i.y)*0.5 + 0.5*(i.y - i.x);\n}\n\n// grid ratio\nfloat", "\n    mr = floor(n) + vec2(0.5);\n    // take half-cell position\n    mg = floor(f) + vec2(0.5);\n    // take cell corners\n    vec2 m[4];\n    m[0] = mr;\n    m[1] = mr + vec2(1.0, 0.0);\n    m[2] = mr + vec2(0.0, 1.0);\n    m[3] = mr + vec2(1.0, 1.0);\n    // find closest corner\n    float d = dot(m[0] - n, m[0] - n);\n    float d2 = dot(m[1] - n, m[1] - n);\n    if (d2 < d) {\n        d = d2;\n        mr = m[1];\n    }\n    d2 = dot(m[2] - n, m[2] - n);\n    if (d2 < d) {\n        d = d2;\n        mr = m[2];\n    }\n    d2 = dot(m[3] - n, m[3] - n);\n    if (d2 < d) {\n        d = d2;\n        mr = m[3];\n    }\n    // find closest side\n    d2 = dot(m[0] - f, m[0] - f);\n    if (d2 < d) {\n        d = d2;\n        mg = m[0];\n    }\n    d2 = dot(m[1] - f, m[1] - f);\n    if (d2 < d) {\n        d = d2;\n        mg = m[1];\n    }\n    d2 = dot(m[2] - f, m[2] - f);\n    if (d2 < d) {\n        d = d2;\n        mg = m[2];\n    }\n    d2 = dot(m[3] - f, m[3] - f);\n    if (d2 < d) {\n        d = d2;\n        mg = m[", "\n    vec2 pos = vec2(0.0);\n    if(t < 0.0){\n        pos = vec2(0.0);\n    }else if(t < 0.25){\n        pos = vec2(0.0, 0.5);\n    }else if(t < 0.5){\n        pos = vec2(0.5, 0.5);\n    }else if(t < 0.75){\n        pos = vec2(0.5, 0.0);\n    }else if(t < 1.0){\n        pos = vec2(0.0, 0.0);\n    }\n    return pos;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    //\n    // 1 out, 2 in...\n    //\n    // vec3 p3 = fract(vec3(p.xyx) *.1031);\n    // p3 += dot(p3, p3.yzx + 33.33);\n    // return fract((p3.xx+p3.yz)*p3.zy);\n\n    // 2 out, 2 in...\n    //\n    // const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n    //                     0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n    //                    -0.577350269189626,  // -1.0 + 2.0 * C.x\n    //                     0.024390243902439); // 1.0 / 41.0\n    // vec4 p4 = fract(vec4(p.xyxy) * C.www);\n    // p4 += dot(p4, p4.wzxy+C.xxzz);\n    // return vec2(p4.x, p4.y + p4.z);\n\n    // 2 out, 3 in...\n    //\n    // const vec3 C = vec3(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n    //                     0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n    //                    -0.577350269189626); // -1.0 + 2.0 * C.x\n    // vec4 p4 = fract(vec4(p.xyxy) * C.xyzz);\n    // p4 += dot(p4, p4.wzxy+", "\n    //\n    // float n = sin(p.x) * 43758.5453123;\n    // n = fract(sin(n) * 43758.5453123);\n    // n += sin(p.y) * 43758.5453123;\n    // n = fract(sin(n) * 43758.5453123);\n    // return n;\n\n    // This is a pretty standard 2D hash, but it's a bit slower than the one above,\n    // so if you're in a hurry, and framerate is not a huge issue for you, go with\n    // this one.\n    float n = p.x * 17.0 + p.y * 23.0;\n    return fract(sin(n) * 43758.5453123);\n}\n\n// vec3 to float hash.\nfloat", "\n    float a = length(p0 - p1);\n    float b = length(p1 - p2);\n    float c = length(p2 - p0);\n    \n    // Semiperimeter.\n    float s = (a + b + c) / 2.0;\n    \n    // Incenter.\n    return (a * p0 + b * p1 + c * p2) / (a + b + c);\n}\n\n// Triangle's circumcenter: The center of the circumscribed circle, which in essence is the\n// smallest circle that can be drawn around a triangle.\nvec", "\n    float a = length(p1 - p0);\n    float b = length(p2 - p1);\n    float c = length(p0 - p2);\n\n    // Semiperimeter.\n    float s = (a + b + c) / 2.0;\n\n    // Area of the triangle.\n    float A = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Radius of the incircle.\n    return A / s;\n}\n\n// The radius of the triangle's circumcircle: I'm keeping this separate to the function\n// above, but you could amalgamate the two. \nfloat", "\n   // The projection is a plane in 3D space.\n   // The plane is defined by three points.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the origin to the plane\n   // is the distance from the origin to the plane.\n   // The distance from the", "\n    vec2 v0, v1, v2, v3, v4, v5, v6, v7;\n    \n    // The first step is to find the cell that the point is in.\n    // We do this by finding the cell that contains the point, and then iterating through the cell's neighbors\n    // until we find a quadrilateral.\n    //\n    // The cell that contains the point is the cell that contains the point's x and y coordinates.\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate divided by\n    // the cell size.\n    //\n    // The cell that contains the point's x coordinate is the cell that contains the point's x coordinate divided by\n    // the cell size.\n    // The cell that contains the point's y coordinate is the cell that contains the point's y coordinate", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    //set background color\n    vec3 col = vec3(0.0);\n\n    //set up camera\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camTarget = vec3(0.0, 0.0, 1.0);\n    vec3 camDir = normalize(camTarget - camPos);\n    vec3 camRight = normalize(cross(camDir, vec3(0.0, 1.0, 0.0)));\n    vec3 camUp = normalize(cross(camRight, camDir));\n\n    //set up ray\n    vec3 rayOrigin = camPos;\n    vec3 rayDir = normalize(camRight * uv.x + camUp * uv.y + camDir);\n\n    //set up sphere\n    vec3 sphereCenter = vec3(0.0, 0.0, 1.0);\n    float sphereRadius = 0.5;\n\n    //intersect ray with sphere\n    float a = dot(rayDir, rayDir);\n    float b = 2.0 * dot(rayOrigin - sphereCenter, rayDir);\n    float c = dot(rayOrigin - sphereCenter, rayOrigin - sphereCenter) - sphereRadius * sphereRadius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant > 0.0) {\n        float t1 = (-b + sqrt(discriminant)) / (2.0 * a);\n        float t2 = (-b - sqrt(discriminant)) / (2.0 * a);\n        float t = min(t1, t2);\n        if (t > 0.0) {\n            vec3 hitPos = rayOrigin + rayDir * t;\n            vec3 normal = normalize(hitPos - sphereCenter);\n            col = vec3(1.0, 0.0, 0.0);\n        }\n    }\n\n    //output color\n    fragColor", "\n    //p = fract(p * vec2(233.34, 851.73));\n    //p += dot(p, p + 23.45);\n    \n    // I like this one best.\n    p = p*p*157.139 + p*137.549;\n    return fract((p + vec2(233.34, 851.73))*p);\n    \n    // Another nice one from IQ\n    //p = p*p*p*p*521.0 + p*p*p*196.0 + p*p*39.346 + p*78.253;\n    //return fract(p);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    /////////////////////////////////\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n    //\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n    //\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9", "\n    /////////////////////////////////\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the square of a number. //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float sqr( float x ) { return x*x; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the dot product of two //\n    // vectors.                                                                  //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float dot( in vec3 a, in vec3 b ) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the length of a vector.//\n    ///////////////////////////////////////////////////////////////////////////////\n    // float length( in vec3 a ) { return sqrt( dot(a,a) ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the distance between two//\n    // points.                                                                   //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float distance( in vec3 a, in vec3 b ) { return length( a - b ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the cross product of two//\n    // vectors.                                                                  //\n    ///////////////////////////////////////////////////////////////////////////////\n    // vec3 cross( in vec3 a, in vec3 b ) { return vec3( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the normalize of a     //\n    // vector.                                                                   //\n    ///////////////////////////////////////////////////////////////////////////////\n    // vec3 normalize( in vec3 a ) { return a / length(a); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the reflection of a    //\n    // vector.                                                                  ", "\n    // Find whether the hit point is in shadow or not.\n    // If there is no intersection, return the background color.\n    // If there is intersection, return the color.\n    /////////////////////////////////////////////////////////////////////////////\n    // \u627e\u5230\u5149\u7ebf\u662f\u5426\u4e0e\u67d0\u4e9b\u7269\u4f53\u76f8\u4ea4\u3002\n    // \u627e\u5230\u6700\u8fd1\u7684\u4ea4\u70b9\u3002\n    // \u627e\u5230\u4ea4\u70b9\u662f\u5426\u5728\u9634\u5f71\u4e2d\u3002\n    // \u5982\u679c\u6ca1\u6709\u76f8\u4ea4\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\u3002\n    // \u5982\u679c\u6709\u76f8\u4ea4\uff0c\u5219\u8fd4\u56de\u989c\u8272\u3002\n    /////////////////////////////////////////////////////////////////////////////\n    hasHit = false;\n    float tmin = 1e10;\n    vec3 hitPos_temp;\n    vec3 hitNormal_temp;\n    vec3 k_rg_temp;\n    for (int i = 0; i < numObjects; i++) {\n        if (objects[i].Intersect(ray, tmin, hitPos_temp, hitNormal_temp, k_rg_temp)) {\n            hasHit = true;\n            tmin = tmin;\n            hitPos = hitPos_temp;\n            hitNormal = hitNormal_temp;\n            k_rg = k_rg_temp;\n        }\n    }\n    if (!hasHit) {\n        return backgroundColor;\n    }\n\n    // Compute the color using Phong Lighting Model.\n    /////////////////////////////////////////////////////////////////////////////\n    // \u4f7f\u7528Phong\u7167\u660e\u6a21\u578b\u8ba1\u7b97\u989c\u8272\u3002\n    /////////////////////////////////////////////////////////////////////////////\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < numLights; i++) {\n        // Compute the diffuse and specular components.\n        /////////////////////////////////////////////////////////////////////////////\n        // \u8ba1\u7b97\u6f2b\u53cd\u5c04\u548c\u955c\u9762\u53cd\u5c04\u5206\u91cf\u3002\n        /////////////////////////////////////////////////////////////////////////////\n        vec3 lightDir = normalize(lights[i].position - hitPos);\n        float diffuse = max(dot(lightDir, hitNormal), 0.0);\n        vec3 reflectDir = reflect(-lightDir, hitNormal);\n        float specular = pow(max(dot(reflectDir, normalize(ray.direction)), 0.0), 16.0);\n\n        // Compute the shadow.\n       ", "\n    vec2 p01 = p1 - p0;\n    vec2 p12 = p2 - p1;\n    vec2 p20 = p0 - p2;\n\n    // distances\n    float d01 = length(p01);\n    float d12 = length(p12);\n    float d20 = length(p20);\n\n    // angles\n    float a01 = atan(p01.y, p01.x);\n    float a12 = atan(p12.y, p12.x);\n    float a20 = atan(p20.y, p20.x);\n\n    // min/max angles\n    float amin = min(a01, min(a12, a20));\n    float amax = max(a01, max(a12, a20));\n\n    // min/max distances\n    float dmin = min(d01, min(d12, d20));\n    float dmax = max(d01, max(d12, d20));\n\n    // compute bounding box\n    vec2 pmin = vec2(cos(amin), sin(amin)) * dmin;\n    vec2 pmax = vec2(cos(amax), sin(amax)) * dmax;\n\n    return vec4(pmin, pmax);\n}\n\n// Exact BBox to a cubic bezier\nvec", "\n    vec3 pmin = min( min( p0, p1 ), min( p2, p3 ) );\n    vec3 pmax = max( max( p0, p1 ), max( p2, p3 ) );\n\n    // control points\n    vec3 c0 = ( p0 + p1 ) * 0.5;\n    vec3 c1 = ( p1 + p2 ) * 0.5;\n    vec3 c2 = ( p2 + p3 ) * 0.5;\n    vec3 c3 = ( c0 + c1 ) * 0.5;\n    vec3 c4 = ( c1 + c2 ) * 0.5;\n    vec3 c5 = ( c3 + c4 ) * 0.5;\n\n    // control points\n    vec3 c6 = ( c0 + c3 ) * 0.5;\n    vec3 c7 = ( c3 + c5 ) * 0.5;\n    vec3 c8 = ( c5 + c6 ) * 0.5;\n    vec3 c9 = ( c6 + c7 ) * 0.5;\n    vec3 c10 = ( c7 + c8 ) * 0.5;\n    vec3 c11 = ( c8 + c9 ) * 0.5;\n    vec3 c12 = ( c9 + c10 ) * 0.5;\n    vec3 c13 = ( c10 + c11 ) * 0.5;\n    vec3 c14 = ( c11 + c12 ) * 0.5;\n    vec3 c15 = ( c12 + c13 ) * 0.5;\n    vec3 c16 = ( c13 + c14 ) * 0.5;\n    vec3 c17 = ( c14 + c15 ) * 0.5;\n    vec3 c18 = ( c15 + c16 ) * 0.5;\n    vec3 c19 = ( c16 + c17 ) * 0.5;\n", "\n    const float PI = 3.1415926535897932384626433832795;\n    const float TWO_PI = 6.283185307179586476925286766559;\n    const float HALF_PI = 1.5707963267948966192313216916398;\n    const float INV_PI = 0.31830988618379067153776752674503;\n    const float INV_TWO_PI = 0.15915494309189533576888378337251;\n    const float INV_HALF_PI = 0.63661977236758134307553505349006;\n    const float SQRT_TWO = 1.4142135623730950488016887242097;\n    const float SQRT_THREE = 1.7320508075688772935274463415059;\n    const float SQRT_TWO_PI = 2.5066282746310005024157652848110;\n    const float SQRT_HALF_PI = 1.2533141373155002512078826424055;\n    const float SQRT_INV_TWO_PI = 0.79788456080286535587989211986876;\n    const float SQRT_INV_", "\n    return 0.5 * ( 1.0 - cos( k * PI ) ); // EaseInOut\n}\n\n/**\n * Linear Easing Curve\n */\nfloat", "\n    const vec4 C = vec4(0.211324865405187,\n                        // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,\n                        // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626,\n                        // -1.0 + 2.0 * C.x\n                        0.024390243902439);\n                        // 1.0 / 41.0\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1;\n    // i1.x = step( x0.y, x0.x ); // x0.x > x0.y? 1.0 : 0.0\n    // i1.y = 1.0 - i1.x;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    // x0 = x0 - 0.0 + 0.0 * C.xx ;\n    // x1 = x0 - i1 + 1.0 * C.xx ;\n    // x2 = x0 - 1.0 + 2.0 * C.xx ;\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod(i, 289.0); // Avoid truncation effects in permutation\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n                        + i.x + vec3(0.0, i1.x, 1", "\n\tvec2 uv = fragCoord/iResolution.xy;\n\n\t// Time varying pixel color\n\tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n    coord -= res/2.0;\n\n    // Scale the coordinate so that the julia set is in the [-2;-2] - [2;2] space.\n    coord *= 4.0/res.x;\n\n    return coord;\n}\n\n// Calculate the distance from the origin to the point (x;y).\nfloat", "\n    vec2 w = fwidth(p) + 0.001;\n    // analytical integral (box filter)\n    vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    return 0.5 - 0.5*i.x*i.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n    vec4 p = mix(vec4(rgb.bg, K.wz), vec4(rgb.gb, K.xy), step(rgb.b, rgb.g));\n    vec4 q = mix(vec4(p.xyw, rgb.r), vec4(rgb.r, p.yzx), step(p.x, rgb.r));\n\n    float d = q.x - min(q.w, q.y);\n    float e = 1.0e-10;\n    return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Higher quality, more disperse, but slower.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D simplex noise.\n//\n// Should match the noise function in the noise module.\nfloat", "\n    const float eps = 0.0005;\n    const vec2 h = vec2(eps,0);\n    return normalize( p - vec3(\n        map(p-h.xyy).x,\n        map(p-h.yxy).x,\n        map(p-h.yyx).x ) );\n}\n\n// Tetrahedral distance function.\nfloat", "\n    return fract(sin(dot(q.x, q.y, 19.19898))*43758.5453);\n}\n\n// random hash\nfloat", "\n    float angle = width * 2. * PI;\n    float r = radius * cos(angle);\n    float h = radius * sin(angle);\n    float d = sqrt(r*r + h*h);\n    float a = atan(h, r);\n    float b = atan(h, d-r);\n    float c = atan(h, d);\n    float d1 = a - b;\n    float d2 = c - b;\n    float d3 = c - a;\n    float d4 = b - a;\n    float d5 = c - a;\n    float d6 = c - b;\n    float d7 = b - a;\n    float d8 = c - b;\n    float d9 = a - b;\n    float d10 = c - a;\n    float d11 = b - a;\n    float d12 = c - b;\n    float d13 = a - b;\n    float d14 = c - a;\n    float d15 = b - a;\n    float d16 = c - b;\n    float d17 = a - b;\n    float d18 = c - a;\n    float d19 = b - a;\n    float d20 = c - b;\n    float d21 = a - b;\n    float d22 = c - a;\n    float d23 = b - a;\n    float d24 = c - b;\n    float d25 = a - b;\n    float d26 = c - a;\n    float d27 = b - a;\n    float d28 = c - b;\n    float d29 = a - b;\n    float d30 = c - a;\n    float d31 = b - a;\n    float d32 = c - b;\n    float d33 = a - b;\n    float d34 = c - a;\n    float d35 = b - a;\n    float d36 = c - b;\n    float d37 = a - b;\n    float d38 = c - a;\n    float d39 = b - a;\n   ", "\n    const vec4 C = vec4(0.211324865405187,\n                        0.366025403784439,\n                        -0.577350269189626,\n                        0.024390243902439);\n\n    // First corner (x0)\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other two corners (x1, x2)\n    vec2 i1 = vec2(0.0);\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec2 x1 = x0.xy + C.xx - i1;\n    vec2 x2 = x0.xy + C.zz;\n\n    // Do some permutations to avoid\n    // truncation effects in permutation\n    i = mod(i, 289.0);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0))\n        + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0),\n                            dot(x1, x1),\n                            dot(x2, x2)),\n                0.0);\n\n    m = m*m ;\n    m = m*m ;\n\n    // Gradients:\n    //  41 pts uniformly over a line, mapped onto a diamond\n    //  The ring size 17*17 = 289 is close to a multiple\n    //      of 41 (41*7 = 287)\n\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h =", "\n\tvec2 uv = (fragCoord.xy - 0.5*iResolution.xy) / iResolution.y;\n\t\n\t// camera\n\tvec3 camPos = vec3(0.0, 0.0, 2.0);\n\tvec3 camTarget = vec3(0.0, 0.0, 0.0);\n\tvec3 camDir = normalize(camTarget - camPos);\n\tvec3 camRight = normalize(cross(vec3(0.0, 1.0, 0.0), camDir));\n\tvec3 camUp = normalize(cross(camDir, camRight));\n\t\n\t// ray\n\tvec3 rayDir = normalize(camDir + uv.x*camRight + uv.y*camUp);\n\t\n\t// sphere\n\tvec3 sphereCenter = vec3(0.0, 0.0, 0.0);\n\tfloat sphereRadius = 1.0;\n\t\n\t// ray-sphere intersection\n\tvec3 oc = camPos - sphereCenter;\n\tfloat a = dot(rayDir, rayDir);\n\tfloat b = 2.0 * dot(oc, rayDir);\n\tfloat c = dot(oc, oc) - sphereRadius*sphereRadius;\n\tfloat d = b*b - 4.0*a*c;\n\tif(d < 0.0){\n\t\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n\t\treturn;\n\t}\n\tfloat t = (-b - sqrt(d)) / (2.0*a);\n\tvec3 hitPos = camPos + t*rayDir;\n\tvec3 normal = normalize(hitPos - sphereCenter);\n\t\n\t// lighting\n\tvec3 lightPos = vec3(0.0, 0.0, 5.0);\n\tvec3 lightDir = normalize(lightPos - hitPos);\n\tfloat diffuse = max(dot(normal, lightDir), 0.0);\n\t\n\t// shading\n\tfragColor = vec4(diffuse, diffuse, diffuse, 1.0);\n}", "\n    vec3 s = vec3(7, 157, 113);\n\n    // Integer part, floor(p), then mod 289.\n    vec3 i = floor(mod(p, 289.0));\n\n    // Fractional part, after the decimal point.\n    vec3 f = fract(p);\n\n    // This is the first part of the hash.\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    // This is the second part of the hash.\n    return mix(mix(mix( dot( s, i + vec3(0.0, 0.0, 0.0) ),\n                        dot( s, i + vec3(1.0, 0.0, 0.0) ), u.x),\n                   mix( dot( s, i + vec3(0.0, 1.0, 0.0) ),\n                        dot( s, i + vec3(1.0, 1.0, 0.0) ), u.x), u.y),\n               mix(mix( dot( s, i + vec3(0.0, 0.0, 1.0) ),\n                        dot( s, i + vec3(1.0, 0.0, 1.0) ), u.x),\n                   mix( dot( s, i + vec3(0.0, 1.0, 1.0) ),\n                        dot( s, i + vec3(1.0, 1.0, 1.0) ), u.x), u.y), u.z);\n}\n\n// Thanks Shane.\nfloat", "\n\tsp = log_spherical(p);\n\n\t// Apply the tiling\n\ttp = tiling(sp);\n\n\t// Apply the rotation\n\trp = rotation(tp);\n\n\t// Compute the scaling factor\n\tmul = scaling(rp);\n}\n\n/*\nCompute the log-spherical distance between two points.\n\n- in `p1`: first point\n- in `p2`: second point\n- out `d`: distance between the two points\n*/\nvoid distance(in vec3 p1, in vec3 p2, out float d)\n{\n\t// Compute the log-spherical distance\n\td = length(p1 - p2);\n}\n\n/*\nCompute the log-spherical distance between two points.\n\n- in `p1`: first point\n- in `p2`: second point\n- out `d`: distance between the two points\n*/\nvoid distance(in vec3 p1, in vec3 p2, out float d, out float d1, out float d2)\n{\n\t// Compute the log-spherical distance\n\td = length(p1 - p2);\n\n\t// Compute the log-spherical distance of the first point\n\td1 = length(p1);\n\n\t// Compute the log-spherical distance of the second point\n\td2 = length(p2);\n}\n\n/*\nCompute the log-spherical distance between two points.\n\n- in `p1`: first point\n- in `p2`: second point\n- out `d`: distance between the two points\n*/\nvoid distance(in vec3 p1, in vec3 p2, out float d, out float d1, out float d2, out float d3)\n{\n\t// Compute the log-spherical distance\n\td = length(p1 - p2);\n\n\t// Compute the log-spherical distance of the first point\n\td1 = length(p1);\n\n\t// Compute the log-spherical distance of the second point\n\td2 = length(p2);\n\n\t// Compute the log-spherical distance of the third point\n\td3 = length(p1 + p2);\n}\n\n/*", "\n    float y = sin(p.x*0.5+iTime*0.5)*0.5+0.5;\n    float r = cos(p.x*0.5+iTime*0.5)*0.5+0.5;\n    float d = length(p-vec3(0.0,y,0.0))-r;\n    \n    //distance to plane = distance to plane minus height\n    float h = sin(p.x*0.5+iTime*0.5)*0.5+0.5;\n    float d2 = p.y-h;\n    \n    //return the minimum of the two distances\n    return vec2(min(d,d2),0.0);\n}\n\n//the normal function returns the normal at a point\nvec", "\n  return vec2 (z.x*w.x-z.y*w.y, z.x*w.y+z.y*w.x);\n}\n\nvec", "\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 0.0), aaSize);\n\t// T to R\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1.0), aaSize);\n\t// R to B\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(1.0, 1.0), vec2(0.0, 1.0), aaSize);\n\t// B to L\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0), aaSize);\n\n\t// L to R\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 0.0), aaSize);\n\t// R to T\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1.0), aaSize);\n\t// T to L\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 1.0), aaSize);\n\t// L to T\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(0.0, 1.0), vec2(1.0, 0.0), aaSize);\n\n\t// T to B\n\tret += drawSquare(p, vec2(0.0, 0.0), vec2(1.0, 0.0), vec2(1.0, 1", "\n    mat3 rot = getRotationMatrix(boxRotation);\n\n    // rotate the position\n    pos = rot * pos;\n\n    // get the distance to the box\n    float dist = length(max(abs(pos) - boxSize, 0.0));\n\n    // return the distance and the material ID\n    return vec2(dist, boxMaterial);\n}\n\n// returns the distance to our sphere and the its associated material ID packed into a vec2\nvec", "\n    float y = sin(pos.x * 0.5 + time * 0.5) * 0.5 + 0.5;\n\n    // return the distance to the sphere and the material ID\n    return vec2(length(pos - vec3(0.0, y, 0.0)) - 0.5, 0.0);\n}\n\n// returns the distance to the ground plane\nfloat", "\n    vec2 s1 = sdSphere(pos, vec3(0.0, 0.0, 0.0), 1.0);\n    vec2 s2 = sdBox(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    vec2 s3 = sdCylinder(pos, vec3(0.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s4 = sdCone(pos, vec3(0.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s5 = sdPlane(pos, vec3(0.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec2 s6 = sdTriangle(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0));\n    vec2 s7 = sdTorus(pos, vec3(0.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s8 = sdCapsule(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s9 = sdCapsule(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0.0), 1.0, 2.0);\n    vec2 s10 = sdCapsule(pos, vec3(0.0, 0.0, 0.0), vec3(1.0, 0.0, 0", "\n    vec3 rayDir = normalize(camDir + (fragCoord.x * u_camRight) + (fragCoord.y * u_camUp));\n    \n    // march the ray through the scene\n    vec4 color = march(camPos, rayDir);\n    \n    // apply lighting\n    color.rgb *= (0.5 + dot(lightDir, rayDir) * 0.5);\n    \n    return color;\n}\n\nvoid main() {\n    \n    // calculate the camera position and direction\n    vec3 camPos = u_camPos;\n    vec3 camDir = normalize(u_camDir);\n    \n    // calculate the direction of the light\n    vec3 lightDir = normalize(u_lightDir);\n    \n    // raymarch the scene\n    vec4 color = marchScene(v_fragCoord, camPos, camDir, lightDir);\n    \n    // output the color\n    gl_FragColor = color;\n}\n", "\n\tvec3 m = 1.0/rd;\n\tvec3 n = m*ro;\n\tvec3 k = abs(m)*rad;\n\tvec3 t1 = -n - k;\n\tvec3 t2 = -n + k;\n\tfloat tN = max( max( t1.x, t1.y ), t1.z );\n\tfloat tF = min( min( t2.x, t2.y ), t2.z );\n\treturn vec2( tN, tF );\n}\n\n//https://www.shadertoy.com/view/XsXXD1\nfloat", "\n\tvec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n\n\t// ray direction\n\tvec3 rayDir = normalize(vec3(uv, 1.0));\n\n\t// ray origin\n\tvec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n\n\t// ray marching\n\tfloat t = 0.0;\n\tfloat maxDist = 100.0;\n\tfloat minDist = 0.001;\n\tfloat dist;\n\tvec3 pos;\n\tvec3 normal;\n\tvec3 color = vec3(0.0);\n\tfloat specular = 0.0;\n\tfloat shadow = 1.0;\n\tfloat shadowDist;\n\tvec3 shadowRayOrigin;\n\tvec3 shadowRayDir;\n\tvec3 shadowPos;\n\tvec3 shadowNormal;\n\tfloat shadowT;\n\tfloat shadowMaxDist;\n\tfloat shadowMinDist;\n\tfloat shadowDist;\n\tvec3 shadowColor = vec3(0.0);\n\tfloat shadowSpecular = 0.0;\n\tfloat shadowShadow = 1.0;\n\tfloat shadowShadowDist;\n\tvec3 shadowShadowRayOrigin;\n\tvec3 shadowShadowRayDir;\n\tvec3 shadowShadowPos;\n\tvec3 shadowShadowNormal;\n\tfloat shadowShadowT;\n\tfloat shadowShadowMaxDist;\n\tfloat shadowShadowMinDist;\n\tfloat shadowShadowDist;\n\tvec3 shadowShadowColor = vec3(0.0);\n\tfloat shadowShadowSpecular = 0.0;\n\tfloat shadowShadowShadow = 1.0;\n\tfloat shadowShadowShadowDist;\n\tvec3 shadowShadowShadowRayOrigin;\n\tvec3 shadowShadowShadowRayDir;\n\tvec3 shadowShadowShadowPos;\n\tvec3 shadowShadowShadowNormal;\n\tfloat shadowShadowShadowT;\n\tfloat shadowShadowShadowMaxDist;\n\tfloat shadowShadowShadowMinDist;\n\tfloat shadowShadowShadowDist;\n\tvec3 shadowShadowShadowColor", "\n    return dot(pos, plane.normal) + plane.distance;\n}\n\n/// @brief Get signed-distance funciton weight value of sphere.\nfloat", " cell\n    ivec3 g = ix >> uvec3(1,1,1);\n    // grid cell offset\n    vec3 gf = fract(fx);\n    // grid cell corners\n    vec3 g000 = vec3(g.x, g.y, g.z);\n    vec3 g100 = vec3(g.x+1, g.y, g.z);\n    vec3 g010 = vec3(g.x, g.y+1, g.z);\n    vec3 g110 = vec3(g.x+1, g.y+1, g.z);\n    vec3 g001 = vec3(g.x, g.y, g.z+1);\n    vec3 g101 = vec3(g.x+1, g.y, g.z+1);\n    vec3 g011 = vec3(g.x, g.y+1, g.z+1);\n    vec3 g111 = vec3(g.x+1, g.y+1, g.z+1);\n    // grid cell corners offset\n    vec3 g000f = fract(g000);\n    vec3 g100f = fract(g100);\n    vec3 g010f = fract(g010);\n    vec3 g110f = fract(g110);\n    vec3 g001f = fract(g001);\n    vec3 g101f = fract(g101);\n    vec3 g011f = fract(g011);\n    vec3 g111f = fract(g111);\n    // grid cell corners random value\n    float n000 = hash(g000);\n    float n100 = hash(g100);\n    float n010 = hash(g010);\n    float n110 = hash(g110);\n    float n001 = hash(g001);\n", "\n    // and integer octaves\n    int period = 100;\n    int lacunarity = 2;\n    int octaves = 5;\n    float h = 0.0;\n    float g = -0.7;\n    float f = 0.5;\n    float a = 0.5;\n    float t = 1.0;\n    for(int i = 0; i < octaves; i++){\n        h += a * noise(fxyz);\n        fxyz = f * fxyz;\n        a *= g;\n        t *= lacunarity;\n    }\n    return h;\n}\n\nvoid main() {\n    // get the position of the current pixel\n    vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n    // get the position of the current pixel in the world\n    vec3 pos = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos2 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos3 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos4 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos5 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos6 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos7 = vec3(uv * 2.0 - 1.0, 0.0);\n    // get the position of the current pixel in the world\n    vec3 pos8 = vec3(uv * 2.0 -", "\n    p.y -= h * 0.5;\n\n    // Capsule\n    vec2 d = abs(vec2(length(p.xz),p.y)) - vec2(r,h*0.5);\n    return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat", "\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin(iTime),cos(iTime));\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos(iTime),sin(iTime),-sin_cos);\n     p.xz *= mat2(cos", "\n  vec3 eps = vec3(0.001, 0.0, 0.0);\n\n  // Compute the normal by taking the gradient of the distance function\n  vec3 n = vec3(\n    distance_function(p + eps.xyy) - distance_function(p - eps.xyy),\n    distance_function(p + eps.yxy) - distance_function(p - eps.yxy),\n    distance_function(p + eps.yyx) - distance_function(p - eps.yyx)\n  );\n\n  return normalize(n);\n}\n\n// Compute the color of a point on the surface of our objects\nvec", "\n    return max(dot(n,l),0.0)*d;\n}\n\nfloat", "\n    float a = dot(rd,rd);\n    float b = dot(rd,ro);\n    float c = dot(ro,ro) - ra*ra;\n    float d = b*b - a*c;\n    if( d<0.0 ) return -1.0;\n    d = sqrt(d);\n    float t1 = (-b-d)/a;\n    float t2 = (-b+d)/a;\n    if( t1>t2 ) { float tmp=t1; t1=t2; t2=tmp; }\n    if( t1<0.0 ) t1 = t2;\n    if( t1<0.0 ) return -1.0;\n    return t1;\n}\n\n// -----------------------------\n// sphere\n// -----------------------------\nfloat", "\n    vec2 w = abs(dpdx) + abs(dpdy);\n    // analytic 2D gradient\n    vec2 g = vec2(dpdy.x*p.x - dpdx.x*p.y, dpdy.y*p.x - dpdx.y*p.y);\n    // range in [-w,w]\n    g = clamp(g,-w,w);\n    // range in [0,1]\n    g = (g + w) / (2.0*w);\n    // range in [-1,1]\n    g = g * 2.0 - 1.0;\n    // range in [0,1]\n    g = (g + 1.0) / 2.0;\n    // range in [0,1] again\n    g = smoothstep(0.0,1.0,g);\n    // return 1D gradient\n    return g.x*g.y;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    Sphere[0].center.x = 0.0;\n    Sphere[0].center.y = 0.0;\n    Sphere[0].center.z = 0.0;\n    Sphere[0].radius = 1.0;\n    Sphere[0].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[1].center.x = -2.0;\n    Sphere[1].center.y = 0.0;\n    Sphere[1].center.z = 0.0;\n    Sphere[1].radius = 1.0;\n    Sphere[1].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[2].center.x = 2.0;\n    Sphere[2].center.y = 0.0;\n    Sphere[2].center.z = 0.0;\n    Sphere[2].radius = 1.0;\n    Sphere[2].materialID = 0;\n\n    // Top bouncing sphere.\n    Sphere[3].center.x = 0.0;\n    Sphere[3].center.y = 2.0;\n    Sphere[3].center.z = 0.0;\n    Sphere[3].radius = 1.0;\n    Sphere[3].materialID = 0;\n\n    // Bottom bouncing sphere.\n    Sphere[4].center.x = 0.0;\n    Sphere[4].center.y = -2.0;\n    Sphere[4].center.z = 0.0;\n    Sphere[4].radius = 1.0;\n    Sphere[4].materialID = 0;\n\n    // Back bouncing sphere.\n    Sphere[5].center.x = 0.0;\n    Sphere[5].center.y = 0.0;\n    Sphere[5].center.z = -2.0;\n    Sphere[5].radius = 1.0;\n    Sphere[5].materialID = 0;\n\n    // Front bouncing sphere.\n    Sphere[6].center.x = 0.0;\n    Sphere[6].center.y = 0.0;\n    Sphere", "\n    // Compute the intersection between the ray and the sphere.\n    // If there is an intersection, return true and output the value of t,\n    // the position of the intersection and the normal vector at the intersection.\n    // Otherwise, return false.\n    //\n    // Hint: You can use the quadratic equation to solve the intersection.\n    //\n    // Hint: You can use the following functions:\n    //       dot(vec3 a, vec3 b)\n    //       length(vec3 v)\n    //       normalize(vec3 v)\n    //\n    // Hint: You can use the following constants:\n    //       PI\n    //\n    // Hint: You can use the following variables:\n    //       sph.center\n    //       sph.radius\n    //       ray.origin\n    //       ray.direction\n    //\n    // Hint: You can use the following operators:\n    //       + - * /\n    //\n    // Hint: You can use the following functions:\n    //       pow(float x, float y)\n    //       sqrt(float x)\n    //       min(float x, float y)\n    //       max(float x, float y)\n    //\n    // Hint: You can use the following constants:\n    //       PI\n    //\n    // Hint: You can use the following variables:\n    //       sph.center\n    //       sph.radius\n    //       ray.origin\n    //       ray.direction\n    //\n    // Hint: You can use the following operators:\n    //       + - * /\n    //\n    // Hint: You can use the following functions:\n    //       pow(float x, float y)\n    //       sqrt(float x)\n    //       min(float x, float y)\n    //       max(float x, float y)\n    //\n    // Hint: You can use the following constants:\n    //       PI\n    //\n    // Hint: You can use the following variables:\n    //       sph.center\n    //       sph.radius\n    //       ray.origin\n    //       ray.direction\n    //\n    // Hint", "\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the square of a number. //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float sqr( float x ) { return x*x; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the dot product of two //\n    // vectors.                                                                  //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float dot( in vec3 a, in vec3 b ) { return a.x*b.x + a.y*b.y + a.z*b.z; }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the length of a vector.//\n    ///////////////////////////////////////////////////////////////////////////////\n    // float length( in vec3 a ) { return sqrt( dot(a,a) ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the distance between two//\n    // points.                                                                   //\n    ///////////////////////////////////////////////////////////////////////////////\n    // float distance( in vec3 a, in vec3 b ) { return length( a - b ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the cross product of two//\n    // vectors.                                                                  //\n    ///////////////////////////////////////////////////////////////////////////////\n    // vec3 cross( in vec3 a, in vec3 b ) { return vec3( a.y*b.z - a.z*b.y, a.z*b.x - a.x*b.z, a.x*b.y - a.y*b.x ); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the normalize of a     //\n    // vector.                                                                   //\n    ///////////////////////////////////////////////////////////////////////////////\n    // vec3 normalize( in vec3 a ) { return a / length(a); }\n\n    ///////////////////////////////////////////////////////////////////////////////\n    // HINT: You can use the following function to compute the reflection of a    //\n    // vector.                                                                   //\n    //////////////////////////////////////////////////////////////////////////", "\n    hasHit = false;\n    float tmin = INFINITY;\n    vec3 hitPos_temp;\n    vec3 hitNormal_temp;\n    vec3 k_rg_temp;\n    for (int i = 0; i < numObjects; i++) {\n        bool hit = objects[i].Intersect(ray, tmin, hitPos_temp, hitNormal_temp, k_rg_temp);\n        if (hit) {\n            hasHit = true;\n            tmin = tmin;\n            hitPos = hitPos_temp;\n            hitNormal = hitNormal_temp;\n            k_rg = k_rg_temp;\n        }\n    }\n\n    // If there was no intersection, return background color\n    if (!hasHit) {\n        return backgroundColor;\n    }\n\n    // Compute color using Phong Lighting Model\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < numLights; i++) {\n        // Compute the color from the ith light source\n        vec3 lightColor = lights[i].ComputeColor(hitPos, hitNormal, k_rg);\n        color += lightColor;\n    }\n\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes the color of the pixel at (x, y) by casting a ray into the scene\n// and finding the color at the nearest intersection point.\n/////////////////////////////////////////////////////////////////////////////\nvec", "\n    float tp = (0.5-ro.y)/rd.y; if( tp>0.0 ) mint = max( mint, tp );\n    float tm = (1.5-ro.y)/rd.y; if( tm>0.0 ) tmax = min( tmax, tm );\n    if( mint>tmax ) return 1.0;\n\n    // raymarch loop\n    float res = 1.0;\n    for( int i=ZERO; i<NUM_STEPS; i++ )\n    {\n        float h = map( ro + rd*mint );\n        res = min( res, 8.0*h/mint );\n        mint += clamp( h, 0.02, 0.1 );\n        if( mint>tmax ) break;\n    }\n\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvoid main()\n{\n    vec3 pos = position;\n    vec3 normal = normalize(normalMatrix * normal);\n    vec3 tangent = normalize(normalMatrix * tangent);\n    vec3 bitangent = normalize(normalMatrix * bitangent);\n    \n    vec3 viewDir = normalize(viewPos - pos);\n    vec3 reflectDir = reflect(-viewDir, normal);\n    \n    vec3 lightDir = normalize(lightPos - pos);\n    vec3 halfwayDir = normalize(lightDir + viewDir);\n    \n    float diff = max(dot(normal, lightDir), 0.0);\n    float spec = pow(max(dot(normal, halfwayDir), 0.0), 16.0);\n    \n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 ambient = 0.1 * lightColor;\n    vec3 diffuse = diff * lightColor;\n    vec3 specular = spec * lightColor;\n    \n    vec3 color = texture(texture_diffuse1, texCoord).rgb;\n    vec3 normalMap = texture(texture_normal1, texCoord).rgb;\n    normalMap = normalize(normalMap * 2.0 - 1.0);\n    normalMap = normalize", "\n    vec3 camera_pos = start + dir * planet_radius;\n\n    // calculate the rayleigh and mie scattering\n    vec3 rayleigh_scattering = beta_ray * exp(-beta_absorption * height_ray);\n    vec3 mie_scattering = beta_mie * exp(-beta_absorption * height_mie);\n\n    // calculate the primary ray\n    vec3 primary_ray = primary_ray_trace(\n        camera_pos, \n        dir, \n        max_dist, \n        planet_position, \n        planet_radius, \n        atmo_radius, \n        beta_absorption, \n        height_absorption, \n        absorption_falloff, \n        steps_i\n    );\n\n    // calculate the light ray\n    vec3 light_ray = light_ray_trace(\n        camera_pos, \n        light_dir, \n        max_dist, \n        planet_position, \n        planet_radius, \n        atmo_radius, \n        beta_absorption, \n        height_absorption, \n        absorption_falloff, \n        steps_l\n    );\n\n    // calculate the final color\n    vec3 color = primary_ray * rayleigh_scattering + light_ray * mie_scattering + scene_color * beta_ambient;\n\n    // return the final color\n    return color;\n}\n\n/*\nThe main function.\nThis is the function that is called when the shader is run.\nIt takes in the camera position, the camera vector, the maximum distance the ray can travel, the color of the scene, the direction of the light, the intensity of the light, the position of the planet, the radius of the planet, the radius of the atmosphere, the amount of rayleigh scattering, the amount of mie scattering, the amount of absorption, the amount of ambient scattering, the direction of mie scattering, the height at which there is no rayleigh scattering, the height at which there is no mie scattering, the height at which there is no absorption, the falloff of the absorption, the amount of steps along the primary ray, and the amount of steps along the", "\n    vec3 bent_normal = normalize(mix(surface_normal, light_dir, 0.5));\n\n    // sample the atmosphere\n    vec3 sample_col = sample_atmosphere(sample_pos, bent_normal);\n\n    // mix the sample with the background color\n    return mix(sample_col, background_col, 0.5);\n}\n\n/*\nThis is the main function that renders the planet.\n\nIt takes in the ray origin and direction, the current time, and the background color.\n\nIt returns the color of the planet at the given ray.\n*/\nvec", "\n    vec4 color = vec4(0.0);\n    \n    // the distance to the surface\n    float dist = 0.0;\n    \n    // the raymarching step\n    float step = 0.0;\n    \n    // the raymarching distance\n    float march = 0.0;\n    \n    // the raymarching distance\n    float march_dist = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = 0.0;\n    \n    // the raymarching distance\n    float march_dist_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev_prev = ", " and position\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camDir = normalize(vec3(fragCoord.x - 0.5 * iResolution.x, fragCoord.y - 0.5 * iResolution.y, 1.0));\n    \n    // get the light direction\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    \n    // draw the atmosphere\n    fragColor = drawAtmosphere(camPos, camDir, lightDir);\n}\n", "\n    vec3 s0_r0 = s0 - r0;\n    float b = dot(s0_r0, rd);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    if (c > 0.0 && b > 0.0) return -1.0;\n    float discr = b * b - c;\n    if (discr < 0.0) return -1.0;\n    else return b - sqrt(discr);\n}\n\n//-----------------------------------------------------------------------\nfloat", "ialize the ray\n    vec3 rayPos = cameraPos;\n    vec3 rayDir = cameraRayDir;\n\n    //initialize the color\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n\n    //initialize the distance\n    float distance = 0.0;\n\n    //initialize the material\n    Material material;\n\n    //initialize the hit\n    bool hit = false;\n\n    //initialize the normal\n    vec3 normal;\n\n    //initialize the hit position\n    vec3 hitPos;\n\n    //initialize the hit normal\n    vec3 hitNormal;\n\n    //initialize the hit material\n    Material hitMaterial;\n\n    //initialize the hit distance\n    float hitDistance;\n\n    //initialize the hit object\n    int hitObject;\n\n    //initialize the hit object index\n    int hitObjectIndex;\n\n    //initialize the hit object index\n    int hitObjectIndex2;\n\n    //initialize the hit object index\n    int hitObjectIndex3;\n\n    //initialize the hit object index\n    int hitObjectIndex4;\n\n    //initialize the hit object index\n    int hitObjectIndex5;\n\n    //initialize the hit object index\n    int hitObjectIndex6;\n\n    //initialize the hit object index\n    int hitObjectIndex7;\n\n    //initialize the hit object index\n    int hitObjectIndex8;\n\n    //initialize the hit object index\n    int hitObjectIndex9;\n\n    //initialize the hit object index\n    int hitObjectIndex10;\n\n    //initialize the hit object index\n    int hitObjectIndex11;\n\n    //initialize the hit object index\n    int hitObjectIndex12;\n\n    //initialize the hit object index\n    int hitObjectIndex13;\n\n    //initialize the hit object index\n    int hitObjectIndex14;\n\n    //initialize the hit object index\n    int hitObjectIndex15;\n\n    //initialize the hit object index\n    int hitObjectIndex16;\n\n    //initialize the hit object index\n    int hit", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", " ray\n    RayQueue ray_queue = RayQueue(ray_origin, ray_target);\n\n    // Initialize the sample color\n    vec3 sample_color = vec3(0.0);\n\n    // Initialize the number of reflections and refractions\n    int num_reflections = 0;\n    int num_refractions = 0;\n\n    // Initialize the number of bounces\n    int num_bounces = 0;\n\n    // Initialize the number of samples\n    int num_samples = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_max = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_min = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_avg = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_max = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_min = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg_max = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg_min = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg_avg = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg_avg_max = 0;\n\n    // Initialize the number of samples\n    int num_samples_per_pixel_std_avg_avg_min = 0;\n\n", "\n    vec2 id = floor(p);\n    vec2 pos = p - id;\n    \n    // Local cell color ID.\n    float cid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 color = vec3(0.0);\n    \n    // Local cell color ID.\n    float nid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 ncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.y, 2.0);\n    \n    // Local cell color.\n    vec3 nncolor = vec3(0.0);\n    \n    // Local cell color ID.\n    float nnid = mod(id.x + id.", "\n    vec3 sphere_pos = vec3(0.0, 0.0, 0.0);\n    float sphere_radius = 1.0;\n\n    // calculate distance to sphere\n    return length(p - sphere_pos) - sphere_radius;\n}\n\n// Get normal of the sphere\nvec", "\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    // calculate the hash\n    vec4 hashx0, hashy0, hashz0, hashx1, hashy1, hashz1;\n    FAST32_hash_3D( Pi, hashx0, hashy0, hashz0 );\n    FAST32_hash_3D( Pi + vec3(1.0, 0.0, 0.0), hashx1, hashy1, hashz1 );\n\n    // calculate the gradients\n    vec4 gradx0 = hashx0 - 0.49999;\n    vec4 grady0 = hashy0 - 0.49999;\n    vec4 gradz0 = hashz0 - 0.49999;\n    vec4 gradx1 = hashx1 - 0.49999;\n    vec4 grady1 = hashy1 - 0.49999;\n    vec4 gradz1 = hashz1 - 0.49999;\n\n    // normalize gradients\n    vec4 normx0 = inversesqrt( gradx0 * gradx0 + vec4(1.0) );\n    vec4 normy0 = inversesqrt( grady0 * grady0 + vec4(1.0) );\n    vec4 normz0 = inversesqrt( gradz0 * gradz0 + vec4(1.0) );\n    vec4 normx1 = inversesqrt( gradx1 * gradx1 + vec4(1.0) );\n    vec4 normy1 = inversesqrt( grady1 * grady1 + vec4(1.0) );\n    vec4 normz1 = inversesqrt( gradz1 * gradz1 + vec4(1.0) );\n\n    // gradient dot product\n    vec4 m00 = dot( gradx0, normx0 ) * normx0;\n    vec4 m01 = dot( gr", "\n    float i = floor(x);\n    float f = fract(x);\n\n    // quintic interpolation\n    float u = f*f*f*(f*(f*6.0-15.0)+10.0);\n\n    // hash lookup\n    float a = hash(i);\n    float b = hash(i + 1.0);\n\n    // interpolate\n    return lerp(a, b, u);\n}\n\n// 2D noise\nfloat", "\n    float d = p.y + 1.0;\n    float id = 1.0;\n\n    // sphere\n    vec3 q = p - vec3(0.0, 1.0, 0.0);\n    float r = 0.5;\n    float d2 = length(q) - r;\n    if (d2 < d)\n    {\n        d = d2;\n        id = 2.0;\n    }\n\n    return vec2(d, id);\n}\n\nvec", "\n    float d = sdBox(p, vec3(1.0));\n\n    // add a sphere\n    float sd = sdSphere(p, vec3(0.0, 0.0, 0.0), 0.5);\n    d = opU(d, sd);\n\n    // add a box\n    sd = sdBox(p, vec3(0.5));\n    d = opU(d, sd);\n\n    return vec2(d, 0.0);\n}\n\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - pix - d;\n}\n\nfloat", "\n\tvec2 st = fragCoord/iResolution.xy;\n\t\n\tvec3 color = vec3(0.0);\n\t\n\tfloat d = distance(st,vec2(0.5));\n\t\n\tfloat r = d*10.0;\n\t\n\tfloat f = sin(r);\n\t\n\tcolor = vec3(f);\n\t\n\tfragColor = vec4(color,1.0);\n}", "\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Pointed top hexagons.\n    p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat top hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat bottom hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed top hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat top hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed top hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat top hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed top hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat top hexagons.\n    // p.x += step(1., mod(p.y, 2.));\n    \n    // Pointed top hexagons.\n    // p.x += step(1., mod(p.y, 2.)) * 0.5;\n    \n    // Flat top hexagons.\n    // p.x += step(1", "\n    return (sin(ix*1600)*1376+sin(iy*1600)*1376+sin(ix*1600+iy*1600)*1376)/3000;\n}\n\nfloat", "\n    p = rotate(p, vec3(0.0, 0.0, 1.0), 0.5*iTime);\n\n    // solve the quadratic polynomial\n    float a = dot(p, p);\n    float b = dot(p, p*p);\n    float c = dot(p, p*p*p);\n    float d = dot(p, p*p*p*p);\n\n    // get the solutions\n    float s1 = (-b + sqrt(b*b - 4.0*a*c)) / (2.0*a);\n    float s2 = (-b - sqrt(b*b - 4.0*a*c)) / (2.0*a);\n\n    // get the colors\n    vec3 c1 = getColor(s1);\n    vec3 c2 = getColor(s2);\n\n    // mix the colors\n    return mix(c1, c2, 0.5);\n}\n\n//------------------------------------------------------------------\n// main\n//------------------------------------------------------------------\nvoid main()\n{\n    // get the ray direction\n    vec3 rayDir = normalize(vec3(gl_FragCoord.xy - 0.5*iResolution.xy, iResolution.y));\n\n    // get the ray origin\n    vec3 rayOrigin = vec3(0.0, 0.0, 1.0);\n\n    // get the ray intersection\n    float t = intersect(rayOrigin, rayDir);\n\n    // if the ray intersects the sphere\n    if (t > 0.0)\n    {\n        // get the intersection point\n        vec3 p = rayOrigin + t*rayDir;\n\n        // get the color\n        vec3 color = getColor(p);\n\n        // set the fragment color\n        gl_FragColor = vec4(color, 1.0);\n    }\n    else\n    {\n        // set the fragment color\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n", "\n    p *= 10.0;\n\n    // add a few elements\n    float e1 = sdBox(p, vec3(1.0, 1.0, 1.0));\n    float e2 = sdBox(p + vec3(2.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float e3 = sdBox(p + vec3(4.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float e4 = sdBox(p + vec3(6.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float e5 = sdBox(p + vec3(8.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n\n    // combine elements\n    float d = min(e1, min(e2, min(e3, min(e4, e5))));\n\n    // scale back\n    d /= 10.0;\n\n    return d;\n}\n\n// Fifth scene (many elements)\nfloat", "\n    return vec2(atan(z.y,z.x),length(z));\n}\n\nvec", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n\t vec3 s = floor(p + dot(p, vec3(F3)));\n\t vec3 x = p - s + dot(s, vec3(G3));\n\t \n\t /* calculate i1 and i2 */\n\t vec3 e = step(vec3(0.0), x - x.yzx);\n\t vec3 i1 = e*(1.0 - e.zxy);\n\t vec3 i2 = 1.0 - e.zxy*(1.0 - e);\n\t \n\t /* x1, x2, x3 */\n\t vec3 x1 = x - i1 + G3;\n\t vec3 x2 = x - i2 + 2.0*G3;\n\t vec3 x3 = x - 1.0 + 3.0*G3;\n\t \n\t /* calculate dot products */\n\t vec4 p1 = permute(permute(permute(s.z) + s.y) + s.x);\n\t vec4 p2 = permute(permute(permute(s.z + i1.z) + s.y) + s.x);\n\t vec4 p3 = permute(permute(permute(s.z + i2.z) + s.y) + s.x);\n\t vec4 p4 = permute(permute(permute(s.z + 1.0) + s.y) + s.x);\n\t \n\t vec4 w, d1, d2, d3;\n\t \n\t w.x = dot(x, x);\n\t w.y = dot(x1, x1);\n\t w.z = dot(x2, x2);\n\t w.w = dot(x3, x3);\n\t \n\t /* w.x will always be less than or equal to the other three, so we can use it to find the largest component */\n\t w = max(0.6 - w, 0.0);\n\t \n\t d1 = x.xyxy * p1.xyxy + p1.zwzw;\n\t d2 = x1.xyxy * p2.xy", "\n    float t = mod(iTime, 25.0);\n    float t1 = t;\n    float t2 = t + 12.5;\n    float t3 = t + 25.0;\n    float t4 = t + 37.5;\n    float t5 = t + 50.0;\n    float t6 = t + 62.5;\n    float t7 = t + 75.0;\n    float t8 = t + 87.5;\n    float t9 = t + 100.0;\n    float t10 = t + 112.5;\n    float t11 = t + 125.0;\n    float t12 = t + 137.5;\n    float t13 = t + 150.0;\n    float t14 = t + 162.5;\n    float t15 = t + 175.0;\n    float t16 = t + 187.5;\n    float t17 = t + 200.0;\n    float t18 = t + 212.5;\n    float t19 = t + 225.0;\n    float t20 = t + 237.5;\n    float t21 = t + 250.0;\n    float t22 = t + 262.5;\n    float t23 = t + 275.0;\n    float t24 = t + 287.5;\n    float t25 = t + 300.0;\n    float t26 = t + 312.5;\n    float t27 = t + 325.0;\n    float t28 = t + 337.5;\n    float t29 = t + 350.0;\n    float t30 = t + 362.5;\n    float t31 = t + 375.0;\n    float t32 = t + 387.5;\n    float t33 = t + 400.0;\n    float t34 = t + 412.5;\n    float t35 = t", " in the scene\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.xz *= rot(iTime*0.1);\n    //p.", "\n    float k = floor(rp.x*.5)*.5;\n    float d = sdBox(rp-vec3(k,0,0),vec3(.25,.5,.25));\n    return d;\n}\n\n// The normal of the surface at point p\nvec", "\n\treturn max(0.0, min(1.0, (end - d) / (end - start)));\n}\n\nvoid main() {\n\tvec3 color = texture(tex, texCoord).rgb;\n\tfloat fog = linearFog(gl_FragCoord.z, 0.0, 100.0);\n\tcolor = mix(color, fogColor, fog);\n\toutColor = vec4(color, 1.0);\n}\n", "\n    vec4 hex = vec4(0.0);\n    \n    // The hexagon centers are stored in a 2D grid, with the first row of hexagons centered at \n    // (0,0), and the second row centered at (0,1), etc.\n    hex.xy = floor(p);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    // The hexagon centers are offset by a small amount, to make sure that the hexagons are \n    // centered on the grid points.\n    hex.xy += vec2(0.5, 0.5);\n    \n    //", "\n    float r = rand(floor(p));\n    \n    // The distance to the center of the cell.\n    float d = length(p);\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d2 = length(p + vec2(r, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d3 = length(p + vec2(r, -r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d4 = length(p + vec2(-r, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d5 = length(p + vec2(-r, -r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d6 = length(p + vec2(r, 0.0));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d7 = length(p + vec2(-r, 0.0));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d8 = length(p + vec2(0.0, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d9 = length(p + vec2(0.0, -r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d10 = length(p + vec2(r, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d11 = length(p + vec2(r, -r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d12 = length(p + vec2(-r, r));\n    \n    // The distance to the center of the cell, but with a random offset.\n    float d13 = length(p + vec2(-r, -r));\n    ", "\n    float scale = iMouse.x / iResolution.x;\n\n    // Set color according to scale.\n    // If scale is 0.0, color is red.\n    // If scale is 1.0, color is blue.\n    // If scale is 0.5, color is green.\n    // If scale is 0.25, color is yellow.\n    // If scale is 0.75, color is purple.\n    // If scale is 0.125, color is orange.\n    // If scale is 0.875, color is cyan.\n    // If scale is 0.375, color is magenta.\n    // If scale is 0.625, color is brown.\n    // If scale is 0.1875, color is pink.\n    // If scale is 0.8125, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale is 0.75, color is white.\n    // If scale is 0.5, color is gray.\n    // If scale is 0.25, color is black.\n    // If scale", "\n    float theta = atan(pc.y, pc.x);\n    float r = length(pc);\n    float theta_spiral = atan(b*theta, a+b*theta);\n    \n    //If the polar coordinate is on the spiral, return theta.\n    //If not, return -1.0\n    if(abs(theta_spiral - theta) < 0.0001){\n        return theta;\n    }else{\n        return -1.0;\n    }\n}\n\n//https://en.wikipedia.org/wiki/Archimedean_spiral\n//Given a polar coordinate (r, theta), return the cartesian coordinate (x, y)\nvec", "\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid main() {\n  vec2 st = gl_FragCoord.xy/u_resolution.xy;\n  vec3 color = vec3(0.0);\n\n  // Plot a line\n  color = vec3(plot(st,0.5));\n\n  gl_FragColor = vec4(color,1.0);\n}\n", "\n    //\n    // The following is a diagram of the initial circular domain.\n    //\n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // \n    // ", "\n    float a = atan(p.y, p.x);\n    float ia = floor(a / (2.0 * PI) +.5);\n    a -= ia * 2.0 * PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float r = length(p);\n    float ir = floor(r / circ.z +.5);\n    r -= ir * circ.z;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float b = atan(p.y, p.x);\n    float ib = floor(b / (2.0 * PI) +.5);\n    b -= ib * 2.0 * PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float c = atan(p.y, p.x);\n    float ic = floor(c / (2.0 * PI) +.5);\n    c -= ic * 2.0 * PI;\n    \n    // The following is a standard polar repeat operation. It works\n    // the same in hyperbolic space as it does in Euclidian space.\n    // If you didn't do this, you'd reflect across just the one\n    // edge. Set \"ia\" to \".5/float(N)\" to see what I mean.\n    float d = atan(", "\n    vec2 m = iMouse.xy / iResolution.xy;\n    \n    // Invert mouse coordinates.\n    m = (m - 0.5) * 2.0;\n    \n    // Invert mouse coordinates.\n    m.y *= -1.0;\n    \n    // Return inverted mouse coordinates.\n    return m;\n}\n\n// Mouse pointer inversion.\nvec", "\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos2 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos3 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos4 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos5 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos6 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos7 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos8 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos9 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos10 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos11 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos12 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos13 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos14 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos15 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos16 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos17 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos18 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos19 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos20 =", "\n\tvec3 camPos = vec3(0.0, 0.0, 0.0);\n\tvec3 camDir = normalize(vec3(0.0, 0.0, 1.0));\n\tvec3 camUp = normalize(vec3(0.0, 1.0, 0.0));\n\tvec3 camSide = normalize(cross(camDir, camUp));\n\t\n\t// Camera\n\tvec3 rayDir = normalize(camSide * (fragCoord.x - iResolution.x * 0.5) + camUp * (fragCoord.y - iResolution.y * 0.5) + camDir * 1.0);\n\t\n\t// Raymarch\n\tvec3 rayPos = camPos;\n\tfloat dist = 0.0;\n\tfloat totalDist = 0.0;\n\tfloat t = 0.0;\n\tfloat tMax = 100.0;\n\t\n\tfor (int i = 0; i < 100; i++)\n\t{\n\t\tdist = map(rayPos);\n\t\ttotalDist += dist;\n\t\trayPos += rayDir * dist;\n\t\tt += dist;\n\t\tif (dist < 0.001 || t > tMax)\n\t\t{\n\t\t\tbreak;\n\t\t}\n\t}\n\t\n\t// Lighting\n\tvec3 lightPos = vec3(0.0, 0.0, 10.0);\n\tvec3 lightDir = normalize(lightPos - rayPos);\n\tfloat lightDist = length(lightPos - rayPos);\n\tfloat lightAtten = 1.0 / (1.0 + 0.01 * lightDist + 0.001 * lightDist * lightDist);\n\tfloat lightDiffuse = max(dot(lightDir, normalize(normal(rayPos))), 0.0);\n\tfloat lightSpecular = pow(max(dot(reflect(-lightDir, normal(rayPos)), -rayDir), 0.0), 16.0);\n\t\n\t// Shading\n\tvec3 color = vec3(0.0);\n\tif (dist < 0.001)\n\t{\n\t\tcolor = vec3(", "\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Convert to polar coordinates\n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n\n    // Convert to HSB\n    float h = a / (2.0 * PI);\n    float s = 1.0;\n    float b = r;\n\n    // Convert to RGB\n    vec3 rgb = hsb2rgb(vec3(h, s, b));\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}\n", "\n    vec3 cube = mod(floor(hash * 6.0), 2.0) * 2.0 - 1.0;\n    \n    // Random vertex of a rhombic dodecahedron\n    float cb = (cube.x + cube.y + cube.z) / 3.0;\n    float cr = (cube.x + cube.y) / 2.0;\n    float cs = (cube.x + cube.z) / 2.0;\n    float ct = (cube.y + cube.z) / 2.0;\n    vec3 rhomb = vec3(cr + cb, ct + cb, cs + cb);\n    \n    // Expand outwards\n    float scale = 1.0 / (sqrt(3.0) * (abs(rhomb.x) + abs(rhomb.y) + abs(rhomb.z)));\n    return rhomb * scale;\n}\n\n// 2D simplex noise\nfloat", "\n    // This is a bit of a hack, but it's the only way to get a triangular\n    // alignment.\n    X.yz = X.yz * mat2(0.866025404, -0.5, 0.5, 0.866025404);\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.y;\n    \n    // The main diagonal is the only one that repeats.\n    X.z = X.z + X.x;\n    \n    // The main diagonal is the only one that repe", "\n  float d = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the YZ plane\n  float d2 = length(p.yz) - 0.5;\n  // distance from the point `p` to the center of the XY plane\n  float d3 = length(p.xy) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d4 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d5 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d6 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d7 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d8 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d9 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d10 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d11 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d12 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d13 = length(p.xz) - 0.5;\n  // distance from the point `p` to the center of the XZ plane\n  float d14 = length(p.xz) - 0.5;\n  // distance from the point `p", "\n    // \ub9cc\uc57d \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \uc815\ud655\ud55c \uacc4\uc0b0\uc774 \ub418\uc9c0 \uc54a\ub294\ub2e4.\n    // \ub530\ub77c\uc11c \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ub178\uba40\ub77c\uc774\uc988 \ub418\uc5b4 \uc788\uc9c0 \uc54a\ub2e4\uba74, \ub178\uba40\ub77c\uc774\uc988 \ud574\uc8fc\ub294 \uac83\uc774 \uc88b\ub2e4.\n    // \ufffd", "\n\tmat2 rot = mat2(cos(iTime), sin(iTime), -sin(iTime), cos(iTime));\n\t\n\t// Get the pixel coordinates\n\tvec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\t\n\t// Rotate the pixel coordinates\n\tuv = rot * uv;\n\t\n\t// Get the distance from the center\n\tfloat dist = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist2 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle2 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist3 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle3 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist4 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle4 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist5 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle5 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist6 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle6 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist7 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle7 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist8 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle8 = atan(uv.y, uv.x);\n\t\n\t// Get the distance from the center\n\tfloat dist9 = length(uv);\n\t\n\t// Get the angle from the center\n\tfloat angle9 = atan(uv.y", "\n    vec4 s = vec4(p, 0.0);\n    s.y -= 0.5;\n    s.y = pModPolar(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y += 0.5;\n    s.y = pModCylinder(s.yz, vec2(0.5, 0.5));\n    s.y -= 0.", "\n    vec3 targetDir = normalize( targetPos - ray.origin );\n    float targetDist = length( targetPos - ray.origin );\n    float targetAngle = dot( targetDir, ray.direction );\n    float targetAngle2 = targetAngle * targetAngle;\n    float targetAngle3 = targetAngle2 * targetAngle;\n    float targetAngle4 = targetAngle2 * targetAngle2;\n    float targetAngle5 = targetAngle3 * targetAngle2;\n    float targetAngle6 = targetAngle3 * targetAngle3;\n    float targetAngle7 = targetAngle4 * targetAngle3;\n    float targetAngle8 = targetAngle4 * targetAngle4;\n    float targetAngle9 = targetAngle5 * targetAngle4;\n    float targetAngle10 = targetAngle5 * targetAngle5;\n    float targetAngle11 = targetAngle6 * targetAngle5;\n    float targetAngle12 = targetAngle6 * targetAngle6;\n    float targetAngle13 = targetAngle7 * targetAngle6;\n    float targetAngle14 = targetAngle7 * targetAngle7;\n    float targetAngle15 = targetAngle8 * targetAngle7;\n    float targetAngle16 = targetAngle8 * targetAngle8;\n    float targetAngle17 = targetAngle9 * targetAngle8;\n    float targetAngle18 = targetAngle9 * targetAngle9;\n    float targetAngle19 = targetAngle10 * targetAngle9;\n    float targetAngle20 = targetAngle10 * targetAngle10;\n    float targetAngle21 = targetAngle11 * targetAngle10;\n    float targetAngle22 = targetAngle11 * targetAngle11;\n    float targetAngle23 = targetAngle12 * targetAngle11;\n    float targetAngle24 = targetAngle12 * targetAngle12;\n    float targetAngle25 = targetAngle13 * targetAngle12;\n    float targetAng", "\n    // p.y -= 1.;\n    // p.z -= 1.;\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.yz*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.", "\n    float i = floor(x);\n    float f = fract(x);\n\n    // quintic interpolation\n    float u = f * f * f * (f * (f * 6.0 - 15.0) + 10.0);\n\n    // noise\n    return mix(\n        hash(i),\n        hash(i + 1.0),\n        u\n    );\n}\n\n// 2D noise\nfloat", "\n    vec2 v0 = p3 - p1;\n    vec2 v1 = p2 - p1;\n    vec2 v2 = uv - p1;\n    \n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    \n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n    \n    return (u >= 0.0) && (v >= 0.0) && (u + v < 1.0);\n}\n\n//Check if uv inside triangle using barycentric coords\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nbool in_triangle(vec3 p1, vec3 p2, vec3 p3, vec3 uv){\n    \n    //Delicious math\n    vec3 v0 = p3 - p1;\n    vec3 v1 = p2 - p1;\n    vec3 v2 = uv - p1;\n    \n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n    \n    float invDenom = 1.0 / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot0", "\n    float n = log(start_radius/uv.x)/log(1.5);\n    return int(n);\n}\n\n//Find the hexagon a point is in\nvec", ".\n    //Points are in clockwise order.\n    vec2 p0 = hex_point(uv, circumradius, rotation, 0);\n    vec2 p1 = hex_point(uv, circumradius, rotation, 1);\n    vec2 p2 = hex_point(uv, circumradius, rotation, 2);\n    vec2 p3 = hex_point(uv, circumradius, rotation, 3);\n    vec2 p4 = hex_point(uv, circumradius, rotation, 4);\n    vec2 p5 = hex_point(uv, circumradius, rotation, 5);\n    \n    //Check if uv is on an edge.\n    if(on_edge(uv, p0, p1) || on_edge(uv, p1, p2) || on_edge(uv, p2, p3) ||\n       on_edge(uv, p3, p4) || on_edge(uv, p4, p5) || on_edge(uv, p5, p0)){\n        return ON_TRIANGLE;\n    }\n    \n    //Check if uv is inside the triangle.\n    if(inside_triangle(uv, p0, p1, p2) || inside_triangle(uv, p1, p2, p3) ||\n       inside_triangle(uv, p2, p3, p4) || inside_triangle(uv, p3, p4, p5) ||\n       inside_triangle(uv, p4, p5, p0)){\n        return ON_TRIANGLE;\n    }\n    \n    return NOT_IN_TRIANGLE;\n}\n\n//Check if uv is on or near an equilateral triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint", ".\n    //Points are in clockwise order.\n    vec2 p0 = hex_point(uv, circumradius, rotation, 0);\n    vec2 p1 = hex_point(uv, circumradius, rotation, 1);\n    vec2 p2 = hex_point(uv, circumradius, rotation, 2);\n    vec2 p3 = hex_point(uv, circumradius, rotation, 3);\n    vec2 p4 = hex_point(uv, circumradius, rotation, 4);\n    vec2 p5 = hex_point(uv, circumradius, rotation, 5);\n    \n    //Check if uv is on an edge.\n    if(on_edge(uv, p0, p1) || on_edge(uv, p1, p2) || on_edge(uv, p2, p3) ||\n       on_edge(uv, p3, p4) || on_edge(uv, p4, p5) || on_edge(uv, p5, p0)){\n        return ON_TRIANGLE;\n    }\n    \n    //Check if uv is inside the first triangle.\n    if(inside_triangle(uv, p0, p1, p2)){\n        return 1;\n    }\n    \n    //Check if uv is inside the second triangle.\n    if(inside_triangle(uv, p0, p2, p3)){\n        return 2;\n    }\n    \n    //Check if uv is inside the third triangle.\n    if(inside_triangle(uv, p0, p3, p4)){\n        return 3;\n    }\n    \n    //Check if uv is inside the fourth triangle.\n    if(inside_triangle(uv, p0, p4, p5)){\n        return 4;\n    }\n    \n    //Check if uv is inside the fifth triangle.\n    if(inside_triangle(uv, p0, p5, p1)){\n        return 5;\n    }\n    \n    //Check if uv is inside the sixth triangle.\n    if(inside_triangle(uv, p1, p5, p2)){\n        return ", "\n    float L = exp(-d);\n    float k = 0.0;\n    float p = 1.0;\n    float U1 = U.x;\n    while (U1 > L) {\n        k += 1.0;\n        p *= (d / k);\n        U1 *= U.y;\n    }\n    return k;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat", "'s work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash2(uint n)\n{\n    // integer hash copied from Hugo Elias's work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash3(uint n)\n{\n    // integer hash copied from Hugo Elias's work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash4(uint n)\n{\n    // integer hash copied from Hugo Elias's work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash5(uint n)\n{\n    // integer hash copied from Hugo Elias's work\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\n// https://www.shadertoy.com/view/llGSzw\nuint hash6(uint n)", "\n    vec2 uv = (fragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n\n    // time\n    float t = iTime;\n\n    // color\n    vec3 col = vec3(0.0);\n\n    // loop\n    for (float i = 0.0; i < 10.0; i++) {\n        // position\n        vec2 pos = vec2(sin(t * 0.1 + i * 0.1), cos(t * 0.1 + i * 0.1)) * 0.5;\n\n        // distance\n        float d = length(uv - pos);\n\n        // color\n        col += vec3(1.0 / d);\n    }\n\n    // output\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvoid main()\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n", "\n  float epsilon = 0.0001;\n  // Compute normal using central differences method\n  vec3 normal = vec3(\n    calcD(pos, epsilon, 0),\n    calcD(pos, 0, epsilon),\n    calcD(pos, epsilon, epsilon)\n  );\n  return normalize(normal);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n  float t = castRay(ro, rd);\n  if (t < 0.0) {\n    return vec3(0.0, 0.0, 0.0);\n  }\n  vec3 pos = ro + rd * t;\n  vec3 normal = calcNormal(pos);\n  vec3 color = vec3(0.0, 0.0, 0.0);\n  if (t < tmin) {\n    color = vec3(0.0, 0.0, 0.0);\n  } else if (t < tmax) {\n    color = vec3(1.0, 1.0, 1.0);\n  } else {\n    color = vec3(0.0, 0.0, 0.0);\n  }\n  return color;\n}\n\nvoid main() {\n  // camera\n  vec3 ro = vec3(0.0, 0.0, 0.0);\n  vec3 rd = normalize(vec3(vUv.x - 0.5, vUv.y - 0.5, 1.0));\n  vec3 color = render(ro, rd);\n  gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float epsilon = 0.0001;\n    // Compute normal using central differences method\n    vec3 normal = vec3(\n        calcD(pos, epsilon, 0),\n        calcD(pos, 0, epsilon),\n        calcD(pos, epsilon, epsilon)\n    );\n    return normalize(normal);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n    float t = castRay(ro, rd);\n    if (t < 0.0) {\n        return vec3(0.0, 0.0, 0.0);\n    }\n\n    // get position and normal at hit point\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    // get material color at hit point\n    vec3 col = getMaterialColor(pos);\n\n    // calculate lighting\n    float occ = calcAO(pos, nor);\n    vec3 lig = calcLighting(pos, nor, col, occ);\n\n    // calculate fog\n    float fogAmount = calcFog(t);\n    vec3 fogCol = vec3(0.5, 0.6, 0.7);\n    vec3 colFog = mix(col, fogCol, fogAmount);\n\n    // calculate reflections\n    vec3 ref = reflect(rd, nor);\n    vec3 refCol = render(pos + nor * 0.001, ref);\n\n    // calculate refractions\n    vec3 refr = refract(rd, nor, 1.0 / 1.333);\n    vec3 refrCol = render(pos + nor * 0.001, refr);\n\n    // calculate final color\n    vec3 finalCol = mix(colFog, refCol, 0.5) + mix(colFog, refrCol, 0.5);\n\n    return finalCol;\n}\n\nvoid main() {\n    // get normalized device coordinates\n    vec2 uv = (gl_FragCoord.xy * 2.0 - resolution.xy) / resolution.y;\n\n    // get ray direction\n    vec3 rd = normalize(vec3(uv, 1.0));\n\n    // get ray origin\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n\n    // render scene\n    vec3 col = render(ro, rd);\n\n    // output final color\n    gl_FragColor = vec4(col, 1", "\n    vec3 s = vec3(0.0);\n    for (int i=ZERO; i<8; i++) {\n        float j = float(i);\n        vec2 e = vec2(cos(j), sin(j))*0.02;\n        s += vec3(0.5 + 0.5*dot(e, e));\n    }\n    s = s*s*(3.0 - 2.0*s);\n\n    //normal\n    vec2 e = vec2(1.0, 0.0)*0.001;\n    vec3 n = sdf(p + e.xyy) - sdf(p - e.xyy);\n    n.x = sdf(p + e.yxy) - sdf(p - e.yxy);\n    n.y = sdf(p + e.yyx) - sdf(p - e.yyx);\n    return normalize(n);\n}\n\n/**\n * Raymarching using the gradient of the SDF.\n */\nfloat", "\n    return fract(sin(dot(q.x, q.y, 19.19898))*43758.5453);\n}\n\n// random hash via https://www.shadertoy.com/view/3d2GRh\n// I didnt update this hash until after I styled it -_- so it stays\nfloat", "els\n\tvec2 texel = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x16 texels\n\tvec2 texelSize = vec2( 1.0 / 16.0, 1.0 / 16.0 );\n\n\t// 16x", "\n    p = abs(p);\n\n    // normalize\n    float a = ab.x;\n    float b = ab.y;\n    float r = a / b;\n    p *= r;\n\n    // project\n    float l = length(p);\n    float m = l*l/(a*a+b*b);\n    vec2 n = m*p;\n\n    // distance\n    float d = l*sqrt(m*m+1.0-m);\n\n    // gradient\n    vec3 g;\n    g.x = d;\n    g.yz = n;\n\n    return g;\n}\n\n// signed distance to ellipse\nfloat", "\n    vec3 q = vec3(dot(vec2(1.0, 1.0), vec2(p, p + iGlobalTime)),\n                  dot(vec2(7.0, 13.0), vec2(p, p + 1.0)),\n                  dot(vec2(17.0, 19.0), vec2(p, p + 2.0)));\n    return fract(sin(q) * 43758.5453);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Plot a line\n    float y = plot(uv, vec2(0.4, 0.6));\n    col = vec3(y);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n", "\n    float dist = 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float cx = cos(rotation.x);\n    float sx = sin(rotation.x);\n    float cy = cos(rotation.y);\n    float sy = sin(rotation.y);\n    float cz = cos(rotation.z);\n    float sz = sin(rotation.z);\n\n    // Calculate the Rotation Matrix\n    return mat3(\n        cy*cz, cy*sz*sx - cx*sz, cy*sz*cx + sx*sz,\n        sx*sy, cx*cz + sx*sy*sz, cx*sz - cy*sx*sz,\n        -sy, cy*sx + sy*sz*cx, cy*cx - sx*sy*sz\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat", "\n    rayori = rayori - camera;\n    // Raymarching\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        // Get the distance to the nearest object\n        d = map(rayori + raydir * t);\n        // If we are close enough to the object, break\n        if(d < MIN_DIST){\n            break;\n        }\n        // Move the ray forward\n        t += d;\n        // If we are too far away, break\n        if(t > MAX_DIST){\n            break;\n        }\n    }\n    // Get the normal of the object\n    vec3 normal = getNormal(rayori + raydir * t);\n    // Get the color of the object\n    vec3 color = getColor(rayori + raydir * t);\n    // Get the light direction\n    vec3 light = normalize(vec3(1.0, 1.0, 1.0));\n    // Get the ambient light\n    float ambient = 0.1;\n    // Get the diffuse light\n    float diffuse = max(dot(normal, light), 0.0);\n    // Get the specular light\n    float specular = pow(max(dot(reflect(raydir.xyz, normal), light), 0.0), 16.0);\n    // Get the final color\n    vec3 finalColor = color * (ambient + diffuse + specular);\n    // Return the final color\n    return finalColor;\n}\n\n// 3D Ray-Marching\nvec", "\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.0));\n    // Calculate the Position of the Ray\n    vec3 rayPos = vec3(0.0, 0.0, 0.0);\n    // Calculate the Distance of the Ray\n    float rayDist = rayMarch(rayPos, rayDir);\n    // Calculate the Position of the Ray\n    vec3 rayPos2 = rayPos + rayDist * rayDir;\n    // Calculate the Normal of the Ray\n    vec3 rayNorm = calcNormal(rayPos2);\n    // Calculate the Light of the Ray\n    vec3 rayLight = calcLight(rayPos2, rayNorm);\n    // Calculate the Color of the Ray\n    vec3 rayColor = rayLight * calcColor(rayPos2);\n    // Return the Color of the Ray\n    return rayColor;\n}\n\n// 4D Screen Output Image\nvec", "\n    rayori = cameraPos;\n    // Set the Raymarching Distance\n    float dist = 0.0;\n    // Set the Raymarching Maximum Distance\n    float maxDist = 100.0;\n    // Set the Raymarching Step Size\n    float stepSize = 0.01;\n    // Set the Raymarching Color\n    vec3 color = vec3(0.0);\n    // Set the Raymarching Normal\n    vec3 normal = vec3(0.0);\n    // Set the Raymarching Material\n    vec3 material = vec3(0.0);\n    // Set the Raymarching Light\n    vec3 light = vec3(0.0);\n    // Set the Raymarching Light Color\n    vec3 lightColor = vec3(1.0);\n    // Set the Raymarching Light Position\n    vec3 lightPos = vec3(0.0, 10.0, 0.0);\n    // Set the Raymarching Light Attenuation\n    float lightAttenuation = 1.0;\n    // Set the Raymarching Light Ambient\n    float lightAmbient = 0.1;\n    // Set the Raymarching Light Diffuse\n    float lightDiffuse = 0.5;\n    // Set the Raymarching Light Specular\n    float lightSpecular = 0.5;\n    // Set the Raymarching Light Specular Power\n    float lightSpecularPower = 10.0;\n    // Set the Raymarching Light Specular Color\n    vec3 lightSpecularColor = vec3(1.0);\n    // Set the Raymarching Light Specular Attenuation\n    float lightSpecularAttenuation = 1.0;\n    // Set the Raymarching Light Specular Ambient\n    float lightSpecularAmbient = 0.1;\n    // Set the Raymarching Light Specular Diffuse\n    float lightSpecularDiffuse = 0.5;\n    // Set the Raymarching Light Specular Specular\n    float lightSpecularSpecular = 0.5;\n    // Set the Raymarching Light Spec", "\n    float seed = dot(fragCoord, iResolution.xy);\n    seed = seed + iGlobalTime;\n    seed = seed * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float fade = clamp(1.0 - abs(coord.x - 0.5) * 2.0, 0.0, 1.0);\n\n    // Calculate the ray's position\n    float rayPos = coord.x + travelRate * frequency;\n\n    // Calculate the ray's strength\n    float rayStrength = clamp(1.0 - abs(rayPos - 0.5) * 2.0, 0.0, 1.0);\n\n    // Return the ray's strength multiplied by the fade\n    return rayStrength * fade * maxStrength;\n}\n\n// Calculate the color of the fragment\nvec", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n// -----------------------------------------------\n", " right now\n    vec2 p1 = p - d;\n    vec2 p2 = p + d;\n    vec2 p3 = p - vec2(d.x, -d.y);\n    vec2 p4 = p + vec2(d.x, -d.y);\n    vec2 p5 = p - vec2(-d.x, d.y);\n    vec2 p6 = p + vec2(-d.x, d.y);\n    vec2 p7 = p - vec2(-d.x, -d.y);\n    vec2 p8 = p + vec2(-d.x, -d.y);\n    float d1 = distance(p, p1);\n    float d2 = distance(p, p2);\n    float d3 = distance(p, p3);\n    float d4 = distance(p, p4);\n    float d5 = distance(p, p5);\n    float d6 = distance(p, p6);\n    float d7 = distance(p, p7);\n    float d8 = distance(p, p8);\n    float dmin = min(d1, min(d2, min(d3, min(d4, min(d5, min(d6, min(d7, d8)))))));\n    if (dmin == d1) {\n        e1 = p1;\n        e2 = p2;\n        e3 = p3;\n        e4 = p4;\n    } else if (dmin == d2) {\n        e1 = p2;\n        e2 = p1;\n        e3 = p4;\n        e4 = p3;\n    } else if (dmin == d3) {\n        e1 = p3;\n        e2 = p4;\n        e3 = p1;\n        e4 = p2;\n    } else if (dmin == d4) {\n        e1 = p4;\n        e2 = p3;\n        e3 = p2;\n        e4 = p1;\n    } else if (dmin == d5) {\n        e1 = p5;\n", "\n    color = max(vec3(0.0), color - 0.004);\n    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);\n    return color;\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec", "\n    vec2 dir = normalize(b-a);\n    vec2 n = vec2(-dir.y,dir.x);\n    float k = w1+w2;\n\n    // start with a box\n    float d = sdBox(p,a,b,vec2(w1,w1));\n\n    // subtract the arrowhead\n    float d2 = sdSegment(p,a,b);\n    d2 = max(d2,-dot(p-a,n));\n    d2 = max(d2,-dot(p-b,n));\n    d = min(d,d2);\n\n    // subtract the arrowhead\n    d2 = sdSegment(p,b-n*k,b);\n    d2 = max(d2,-dot(p-b,n));\n    d = min(d,d2);\n\n    return d;\n}\n\n//------------------------------------------------------------------\n// sdSegment\n//\n// Returns the distance from p to the line segment ab.\n//\n// The line segment is defined by two points a and b.\n//\n// The parameter t is clamped to the range [0.0, 1.0].\n//\n// The function returns a negative value if p is on the backward\n// side of the line segment.\n//\n// The function returns a positive value if p is on the forward\n// side of the line segment.\n//\n// The function returns zero if p is on the line segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if p is on the line\n// segment.\n//\n// The function returns a positive value if", "\n    uv = (uv - 0.5) * mat2(0.8,0.6,-0.6,0.8);\n    \n    //get the distance to the center\n    float d = length(uv);\n    \n    //get the angle of the uv\n    float a = atan(uv.y,uv.x);\n    \n    //get the distance to the edge\n    float e = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float f = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float g = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float h = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float i = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float j = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float k = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float l = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float m = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float n = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float o = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float p = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float q = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float r = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float s = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float t = abs(d - 0.5);\n    \n    //get the distance to the edge\n    float u = abs(d - 0.5);\n    \n    //get", "\n    vec3 colA = vec3(0.0,0.0,0.0);\n    vec3 colB = vec3(1.0,1.0,1.0);\n    return mix( colA, colB, rnd ) * falloff;\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nvec", "\n    vec2 uv = fragCoord/iResolution.x; //x-fov\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n   vec3 q = vec3(dot(vec2(1.0, 1.0), p),\n                 dot(vec2(57.0, 113.0), p),\n                 dot(vec2(157.0, 213.0), p));\n   return fract(sin(q) * 43758.5453);\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n  //  return x - x*x*x/3 + x*x*x*x*x/5;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x/11;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x/11 + x*x*x*x*x*x*x*x*x*x*x*x*x*x*x/13;\n  //  return x - x*x*x/3 + x*x*x*x*x/5 - x*x*x*x*x*x*x/7 + x*x*x*x*x*x*x*x*x*x/9 - x*x*x*x*x*x*x*x*x*x*x*x/11 + x*x*x*x*x*x*x*x*x*x*x*x*x*x*x/13 - x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*x*", ", I don't remember where.\n  //  It's a post-processing effect that makes the image look more like a\n  //  film.\n  col = pow(col, vec3(0.4545));\n  col = col * (col * 0.5 + 0.5);\n  col = col * (1.0 - pow(clamp(1.0 - max(dot(q, q), 0.0), 0.0, 1.0), 1.5));\n  col = col * (0.5 + 0.5 * pow(16.0 * q.x * q.y * (1.0 - q.x) * (1.0 - q.y), 0.75));\n  return clamp(col, 0.0, 1.0);\n}\n\n//  This is the main function that is called by the shadertoy API.\n//  It is called once per frame, and it is responsible for rendering the scene.\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n  //  The following code is a bit of a hack, but it works.\n  //  The shadertoy API passes the mouse position in the fragCoord variable.\n  //  We use this to set the mouse position in the scene.\n  //  The mouse position is used to control the camera position.\n  //  The camera position is used to control the view matrix.\n  //  The view matrix is used to control the projection matrix.\n  //  The projection matrix is used to control the camera position.\n  //  The camera position is used to control the view matrix.\n  //  The view matrix is used to control the projection matrix.\n  //  The projection matrix is used to control the camera position.\n  //  The camera position is used to control the view matrix.\n  //  The view matrix is used to control the projection matrix.\n  //  The projection matrix is used to control the camera position.\n  //  The camera position is used to control the view matrix.\n  //  The view matrix is used to control the projection matrix.\n  //  The projection matrix is used to control the camera position.\n  //  The camera position is", "\n    vec3 d = abs(p) - vec3(1.0);\n    // Return the maximum component of d\n    return max(d.x, max(d.y, d.z));\n}\n\n/* \u4e00\u4e2a\u7403\u4f53\u7684SDF */\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Draw a circle\n    float radius = iMouse.x / iResolution.x;\n    float radius_last = iMouse.x / iResolution.x;\n    float radius_diff = radius - radius_last;\n    float brightness = radius_diff;\n    col = vec3(brightness, brightness, brightness);\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n"], "input_both": ["\n\treturn max(0.0,cos(a)*2-1);\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) =.5, fsin(2/3) =.5\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat", "\n    vec3 q = p;\n    q.xz = Rotate(q.xz, rotDir, rotSpeed);\n    q.y = Rotate(q.y, rotDir, rotSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 r = p;\n    r.xz = Rotate(r.xz, scaleDir, scaleSpeed);\n    r.y = Rotate(r.y, scaleDir, scaleSpeed);\n\n    // Translate, but only the part that is on the side of transDir\n    vec3 s = p;\n    s.xz = Rotate(s.xz, transDir, transSpeed);\n    s.y = Rotate(s.y, transDir, transSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 t = p;\n    t.xz = Rotate(t.xz, scaleDir, scaleSpeed);\n    t.y = Rotate(t.y, scaleDir, scaleSpeed);\n\n    // Rotate, but only the part that is on the side of rotDir\n    vec3 u = p;\n    u.xz = Rotate(u.xz, rotDir, rotSpeed);\n    u.y = Rotate(u.y, rotDir, rotSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 v = p;\n    v.xz = Rotate(v.xz, scaleDir, scaleSpeed);\n    v.y = Rotate(v.y, scaleDir, scaleSpeed);\n\n    // Translate, but only the part that is on the side of transDir\n    vec3 w = p;\n    w.xz = Rotate(w.xz, transDir, transSpeed);\n    w.y = Rotate(w.y, transDir, transSpeed);\n\n    // Scale, but only the part that is on the side of scaleDir\n    vec3 x = p;\n    x.xz = Rotate(x.xz, scaleDir, scaleSpeed);\n    x.y =", "\n\tglowCounter += (1.0 - glowCounter) * (1.0 - glowCounter);\n\n\t// Get the voxel position\n\tvec3 voxelPos = floor(p);\n\n\t// Get the voxel size\n\tfloat voxelSize = voxelSizeF;\n\n\t// Get the voxel color\n\tvec4 voxelColor = texture(voxelTexture, voxelPos.xy / voxelSize);\n\n\t// Get the voxel distance\n\tfloat voxelDist = length(p - voxelPos);\n\n\t// Get the voxel glow\n\tfloat voxelGlow = glowCounter;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity = voxelColor.a;\n\n\t// Get the voxel distance\n\tfloat voxelDist2 = voxelDist * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow2 = voxelGlow * voxelGlow;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity2 = voxelOpacity * voxelOpacity;\n\n\t// Get the voxel distance\n\tfloat voxelDist3 = voxelDist2 * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow3 = voxelGlow2 * voxelGlow;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity3 = voxelOpacity2 * voxelOpacity;\n\n\t// Get the voxel distance\n\tfloat voxelDist4 = voxelDist3 * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow4 = voxelGlow3 * voxelGlow;\n\n\t// Get the voxel opacity\n\tfloat voxelOpacity4 = voxelOpacity3 * voxelOpacity;\n\n\t// Get the voxel distance\n\tfloat voxelDist5 = voxelDist4 * voxelDist;\n\n\t// Get the voxel glow\n\tfloat voxelGlow5 = voxelGlow4 * voxelG", "\n\tglowCounter += 1.0;\n\n\t// Get the distance to the scene\n\tfloat d = scene(p);\n\n\t// Get the closest point on the scene\n\tP = vec3(p.x, p.y, d);\n\n\t// Return the distance to the scene\n\treturn vec2(d, glowCounter);\n}\n\n// Distance to the scene and color of the closest point\nvec", " position in the pixel\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\n\t// Get the fragment position in the screen\n\tvec2 p_screen = (p * 2.0) - 1.0;\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the camera\n\tvec3 p_camera = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n\t// Get the fragment position in the world\n\tvec3 p_world = vec3(p_screen * 2.0 - 1.0, 1.0);\n\n", "\n\tvec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n\t\n\t// this is a bit of a hack to get the color gradient to work\n\t// the color values are in the range 0.0 to 1.0\n\t// the x value is in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to 1.0\n\t// the color values are in the range 0.0 to ", "\n\tvec4 c = texture(color_map, vec2(d, 0.5));\n\t\n\t// apply gamma correction\n\tc.rgb = pow(c.rgb, vec3(1.0/2.2));\n\t\n\t// apply brightness\n\tc.rgb *= vec3(0.5);\n\t\n\t// apply contrast\n\tc.rgb = (c.rgb - 0.5) * 2.0 + 0.5;\n\t\n\t// apply saturation\n\tc.rgb = mix(c.rgb, vec3(0.0), 0.5);\n\t\n\treturn c;\n}\n\n// main\nvoid main()\n{\n\t// get distance to surface\n\tfloat d = texture(depth_map, v_texcoord).r;\n\t\n\t// shade point\n\tvec4 c = shade(d);\n\t\n\t// write to framebuffer\n\tgl_FragColor = c;\n}\n", " and forth\n    float fade = clamp(0.5 + 0.5 * (1.0 + dot(rayDir, sunDir)), 0.0, 1.0);\n\n    // softbox\n    vec3 color = vec3(0.0);\n    vec3 pos = vec3(0.0);\n    float dist = 0.0;\n    float scale = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        pos = vec3(0.0);\n        dist = 0.0;\n        for (int j = 0; j < 10; j++)\n        {\n            pos += vec3(0.0, 0.0, 0.0);\n            pos.x += scale;\n            pos.y += scale;\n            pos.z += scale;\n            dist += scale;\n            scale *= 0.5;\n        }\n        pos.x -= dist;\n        pos.y -= dist;\n        pos.z -= dist;\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n        color += vec3(0.0, 0.0, 0.0);\n       ", "\n    float time = (coords.x - 2.0) / 2.0;\n    return sin(time) * 0.5 + 0.5;\n}\n\n// F(x,y) = F(x) - y\nfloat", "\n    float time = (coords.x - 2.0) / 4.0;\n    return sin(time) * 0.5 + 0.5;\n}\n\n// F(x,y) = F(x) - y\nfloat", "\n    float time = (coords.x - 1.0) / 3.0;\n    return sin(time) * 0.5 + 0.5;\n}\n\n// F(x,y) = F(x) - y\nfloat", "\n    float speed = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float t = p.z * 0.001;\n\n    // The first layer is just a simple noise function.\n    float n = noise(p);\n\n    // The second layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t)) * 0.5;\n\n    // The third layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 2.0)) * 0.25;\n\n    // The fourth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 4.0)) * 0.125;\n\n    // The fifth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 8.0)) * 0.0625;\n\n    // The sixth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 16.0)) * 0.03125;\n\n    // The seventh layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 32.0)) * 0.015625;\n\n    // The eighth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 64.0)) * 0.0078125;\n\n    // The ninth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 128.0)) * 0.00390625;\n\n    // The tenth layer is a parallax effect.\n    n += noise(p + vec3(0.0, 0.0, t * 256.0)) * 0.001953125;", "\n    //return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Better, but doesn't disperse things as nicely as the first way.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    // This is a simplex grid, with a 3x3x3 grid.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid of 16-bit integers.\n    //\n    // The grid is a 3x3x3 grid", "\n    vec2 cell = floor(p);\n    vec2 cell_size = vec2(1.0);\n    vec2 cell_offset = vec2(0.5);\n    vec2 cell_center = (cell + cell_offset) * cell_size;\n\n    // The distance from the cell center to the point.\n    vec2 dist = abs(p - cell_center);\n\n    // The distance from the cell center to the point.\n    float dist_min = min(dist.x, dist.y);\n\n    // The distance from the cell center to the point.\n    float dist_max = max(dist.x, dist.y);\n\n    // The distance from the cell center to the point.\n    float dist_avg = (dist_min + dist_max) / 2.0;\n\n    // The distance from the cell center to the point.\n    float dist_max_avg = max(dist_max, dist_avg);\n\n    // The distance from the cell center to the point.\n    float dist_min_avg = min(dist_min, dist_avg);\n\n    // The distance from the cell center to the point.\n    float dist_max_min = max(dist_max_avg, dist_min_avg);\n\n    // The distance from the cell center to the point.\n    float dist_min_max = min(dist_max_avg, dist_min_avg);\n\n    // The distance from the cell center to the point.\n    float dist_max_max = max(dist_max_avg, dist_max_avg);\n\n    // The distance from the cell center to the point.\n    float dist_min_min = min(dist_max_avg, dist_min_avg);\n\n    // The distance from the cell center to the point.\n    float dist_max_min_max = max(dist_max_min, dist_min_max);\n\n    // The distance from the cell center to the point.\n    float dist_min_min_max = min(dist_max_min, dist_min_max);\n\n    // The distance from the cell center to the point.", "\n  // 0.0 - 1.0\n  // 0.0 - 255.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.", "\n    vec2 res = vec2(0.0);\n\n    // find the closest object\n    float t = INF;\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        float d = distance(p, objects[i].position);\n        if (d < t)\n        {\n            t = d;\n            res = objects[i].position;\n        }\n    }\n\n    // move the object\n    if (t < INF)\n    {\n        p = res;\n    }\n\n    // find the closest point on the sphere\n    float d = distance(p, vec3(0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the cylinder\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the cone\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the torus\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the sphere\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the sphere\n    d = distance(p, vec3(0.0, 1.0, 0.0));\n    if (d < t)\n    {\n        t = d;\n        res = p;\n    }\n\n    // find the closest point on the sphere", "\n\tfloat t = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat tmin = 0.001;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.0;\n\tfloat t38 = 0.0;\n\tfloat t39 = 0.0;\n\tfloat t40 = 0.0;\n\tfloat t41 = 0.0;\n\tfloat t42 = 0.0;\n\tfloat t43 = 0.0;\n\tfloat t", "\n    vec4 result = vec4(0.0);\n\n    // find the closest object\n    float t = findClosest(p);\n\n    // if there is an object, then we have a hit\n    if (t > 0.0)\n    {\n        // get the position of the object\n        vec3 q = p + t * rayDir;\n\n        // get the color of the object\n        vec3 color = getColor(q);\n\n        // get the normal of the object\n        vec3 normal = getNormal(q);\n\n        // get the specular color of the object\n        vec3 specular = getSpecular(q);\n\n        // get the ambient color of the object\n        vec3 ambient = getAmbient(q);\n\n        // get the diffuse color of the object\n        vec3 diffuse = getDiffuse(q);\n\n        // get the light direction\n        vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n\n        // get the diffuse color of the light\n        vec3 diffuseLight = getDiffuse(lightDir);\n\n        // get the specular color of the light\n        vec3 specularLight = getSpecular(lightDir);\n\n        // get the ambient color of the light\n        vec3 ambientLight = getAmbient(lightDir);\n\n        // get the diffuse color of the light\n        vec3 diffuseLight2 = getDiffuse(lightDir);\n\n        // get the specular color of the light\n        vec3 specularLight2 = getSpecular(lightDir);\n\n        // get the ambient color of the light\n        vec3 ambientLight2 = getAmbient(lightDir);\n\n        // get the diffuse color of the light\n        vec3 diffuseLight3 = getDiffuse(lightDir);\n\n        // get the specular color of the light\n        vec3 specularLight3 = getSpecular(lightDir);\n\n        // get the ambient color of the light\n        vec3 ambientLight3 = getAmbient(lightDir);\n\n        // get the diffuse color of the light\n        vec3 diff", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 10000.0;\n    float tmin_tmax = 0.0;\n    float tmax_tmin = 10000.0;\n    float tmin_tmax_t = 0.0;\n    float tmax_tmin_t = 10000.0;\n    float tmin_tmax_t_t = 0.0;\n    float tmax_tmin_t_t = 10000.0;\n    float tmin_tmax_t_t_t = 0.0;\n    float tmax_tmin_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t_t_t = 10000.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmax_tmin_t_t_t_t_t_t_t_t_t = 10000.0", "s\n    vec3 wp1 = vec3(0.0);\n    vec3 wp2 = vec3(0.0);\n    vec3 wp3 = vec3(0.0);\n    vec3 wp4 = vec3(0.0);\n    vec3 wp5 = vec3(0.0);\n    vec3 wp6 = vec3(0.0);\n    vec3 wp7 = vec3(0.0);\n    vec3 wp8 = vec3(0.0);\n    vec3 wp9 = vec3(0.0);\n    vec3 wp10 = vec3(0.0);\n    vec3 wp11 = vec3(0.0);\n    vec3 wp12 = vec3(0.0);\n    vec3 wp13 = vec3(0.0);\n    vec3 wp14 = vec3(0.0);\n    vec3 wp15 = vec3(0.0);\n    vec3 wp16 = vec3(0.0);\n    vec3 wp17 = vec3(0.0);\n    vec3 wp18 = vec3(0.0);\n    vec3 wp19 = vec3(0.0);\n    vec3 wp20 = vec3(0.0);\n    vec3 wp21 = vec3(0.0);\n    vec3 wp22 = vec3(0.0);\n    vec3 wp23 = vec3(0.0);\n    vec3 wp24 = vec3(0.0);\n    vec3 wp25 = vec3(0.0);\n    vec3 wp26 = vec3(0.0);\n    vec3 wp27 = vec3(0.0);\n    vec3 wp28 = vec3(0.0);\n    vec3 wp29 = vec3(0.", "\n    float n = 123456789.0;\n    float b = 0.0;\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float h = fract(sin(dot(p, vec3(n, n+1.0, n+2.0))) * 43758.5453);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float f = fract(sin(dot(p, vec3(n+3.0, n+5.0, n+7.0))) * 98765.4321);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float g = fract(sin(dot(p, vec3(n+9.0, n+13.0, n+17.0))) * 15973.3645);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to mind.\n    float r = fract(sin(dot(p, vec3(n+19.0, n+23.0, n+27.0))) * 31415.9265);\n    \n    // This is the actual randomization line.\n    //\n    // I've tried to come up with some clever way to improve the randomization line\n    // (h = mix(fract...), but so far, nothing's come to", "\n\tvec3 color = vec3(0.0);\n\tvec2 uv = vec2(0.0);\n\tfloat t = 0.0;\n\tfloat tmax = 10000.0;\n\tfloat tmin = 0.0;\n\tfloat tstep = 0.001;\n\tfloat tstep2 = 0.0001;\n\tfloat tstep3 = 0.00001;\n\tfloat tstep4 = 0.000001;\n\tfloat tstep5 = 0.0000001;\n\tfloat tstep6 = 0.00000001;\n\tfloat tstep7 = 0.000000001;\n\tfloat tstep8 = 0.0000000001;\n\tfloat tstep9 = 0.00000000001;\n\tfloat tstep10 = 0.000000000001;\n\tfloat tstep11 = 0.0000000000001;\n\tfloat tstep12 = 0.00000000000001;\n\tfloat tstep13 = 0.000000000000001;\n\tfloat tstep14 = 0.0000000000000001;\n\tfloat tstep15 = 0.00000000000000001;\n\tfloat tstep16 = 0.000000000000000001;\n\tfloat tstep17 = 0.0000000000000000001;\n\tfloat tstep18 = 0.00000000000000000001;\n\tfloat tstep19 = 0.000000000000000000001;\n\tfloat tstep20 = 0.0000000000000", "\n    vec2 box = vec2(abs(A.x - B.x), abs(A.y - B.y));\n    // calculate the distance from the box center to the line\n    float lineDist = distance(coords, mix(A, B, 0.5));\n    // calculate the distance from the box center to the line\n    float boxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxLineDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineBoxLineDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float boxLineBoxBoxDist = distance(coords, mix(A + box * 0.5, B - box * 0.5, 0.5));\n    // calculate the distance from the box center to the line\n    float lineBoxBoxBoxDist = distance(coords, mix(A + box * 0.5, B -", "\n     float dot = dot(start, end);\n\n     // If the dot product is negative, the angle between the vectors is greater than 180 degrees.\n     // In this case, we need to take the shortest path.\n     if (dot < 0.0f)\n     {\n          dot = -dot;\n     }\n\n     // If the dot product is 1, the angle between the vectors is 0 degrees.\n     // In this case, we need to take the longer path.\n     if (dot > 0.9999f)\n     {\n          return normalize(start + (end - start) * percent);\n     }\n\n     // The angle between the vectors is less than 180 degrees.\n     // Perform a linear interpolation.\n     float theta = acos(dot);\n     float sinTheta = sin(theta);\n\n     // If the angle is 0, return the first vector.\n     if (sinTheta < 0.0001f)\n     {\n          return start;\n     }\n\n     // Compute the sin of the angle.\n     float sinPerTheta = sin(theta * percent);\n\n     // Compute the cos of the angle.\n     float cosPerTheta = sqrt(1.0f - sinPerTheta * sinPerTheta);\n\n     // Compute the cross product.\n     vec2 perp;\n     perp.x = perp.y = 0.0f;\n     perp.x = perp.y = (end.y * sinPerTheta - start.y * cosPerTheta) / sinTheta;\n\n     // Compute the final vector.\n     return normalize(start + perp * cosPerTheta);\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 ro = vec3( 0.0, 0.0, 1.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    float dist = length( ta - ro );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross( vec3( 0.0, 1.0, 0.0 ), ww ) );\n    vec3 vv = normalize( cross( ww, uu ) );\n    vec3 rd = normalize( p.x * uu + p.y * vv + dist * ww );\n\n    // raymarch\n    vec3 col = vec3( 0.0 );\n    float t = 0.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        vec3 pos = ro + t * rd;\n        float d = map( pos );\n        col += d * vec3( 0.5, 0.5, 0.5 );\n        t += d;\n        if( t > 100.0 || d < 0.001 ) break;\n    }\n\n    // tone mapping\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // output to screen\n    fragColor = vec4( col, 1.0 );\n}\n", "\n    //\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b-a)\n    //e = (p-a) x (b", " and forth\n    float fade = clamp(0.5 + 0.5 * rayDir.y, 0.0, 1.0);\n    vec3 color = vec3(0.0);\n    color += vec3(0.0, 0.0, 0.0) * fade;\n    color += vec3(0.0, 0.0, 0.0) * (1.0 - fade);\n    return color;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec", "\n    vec2 d = vec2(0.0);\n    vec2 a = vec2(0.0);\n    vec2 b = vec2(0.0);\n    vec2 c = vec2(0.0);\n    vec2 d1 = vec2(0.0);\n    vec2 d2 = vec2(0.0);\n    vec2 d3 = vec2(0.0);\n    vec2 d4 = vec2(0.0);\n    vec2 d5 = vec2(0.0);\n    vec2 d6 = vec2(0.0);\n    vec2 d7 = vec2(0.0);\n    vec2 d8 = vec2(0.0);\n    vec2 d9 = vec2(0.0);\n    vec2 d10 = vec2(0.0);\n    vec2 d11 = vec2(0.0);\n    vec2 d12 = vec2(0.0);\n    vec2 d13 = vec2(0.0);\n    vec2 d14 = vec2(0.0);\n    vec2 d15 = vec2(0.0);\n    vec2 d16 = vec2(0.0);\n    vec2 d17 = vec2(0.0);\n    vec2 d18 = vec2(0.0);\n    vec2 d19 = vec2(0.0);\n    vec2 d20 = vec2(0.0);\n    vec2 d21 = vec2(0.0);\n    vec2 d22 = vec2(0.0);\n    vec2 d23 = vec2(0.0);\n    vec2 d24 = vec2(0.0);\n    vec2 d25 = vec2(0.0);\n    vec2 d26 = vec2(0.0);\n    vec2 d27 = vec2(0.0);\n   ", "^2\n\t// t = -0.5*org.x/dir.x\n\tfloat t = -0.5*dot(org, dir)/dot(dir, dir);\n\tnear = t;\n\tfar = t + 0.5;\n\treturn near >= 0 && far <= 1;\n}\n\n// from https://www.shadertoy.com/view/4s23DX\nfloat", "\n    vec3 q = p - vec3(s.xy, s.z);\n    vec3 q2 = q * q;\n    vec3 q3 = q2 * q;\n    vec3 q4 = q3 * q;\n    vec3 q5 = q4 * q;\n    vec3 q6 = q5 * q;\n    vec3 q7 = q6 * q;\n    vec3 q8 = q7 * q;\n    vec3 q9 = q8 * q;\n    vec3 q10 = q9 * q;\n    vec3 q11 = q10 * q;\n    vec3 q12 = q11 * q;\n    vec3 q13 = q12 * q;\n    vec3 q14 = q13 * q;\n    vec3 q15 = q14 * q;\n    vec3 q16 = q15 * q;\n    vec3 q17 = q16 * q;\n    vec3 q18 = q17 * q;\n    vec3 q19 = q18 * q;\n    vec3 q20 = q19 * q;\n    vec3 q21 = q20 * q;\n    vec3 q22 = q21 * q;\n    vec3 q23 = q22 * q;\n    vec3 q24 = q23 * q;\n    vec3 q25 = q24 * q;\n    vec3 q26 = q25 * q;\n    vec3 q27 = q26 * q;\n    vec3 q28 = q27 * q;\n    vec3 q29 = q28 * q;\n    vec3 q30 = q29 * q;\n    vec3 q31 = q30 * q;\n    vec3 q32 = q31 * q;\n    vec3 q33 = q32 * q;\n    vec3 q34 = q33 * q;\n    vec3 q35 = q34 * q", "\n    float n = noise(p);\n    float n2 = noise(p + vec3(1.0, 0.0, 0.0));\n    float n3 = noise(p + vec3(0.0, 1.0, 0.0));\n    float n4 = noise(p + vec3(0.0, 0.0, 1.0));\n    \n    // This is the actual formula.\n    return mix(n, n2, step(0.5, fract(p.x)));\n    return mix(n3, n4, step(0.5, fract(p.y)));\n    return mix(n, n3, step(0.5, fract(p.z)));\n}\n\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat", "\n    float d = length(p) - 1.0;\n    \n    // The distance to the nearest wrappable circle.\n    float d2 = min(d, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d3 = min(d2, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d4 = min(d3, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d5 = min(d4, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d6 = min(d5, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d7 = min(d6, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d8 = min(d7, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d9 = min(d8, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d10 = min(d9, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d11 = min(d10, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d12 = min(d11, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d13 = min(d12, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d14 = min(d13, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d15 = min(d14, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d16 = min(d15, 1.0);\n    \n    // The distance to the nearest wrappable circle.\n    float d1", "\n    // fz - Change in \"f\" in in the Z-direction.\n    //\n    // bumpFactor - The amount of bump mapping to apply.\n    //\n    // The following is the bump mapping function.\n    //\n    // The bump mapping function is a simple bump mapping function.\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor * (fx, fy, fz)\n    //\n    // The function is defined as:\n    //\n    // f(x,y,z) = f(x,y,z) + bumpFactor", "\n    //return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n    \n    // Better, but not as nicely as the other methods.\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 light_color = vec3(1.0, 1.0, 1.0);\n  float light_intensity = 1.0;\n\n  // ambient\n  vec3 ambient = vec3(0.1, 0.1, 0.1) * light_color * light_intensity;\n\n  // diffuse\n  float diffuse = max(dot(light_dir, n), 0.0);\n  vec3 diffuse_color = vec3(0.5, 0.5, 0.5) * light_color * diffuse * light_intensity;\n\n  // specular\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 reflect_dir = reflect(-light_dir, n);\n  float specular = pow(max(dot(view_dir, reflect_dir), 0.0), 32.0);\n  vec3 specular_color = vec3(1.0, 1.0, 1.0) * light_color * specular * light_intensity;\n\n  return ambient + diffuse_color + specular_color;\n}\n\n// raymarching\n// p : point,\n// n : normal at point\nfloat", "\n    Ray ray = Ray(vec3(0.0), vec3(0.0, 0.0, 1.0));\n    //creates a camera object\n    Camera cam = Camera(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0), vec3(0.0, 1.0, 0.0), 1.0, 1.0, 1.0, 1.0, 1.0);\n    //creates a sphere object\n    Sphere sphere = Sphere(vec3(0.0, 0.0, 0.0), 1.0);\n    //creates a plane object\n    Plane plane = Plane(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    //creates a light object\n    Light light = Light(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 1.0));\n    //creates a material object\n    Material material = Material(vec3(0.0, 0.0, 0.0), vec3(0.0, 0.0, 0.0), 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, ", "\n    //vec3 par = vec3(0.075, 0.565,.03);\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(rd, vec3(0.0, 1.0, 0.0));\n    t = clamp(t, 0.0, 1.0);\n    sky = mix(sky, par, t);\n    return sky;\n}\n\n// skybox\nvec", "i\n    vec3 col = vec3(0.0);\n    vec3 pos = ro;\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;\n", "\n    return length(p) - rad;\n}\n\n//cube\nfloat", "\n    float floor = p.y - param.y;\n    float ceiling = param.y - p.y;\n\n    // distance to the floor\n    float d1 = abs(floor) - param.z;\n\n    // distance to the ceiling\n    float d2 = abs(ceiling) - param.z;\n\n    // return the smaller distance\n    return min(d1, d2);\n}\n\n// scene distance\nfloat", "\n    float floor = p.y - param.y;\n    float ceiling = param.y - p.y;\n\n    // light gathering\n    float light = max(floor, ceiling);\n\n    // distance to light\n    float dist = length(p - param);\n\n    // return the distance to light\n    return dist - light;\n}\n\n// scene distant with light gathering\nfloat", "\n    vec3 par = vec3(0.075, 0.565,.03);\n    vec3 sky = vec3(0.0, 0.0, 0.0);\n    float t = dot(ro, par);\n    if (t < 0.0)\n        return sky;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t3", "i\n    const float k = 1.0;\n    const float k2 = 1.0;\n    const float k3 = 1.0;\n    const float k4 = 1.0;\n    const float k5 = 1.0;\n    const float k6 = 1.0;\n    const float k7 = 1.0;\n    const float k8 = 1.0;\n    const float k9 = 1.0;\n    const float k10 = 1.0;\n    const float k11 = 1.0;\n    const float k12 = 1.0;\n    const float k13 = 1.0;\n    const float k14 = 1.0;\n    const float k15 = 1.0;\n    const float k16 = 1.0;\n    const float k17 = 1.0;\n    const float k18 = 1.0;\n    const float k19 = 1.0;\n    const float k20 = 1.0;\n    const float k21 = 1.0;\n    const float k22 = 1.0;\n    const float k23 = 1.0;\n    const float k24 = 1.0;\n    const float k25 = 1.0;\n    const float k26 = 1.0;\n    const float k27 = 1.0;\n    const float k28 = 1.0;\n    const float k29 = 1.0;\n    const float k30 = 1.0;\n    const float k31 = 1.0;\n    const float k32 = 1.0;\n    const float k33 = 1.0;\n    const float k34 = 1.0;\n    const float k35 = 1.0;\n    const float k36 = 1.0;\n    const float k37 = 1.0;\n    const float k38 = 1.0;\n    const float k39 = 1.0;\n    const float k40 = 1.0;\n    const float k41 = 1.0;\n    const float k42 = 1.0;\n    const float k43 = 1.0;\n    const float k", "\n    vec2 q = p - diamond.xy;\n    return length(q - vec2(clamp(q.x, -diamond.z, diamond.z), clamp(q.y, -diamond.w, diamond.w))) - diamond.z;\n}\n\n// triangle: (center.x, center.y, helf width, helf height)\nfloat", "\n    // to avoid the need for a separate background texture.\n    vec3 background = vec3(0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);\n    background += vec3(0.0, 0.0, 0.0);", "\n\tfloat d = length( pos - vec3( 0.0, 0.0, 0.0 ) );\n\treturn d;\n}\n\n// get distance in the world\nfloat", "\n\tvec3 light = vec3(0.0, 0.0, 0.0);\n\tvec3 diffuse = vec3(0.0, 0.0, 0.0);\n\tvec3 specular = vec3(0.0, 0.0, 0.0);\n\tvec3 ambient = vec3(0.0, 0.0, 0.0);\n\tvec3 color = vec3(0.0, 0.0, 0.0);\n\n\tvec3 lightDir = normalize(light - v);\n\tvec3 viewDir = normalize(eye - v);\n\tvec3 halfDir = normalize(lightDir + viewDir);\n\tfloat diff = max(dot(n, lightDir), 0.0);\n\tdiffuse = diff * vec3(1.0, 1.0, 1.0);\n\tfloat spec = pow(max(dot(n, halfDir), 0.0), 16.0);\n\tspecular = spec * vec3(1.0, 1.0, 1.0);\n\tambient = vec3(0.1, 0.1, 0.1) * diffuse;\n\tcolor = (ambient + diffuse + specular) * vec3(1.0, 1.0, 1.0);\n\treturn color;\n}\n\n// raymarching\nvec", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Better, but doesn't disperse things quite as nicely as the first. :)\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D noise with 2D gradient.\nfloat", "\n    // 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n    //(This is not a requirement of the SCPF)\n   ", ".\n    float d = length(p.xy) - r;\n    // How far along the cylinder the point is, vertically.\n    float dz = p.z;\n    // If the point is inside the cylinder, return the distance.\n    if (dz < -h / 2.0) {\n        return d;\n    }\n    // If the point is outside the cylinder, return the distance.\n    if (dz > h / 2.0) {\n        return d;\n    }\n    // If the point is on the cylinder, return the distance.\n    return dz;\n}\n\n/**\n * Signed distance function for an XY aligned sphere centered at the origin with\n * radius r.\n */\nfloat", "\n    float t = TIME * 0.01;\n    float s = sin(t);\n    float c = cos(t);\n    p.xz *= mat2(c, s, -s, c);\n    \n    // Scale the scene\n    p *= 1.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, 0.5, -0.5, 0.866);\n    \n    // Move the scene\n    p.xz += vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, -0.5, 0.5, 0.866);\n    \n    // Move the scene\n    p.xz -= vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, 0.5, -0.5, 0.866);\n    \n    // Move the scene\n    p.xz += vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, -0.5, 0.5, 0.866);\n    \n    // Move the scene\n    p.xz -= vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *= 0.5;\n    \n    // Rotate the scene\n    p.xz *= mat2(0.866, 0.5, -0.5, 0.866);\n    \n    // Move the scene\n    p.xz += vec2(0.5, 0.5);\n    \n    // Scale the scene\n    p *", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n\n    return mat3(\n        s.x, u.x, -f.x,\n        s.y, u.y, -f.y,\n        s.z, u.z, -f.z\n    );\n}\n\n/**\n * Return a transform matrix that will transform a ray from world space\n * to view coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat", "\n    float f = fbm(p);\n    f = fbm(p*2.0);\n    f = fbm(p*4.0);\n    f = fbm(p*8.0);\n    f = fbm(p*16.0);\n    f = fbm(p*32.0);\n    f = fbm(p*64.0);\n    f = fbm(p*128.0);\n    f = fbm(p*256.0);\n    f = fbm(p*512.0);\n    f = fbm(p*1024.0);\n    f = fbm(p*2048.0);\n    f = fbm(p*4096.0);\n    f = fbm(p*8192.0);\n    f = fbm(p*16384.0);\n    f = fbm(p*32768.0);\n    f = fbm(p*65536.0);\n    f = fbm(p*131072.0);\n    f = fbm(p*262144.0);\n    f = fbm(p*524288.0);\n    f = fbm(p*1048576.0);\n    f = fbm(p*2097152.0);\n    f = fbm(p*4194304.0);\n    f = fbm(p*8388608.0);\n    f = fbm(p*16777216.0);\n    f = fbm(p*33554432.0);\n    f = fbm(p*67108864.0);\n    f = fbm(p*134217728.0);\n    f = fbm(p*268435456.0);\n    f = fbm(p*536870912.0);\n    f = fbm(p", "\n    //It is used to calculate the color of a biomorph\n    //The biomorph is a 2D fractal\n    //The biomorph is a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal\n    //The biomorph is a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fractal of a fract", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    vec2 p2 = vec2(p.x, p.z);\n    float r = length(p2);\n    float theta = atan(p2.y, p2.x);\n    float phi = atan(p.y, p.x);\n    \n    // The bump mapping function.\n    float bump = sin(r * 10.0) * 0.5 + 0.5;\n    bump = clamp(bump, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump2 = sin(r * 10.0) * 0.5 + 0.5;\n    bump2 = clamp(bump2, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump3 = sin(r * 10.0) * 0.5 + 0.5;\n    bump3 = clamp(bump3, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump4 = sin(r * 10.0) * 0.5 + 0.5;\n    bump4 = clamp(bump4, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump5 = sin(r * 10.0) * 0.5 + 0.5;\n    bump5 = clamp(bump5, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump6 = sin(r * 10.0) * 0.5 + 0.5;\n    bump6 = clamp(bump6, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump7 = sin(r * 10.0) * 0.5 + 0.5;\n    bump7 = clamp(bump7, 0.0, 1.0);\n    \n    // The bump mapping function.\n    float bump8 = sin(r *", "\n    //\n    // scr_pt is in screen space, and is in the range [0,1]x[0,1].\n    //\n    // view_inv is the inverse of the view matrix.\n    //\n    // proj_inv is the inverse of the projection matrix.\n    //\n    // viewp_inv is the inverse of the view projection matrix.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray is defined as the line segment from the camera position\n    // to the point scr_pt.\n    //\n    // The ray", "\n    if (rounded > thick.y) {\n        rounded = thick.y;\n    }\n\n    // Get the distance from the line to the point.\n    float d = distance(pA, pB);\n\n    // Get the distance from the point to the line.\n    float d2 = distance(uv, pA);\n\n    // Get the distance from the point to the line.\n    float d3 = distance(uv, pB);\n\n    // Get the distance from the point to the line.\n    float d4 = distance(uv, pA + (pB - pA) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d5 = distance(uv, pB + (pA - pB) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d6 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d7 = distance(uv, pB + (pA - pB) * 0.5 + (pA - pB) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d8 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d9 = distance(uv, pB + (pA - pB) * 0.5 + (pA - pB) * 0.5 + (pA - pB) * 0.5);\n\n    // Get the distance from the point to the line.\n    float d10 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n\n    // Get the distance from the point", "\n  vec3 light = vec3(0.0, 0.0, 0.0);\n  vec3 light_dir = normalize(light - p);\n  vec3 light_color = vec3(1.0, 1.0, 1.0);\n  vec3 light_ambient = vec3(0.2, 0.2, 0.2);\n  vec3 light_diffuse = vec3(0.5, 0.5, 0.5);\n  vec3 light_specular = vec3(1.0, 1.0, 1.0);\n  float light_shininess = 100.0;\n\n  // material\n  vec3 material_ambient = vec3(0.2, 0.2, 0.2);\n  vec3 material_diffuse = vec3(0.5, 0.5, 0.5);\n  vec3 material_specular = vec3(1.0, 1.0, 1.0);\n  float material_shininess = 100.0;\n\n  // ambient\n  vec3 ambient = light_ambient * material_ambient;\n\n  // diffuse\n  float diff = max(dot(light_dir, n), 0.0);\n  vec3 diffuse = light_diffuse * diff * material_diffuse;\n\n  // specular\n  vec3 view_dir = normalize(camera_pos - p);\n  vec3 reflect_dir = reflect(-light_dir, n);\n  float spec = pow(max(dot(view_dir, reflect_dir), 0.0), material_shininess);\n  vec3 specular = light_specular * spec * material_specular;\n\n  // combine\n  vec3 result = (ambient + diffuse + specular) * light_color;\n  return result;\n}\n\n// raymarching\n// p : point,\n// n : normal at point\nfloat", "\n\tvec3 n = (cen - ro) / rd;\n\tvec3 f = fract(n);\n\tvec3 e = (cen + rad) - ro;\n\tvec3 t = e / rd;\n\tvec3 s = sign(e);\n\tvec3 t1 = min(t, f);\n\tvec3 t2 = max(t, f);\n\tvec3 tf = max(t1, t2);\n\tvec3 ts = min(s, tf);\n\treturn ts;\n}\n\n// ray-sphere intersection (simplified)\nvec", "\n  return sin(x * PI) * (a + (b - a) * 0.5 * (1.0 + cos(x * TWO_PI)));\n}\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat", "\n\treturn vec2(a.x*b.x, a.y*b.y);\n}\n\n// z * z\nvec", "\n    vec3 ab = pb - pa;\n    vec3 abn = normalize(ab);\n    // center the cylinder\n    vec3 oc = ro - pa;\n    // ray-cylinder intersection\n    float tca = dot(oc, abn);\n    if( tca < 0.0 ) return vec4(0.0);\n    float d2 = dot(oc, oc) - tca*tca;\n    if( d2 > ra*ra ) return vec4(0.0);\n    float thc = sqrt( ra*ra - d2 );\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    // find the nearest t value\n    float t = t0 < 0.0? t1 : t0;\n    if( t < 0.0 ) return vec4(0.0);\n    // get the normal\n    vec3 n = abn * sign(tca - ra) + abn * sign(tca + ra);\n    return vec4(t, n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec", "\n\n\tfloat d = length(P-U);\n\tfloat r2 = r*r;\n\tfloat d2 = d*d;\n\tfloat d3 = d2*d;\n\tfloat d4 = d3*d;\n\tfloat d5 = d4*d;\n\tfloat d6 = d5*d;\n\tfloat d7 = d6*d;\n\tfloat d8 = d7*d;\n\tfloat d9 = d8*d;\n\tfloat d10 = d9*d;\n\tfloat d11 = d10*d;\n\tfloat d12 = d11*d;\n\tfloat d13 = d12*d;\n\tfloat d14 = d13*d;\n\tfloat d15 = d14*d;\n\tfloat d16 = d15*d;\n\tfloat d17 = d16*d;\n\tfloat d18 = d17*d;\n\tfloat d19 = d18*d;\n\tfloat d20 = d19*d;\n\tfloat d21 = d20*d;\n\tfloat d22 = d21*d;\n\tfloat d23 = d22*d;\n\tfloat d24 = d23*d;\n\tfloat d25 = d24*d;\n\tfloat d26 = d25*d;\n\tfloat d27 = d26*d;\n\tfloat d28 = d27*d;\n\tfloat d29 = d28*d;\n\tfloat d30 = d29*d;\n\tfloat d31 = d30*d;\n\tfloat d32 = d31*d;\n\tfloat d33 = d32*d;\n\tfloat d34 = d33*d;\n\tfloat d35 = d34*d;\n\tfloat d36 = d35*d;\n\tfloat d37 = d36*d;\n\tfloat d38 = d37*d;\n\tfloat d39 = d38*d;\n\tfloat d40 = d39*d;\n", "\n    p.xz *= mat2(1.0, 0.5, 0.5, 1.0);\n    p.y *= 0.5;\n\n    // calculate the distance to the scene\n    float d = length(p.xz) - 0.5;\n\n    // calculate the distance to the camera\n    float d2 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d3 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d4 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d5 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d6 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d7 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d8 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d9 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d10 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d11 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // calculate the distance to the light\n    float d12 = length(p.", "\n    float scale = (1.0/float(scaleCount))*layerID;\n    float scale2 = (1.0/float(scaleCount))*(layerID+1);\n\n    // The scale is a percentage of the grid size.\n    // The scale2 is a percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the grid size,\n    // but one layer higher.\n    // The scale2 is the percentage of the grid size, but one layer higher.\n    // The scale is the percentage of the grid size, and the scale2 is the percentage of the", "\n    float scale = 0.005;\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p0 = p;\n    vec2 p1 = p + vec2(scale, 0.0);\n    vec2 p2 = p + vec2(0.0, scale);\n    vec2 p3 = p + vec2(-scale, 0.0);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p4 = p + vec2(scale, scale);\n    vec2 p5 = p + vec2(0.0, scale) + vec2(scale, scale);\n    vec2 p6 = p + vec2(scale, 0.0) + vec2(scale, scale);\n    vec2 p7 = p + vec2(0.0, scale) + vec2(0.0, scale);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p8 = p + vec2(-scale, scale);\n    vec2 p9 = p + vec2(-scale, 0.0) + vec2(scale, scale);\n    vec2 p10 = p + vec2(-scale, 0.0) + vec2(0.0, scale);\n    vec2 p11 = p + vec2(-scale, scale) + vec2(0.0, scale);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p12 = p + vec2(-scale, -scale);\n    vec2 p13 = p + vec2(-scale, -scale) + vec2(scale, scale);\n    vec2 p14 = p + vec2(-scale, -scale) + vec2(0.0, scale);\n    vec2 p15 = p + vec2(-scale, -scale) + vec2(-scale, scale);\n    \n    // The scale tiles are made up of 4 fans.\n    vec2 p16 = p + vec2(scale, -scale);\n", "\n\n    // \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0444\u0435\u0440\u044b\n    float distance = length(currentRayPosition.xz) - 0.5;\n\n    // \u0435\u0441\u043b\u0438 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0444\u0435\u0440\u044b \u043c\u0435\u043d\u044c\u0448\u0435 0.5, \u0442\u043e \u043f\u043b\u0430\u043c\u044f \u0432\u044b\u043b\u0435\u0442\u0430\u0435\u0442\n    if (distance < 0.5)\n    {\n        return 0.0;\n    }\n\n    // \u0435\u0441\u043b\u0438 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u0434\u043e \u0441\u0444\u0435\u0440\u044b \u0431\u043e\u043b\u044c\u0448\u0435 0.5, \u0442\u043e \u043f\u043b\u0430\u043c\u044f \u0432\u044b\u043b\u0435\u0442\u0430\u0435\u0442\n    return 1.0 - distance;\n}\n\n// \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u044f \u0434\u043e \u0441\u0444\u0435\u0440\u044b \u0441 \u044d\u0444\u0444\u0435\u043a\u0442\u043e\u043c \u043f\u043b\u0430\u043c\u0435\u043d\u0438\nfloat", "\n    // \u0438\u043d\u0430\u0447\u0435 \u0431\u0443\u0434\u0435\u0442 \u0432\u044b\u0447\u0438\u0441\u043b\u044f\u0442\u044c\u0441\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0441\u043b\u0438\u0448\u043a\u043e\u043c \u0434\u043e\u043b\u0433\u043e\n    // \u0438 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u0435 \u0431\u0443\u0434\u0435\u0442 \u043d\u0435\u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\n    return abs(flameDistance(currentRayPosition));\n}\n\n// ray marching\n// ray - \u043b\u0443\u0447, \u043a\u043e\u0442\u043e\u0440\u044b\u0439 \u043f\u0440\u043e\u0445\u043e\u0434\u0438\u0442 \u043f\u043e \u0441\u0446\u0435\u043d\u0435\n// rayDirection - \u043d\u0430\u043f\u0440\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u043b\u0443\u0447\u0430\n// rayLength - \u0434\u043b\u0438\u043d\u0430 \u043b\u0443\u0447\u0430\n// currentRayPosition - \u0442\u0435\u043a\u0443\u0449\u0430\u044f \u043f\u043e\u0437\u0438\u0446\u0438\u044f \u043b\u0443\u0447\u0430\n// currentRayLength - \u0434\u043b\u0438\u043d\u0430 \u043b\u0443\u0447\u0430, \u043a\u043e\u0442\u043e\u0440\u043e\u0435 \u043f\u0440\u043e\u0448\u043b\u043e\n// currentRayColor - \u0446\u0432\u0435\u0442 \u043b\u0443\u0447\u0430\n// currentRayStep - \u0448\u0430\u0433 \u043b\u0443\u0447\u0430\n// currentRayStepLength - \u0434\u043b\u0438\u043d\u0430 \u0448\u0430\u0433\u0430 \u043b\u0443\u0447\u0430\n// currentRayStepColor - \u0446\u0432\u0435\u0442 \u0448\u0430\u0433\u0430 \u043b\u0443\u0447\u0430\n// currentRayStepCount - \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b\u0443\u0447\u0430\n// currentRayStepCountMax - \u043c\u0430\u043a\u0441\u0438\u043c\u0430\u043b\u044c\u043d\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0448\u0430\u0433\u043e\u0432 \u043b", "\n    float s = sm;\n    \n    // Get the integer part of the input.\n    float i = floor(x);\n    \n    // Get the fractional part of the input.\n    float f = x - i;\n    \n    // Get the fractional part of the integer part.\n    float fInt = f - floor(f);\n    \n    // Get the fractional part of the integer part.\n    float fFrac = fInt - floor(fInt);\n    \n    // Get the fractional part of the integer part.\n    float fFrac2 = fFrac - floor(fFrac);\n    \n    // Get the fractional part of the integer part.\n    float fFrac3 = fFrac2 - floor(fFrac2);\n    \n    // Get the fractional part of the integer part.\n    float fFrac4 = fFrac3 - floor(fFrac3);\n    \n    // Get the fractional part of the integer part.\n    float fFrac5 = fFrac4 - floor(fFrac4);\n    \n    // Get the fractional part of the integer part.\n    float fFrac6 = fFrac5 - floor(fFrac5);\n    \n    // Get the fractional part of the integer part.\n    float fFrac7 = fFrac6 - floor(fFrac6);\n    \n    // Get the fractional part of the integer part.\n    float fFrac8 = fFrac7 - floor(fFrac7);\n    \n    // Get the fractional part of the integer part.\n    float fFrac9 = fFrac8 - floor(fFrac8);\n    \n    // Get the fractional part of the integer part.\n    float fFrac10 = fFrac9 - floor(fFrac9);\n    \n    // Get the fractional part of the integer part.\n    float fFrac11 = fFrac10 - floor(fFrac10);\n    \n    // Get the fractional part of the integer part.\n    float fFrac12 = fFrac11 - floor(fFrac11);\n    \n    // Get the fractional part of the integer", "\n\n    // p = fract(p * 0.3183099 + vec3(0.0, 0.0, 0.0));\n    // p += dot(p, p.yxz + 19.19);\n    // return fract(vec3(p.x + p.y + p.z, p.x + p.y + p.z) * 0.3183099);\n\n    // This is the original, but it's a bit more complicated. It's a bit more complicated, but it's\n    // more accurate. It's also more accurate, but it's slower.\n\n    p = fract(p * 0.3183099 + vec3(0.0, 0.0, 0.0));\n    p += dot(p, p.yxz + 19.19);\n    return fract(vec3(p.x + p.y + p.z, p.x + p.y + p.z) * 0.3183099);\n}\n\n// This is a simple noise function, that I've found on the internet. It's not as accurate as the\n// hash33 function, but it's faster.\nfloat", "\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n\n    // Determining the first vertice and the fractional position.\n    vec3 v = p - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v2 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v3 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v4 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v5 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v6 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v7 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v8 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v9 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v10 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v11 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v12 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v13 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v14 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v15 = v - f + u;\n\n    // Determining the first vertice and the fractional position.\n    vec3 v1", "\n    float n = 0.0;\n    \n    // The number of octaves.\n    int octaves = 10;\n    \n    // The frequency of the noise.\n    float freq = 1.0;\n    \n    // The amplitude of the noise.\n    float amp = 0.5;\n    \n    // The persistence.\n    float persistence = 0.5;\n    \n    // The scale.\n    float scale = 0.5;\n    \n    // The offset.\n    float offset = 0.0;\n    \n    // The total amplitude.\n    float totalAmp = 0.0;\n    \n    // The total frequency.\n    float totalFreq = freq;\n    \n    // The total persistence.\n    float totalPersistence = persistence;\n    \n    // The total scale.\n    float totalScale = scale;\n    \n    // The total offset.\n    float totalOffset = offset;\n    \n    // The total noise.\n    float totalNoise = 0.0;\n    \n    // The total noise.\n    float totalNoise2 = 0.0;\n    \n    // The total noise.\n    float totalNoise3 = 0.0;\n    \n    // The total noise.\n    float totalNoise4 = 0.0;\n    \n    // The total noise.\n    float totalNoise5 = 0.0;\n    \n    // The total noise.\n    float totalNoise6 = 0.0;\n    \n    // The total noise.\n    float totalNoise7 = 0.0;\n    \n    // The total noise.\n    float totalNoise8 = 0.0;\n    \n    // The total noise.\n    float totalNoise9 = 0.0;\n    \n    // The total noise.\n    float totalNoise10 = 0.0;\n    \n    // The total noise.\n    float totalNoise11 = 0.0;\n    \n    // The total noise.\n    float totalNoise12 = 0.0;\n    \n    // The total noise.\n    float totalNoise13 = 0.0;\n    \n    // The total noise.\n    float totalNoise14 = 0.", "\n  vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon radius\n  float balloonRadius = 0.05;\n  \n  // We calculate the distance between the current ray position and the balloon position\n  float distance = length( currentRayPosition - balloonPosition );\n  \n  // If the distance is smaller than the balloon radius, we return the distance and the color of the balloon\n  if( distance < balloonRadius ){\n    return vec2( distance, vec3( 0.0, 0.0, 1.0 ) );\n  }\n  \n  // If the distance is larger than the balloon radius, we return the distance and the color of the background\n  return vec2( distance, vec3( 0.0, 0.0, 0.0 ) );\n}\n\n//'TAG: BALL'\nvec", "\n\tvec3 tmin = (rad-ro)/rd;\n\tvec3 tmax = (rad-ro-1.0)/rd;\n\tvec3 t1 = min(tmin,tmax);\n\tvec3 t2 = max(tmin,tmax);\n\tfloat t0 = max(max(t1.x,t1.y),t1.z);\n\tfloat t3 = min(min(t2.x,t2.y),t2.z);\n\tif(t0>t3) return vec4(0.0);\n\tt0 = max(t0,t1.x);\n\tt3 = min(t3,t2.x);\n\tif(t3<t0) return vec4(0.0);\n\tt0 = max(t0,t1.y);\n\tt3 = min(t3,t2.y);\n\tif(t3<t0) return vec4(0.0);\n\tt0 = max(t0,t1.z);\n\tt3 = min(t3,t2.z);\n\tif(t3<t0) return vec4(0.0);\n\treturn vec4(t0,t1.x,t1.y,t1.z);\n}\n\n// ray sphere intersection by iq https://www.shadertoy.com/view/ld23DV\nvec", "\n    vec3 f = fract(p);\n    vec3 u = f*f*(3.0-2.0*f);\n    \n    // Determining the first vertice.\n    vec3 v = p - f + u;\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v0 = v + u;\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v1 = v + vec3(u.x, u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v2 = v + vec3(u.x, 1.0-u.y, u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v3 = v + vec3(1.0-u.x, u.y, u.z);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v4 = v + vec3(u.x, u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v5 = v + vec3(1.0-u.x, 1.0-u.y, u.z);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v6 = v + vec3(u.x, 1.0-u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v7 = v + vec3(1.0-u.x, 1.0-u.y, 1.0-u.x-u.y);\n    \n    // Determining the first vertice's position in the grid.\n    vec3 v8 = v + vec3(u.x, u.y, 1.0-u.x-", "\n vec3 col=vec3(0);\n vec2 v=vec2(0);\n float d=0;\n float d2=0;\n float d3=0;\n float d4=0;\n float d5=0;\n float d6=0;\n float d7=0;\n float d8=0;\n float d9=0;\n float d10=0;\n float d11=0;\n float d12=0;\n float d13=0;\n float d14=0;\n float d15=0;\n float d16=0;\n float d17=0;\n float d18=0;\n float d19=0;\n float d20=0;\n float d21=0;\n float d22=0;\n float d23=0;\n float d24=0;\n float d25=0;\n float d26=0;\n float d27=0;\n float d28=0;\n float d29=0;\n float d30=0;\n float d31=0;\n float d32=0;\n float d33=0;\n float d34=0;\n float d35=0;\n float d36=0;\n float d37=0;\n float d38=0;\n float d39=0;\n float d40=0;\n float d41=0;\n float d42=0;\n float d43=0;\n float d44=0;\n float d45=0;\n float d46=0;\n float d47=0;\n float d48=0;\n float d49=0;\n float d50=0;\n float d51=0;\n float d52=0;\n float d53=0;\n float d54=0;\n float d55=0;\n float d56=0;\n float d57=0;\n float d58=0;\n float d59=0;\n float d60=0;\n float d61=0;\n float d62=0;\n float d6", "\n    //Use a float instead.\n    float a = 0.0;\n    float b = 0.0;\n    float r = 0.0;\n    float i = 0.0;\n    float zr = 0.0;\n    float zi = 0.0;\n    float zr2 = 0.0;\n    float zi2 = 0.0;\n    float zr3 = 0.0;\n    float zi3 = 0.0;\n    float zr4 = 0.0;\n    float zi4 = 0.0;\n    float zr5 = 0.0;\n    float zi5 = 0.0;\n    float zr6 = 0.0;\n    float zi6 = 0.0;\n    float zr7 = 0.0;\n    float zi7 = 0.0;\n    float zr8 = 0.0;\n    float zi8 = 0.0;\n    float zr9 = 0.0;\n    float zi9 = 0.0;\n    float zr10 = 0.0;\n    float zi10 = 0.0;\n    float zr11 = 0.0;\n    float zi11 = 0.0;\n    float zr12 = 0.0;\n    float zi12 = 0.0;\n    float zr13 = 0.0;\n    float zi13 = 0.0;\n    float zr14 = 0.0;\n    float zi14 = 0.0;\n    float zr15 = 0.0;\n    float zi15 = 0.0;\n    float zr16 = 0.0;\n    float zi16 = 0.0;\n    float zr17 = 0.0;\n    float zi17 = 0.0;\n    float zr18 = 0.0;\n    float zi18 = 0.0;\n    float zr19 = 0.0;\n    float zi19 = 0.0;\n    float zr20 = 0.0;\n    float zi20 = 0.0;\n    float zr21 = ", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n\n    //we need to create the new coord system\n    mat4 m;\n    m[0] = vec4(x, 0.0);\n    m[1] = vec4(y, 0.0);\n    m[2] = vec4(z, 0.0);\n    m[3] = vec4(0.0, 0.0, 0.0, 1.0);\n\n    return m;\n}\n\n//view matrix\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy / iResolution.xy);\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 q = p;\n    vec2 r = p;\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tt = 0.0;\n    float ttt = 0.0;\n    float tttt = 0.0;\n    float ttttt = 0.0;\n    float tttttt = 0.0;\n    float ttttttt = 0.0;\n    float tttttttt = 0.0;\n    float ttttttttt = 0.0;\n    float tttttttttt = 0.0;\n    float ttttttttttt = 0.0;\n    float tttttttttttt = 0.0;\n    float ttttttttttttt = 0.0;\n    float tttttttttttttt = 0.0;\n    float ttttttttttttttt = 0.0;\n    float tttttttttttttttt = 0.0;\n    float ttttttttttttttttt = 0.0;\n    float tttttttttttttttttt = 0.0;\n    float ttttttttttttttttttt = 0.0;\n    float tttttttttttttttttttt = 0.0;\n    float", "\n    float d = w / 10.0;\n    float d2 = d / 2.0;\n    float d3 = d2 / 2.0;\n    float d4 = d3 / 2.0;\n    float d5 = d4 / 2.0;\n    float d6 = d5 / 2.0;\n    float d7 = d6 / 2.0;\n    float d8 = d7 / 2.0;\n    float d9 = d8 / 2.0;\n    float d10 = d9 / 2.0;\n    float d11 = d10 / 2.0;\n    float d12 = d11 / 2.0;\n    float d13 = d12 / 2.0;\n    float d14 = d13 / 2.0;\n    float d15 = d14 / 2.0;\n    float d16 = d15 / 2.0;\n    float d17 = d16 / 2.0;\n    float d18 = d17 / 2.0;\n    float d19 = d18 / 2.0;\n    float d20 = d19 / 2.0;\n    float d21 = d20 / 2.0;\n    float d22 = d21 / 2.0;\n    float d23 = d22 / 2.0;\n    float d24 = d23 / 2.0;\n    float d25 = d24 / 2.0;\n    float d26 = d25 / 2.0;\n    float d27 = d26 / 2.0;\n    float d28 = d27 / 2.0;\n    float d29 = d28 / 2.0;\n    float d30 = d29 / 2.0;\n    float d31 = d30 / 2.0;\n    float d32 = d31 / 2.0;\n    float d33 = d32 / 2.0;\n    float d3", "\n    if (a == b)\n        return 0.0;\n\n    // clamp x to [0, 1]\n    x = clamp(x, 0.0, 1.0);\n\n    // lerp between a and b\n    return lerp(a, b, x);\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat", "\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol, float curve)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol, float curve, float curve2)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 xy, vec4 curveCol, float curve, float curve2, float curve3)\n{\n    // samples the function around x neighborhood to get distance to curve\n    float dist = func(xy);\n\n    // if distance is less than curve, draw curve\n    if (dist < curve)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawImplicit(inout vec4 baseCol, vec2 x", "\n float a=j*3.1415926535897932384626433832795;\n float b=j*3.1415926535897932384626433832795+0.5;\n float c=j*3.1415926535897932384626433832795+1.5;\n float d=j*3.1415926535897932384626433832795+2.5;\n float e=j*3.1415926535897932384626433832795+3.5;\n // random offsets of neighbors (counter-clockwise starting south)\n float f=j*3.1415926535897932384626433832795-0.5;\n float g=j*3.1415926535897932384626433832795-1.5;\n float h=j*3.1415926535897932384626433832795-2.5;\n float i=j*3.1415926535897932384626433832795-3.5;\n // random offsets of neighbors (clockwise starting east)\n float j=j*3.1415926535897932384626433832795+4.5;\n float k=j*3.1415926535897932384626433832795+5.5;\n float l=", "\n //f+=.05*sin(p.z*5.);\n //f+=.05*cos(p.w*5.);\n return f;\n}\n\n//making a linear gradient smoothe and more erroded.\nfloat", ", but it's a good start\n    vec3 rgb = vec3(0.0);\n    rgb.r = c.r * 0.299;\n    rgb.g = c.g * 0.587;\n    rgb.b = c.b * 0.114;\n    return rgb;\n}\n\n//this is a pretty good way to get a color that is a bit more\n//\"natural\" than the default color, but it's not as good as\n//EnChromaRgb()\nvec", "\n  vec4 d=vec4(0.);\n  vec3 q=abs(p)-s;\n  d.x=min(max(q.x,0.),min(q.y,q.z));\n  d.y=min(max(q.y,0.),min(q.z,q.x));\n  d.z=min(max(q.z,0.),min(q.x,q.y));\n  d.w=max(max(q.x,q.y),max(q.y,q.z));\n  return d;\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec", "\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4(1.5,.5,1.5,.5);\n //vec4 s=vec4", "\n    Material mat = distScene(pos, depth, steps);\n    return mat;\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float t)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    Material mat = distScene(pos, depth, steps, t);\n    return mat;\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float t, float t2)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + 1.0) * 2.0, 7.0));\n    //Material mat = materials[matrIndex];\n    //return mat;\n    \n    // replicate the distScene with material indices\n    Material mat = distScene(pos, depth, steps, t, t2);\n    return mat;\n}\n\n// Material scene, run once when we know the final position\n// Returns vec3(sourceMaterial, targetMaterial, interpolant)\nMaterial matScene(vec3 pos, float depth, int steps, float t, float t2, float t3)\n{\n    // material freakshow\n    //int matrIndex = int(mod(float(steps) * 10.0 / float(MARCH_MAX_STEPS), 7.0));\n    //int matrIndex = int(mod((depth + ", "\n    // https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\n    return clamp((x * (0.055f * (x * (x * 0.3f + 0.5f)) + 0.05f)) / (x * (0.119192f * (x * 0.3f + 0.5f) + 0.332f) + 0.18055f), 0.0f, 1.0f);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec", "\n    p.z += 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    if (p.x*p.x + p.y*p.y + p.z*p.z < 1.0) {\n        return vec4(0.5, 0.5, 0.5, 1.0);\n    }\n    //plane\n    else if (p.x == 0.0 && p.y == 0.0 && p.z == 0.0) {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n    //cube\n    else {\n        return vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n\n//scene light at position p\nvec", "\n    mat2 m = mat2( 0.8, -0.6, 0.6, 0.8 );\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2( 100 );\n    // rotate point p by 45 degrees\n    p = m * p;\n    // add noise to each axis\n    for ( int i = 0; i < 5; i++ ) {\n        f += a * noise( p );\n        p = m * p * 2.02 + shift;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// returns a fractal noise in a 3D space\nfloat", "\n    \n    // The first point is the wrapped point.\n    vec2 p0 = p;\n    \n    // The second point is the wrapped point rotated 90 degrees.\n    vec2 p1 = vec2(p0.y, -p0.x);\n    \n    // The third point is the wrapped point rotated 180 degrees.\n    vec2 p2 = vec2(-p0.y, p0.x);\n    \n    // The fourth point is the wrapped point rotated 270 degrees.\n    vec2 p3 = vec2(-p0.x, -p0.y);\n    \n    // The fifth point is the wrapped point rotated 360 degrees.\n    vec2 p4 = p0;\n    \n    // The sixth point is the wrapped point rotated 45 degrees.\n    vec2 p5 = vec2(-p0.y, -p0.x);\n    \n    // The seventh point is the wrapped point rotated 135 degrees.\n    vec2 p6 = vec2(p0.x, -p0.y);\n    \n    // The eighth point is the wrapped point rotated 225 degrees.\n    vec2 p7 = vec2(-p0.x, p0.y);\n    \n    // The ninth point is the wrapped point rotated 315 degrees.\n    vec2 p8 = vec2(-p0.y, -p0.x);\n    \n    // The tenth point is the wrapped point rotated 45 degrees.\n    vec2 p9 = vec2(p0.y, p0.x);\n    \n    // The eleventh point is the wrapped point rotated 135 degrees.\n    vec2 p10 = vec2(-p0.x, p0.y);\n    \n    // The twelfth point is the wrapped point rotated 225 degrees.\n    vec2 p11 = vec2(p0.x, -p0.y);\n    \n    // The thirteenth point is the wrapped point rotated 315 degrees.\n    vec", "\n return dot(u,m);\n}\n\n//return __signed distance of [u] to line trough (0,0) and [m], m must be normalized.\nfloat", "\n return mix(length(u),abs(dot(m,vec2(-u.y,u.x))),step(0.,dot(m,u)));//branchless\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat", " to define a line.\n //return length(u-d)-.1;\n return length(u-m.xy)-.1;\n}\n\n//return signed distance of u to line trough m.xy and m.zw\nfloat", "\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n/* end.Main\n   start.Implicit\n*/\nv2 c(v1 U){\n /*I*/\n ", "\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*I*/\n  return v1;\n}", "\n    return normalize(a - dot(a, b) * b);\n}\n\n//Gram-Schmidt method\nvec", "\n\tfloat alpha = acos(dot(normalize(A - B), normalize(C - B)));\n\tfloat beta = acos(dot(normalize(A - C), normalize(B - C)));\n\tfloat gamma = acos(dot(normalize(B - C), normalize(A - C)));\n\n\t//calculate the solid angle of the spherical triangle\n\tfloat solidAngle = alpha + beta + gamma - M_PI;\n\n\t//calculate the solid angle of the triangle\n\tfloat solidAngleTriangle = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of the triangle projected on the sphere\n\tfloat solidAngleTriangleProjected = (alpha * sin(alpha) * sin(beta) + beta * sin(beta) * sin(gamma) + gamma * sin(gamma) * sin(alpha)) / 2.0;\n\n\t//calculate the solid angle of", "\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In*/\n /* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n /*In", "\n    \n    // The tube is a cylinder with a radius of 1.\n    float r = 1.0;\n    \n    // The tube is a cylinder with a radius of 1.\n    float h = 0.5;\n    \n    // The tube is a cylinder with a radius of 1.\n    float d = 0.05;\n    \n    // The tube is a cylinder with a radius of 1.\n    float a = 0.1;\n    \n    // The tube is a cylinder with a radius of 1.\n    float b = 0.05;\n    \n    // The tube is a cylinder with a radius of 1.\n    float c = 0.01;\n    \n    // The tube is a cylinder with a radius of 1.\n    float e = 0.001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float f = 0.0001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float g = 0.00001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hh = 0.000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhh = 0.0000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhh = 0.00000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhh = 0.000000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhhh = 0.0000000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhhhh = 0.00000000001;\n    \n    // The tube is a cylinder with a radius of 1.\n    float hhhhhhhh = 0.000000000001;\n    \n    // The tube is a cylinder with a", "\n    float tubeWidth = 0.005;\n\n    // Tube height.\n    float tubeHeight = 0.005;\n\n    // Tube radius.\n    float tubeRadius = 0.005;\n\n    // Tube thickness.\n    float tubeThickness = 0.0005;\n\n    // Tube color.\n    vec4 tubeColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    // Tube inner color.\n    vec4 tubeInnerColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    // Tube bands color.\n    vec4 tubeBandsColor = vec4(0.5, 0.5, 0.5, 1.0);\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness.\n    float tubeBandsThickness = 0.0005;\n\n    // Tube bands radius.\n    float tubeBandsRadius = 0.0005;\n\n    // Tube bands thickness", "\n    float g = floor(gID);\n    \n    // The distance from the point to the grid cell.\n    float d = p.x - g;\n    \n    // The distance from the point to the grid cell.\n    float d2 = p.y - g;\n    \n    // The distance from the point to the grid cell.\n    float d3 = p.z - g;\n    \n    // The distance from the point to the grid cell.\n    float d4 = p.x - g + 1.0;\n    \n    // The distance from the point to the grid cell.\n    float d5 = p.y - g + 1.0;\n    \n    // The distance from the point to the grid cell.\n    float d6 = p.z - g + 1.0;\n    \n    // The distance from the point to the grid cell.\n    float d7 = p.x - g + 2.0;\n    \n    // The distance from the point to the grid cell.\n    float d8 = p.y - g + 2.0;\n    \n    // The distance from the point to the grid cell.\n    float d9 = p.z - g + 2.0;\n    \n    // The distance from the point to the grid cell.\n    float d10 = p.x - g + 3.0;\n    \n    // The distance from the point to the grid cell.\n    float d11 = p.y - g + 3.0;\n    \n    // The distance from the point to the grid cell.\n    float d12 = p.z - g + 3.0;\n    \n    // The distance from the point to the grid cell.\n    float d13 = p.x - g + 4.0;\n    \n    // The distance from the point to the grid cell.\n    float d14 = p.y - g + 4.0;\n    \n    // The distance from the point to the grid cell.\n    float d15 = p.z - g + 4.0;\n    \n    // The distance from the point to the grid cell.\n    float d16 = p.x - g + 5.0;\n    \n    // The distance from the point to the", "\n    float t = 0., tmin = 1e10;\n    \n    // Loop until we reach the maximum ray distance or the object is hit.\n    for(int i = 0; i < 100; i++){\n        \n        // Get the current ray position.\n        vec3 p = o + r * t;\n        \n        // Get the distance to the object at the current ray position.\n        float d = length(p - object_position);\n        \n        // If the ray is closer than the current nearest distance, update the nearest distance.\n        if(d < tmin){\n            tmin = d;\n        }\n        \n        // If the ray is closer than the maximum ray distance, stop the ray.\n        if(t + d > max_ray_distance){\n            break;\n        }\n        \n        // Update the ray position.\n        t += d;\n    }\n    \n    // If the ray is closer than the maximum ray distance, return the nearest distance.\n    if(t < max_ray_distance){\n        return tmin;\n    }\n    \n    // If the ray is closer than the maximum ray distance, return the maximum ray distance.\n    return max_ray_distance;\n}\n\n// Calculate the color of the ray.\nvec", "\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm not sure if this is the best way to do it, but it works.\n    // I'm", "\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting for PPI; There's not a lot I can do about that.\n    //\n    // I'm also using a fixed epsilon versus using an epsilon value that varies with\n    // resolution. Each affects the look in different ways. Here, I'm using a mixture.\n    // I want the lines to be thicker at larger resolutions, but not too thick.\n    // As for accounting", "\n    vec3 w = abs(m[0] * p3) + abs(m[1] * p3) + abs(m[2] * p3);\n    // normalize weights\n    w = w / (w.x + w.y + w.z);\n    // compute barycentric coordinates\n    return vec4(1.0 - w.x - w.y - w.z, w.x, w.y, w.z);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n    vec4 hexagonCenter = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonID = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID2 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID3 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID4 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID5 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID6 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID7 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID8 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID9 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID10 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hexagon point ID.\n    int hexagonPointID11 = int(p.x) + int(p.y);\n    \n    // The hexagon ID is the unique hex", "\n    vec2 uv = vec2(df_truchet(p), dir);\n    \n    // The Truchet distance field is a 2D texture, so we need to sample it.\n    // The second argument is the \"wrap\" mode, which is set to clamp.\n    return texture2D(df_texture, uv).r;\n}\n\n// The Truchet distance field is a 2D texture, so we need to sample it.\n// The second argument is the \"wrap\" mode, which is set to clamp.\nfloat", "\n    // q is the pixel position.\n    // dir is the direction of the arc.\n    //\n    // The direction is in radians.\n    //\n    // The polar coordinate is the angle of the arc.\n    //\n    // The polar coordinate is in radians.\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar coordinate is in the range [0, 2*pi].\n    //\n    // The polar", "\n    vec3 w = abs(n[0].xyz) * dot(p3, n[0].xyz);\n    w += abs(n[1].xyz) * dot(p3, n[1].xyz);\n    w += abs(n[2].xyz) * dot(p3, n[2].xyz);\n    return vec4(w, 1.0) / dot(w, t);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", ".\n  if (abs(r.w) < abs(p.w)) {\n    return 0.0;\n  }\n\n  // If the line is parallel to the plane, then\n  // the distance is zero.\n  if (abs(r.w) < EPSILON) {\n    return 0.0;\n  }\n\n  // Compute the distance to the line.\n  float t = (p.w - q.w) / r.w;\n\n  // If the distance is negative, then the line\n  // is behind the plane.\n  if (t < 0.0) {\n    return 0.0;\n  }\n\n  // Compute the distance to the plane.\n  float d = dot(r, q) - dot(r, p);\n\n  // If the distance is negative, then the line\n  // is behind the plane.\n  if (d < 0.0) {\n    return 0.0;\n  }\n\n  // Compute the distance to the point.\n  float s = d / r.w;\n\n  // If the distance is negative, then the line\n  // is behind the plane.\n  if (s < 0.0) {\n    return 0.0;\n  }\n\n  // Compute the squared distance to the point.\n  float d2 = s * s;\n\n  // Compute the squared distance to the line.\n  float d3 = d2 + t * t;\n\n  // Return the squared distance to the line.\n  return d3;\n}\n\n// Find the (squared) distance to the line in R3 but\n// using homogeneous coordinates.\nfloat", "\n    float t = tru(p, lW);\n    float t2 = tru(p, lW*2.0);\n    float t3 = tru(p, lW*3.0);\n    float t4 = tru(p, lW*4.0);\n    float t5 = tru(p, lW*5.0);\n    float t6 = tru(p, lW*6.0);\n    float t7 = tru(p, lW*7.0);\n    float t8 = tru(p, lW*8.0);\n    float t9 = tru(p, lW*9.0);\n    float t10 = tru(p, lW*10.0);\n    float t11 = tru(p, lW*11.0);\n    float t12 = tru(p, lW*12.0);\n    float t13 = tru(p, lW*13.0);\n    float t14 = tru(p, lW*14.0);\n    float t15 = tru(p, lW*15.0);\n    float t16 = tru(p, lW*16.0);\n    float t17 = tru(p, lW*17.0);\n    float t18 = tru(p, lW*18.0);\n    float t19 = tru(p, lW*19.0);\n    float t20 = tru(p, lW*20.0);\n    float t21 = tru(p, lW*21.0);\n    float t22 = tru(p, lW*22.0);\n    float t23 = tru(p, lW*23.0);\n    float t24 = tru(p, lW*24.0);\n    float t25 = tru(p, lW*25.0);\n    float t26 = tru(p, lW*26.0);\n    float t27 = tru(p, lW*", "\n\tfloat k = 1.0 / ( 2.0 * ( ddx.x * ddy.y - ddy.x * ddx.y ) );\n\n\t// sample texture\n\tvec2 dp = ddx * ddy;\n\tvec2 dp2 = dp * dp;\n\tvec2 dp3 = dp2 * dp;\n\tvec2 dp4 = dp3 * dp;\n\tvec2 dp5 = dp4 * dp;\n\tvec2 dp6 = dp5 * dp;\n\tvec2 dp7 = dp6 * dp;\n\tvec2 dp8 = dp7 * dp;\n\tvec2 dp9 = dp8 * dp;\n\tvec2 dp10 = dp9 * dp;\n\tvec2 dp11 = dp10 * dp;\n\tvec2 dp12 = dp11 * dp;\n\tvec2 dp13 = dp12 * dp;\n\tvec2 dp14 = dp13 * dp;\n\tvec2 dp15 = dp14 * dp;\n\tvec2 dp16 = dp15 * dp;\n\tvec2 dp17 = dp16 * dp;\n\tvec2 dp18 = dp17 * dp;\n\tvec2 dp19 = dp18 * dp;\n\tvec2 dp20 = dp19 * dp;\n\tvec2 dp21 = dp20 * dp;\n\tvec2 dp22 = dp21 * dp;\n\tvec2 dp23 = dp22 * dp;\n\tvec2 dp24 = dp23 * dp;\n\tvec2 dp25 = dp24 * dp;\n\tvec2 dp26 = dp25 * dp;\n\tvec2 dp27 = dp26 * dp;\n\tvec2 dp28 = dp27 * dp;\n\tvec2 dp29 = dp28 * dp", " of query point\n    vec2 q = floor(n);\n    // take half-cell position of query point\n    vec2 qf = floor(f);\n    // take half-cell position of query point\n    vec2 qn = floor(n+1.0);\n    // take half-cell position of query point\n    vec2 qnf = floor(f+1.0);\n    // take half-cell position of query point\n    vec2 qnq = floor(n+q);\n    // take half-cell position of query point\n    vec2 qnqf = floor(f+q);\n    // take half-cell position of query point\n    vec2 qnqn = floor(n+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnf = floor(f+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnq = floor(n+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqf = floor(f+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqn = floor(n+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnf = floor(f+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnq = floor(n+q+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqnqf = floor(f+q+q+q);\n    // take half-cell position of query point\n    vec2 qnqnqnqn = floor(n+q+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnqnf = floor(f+q+q+q+1.0);\n    // take half-cell position of query point\n    vec2 qnqnqnqn", "\n    return vec2(\n        mix(p1.x,p2.x,t),\n        mix(p1.y,p2.y,t)\n    );\n}\n\n////////////////////////////// POSICAO PONTOS\nvec", "\n\n    // p = p*2891336453.0 + 1.0;\n    // return fract(sin(p)*43758.5453123);\n\n    // This is a much more accurate version of the above, but it's slower.\n    // It's also more accurate, but it's not as nice.\n\n    p = p*2891336453.0 + 1.0;\n    return fract(sin(p)*43758.5453123);\n}\n\n// vec3 to vec3 hash.\nvec", "\n\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n    // p = p * 2.0 - 1.0;\n", "\n    float a = length(p1 - p0);\n    float b = length(p2 - p1);\n    float c = length(p0 - p2);\n    \n    // Angles.\n    float alpha = acos((a*a + b*b - c*c) / (2.0 * a * b));\n    float beta = acos((b*b + c*c - a*a) / (2.0 * b * c));\n    float gamma = acos((c*c + a*a - b*b) / (2.0 * c * a));\n    \n    // Incenter.\n    vec2 incenter = (p0 + p1 + p2) / 3.0;\n    \n    // Rotate incenter.\n    incenter = rotate(incenter, alpha);\n    incenter = rotate(incenter, beta);\n    incenter = rotate(incenter, gamma);\n    \n    return incenter;\n}\n\n// Triangle's circumcenter: The center of the circumcircle, which in essence is the smallest\n// circle that you can fit into a triangle.\nvec", "\n    float a = distance(p0, p1);\n    float b = distance(p1, p2);\n    float c = distance(p2, p0);\n\n    // Semiperimeter.\n    float s = (a + b + c) / 2.0;\n\n    // Area of the triangle.\n    float area = sqrt(s * (s - a) * (s - b) * (s - c));\n\n    // Circumradius.\n    float r = (a * b * c) / (4.0 * area);\n\n    return r;\n}\n\n// The radius of the triangle's circumcircle: I'm keeping this separate to the function\n// above, but you could amalgamate the two. \nfloat", "\n   // Returns distance of origin to a plane crossing projected triangle.\n   // h1, h2, h3 are the vertices of the triangle.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1, h2, h3 are projected onto the paraboloid.\n   // h1", "\n    vec2 v0 = vec2(0.0);\n    vec2 v1 = vec2(0.0);\n    vec2 v2 = vec2(0.0);\n    vec2 v3 = vec2(0.0);\n    vec2 v4 = vec2(0.0);\n    vec2 v5 = vec2(0.0);\n    vec2 v6 = vec2(0.0);\n    vec2 v7 = vec2(0.0);\n    \n    // I'm declaring the triangles outside the loop, because it looks neater, but I hear it's faster to declare them\n    // as locally as possible.\n    triObj t0 = triObj(0.0, 0.0, 0.0);\n    triObj t1 = triObj(0.0, 0.0, 0.0);\n    triObj t2 = triObj(0.0, 0.0, 0.0);\n    triObj t3 = triObj(0.0, 0.0, 0.0);\n    triObj t4 = triObj(0.0, 0.0, 0.0);\n    triObj t5 = triObj(0.0, 0.0, 0.0);\n    triObj t6 = triObj(0.0, 0.0, 0.0);\n    triObj t7 = triObj(0.0, 0.0, 0.0);\n    \n    // I'm declaring the triangles outside the loop, because it looks neater, but I hear it's faster to declare them\n    // as locally as possible.\n    triObj t8 = triObj(0.0, 0.0, 0.0);\n    triObj t9 = triObj(0.0, 0.0, 0.0);\n    triObj t10 = triObj(0.0, 0.0, 0.0);\n    triObj t11 = triObj(0.0, 0.0, 0.0);\n    triObj t12 = triObj(0", "\n    vec2 uv = fragCoord/iResolution.xy;\n    //uv.x *= iResolution.x/iResolution.y;\n\n    //get the color of the pixel\n    vec3 color = texture(iChannel0, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color2 = texture(iChannel1, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color3 = texture(iChannel2, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color4 = texture(iChannel3, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color5 = texture(iChannel4, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color6 = texture(iChannel5, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color7 = texture(iChannel6, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color8 = texture(iChannel7, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color9 = texture(iChannel8, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color10 = texture(iChannel9, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color11 = texture(iChannel10, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color12 = texture(iChannel11, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color13 = texture(iChannel12, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color14 = texture(iChannel13, uv).rgb;\n\n    //get the color of the pixel\n    vec3 color15 = texture(iChannel14, uv).rgb;\n\n    //get the color of the pixel\n    vec", "\n    //return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n    \n    // Better, but not as nicely as the other methods.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    /////////////////////////////////\n    // 1. Compute the intersection between the ray and the sphere.\n    // 2. If there is an intersection, return true.\n    // 3. If there is no intersection, return false.\n    // 4. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 5. If there is no intersection, return false.\n    // 6. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 7. If there is no intersection, return false.\n    // 8. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 9. If there is no intersection, return false.\n    // 10. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 11. If there is no intersection, return false.\n    // 12. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 13. If there is no intersection, return false.\n    // 14. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 15. If there is no intersection, return false.\n    // 16. If there is one or two intersections, output the value of the smaller t, the position of the intersection (hitPos) and the normal vector at the intersection (hitNormal).\n    // 17. If there is no intersection, return false.\n    // 18. If there is one or two intersections, output the value of the smaller t, the position of the intersection (", "\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true", "\n    // If there is no hit, return the background color.\n    // If there is a hit, return the color of the object.\n    //////////////////////////////////////////////////////////////////////////\n    // 1. Find the nearest hit point.\n    // 2. If there is no hit, return the background color.\n    // 3. If there is a hit, return the color of the object.\n    //////////////////////////////////////////////////////////////////////////\n    vec3 color = vec3(0.0);\n    vec3 hitPos_ = vec3(0.0);\n    vec3 hitNormal_ = vec3(0.0);\n    vec3 k_rg_ = vec3(0.0);\n    float t_min = INFINITY;\n    float t_max = -INFINITY;\n    bool hit = false;\n    for (int i = 0; i < num_objects; i++) {\n        float t = IntersectRay(ray, objects[i]);\n        if (t < t_min) {\n            t_min = t;\n        }\n        if (t > t_max) {\n            t_max = t;\n        }\n        if (t > 0.0) {\n            hit = true;\n            hitPos_ = ray.origin + t * ray.dir;\n            hitNormal_ = objects[i].normal(hitPos_);\n            k_rg_ = objects[i].k_rg;\n        }\n    }\n    if (hit) {\n        hasHit = true;\n        hitPos = hitPos_;\n        hitNormal = hitNormal_;\n        k_rg = k_rg_;\n    } else {\n        hasHit = false;\n        color = vec3(0.0);\n    }\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p20 = mix(p2, p0, 0.5);\n\n    // midpoints\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p120 = mix(p12, p20, 0.5);\n    vec2 p201 = mix(p20, p01, 0.5);\n\n    // corners\n    vec2 p0120 = mix(p012, p120, 0.5);\n    vec2 p1201 = mix(p120, p201, 0.5);\n    vec2 p2010 = mix(p201, p012, 0.5);\n\n    // return the bbox\n    return vec4(p0120, p1201, p2010);\n}\n\n// Approximate BBox to a quadratic bezier\nvec", "\n    vec3 bmin = min( p0, min( p1, min( p2, p3 ) ) );\n    vec3 bmax = max( p0, max( p1, max( p2, p3 ) ) );\n\n    // center\n    vec3 bcenter = 0.5 * ( bmin + bmax );\n\n    // diagonal\n    vec3 bdiag = bmax - bmin;\n\n    // return\n    return bound3( bcenter - 0.5 * bdiag, bcenter + 0.5 * bdiag );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://iquilezles.org/www/articles/spheresphere/spheresphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 q, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/conecone/conecone.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 p, in vec3 q, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 q, in float r )\n{\n", "\n    const float PI = 3.1415926535897932384626433832795;\n    const float TAU = 2.0 * PI;\n    const float PI_OVER_2 = PI / 2.0;\n    const float PI_OVER_4 = PI / 4.0;\n    const float PI_OVER_6 = PI / 6.0;\n    const float PI_OVER_8 = PI / 8.0;\n    const float PI_OVER_16 = PI / 16.0;\n    const float PI_OVER_32 = PI / 32.0;\n    const float PI_OVER_64 = PI / 64.0;\n    const float PI_OVER_128 = PI / 128.0;\n    const float PI_OVER_256 = PI / 256.0;\n    const float PI_OVER_512 = PI / 512.0;\n    const float PI_OVER_1024 = PI / 1024.0;\n    const float PI_OVER_2048 = PI / 2048.0;\n    const float PI_OVER_4096 = PI / 4096.0;\n    const float PI_OVER_8192 = PI / 8192.0;\n    const float PI_OVER_16384 = PI / 16384.0;\n    const float PI_OVER_32768 = PI / 32768.0;\n    const float PI_OVER_65536 = PI / 65536.0;\n    const float PI_OVER_131072 = PI / 131072.0;\n    const float PI_OVER_262144 = PI / ", "\n    return cos( k * PI / 2.0 ); // EaseInOut\n}\n\n/**\n * Easing Curve\n */\nfloat", "\n    vec4 b = vec4(v.x - floor(v.x + 0.5), v.x - floor(v.x - 0.5),\n                  v.y - floor(v.y + 0.5), v.y - floor(v.y - 0.5));\n\n    // Gradients\n    // (N*5 - 1) / 4 used to avoid 0s in the gradient.\n    vec4 o = vec4(0.041970724, 0.024665052, 0.014403290, 0.009360530) - b;\n\n    // Mix final noise value\n    vec4 n0 = vec4(dot(b, vec4(dot(o, vec4(1.000000, 57.000000, 113.000000, 259.000000)))));\n    vec4 n1 = vec4(dot(b, vec4(dot(o, vec4(33.000000, 21.000000, 3.000000, 9.000000)))));\n\n    return 49.000000 * (dot(n0, v) + dot(n1, v + vec4(1.000000, 1.000000, 0.000000, 0.000000)));\n}\n\n//\n// Description : GLSL 2D simplex noise function\n//      Author : Ian McEwan, Ashima Arts\n//  Maintainer : ijm\n//     Lastmod : 20110822 (ijm)\n//     License :\n//  Copyright (C) 2011 Ashima Arts. All rights reserved.\n//  Distributed under the MIT License. See LICENSE file.\n//  https://github.com/ashima/webgl-noise\n//\nfloat", "\n\tvec2 uv = fragCoord/iResolution.xy;\n\t\n\t// Time varying pixel color\n\tvec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\t\n\t// Output to screen\n\tfragColor = vec4(col,1.0);\n}\n", "\n    coord -= vec2(0.5);\n\n    // Scale the coordinate to the size of the screen.\n    coord *= res;\n\n    // Translate the coordinate to the center of the screen.\n    coord += vec2(0.5);\n\n    return coord;\n}\n\n// Remap the OpenGL space to the space where the julia set is defined ( [(-2;-2),(2;2)] ).\nvec", "\n    float f = sin(p.x*10.0)*sin(p.y*10.0);\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f*f;\n    f = f", "\n    // https://www.shadertoy.com/view/4djSRW\n    vec3 rgb2hcv = rgb * 2.04040323 - 0.5;\n    rgb2hcv.xz *= mat2(1.0, 1.0, -1.0, -1.0);\n    rgb2hcv.y = sqrt(rgb2hcv.y);\n    return rgb2hcv;\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec", "\n    // return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n\n    // Better, but still not as nicely dispersed.\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D noise with perlin noise.\nfloat", "\n    const float eps = 0.0001;\n    return normalize(\n        vec3(\n            map( p + vec3( eps, 0.0, 0.0 ) ) - map( p - vec3( eps, 0.0, 0.0 ) ),\n            map( p + vec3( 0.0, eps, 0.0 ) ) - map( p - vec3( 0.0, eps, 0.0 ) ),\n            map( p + vec3( 0.0, 0.0, eps ) ) - map( p - vec3( 0.0, 0.0, eps ) )\n        )\n    );\n}\n\n// Tetrahedral normal, to save a couple of \"map\" calls. Courtesy of IQ.\nvec", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// 2D Perlin Noise based on Morgan McGuire @morgan3d\n// https://www.shadertoy.com/view/4dS3Wd\nfloat", "\n    float angle = TWO_PI / width;\n    float x = radius * cos(angle);\n    float y = radius * sin(angle);\n    return DrawPoint(pos + vec2(x, y), 0.001);\n}\n\n// Draw a piece of leaf points to LEFT ((0,0)->(-1,0))\n// width (0.,1.)\nfloat", "\n    vec4 v3 = vec4(v.x - floor(v.x + 0.5), v.y - floor(v.y + 0.5), 0.0, 0.0);\n    vec4 i3 = floor(v3 + 0.5);\n\n    // Replicate v3 to full 4x4 grid of v\n    vec4 v4 = smoothstep(vec4(0.0), vec4(1.0, 1.0, 1.0, 1.0), v3);\n\n    // Linearly interpolate between four corners of a tile\n    vec4 i = vec4(i3.x + i3.y * 57.0, i3.x + 1.0 + i3.y * 57.0, i3.x + i3.y * 113.0, i3.x + 1.0 + i3.y * 113.0);\n    vec4 x = v4.xzxy + v4.ywys;\n\n    // Mix final noise value in range 0-1\n    return mix(mix(mix(dot(x, vec4(1.0, 57.0, 57.0, 113.0)), x.y), x.z, x.w), x.x, v4.y);\n}\n\n//SNOISE\nfloat", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tuv.x *= iResolution.x / iResolution.y;\n\t\n\t// get the ray direction\n\tvec3 rayDir = normalize(vec3(uv * 2.0 - 1.0, 1.0));\n\t\n\t// get the ray origin\n\tvec3 rayOrigin = vec3(0.0);\n\t\n\t// get the ray color\n\tvec3 rayColor = vec3(0.0);\n\t\n\t// get the ray distance\n\tfloat rayDistance = 0.0;\n\t\n\t// get the ray depth\n\tfloat rayDepth = 0.0;\n\t\n\t// get the ray normal\n\tvec3 rayNormal = vec3(0.0);\n\t\n\t// get the ray material\n\tvec3 rayMaterial = vec3(0.0);\n\t\n\t// get the ray light\n\tvec3 rayLight = vec3(0.0);\n\t\n\t// get the ray reflections\n\tvec3 rayReflections = vec3(0.0);\n\t\n\t// get the ray refractions\n\tvec3 rayRefractions = vec3(0.0);\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex2 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex3 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex4 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex5 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex6 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex7 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex8 = 0.0;\n\t\n\t// get the ray refractive index\n\tfloat rayRefractiveIndex9 = 0.0;\n\t\n\t// get the ray refractive index", "\n    float n = noise(p);\n    n += noise(p + vec3(1.0, 0.0, 0.0));\n    n += noise(p + vec3(0.0, 1.0, 0.0));\n    n += noise(p + vec3(0.0, 0.0, 1.0));\n    return n / 4.0;\n}\n\n// Thanks Shane.\nfloat", "\n\tvec3 q = log(p);\n\n\t// Apply the tiling\n\tq.xz *= TILE_SIZE;\n\n\t// Apply the offset\n\tq.xz += TILE_OFFSET;\n\n\t// Apply the rotation\n\tq.yzx = mul(q.yzx, ROTATION);\n\n\t// Apply the inverse log-spherical map\n\tsp = exp(q);\n\n\t// Apply the tiling\n\ttp = sp.xz * TILE_SIZE;\n\n\t// Apply the offset\n\ttp += TILE_OFFSET;\n\n\t// Apply the rotation\n\trp = mul(tp, ROTATION);\n\n\t// Apply the scaling\n\tmul = TILE_SCALE;\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`: point in log-spherical space without offset or tiling\n- out `tp`: point in tiled log-spherical space\n- out `rp`: point in rotated tiled log-spherical space\n- out `mul`: total amount of scaling applied at this point\n*/\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul)\n{\n\t// Apply the forward log-spherical map\n\tvec3 q = log(p);\n\n\t// Apply the tiling\n\tq.xz *= TILE_SIZE;\n\n\t// Apply the offset\n\tq.xz += TILE_OFFSET;\n\n\t// Apply the rotation\n\tq.yzx = mul(q.yzx, ROTATION);\n\n\t// Apply the inverse log-spherical map\n\tsp = exp(q);\n\n\t// Apply the tiling\n\ttp = sp.xz * TILE_SIZE;\n\n\t// Apply the offset\n\ttp += TILE_OFFSET;\n\n\t// Apply the rotation\n\trp = mul(tp, ROTATION);\n\n\t// Apply the scaling\n\tmul = TILE_SCALE;\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`", "\n    float d = length(p.xy) - 0.5;\n    //distance to plane = distance to center of plane minus height\n    //x-pos and height vary over time in some sin/cos pattern\n    float d2 = p.z - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d3 = length(p.xy) - 0.5;\n    //distance to cone = distance to center of cone minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d4 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d5 = length(p.xy) - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d6 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d7 = length(p.xy) - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d8 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d9 = length(p.xy) - 0.5;\n    //distance to cylinder = distance to center of cylinder minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d10 = length(p.xy) - 0.5;\n    //distance to torus = distance to center of torus minus radius\n    //x-pos and radius vary over time in some sin/cos pattern\n    float d11 = length(p.xy) - 0.", "\n  return vec2(z.x*w.x-z.y*w.y, z.y*w.x+z.x*w.y);\n}\n\n// Complex functions\nvec", "\n\tret += vec3(p.x, p.y, 0.0);\n\tret += vec3(p.x, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize, p.y, 0.0);\n\n\t// T to R\n\tret += vec3(p.x + aaSize, p.y, 0.0);\n\tret += vec3(p.x + aaSize, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 2.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 2.0, p.y, 0.0);\n\n\t// R to B\n\tret += vec3(p.x + aaSize * 2.0, p.y, 0.0);\n\tret += vec3(p.x + aaSize * 2.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 3.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x + aaSize * 3.0, p.y, 0.0);\n\n\t// B to L\n\tret += vec3(p.x + aaSize * 3.0, p.y, 0.0);\n\tret += vec3(p.x + aaSize * 3.0, p.y + aaSize, 0.0);\n\tret += vec3(p.x, p.y + aaSize, 0.0);\n\tret += vec3(p.x, p.y, 0.0);\n}\n\n/*\nConstruct a Penrose triangle in 3D by manually placing a bunch of angled\nsquares. Nothing really magic.\n*/\nvoid drawPen", "\n    mat3 rot = mat3(\n        vec3(cos(time), 0.0, sin(time)),\n        vec3(0.0, 1.0, 0.0),\n        vec3(-sin(time), 0.0, cos(time))\n    );\n\n    // rotate the position of the box\n    vec3 rotatedPos = rot * pos;\n\n    // get the distance to the box\n    vec2 dist = vec2(length(rotatedPos.xz) - 0.5, rotatedPos.y);\n\n    // get the material ID of the box\n    vec2 materialID = vec2(0.0, 0.0);\n\n    // if the box is closer to the camera than the previous closest box, update the closest box\n    if (dist.x < closestBox.x) {\n        closestBox = dist;\n        materialID = vec2(1.0, 0.0);\n    }\n\n    // if the box is closer to the camera than the previous closest box, update the closest box\n    if (dist.x < closestBox2.x) {\n        closestBox2 = dist;\n        materialID = vec2(1.0, 1.0);\n    }\n\n    // return the distance to the box and the material ID\n    return dist;\n}\n\n// returns the distance to our rotating box and the its associated material ID packed into a vec2\nvec", "\n    float dist = length(pos.xz) - 0.5;\n\n    // if the sphere is closer to the camera, make it darker\n    float darken = smoothstep(0.0, 0.05, dist);\n\n    // return the distance to the sphere and the material ID\n    return vec2(dist, darken);\n}\n\n// returns the distance to our moving sphere and the its associated material ID packed into a vec2\nvec", "\n    vec2 res = vec2(1.0);\n    res.x = sdf_sphere(pos, vec3(0.0, 0.0, 0.0), 0.5);\n    res.y = sdf_sphere(pos, vec3(0.0, 0.0, 0.0), 0.1);\n    return res;\n}\n\n// this is the combined scene sdf function for the shadow ray.\n// it returns a vec2 containing a depth value for the x coordinate, and a material ID for the y coordinate.\nvec", "\n    vec3 rayDir = normalize(camDir + lightDir);\n    \n    // march the ray in the scene\n    vec4 color = vec4(0.0);\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec3 p = camPos + rayDir * t;\n        vec4 s = scene(p);\n        color += s;\n        t += s.a;\n        if (t > MAX_DIST || s.a < 0.001) break;\n    }\n    \n    // return the color of the ray\n    return color;\n}\n\n// raymarches our scene with a provided camera position, camera direction, and simple directional light\nvec", "\n\tvec3 bmin = rad;\n\tvec3 bmax = -rad;\n\tvec3 tmin = (bmin - ro) / rd;\n\tvec3 tmax = (bmax - ro) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(max(t1.x, t1.y), t1.z);\n\tfloat tN = min(min(t2.x, t2.y), t2.z);\n\tif (t0 > tN) return vec2(-1.0);\n\treturn vec2(t0, tN);\n}\n\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec", "\n\tvec2 uv = (fragCoord.xy / iResolution.xy) * 2.0 - 1.0;\n\tuv.x *= iResolution.x / iResolution.y;\n\n\t// raymarching\n\tvec3 ro = vec3(0.0, 0.0, 0.0);\n\tvec3 rd = normalize(vec3(uv, 1.0));\n\tvec3 col = vec3(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n", "\n    return dot(plane.normal, pos) - plane.distance;\n}\n\n// @brief Get signed-distance funciton weight value of sphere.\nfloat", " cell coordinates\n    ivec3 gx = ix;\n    // grid cell coordinates offset by 1\n    ivec3 gy = ix + ivec3(1, 1, 1);\n    // grid cell coordinates offset by 2\n    ivec3 gz = ix + ivec3(2, 2, 2);\n    // grid cell coordinates offset by 3\n    ivec3 gw = ix + ivec3(3, 3, 3);\n    // grid cell coordinates offset by 4\n    ivec3 gx1 = ix + ivec3(4, 4, 4);\n    // grid cell coordinates offset by 5\n    ivec3 gy1 = ix + ivec3(5, 5, 5);\n    // grid cell coordinates offset by 6\n    ivec3 gz1 = ix + ivec3(6, 6, 6);\n    // grid cell coordinates offset by 7\n    ivec3 gw1 = ix + ivec3(7, 7, 7);\n    // grid cell coordinates offset by 8\n    ivec3 gx2 = ix + ivec3(8, 8, 8);\n    // grid cell coordinates offset by 9\n    ivec3 gy2 = ix + ivec3(9, 9, 9);\n    // grid cell coordinates offset by 10\n    ivec3 gz2 = ix + ivec3(10, 10, 10);\n    // grid cell coordinates offset by 11\n    ivec3 gw2 = ix + ivec3(11, 11, 11);\n    // grid cell coordinates offset by 12\n    ivec3 gx3 = ix + ivec3(12, 12, 12);\n    // grid cell coordinates offset by 13\n    ivec3 gy3 = ix + ivec3(13, 13, 13);\n    // grid cell coordinates offset by 14\n    ivec3 gz3 = ix + ivec3(14, 14, 14);\n    // grid cell coordinates", "\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we need to use integer values for the period and lacunarity\n    // to avoid floating point errors\n    // we", "\n    float s = sin(p.x);\n    p.x = abs(p.x);\n    p.x = p.x - 2.0 * s;\n    p.x = abs(p.x);\n    p.x = max(p.x, 0.0);\n    p.x = min(p.x, 1.0);\n    p.x = p.x * p.x * (3.0 - 2.0 * p.x);\n\n    // Distance to the capsule\n    float d = length(p) - r;\n\n    // Slice shift effect (only applied on instance of capsule)\n    p.x = abs(p.x);\n    p.x = p.x - 2.0 * s;\n    p.x = abs(p.x);\n    p.x = max(p.x, 0.0);\n    p.x = min(p.x, 1.0);\n    p.x = p.x * p.x * (3.0 - 2.0 * p.x);\n\n    // Distance to the capsule\n    d = max(d, -p.x);\n\n    // Return the distance to the capsule\n    return d;\n}\n\nfloat", "\n     p.xz = mat2(cos(time),sin(time),-sin(time),cos(time))*p.xz;\n     p.xz += vec2(sin(time),cos(time))*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2.0)*0.1;\n     p.xz.y += sin(time*2.0)*0.1;\n     p.xz.y += cos(time*2", "\n  // eps.xxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxy <=> vec3(0.001, 0.  , 0.001)\n  // eps.xyx <=> vec3(0.  , 0.001, 0.001)\n  // eps.yxx <=> vec3(0.  , 0.001, 0.001)\n  // eps.yxy <=> vec3(0.  , 0.001, 0.001)\n  // eps.yyx <=> vec3(0.  , 0.001, 0.001)\n  // eps.xxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxy <=> vec3(0.001, 0.001, 0.001)\n  // eps.xyx <=> vec3(0.001, 0.001, 0.001)\n  // eps.yxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.yxy <=> vec3(0.001, 0.001, 0.001)\n  // eps.yyx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxx <=> vec3(0.001, 0.001, 0.001)\n  // eps.xxy <=> vec3(0.001, 0.001, 0.001)\n  // eps.xyx <=> vec3(0.001, 0.001, 0.001)\n  // eps.yxx <=> vec3(0", "\n    return max(dot(n,l),0.0);\n}\n\n// Lighting part, still confusing\nfloat", "\n    vec4 q = vec4( rd.x, rd.y, rd.z, -ra*ra );\n    vec4 k = vec4( 1.0, 1.0, 1.0, -4.0 );\n    vec4 u = solveQuartic( q, k );\n\n    // -----------------------------\n    // check if ray intersects sphere\n    // -----------------------------\n    float tmin = u.x;\n    float tmax = u.y;\n    if( tmin > tmax )\n    {\n        return -1.0;\n    }\n\n    // -----------------------------\n    // compute sphere intersection\n    // -----------------------------\n    float t = tmin;\n    vec3 p = ro + t*rd;\n    float d = length( p );\n    if( d > ra )\n    {\n        return -1.0;\n    }\n\n    return t;\n}\n\n// -----------------------------\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat", "\n    vec2 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n\n    // gradient\n    vec2 g = dpdx*f.x + dpdy*f.y;\n    g = f*f*(3.0-2.0*f);\n\n    // sum\n    return dot(g,g);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    Sphere[0].center.x = 0.0;\n    Sphere[0].center.y = 0.0;\n    Sphere[0].center.z = 0.0;\n    Sphere[0].radius = 1.0;\n    Sphere[0].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[1].center.x = -1.0;\n    Sphere[1].center.y = 0.0;\n    Sphere[1].center.z = 0.0;\n    Sphere[1].radius = 1.0;\n    Sphere[1].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[2].center.x = 1.0;\n    Sphere[2].center.y = 0.0;\n    Sphere[2].center.z = 0.0;\n    Sphere[2].radius = 1.0;\n    Sphere[2].materialID = 0;\n\n    // Top bouncing sphere.\n    Sphere[3].center.x = 0.0;\n    Sphere[3].center.y = 1.0;\n    Sphere[3].center.z = 0.0;\n    Sphere[3].radius = 1.0;\n    Sphere[3].materialID = 0;\n\n    // Bottom bouncing sphere.\n    Sphere[4].center.x = 0.0;\n    Sphere[4].center.y = -1.0;\n    Sphere[4].center.z = 0.0;\n    Sphere[4].radius = 1.0;\n    Sphere[4].materialID = 0;\n\n    // Left bouncing sphere.\n    Sphere[5].center.x = -1.0;\n    Sphere[5].center.y = 0.0;\n    Sphere[5].center.z = 0.0;\n    Sphere[5].radius = 1.0;\n    Sphere[5].materialID = 0;\n\n    // Right bouncing sphere.\n    Sphere[6].center.x = 1.0;\n    Sphere[6].center.y = 0.0;\n    Sphere", "\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ///////////////////////////////////////\n    // END OF TASK. DO NOT DELETE THIS //\n    ///////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and t", "\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION POINT. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION DISTANCE. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION CODE. //\n    ////////////////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION POINT. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION DISTANCE. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION CODE. //\n    ////////////////////////////////////////////////\n\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax )\n{\n    /////////////////////////////////\n    // TASK: WRITE YOUR CODE HERE. //\n    /////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION POINT. //\n    ////////////////////////////////////////////////\n\n    ////////////////////////////////////////////////\n    // TASK: COMPUTE THE INTERSECTION DISTANCE. //\n    ////////////////////////////////////////////////\n", "\n    vec3 nearestHitPos = vec3(0.0);\n    vec3 nearestHitNormal = vec3(0.0);\n    vec3 nearestHitK_rg = vec3(0.0);\n    float nearestHitT = INFINITY;\n    for ( int i = 0; i < scene.numObjects; i++ ) {\n        Intersection_t hit = IntersectRay( ray, scene.objects[i] );\n        if ( hit.t < nearestHitT ) {\n            nearestHitT = hit.t;\n            nearestHitPos = hit.pos;\n            nearestHitNormal = hit.normal;\n            nearestHitK_rg = hit.k_rg;\n        }\n    }\n\n    // If there is no intersection, return the background color.\n    if ( nearestHitT == INFINITY ) {\n        hasHit = false;\n        hitPos = vec3(0.0);\n        hitNormal = vec3(0.0);\n        k_rg = vec3(0.0);\n        return scene.backgroundColor;\n    }\n\n    // If there is intersection, compute the color at the hit point.\n    hasHit = true;\n    hitPos = nearestHitPos;\n    hitNormal = nearestHitNormal;\n    k_rg = nearestHitK_rg;\n\n    // Compute the color at the hit point using Phong Lighting Model.\n    vec3 color = vec3(0.0);\n    for ( int i = 0; i < scene.numLights; i++ ) {\n        // Compute the shadow ray.\n        Ray_t shadowRay = Ray_t( nearestHitPos, scene.lights[i].pos - nearestHitPos );\n\n        // Find whether the shadow ray hits any object.\n        bool shadowHit = false;\n        for ( int j = 0; j < scene.numObjects; j++ ) {\n            Intersection_t shadowHit = IntersectRay( shadowRay, scene.objects[j] );\n            if ( shadowHit.t < scene.objects[j].radius ) {\n                shadowHit = true;\n                break;\n            }\n        }\n\n        // If the shadow", " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n\n    // shadow accumulator\n    float shade = 0.0;\n\n    // number of steps\n    const int steps = 100;\n\n    // step size\n    float d = 1.0 / float(steps);\n\n    // step count\n    int i = 0;\n\n    // loop\n    for( ; i < steps; i++ )\n    {\n        // get the current position\n        vec3 p = ro + rd * tmax;\n\n        // get the current depth\n        float t = texture( shadowMap, p.xy ).x;\n\n        // if the current depth is greater than the current bounding volume\n        // then we have a shadow\n        if( t > bv.z )\n        {\n            // add the current depth to the accumulator\n            shade += t - bv.z;\n\n            // if the current depth is less than the minimum depth then we\n            // have a shadow\n            if( t < mint )\n            {\n                // we are done\n                break;\n            }\n\n            // update the bounding volume\n            bv = bv + vec4(rd * d, 0.0);\n        }\n\n        // update the maximum depth\n        tmax -= d;\n    }\n\n    // return the shadow\n    return shade / float(i);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat", "\n    start += planet_position;\n\n    // the color of the rayleigh scattering\n    vec3 rayleigh_color = vec3(0.0);\n\n    // the color of the mie scattering\n    vec3 mie_color = vec3(0.0);\n\n    // the color of the absorption\n    vec3 absorption_color = vec3(0.0);\n\n    // the color of the ambient\n    vec3 ambient_color = vec3(0.0);\n\n    // the color of the final result\n    vec3 final_color = vec3(0.0);\n\n    // the color of the light\n    vec3 light_color = vec3(0.0);\n\n    // the color of the atmosphere\n    vec3 atmosphere_color = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_2 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_2 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_3 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_3 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_4 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_4 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_5 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_5 = vec3(0", "\n    vec3 light_dir_bend = normalize(light_dir + surface_normal * 0.001);\n\n    // sample the skylight\n    vec3 skylight_sample = texture(skylight_tex, sample_pos.xy).rgb;\n\n    // sample the skylight in the direction of the light direction\n    vec3 skylight_sample_light = texture(skylight_tex, sample_pos.xy + light_dir_bend * 0.001).rgb;\n\n    // mix the skylight samples\n    vec3 skylight_mix = mix(skylight_sample, skylight_sample_light, 0.5);\n\n    // mix the skylight with the background color\n    vec3 skylight_mix_background = mix(skylight_mix, background_col, 0.5);\n\n    return skylight_mix_background;\n}\n\n/*\nThe atmosphere function takes in a sample position and a surface normal and returns the color of the atmosphere\n*/\nvec", "\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // the distance to the surface\n    float dist = length(pos);\n    \n    // the color of the sphere\n    vec3 sphere_color = vec3(0.0, 1.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_2 = vec3(0.0, 0.0, 1.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_3 = vec3(1.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_4 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_5 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_6 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_7 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_8 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_9 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_10 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_11 = vec3(0.0, 0.0, 0.0);\n    \n    // the color of the sphere\n    vec3 sphere_color_12 = vec3(0.0, 0.0", " and position\n    vec3 camPos = cameraPos;\n    vec3 camDir = cameraDir;\n    \n    // get the light dir\n    vec3 lightDir = normalize(lightDir);\n    \n    // get the ray direction\n    vec3 rayDir = normalize(camDir + lightDir);\n    \n    // get the ray origin\n    vec3 rayOrigin = camPos;\n    \n    // get the ray length\n    float rayLength = 1000.0;\n    \n    // get the ray color\n    vec3 rayColor = vec3(0.0);\n    \n    // get the ray step\n    float rayStep = 0.001;\n    \n    // get the ray step\n    float rayStep2 = 0.0001;\n    \n    // get the ray step\n    float rayStep3 = 0.00001;\n    \n    // get the ray step\n    float rayStep4 = 0.000001;\n    \n    // get the ray step\n    float rayStep5 = 0.0000001;\n    \n    // get the ray step\n    float rayStep6 = 0.00000001;\n    \n    // get the ray step\n    float rayStep7 = 0.000000001;\n    \n    // get the ray step\n    float rayStep8 = 0.0000000001;\n    \n    // get the ray step\n    float rayStep9 = 0.00000000001;\n    \n    // get the ray step\n    float rayStep10 = 0.000000000001;\n    \n    // get the ray step\n    float rayStep11 = 0.0000000000001;\n    \n    // get the ray step\n    float rayStep12 = 0.00000000000001;\n    \n    // get the ray step\n    float rayStep13 = 0.000000000000001;\n    \n    //", "\n\n    // Compute a\n    vec3 a = r0 - s0;\n\n    // Compute b\n    float b = dot(a, rd);\n\n    // Compute c\n    float c = dot(a, a) - sr * sr;\n\n    // Compute discriminant\n    float d = b * b - c;\n\n    // If discriminant is negative, there are no real roots, so return -1.0\n    if (d < 0.0) {\n        return -1.0;\n    }\n\n    // Compute the two roots\n    float root1 = -b - sqrt(d);\n    float root2 = -b + sqrt(d);\n\n    // Return the smaller root\n    if (root1 < 0.0) {\n        return root2;\n    }\n    if (root2 < 0.0) {\n        return root1;\n    }\n    return min(root1, root2);\n}\n\n//-----------------------------------------------------------------------\n// raySphereIntersect\n//-----------------------------------------------------------------------\nfloat", "ialize variables\n    vec4 finalColor = vec4(0.0);\n    vec3 rayDir = normalize(cameraRayDir);\n    vec3 rayPos = cameraPos;\n    vec3 rayPos2 = cameraPos;\n    vec3 rayPos3 = cameraPos;\n    vec3 rayPos4 = cameraPos;\n    vec3 rayPos5 = cameraPos;\n    vec3 rayPos6 = cameraPos;\n    vec3 rayPos7 = cameraPos;\n    vec3 rayPos8 = cameraPos;\n    vec3 rayPos9 = cameraPos;\n    vec3 rayPos10 = cameraPos;\n    vec3 rayPos11 = cameraPos;\n    vec3 rayPos12 = cameraPos;\n    vec3 rayPos13 = cameraPos;\n    vec3 rayPos14 = cameraPos;\n    vec3 rayPos15 = cameraPos;\n    vec3 rayPos16 = cameraPos;\n    vec3 rayPos17 = cameraPos;\n    vec3 rayPos18 = cameraPos;\n    vec3 rayPos19 = cameraPos;\n    vec3 rayPos20 = cameraPos;\n    vec3 rayPos21 = cameraPos;\n    vec3 rayPos22 = cameraPos;\n    vec3 rayPos23 = cameraPos;\n    vec3 rayPos24 = cameraPos;\n    vec3 rayPos25 = cameraPos;\n    vec3 rayPos26 = cameraPos;\n    vec3 rayPos27 = cameraPos;\n    vec3 rayPos28 = cameraPos;\n    vec3 rayPos29 = cameraPos;\n    vec3 rayPos30 = cameraPos;\n    vec3 rayPos31 = cameraPos;\n    vec3 rayPos32 = cameraPos;\n    vec3 rayPos33 = cameraPos;\n    vec3 rayPos34 = cameraPos;\n    vec3 rayPos35 = cameraPos;\n    vec3 rayPos36 = cameraPos;\n    vec3 rayPos37 = cameraPos;\n    vec3 ray", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", " ray\n    vec3 ray_path[MAX_PATHS];\n    ray_path[0] = ray_origin;\n\n    // Initialize the sample color -\n    // the color of the sample ray\n    vec3 sample_color = vec3(0.0);\n\n    // Initialize the sample depth -\n    // the depth of the sample ray\n    float sample_depth = 0.0;\n\n    // Initialize the sample index -\n    // the index of the sample ray in the ray path list\n    int sample_index = 0;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray = ray_target;\n\n    // Initialize the sample ray direction -\n    // the direction of the sample ray\n    vec3 sample_ray_direction = normalize(ray_target - ray_origin);\n\n    // Initialize the sample ray length -\n    // the length of the sample ray\n    float sample_ray_length = length(ray_target - ray_origin);\n\n    // Initialize the sample ray length squared -\n    // the length of the sample ray squared\n    float sample_ray_length_squared = sample_ray_length * sample_ray_length;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed = sample_ray_length_squared * sample_ray_length;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root = sqrt(sample_ray_length_cubed);\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root_inv = 1.0 / sample_ray_length_cubed_root;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root_inv_2 = sample_ray_length_cubed_root_inv * sample_", "\n    int cellID = int(p.x) + int(p.y) * 10;\n    vec2 cellCoords = vec2(p.x, p.y);\n    \n    // Local cell coordinates.\n    vec2 cellCoordsLocal = cellCoords - vec2(0.5);\n    \n    // Local cell coordinates in the range [-1, 1].\n    vec2 cellCoordsLocalRange = cellCoordsLocal / 10.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset.\n    vec2 cellCoordsLocalOffset = cellCoordsLocalRange + vec2(0.5);\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenter = cellCoordsLocalOffset + vec2(0.5);\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange = cellCoordsLocalOffsetCenter / 10.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange2 = cellCoordsLocalOffsetCenterRange * 2.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange3 = cellCoordsLocalOffsetCenterRange2 * 2.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange4 = cellCoordsLocalOffsetCenterRange3 * 2.0;\n    \n    // Local cell coordinates in the range [-1, 1] with the \n    // diagonal offset and the offset to the center.\n    vec2 cellCoordsLocalOffsetCenterRange5 = cellCoordsLocalOffset", "\n    vec3 sphere_loc = vec3(0.0, 0.0, 0.0);\n    float sphere_rad = 1.0;\n\n    // calculate distance from sphere\n    float dist = length(p - sphere_loc) - sphere_rad;\n\n    return dist;\n}\n\n// Get the color of the sphere\nvec", "\n    vec3 Pi0 = floor( P );\n    vec3 Pf0 = fract( P );\n\n    // calculate the distance from each corner to the point\n    vec3 uv0 = Pf0*Pf0*(3.0-2.0*Pf0);\n\n    // calculate the distance from each corner to the point\n    vec3 uv1 = Pf0*(1.0-Pf0)*(1.0-Pf0)*Pf0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv2 = 1.0-Pf0*(1.0-Pf0)*Pf0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv3 = 1.0-uv0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv4 = Pf0*Pf0;\n\n    // calculate the distance from each corner to the point\n    vec3 uv5 = 1.0-uv4;\n\n    // calculate the distance from each corner to the point\n    vec3 uv6 = Pf0*(1.0-uv4);\n\n    // calculate the distance from each corner to the point\n    vec3 uv7 = 1.0-uv6;\n\n    // calculate the distance from each corner to the point\n    vec3 uv8 = Pf0*uv4;\n\n    // calculate the distance from each corner to the point\n    vec3 uv9 = 1.0-uv8;\n\n    // calculate the distance from each corner to the point\n    vec3 uv10 = Pf0*uv6;\n\n    // calculate the distance from each corner to the point\n    vec3 uv11 = 1.0-uv10;\n\n    // calculate the distance from each corner to the point\n    vec3 uv12 = Pf0*uv8;\n\n    // calculate the distance from each corner to the point\n    vec3 uv13 = 1.0-uv12;\n\n    // calculate the distance from each corner to the point\n    vec3 uv14 = Pf0", "\n    float n = floor(x);\n    float f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    // return noise\n    return mix(\n        noise(n),\n        noise(n + 1.0),\n        f\n    );\n}\n\n// 2D Perlin Noise\nfloat", "\n    vec3 ground = vec3(0.0, -0.001, 0.0);\n    vec3 ground_size = vec3(100.0, 0.001, 100.0);\n    vec3 ground_pos = vec3(0.0, -0.001, 0.0);\n    vec3 ground_rot = vec3(0.0, 0.0, 0.0);\n    vec3 ground_scale = vec3(1.0, 1.0, 1.0);\n    vec3 ground_color = vec3(0.0, 0.0, 0.0);\n    vec3 ground_normal = vec3(0.0, 1.0, 0.0);\n    vec3 ground_specular = vec3(0.0, 0.0, 0.0);\n    vec3 ground_shininess = 1.0;\n    vec3 ground_transparency = 1.0;\n    vec3 ground_reflection = 0.0;\n    vec3 ground_refraction = 0.0;\n    vec3 ground_emission = vec3(0.0, 0.0, 0.0);\n    vec3 ground_light = vec3(0.0, 0.0, 0.0);\n    vec3 ground_attenuation = vec3(1.0, 0.0, 0.0);\n    vec3 ground_light_color = vec3(0.0, 0.0, 0.0);\n    vec3 ground_light_intensity = 0.0;\n    vec3 ground_light_radius = 0.0;\n    vec3 ground_light_angle = 0.0;\n    vec3 ground_light_falloff = 0.0;\n    vec3 ground_light_attenuation = vec3(1.0, 0.0, 0.0);\n    vec3 ground_light_color_attenuation = vec3(1.0, ", "\n    vec3 world = p;\n\n    // world to camera\n    vec3 cam = world - vec3(0.0, 0.0, 10.0);\n\n    // camera to screen\n    vec2 screen = cam.xy / cam.z * 0.5 + 0.5;\n\n    // screen to world\n    vec3 worldScreen = vec3(screen, 1.0);\n\n    // world to screen\n    vec2 worldScreen2 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen3 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen4 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen5 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen6 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen7 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen8 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen9 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen10 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen11 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen12 = worldScreen.xy / worldScreen.z * 0.5 + 0.5;\n\n    // world to screen\n    vec2 worldScreen13 = worldScreen.xy / world", " from a to b\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float t = dot(pa, ba) / dot(ba, ba);\n    if (t < 0.0) return d;\n    if (t > 1.0) return d;\n    return d + pix * length(pa - ba * t);\n}\n\nfloat", "\n\tvec2 st = fragCoord/iResolution.xy;\n\tvec2 p = -1.0 + 2.0*st;\n\tfloat d = length(p);\n\tfloat a = atan(p.y,p.x);\n\tfloat r = (d-0.01)/0.02;\n\tfloat t = iTime*0.2;\n\tfloat c = cos(t);\n\tfloat s = sin(t);\n\tfloat m = mod(t,1.0);\n\tfloat n = mod(t,2.0);\n\tfloat k = mod(t,3.0);\n\tfloat l = mod(t,4.0);\n\tfloat o = mod(t,5.0);\n\tfloat p = mod(t,6.0);\n\tfloat q = mod(t,7.0);\n\tfloat r = mod(t,8.0);\n\tfloat s = mod(t,9.0);\n\tfloat t = mod(t,10.0);\n\tfloat u = mod(t,11.0);\n\tfloat v = mod(t,12.0);\n\tfloat w = mod(t,13.0);\n\tfloat x = mod(t,14.0);\n\tfloat y = mod(t,15.0);\n\tfloat z = mod(t,16.0);\n\tfloat a = mod(t,17.0);\n\tfloat b = mod(t,18.0);\n\tfloat c = mod(t,19.0);\n\tfloat d = mod(t,20.0);\n\tfloat e = mod(t,21.0);\n\tfloat f = mod(t,22.0);\n\tfloat g = mod(t,23.0);\n\tfloat h = mod(t,24.0);\n\tfloat i = mod(t,25.0);\n\tfloat j = mod(t,26.0);\n\tfloat k = mod(t,27.0);\n\tfloat l = mod(t,28.0);\n\tfloat m = mod(t,29.0);\n\tfloat n = mod(t,", "\n    if(p.y > 0.0){\n        return abs(p.x) + abs(p.y);\n    }\n    \n    // Flat bottom and pointed bottom hexagons.\n    else{\n        return abs(p.x) + abs(p.y);\n    }\n}\n\n// Circular bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat", "\n    return (sin(ix*iy*12453+136*pow(ix+15, iy%16)+sin(iy*1600)*1376+ix*656+iy*75)%1000)/1000;\n}\n\n// yea i basically spammed random stuff\nfloat", "\n    // by theta and phi to get the surface\n    float theta = atan(p.y, p.x);\n    float phi = asin(p.z);\n    float r = length(p);\n    float t = theta / 3.1415926535897932384626433832795;\n    float s = phi / 3.1415926535897932384626433832795;\n    // compute the color\n    return vec3(0.5 + 0.5 * cos(t + s), 0.5 + 0.5 * sin(t + s), 0.5 + 0.5 * cos(t - s));\n}\n\n// compute the color of a ray\nvec", "\n    p = p * 0.001;\n    // scale to 0-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0;\n    // scale to -1-1\n    p = p * 2.0 - 1.0", "\n    return vec2(atan(z.y,z.x),length(z));\n}\n\nvec", "\n    return vec2(z.x*w.x - z.y*w.y, z.x*w.y + z.y*w.x);\n}\n\nvec", "\n\t vec3 s = floor(p);\n\t vec3 x = p - s;\n\t \n\t /* calculate i1, i2, 1.0 - the integer coordinates of the four corners of T */\n\t vec3 i1 = step(vec3(0.0), x - vec3(0.0, 0.0, 1.0));\n\t vec3 i2 = step(vec3(1.0), x - vec3(1.0, 0.0, 1.0));\n\t vec3 i3 = step(vec3(1.0), x - vec3(1.0, 1.0, 1.0));\n\t vec3 i4 = step(vec3(0.0), x - vec3(0.0, 1.0, 1.0));\n\t \n\t /* calculate the contribution from the four corners */\n\t vec3 x1 = x - i1 + (i2 - i1) * vec3(0.0, 0.0, 1.0);\n\t vec3 x2 = x - i2 + (i3 - i2) * vec3(0.0, 0.0, 1.0);\n\t vec3 x3 = x - i3 + (i4 - i3) * vec3(0.0, 0.0, 1.0);\n\t vec3 x4 = x - i4 + (i1 - i4) * vec3(0.0, 0.0, 1.0);\n\t \n\t /* calculate the contribution from the four vertices */\n\t vec3 y0 = x - vec3(0.0, 0.0, 0.0);\n\t vec3 y1 = x - vec3(1.0, 0.0, 0.0);\n\t vec3 y2 = x - vec3(1.0, 1.0, 0.0);\n\t vec3 y3 = x - vec3(0.0, 1.0, 0.0);\n\t vec3 y4 = x - vec3(0.0, 0.", " of the rings\n    float ring = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet2 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet3 = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet4 = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet5 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet6 = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet7 = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet8 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet9 = sin( p.x * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet10 = sin( p.y * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet11 = sin( p.z * 10.0 ) * 0.5 + 0.5;\n    // drop one of the droplets\n    float droplet12 = sin( p.x * 10.0 ) * 0.5 + 0.5;", " in the final image\n    p.xz *= 0.5;\n    p.y -= 0.001;\n\n    // add some noise to the space\n    p.xz += noise( p.xy );\n    p.y += noise( p.xz );\n\n    // add some more noise to the space\n    p.xz += noise( p.yx );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.zy );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.zy );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add some more noise to the space\n    p.xz += noise( p.yz );\n    p.y += noise( p.xy );\n\n    // add", "\n    float k = floor(rp.x*.75)*.25;\n    float s = sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.01);\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.005));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.0025));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.001));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.0005));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.00025));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.0001));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.00005));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.000025));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.00001));\n    s = min(s, sdCylinder(rp, vec3(0,0,0), vec3(0,0,1), 0.000005));\n    s = min(s, sd", "\n\tfloat t = clamp((end - d) / (end - start), 0.0, 1.0);\n\treturn mix(start, end, t);\n}\n\n// ref: https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\nfloat", "\n    vec4 hexagonCenter = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // The hexagon ID is the unique hexagon point.\n    int hexagonID = int(p.x) + int(p.y);\n    \n    // The hexagon center is the hexagon point closest to the current point.\n    if (abs(p.x - floor(p.x)) < abs(p.y - floor(p.y)))\n    {\n        hexagonCenter = vec4(p.x, 0.0, 0.0, hexagonID);\n    }\n    else\n    {\n        hexagonCenter = vec4(0.0, p.y, 0.0, hexagonID);\n    }\n    \n    // The hexagon center is the hexagon point closest to the current point.\n    return hexagonCenter;\n}\n\n//\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec", "\n    vec2 r = vec2(random(p), random(p+vec2(1.0)));\n    \n    // The distance field.\n    vec2 d = vec2(0.0);\n    \n    // The distance field.\n    for(int i=0; i<2; i++){\n        for(int j=0; j<2; j++){\n            d += abs(r[j]-0.5);\n        }\n        r = rotate(r);\n    }\n    \n    // The distance field.\n    return d;\n}\n\n// The distance field.\nvec", "\n    float scale = (mouse.x - 0.5) / 0.5;\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    if (scale > 0.0 && scale < 1.0) {\n        color = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color2 = vec3(0.0, 0.0, 0.0);\n    if (scale > 1.0 && scale < 2.0) {\n        color2 = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color3 = vec3(0.0, 0.0, 0.0);\n    if (scale > 2.0 && scale < 3.0) {\n        color3 = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (full left) to 1.0 (full right)\n    // Mouse coordinate is set when left-mouse-button is clicked.\n    vec3 color4 = vec3(0.0, 0.0, 0.0);\n    if (scale > 3.0 && scale < 4.0) {\n        color4 = vec3(1.0, 1.0, 1.0);\n    }\n\n    // Set color according to how far mouse is from left side. 0.0 (", " from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the spiral.\n    //\n    //Solve for theta, given the distance of the polar coordinate\n    //(r = a+b*theta) from the center of the", "\n    return smoothstep(pct-EPSILON, pct, st.y) - smoothstep(pct, pct+EPSILON, st.y);\n}\n\n// Plot a line on X using a value between 0.0-1.0\nfloat", "\n    //\n    // I'm not going to go into the details of the hyperbolic geometry here,\n    // but I'll say that the hyperbolic geometry is a bit more involved than\n    // the Euclidean geometry, so I'll leave that to you.\n\n    // The following is the number of polygon sides (N) and the number of adjacent\n    // polygons (Q) that meet at a vertex point.\n    int N = int(gl_FragCoord.x);\n    int Q = int(gl_FragCoord.y);\n\n    // The following is the radius of the initial circle.\n    float r = float(N);\n\n    // The following is the distance from the center of the initial circle to the\n    // center of the circle that runs adjacent to the current domain edges.\n    float d = float(Q);\n\n    // The following is the angle of the initial circle.\n    float a = float(Q);\n\n    // The following is the angle of the initial circle.\n    float b = float(Q);\n\n    // The following is the angle of the initial circle.\n    float c = float(Q);\n\n    // The following is the angle of the initial circle.\n    float d = float(Q);\n\n    // The following is the angle of the initial circle.\n    float e = float(Q);\n\n    // The following is the angle of the initial circle.\n    float f = float(Q);\n\n    // The following is the angle of the initial circle.\n    float g = float(Q);\n\n    // The following is the angle of the initial circle.\n    float h = float(Q);\n\n    // The following is the angle of the initial circle.\n    float i = float(Q);\n\n    // The following is the angle of the initial circle.\n    float j = float(Q);\n\n    // The following is the angle of the initial circle.\n    float k = float(Q);\n\n    // The following is the angle of the initial circle.\n    float l = float(Q);\n\n    // The following is the angle of the initial circle.\n    float m = float(Q);\n\n    // The following is the angle of the initial circle.\n    float n = float(", "\n    float ia =.5/float(N);\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float c = mod(a + ia, 2.0*pi);\n    float s = sign(c - a);\n    float r2 = sqrt(r);\n    float c2 = mod(c + ia, 2.0*pi);\n    float s2 = sign(c2 - c);\n    float r3 = sqrt(r2);\n    float c3 = mod(c2 + ia, 2.0*pi);\n    float s3 = sign(c3 - c2);\n    float r4 = sqrt(r3);\n    float c4 = mod(c3 + ia, 2.0*pi);\n    float s4 = sign(c4 - c3);\n    float r5 = sqrt(r4);\n    float c5 = mod(c4 + ia, 2.0*pi);\n    float s5 = sign(c5 - c4);\n    float r6 = sqrt(r5);\n    float c6 = mod(c5 + ia, 2.0*pi);\n    float s6 = sign(c6 - c5);\n    float r7 = sqrt(r6);\n    float c7 = mod(c6 + ia, 2.0*pi);\n    float s7 = sign(c7 - c6);\n    float r8 = sqrt(r7);\n    float c8 = mod(c7 + ia, 2.0*pi);\n    float s8 = sign(c8 - c7);\n    float r9 = sqrt(r8);\n    float c9 = mod(c8 + ia, 2.0*pi);\n    float s9 = sign(c9 - c8);\n    float r10 = sqrt(r9);\n    float c10 = mod(c9 + ia, 2.0*pi);\n    float s10 = sign(c10 - c9);\n    float r11 = sqrt(r10);\n    float c11", "\n    vec2 m = vec2(mouseX, mouseY);\n    \n    // Mouse position inverted.\n    vec2 mInv = vec2(1.0 - m.x, 1.0 - m.y);\n    \n    // Mouse position inverted.\n    return mInv - p;\n}\n\n// Mouse pointer inversion.\nvec", "\n\tvec3 lightPos = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos2 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos3 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos4 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos5 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos6 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos7 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos8 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos9 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos10 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos11 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos12 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos13 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos14 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos15 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos16 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos17 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos18 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos19 = vec3(0.0, 0.0, 0.0);\n\tvec3 lightPos20 =", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tp.x *= iResolution.x / iResolution.y;\n\t\n\t// Camera\n\tvec3 ro = vec3( 0.0, 0.0, 1.0 );\n\tvec3 ta = vec3( 0.0, 0.0, 0.0 );\n\tvec3 ww = normalize( ta - ro );\n\tvec3 uu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvec3 vv = normalize( cross(uu,ww));\n\t\n\t// Camera Movement\n\tfloat speed = 0.01;\n\tfloat rotSpeed = 0.002;\n\tfloat zoomSpeed = 0.0001;\n\tfloat zoom = 1.0;\n\t\n\t// Camera Rotation\n\tfloat rotX = iTime * rotSpeed;\n\tfloat rotY = iTime * rotSpeed;\n\t\n\t// Camera Zoom\n\tfloat zoomAmount = iMouse.z * zoomSpeed;\n\t\n\t// Camera Movement\n\tfloat moveSpeed = speed * zoom;\n\t\n\t// Camera Movement\n\tro += moveSpeed * ( p.x*uu + p.y*vv );\n\t\n\t// Camera Rotation\n\trotY += p.x * rotSpeed;\n\trotX += p.y * rotSpeed;\n\t\n\t// Camera Rotation\n\tvec3 vp = vec3( sin(rotY)*cos(rotX), cos(rotY), sin(rotY)*sin(rotX) );\n\tww = normalize( ta - ro );\n\tuu = normalize( cross(ww,vec3(0.0,1.0,0.0) ) );\n\tvv = normalize( cross(uu,ww));\n\t\n\t// Light\n\tvec3 light = vec3( 0.0, 0.0, 1.0 );\n\t\n\t// Light\n\tvec3 col = vec3( 0.0 );\n\t\n\t// Light\n\tvec3 n = normalize( vec3", "\n\n    // Get the position of the pixel in the image.\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // Get the position of the pixel in the polar coordinate system.\n    vec2 q = vec2(\n        atan(p.y - 0.5, p.x - 0.5) / 3.1415926535897932384626433832795,\n        length(p - 0.5)\n    );\n\n    // Get the position of the pixel in the HSB colour space.\n    vec3 hsb = vec3(\n        mod(q.x + 0.5, 1.0),\n        clamp(q.y, 0.0, 1.0),\n        mod(q.x + 0.5, 1.0)\n    );\n\n    // Get the position of the pixel in the RGB colour space.\n    vec3 rgb = hsv2rgb(hsb);\n\n    // Get the position of the pixel in the HSB colour space.\n    vec3 hsb2 = vec3(\n        mod(q.x + 0.5, 1.0),\n        clamp(q.y, 0.0, 1.0),\n        mod(q.x + 0.5, 1.0)\n    );\n\n    // Get the position of the pixel in the RGB colour space.\n    vec3 rgb2 = hsv2rgb(hsb2);\n\n    // Get the position of the pixel in the HSB colour space.\n    vec3 hsb3 = vec3(\n        mod(q.x + 0.5, 1.0),\n        clamp(q.y, 0.0, 1.0),\n        mod(q.x + 0.5, 1.0)\n    );\n\n    // Get the position of the pixel in the RGB colour space.\n    vec3 rgb3 = hsv2rgb(hsb3);\n\n    // Get the position of the pixel in the HSB colour space.\n   ", " axis\n    vec3 v = vec3(\n        hash * 2.0 - 1.0,\n        hash * 2.0 - 1.0,\n        hash * 2.0 - 1.0\n    );\n    \n    // Gradient set is a normalized expanded rhombic dodecahedron\n    return normalize(v);\n}\n\n// Hash function\nfloat", "\n    vec3 Y = normalize(cross(X.xy, X.zx));\n    vec3 Z = normalize(cross(Y, X));\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(Y, Z, X);\n    Y = Y * mat3(Y, Z, X);\n    \n    // Rotate the Z vector to the plane.\n    Z = Z * mat3(Y, Z, X);\n    \n    // Rotate the X and Y vectors to the plane.\n    X = X * mat3(", "\n  float d = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d2 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d3 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d4 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d5 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d6 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d7 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d8 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d9 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d10 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d11 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d12 = length(p.xy) - 1.0;\n  // distance from the point `p` to the center of the XZ plane\n  float d13 = length(p.xz) - 1.0;\n  // distance from the point `p` to the center of the Y plane\n  float d14 = p.y + 1.0;\n  // distance from the point `p` to the center of the XY plane\n  float d15 = length(p.xy) - 1.0;\n  // distance from", "\n    float t = dot( targetPos - ray.ro, ray.rd ) / dot( ray.rd, ray.rd );\n    return ray.ro + t * ray.rd;\n}\n\n// \uc810\uc5d0\uc11c \ubc18\uc0ac\ub418\ub294 \uc0c9\uc0c1\uc744 \uad6c\ud55c\ub2e4.\nvec", "\n\tmat2 rot = mat2(cos(iGlobalTime), -sin(iGlobalTime), sin(iGlobalTime), cos(iGlobalTime));\n\n\t// Get the pixel coordinates\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\n\t// Get the pixel color\n\tvec3 color = vec3(0.0);\n\tcolor += texture(iChannel0, uv).rgb;\n\tcolor += texture(iChannel1, uv).rgb;\n\tcolor += texture(iChannel2, uv).rgb;\n\tcolor += texture(iChannel3, uv).rgb;\n\tcolor += texture(iChannel4, uv).rgb;\n\tcolor += texture(iChannel5, uv).rgb;\n\tcolor += texture(iChannel6, uv).rgb;\n\tcolor += texture(iChannel7, uv).rgb;\n\tcolor += texture(iChannel8, uv).rgb;\n\tcolor += texture(iChannel9, uv).rgb;\n\tcolor += texture(iChannel10, uv).rgb;\n\tcolor += texture(iChannel11, uv).rgb;\n\tcolor += texture(iChannel12, uv).rgb;\n\tcolor += texture(iChannel13, uv).rgb;\n\tcolor += texture(iChannel14, uv).rgb;\n\tcolor += texture(iChannel15, uv).rgb;\n\tcolor += texture(iChannel16, uv).rgb;\n\tcolor += texture(iChannel17, uv).rgb;\n\tcolor += texture(iChannel18, uv).rgb;\n\tcolor += texture(iChannel19, uv).rgb;\n\tcolor += texture(iChannel20, uv).rgb;\n\tcolor += texture(iChannel21, uv).rgb;\n\tcolor += texture(iChannel22, uv).rgb;\n\tcolor += texture(iChannel23, uv).rgb;\n\tcolor += texture(iChannel24, uv).rgb;\n\tcolor += texture(iChannel25, uv).rgb", "-Normal-TexCoord\n    vec4 pos = vec4(p, 1.0);\n    pos.xyz += vec3(0.0, 0.0, 0.0);\n    pos.w = 1.0;\n    return pos;\n}\n\n//---Essential Fragment Function\nvec", "\n    vec3 lightPos = vec3( 0.0f, 0.0f, 0.0f );\n    vec3 lightDir = normalize( lightPos - targetPos );\n    vec3 viewDir = normalize( ray.origin - targetPos );\n    vec3 halfDir = normalize( lightDir + viewDir );\n    \n    float NdotL = max( 0.0f, dot( lightDir, halfDir ) );\n    float NdotV = max( 0.0f, dot( lightDir, viewDir ) );\n    float NdotH = max( 0.0f, dot( lightDir, lightDir ) );\n    \n    float NdotH2 = NdotH * NdotH;\n    float NdotH4 = NdotH2 * NdotH2;\n    float NdotH6 = NdotH4 * NdotH2;\n    float NdotH8 = NdotH6 * NdotH2;\n    \n    float NdotV2 = NdotV * NdotV;\n    float NdotV4 = NdotV2 * NdotV2;\n    float NdotV6 = NdotV4 * NdotV2;\n    float NdotV8 = NdotV6 * NdotV2;\n    \n    float NdotL2 = NdotL * NdotL;\n    float NdotL4 = NdotL2 * NdotL2;\n    float NdotL6 = NdotL4 * NdotL2;\n    float NdotL8 = NdotL6 * NdotL2;\n    \n    float NdotH2_4 = NdotH2 * NdotH4;\n    float NdotH2_6 = NdotH2_4 * NdotH6;\n    float NdotH2_8 = NdotH2_6 * NdotH8;\n    \n    float NdotV2_4 = NdotV2 * NdotV4;\n    float NdotV2_6 = NdotV2_4 * NdotV6;\n    float NdotV2_8 = NdotV2_6 * NdotV8;\n    \n    float NdotL", "\n    // p.y -= 1.;\n    // p.z -= 1.;\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / 2.);\n    // p.xz*=Rot(PI / 2.);\n    // p.zy*=Rot(PI / ", "\n    float n0 = 0.0; // noise accumulator\n    float n1 = 0.0;\n    float n2 = 0.0;\n    float n3 = 0.0;\n    float n4 = 0.0;\n    float n5 = 0.0;\n    float n6 = 0.0;\n    float n7 = 0.0;\n    float n8 = 0.0;\n    float n9 = 0.0;\n    float n10 = 0.0;\n    float n11 = 0.0;\n    float n12 = 0.0;\n    float n13 = 0.0;\n    float n14 = 0.0;\n    float n15 = 0.0;\n    float n16 = 0.0;\n    float n17 = 0.0;\n    float n18 = 0.0;\n    float n19 = 0.0;\n    float n20 = 0.0;\n    float n21 = 0.0;\n    float n22 = 0.0;\n    float n23 = 0.0;\n    float n24 = 0.0;\n    float n25 = 0.0;\n    float n26 = 0.0;\n    float n27 = 0.0;\n    float n28 = 0.0;\n    float n29 = 0.0;\n    float n30 = 0.0;\n    float n31 = 0.0;\n    float n32 = 0.0;\n    float n33 = 0.0;\n    float n34 = 0.0;\n    float n35 = 0.0;\n    float n36 = 0.0;\n    float n37 = 0.0;\n    float n38 = 0.0;\n    float n39 = 0.0;\n    float n40 = 0.0;\n    float n41 = 0.0;\n    float n42 = 0.0;\n    float n43 = 0.0;\n    float n44 = 0.0;\n    float n45 = 0.0;\n    float n46 = 0.0;\n", "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n    \n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    \n    return (v >= 0.0f && v <= 1.0f && w >= 0.0f && w <= 1.0f);\n}\n\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nvec", "\n    float n = log(start_radius)/log(1.5);\n    \n    //Find the closest hexagon to the point\n    int closest_hex = (int)n;\n    for(int i=0; i<closest_hex; i++){\n        n = log(start_radius)/log(1.5);\n        closest_hex = (int)n;\n    }\n    \n    return closest_hex;\n}\n\n//Find the closest hexagon a point would be near\nint", ".\n    //n-2 of next hexagon, and n-1 of cur hexagon.\n    //n-3 of next hexagon, and n of cur hexagon.\n    //n-4 of next hexagon, and n-1 of next hexagon.\n    //n-5 of next hexagon, and n-2 of next hexagon.\n    //n-6 of next hexagon, and n-3 of next hexagon.\n    //n-7 of next hexagon, and n-4 of next hexagon.\n    //n-8 of next hexagon, and n-5 of next hexagon.\n    //n-9 of next hexagon, and n-6 of next hexagon.\n    //n-10 of next hexagon, and n-7 of next hexagon.\n    //n-11 of next hexagon, and n-8 of next hexagon.\n    //n-12 of next hexagon, and n-9 of next hexagon.\n    //n-13 of next hexagon, and n-10 of next hexagon.\n    //n-14 of next hexagon, and n-11 of next hexagon.\n    //n-15 of next hexagon, and n-12 of next hexagon.\n    //n-16 of next hexagon, and n-13 of next hexagon.\n    //n-17 of next hexagon, and n-14 of next hexagon.\n    //n-18 of next hexagon, and n-15 of next hexagon.\n    //n-19 of next hexagon, and n-16 of next hexagon.\n    //n-20 of next hexagon, and n-17 of next hexagon.\n    //n-21 of next hexagon, and n-18 of next hexagon.\n    //n-22 of next hexagon, and n-19 of next hexagon.\n    //n-23 of next hexagon, and n-20 of next hexagon.\n    //n-24 of next hexagon, and n-21 of next hexagon.\n    //n-25 of next hexagon, and n-22 of next hexagon.\n    //n", ".\n    //n+2 of cur hexagon, n+3 of cur hexagon, and n+4 of cur hexagon.\n    //n+5 of cur hexagon, n+6 of cur hexagon, and n+7 of cur hexagon.\n    //n+8 of cur hexagon, n+9 of cur hexagon, and n+10 of cur hexagon.\n    //n+11 of cur hexagon, n+12 of cur hexagon, and n+13 of cur hexagon.\n    //n+14 of cur hexagon, n+15 of cur hexagon, and n+16 of cur hexagon.\n    //n+17 of cur hexagon, n+18 of cur hexagon, and n+19 of cur hexagon.\n    //n+20 of cur hexagon, n+21 of cur hexagon, and n+22 of cur hexagon.\n    //n+23 of cur hexagon, n+24 of cur hexagon, and n+25 of cur hexagon.\n    //n+26 of cur hexagon, n+27 of cur hexagon, and n+28 of cur hexagon.\n    //n+29 of cur hexagon, n+30 of cur hexagon, and n+31 of cur hexagon.\n    //n+32 of cur hexagon, n+33 of cur hexagon, and n+34 of cur hexagon.\n    //n+35 of cur hexagon, n+36 of cur hexagon, and n+37 of cur hexagon.\n    //n+38 of cur hexagon, n+39 of cur hexagon, and n+40 of cur hexagon.\n    //n+41 of cur hexagon, n+42 of cur hexagon, and n+43 of cur hexagon.\n    //n+44 of cur hexagon, n+45 of cur hexagon, and n+46 of cur hexagon.\n    //n+47 of cur hexagon, n+48 of cur hexagon, and n+49 of cur hexagon.\n    //n+50 of cur hexagon, n+51 of cur hexagon, and n", "\n    float p = exp(-d);\n    float sum = 0.0;\n    for (int i = 0; i < 1000; i++) {\n        float x = InverseTransformSampling(U);\n        sum += x;\n    }\n    return sum / 1000.0;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat", "'s implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash2(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash3(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash4(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash5(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);\n    n += (n << 3);\n    n ^= (n >> 4);\n    n *= 0x27d4eb2d;\n    n ^= (n >> 15);\n    return n;\n}\n\nuint hash6(uint n)\n{\n    // integer hash copied from Hugo Elias's implementation\n    n = (n ^ 61) ^ (n >> 16);", "\n    vec2 center = vec2(0.5);\n    // distance from center\n    vec2 dist = fragCoord - center;\n    // distance from center squared\n    float distSq = dot(dist, dist);\n    // distance from center cubed\n    float distCubed = dot(dist, distSq);\n    // distance from center cubed squared\n    float distCubedSq = dot(dist, distCubed);\n    // distance from center cubed cubed\n    float distCubedCubed = dot(dist, distCubedSq);\n    // distance from center cubed cubed squared\n    float distCubedCubedSq = dot(dist, distCubedCubed);\n    // distance from center cubed cubed cubed\n    float distCubedCubedCubed = dot(dist, distCubedCubedSq);\n    // distance from center cubed cubed cubed squared\n    float distCubedCubedCubedSq = dot(dist, distCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed\n    float distCubedCubedCubedCubed = dot(dist, distCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed\n    float distCubedCubedCubedCubedCubed = dot(dist, distCubedCubedCubedCubedSq);\n    // distance from center cubed cubed cubed cubed cubed squared\n    float distCubedCubedCubedCubedCubedSq = dot(dist, distCubedCubedCubedCubedCubed);\n    // distance from center cubed cubed cubed cubed cubed cubed\n    float distCubedCubedCubedC", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n  const float epsilon = 0.0001;\n\n  // compute normal vector\n  vec3 normal = vec3(0.0);\n  normal.x = calcHeight(pos + vec3(epsilon, 0.0, 0.0)) - calcHeight(pos - vec3(epsilon, 0.0, 0.0));\n  normal.y = calcHeight(pos + vec3(0.0, epsilon, 0.0)) - calcHeight(pos - vec3(0.0, epsilon, 0.0));\n  normal.z = calcHeight(pos + vec3(0.0, 0.0, epsilon)) - calcHeight(pos - vec3(0.0, 0.0, epsilon));\n  return normalize(normal);\n}\n\n// Compute height of surface at pos\nfloat", "\n  vec3 p = castRay(ro, rd);\n  // get color of nearest object\n  vec3 col = getColor(p);\n  // get normal of nearest object\n  vec3 n = getNormal(p);\n  // get specular value of nearest object\n  float s = getSpecular(p);\n  // get diffuse value of nearest object\n  float d = getDiffuse(p);\n  // get ambient value of nearest object\n  float a = getAmbient(p);\n  // get reflection value of nearest object\n  float r = getReflection(p);\n  // get refraction value of nearest object\n  float t = getRefraction(p);\n  // get refractive index of nearest object\n  float i = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get refractive index of nearest object\n  float nt = getRefractiveIndex(p);\n  // get", "\n    const float epsilon = 0.0001;\n    vec3 normal = vec3(0.0);\n    normal.x = calcHeight(pos + vec3(epsilon, 0.0, 0.0)) - calcHeight(pos - vec3(epsilon, 0.0, 0.0));\n    normal.y = calcHeight(pos + vec3(0.0, epsilon, 0.0)) - calcHeight(pos - vec3(0.0, epsilon, 0.0));\n    normal.z = calcHeight(pos + vec3(0.0, 0.0, epsilon)) - calcHeight(pos - vec3(0.0, 0.0, epsilon));\n    return normalize(normal);\n}\n\n// Compute height of surface at pos\nfloat", "\n    vec3 p = castRay(ro, rd);\n    // get color of nearest object\n    vec3 col = getColor(p);\n    // get normal of nearest object\n    vec3 n = getNormal(p);\n    // get specular value of nearest object\n    float s = getSpecular(p);\n    // get diffuse value of nearest object\n    float d = getDiffuse(p);\n    // get ambient value of nearest object\n    float a = getAmbient(p);\n    // get reflection value of nearest object\n    vec3 r = getReflection(p, rd);\n    // get refraction value of nearest object\n    vec3 t = getRefraction(p, rd);\n    // get refractive index of nearest object\n    float i = getRefractiveIndex(p);\n    // get refractive index of nearest object\n    float rf = getRefractiveFactor(p);\n    // get refractive index of nearest object\n    float rt = getRefractiveTransmittance(p);\n    // get refractive index of nearest object\n    float rt2 = getRefractiveTransmittance2(p);\n    // get refractive index of nearest object\n    float rt3 = getRefractiveTransmittance3(p);\n    // get refractive index of nearest object\n    float rt4 = getRefractiveTransmittance4(p);\n    // get refractive index of nearest object\n    float rt5 = getRefractiveTransmittance5(p);\n    // get refractive index of nearest object\n    float rt6 = getRefractiveTransmittance6(p);\n    // get refractive index of nearest object\n    float rt7 = getRefractiveTransmittance7(p);\n    // get refractive index of nearest object\n    float rt8 = getRefractiveTransmittance8(p);\n    // get refractive index of nearest object\n    float rt9 = getRefractiveTransmittance9(p);\n    // get refractive index of nearest object\n    float rt10 = getRefractiveTransmittance10(p);\n    //", "\n    vec3 color = texture(texture_diffuse1, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color2 = texture(texture_diffuse2, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color3 = texture(texture_diffuse3, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color4 = texture(texture_diffuse4, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color5 = texture(texture_diffuse5, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color6 = texture(texture_diffuse6, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color7 = texture(texture_diffuse7, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color8 = texture(texture_diffuse8, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color9 = texture(texture_diffuse9, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color10 = texture(texture_diffuse10, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color11 = texture(texture_diffuse11, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color12 = texture(texture_diffuse12, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color13 = texture(texture_diffuse13, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color14 = texture(texture_diffuse14, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color15 = texture(texture_diffuse15, p.xy).rgb;\n    //surface color for bump mapping\n    vec3 color", "\n    // This is a simple hash function for 2D integer coordinates.\n    // It is not optimized for speed, but it is good enough for our purposes.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it is fast.\n    // The hash is not very good, but it", "el\n\tvec2 texel = vec2( 1.0 / 16.0 );\n\tvec2 coord1 = coord;\n\tvec2 coord2 = coord + texel;\n\tvec2 coord3 = coord + texel * 2.0;\n\tvec2 coord4 = coord + texel * 3.0;\n\tvec2 coord5 = coord + texel * 4.0;\n\tvec2 coord6 = coord + texel * 5.0;\n\tvec2 coord7 = coord + texel * 6.0;\n\tvec2 coord8 = coord + texel * 7.0;\n\tvec2 coord9 = coord + texel * 8.0;\n\tvec2 coord10 = coord + texel * 9.0;\n\tvec2 coord11 = coord + texel * 10.0;\n\tvec2 coord12 = coord + texel * 11.0;\n\tvec2 coord13 = coord + texel * 12.0;\n\tvec2 coord14 = coord + texel * 13.0;\n\tvec2 coord15 = coord + texel * 14.0;\n\tvec2 coord16 = coord + texel * 15.0;\n\n\tvec3 color1 = texture( texture1, coord1 ).rgb;\n\tvec3 color2 = texture( texture1, coord2 ).rgb;\n\tvec3 color3 = texture( texture1, coord3 ).rgb;\n\tvec3 color4 = texture( texture1, coord4 ).rgb;\n\tvec3 color5 = texture( texture1, coord5 ).rgb;\n\tvec3 color6 = texture( texture1, coord6 ).rgb;\n\tvec3 color7 = texture( texture1, coord7 ).rgb;\n\tvec3 color8 = texture( texture1, coord8 ).rgb;\n\tvec3 color9 = texture( texture1, coord9 ).rgb;\n\tvec3 color10 = texture( texture1, coord10 ).rgb;\n\tvec3 color11 = texture( texture1, coord11 ).rg", "\n    p.x = abs(p.x);\n\n    // rotate\n    float c = cos(p.y);\n    float s = sin(p.y);\n    mat2 m = mat2(c, -s, s, c);\n    p = m * p;\n\n    // scale\n    p.x *= ab.x;\n    p.y *= ab.y;\n\n    // translate\n    p.x += ab.x * 0.5;\n    p.y += ab.y * 0.5;\n\n    return p;\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    p = fract(p * 0.1031);\n    p *= 33.33;\n    p += fract(p * 2.02);\n    return fract(vec3(p, p + 2.33, p + 3.23));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n    vec3 color = vec3(0.0);\n\n    // Get the position of the pixel\n    vec2 pixel = fragCoord.xy / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy;\n\n    // Get the position of the pixel in the 3D space\n    vec3 pos = vec3(pixel, 0.0);\n\n    // Get the position of the pixel in the 2D space\n    vec2 uv = pixel / iResolution.xy", "\n    float t = 0.0;\n    float tmin = 1000000.0;\n    float tmax = 0.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n    float t40 = 0.0;\n    float t41 = 0.0;\n    float t42 = 0.0;\n    float t43 = 0.0;\n    float", "\n    float s = sin(rotation.x);\n    float c = cos(rotation.x);\n    float t = sin(rotation.y);\n    float ct = cos(rotation.y);\n    float n = sin(rotation.z);\n    float cn = cos(rotation.z);\n\n    // Create the Rotation Matrix\n    return mat3(\n        vec3(cn*ct, cn*s, -sn),\n        vec3(cn*t, cn*ct*t - s, cn*sn),\n        vec3(sn*ct, sn*s, cn*ct*t + s)\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat", "\n    vec4 raypos = vec4(0.0, 0.0, 0.0, 1.0);\n\n    // Ray-Marching\n    float t = 0.0;\n    float tmax = 1000.0;\n    float tmin = 0.0;\n    float tmin_tmax = 0.0;\n    float tmin_tmax_t = 0.0;\n    float tmin_tmax_t_t = 0.0;\n    float tmin_tmax_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t_t_t = 0.0;\n    float tmin_tmax_t_t_t_t_t_t_t_t_t_t_t_t_t_t", "\n    vec3 rayDir = normalize(vec3(uv.x, uv.y, 1.0));\n    // Calculate the Origin of the Ray\n    vec3 rayOrigin = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n    // Calculate the Ray's Length\n    float rayLength4D = 100.0;\n    // Calculate the Ray's Origin\n    vec3 rayOrigin4D = vec3(0.0, 0.0, 0.0);\n", "\n    vec3 raypos = vec3(0.0, 0.0, 0.0);\n    // Set the Ray Origin\n    raypos = rayori;\n    // Set the Ray Direction\n    raydir = normalize(raydir);\n    // Set the Ray Length\n    float raylen = 100.0;\n    // Set the Ray Step Size\n    float raystep = 0.01;\n    // Set the Ray Step Count\n    float raystepcount = 0.0;\n    // Set the Ray Color\n    vec3 raycolor = vec3(0.0, 0.0, 0.0);\n    // Set the Ray Distance\n    float raydist = 0.0;\n    // Set the Ray Distance Threshold\n    float raydistthresh = 0.001;\n    // Set the Ray Distance Threshold\n    float raydistthresh2 = 0.0001;\n    // Set the Ray Distance Threshold\n    float raydistthresh3 = 0.00001;\n    // Set the Ray Distance Threshold\n    float raydistthresh4 = 0.000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh5 = 0.0000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh6 = 0.00000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh7 = 0.000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh8 = 0.0000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh9 = 0.00000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh10 = 0.000000000001;\n    // Set the Ray Distance Threshold\n    float raydistthresh11 = 0.0000000000001;\n    // Set the Ray Distance Threshold\n", "\n    float seed = iTime;\n    float rng = rand(seed);\n\n    // Initialize the image\n    vec3 color = vec3(0.0);\n\n    // Calculate the position of the pixel\n    vec2 pos = fragCoord.xy / iResolution.xy;\n\n    // Calculate the position of the pixel in the 3D space\n    vec3 p = vec3(pos.xy, rng);\n\n    // Calculate the ray direction\n    vec3 ray = normalize(vec3(pos.xy, 1.0));\n\n    // Calculate the ray origin\n    vec3 origin = vec3(0.0);\n\n    // Calculate the ray length\n    float length = 100.0;\n\n    // Calculate the ray color\n    vec3 rayColor = vec3(0.0);\n\n    // Calculate the ray step\n    float step = 0.001;\n\n    // Calculate the ray step\n    float step2 = 0.0001;\n\n    // Calculate the ray step\n    float step3 = 0.00001;\n\n    // Calculate the ray step\n    float step4 = 0.000001;\n\n    // Calculate the ray step\n    float step5 = 0.0000001;\n\n    // Calculate the ray step\n    float step6 = 0.00000001;\n\n    // Calculate the ray step\n    float step7 = 0.000000001;\n\n    // Calculate the ray step\n    float step8 = 0.0000000001;\n\n    // Calculate the ray step\n    float step9 = 0.00000000001;\n\n    // Calculate the ray step\n    float step10 = 0.000000000001;\n\n    // Calculate the ray step\n    float step11 = 0.0000000000001;\n\n    // Calculate the ray step\n    float step12 = 0.", "\n    float fade = fadeOut(coord, frequency, travelRate);\n\n    // Get the ray's direction\n    vec2 rayDir = vec2(travelRate, 0.0);\n\n    // Get the ray's position\n    vec2 rayPos = vec2(coord.x, 0.0);\n\n    // Get the ray's intensity\n    float rayIntensity = rayIntensity(rayPos, rayDir, frequency, travelRate, maxStrength);\n\n    // Return the ray's intensity\n    return rayIntensity * fade;\n}\n\n// rayIntensity: (position, direction, frequency, travel rate, max strength)\n// coord: (texture coordinate: [0-1], [0-1])\n// frequency: rate at which ray appears\n// travel rate: direction the ray travels in the x directions\n// max strength: light intensity of the ray\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n// -----------------------------------------------\n", "\n\tvec2 d2 = d / 2.0;\n\tvec2 p2 = p - d2;\n\tvec2 p3 = p + d2;\n\tvec2 p4 = p + d;\n\tvec2 p5 = p - d;\n\tvec2 p6 = p + d2.yx;\n\tvec2 p7 = p - d2.yx;\n\tvec2 p8 = p + d2.xy;\n\tvec2 p9 = p - d2.xy;\n\tvec2 p10 = p + d.yx;\n\tvec2 p11 = p - d.yx;\n\tvec2 p12 = p + d.xy;\n\tvec2 p13 = p - d.xy;\n\tvec2 p14 = p + d2.yx + d2.xy;\n\tvec2 p15 = p - d2.yx + d2.xy;\n\tvec2 p16 = p + d2.yx - d2.xy;\n\tvec2 p17 = p - d2.yx - d2.xy;\n\tvec2 p18 = p + d2.xy + d2.yx;\n\tvec2 p19 = p - d2.xy + d2.yx;\n\tvec2 p20 = p + d2.xy - d2.yx;\n\tvec2 p21 = p - d2.xy - d2.yx;\n\tvec2 p22 = p + d.yx + d.xy;\n\tvec2 p23 = p - d.yx + d.xy;\n\tvec2 p24 = p + d.yx - d.xy;\n\tvec2 p25 = p - d.yx - d.xy;\n\tvec2 p26 = p + d.xy + d.yx;\n\tvec2 p27 = p - d.xy + d.yx;\n\tvec2 p28 = p + d.xy - d.yx;\n\tvec2 p29 = p - d.xy - d.yx;\n\tvec2 p30 = p + d2.yx +", "\n    return pow(color, vec3(2.2));\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec", "\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    vec2 bp = p-b;\n    float h = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n\n    // head\n    float d = length( ap - ab*h ) - w2;\n\n    // shaft\n    float s = length( ap - ab*h ) - w1;\n\n    return min(d,s);\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    uv = uv - 0.5;\n    uv.x *= TAU;\n    uv.y *= TAU;\n\n    //get the distance from the center\n    float d = length(uv);\n\n    //get the angle from the center\n    float a = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a2 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a3 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a4 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a5 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a6 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a7 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a8 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a9 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a10 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a11 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a12 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a13 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a14 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a15 = atan(uv.y, uv.x);\n\n    //get the angle from the center\n    float a16 = atan(uv.y, uv.x);\n\n    //", "\n    //vec3 colC = vec3(0.0,0.0,0.0);\n    //vec3 colD = vec3(0.0,0.0,0.0);\n    //vec3 colE = vec3(0.0,0.0,0.0);\n    //vec3 colF = vec3(0.0,0.0,0.0);\n    //vec3 colG = vec3(0.0,0.0,0.0);\n    //vec3 colH = vec3(0.0,0.0,0.0);\n    //vec3 colI = vec3(0.0,0.0,0.0);\n    //vec3 colJ = vec3(0.0,0.0,0.0);\n    //vec3 colK = vec3(0.0,0.0,0.0);\n    //vec3 colL = vec3(0.0,0.0,0.0);\n    //vec3 colM = vec3(0.0,0.0,0.0);\n    //vec3 colN = vec3(0.0,0.0,0.0);\n    //vec3 colO = vec3(0.0,0.0,0.0);\n    //vec3 colP = vec3(0.0,0.0,0.0);\n    //vec3 colQ = vec3(0.0,0.0,0.0);\n    //vec3 colR = vec3(0.0,0.0,0.0);\n    //vec3 colS = vec3(0.0,0.0,0.0);\n    //vec3 colT = vec3(0.0,0.0,0.0);\n    //vec3 colU = vec3(0.0,0.0,0.0);\n    //vec3 colV = vec3(0.0,0.0,0.0);\n    //vec3 colW = vec3(0.0,0.0,0.0);\n    //vec3 colX =", "\n    vec2 uv = fragCoord/iResolution.xy; //x-fov\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = (2.0 * uv) - 1.0;\n\n    // Time varying pixel color\n", "\n   p = fract(p * 0.1031);\n   p *= 133.421312421;\n   p += fract(p * 0.0265348192);\n   p = fract(p);\n   p *= 133.421312421;\n   p += fract(p * 0.0265348192);\n   p = fract(p);\n   return fract(vec3(p, p + 1.0, p + 2.0));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (", ", but I don't remember where.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //", "\n    return length(max(abs(p) - 1.0, 0.0));\n}\n\n/* \u4e00\u4e2a\u5706\u7684SDF */\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Get the radius of the circle\n    float radius = iTime * 0.01;\n\n    // Get the distance from the center of the circle\n    float dist = distance(uv, vec2(0.5));\n\n    // Get the brightness of the circle\n    float brightness = (1.0 - dist) / radius;\n\n    // Set the color based on the brightness\n    col = vec3(brightness);\n\n    // Output to screen\n    fragColor = vec4(col, 1.0);\n}\n"], "input_comment-67b": ["\n    return (cos(a*TAU)+1.)/2.;\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) = 1, fsin(2/3) = -1\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat", "\n    float d = p.y + 1.0;\n    float r = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        p = abs(p) - 1.0;\n        p.xy = vec2(p.x + p.y, p.x - p.y) * 0.57735027;\n        p.z -= r;\n        r *= 3.0;\n        d = max(d, length(p) * pow(r, -2.1));\n    }\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nvec", "\n    return length(max(abs(p) - vec3(0.5), 0.0));\n}\n\n// Distance to the scene\nfloat", "\n    vec3 q = p;\n    float d = length(q) - 1.0;\n    P = q;\n    return vec2(d, 0.0);\n}\n\n// Distance to the scene and color of the closest point\nvec", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n    vec4 c1 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 c2 = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 c3 = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 c4 = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 c5 = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 c6 = vec4(1.0, 1.0, 0.0, 1.0);\n    vec4 c7 = vec4(0.0, 1.0, 1.0, 1.0);\n    vec4 c8 = vec4(1.0, 0.0, 1.0, 1.0);\n    vec4 c9 = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 c10 = vec4(0.5, 0.5, 1.0, 1.0);\n    vec4 c11 = vec4(0.5, 1.0, 0.5, 1.0);\n    vec4 c12 = vec4(1.0, 0.5, 0.5, 1.0);\n    vec4 c13 = vec4(0.5, 0.5, 0.0, 1.0);\n    vec4 c14 = vec4(0.5, 0.0, 0.5, 1.0);\n    vec4 c15 = vec4(0.0, 0.5, 0.5, 1.0);\n    vec4 c16 = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 c17 =", "\n    float d2 = d * d;\n    float d3 = d2 * d;\n    float d4 = d2 * d2;\n    float d5 = d4 * d;\n    float d6 = d4 * d2;\n    float d7 = d6 * d;\n    float d8 = d6 * d2;\n    float d9 = d8 * d;\n    float d10 = d8 * d2;\n    float d11 = d10 * d;\n    float d12 = d10 * d2;\n    float d13 = d12 * d;\n    float d14 = d12 * d2;\n    float d15 = d14 * d;\n    float d16 = d14 * d2;\n    float d17 = d16 * d;\n    float d18 = d16 * d2;\n    float d19 = d18 * d;\n    float d20 = d18 * d2;\n    float d21 = d20 * d;\n    float d22 = d20 * d2;\n    float d23 = d22 * d;\n    float d24 = d22 * d2;\n    float d25 = d24 * d;\n    float d26 = d24 * d2;\n    float d27 = d26 * d;\n    float d28 = d26 * d2;\n    float d29 = d28 * d;\n    float d30 = d28 * d2;\n    float d31 = d30 * d;\n    float d32 = d30 * d2;\n    float d33 = d32 * d;\n    float d34 = d32 * d2;\n    float d35 = d34 * d;\n    float d36 = d34 * d2;\n    float d37 = d36 * d;\n    float d38 = d36 * d2;\n    float d39 = d38 * d;\n    float d40 = d38 * d2;\n    float d", "\n    // Softbox\n    float t = RayBox(rayDir, vec3(0.0), vec3(1000.0), 0.0);\n    if (t > 0.0)\n    {\n        vec3 pos = rayDir * t;\n        vec3 normal = GetBoxNormal(pos, vec3(0.0), vec3(1000.0), 0.0);\n        return GetSoftboxColor(pos, normal, sunDir);\n    }\n\n    // Lights\n    vec3 lightColor = vec3(0.0);\n    for (int i = 0; i < 4; i++)\n    {\n        float angle = float(i) * 0.7853981633974483;\n        vec3 lightPos = vec3(cos(angle), 0.0, sin(angle)) * 100.0;\n        float dist = length(lightPos - rayDir * 100.0);\n        float atten = 1.0 / (dist * dist);\n        lightColor += GetLightColor(lightPos, sunDir) * atten;\n    }\n\n    // Fade\n    float fade = rayDir.y * 0.5 + 0.5;\n    return lightColor * fade;\n}\n\n// This is a procedural environment map with a giant overhead softbox,\n// 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec", "\n    return texture(iChannel0, coords).r - iChannelResolution.y;\n}\n\n// F'(x,y) = F'(x)\nfloat", "\n    return texture(iChannel0, coords).r - iChannelResolution.y;\n}\n\n// F'(x,y) = F'(x)\nfloat", "\n    return texture(iChannel0, coords).r - iChannelResolution.y;\n}\n\n// F'(x,y) = F'(x)\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = vec3(uv,0.5+0.5*sin(iTime));\n    fragColor = vec4(col,1.0);\n}", "\n    float f = 0.0;\n    float w = 0.5;\n    float ws = 0.0;\n    for (int i = 0; i < 5; i++) {\n        f += w * noise(p);\n        ws += w;\n        w *= 0.5;\n        p *= 2.0;\n    }\n    return f / ws;\n}\n\n// Standard fBm function with some time dialation to give a parallax \n// kind of effect. In other words, the position and time frequencies \n// are changed at different rates from layer to layer.\n//\nfloat", "\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    vec2 p0 = floor(p);\n    vec2 p1 = p0 + vec2(1.0, 0.0);\n    vec2 p2 = p0 + vec2(0.0, 1.0);\n    vec2 p3 = p0 + vec2(1.0, 1.0);\n\n    float v0 = random(p0);\n    float v1 = random(p1);\n    float v2 = random(p2);\n    float v3 = random(p3);\n\n    vec2 d0 = p - p0;\n    vec2 d1 = p - p1;\n    vec2 d2 = p - p2;\n    vec2 d3 = p - p3;\n\n    float d00 = dot(d0, d0);\n    float d11 = dot(d1, d1);\n    float d22 = dot(d2, d2);\n    float d33 = dot(d3, d3);\n\n    float d01 = dot(d0, d1);\n    float d02 = dot(d0, d2);\n    float d03 = dot(d0, d3);\n    float d12 = dot(d1, d2);\n    float d13 = dot(d1, d3);\n    float d23 = dot(d2, d3);\n\n    float m0 = max(v0, max(v1, v2));\n    float m1 = max(v3, max(v0, v1));\n    float m2 = max(v2, max(v3, v0));\n    float m3 = max(v1, max(v2, v3));\n\n    float f0 = m0 - v0;\n    float f1 = m1 - v1;\n    float f2 = m2 - v2;\n    float f3 = m3 - v3;\n\n    float f01 = f0 + f1;\n    float f02 = f0 + f2;\n    float f03 = f0 + f3;\n    float f12 = f1 + f2", "\n    // Get the integer part of the coordinate and scale it up\n    vec2 i_p = floor(p);\n    p -= i_p;\n\n    // Get the distance to the four closest points\n    vec2 d0 = vec2(distance(p, vec2(0.0, 0.0)));\n    vec2 d1 = vec2(distance(p, vec2(1.0, 0.0)));\n    vec2 d2 = vec2(distance(p, vec2(0.0, 1.0)));\n    vec2 d3 = vec2(distance(p, vec2(1.0, 1.0)));\n\n    // Get the minimum of those four distances\n    float dmin = min(d0, min(d1, min(d2, d3)));\n\n    // Return the square root of the minimum distance\n    return sqrt(dmin);\n}\n\n// The main function\nvoid main()\n{\n    // Get the texture coordinate\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    // Get the Voronoi value\n    float v = Voronoi(uv);\n\n    // Output the Voronoi value\n    gl_FragColor = vec4(v, v, v, 1.0);\n}\n", "\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition", "\n    // ~~~~~~~ sphere\n    // vec3 s = vec3(0.0, 0.0, 0.0);\n    // float r = 1.0;\n    // float d = length(p - s) - r;\n\n    // ~~~~~~~ plane\n    // vec3 pn = vec3(0.0, 1.0, 0.0);\n    // float d = dot(p, pn);\n\n    // ~~~~~~~ box\n    // vec3 b = vec3(0.0, 0.0, 0.0);\n    // vec3 s = vec3(1.0, 1.0, 1.0);\n    // vec3 d = abs(p - b) - s;\n    // float res = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n\n    // ~~~~~~~ torus\n    // vec2 t = vec2(0.5, 0.2);\n    // vec3 c = vec3(0.0, 0.0, 0.0);\n    // vec3 pt = p - c;\n    // float d = length(vec2(length(pt.xz) - t.x, pt.y)) - t.y;\n\n    // ~~~~~~~ torus\n    // vec2 t = vec2(0.5, 0.2);\n    // vec3 c = vec3(0.0, 0.0, 0.0);\n    // vec3 pt = p - c;\n    // float d = length(vec2(length(pt.xz) - t.x, pt.y)) - t.y;\n\n    // ~~~~~~~ torus\n    // vec2 t = vec2(0.5, 0.2);\n    // vec3 c = vec3(0.0, 0.0, 0.0);\n    // vec3 pt = p - c;\n    // float d = length(vec2(length(pt.", "\n\tfloat tmin = 1000.0;\n\tfloat tmax = 2000.0;\n\t\n\tfloat t = tmin;\n\t\n\tfor (int i = 0; i < NUM_OBJECTS; i++)\n\t{\n\t\tfloat d = objects[i].sdf(ro);\n\t\tif (d < t)\n\t\t{\n\t\t\tt = d;\n\t\t\thitID = i;\n\t\t}\n\t}\n\t\n\treturn vec2(t, hitID);\n}\n\n// ~~~~~~~ get normal of the object at the hit point\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// input t --> distance travelled by ray\n// output is normal of the object at the hit point\n//\nvec", "\n    // ~~~~~~~ sphere\n    float sd = sdSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    vec3 sColor = vec3(1.0, 0.0, 0.0);\n\n    // ~~~~~~~ plane\n    float pd = p.y;\n    vec3 pColor = vec3(0.0, 1.0, 0.0);\n\n    // ~~~~~~~ box\n    float bd = sdBox(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    vec3 bColor = vec3(0.0, 0.0, 1.0);\n\n    // ~~~~~~~ union\n    float ud = opUnion(sd, pd);\n    vec3 uColor = vec3(1.0, 1.0, 0.0);\n\n    // ~~~~~~~ intersection\n    float id = opIntersection(sd, pd);\n    vec3 iColor = vec3(1.0, 0.0, 1.0);\n\n    // ~~~~~~~ difference\n    float dd = opDifference(sd, pd);\n    vec3 dColor = vec3(0.0, 1.0, 1.0);\n\n    // ~~~~~~~ blend\n    float blend = smoothstep(0.0, 0.01, ud);\n    vec3 color = mix(sColor, uColor, blend);\n\n    return vec4(color, 1.0);\n}\n\n// ~~~~~~~ ray march\n// input p --> is ray position\n// input rd --> is ray direction\n// outputs distance to the closest object\nfloat", "\n    float tmin = 1000.0;\n    float tmax = 2000.0;\n\n    float t = tmin;\n    float m = -1.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec2 res = map(ro + rd * t);\n        if (res.x < EPSILON)\n        {\n            m = res.y;\n            break;\n        }\n        t += res.x;\n        if (t > tmax)\n        {\n            break;\n        }\n    }\n\n    if (m == -1.0)\n    {\n        return vec4(t, m, itterRatio, 0.0);\n    }\n\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    vec3 mate = vec3(0.0);\n    if (m == 0.0)\n    {\n        mate = vec3(0.8, 0.3, 0.3);\n    }\n    else if (m == 1.0)\n    {\n        mate = vec3(0.3, 0.3, 0.8);\n    }\n    else if (m == 2.0)\n    {\n        mate = vec3(0.8, 0.8, 0.3);\n    }\n    else if (m == 3.0)\n    {\n        mate = vec3(0.3, 0.8, 0.3);\n    }\n    else if (m == 4.0)\n    {\n        mate = vec3(0.8, 0.3, 0.8);\n    }\n    else if (m == 5.0)\n    {\n        mate = vec3(0.3, 0.8, 0.8);\n    }\n    else if (m == 6.0)\n    {\n        mate = vec3(0.8, 0.8, 0.8);\n    }\n\n    float dif = clamp(dot(nor, vec3", "\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    float w = 0.0;\n    float wSum = 0.0;\n    float dSum = 0.0;\n    float dMax = 0.0;\n    float dMin = 1000000.0;\n    float dMinIdx = 0.0;\n    float dMaxIdx = 0.0;\n    float dMinIdx2 = 0.0;\n    float dMaxIdx2 = 0.0;\n    float dMinIdx3 = 0.0;\n    float dMaxIdx3 = 0.0;\n    float dMinIdx4 = 0.0;\n    float dMaxIdx4 = 0.0;\n    float dMinIdx5 = 0.0;\n    float dMaxIdx5 = 0.0;\n    float dMinIdx6 = 0.0;\n    float dMaxIdx6 = 0.0;\n    float dMinIdx7 = 0.0;\n    float dMaxIdx7 = 0.0;\n    float dMinIdx8 = 0.0;\n    float dMaxIdx8 = 0.0;\n    float dMinIdx9 = 0.0;\n    float dMaxIdx9 = 0.0;\n    float dMinIdx10 = 0.0;\n    float dMaxIdx10 = 0.0;\n    float dMinIdx11 = 0.0;\n    float dMaxIdx11 = 0.0;\n    float dMinIdx12 = 0.0;\n    float dMaxIdx12 = 0.0;\n    float dMinIdx13 = 0.0;\n    float dMaxIdx13 = 0.0;\n    float dMinIdx14 = 0.0;\n    float dMaxIdx14 = 0.0;\n    float dMinIdx15 = 0.0;\n    float dMaxIdx15 = 0.0;\n    float dMinIdx16 = 0.0;\n    float dMaxIdx16 = 0.0;\n    float dMin", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, vec3(1.0, 57.0, 21.0));\n    vec4 v = vec4(n, n+1.0, n+57.0, n+58.0) + dot(i, vec3(57.0, 21.0, 1.0));\n    vec4 r = fract(sin(v*0.015625)*23456.54321);\n    r *= 2.0-r.yzwx;\n    return mix(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y), mix(mix(r.x, r.y, f.z), mix(r.z, r.w, f.z), f.y), f.w);\n}\n\n// This is a 3D value noise function that returns a value between 0.0 and 1.0.\n// It's a lot like the 2D version, but it's 3D.\nfloat", "\n    vec3 color = vec3(0.0);\n    float t = 0.0;\n    float tmax = 1000.0;\n    float tmin = 0.001;\n    float tstep = 0.01;\n    for (int i = 0; i < 100; i++) {\n        t += tstep;\n        if (t > tmax) break;\n        vec3 pos = rayDir * t;\n        float d = map(pos);\n        if (d < tstep) {\n            vec3 normal = GetNormal(pos);\n            float diffuse = max(0.0, dot(normal, -rayDir));\n            color += diffuse * vec3(1.0, 0.5, 0.0);\n            t += d;\n            tstep = d * 0.5;\n        }\n    }\n    return color;\n}\n\nvec", "\n    vec2 AB = B - A;\n    vec2 AC = coords - A;\n    float t = dot(AC, AB) / dot(AB, AB);\n    t = clamp(t, 0.0, 1.0);\n    vec2 P = A + t * AB;\n    float d = length(P - coords);\n    return d - height;\n}\n\n//============================================================\nfloat", "\n    float dot = dot(start, end);\n    float theta_0 = acos(dot);\n    float theta = theta_0 * percent;\n    vec2 v2 = end - start * dot;\n    v2 = normalize(v2);\n    return ((start * cos(theta)) + (v2 * sin(theta)));\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    float t = iTime;\n    float t2 = t * 0.5;\n    float t3 = t * 0.25;\n    float t4 = t * 0.125;\n    \n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n    float s = sin(a * 10.0 + t2);\n    float c = cos(a * 10.0 + t2);\n    float r2 = r + s * 0.05;\n    float r3 = r + c * 0.05;\n    float r4 = r + s * 0.025;\n    float r5 = r + c * 0.025;\n    \n    float f1 = smoothstep(0.0, 0.01, abs(r - r2));\n    float f2 = smoothstep(0.0, 0.01, abs(r - r3));\n    float f3 = smoothstep(0.0, 0.01, abs(r - r4));\n    float f4 = smoothstep(0.0, 0.01, abs(r - r5));\n    \n    float f = f1 + f2 + f3 + f4;\n    \n    col = vec3(f);\n    \n    fragColor = vec4(col, 1.0);\n}\n//============================================================", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    if (t < 0.0)\n        return length(ap);\n    else if (t > 1.0)\n        return length(p - b);\n    else\n        return length(ap - t * ab);\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat", "\n    vec3 color = vec3(0.0);\n\n    // Add a softbox light.\n    float dist = RayBox(rayDir, vec3(0.0), vec3(1000.0), 0.0);\n    if (dist > 0.0)\n    {\n        color += vec3(1.0);\n    }\n\n    return color;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec", "\n    // The material index.\n    int materialIndex = 0;\n\n    // The distance to the nearest surface.\n    float distanceToSurface = -1.0;\n\n    // The distance to the sphere.\n    float distanceToSphere = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n\n    // The distance to the plane.\n    float distanceToPlane = p.y;\n\n    // The distance to the box.\n    float distanceToBox = length(max(abs(p) - vec3(1.0, 1.0, 1.0), 0.0));\n\n    // The distance to the torus.\n    float distanceToTorus = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // The distance to the cylinder.\n    float distanceToCylinder = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // The distance to the cone.\n    float distanceToCone = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n\n    // The distance to the torus.\n    float distanceToTorus2 = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // The distance to the cylinder.\n    float distanceToCylinder2 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // The distance to the cone.\n    float distanceToCone2 = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n\n    // The distance to the torus.\n    float distanceToTorus3 = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // The distance to the cylinder.\n    float distanceToCylinder3 = length(p.xz - vec", "\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, org);\n    float c = dot(org, org) - 1.0;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0)\n        return false;\n    float t1 = (-b - sqrt(d)) / (2.0 * a);\n    float t2 = (-b + sqrt(d)) / (2.0 * a);\n    near = min(t1, t2);\n    far = max(t1, t2);\n    return true;\n}\n\n// from https://www.shadertoy.com/view/4s23DR\nbool sphere(vec3 org, vec3 dir, out float near, out float far)\n{\n    float b = dot(org, dir);\n    float c = dot(org, org) - 1.0;\n    float d = b * b - c;\n    if (d < 0.0)\n        return false;\n    float t1 = -b - sqrt(d);\n    float t2 = -b + sqrt(d);\n    near = min(t1, t2);\n    far = max(t1, t2);\n    return true;\n}\n\n// from https://www.shadertoy.com/view/4s23DR\nbool plane(vec3 org, vec3 dir, out float near)\n{\n    float d = dot(org, vec3(0.0, 1.0, 0.0));\n    float b = dot(dir, vec3(0.0, 1.0, 0.0));\n    if (b == 0.0)\n        return false;\n    near = -d / b;\n    return true;\n}\n\n// from https://www.shadertoy.com/view/4s23DR\nbool box(vec3 org, vec3 dir, out float near, out float far)\n{\n    vec3 t1 = (-1.0 - org) / dir;\n    vec3 t2 = (1.0 - org", "\n    vec3 q = abs(p) - s.xyz + r.x;\n    float k0 = max(q.x, max(q.y, q.z * r.z));\n    float k1 = max(q.z, max(q.x, q.y * r.z));\n    float k2 = max(q.y, max(q.x, q.z * r.z));\n    float d = min(max(k0, k1), k2);\n    return d - s.w;\n}\n\nfloat", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // For performance, compute the cross-product for the three corners of the cube\n    // in which the point p resides.\n    vec3 u = f*f*(3.0-2.0*f);\n\n    // Random float offsets for the 3D noise\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    // Compute the dot product between the gradients and the distance vector\n    // for each of the 8 corners of the cube.\n    return mix(\n        mix(\n            mix(\n                dot(\n                    hash33(n+dot(i, vec3(0, 1, 1))),\n                    f - vec3(0, 0, 0),\n                    u\n                ),\n                dot(\n                    hash33(n+dot(i, vec3(1, 0, 1))),\n                    f - vec3(1, 0, 0),\n                    u\n                ),\n                u.y\n            ),\n            mix(\n                dot(\n                    hash33(n+dot(i, vec3(0, 1, 0))),\n                    f - vec3(0, 1, 0),\n                    u\n                ),\n                dot(\n                    hash33(n+dot(i, vec3(1, 1, 0))),\n                    f - vec3(1, 1, 0),\n                    u\n                ),\n                u.y\n            ),\n            u.z\n        ),\n        mix(\n            mix(\n                dot(\n                    hash33(n+dot(i, vec3(0, 0, 1))),\n                    f - vec3(0, 0, 1),\n                    u\n                ),\n                dot(\n                    hash33(n+dot(i, vec3(1, 0, 1))),\n                    f - vec3(1, 0, 1),\n                    u\n                ),\n                u.y\n            ),\n", "\n    float d = 1e5;\n    for(int i=0; i<4; i++){\n        float a = float(i)*TWO_PI/4.0;\n        vec2 q = p - vec2(cos(a), sin(a))*0.5;\n        d = min(d, length(q)-0.2);\n    }\n    return d;\n}\n\nvec", "\n    vec3 bump = normalize(sn);\n    bump = normalize(bump + sp);\n    bump *= bumpFactor;\n    return bump;\n}\n\n// Standard bump function.\n//\nvec", "\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    vec3 l = normalize(light_pos - p);\n    vec3 v = normalize(camera_pos - p);\n    vec3 h = normalize(l + v);\n\n    float n_dot_l = max(dot(n, l), 0.0);\n    float n_dot_h = max(dot(n, h), 0.0);\n\n    vec3 diffuse = n_dot_l * light_color;\n    vec3 specular = pow(n_dot_h, 100.0) * light_color;\n\n    return diffuse + specular;\n}\n\n// Ray marching\n// p : point,\n// d : direction\nfloat", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "\n    vec3 uvw = normalize(rd);\n    float u = atan(uvw.z, uvw.x) / 3.1415926535897932384626433832795;\n    float v = 0.5 - asin(uvw.y) / 3.1415926535897932384626433832795;\n    return texture(iChannel0, vec2(u, v)).rgb;\n}\n\n// raymarching\nfloat", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        d = map(ro + rd * t);\n        if (d < 0.001)\n        {\n            col = vec3(1.0, 0.0, 0.0);\n            break;\n        }\n        t += d;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = rayColor(ro, rd);\n    fragColor = vec4(col, 1.0);\n}\n", "\n    return length(p)-rad;\n}\n\nfloat", "\n    float d = length(p) - param.x;\n    return d;\n}\n\n// scene distance\nfloat", "\n    float d = DE(p, param);\n    float l = length(p);\n    float ld = l * d;\n    float ld2 = ld * ld;\n    float ld3 = ld2 * ld;\n    float ld4 = ld2 * ld2;\n    float ld5 = ld4 * ld;\n    float ld6 = ld4 * ld2;\n    float ld7 = ld6 * ld;\n    float ld8 = ld6 * ld2;\n    float ld9 = ld8 * ld;\n    float ld10 = ld8 * ld2;\n    float ld11 = ld10 * ld;\n    float ld12 = ld10 * ld2;\n    float ld13 = ld12 * ld;\n    float ld14 = ld12 * ld2;\n    float ld15 = ld14 * ld;\n    float ld16 = ld14 * ld2;\n    float ld17 = ld16 * ld;\n    float ld18 = ld16 * ld2;\n    float ld19 = ld18 * ld;\n    float ld20 = ld18 * ld2;\n    float ld21 = ld20 * ld;\n    float ld22 = ld20 * ld2;\n    float ld23 = ld22 * ld;\n    float ld24 = ld22 * ld2;\n    float ld25 = ld24 * ld;\n    float ld26 = ld24 * ld2;\n    float ld27 = ld26 * ld;\n    float ld28 = ld26 * ld2;\n    float ld29 = ld28 * ld;\n    float ld30 = ld28 * ld2;\n    float ld31 = ld30 * ld;\n    float ld3", "\n    vec3 col = vec3(0.0);\n    float sun = max(dot(rd, sunDir), 0.0);\n    float sky = max(dot(rd, skyDir), 0.0);\n    float sky2 = max(dot(rd, skyDir2), 0.0);\n    float sky3 = max(dot(rd, skyDir3), 0.0);\n    float sky4 = max(dot(rd, skyDir4), 0.0);\n    float sky5 = max(dot(rd, skyDir5), 0.0);\n    float sky6 = max(dot(rd, skyDir6), 0.0);\n    float sky7 = max(dot(rd, skyDir7), 0.0);\n    float sky8 = max(dot(rd, skyDir8), 0.0);\n    float sky9 = max(dot(rd, skyDir9), 0.0);\n    float sky10 = max(dot(rd, skyDir10), 0.0);\n    float sky11 = max(dot(rd, skyDir11), 0.0);\n    float sky12 = max(dot(rd, skyDir12), 0.0);\n    float sky13 = max(dot(rd, skyDir13), 0.0);\n    float sky14 = max(dot(rd, skyDir14), 0.0);\n    float sky15 = max(dot(rd, skyDir15), 0.0);\n    float sky16 = max(dot(rd, skyDir16), 0.0);\n    float sky17 = max(dot(rd, skyDir17), 0.0);\n    float sky18 = max(dot(rd, skyDir18), 0.0);\n    float sky19 = max(dot(rd, skyDir19), 0.0);\n    float sky20 = max(dot(rd, skyDir20), 0.0);\n    float sky21 = max(dot(rd, skyDir21), 0.0);\n    float sky22 = max(dot(rd, skyDir", "\n    vec3 col = vec3(0.0);\n    float t = ti;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        d = map(ro + rd * t);\n        if (d < 0.001)\n        {\n            col = vec3(1.0, 0.0, 0.0);\n            break;\n        }\n        t += d;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = rayColor(ro, rd, 0.0);\n    fragColor = vec4(col, 1.0);\n}\n", "\n    p = abs(p - diamond.xy);\n    p -= 2.0 * clamp(dot(vec2(1.0, 1.0), p), 0.0, 1.0);\n    return length(p) * sign(p.x + p.y);\n}\n\n// circle: (center.x, center.y, radius)\nfloat", "\n    vec3 col = vec3(0.0);\n    uv *= 1.0;\n    uv = fract(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv", "\n    float d = length(pos) - 1.0;\n    return d;\n}\n\n// get normal in the world\nvec", "\n    vec3 l = normalize( vec3( 1.0, 1.0, 1.0 ) );\n    vec3 h = normalize( l + eye );\n    float ndotl = max( dot( n, l ), 0.0 );\n    float ndoth = max( dot( n, h ), 0.0 );\n    float spec = pow( ndoth, 10.0 );\n    return vec3( 0.2, 0.2, 0.2 ) + vec3( 0.8, 0.8, 0.8 ) * ndotl + vec3( 1.0, 1.0, 1.0 ) * spec;\n}\n\nvoid main() {\n    vec3 v = normalize( vec3( gl_FragCoord.xy - u_resolution.xy, u_resolution.y ) );\n    vec3 n = normalize( vec3( 0.0, 0.0, 1.0 ) );\n    vec3 eye = normalize( vec3( 0.0, 0.0, 1.0 ) );\n    gl_FragColor = vec4( shading( v, n, eye ), 1.0 );\n}\n", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    float d = length(p) - offset;\n    return pow(abs(sin(d * 100.0)), 1.0);\n}\n\n// 2d rotation matrix\nmat", "\n    float xmts = (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (", "\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h/2.0);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n/**\n * Signed distance function for a box centered at the origin with the given dimensions.\n */\nfloat", "\n    float sphere = length(p) - 1.0;\n    float plane = p.y;\n    return min(sphere, plane);\n}\n\n/**\n * Calculate the normal of the surface at point p.\n */\nvec", "\n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, up));\n    vec3 up_ = normalize(cross(right, forward));\n\n    return mat3(right, up_, -forward);\n}\n\n/**\n * Return a transform matrix that will transform a ray from world coordinates\n * to view space, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat", "\n    float n = pnoise(p, 1.0);\n    n += pnoise(p*2.0, 2.0);\n    n += pnoise(p*4.0, 4.0);\n    n += pnoise(p*8.0, 8.0);\n    n /= 4.0;\n    return n;\n}\n\n// my noise\nfloat", "\n    vec2 pos = coord;\n    float r = length(pos);\n    float a = atan(pos.y, pos.x);\n    float f = fract(a / 3.1415926535897932384626433832795);\n    float g = fract(a / 3.1415926535897932384626433832795 + 0.5);\n    float b = fract(a / 3.1415926535897932384626433832795 + 1.0);\n    float h = fract(a / 3.1415926535897932384626433832795 + 1.5);\n    float i = fract(a / 3.1415926535897932384626433832795 + 2.0);\n    float j = fract(a / 3.1415926535897932384626433832795 + 2.5);\n    float k = fract(a / 3.1415926535897932384626433832795 + 3.0);\n    float l = fract(a / 3.1415926535897932384626433832795 + 3.5);\n    float m = fract(a / 3.1415926535897932384626433832795 + 4.0);\n    float n = fract(a / 3.1415926535897932384626433832795 + 4.5);\n   ", "\n  vec2 q = vec2(\n    dot(p, vec2(127.1, 311.7)),\n    dot(p, vec2(269.5, 183.3))\n  );\n  return fract(sin(q) * w);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.1250*noise(p); p = p*2.01;\n    f += 0.0625*noise(p);\n    return f;\n}\n\n// The bump mapping function.\nvec", "\n    vec4 scr_pt_hom = vec4(scr_pt, 0.0, 1.0);\n    vec4 view_pt = viewp_inv * scr_pt_hom;\n    view_pt /= view_pt.w;\n    vec4 world_pt = view_inv * view_pt;\n    vec4 world_dir = world_pt - view_inv[3];\n    return world_dir;\n}\n\n// screen to world: http://bookofhook.com/mousepick.pdf\nvec", "\n    vec2 dir = pB - pA;\n    vec2 dirN = normalize(dir);\n    vec2 dirP = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90 = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90 = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P = normalize(dir * vec2(1.0, 1.0));\n    vec2 dirP90P = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90N = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90N = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P90 = normalize(dir * vec2(1.0, 1.0));\n    vec2 dirP90P90 = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90N90 = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90N90 = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P90N90 = normalize(dir * vec2(1.0, 1.0));\n    vec2 dirP90P90N90 = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90N90P90N90 = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90N90P90N90 = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P90N90P90N90 =", "\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 ambient = vec3(0.1, 0.1, 0.1);\n    vec3 diffuse = max(dot(n, lightDir), 0.0) * lightColor;\n    return ambient + diffuse;\n}\n\n// Ray-marching\n// p : point,\n// d : direction\nfloat", "\n    vec3 m = (ro - cen) / rd;\n    vec3 n = (ro - cen) / rad;\n    vec3 k = abs(m) - n;\n    float t1 = max( max( k.x, k.y ), k.z );\n    float t2 = min( min( k.x, k.y ), k.z );\n    return vec2( max( t1, t2 ), min( t1, t2 ) );\n}\n\n// ray-box intersection (simplified)\nvec", "\n    float y = sin(x);\n    float z = (y + 1) / 2;\n    float w = pow(z, a);\n    float v = pow(1 - z, b);\n    return w * v;\n}\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat", "\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// z * z\nvec", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b - sqrt(h)) / a;\n        vec3  p = ro + t*rd;\n        vec3  n = (p-pa) - ba*dot(p-pa,ba)/baba;\n        return vec4( t, n );\n    }\n    return vec4( -1.0 );\n}\n\n// ray-cone intersection (returns t and normal)\nvec", "\n    vec2 p = P - U;\n    float d = length(p);\n    if (d < r) {\n        float a = atan(p.y, p.x);\n        float s = sin(a);\n        float c = cos(a);\n        float t = (d - r) / r;\n        float aa = a + t * 0.5;\n        float ss = sin(aa);\n        float cc = cos(aa);\n        float dd = d + t * r;\n        float h = sqrt(r * r - dd * dd);\n        float sss = ss * h;\n        float ccc = cc * h;\n        O.x = sss + dd * c;\n        O.y = ccc - dd * s;\n        O.z = dd;\n        O.w = aa;\n        O.xyz = C;\n    }\n}\n\nvoid main() {\n    vec2 U = iMouse.xy / iResolution.xy;\n    vec2 P = gl_FragCoord.xy / iResolution.xy;\n    vec4 O = vec4(0.0);\n    sphere(O, U, P, 0.2, vec3(1.0, 0.0, 0.0));\n    sphere(O, U, P, 0.1, vec3(0.0, 1.0, 0.0));\n    sphere(O, U, P, 0.05, vec3(0.0, 0.0, 1.0));\n    gl_FragColor = vec4(O.xyz, 1.0);\n}\n", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    return d;\n}\n\n// ray marching\nvec", "\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = r - layerID;\n    float s = sin(a);\n    float c = cos(a);\n    float s2 = s*s;\n    float c2 = c*c;\n    float s3 = s*s2;\n    float c3 = c*c2;\n    float s4 = s*s3;\n    float c4 = c*c3;\n    float s5 = s*s4;\n    float c5 = c*c4;\n    float s6 = s*s5;\n    float c6 = c*c5;\n    float s7 = s*s6;\n    float c7 = c*c6;\n    float s8 = s*s7;\n    float c8 = c*c7;\n    float s9 = s*s8;\n    float c9 = c*c8;\n    float s10 = s*s9;\n    float c10 = c*c9;\n    float s11 = s*s10;\n    float c11 = c*c10;\n    float s12 = s*s11;\n    float c12 = c*c11;\n    float s13 = s*s12;\n    float c13 = c*c12;\n    float s14 = s*s13;\n    float c14 = c*c13;\n    float s15 = s*s14;\n    float c15 = c*c14;\n    float s16 = s*s15;\n    float c16 = c*c15;\n    float s17 = s*s16;\n    float c17 = c*c16;\n    float s18 = s*s17;\n    float c18 = c*c17;\n    float s19 = s*s18;\n    float c19 = c*c18;\n    float s20 = s*s19;\n    float c20 = c*c19;\n", "\n    vec3 col = vec3(0.0);\n    float d = 1000.0;\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float s = sin(a*10.0);\n    float c = cos(a*10.0);\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r6 = r4*r2;\n    float r8 = r4*r4;\n    float r10 = r8*r2;\n    float r12 = r8*r4;\n    float r14 = r12*r2;\n    float r16 = r12*r4;\n    float r18 = r16*r2;\n    float r20 = r16*r4;\n    float r22 = r20*r2;\n    float r24 = r20*r4;\n    float r26 = r24*r2;\n    float r28 = r24*r4;\n    float r30 = r28*r2;\n    float r32 = r28*r4;\n    float r34 = r32*r2;\n    float r36 = r32*r4;\n    float r38 = r36*r2;\n    float r40 = r36*r4;\n    float r42 = r40*r2;\n    float r44 = r40*r4;\n    float r46 = r44*r2;\n    float r48 = r44*r4;\n    float r50 = r48*r2;\n    float r52 = r48*r4;\n    float r54 = r52*r2;\n    float r56 = r52*r4;\n    float r58 = r56*r2;\n    float r60 = r56*r4;\n    float r62 = r60*r2;\n    float r64 = r60", "\n    float flameRadius = 0.5;\n    float flameHeight = 0.5;\n    float flameWidth = 0.5;\n    float flameLength = 0.5;\n    float flameSpeed = 0.5;\n    float flameTime = iTime * flameSpeed;\n    float flameNoise = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime));\n    float flameNoise2 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 1.0));\n    float flameNoise3 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 2.0));\n    float flameNoise4 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 3.0));\n    float flameNoise5 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 4.0));\n    float flameNoise6 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 5.0));\n    float flameNoise7 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 6.0));\n    float flameNoise8 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 7.0));\n    float flameNoise9 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 8.0));\n    float flameNoise10 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 9.0));\n    float flameNoise11 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition", "\n    float sphereDist = sdSphere(currentRayPosition, vec3(0.0, 0.0, 0.0), 1.0);\n    float planeDist = sdPlane(currentRayPosition, vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0));\n    float boxDist = sdBox(currentRayPosition, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float result = min(sphereDist, planeDist);\n    result = min(result, boxDist);\n    return result;\n}\n\n// \u043d\u043e\u0440\u043c\u0430\u043b\u044c \u043a \u0442\u043e\u0447\u043a\u0435\nvec", "\n    return fract(sin(x)*sm);\n}\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat", "\n    vec3 q = vec3(dot(p, vec3(1.0, 57.0, 21.0)),\n                  dot(p, vec3(57.0, 21.0, 1.0)),\n                  dot(p, vec3(21.0, 1.0, 57.0)));\n    return fract(sin(q) * 43758.5453);\n}\n\n// vec3 to float hash algorithm.\nfloat", "\n    // Skew the input space to determine which simplex cell we're in\n    float s = (p.x + p.y + p.z) * F3; // F3 = (sqrt(3) - 1) / 3;\n    // Very nice interpolating function.\n    // s = s - floor(s * (1.0 / 69.0)) * 69.0;\n    // And this is the same thing, but faster.\n    s = fract(s);\n    // To reduce the common \"wrap\" artifact, I'm using a bitwise AND.\n    // The result is a value in the range [0, 64].\n    int i = int(p.x + s);\n    int j = int(p.y + s);\n    int k = int(p.z + s);\n\n    float x0 = float(i) - s;\n    float y0 = float(j) - s;\n    float z0 = float(k) - s;\n    float x1 = x0 + 1.0;\n    float y1 = y0;\n    float z1 = z0;\n    float x2 = x0;\n    float y2 = y0 + 1.0;\n    float z2 = z0;\n    float x3 = x0;\n    float y3 = y0;\n    float z3 = z0 + 1.0;\n\n    // Work out the hashed gradient indices of the four simplex corners\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int gi0 = perm[ii + perm[jj + perm[kk]]] % 12;\n    int gi1 = perm[ii + 1 + perm[jj + perm[kk]]] % 12;\n    int gi2 = perm[ii + perm[jj + 1 + perm[kk]]] % 12;\n    int gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk]]] % 12;\n\n    // Calculate the contribution from the four corners\n    float t0", "\n    float f = snoise(p);\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*", "\n\n    float balloonRadius = 0.05;\n    float balloonHeight = 0.1;\n\n    vec3 balloonPosition = vec3(0.0, 0.0, 0.0);\n\n    vec3 balloonToCurrentRayPosition = currentRayPosition - balloonPosition;\n\n    float balloonToCurrentRayPositionLength = length(balloonToCurrentRayPosition);\n\n    float balloonToCurrentRayPositionLengthSquared = balloonToCurrentRayPositionLength * balloonToCurrentRayPositionLength;\n\n    float balloonToCurrentRayPositionLengthSquaredMinusBalloonRadiusSquared = balloonToCurrentRayPositionLengthSquared - (balloonRadius * balloonRadius);\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeight = balloonToCurrentRayPositionLength - balloonHeight;\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquared = balloonToCurrentRayPositionLengthMinusBalloonHeight * balloonToCurrentRayPositionLengthMinusBalloonHeight;\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquared = balloonToCurrentRayPositionLengthMinusBalloonHeightSquared - (balloonRadius * balloonRadius);\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquaredSquared = balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquared * balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquared;\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquaredSquaredSquared = balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquaredSquared * balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusS", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec4( tN, tF, tN > tF? -1.0 : tF < tN? 0.0 : 1.0, tF );\n}\n\n// ray box intersection by iq https://www.shadertoy.com/view/ld23DV\nvec", "\n    // Skew the input space to determine which simplex cell we're in\n    float s = (p.x + p.y + p.z) * F3; // F3 = (sqrt(3.0) - 1.0) / 3.0\n    // Very nice interpolating function.\n    // s = s - floor(s * (1.0 / 69.0)) * 69.0;\n    // And this is the same thing, but faster.\n    s = s - (floor(s + 0.5) - 0.5);\n    // Truncate the integer part of the coordinates, leaving only the \"smaller\" coordinates.\n    // This is the index of the first corner of the simplex cell we are in.\n    // The last incremental value is guaranteed to be less than 1.\n    ivec3 i = ivec3(floor(p + s));\n    vec3 x0 = vec3(p - i); // The vector, p, relative to the i'th corner of the simplex cell.\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n    int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n    if(x0.x >= x0.y){\n        if(x0.y >= x0.z){\n            i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; // X Y Z order\n        }else if(x0.x >= x0.z){\n            i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; // X Z Y order\n        }else{\n            i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; // Z X Y order\n        }\n    }else{ //", "\n    vec2 pa=p-a, ba=b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return c*(1.0-h);\n}\n\n//coloring lineAO()\nvec", "\n    float i = 0.0;\n    float r = 0.0;\n    float r2 = 0.0;\n    float i2 = 0.0;\n    float r2i2 = 0.0;\n    float r2i2_2 = 0.0;\n    float r2i2_4 = 0.0;\n    float r2i2_8 = 0.0;\n    float r2i2_16 = 0.0;\n    float r2i2_32 = 0.0;\n    float r2i2_64 = 0.0;\n    float r2i2_128 = 0.0;\n    float r2i2_256 = 0.0;\n    float r2i2_512 = 0.0;\n    float r2i2_1024 = 0.0;\n    float r2i2_2048 = 0.0;\n    float r2i2_4096 = 0.0;\n    float r2i2_8192 = 0.0;\n    float r2i2_16384 = 0.0;\n    float r2i2_32768 = 0.0;\n    float r2i2_65536 = 0.0;\n    float r2i2_131072 = 0.0;\n    float r2i2_262144 = 0.0;\n    float r2i2_524288 = 0.0;\n    float r2i2_1048576 = 0.0;\n    float r2i2_2097152 = 0.0;\n    float r2i2_4194304 = 0.0;\n    float r2i2_8388608 = 0.0;\n    float r2i2_16777216 = 0.0;\n    float r2i2_33554432 = 0.0;\n    float r2i2_67108864 = 0.0;\n    float r2", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n\n    return mat4(\n        x.x, x.y, x.z, 0.0,\n        y.x, y.y, y.z, 0.0,\n        z.x, z.y, z.z, 0.0,\n        cam.x, cam.y, cam.z, 1.0\n    );\n}\n\n//projection matrix\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec", "\n    float d = abs(p.x) - w;\n    d = max(d, abs(p.y) - w);\n    d = max(d, abs(p.x) - w * dir);\n    return d;\n}\n\nfloat", "\n    return (x - a) / (b - a);\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat", "\n    float x = xy.x;\n    float y = func(x);\n    if (y < xy.y && xy.y < y + 1.0)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float y)\n{\n    float x = xy.x;\n    if (y < xy.y && xy.y < y + 1.0)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws explicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float y, float y2)\n{\n    float x = xy.x;\n    if (y < xy.y && xy.y < y + 1.0)\n    {\n        baseCol = curveCol;\n    }\n    else if (y2 < xy.y && xy.y < y2 + 1.0)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float y, float y2, float y3)\n{\n    float x = xy.x;\n    if (y < xy.y && xy.y < y + 1.0)\n    {\n        baseCol = curveCol;\n    }\n    else if (y2 < xy.y && xy.y < y2 + 1.0)\n    {\n        baseCol = curveCol;\n    }\n    else if (y3 < xy.y && xy.y < y3 + 1.0)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float y, float y2,", "\n    float d=0.;\n    float a=0.;\n    for(int i=0;i<5;i++){\n        float n=float(i)+1.;\n        float t=n*3.1415926535897932384626433832795/2.;\n        vec2 q=p+vec2(cos(t),sin(t))*j;\n        d+=abs(length(q)-n);\n        a+=atan(q.y,q.x);\n    }\n    return d/5.-a/3.1415926535897932384626433832795;\n}\n\nfloat", "\n    return smoothstep(0.0, 1.0, f);\n}\n\nfloat", "\n    c.r = c.r*1.05 - 0.05;\n    c.g = c.g*0.95 + 0.05;\n    c.b = c.b*1.05 - 0.05;\n    return c;\n}\n\n//reduce rgb values of some ranges, similar to EnChromaHsv(), but\n//not quite how human vision works, still helps \"visualizing\"\n//how this apparently enhanches yellow, and mostly filters out green.\nvec", "\n    vec3 d = abs(p) - s;\n    float insideDistance = min(max(d.x,max(d.y,d.z)),0.0);\n    float outsideDistance = length(max(d,0.0));\n    return vec4(insideDistance + outsideDistance,1.0,0.0,0.0);\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec", "\n    float d = sdSphere(p,r.x);\n    float d2 = sdBox(p,r.y);\n    float d3 = sdBox(p,r.z);\n    float d4 = sdBox(p,r.w);\n    float d5 = sdBox(p,r.x);\n    float d6 = sdBox(p,r.y);\n    float d7 = sdBox(p,r.z);\n    float d8 = sdBox(p,r.w);\n    float d9 = sdBox(p,r.x);\n    float d10 = sdBox(p,r.y);\n    float d11 = sdBox(p,r.z);\n    float d12 = sdBox(p,r.w);\n    float d13 = sdBox(p,r.x);\n    float d14 = sdBox(p,r.y);\n    float d15 = sdBox(p,r.z);\n    float d16 = sdBox(p,r.w);\n    float d17 = sdBox(p,r.x);\n    float d18 = sdBox(p,r.y);\n    float d19 = sdBox(p,r.z);\n    float d20 = sdBox(p,r.w);\n    float d21 = sdBox(p,r.x);\n    float d22 = sdBox(p,r.y);\n    float d23 = sdBox(p,r.z);\n    float d24 = sdBox(p,r.w);\n    float d25 = sdBox(p,r.x);\n    float d26 = sdBox(p,r.y);\n    float d27 = sdBox(p,r.z);\n    float d28 = sdBox(p,r.w);\n    float d29 = sdBox(p,r.x);\n    float d30 = sdBox(p,r.y);\n    float d31 = sdBox(", "\n    // Get the material at the current position\n    Material mat = getMaterial(pos);\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 0.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 1.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 2.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 3.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 4.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 5.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 6.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 7.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 8.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 9.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 10.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 11.0)\n    {\n        return mat;\n", "\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec", "\n    float r = 1e10;\n    for(int i=0; i<10; i++){\n        p = abs(p*2.)-1.;\n        p.x = max(p.x, p.y);\n        p.x = max(p.x, p.z);\n        r = min(r, p.x);\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    vec3 p = vec3(uv, 0);\n    float t = iGlobalTime*.5;\n    p.z = t;\n    p.xy *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    float d = m(p);\n    vec3 c = vec3(1.0, 0.5, 0.25) * d;\n    fragColor = vec4(c, 1.0);\n}\n", "\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    float diffuse = max(dot(n, l), 0.0);\n    float specular = pow(max(dot(reflect(-l, n), normalize(camPos - p)), 0.0), 16.0);\n    return mat(diffuse, specular);\n}\n\n//scene color at position p\nvec", "\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// returns a fractal noise in a 3D space\nfloat", "\n    vec2 a = vec2(0.0, 0.0);\n    vec2 b = vec2(0.0, 0.0);\n    vec2 c = vec2(0.0, 0.0);\n    vec2 d = vec2(0.0, 0.0);\n    vec2 e = vec2(0.0, 0.0);\n    vec2 f = vec2(0.0, 0.0);\n    vec2 g = vec2(0.0, 0.0);\n    vec2 h = vec2(0.0, 0.0);\n    vec2 i = vec2(0.0, 0.0);\n    vec2 j = vec2(0.0, 0.0);\n    vec2 k = vec2(0.0, 0.0);\n    vec2 l = vec2(0.0, 0.0);\n    vec2 m = vec2(0.0, 0.0);\n    vec2 n = vec2(0.0, 0.0);\n    vec2 o = vec2(0.0, 0.0);\n    vec2 p = vec2(0.0, 0.0);\n    vec2 q = vec2(0.0, 0.0);\n    vec2 r = vec2(0.0, 0.0);\n    vec2 s = vec2(0.0, 0.0);\n    vec2 t = vec2(0.0, 0.0);\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n    vec2 w = vec2(0.0, 0.0);\n    vec2 x = vec2(0.0, 0.0);\n    vec2 y = vec2(0.0, 0.0);\n    vec2 z = vec2(0", "\n    return dot(u,m);\n}\n\n//return __signed distance of [u] to line trough [a] and [b], b must be normalized.\nfloat", "\n    return dot(u,m);\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat", "\n    vec2 d = u - m.xy;\n    return dot(d, normalize(m.zw - m.xy));\n}\n\n//return signed distance of u to line trough m.xy and m.zw\nfloat", "\n  return U.x;\n}\n\nv2 d(v1 U){\n  return U.y;\n}\n\nv2 e(v1 U){\n  return U.z;\n}\n\nv2 f(v1 U){\n  return U.w;\n}\n\nv2 g(v1 U){\n  return U.x;\n}\n\nv2 h(v1 U){\n  return U.y;\n}\n\nv2 i(v1 U){\n  return U.z;\n}\n\nv2 j(v1 U){\n  return U.w;\n}\n\nv2 k(v1 U){\n  return U.x;\n}\n\nv2 l(v1 U){\n  return U.y;\n}\n\nv2 m(v1 U){\n  return U.z;\n}\n\nv2 n(v1 U){\n  return U.w;\n}\n\nv2 o(v1 U){\n  return U.x;\n}\n\nv2 p(v1 U){\n  return U.y;\n}\n\nv2 q(v1 U){\n  return U.z;\n}\n\nv2 r(v1 U){\n  return U.w;\n}\n\nv2 s(v1 U){\n  return U.x;\n}\n\nv2 t(v1 U){\n  return U.y;\n}\n\nv2 u(v1 U){\n  return U.z;\n}\n\nv2 v(v1 U){\n  return U.w;\n}\n\nv2 w(v1 U){\n  return U.x;\n}\n\nv2 x(v1 U){\n  return U.y;\n}\n\nv2 y(v1 U){\n  return U.z;\n}\n\nv2 z(v1 U){\n  return U.w;\n}\n\nv2 A(v1 U){\n  return U.x;\n}\n\nv2 B(v1 U){\n  return U.y;\n}\n\nv2 C(v1 U){\n  return U.z;\n}\n\nv2 D(v1 U", "\n  return U.x;\n}\n\nv2 d(v1 U){\n  return U.x;\n}\n\nv2 e(v1 U){\n  return U.x;\n}\n\nv2 f(v1 U){\n  return U.x;\n}\n\nv2 g(v1 U){\n  return U.x;\n}\n\nv2 h(v1 U){\n  return U.x;\n}\n\nv2 i(v1 U){\n  return U.x;\n}\n\nv2 j(v1 U){\n  return U.x;\n}\n\nv2 k(v1 U){\n  return U.x;\n}\n\nv2 l(v1 U){\n  return U.x;\n}\n\nv2 m(v1 U){\n  return U.x;\n}\n\nv2 n(v1 U){\n  return U.x;\n}\n\nv2 o(v1 U){\n  return U.x;\n}\n\nv2 p(v1 U){\n  return U.x;\n}\n\nv2 q(v1 U){\n  return U.x;\n}\n\nv2 r(v1 U){\n  return U.x;\n}\n\nv2 s(v1 U){\n  return U.x;\n}\n\nv2 t(v1 U){\n  return U.x;\n}\n\nv2 u(v1 U){\n  return U.x;\n}\n\nv2 v(v1 U){\n  return U.x;\n}\n\nv2 w(v1 U){\n  return U.x;\n}\n\nv2 x(v1 U){\n  return U.x;\n}\n\nv2 y(v1 U){\n  return U.x;\n}\n\nv2 z(v1 U){\n  return U.x;\n}\n\nv2 A(v1 U){\n  return U.x;\n}\n\nv2 B(v1 U){\n  return U.x;\n}\n\nv2 C(v1 U){\n  return U.x;\n}\n\nv2 D(v1 U", "\n    return a - dot(a, b) * b;\n}\n\nvec", "\n    float r1 = sqrt(Xi1);\n    float r2 = Xi2;\n    w = mix(A, B, r1);\n    w = mix(w, C, r1);\n    w = mix(w, A, r2);\n    w = normalize(w);\n    wPdf = 1.0 / (2.0 * PI);\n}\n\n//Function which does triangle sampling proportional to their area.\n//You can find more information and pseudocode here:\n// * Stratified Sampling of Spherical Triangles. J Arvo - \u200e1995\n// * Stratified sampling of 2d manifolds. J Arvo - \u200e2001\nvoid sampleSphericalTriangleArea(in vec3 A, in vec3 B, in vec3 C, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    float r1 = sqrt(Xi1);\n    float r2 = Xi2;\n    w = mix(A, B, r1);\n    w = mix(w, C, r1);\n    w = mix(w, A, r2);\n    w = normalize(w);\n    wPdf = 1.0 / (2.0 * (dot(cross(A, B), C) + dot(cross(B, C), A) + dot(cross(C, A), B)));\n}\n\n//Function which does triangle sampling proportional to their area.\n//You can find more information and pseudocode here:\n// * Stratified Sampling of Spherical Triangles. J Arvo - \u200e1995\n// * Stratified sampling of 2d manifolds. J Arvo - \u200e2001\nvoid sampleSphericalTriangleArea(in vec3 A, in vec3 B, in vec3 C, in float Xi1, in float Xi2, out vec3 w, out float wPdf, out vec3 wN) {\n    float r1 = sqrt(Xi1);\n    float r2 = Xi2;\n    w = mix(A, B, r1);\n    w =", "\n  return U.x;\n}\n\nv2 d(v1 U){\n  return U.x;\n}\n\nv2 e(v1 U){\n  return U.x;\n}\n\nv2 f(v1 U){\n  return U.x;\n}\n\nv2 g(v1 U){\n  return U.x;\n}\n\nv2 h(v1 U){\n  return U.x;\n}\n\nv2 i(v1 U){\n  return U.x;\n}\n\nv2 j(v1 U){\n  return U.x;\n}\n\nv2 k(v1 U){\n  return U.x;\n}\n\nv2 l(v1 U){\n  return U.x;\n}\n\nv2 m(v1 U){\n  return U.x;\n}\n\nv2 n(v1 U){\n  return U.x;\n}\n\nv2 o(v1 U){\n  return U.x;\n}\n\nv2 p(v1 U){\n  return U.x;\n}\n\nv2 q(v1 U){\n  return U.x;\n}\n\nv2 r(v1 U){\n  return U.x;\n}\n\nv2 s(v1 U){\n  return U.x;\n}\n\nv2 t(v1 U){\n  return U.x;\n}\n\nv2 u(v1 U){\n  return U.x;\n}\n\nv2 v(v1 U){\n  return U.x;\n}\n\nv2 w(v1 U){\n  return U.x;\n}\n\nv2 x(v1 U){\n  return U.x;\n}\n\nv2 y(v1 U){\n  return U.x;\n}\n\nv2 z(v1 U){\n  return U.x;\n}\n\nv2 A(v1 U){\n  return U.x;\n}\n\nv2 B(v1 U){\n  return U.x;\n}\n\nv2 C(v1 U){\n  return U.x;\n}\n\nv2 D(v1 U", "\n    p.x = abs(p.x);\n    p.y -=.5;\n    return length(p)-.5;\n}\n\n// Torus: A torus is a tube with a hole in the middle.\nfloat", "\n    vec3 q = p;\n    q.xz = mod(q.xz, 2.0) - 1.0;\n    q.y = mod(q.y, 2.0) - 1.0;\n    float d = length(q) - 0.5;\n    float d2 = length(q.xz) - 0.5;\n    float d3 = length(q.yz) - 0.5;\n    float d4 = length(q.xy) - 0.5;\n    float d5 = length(q.xz) - 0.5;\n    float d6 = length(q.yz) - 0.5;\n    float d7 = length(q.xy) - 0.5;\n    float d8 = length(q.xz) - 0.5;\n    float d9 = length(q.yz) - 0.5;\n    float d10 = length(q.xy) - 0.5;\n    float d11 = length(q.xz) - 0.5;\n    float d12 = length(q.yz) - 0.5;\n    float d13 = length(q.xy) - 0.5;\n    float d14 = length(q.xz) - 0.5;\n    float d15 = length(q.yz) - 0.5;\n    float d16 = length(q.xy) - 0.5;\n    float d17 = length(q.xz) - 0.5;\n    float d18 = length(q.yz) - 0.5;\n    float d19 = length(q.xy) - 0.5;\n    float d20 = length(q.xz) - 0.5;\n    float d21 = length(q.yz) - 0.5;\n    float d22 = length(q.xy) - 0.5;\n    float d23 = length(q.xz) - 0.5;\n    float d24 = length(q.yz) -", "\n    float d = length(p) - 0.5;\n    float id = floor(gID);\n    float blink = mod(id, 2.0);\n    if(blink > 0.5){\n        d = abs(d);\n    }\n    return d;\n}\n\n// Recreating part of the distance function to obtain the segment IDs, which in turn is used\n// to create the blink effect.\nfloat", "\n    float t = 0.0;\n    for(int i = 0; i < 128; i++){\n        vec3 p = o + r * t;\n        float d = map(p);\n        if(d < 0.001){\n            return t;\n        }\n        t += d;\n    }\n    return 1000.0;\n}\n\n// Calculate the normal of the surface at a point.\nvec", "\n    float res = 1.0;\n    float tmax = 100.0;\n    float tmin = 0.001;\n    float tstep = tmax/100.0;\n    for(float ti = tmin; ti < tmax; ti += tstep){\n        float h = map(ro + lp*ti);\n        if(h < 0.001){\n            return 0.0;\n        }\n        float y = h*h/(2.0*k*ti);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 32.0*d/ti);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// The main raymarching function.\nfloat", "\n    vec3 e = vec3(0.001, 0., 0.);\n    vec3 n = vec3(0.);\n    n += sdf(p + e.yxx) - sdf(p - e.yxx);\n    n += sdf(p + e.xyx) - sdf(p - e.xyx);\n    n += sdf(p + e.xxy) - sdf(p - e.xxy);\n    n.x = abs(n.x);\n    n.y = abs(n.y);\n    n.z = abs(n.z);\n    n = normalize(n);\n    edge = min(min(n.x, n.y), n.z);\n    crv = (sdf(p + e.yxx) + sdf(p - e.yxx) + sdf(p + e.xyx) + sdf(p - e.xyx) + sdf(p + e.xxy) + sdf(p - e.xxy)) / 6.0;\n    return n;\n}\n\n// Normal calculation, with some edging and curvature bundled in.\nvec", "\n    vec3 v = p3 - t;\n    return vec4(dot(v, m[0]), dot(v, m[1]), dot(v, m[2]), 1.0);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n   ", "\n    float d = p.x;\n    d = max(d, -p.y);\n    d = max(d, p.y - 1.0);\n    return d;\n}\n\n// Distance to the pattern.\nfloat", "\n    float r = length(q);\n    float theta = atan(q.y, q.x);\n    if(dir == 1.){\n        return theta;\n    }else{\n        return r;\n    }\n}\n\n// Get the color of the arc pixel.\nvec", "\n    vec3 v = p3 - t;\n    vec3 b = vec3(dot(v, n[0]), dot(v, n[1]), dot(v, n[2]));\n    return vec4(b.x, b.y, b.z, 1.0 - b.x - b.y - b.z);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n  vec4 v = q - p;\n  vec4 w = r - p;\n  float a = dot(v, v);\n  float b = dot(v, w);\n  float c = dot(w, w);\n  float bb4ac = b * b - a * c;\n  if (bb4ac <= 0.0) return 0.0;\n  return (a * c - b * b) / bb4ac;\n}\n\n// Find the (squared) distance to the line segment in R3 but\n// using homogeneous coordinates.\nfloat", "\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float s = sin(a * 10.0);\n    float c = cos(a * 10.0);\n    float r = lW * 0.5;\n    float w = r * (1.0 - s * s);\n    float d1 = d - w;\n    float d2 = d + w;\n    float d3 = d1 * d1 + r * r;\n    float d4 = d2 * d2 + r * r;\n    float d5 = sqrt(d3) * sqrt(d4);\n    float d6 = d5 / (d1 + d2);\n    float d7 = d6 * 0.5;\n    float d8 = d7 * c;\n    float d9 = d7 * s;\n    float d10 = d8 + d9;\n    float d11 = d10 * 0.5;\n    float d12 = d11 * 0.5;\n    float d13 = d12 * 0.5;\n    float d14 = d13 * 0.5;\n    float d15 = d14 * 0.5;\n    float d16 = d15 * 0.5;\n    float d17 = d16 * 0.5;\n    float d18 = d17 * 0.5;\n    float d19 = d18 * 0.5;\n    float d20 = d19 * 0.5;\n    float d21 = d20 * 0.5;\n    float d22 = d21 * 0.5;\n    float d23 = d22 * 0.5;\n    float d24 = d23 * 0.5;\n    float d25 = d24 * 0.5;\n    float d26 = d25 * 0.5;\n    float d27 = d26 * 0.5;\n    float d28 = d27 * 0.5;\n    float d", "\n    vec2 grid = fract(p);\n    vec2 d = abs(ddx) + abs(ddy);\n    vec2 offset = vec2(0.5, 0.5) - grid;\n    vec2 r = vec2(\n        dot2(greaterThan(d.xy, offset.xy)),\n        dot2(greaterThan(d.yx, offset.yx))\n    );\n    return r.x * r.y;\n}\n\n// grid ratio\nfloat", "\n    vec2 p = n;\n    float d = dot(p,p);\n    mr = p;\n    mg = p;\n    for( int i=0; i<4; i++ )\n    {\n        p.x = n.x;\n        p.y = f.y;\n        float d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = f.x;\n        p.y = n.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = f.x;\n        p.y = f.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = n.x;\n        p.y = n.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = n.x;\n        p.y = f.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = f.x;\n        p.y = n.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = f.x;\n        p.y = f.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = n.x;\n        p.y = n.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = n.x;\n        p.y = f.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=", "\n    return vec2(lerp(pos_inicial.x, pos_final.x, t), lerp(pos_inicial.y, pos_final.y, t));\n}\n\n//////////// POSICAO PONTOS\n\n//////////// POSICAO PONTOS\nvec", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// vec3 to vec3 hash.\nvec", "\n  p = fract(p * vec2(123.34, 345.45));\n  p += dot(p, p + 23.45);\n  return fract(p.x * p.y);\n}\n\n// vec2 to vec2 hash.\nfloat", "\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p0;\n    vec2 c = p2 - p1;\n    float a2 = dot(a, a);\n    float b2 = dot(b, b);\n    float c2 = dot(c, c);\n    float denom = a2 * (b2 + c2 - a2) + b2 * c2;\n    vec2 ab = (a2 * b + a * b2 + a * c2) / denom;\n    vec2 bc = (b2 * c + b * c2 + b * a2) / denom;\n    vec2 ca = (c2 * a + c * a2 + c * b2) / denom;\n    return ab * a2 + bc * b2 + ca * c2;\n}\n\n// Triangle's circumcenter: The center of the circumscribed circle, which in essence is the\n// smallest circle that can contain a triangle.\nvec", "\n    float a = length(p0 - p1);\n    float b = length(p1 - p2);\n    float c = length(p2 - p0);\n    float s = (a + b + c) / 2.0;\n    return sqrt(s * (s - a) * (s - b) * (s - c)) / s;\n}\n\n// The radius of the triangle's circumcircle:\nfloat", "\n    vec2 v1 = h2 - h1;\n    vec2 v2 = h3 - h1;\n    vec2 v3 = h3 - h2;\n    float a = dot(v1, v1);\n    float b = dot(v2, v2);\n    float c = dot(v3, v3);\n    float d = dot(v1, v2);\n    float e = dot(v1, v3);\n    float f = dot(v2, v3);\n    float g = dot(h1, h1);\n    float h = dot(h2, h2);\n    float i = dot(h3, h3);\n    float j = dot(h1, h2);\n    float k = dot(h1, h3);\n    float l = dot(h2, h3);\n    float m = a * (b + c - a) * (a + b - c) * (a + c - b);\n    float n = b * (a + c - b) * (b + a - c) * (b + c - a);\n    float o = c * (a + b - c) * (c + a - b) * (c + b - a);\n    float p = d * (e + f - d) * (d + e - f) * (d + f - e);\n    float q = e * (d + f - e) * (e + d - f) * (e + f - d);\n    float r = f * (d + e - f) * (f + d - e) * (f + e - d);\n    float s = g * (h + i - g) * (g + h - i) * (g + i - h);\n    float t = h * (g + i - h) * (h + g - i) * (h + i - g);\n    float u = i * (g + h - i) * (i + g - h) * (i + h - g);\n    float v = j * (k + l - j) * (j + k - l) * (j + l - k);\n    float w = k * (j + l - k)", "\n    vec2 p0 = p;\n    vec2 p1 = p;\n    vec2 p2 = p;\n    vec2 p3 = p;\n    vec2 p4 = p;\n    vec2 p5 = p;\n    vec2 p6 = p;\n    vec2 p7 = p;\n    vec2 p8 = p;\n    vec2 p9 = p;\n    vec2 p10 = p;\n    vec2 p11 = p;\n    vec2 p12 = p;\n    vec2 p13 = p;\n    vec2 p14 = p;\n    vec2 p15 = p;\n    vec2 p16 = p;\n    vec2 p17 = p;\n    vec2 p18 = p;\n    vec2 p19 = p;\n    vec2 p20 = p;\n    vec2 p21 = p;\n    vec2 p22 = p;\n    vec2 p23 = p;\n    vec2 p24 = p;\n    vec2 p25 = p;\n    vec2 p26 = p;\n    vec2 p27 = p;\n    vec2 p28 = p;\n    vec2 p29 = p;\n    vec2 p30 = p;\n    vec2 p31 = p;\n    vec2 p32 = p;\n    vec2 p33 = p;\n    vec2 p34 = p;\n    vec2 p35 = p;\n    vec2 p36 = p;\n    vec2 p37 = p;\n    vec2 p38 = p;\n    vec2 p39 = p;\n    vec2 p40 = p;\n    vec2 p41 = p;\n    vec2 p42 = p;\n    vec2 p43 = p;\n    vec2 p44 = p;\n    vec2 p45 = p;\n    vec2 p46 = p;\n    vec2", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col, 1.0);\n}\n", "\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    /////////////////////////////////////////////////////////////////////////////\n    // Compute the intersection between the ray and the sphere.\n    //\u8ba1\u7b97\u5c04\u7ebf\u548c\u7403\u4f53\u4e4b\u95f4\u7684\u4ea4\u70b9\u3002\n    /////////////////////////////////////////////////////////////////////////////\n    vec3 L = sph.center - ray.origin;\n    float tca = dot(L, ray.direction);\n    if (tca < 0.0) return false;\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > sph.radius * sph.radius) return false;\n    float thc = sqrt(sph.radius * sph.radius - d2);\n    t = tca - thc;\n    if (t < tmin || t > tmax) {\n        t = tca + thc;\n        if (t < tmin || t > tmax) return false;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Compute the normal at the intersection point.\n    //\u8ba1\u7b97\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u3002\n    /////////////////////////////////////////////////////////////////////////////\n    hitPos = ray.origin + t * ray.direction;\n    hitNormal = normalize(hitPos - sph.center);\n\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n//\u8ba1\u7b97\u5e73\u9762\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n//\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n//\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pl, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec", "\n    // Compute the intersection of the ray and the sphere.\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - a * c;\n    if ( discriminant > 0.0 )\n    {\n        float temp = (-b - sqrt( discriminant )) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            return true;\n        }\n        temp = (-b + sqrt( discriminant )) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, out float t )\n{\n    // Compute the intersection of the ray and the sphere.\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - a * c;\n    if ( discriminant > 0.0 )\n    {\n        float temp = (-b - sqrt( discriminant )) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            t = temp;\n            return true;\n        }\n        temp = (-b + sqrt( discriminant )) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            t = temp;\n            return true;\n        }\n    }\n    return", "\n    /////////////////////////////////////////////////////////////////////////////\n    // TODO:\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219", "\n    vec2 d0 = p1 - p0;\n    vec2 d1 = p2 - p1;\n    vec2 d2 = p0 - p2;\n\n    vec2 d0d1 = d0 * d1;\n    vec2 d1d2 = d1 * d2;\n    vec2 d2d0 = d2 * d0;\n\n    vec2 d0d1d2 = d0d1 * d2;\n    vec2 d1d2d0 = d1d2 * d0;\n    vec2 d2d0d1 = d2d0 * d1;\n\n    vec2 d0d1d2d0 = d0d1d2 * d0;\n    vec2 d1d2d0d1 = d1d2d0 * d1;\n    vec2 d2d0d1d2 = d2d0d1 * d2;\n\n    vec2 d0d1d2d0d1 = d0d1d2d0 * d1;\n    vec2 d1d2d0d1d2 = d1d2d0d1 * d2;\n    vec2 d2d0d1d2d0 = d2d0d1d2 * d0;\n\n    vec2 d0d1d2d0d1d2 = d0d1d2d0d1 * d2;\n    vec2 d1d2d0d1d2d0 = d1d2d0d1d2 * d0;\n    vec2 d2d0d1d2d0d1 = d2d0d1d2d0 * d1;\n\n    vec2 d0d1d2d0d1d2d0 = d0d1d2d0d1d2 * d0;\n    vec2 d1d2d0d1d2d0d1 = d1d2d0d1d2d0 * d1;\n    vec2 d2d0d1d2d0d1d2 = d2d0d1d2d0d1", "\n    vec3 p01 = mix(p0,p1,0.5);\n    vec3 p12 = mix(p1,p2,0.5);\n    vec3 p23 = mix(p2,p3,0.5);\n    vec3 p012 = mix(p01,p12,0.5);\n    vec3 p123 = mix(p12,p23,0.5);\n    vec3 p0123 = mix(p012,p123,0.5);\n    vec3 p01234 = mix(p0123,p3,0.5);\n    return bound3(p01234-vec3(0.001),p01234+vec3(0.001));\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float t )\n{\n    vec3 p01 = mix(p0,p1,t);\n    vec3 p12 = mix(p1,p2,t);\n    vec3 p23 = mix(p2,p3,t);\n    vec3 p012 = mix(p01,p12,t);\n    vec3 p123 = mix(p12,p23,t);\n    vec3 p0123 = mix(p012,p123,t);\n    vec3 p01234 = mix(p0123,p3,t);\n    return bound3(p01234-vec3(0.001),p01234+vec3(0.001));\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = vec3(uv,0.5+0.5*sin(iTime));\n    fragColor = vec4(col,1.0);\n}", "\n    return -0.5 * (cos(k * PI) - 1.0);\n}\n\n/**\n * Sinusoidal In Easing Curve\n */\nfloat", "\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod(i, 289.0);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n    vec3 x = 2.0 * fract(p *", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iGlobalTime;\n    float r = length(uv-0.5);\n    float a = atan(uv.y-0.5,uv.x-0.5);\n    float d = r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*", "\n    return vec2(coord.x / res.x * 4.0 - 2.0, coord.y / res.y * 4.0 - 2.0);\n}\n\n// Compute the number of iterations of the Julia set for a given point.\nint", "\n    // filter kernel\n    const vec2 w = vec2(1.0);\n    // analytical integral (box filter)\n    // vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    bvec2 b = bvec2( mod( floor(p.x), 2.0 ) == mod( floor(p.y), 2.0 ) );\n    float i = float( b.x == b.y );\n    return i;\n}\n\nfloat", "\n    float r = rgb.r;\n    float g = rgb.g;\n    float b = rgb.b;\n\n    float max = max(r, max(g, b));\n    float min = min(r, min(g, b));\n\n    float h = (max - min) / (max + min);\n    float c = (max + min) / 2.0;\n    float v = max;\n\n    return vec3(h, c, v);\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3( map(p+h.xyy).x - map(p-h.xyy).x,\n                            map(p+h.yxy).x - map(p-h.yxy).x,\n                            map(p+h.yyx).x - map(p-h.yyx).x ) );\n}\n\n// Distance estimator.\nfloat", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// random hash\nfloat", "\n    float d = length(pos);\n    float w = width * 0.5;\n    float r = radius * 0.5;\n    float dd = d - r;\n    float ww = w * 0.5;\n    float ddw = dd - ww;\n    float ddww = ddw * ddw;\n    float ddww2 = ddww * ddww;\n    float ddww3 = ddww2 * ddw;\n    float ddww4 = ddww3 * ddw;\n    float ddww5 = ddww4 * ddw;\n    float ddww6 = ddww5 * ddw;\n    float ddww7 = ddww6 * ddw;\n    float ddww8 = ddww7 * ddw;\n    float ddww9 = ddww8 * ddw;\n    float ddww10 = ddww9 * ddw;\n    float ddww11 = ddww10 * ddw;\n    float ddww12 = ddww11 * ddw;\n    float ddww13 = ddww12 * ddw;\n    float ddww14 = ddww13 * ddw;\n    float ddww15 = ddww14 * ddw;\n    float ddww16 = ddww15 * ddw;\n    float ddww17 = ddww16 * ddw;\n    float ddww18 = ddww17 * ddw;\n    float ddww19 = ddww18 * ddw;\n    float ddww20 = ddww19 * ddw;\n    float ddww21 = ddww20 * ddw;\n    float ddww22 = ddww21 * ddw;\n    float ddww23 = ddww22 * ddw;\n    float ddww24 = ddww23 * ddw;\n    float ddww25 =", "\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  *", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ro = vec3(0,0,0);\n    vec3 rd = normalize(vec3(uv,1));\n    float r = 0.5;\n    float t = intersect(ro,rd,r);\n    if(t>0.0){\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p,r);\n        vec3 c = vec3(0.5)+0.5*n;\n        fragColor = vec4(c,1);\n    }else{\n        fragColor = vec4(0,0,0,1);\n    }\n}\n\nfloat", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, vec3(1.0, 57.0, 21.0));\n    vec3 u = vec3(n+13.0, n+51.0, n+19.0);\n    vec3 r = fract(u*0.1);\n    float rx = mix(mix(dot(r, vec3(1.0, 57.0, 21.0)), dot(r, vec3(4.0, 58.0, 22.0)), f.x), mix(dot(r, vec3(17.0, 59.0, 23.0)), dot(r, vec3(19.0, 61.0, 25.0)), f.x), f.y);\n    float ry = mix(mix(dot(r, vec3(13.0, 60.0, 24.0)), dot(r, vec3(15.0, 62.0, 26.0)), f.x), mix(dot(r, vec3(29.0, 63.0, 27.0)), dot(r, vec3(31.0, 65.0, 29.0)), f.x), f.y);\n    float rz = mix(mix(dot(r, vec3(41.0, 67.0, 30.0)), dot(r, vec3(43.0, 69.0, 32.0)), f.x), mix(dot(r, vec3(53.0, 71.0, 34.0)), dot(r, vec3(57.0, 73.0, 35.0)), f.x), f.y);\n    return (mix(rx, ry, f.z)+(1.0-f.z)*r", "\n    // Tile the point in log-spherical space.\n    tp = log(p);\n    tp.xz = mod(tp.xz, 2.0 * PI);\n\n    // Rotate the point in log-spherical space.\n    rp = tp;\n    rp.x = -rp.x;\n\n    // Compute the scaling factor.\n    mul = exp(length(tp) - 1.0);\n\n    // Compute the un-tiled point in log-spherical space.\n    sp = tp / mul;\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`: point in log-spherical space without offset or tiling\n- out `tp`: point in tiled log-spherical space\n- out `rp`: point in rotated tiled log-spherical space\n- out `mul`: total amount of scaling applied at this point\n*/\nvoid tile(in vec2 p, out vec2 sp, out vec2 tp, out vec2 rp, out float mul)\n{\n    // Tile the point in log-spherical space.\n    tp = mod(p, 2.0 * PI);\n\n    // Rotate the point in log-spherical space.\n    rp = tp;\n    rp.x = -rp.x;\n\n    // Compute the scaling factor.\n    mul = exp(length(tp) - 1.0);\n\n    // Compute the un-tiled point in log-spherical space.\n    sp = tp / mul;\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`: point in log-spherical space without offset or tiling\n- out `tp`: point in tiled log-spherical space\n- out `rp`: point in rotated tiled log-spherical space\n- out `mul`: total amount of scaling applied at this point\n*/\nvoid tile(in float p, out float sp, out float tp, out float rp,", "\n    vec2 d = vec2(1000.0, 0.0);\n    d = opU(d, vec2(SDFSphere(p - vec3(0.0, 0.0, 0.0), 1.0), 1.0));\n    d = opU(d, vec2(SDFSphere(p - vec3(0.0, 0.0, 0.0), 1.0), 2.0));\n    return d;\n}\n\nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n    // 1.0 is the size of the square\n    // 0.5 is the size of the angled square\n    // 0.25 is the size of the angled square\n    // 0.125 is the size of the angled square\n    // 0.0625 is the size of the angled square\n    // 0.03125 is the size of the angled square\n    // 0.015625 is the size of the angled square\n    // 0.0078125 is the size of the angled square\n    // 0.00390625 is the size of the angled square\n    // 0.001953125 is the size of the angled square\n    // 0.0009765625 is the size of the angled square\n    // 0.00048828125 is the size of the angled square\n    // 0.000244140625 is the size of the angled square\n    // 0.0001220703125 is the size of the angled square\n    // 0.00006103515625 is the size of the angled square\n    // 0.000030517578125 is the size of the angled square\n    // 0.0000152587890625 is the size of the angled square\n    // 0.00000762939453125 is the size of the angled square\n    // 0.000003814697265625 is the size of the angled square\n    // 0.0000019073486328125 is the size of the angled square\n    // 0.00000095367431640625 is the size of the angled square\n    // 0.000", "\n    vec3 boxPos = pos - vec3(0.0, 0.0, 0.0);\n    float dist = length(boxPos) - 0.5;\n    float matID = 1.0;\n    return vec2(dist, matID);\n}\n\n// returns the distance to our rotating box and the its associated material ID packed into a vec2\nvec", "\n    float dist = length(pos - vec3(0.0, 0.0, 0.0)) - 0.5;\n    return vec2(dist, 0.0);\n}\n\n// returns the distance to the ground plane and the associated material ID packed into a vec2\nvec", "\n    vec2 res = vec2(100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec4 color = vec4(0.0);\n    float dist = 0.0;\n    float totalDist = 0.0;\n    float t = 0.0;\n    float maxDist = 100.0;\n    float maxSteps = 100.0;\n    float eps = 0.001;\n    float lightIntensity = 0.5;\n    float ambientIntensity = 0.1;\n    float specularIntensity = 0.5;\n    float specularPower = 10.0;\n    float shadowIntensity = 0.5;\n    float shadowMaxDist = 10.0;\n    float shadowMaxSteps = 100.0;\n    float shadowEps = 0.001;\n    float shadowBias = 0.001;\n    float shadowFade = 0.001;\n    float shadowFadeDist = 10.0;\n    float shadowFadeSteps = 100.0;\n    float shadowFadeEps = 0.001;\n    float shadowFadeBias = 0.001;\n    float shadowFadeFade = 0.001;\n    float shadowFadeFadeDist = 10.0;\n    float shadowFadeFadeSteps = 100.0;\n    float shadowFadeFadeEps = 0.001;\n    float shadowFadeFadeBias = 0.001;\n    float shadowFadeFadeFade = 0.001;\n    float shadowFadeFadeFadeDist = 10.0;\n    float shadowFadeFadeFadeSteps = 100.0;\n    float shadowFadeFadeFadeEps = 0.001;\n    float shadowFadeFadeFadeBias = 0.001;\n    float shadowFadeFadeFadeFade = 0.001;\n    float shadowFadeFadeFadeFadeDist = 10.0;\n    float shadowFadeFadeFadeFadeSteps = 100.0;\n    float shadowFadeFadeFadeFadeEps = 0.001;", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "\n    return dot(pos, plane.normal) + plane.distance;\n}\n\n/// @brief Get signed-distance funciton weight value of sphere.\nfloat", "\n    ivec3 ix0 = ix;\n    ivec3 ix1 = ix0 + 1;\n    vec3 fx0 = fx;\n    vec3 fx1 = fx - ivec3(1);\n    vec3 fx2 = fx - ivec3(2);\n    vec3 fx3 = fx - ivec3(3);\n    vec3 fx4 = fx - ivec3(4);\n    vec3 fx5 = fx - ivec3(5);\n    vec3 fx6 = fx - ivec3(6);\n    vec3 fx7 = fx - ivec3(7);\n    vec3 fx8 = fx - ivec3(8);\n    vec3 fx9 = fx - ivec3(9);\n    vec3 fx10 = fx - ivec3(10);\n    vec3 fx11 = fx - ivec3(11);\n    vec3 fx12 = fx - ivec3(12);\n    vec3 fx13 = fx - ivec3(13);\n    vec3 fx14 = fx - ivec3(14);\n    vec3 fx15 = fx - ivec3(15);\n    vec3 fx16 = fx - ivec3(16);\n    vec3 fx17 = fx - ivec3(17);\n    vec3 fx18 = fx - ivec3(18);\n    vec3 fx19 = fx - ivec3(19);\n    vec3 fx20 = fx - ivec3(20);\n    vec3 fx21 = fx - ivec3(21);\n    vec3 fx22 = fx - ivec3(22);\n    vec3 fx23 = fx - ivec3(23);\n    vec3 fx24 = fx - ivec3(24);\n    vec3 fx25 = f", "\n    float f = 0.0;\n    float amp = 0.5;\n    float freq = 1.0;\n    for(int i = 0; i < 5; i++){\n        f += amp * noise(fxyz);\n        fxyz *= freq;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return f;\n}\n\n// 3D Perlin Noise\nfloat", "\n    p.xz = abs(p.xz);\n    p.x -= clamp( p.x, 0.0, h );\n    return length(p) - r;\n}\n\nfloat", "\n    float sphere = length(p) - 1.0;\n    float plane = p.y;\n    float box = length(max(abs(p.xz) - vec2(1.0, 0.5), 0.0));\n    float d = min(sphere, plane);\n    d = min(d, box);\n    return d;\n}\n\n/***********************\nThe normal function.\nWe need to know the normal of the surface at a given point.\n\nThe normal is the gradient of the SDF function.\n***********************/\nvec", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(\n        map(p + eps.xyy) - map(p - eps.xyy),\n        map(p + eps.yxy) - map(p - eps.yxy),\n        map(p + eps.yyx) - map(p - eps.yyx)\n    ));\n}\n\n// Compute the color of a point on the surface of our objects\nvec", "\n    return max(dot(n,l),0.0)*d;\n}\n\nfloat", "\n    float k0 = dot(rd,rd);\n    float k1 = dot(rd,ro);\n    float k2 = dot(ro,ro) - ra*ra;\n    float h = k1*k1 - k0*k2;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    float t1 = -k1 - h;\n    float t2 = -k1 + h;\n    if( t1<0.0 ) return t2;\n    if( t2<0.0 ) return t1;\n    return min(t1,t2);\n}\n\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat", "\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = floor(a);\n    vec2 f = fract(a);\n    float va = 0.0;\n    float vb = 0.0;\n    float va1 = 0.0;\n    float va2 = 0.0;\n    float vb1 = 0.0;\n    float vb2 = 0.0;\n    if (i.x+i.y < 1.0) {\n        va = mix( dot(hash22(i+vec2(0.0,0.0)),f-vec2(0.0,0.0) ),\n                  dot(hash22(i+vec2(1.0,0.0)),f-vec2(1.0,0.0) ), f.x);\n        vb = mix( dot(hash22(i+vec2(0.0,1.0)),f-vec2(0.0,1.0) ),\n                  dot(hash22(i+vec2(1.0,1.0)),f-vec2(1.0,1.0) ), f.x);\n    } else {\n        va = mix( dot(hash22(i+vec2(1.0,0.0)),f-vec2(1.0,0.0) ),\n                  dot(hash22(i+vec2(0.0,0.0)),f-vec2(0.0,0.0) ), f.x);\n        vb = mix( dot(hash22(i+vec2(1.0,1.0)),f-vec2(1.0,1.0) ),\n                  dot(hash22(i+vec2(0.0,1.0)),f-vec2(0.0,1.0) ), f.x);\n    }\n    va1 = mix( va, vb, f.y );\n    if (i.x+i.y < 1.0) {\n        va = mix( dot", "\n    // Set the background color.\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n\n    // Set the camera position.\n    g_Camera.SetPosition(0.0f, 0.0f, 10.0f);\n\n    // Set the camera target.\n    g_Camera.SetTarget(0.0f, 0.0f, 0.0f);\n\n    // Set the camera projection parameters.\n    g_Camera.SetProjection(45.0f, 1.0f, 1.0f, 100.0f);\n\n    // Set the camera viewport.\n    g_Camera.SetViewport(0, 0, g_ViewportWidth, g_ViewportHeight);\n\n    // Set the camera aspect ratio.\n    g_Camera.SetAspectRatio((float)g_ViewportWidth / (float)g_ViewportHeight);\n\n    // Set the camera frustum.\n    g_Camera.SetFrustum(45.0f, 1.0f, 1.0f, 100.0f);\n\n    // Set the camera view.\n    g_Camera.SetView(g_Camera.GetPosition(), g_Camera.GetTarget(), g_Camera.GetUp());\n\n    // Set the camera projection.\n    g_Camera.SetProjection(45.0f, 1.0f, 1.0f, 100.0f);\n\n    // Set the camera viewport.\n    g_Camera.SetViewport(0, 0, g_ViewportWidth, g_ViewportHeight);\n\n    // Set the camera aspect ratio.\n    g_Camera.SetAspectRatio((float)g_ViewportWidth / (float)g_ViewportHeight);\n\n    // Set the camera frustum.\n    g_Camera.SetFrustum(45.0f, 1.0f, 1.0f, 100.0f);\n\n    // Set the camera view.\n    g", "\n    // Compute the intersection between the ray and the sphere\n    // (see the lecture slides for the derivation)\n    //\n    // The ray is given by:\n    //\n    //  P(t) = ray.origin + t * ray.direction\n    //\n    // The sphere is given by:\n    //\n    //  (P(t) - sph.center) dot (P(t) - sph.center) = sph.radius * sph.radius\n    //\n    // The above equation can be rewritten as:\n    //\n    //  t^2 * ray.direction dot ray.direction + 2 * t * ray.direction dot (ray.origin - sph.center) + (ray.origin - sph.center) dot (ray.origin - sph.center) - sph.radius * sph.radius = 0\n    //\n    // The quadratic equation is:\n    //\n    //  a * t^2 + b * t + c = 0\n    //\n    // where:\n    //\n    //  a = ray.direction dot ray.direction\n    //  b = 2 * ray.direction dot (ray.origin - sph.center)\n    //  c = (ray.origin - sph.center) dot (ray.origin - sph.center) - sph.radius * sph.radius\n    //\n    // The quadratic equation can be solved using the quadratic formula:\n    //\n    //  t = (-b +/- sqrt(b^2 - 4 * a * c)) / (2 * a)\n    //\n    // The smaller root is the one we are looking for.\n    //\n    // If the smaller root is between tmin and tmax, then the ray intersects\n    // the sphere.\n    //\n    // If the smaller root is outside the range [tmin, tmax], then the ray\n    // misses the sphere.\n    //\n    // If the smaller root is inside the range [tmin, tmax], then the ray\n    // intersects the sphere.\n    //\n    // If the smaller root is negative, then the ray misses the sphere.\n    //\n    // If the smaller root is positive, then the ray intersects the sphere", "\n\tvec3_t L = ray.origin - sph.center;\n\tfloat a = dot( ray.direction, ray.direction );\n\tfloat b = 2.0 * dot( ray.direction, L );\n\tfloat c = dot( L, L ) - sph.radius * sph.radius;\n\tfloat disc = b * b - 4.0 * a * c;\n\n\tif ( disc < 0.0 )\n\t\treturn false;\n\n\tfloat t = ( -b - sqrt( disc ) ) / ( 2.0 * a );\n\n\tif ( t < tmin )\n\t\tt = ( -b + sqrt( disc ) ) / ( 2.0 * a );\n\n\tif ( t < tmin || t > tmax )\n\t\treturn false;\n\n\treturn true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t plane, in Ray_t ray, in float tmin, in float tmax )\n{\n\tfloat denom = dot( plane.normal, ray.direction );\n\n\tif ( abs( denom ) < 0.0001 )\n\t\treturn false;\n\n\tfloat t = dot( plane.point - ray.origin, plane.normal ) / denom;\n\n\tif ( t < tmin || t > tmax )\n\t\treturn false;\n\n\treturn true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a triangle and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax )\n{\n\tvec3_t edge1 = tri.v1 - tri.v0;\n\tvec3_t edge2 = tri.v2 - tri.v0;\n\tvec3_t pvec = cross( ray.direction, edge2 );\n\tfloat det = dot( edge1, p", "\n    /////////////////////////////////////////////////////////////////////////////\n    // TODO: Implement this function.\n    /////////////////////////////////////////////////////////////////////////////\n    hasHit = false;\n    hitPos = vec3(0.0);\n    hitNormal = vec3(0.0);\n    k_rg = vec3(0.0);\n\n    /////////////////////////////////////////////////////////////////////////////\n    // End of TODO.\n    /////////////////////////////////////////////////////////////////////////////\n\n    return vec3(0.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes the color of the pixel at (x, y) by casting a ray into the scene\n// and returning the color computed at the nearest intersection point.\n/////////////////////////////////////////////////////////////////////////////\nvec", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nmat", "\n    // the color of the ray\n    vec3 color = vec3(0.0);\n\n    // the distance the ray has traveled\n    float dist = 0.0;\n\n    // the direction of the ray\n    vec3 ray_dir = dir;\n\n    // the position of the ray\n    vec3 ray_pos = start;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_i = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_i = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_l = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_l = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_i_prev = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_i_prev = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_l_prev = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_l_prev = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_i_prev_prev = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_i_prev_prev = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_l_prev_prev = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_l_prev_prev = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_i_prev", "\n    vec3 sample_dir = normalize(sample_pos - surface_normal);\n    float sample_dist = length(sample_pos - surface_normal);\n    float sample_angle = dot(sample_dir, light_dir);\n\n    float sample_intensity = max(0.0, sample_angle);\n    float sample_attenuation = pow(sample_dist, 2.0);\n\n    return sample_intensity * sample_attenuation * background_col;\n}\n\n/*\nThis is the main function that renders the planet.\n\nIt takes in the position of the planet, the camera, the light direction, the background color, and the time.\n\nIt returns the color of the planet.\n*/\nvec", "\n    vec3 color = vec3(0.0);\n    float dist = 0.0;\n    float depth = 0.0;\n    float shadow = 0.0;\n    float shadow_dist = 0.0;\n    float shadow_depth = 0.0;\n    float shadow_shadow = 0.0;\n    float shadow_shadow_dist = 0.0;\n    float shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camDir = normalize(vec3(uv, 1.0));\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n\n    // get the color of the atmosphere\n    vec3 color = atmosphere(camPos, camDir, lightDir);\n\n    // output the color\n    fragColor = vec4(color, 1.0);\n}\n", "\n    vec3 s0_r0 = s0 - r0;\n    float b = dot(s0_r0, rd);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    float b2_ac = (b * b) - c;\n    if (b2_ac > 0.0) {\n        float t = b - sqrt(b2_ac);\n        if (t > 0.0) {\n            return t;\n        }\n    }\n    return -1.0;\n}\n\n//-----------------------------------------------------------------------\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 position = vec3(0.0);\n    float distance = 0.0;\n    float specular = 0.0;\n    float roughness = 0.0;\n    float metallic = 0.0;\n    float occlusion = 0.0;\n    float alpha = 0.0;\n    float ao = 0.0;\n    float shadow = 0.0;\n    float shadowDistance = 0.0;\n    float shadowFade = 0.0;\n    float shadowFadeDistance = 0.0;\n    float shadowFadeFactor = 0.0;\n    float shadowFadeFactor2 = 0.0;\n    float shadowFadeFactor3 = 0.0;\n    float shadowFadeFactor4 = 0.0;\n    float shadowFadeFactor5 = 0.0;\n    float shadowFadeFactor6 = 0.0;\n    float shadowFadeFactor7 = 0.0;\n    float shadowFadeFactor8 = 0.0;\n    float shadowFadeFactor9 = 0.0;\n    float shadowFadeFactor10 = 0.0;\n    float shadowFadeFactor11 = 0.0;\n    float shadowFadeFactor12 = 0.0;\n    float shadowFadeFactor13 = 0.0;\n    float shadowFadeFactor14 = 0.0;\n    float shadowFadeFactor15 = 0.0;\n    float shadowFadeFactor16 = 0.0;\n    float shadowFadeFactor17 = 0.0;\n    float shadowFadeFactor18 = 0.0;\n    float shadowFadeFactor19 = 0.0;\n    float shadowFadeFactor20 = 0.0;\n    float shadowFadeFactor21 = 0.0;\n    float shadowFadeFactor22 = 0.0;\n    float shadowFadeFactor23 = 0.0;\n    float shadowFadeFactor24 = 0.0;\n    float shadowFadeF", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = length(uv-0.5);\n    float a = atan(uv.y-0.5,uv.x-0.5);\n    float d = abs(r-0.25);\n    float f = smoothstep(0.0,0.01,d);\n    float s = sin(a*10.0+t*10.0);\n    float c = cos(a*10.0+t*10.0);\n    float l = length(uv-vec2(0.5,0.5));\n    float aa = atan(uv.y-0.5,uv.x-0.5);\n    float b = sin(aa*10.0+t*10.0);\n    float c2 = cos(aa*10.0+t*10.0);\n    float d2 = abs(l-0.25);\n    float f2 = smoothstep(0.0,0.01,d2);\n    float s2 = sin(aa*10.0+t*10.0);\n    float c3 = cos(aa*10.0+t*10.0);\n    float l2 = length(uv-vec2(0.5,0.5));\n    float aa2 = atan(uv.y-0.5,uv.x-0.5);\n    float b2 = sin(aa2*10.0+t*10.0);\n    float c4 = cos(aa2*10.0+t*10.0);\n    float d4 = abs(l2-0.25);\n    float f4 = smoothstep(0.0,0.01,d4);\n    float s4 = sin(aa2*10.0+t*10.0);\n    float c5 = cos(aa2*10.0+t*10.0);\n    float l3 = length(uv-vec2(", "\n    vec3 sample_color = vec3(0.0);\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    vec3 ray_position = ray_origin;\n    float ray_length = 0.0;\n    float ray_length_squared = 0.0;\n    float ray_length_squared_max = RAY_LENGTH_MAX * RAY_LENGTH_MAX;\n    float ray_length_squared_min = RAY_LENGTH_MIN * RAY_LENGTH_MIN;\n    float ray_length_squared_min_inv = 1.0 / ray_length_squared_min;\n    float ray_length_squared_max_inv = 1.0 / ray_length_squared_max;\n    float ray_length_squared_min_inv_sq = ray_length_squared_min_inv * ray_length_squared_min_inv;\n    float ray_length_squared_max_inv_sq = ray_length_squared_max_inv * ray_length_squared_max_inv;\n    float ray_length_squared_min_inv_sq_inv = 1.0 / ray_length_squared_min_inv_sq;\n    float ray_length_squared_max_inv_sq_inv = 1.0 / ray_length_squared_max_inv_sq;\n    float ray_length_squared_min_inv_sq_inv_sq = ray_length_squared_min_inv_sq_inv * ray_length_squared_min_inv_sq_inv;\n    float ray_length_squared_max_inv_sq_inv_sq = ray_length_squared_max_inv_sq_inv * ray_length_squared_max_inv_sq_inv;\n    float ray_length_squared_min_inv_sq_inv_sq_inv = 1.0 / ray_length_squared_min_inv_sq_inv_sq;\n    float ray_length_squared_max_inv_sq_inv_sq_inv = 1.0 / ray_length_squared_max_inv_sq", "\n    vec2 q = p*2.0;\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n    float d = (i.x+i.y)%2.0;\n    float m = (i.x+i.y+d)%2.0;\n    float n = (i.x+i.y+1.0-d)%2.0;\n    float o = (i.x+i.y+1.0-m)%2.0;\n    float s = (i.x+i.y+1.0-n)%2.0;\n    float t = (i.x+i.y+1.0-o)%2.0;\n    float u = (i.x+i.y+1.0-s)%2.0;\n    float v = (i.x+i.y+1.0-t)%2.0;\n    float w = (i.x+i.y+1.0-u)%2.0;\n    float x = (i.x+i.y+1.0-v)%2.0;\n    float y = (i.x+i.y+1.0-w)%2.0;\n    float z = (i.x+i.y+1.0-x)%2.0;\n    float a = (i.x+i.y+1.0-y)%2.0;\n    float b = (i.x+i.y+1.0-z)%2.0;\n    float c = (i.x+i.y+1.0-a)%2.0;\n    float e = (i.x+i.y+1.0-b)%2.0;\n    float g = (i.x+i.y+1.0-c)%2.0;\n    float h = (i.x+i.y+1.0-e)%2.0;\n    float i1 = (i.x+i.y+1.0-g)%2.0;\n    float j = (i.x+i", "\n    return length(p) - 1.0;\n}\n\n// Get Normal of the sphere\nvec", "\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    vec3 w = Pf * Pf * (3.0 - 2.0 * Pf);\n\n    return \n        mix(\n            mix(\n                mix( dot( random3( Pi + vec3(0.0,0.0,0.0) ), Pf - vec3(0.0,0.0,0.0) ), \n                    dot( random3( Pi + vec3(1.0,0.0,0.0) ), Pf - vec3(1.0,0.0,0.0) ), w.x),\n                mix( dot( random3( Pi + vec3(0.0,1.0,0.0) ), Pf - vec3(0.0,1.0,0.0) ), \n                    dot( random3( Pi + vec3(1.0,1.0,0.0) ), Pf - vec3(1.0,1.0,0.0) ), w.x),\n                w.y),\n            mix(\n                mix( dot( random3( Pi + vec3(0.0,0.0,1.0) ), Pf - vec3(0.0,0.0,1.0) ), \n                    dot( random3( Pi + vec3(1.0,0.0,1.0) ), Pf - vec3(1.0,0.0,1.0) ), w.x),\n                mix( dot( random3( Pi + vec3(0.0,1.0,1.0) ), Pf - vec3(0.0,1.0,1.0) ), \n                    dot( random3( Pi + vec3(1.0,1.0,1.0) ), Pf - vec3(1.0,1.0,1.0) ), w.x),\n                w.y),\n            w.z);\n}\n\nfloat", "\n    return fract(sin(x)*43758.5453);\n}\n\n// 1D noise\nfloat", "\n    float d = length(p) - 1.0;\n    return vec2(d, 1.0);\n}\n\nvec", "\n    float d = length(p) - 1.0;\n    return vec2(d, 1.0);\n}\n\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - d;\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = length(uv-0.5);\n    float a = atan(uv.y-0.5,uv.x-0.5);\n    float d = abs(r-0.25);\n    float f = smoothstep(0.0,0.01,d);\n    float s = sin(a*10.0+t*10.0);\n    float c = cos(a*10.0+t*10.0);\n    float l = length(uv-vec2(0.5,0.5));\n    float aa = atan(uv.y-0.5,uv.x-0.5);\n    float b = sin(aa*10.0+t*10.0);\n    float c2 = cos(aa*10.0+t*10.0);\n    float l2 = length(uv-vec2(0.5,0.5));\n    float a2 = atan(uv.y-0.5,uv.x-0.5);\n    float b2 = sin(a2*10.0+t*10.0);\n    float c3 = cos(a2*10.0+t*10.0);\n    float l3 = length(uv-vec2(0.5,0.5));\n    float a3 = atan(uv.y-0.5,uv.x-0.5);\n    float b3 = sin(a3*10.0+t*10.0);\n    float c4 = cos(a3*10.0+t*10.0);\n    float l4 = length(uv-vec2(0.5,0.5));\n    float a4 = atan(uv.y-0.5,uv.x-0.5);\n    float b4 = sin(a4*10.0+t*10.0);\n    float c5 = cos(a4*10.0+", "\n    p = abs(p);\n    return max(p.x, p.y) + min(p.x, p.y) * 0.8660254037844386;\n}\n\n// Distance function for a hexagon.\nfloat", "\n    float2 p = float2(ix, iy);\n    float2 f = floor(p);\n    p -= f;\n    float2 u = p*p*(3.0-2.0*p);\n    float2 a = float2(f.x, f.y) + float2(0.0, 1.0);\n    float2 b = float2(f.x, f.y) + float2(1.0, 0.0);\n    float2 c = float2(f.x, f.y) + float2(1.0, 1.0);\n    float2 d = float2(f.x, f.y) + float2(0.0, 2.0);\n    float2 e = float2(f.x, f.y) + float2(1.0, 2.0);\n    float2 f2 = float2(f.x, f.y) + float2(2.0, 0.0);\n    float2 g = float2(f.x, f.y) + float2(2.0, 1.0);\n    float2 h = float2(f.x, f.y) + float2(2.0, 2.0);\n    float k0 = dot(a, a);\n    float k1 = dot(b, b);\n    float k2 = dot(c, c);\n    float k3 = dot(d, d);\n    float k4 = dot(e, e);\n    float k5 = dot(f2, f2);\n    float k6 = dot(g, g);\n    float k7 = dot(h, h);\n    float2 g0 = float2(k0, k0)*float2(k0, k0);\n    float2 g1 = float2(k1, k1)*float2(k1, k1);\n    float2 g2 = float2(k2, k2)*float2(k2, k2);\n    float2 g3 = float2(k3, k3)*float2(k3, k3);\n    float2 g4 = float2(k4, k4)*float2(k4,", "\n    float t = time;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t) * 0.5 + 0.5;\n    float d = cos(t) * 0.5 + 0.5;\n    float e = sin(t) * 0.5 + 0.5;\n    float f = cos(t) * 0.5 + 0.5;\n    float g = sin(t) * 0.5 + 0.5;\n    float h = cos(t) * 0.5 + 0.5;\n    float i = sin(t) * 0.5 + 0.5;\n    float j = cos(t) * 0.5 + 0.5;\n    float k = sin(t) * 0.5 + 0.5;\n    float l = cos(t) * 0.5 + 0.5;\n    float m = sin(t) * 0.5 + 0.5;\n    float n = cos(t) * 0.5 + 0.5;\n    float o = sin(t) * 0.5 + 0.5;\n    float p = cos(t) * 0.5 + 0.5;\n    float q = sin(t) * 0.5 + 0.5;\n    float r = cos(t) * 0.5 + 0.5;\n    float s = sin(t) * 0.5 + 0.5;\n    float t = cos(t) * 0.5 + 0.5;\n    float u = sin(t) * 0.5 + 0.5;\n    float v = cos(t) * 0.5 + 0.5;\n    float w = sin(t) * 0.5 + 0.5;\n    float x = cos(t) * 0.5 + 0.5;\n    float y = sin(t) * 0.5 + 0.5;\n    float z = cos(t) * 0.5 + 0.5;\n    float A = sin(t) * ", "\n    float d = p;\n    d = sdBox(p, vec3(1.0, 1.0, 1.0));\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 1.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 2.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 3.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 4.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 5.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 6.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 7.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 8.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = op", "\n    return vec2(atan(z.x, z.y), length(z));\n}\n\nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n    // 3d simplex noise\n    // https://www.shadertoy.com/view/4djSRW\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33", "\n    float time = mod( iTime, 25.0 );\n    float wave = cos( p.x * 10.0 + time * 0.5 );\n    float dist = length( p );\n    float rings = exp( -dist * dist );\n    return wave * rings;\n}\n\n// the color of the droplet is based on the distance to the center\n// the color is a gradient from blue to red\n// the color is also attenuated by the distance to the center\n// the color is also attenuated by the wave displacement\nvec", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d", "\n    float d = sdBox(rp, vec3(1.0, 1.0, 1.0));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d", "\n    return 1.0 - clamp((d - start) / (end - start), 0.0, 1.0);\n}\n\nvec", "\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n   ", "\n    vec2 q = p;\n    q.x = mod(q.x, 2.0);\n    q.y = mod(q.y, 2.0);\n    vec2 d = vec2(0.0);\n    if(q.x > 1.0){\n        q.x = 2.0 - q.x;\n    }\n    if(q.y > 1.0){\n        q.y = 2.0 - q.y;\n    }\n    if(q.x > q.y){\n        d.x = q.x;\n    }else{\n        d.y = q.y;\n    }\n    return d;\n}\n\n// The distance function for the Truchet tile.\nfloat", "\n\n\t// Set the color of the pixel to a constant color\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}", "\n    float theta = atan(pc.y, pc.x);\n    float r = a + b*theta;\n    float d = length(pc);\n    float d_r = abs(d - r);\n    if(d_r < 0.001){\n        return theta;\n    }\n    return -1.0;\n}\n\n//https://en.wikipedia.org/wiki/Archimedean_spiral\n//If on spiral, return number of degrees (theta).\n//If not on spiral, return -1.0\nfloat", "\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid main() {\n  vec2 st = gl_FragCoord.xy/u_resolution.xy;\n  vec3 color = vec3(0.0);\n\n  // Plot a line\n  color = vec3(plot(st,0.5));\n\n  gl_FragColor = vec4(color,1.0);\n}\n", "\n    // The initial domain is a circle with radius 1.0.\n    // The center of the circle is at the origin.\n    // The circle is divided into N segments.\n    // The segments are numbered from 0 to N-1.\n    // The segment number is calculated as follows:\n    // \n    // 1. The angle of the segment is calculated as follows:\n    //    angle = (2.0 * PI) / N\n    // 2. The segment number is calculated as follows:\n    //    segment = int(mod(atan(v.y, v.x) / angle, N))\n    // 3. The segment number is returned as a vec3 with the x, y, and z components\n    //    equal to the segment number.\n    // 4. The x, y, and z components of the vec3 are then used to calculate the\n    //    position of the point on the circle.\n    // 5. The position of the point on the circle is returned as a vec3.\n    // \n    // The segment number is used to calculate the position of the point on the\n    // circle. The position of the point on the circle is then used to calculate\n    // the position of the point on the circle. The position of the point on the\n    // circle is then used to calculate the position of the point on the circle.\n    // The position of the point on the circle is then used to calculate the\n    // position of the point on the circle. The position of the point on the\n    // circle is then used to calculate the position of the point on the circle.\n    // The position of the point on the circle is then used to calculate the\n    // position of the point on the circle. The position of the point on the\n    // circle is then used to calculate the position of the point on the circle.\n    // The position of the point on the circle is then used to calculate the\n    // position of the point on the circle. The position of the point on the\n    // circle is then used to calculate the position of the point on the circle.\n    // The position of the point on the circle is then used to calculate the\n    // position of the point on the circle. The position of the point on the\n    // circle is", "\n  float r = circ.x;\n  float a = circ.y;\n  float b = circ.z;\n  float c = a * a + b * b;\n  float d = r * r;\n  float e = a * p.x + b * p.y;\n  float f = a * a - b * b;\n  float g = d - e * e / c;\n  float h = sqrt(g);\n  float i = e * h / c;\n  float j = sqrt(c);\n  float k = (d - h * h) / c;\n  float l = (e * h - i * j) / c;\n  float m = (e * i + h * k) / c;\n  float n = (h * l + i * m) / c;\n  float o = (i * l - h * m) / c;\n  float p = (h * k - i * l) / c;\n  float q = (i * m + h * n) / c;\n  float r = (h * o - i * p) / c;\n  float s = (i * n + h * r) / c;\n  float t = (h * q - i * s) / c;\n  float u = (i * r + h * t) / c;\n  float v = (h * u - i * t) / c;\n  float w = (i * q + h * v) / c;\n  float x = (h * w - i * v) / c;\n  float y = (i * x + h * y) / c;\n  float z = (h * y - i * x) / c;\n  float A = (i * z + h * w) / c;\n  float B = (h * A - i * w) / c;\n  float C = (i * B + h * z) / c;\n  float D = (h * C - i * B) / c;\n  float E = (i * D + h * C) / c;\n  float F = (h * E - i * D) / c;\n  float G = (i * F + h * E) / c;", "\n    return vec2(p.x, 1.0 - p.y);\n}\n\n// Mouse pointer inversion.\nvec", "\n    vec3 color = vec3(0.0);\n\n    // Get the normal\n    vec3 normal = getNormal(march);\n\n    // Get the material\n    Material material = getMaterial(march);\n\n    // Get the light\n    vec3 light = getLight(march);\n\n    // Get the shadow\n    float shadow = getShadow(march);\n\n    // Get the specular\n    float specular = getSpecular(march, light, normal);\n\n    // Get the diffuse\n    float diffuse = getDiffuse(march, light, normal);\n\n    // Get the ambient\n    float ambient = getAmbient(march);\n\n    // Get the fresnel\n    float fresnel = getFresnel(march, light, normal);\n\n    // Get the reflection\n    vec3 reflection = getReflection(march, light, normal);\n\n    // Get the refraction\n    vec3 refraction = getRefraction(march, light, normal);\n\n    // Get the fresnel refraction\n    float fresnelRefraction = getFresnelRefraction(march, light, normal);\n\n    // Get the fresnel reflection\n    float fresnelReflection = getFresnelReflection(march, light, normal);\n\n    // Get the fresnel refraction\n    float fresnelRefraction2 = getFresnelRefraction2(march, light, normal);\n\n    // Get the fresnel reflection\n    float fresnelReflection2 = getFresnelReflection2(march, light, normal);\n\n    // Get the fresnel refraction\n    float fresnelRefraction3 = getFresnelRefraction3(march, light, normal);\n\n    // Get the fresnel reflection\n    float fresnelReflection3 = getFresnelReflection3(march, light, normal);\n\n    // Get the fresnel refraction\n    float fresnelRefraction4 = getFresnelRefraction4(march, light, normal);\n\n    // Get the fresnel reflection\n    float fresnelReflection4 = getFresnelReflection4(march, light, normal);\n\n    // Get the fresnel ref", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", " // Input (x, y) pixel coordinate\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Convert to polar coordinates\n    vec2 p = uv * 2.0 - 1.0;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n\n    // Convert to HSB\n    float h = a / (2.0 * PI) + 0.5;\n    float s = 1.0;\n    float b = r;\n\n    // Convert to RGB\n    vec3 rgb = hsb2rgb(vec3(h, s, b));\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}", "\n    float h = fract(hash);\n    float i = floor(hash);\n    float j = floor(i / 12.0);\n    float k = i - j * 12.0;\n    float l = j % 3.0;\n    float m = k % 4.0;\n    float n = k / 4.0;\n    float o = l + m * 0.5;\n    float p = n + o * 0.25;\n    float q = p * 2.0 - 1.0;\n    float r = (l + m * 0.5) * 0.5;\n    float s = (n + o * 0.25) * 0.25;\n    float t = r * 2.0 - 1.0;\n    float u = s * 2.0 - 1.0;\n    float v = t * 2.0 - 1.0;\n    float w = u * 2.0 - 1.0;\n    float x = v * 2.0 - 1.0;\n    float y = w * 2.0 - 1.0;\n    float z = x * 2.0 - 1.0;\n    float a = y * 2.0 - 1.0;\n    float b = z * 2.0 - 1.0;\n    float c = a * 2.0 - 1.0;\n    float d = b * 2.0 - 1.0;\n    float e = c * 2.0 - 1.0;\n    float f = d * 2.0 - 1.0;\n    float g = e * 2.0 - 1.0;\n    float h = f * 2.0 - 1.0;\n    float i = g * 2.0 - 1.0;\n    float j = h * 2.0 - 1.0;\n    float k = i * 2.0 - 1.0;\n    float l = j * 2.0 - 1.0;\n    float m = k * 2.0 - 1.", "\n    X.z = mod(X.z, 1.0);\n    X.xy = mod(X.xy, 1.0);\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n   ", "\n  float plane = p.y;\n  float wave = sin(p.x * 10.0) * sin(p.z * 10.0);\n  return plane + wave;\n}\n\n/* scene normal */\nvec", "\n    vec3 rayToTarget = targetPos - ray.origin;\n    float rayToTargetLength = length( rayToTarget );\n    float rayToTargetLengthSq = rayToTargetLength * rayToTargetLength;\n    float rayToTargetDot = dot( ray.direction, rayToTarget );\n    float rayToTargetDotSq = rayToTargetDot * rayToTargetDot;\n    float rayToTargetDotSqMinusRadiusSq = rayToTargetDotSq - rayToTargetLengthSq + ( 0.0001 * 0.0001 );\n    float rayToTargetDotSqMinusRadiusSqSq = rayToTargetDotSqMinusRadiusSq * rayToTargetDotSqMinusRadiusSq;\n    float rayToTargetDotSqMinusRadiusSqSqSq = rayToTargetDotSqMinusRadiusSqSq * rayToTargetDotSqMinusRadiusSqSq;\n    float rayToTargetDotSqMinusRadiusSqSqSqSq = rayToTargetDotSqMinusRadiusSqSqSq * rayToTargetDotSqMinusRadiusSqSqSq;\n    float rayToTargetDotSqMinusRadiusSqSqSqSqSq = rayToTargetDotSqMinusRadiusSqSqSqSq * rayToTargetDotSqMinusRadiusSqSqSqSq;\n    float rayToTargetDotSqMinusRadiusSqSqSqSqSqSq = rayToTargetDotSqMinusRadiusSqSqSqSqSq * rayToTargetDotSqMinusRadiusSqSqSqSqSq;\n    float rayToTargetDotSqMinusRadiusSqSqSqSqSqSqSq = rayToTargetDotSqMinusRadiusSqSqSqSqSqSq * rayToTargetDotSqMinusRadiusSqSqSqSqSqSq", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col, 1.0);\n}", "\n    float d = length(p) - 1.0;\n    return vec4(d, 1.0, 0.0, 0.0);\n}\n\n//---Essential Ray Marching Function\nvec", "\n\n    float t = length( targetPos - ray.origin );\n    float r = lightDiameter * 0.5;\n    float b = blur;\n\n    float a = r * r - b * b;\n    float b2 = t * t * 2.0 - 4.0 * a;\n    float det = b2 * b2 - 4.0 * a * t * t;\n\n    if ( det < 0.0 ) {\n        return 0.0;\n    }\n\n    float t1 = ( -b2 - sqrt( det ) ) / ( 2.0 * a );\n    float t2 = ( -b2 + sqrt( det ) ) / ( 2.0 * a );\n\n    float tmin = min( t1, t2 );\n    float tmax = max( t1, t2 );\n\n    if ( tmin > tmax ) {\n        float tmp = tmin;\n        tmin = tmax;\n        tmax = tmp;\n    }\n\n    if ( tmin > t || tmax < 0.0 ) {\n        return 0.0;\n    }\n\n    tmin = max( tmin, 0.0 );\n\n    float result = ( tmax - tmin ) / ( t * 2.0 );\n    result = 1.0 - result;\n\n    return result;\n}\n\n// BOKEH\nfloat", "\n    float d = sdSphere(p, 1.0);\n    return vec2(d, 1.0);\n}\n\nvec", "\n    float i = floor(x);\n    float f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), f);\n}\n\n// Fractal noise by iq\n// https://www.shadertoy.com/view/XslGRr\nfloat", "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u = 1.0 - v - w;\n    return (u >= 0.0) && (v >= 0.0) && (w >= 0.0);\n}\n\n//Check if uv inside triangle using barycentric coords\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nbool in_triangle(vec3 p1, vec3 p2, vec3 p3, vec3 uv){\n    vec3 v0 = p2 - p1;\n    vec3 v1 = p3 - p1;\n    vec3 v2 = uv - p1;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u", "\n    vec2 p = uv;\n    float r = start_radius;\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r2*r2;\n    float r5 = r2*r3;\n    float r6 = r2*r4;\n    float r7 = r2*r5;\n    float r8 = r2*r6;\n    float r9 = r2*r7;\n    float r10 = r2*r8;\n    float r11 = r2*r9;\n    float r12 = r2*r10;\n    float r13 = r2*r11;\n    float r14 = r2*r12;\n    float r15 = r2*r13;\n    float r16 = r2*r14;\n    float r17 = r2*r15;\n    float r18 = r2*r16;\n    float r19 = r2*r17;\n    float r20 = r2*r18;\n    float r21 = r2*r19;\n    float r22 = r2*r20;\n    float r23 = r2*r21;\n    float r24 = r2*r22;\n    float r25 = r2*r23;\n    float r26 = r2*r24;\n    float r27 = r2*r25;\n    float r28 = r2*r26;\n    float r29 = r2*r27;\n    float r30 = r2*r28;\n    float r31 = r2*r29;\n    float r32 = r2*r30;\n    float r33 = r2*r31;\n    float r34 = r2*r32;\n    float r35 = r2*r33;\n    float r36 = r2*r34;\n    float r37 = r2*r35;\n    float r38 = r2*", "\n    float r = circumradius;\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r2*r2;\n    float r5 = r4*r;\n    float r6 = r4*r2;\n    float r7 = r6*r;\n    float r8 = r6*r2;\n    float r9 = r8*r;\n    float r10 = r8*r2;\n    float r11 = r10*r;\n    float r12 = r10*r2;\n    float r13 = r12*r;\n    float r14 = r12*r2;\n    float r15 = r14*r;\n    float r16 = r14*r2;\n    float r17 = r16*r;\n    float r18 = r16*r2;\n    float r19 = r18*r;\n    float r20 = r18*r2;\n    float r21 = r20*r;\n    float r22 = r20*r2;\n    float r23 = r22*r;\n    float r24 = r22*r2;\n    float r25 = r24*r;\n    float r26 = r24*r2;\n    float r27 = r26*r;\n    float r28 = r26*r2;\n    float r29 = r28*r;\n    float r30 = r28*r2;\n    float r31 = r30*r;\n    float r32 = r30*r2;\n    float r33 = r32*r;\n    float r34 = r32*r2;\n    float r35 = r34*r;\n    float r36 = r34*r2;\n    float r37 = r36*r;\n    float r38 = r36*r2;\n    float r39 = r38*r;\n    float r40 = r38", "\n    float r = circumradius;\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r6 = r4*r2;\n    float r8 = r6*r2;\n    float r10 = r8*r2;\n    float r12 = r10*r2;\n    float r14 = r12*r2;\n    float r16 = r14*r2;\n    float r18 = r16*r2;\n    float r20 = r18*r2;\n    float r22 = r20*r2;\n    float r24 = r22*r2;\n    float r26 = r24*r2;\n    float r28 = r26*r2;\n    float r30 = r28*r2;\n    float r32 = r30*r2;\n    float r34 = r32*r2;\n    float r36 = r34*r2;\n    float r38 = r36*r2;\n    float r40 = r38*r2;\n    float r42 = r40*r2;\n    float r44 = r42*r2;\n    float r46 = r44*r2;\n    float r48 = r46*r2;\n    float r50 = r48*r2;\n    float r52 = r50*r2;\n    float r54 = r52*r2;\n    float r56 = r54*r2;\n    float r58 = r56*r2;\n    float r60 = r58*r2;\n    float r62 = r60*r2;\n    float r64 = r62*r2;\n    float r66 = r64*r2;\n    float r68 = r66*r2;\n    float r70 = r68*r2;\n    float r72 = r70*r2;\n    float r74 = r72*", "\n    float L = exp(-d);\n    float k = 0.0;\n    float p = L;\n    float U1 = U.x;\n    while (U1 > p) {\n        k += 1.0;\n        p *= d / k;\n    }\n    return k;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat", "\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash2(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash3(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash4(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash5(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash6(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash7(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash8(uint n)\n{\n    n = (n << 1", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    if (uv.x < 0.5) {\n        col = vec3(0.0, 0.0, 1.0);\n    } else {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    fragColor = vec4(col, 1.0);\n}", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx)\n    );\n    return normalize(nor);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec2 res = map(ro + rd * t);\n        float d = res.x;\n        int m = int(res.y);\n        if (d < EPSILON || t > MAX_DISTANCE) break;\n        t += d;\n        if (m == SPHERE) {\n            col = vec3(1.0);\n        }\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx)\n    );\n    return normalize(nor);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec2 res = map(ro + rd * t);\n        float d = res.x;\n        int m = int(res.y);\n        if (d < EPSILON || t > MAX_DISTANCE) break;\n        t += d;\n        if (m == SPHERE) {\n            col = vec3(1.0);\n        }\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.yz)) - sdf(vec3(p.x - EPSILON, p.yz)),\n        sdf(vec3(p.xy + EPSILON, p.z)) - sdf(vec3(p.xy - EPSILON, p.z)),\n        sdf(vec3(p.xy, p.z + EPSILON)) - sdf(vec3(p.xy, p.z - EPSILON))\n    ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n * This is a faster version of estimateNormal that does not normalize the result.\n */\nvec", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// random hash via https://www.shadertoy.com/view/3d2GRh\nfloat", "\n    if ( i == 0 ) {\n        color = vec3( 0.6, 0.6, 0.6 );\n        return true;\n    }\n    if ( i == 1 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 2 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 3 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 4 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 5 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 6 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 7 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 8 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 9 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 10 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 11 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 12 ) {\n        color = vec3( 0.9, 0.9, 0", "\n    p = p*2.0 - 1.0;\n    vec2 p2 = p*p;\n    vec2 p4 = p2*p2;\n    vec2 p8 = p4*p4;\n    vec2 p16 = p8*p8;\n    vec2 p32 = p16*p16;\n    vec2 p64 = p32*p32;\n    vec2 p128 = p64*p64;\n    vec2 p256 = p128*p128;\n    vec2 p512 = p256*p256;\n    vec2 p1024 = p512*p512;\n    vec2 p2048 = p1024*p1024;\n    vec2 p4096 = p2048*p2048;\n    vec2 p8192 = p4096*p4096;\n    vec2 p16384 = p8192*p8192;\n    vec2 p32768 = p16384*p16384;\n    vec2 p65536 = p32768*p32768;\n    vec2 p131072 = p65536*p65536;\n    vec2 p262144 = p131072*p131072;\n    vec2 p524288 = p262144*p262144;\n    vec2 p1048576 = p524288*p524288;\n    vec2 p2097152 = p1048576*p1048576;\n    vec2 p4194304 = p2097152*p2097152;\n    vec2", "\n    vec3 p3 = fract(vec3(p) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n//  4 out, 1 in...\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n    float d = abs(r - 0.5);\n    float f = sin(a * 10.0 + t * 10.0) * 0.5 + 0.5;\n    float g = sin(a * 10.0 + t * 10.0) * 0.5 + 0.5;\n    float b = sin(a * 10.0 + t * 10.0) * 0.5 + 0.5;\n    col = vec3(f, g, b);\n    fragColor = vec4(col, 1.0);\n}", "\n    float d = length(raypos.xyz);\n    float r = hypersphereRadius;\n    float d2 = d*d;\n    float r2 = r*r;\n    float d2r2 = d2-r2;\n    float d2r2_2 = d2r2*d2r2;\n    float d2r2_3 = d2r2_2*d2r2;\n    float d2r2_4 = d2r2_3*d2r2;\n    float d2r2_5 = d2r2_4*d2r2;\n    float d2r2_6 = d2r2_5*d2r2;\n    float d2r2_7 = d2r2_6*d2r2;\n    float d2r2_8 = d2r2_7*d2r2;\n    float d2r2_9 = d2r2_8*d2r2;\n    float d2r2_10 = d2r2_9*d2r2;\n    float d2r2_11 = d2r2_10*d2r2;\n    float d2r2_12 = d2r2_11*d2r2;\n    float d2r2_13 = d2r2_12*d2r2;\n    float d2r2_14 = d2r2_13*d2r2;\n    float d2r2_15 = d2r2_14*d2r2;\n    float d2r2_16 = d2r2_15*d2r2;\n    float d2r2_17 = d2r2_16*d2r2;\n    float d2r2_18 = d2r2_17*d2r2;\n    float d2r2_19 = d2r2_18*d2r2;\n    float d2r2_20 = d2r2_19*d2r2;\n    float d2r2_21 = d2r2_", "\n    float cx = cos(rotation.x);\n    float sx = sin(rotation.x);\n    float cy = cos(rotation.y);\n    float sy = sin(rotation.y);\n    float cz = cos(rotation.z);\n    float sz = sin(rotation.z);\n    return mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat", "\n    float t = 0.0;\n    float d = 0.0;\n    float m = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec4 pos = rayori + raydir * t;\n        d = map(pos);\n        m = d;\n        t += d;\n        if(d < MIN_DIST || t > MAX_DIST) break;\n    }\n    return vec3(t, m, 0.0);\n}\n\n// 3D Ray-Marching\nvec", "\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float t2 = t*t;\n    float t3 = t2*t;\n    float t4 = t3*t;\n    float t5 = t4*t;\n    float t6 = t5*t;\n    float t7 = t6*t;\n    float t8 = t7*t;\n    float t9 = t8*t;\n    float t10 = t9*t;\n    float t11 = t10*t;\n    float t12 = t11*t;\n    float t13 = t12*t;\n    float t14 = t13*t;\n    float t15 = t14*t;\n    float t16 = t15*t;\n    float t17 = t16*t;\n    float t18 = t17*t;\n    float t19 = t18*t;\n    float t20 = t19*t;\n    float t21 = t20*t;\n    float t22 = t21*t;\n    float t23 = t22*t;\n    float t24 = t23*t;\n    float t25 = t24*t;\n    float t26 = t25*t;\n    float t27 = t26*t;\n    float t28 = t27*t;\n    float t29 = t28*t;\n    float t30 = t29*t;\n    float t31 = t30*t;\n    float t32 = t31*t;\n    float t33 = t32*t;\n    float t34 = t33*t;\n    float t35 = t34*t;\n    float t36 = t35*t;\n    float t37 = t36*t;\n    float t38 = t37*t;\n    float t39 = t38*t;\n    float t40 = t39*t;", "\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < 100; i++){\n        d = map(rayori + raydir * t);\n        if(d < 0.001){\n            break;\n        }\n        t += d;\n    }\n    return vec3(t, d, 0.0);\n}\n\n// 3D Raymarching\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col, 1.0);\n}", "\n    float x = coord.x * frequency;\n    float y = coord.y * frequency;\n    float xOffset = travelRate * frequency;\n    float yOffset = travelRate * frequency;\n    float xValue = sin(x + xOffset) * maxStrength;\n    float yValue = sin(y + yOffset) * maxStrength;\n    return xValue + yValue;\n}\n\n// coord: (texture coordinate: [0-1], [0-1])\n// frequency: rate at which ray appears\n// travel rate: direction the ray travels in the x directions\n// max strength: light intensity of the ray\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // --------------------------------------------", "\n    vec2 p1 = p - d;\n    vec2 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec2(p1.x, p2.y);\n    e3 = p2 - vec2(p2.x, p1.y);\n    e4 = p2 - vec2(p1.x, p1.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec3 p, vec3 d, inout vec3 e1, inout vec3 e2, inout vec3 e3, inout vec3 e4) {\n    vec3 p1 = p - d;\n    vec3 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec3(p1.x, p2.y, p1.z);\n    e3 = p2 - vec3(p2.x, p1.y, p1.z);\n    e4 = p2 - vec3(p1.x, p1.y, p2.z);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec4 p, vec4 d, inout vec4 e1, inout vec4 e2, inout vec4 e3, inout vec4 e4) {\n    vec4 p1 = p - d;\n    vec4 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec4(p1.x, p2.y, p1.z, p1.w);\n    e3 = p2 - vec4(p2.x, p1.y, p1.z, p1.w);\n    e4 = p2 - vec4(p1.x, p1.y, p2.z, p1.w);", "\n    color = max(vec3(0.0), color - 0.004);\n    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);\n    return color;\n}\n\n// https://www.shadertoy.com/view/Xlf3Dl\nvec", "\n    vec2  ba = b - a;\n    float h = clamp( dot(p-a,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  n = ba*h - (p-a);\n    float d = length(n)*sign(w1-w2) - w2;\n    float t = w1 - w2;\n    return  min( max(d,-t), min(d,0.0) ) + length(ba)*h;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    float d = length( uv - p );\n    float f = exp( -d * 10.0 );\n    return vec3( f, f, f );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3( 0.0 );\n    for( int i = 0; i < 10; i++ )\n    {\n        float t = float( i ) * 0.1;\n        vec2 p = vec2( sin( t ), cos( t ) ) * 0.5 + 0.5;\n        col += blob( uv, p );\n    }\n    fragColor = vec4( col, 1.0 );\n}\n", "\n    return vec3( 1.0 ) - smoothstep( falloff, falloff + 0.01, rnd );\n}\n\n/////////////////////////////////////////////////////////////\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = length(uv-0.5);\n    float a = atan(uv.y-0.5,uv.x-0.5);\n    float d = abs(r-0.25);\n    float f = smoothstep(0.0,0.01,d);\n    float s = sin(a*10.0+t*10.0);\n    float c = cos(a*10.0+t*10.0);\n    float l = length(uv-vec2(0.5,0.5));\n    float a2 = atan(uv.y-0.5,uv.x-0.5);\n    float s2 = sin(a2*10.0+t*10.0);\n    float c2 = cos(a2*10.0+t*10.0);\n    float l2 = length(uv-vec2(0.5,0.5));\n    float a3 = atan(uv.y-0.5,uv.x-0.5);\n    float s3 = sin(a3*10.0+t*10.0);\n    float c3 = cos(a3*10.0+t*10.0);\n    float l3 = length(uv-vec2(0.5,0.5));\n    float a4 = atan(uv.y-0.5,uv.x-0.5);\n    float s4 = sin(a4*10.0+t*10.0);\n    float c4 = cos(a4*10.0+t*10.0);\n    float l4 = length(uv-vec2(0.5,0.5));\n    float a5 = atan(uv.y-0.5,uv.x-0.5);\n    float s5 = sin(a5*10.0+t*10.0);\n    float c5 = cos(a5*10", "\n    vec3 p3 = fract(vec3(p) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n//  4 out, 1 in...\nvec", "\n    float x2 = x * x;\n    return x * (27.0f + x2) / (27.0f + 9.0f * x2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.4545));\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col", "\n    p = abs(p) - 0.5;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\n/* \u4e00\u4e2a\u7403\u4f53\u7684SDF */\nfloat", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // circle radius\n    float r = 0.1;\n\n    // circle center\n    vec2 c = vec2(0.5, 0.5);\n\n    // circle color\n    vec3 circle_color = vec3(1.0, 0.0, 0.0);\n\n    // circle brightness\n    float circle_brightness = 0.0;\n\n    // circle radius change\n    float circle_radius_change = 0.0;\n\n    // circle radius change threshold\n    float circle_radius_change_threshold = 0.01;\n\n    // circle radius change rate\n    float circle_radius_change_rate = 0.01;\n\n    // circle radius change direction\n    float circle_radius_change_direction = 1.0;\n\n    // circle radius change direction threshold\n    float circle_radius_change_direction_threshold = 0.01;\n\n    // circle radius change direction rate\n    float circle_radius_change_direction_rate = 0.01;\n\n    // circle radius change direction direction\n    float circle_radius_change_direction_direction = 1.0;\n\n    // circle radius change direction direction threshold\n    float circle_radius_change_direction_direction_threshold = 0.01;\n\n    // circle radius change direction direction rate\n    float circle_radius_change_direction_direction_rate = 0.01;\n\n    // circle radius change direction direction direction\n    float circle_radius_change_direction_direction_direction = 1.0;\n\n    // circle radius change direction direction direction threshold\n    float circle_radius_change_direction_direction_direction_threshold = 0.01;\n\n    // circle radius change direction direction direction rate\n    float circle_radius_change_direction_direction_direction_rate = 0.01;\n\n    // circle radius change direction direction direction direction\n    float circle_radius_change_direction_direction_direction_direction = 1.0;\n\n"], "input_comment": ["\n\treturn (cos(a*TAU)+1)/2;\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) =.5, fsin(2/3) =.5\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat", "\n    float d = length(p);\n    return d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat", "\n    return length(p - voxelPos);\n}\n\n// Distance to the voxel\nfloat", "\n    vec3 q = p - scene.position;\n    float d = dot(q, q);\n    P = scene.position + q * scene.radius;\n    return vec2(d, scene.radius);\n}\n\n// Distance to the scene and color of the closest point\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        vec2 q = p;\n        for (int j = 0; j < 10; j++) {\n            q = vec2(q.x * q.x - q.y * q.y, 2.0 * q.x * q.y) + vec2(0.0, 0.0);\n            d = length(q);\n            if (d > 2.0) break;\n        }\n        col += vec3(d < 1.0? 1.0 : 0.0);\n        p = q;\n    }\n    col /= 10.0;\n    fragColor = vec4(col, 1.0);\n}\n", "\n    return vec4(0.0, 0.0, 0.0, 0.0);\n}\n\n// this is the main function that will be called by the shader\nvoid main()\n{\n    // get the position of the vertex\n    vec4 pos = gl_Vertex;\n\n    // get the position of the vertex in the texture\n    vec2 tex = (pos.xy / pos.w) * 0.5 + 0.5;\n\n    // get the color of the vertex\n    vec4 color = texture2D(tex_color, tex);\n\n    // get the color of the vertex\n    vec4 gradient_color = gradient(tex.x);\n\n    // get the color of the vertex\n    vec4 final_color = color * gradient_color;\n\n    // set the color of the vertex\n    gl_FragColor = final_color;\n}\n", "\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\n// shade a point based on distance\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(sunDir);\n    vec3 lightColor = vec3(1.0);\n    float lightRadius = 0.0;\n    float lightIntensity = 0.0;\n    float lightFade = 0.0;\n    float lightFadeEnd = 0.0;\n    float lightFadeStart = 0.0;\n    float lightFadeStep = 0.0;\n    float lightFadeStepEnd = 0.0;\n    float lightFadeStepStart = 0.0;\n    float lightFadeStepStartEnd = 0.0;\n    float lightFadeStepStartEndEnd = 0.0;\n    float lightFadeStepStartEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.0;\n    float lightFadeStepStartEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEndEnd = 0.", "\n    return sin(coords.x) * cos(coords.y);\n}\n\n// F(x,y) = F(x) + y\nfloat", "\n    return sin(coords.x) * cos(coords.y);\n}\n\n// F(x,y) = F(x) + y\nfloat", "\n    return sin(coords.x) * cos(coords.y);\n}\n\n// F(x,y) = F(x) + y\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        vec2 q = p;\n        float a = 0.0;\n        for (int j = 0; j < 10; j++) {\n            q = abs(q);\n            q = q - 0.5;\n            a += length(q);\n        }\n        d = min(d, a);\n        p = p * 2.0 - 1.0;\n    }\n    col = vec3(d);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    float n = 0.0;\n    float f = 1.0;\n    for (int i = 0; i < NUM_LAYERS; i++) {\n        n += f * fbm(p);\n        p *= 2.0;\n        f *= 0.5;\n    }\n    return n;\n}\n\n//\n// Standard fBm function with some time dialation to give a parallax \n// kind of effect. In other words, the position and time frequencies \n// are changed at different rates from layer to layer.\n//\nfloat", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    vec2 i = floor(p);\n    vec2 f = fract(p);\n    vec2 u = f*f*(3.0-2.0*f);\n    return mix(mix(mix(dot(i,vec2(1.0,0.0)),i.y,u.x),\n                   mix(dot(i+vec2(0.0,1.0),vec2(1.0,0.0)),i.x,u.x),u.y),\n               mix(mix(dot(i+vec2(1.0,1.0),vec2(1.0,1.0)),i.y,u.x),\n                   mix(dot(i+vec2(1.0,0.0),vec2(1.0,1.0)),i.x,u.x),u.y),f.y);\n}\n\n//\n// This is a modified version of the Voronoi3Tap function. It is used to generate a\n// 3D Voronoi noise field.\n//\n// The original Voronoi3Tap function is a 2D function. This modified version is a 3D\n// function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a 3D function.\n//\n// The Voronoi3Tap function is a 2D function. This modified version is a", "\n    // The 2D Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point and the\n    // points in the cell.\n    //\n    // The Voronoi diagram is a 2D grid of cells. Each cell is a point in\n    // space. Each cell has a center point and a radius.\n    //\n    // The center point is the average of the points in the cell.\n    //\n    // The radius is the average distance between the center point", "\n    // This is where we decide\n    // what color the world will be\n    // and what marvelous colors it will be\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n    // we will use the eyePosition and rayDirection\n    // to get the color of the world\n    // we will use the rayHitInfo to get the\n    // color of the world\n   ", "\n    // find the closest object\n    float t = -1.0;\n    vec2 closest = vec2(0.0);\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        float d = distance(p, objects[i].position);\n        if (d < objects[i].radius && d < t)\n        {\n            t = d;\n            closest = objects[i].position;\n        }\n    }\n\n    // move the object/shape by messing with p\n    if (t > 0.0)\n    {\n        p = closest;\n    }\n\n    // find the closest point on the plane\n    float t2 = -1.0;\n    vec2 closest2 = vec2(0.0);\n    for (int i = 0; i < NUM_PLANES; i++)\n    {\n        float d = distance(p, planes[i].position);\n        if (d < planes[i].radius && d < t2)\n        {\n            t2 = d;\n            closest2 = planes[i].position;\n        }\n    }\n\n    // move the plane by messing with p\n    if (t2 > 0.0)\n    {\n        p = closest2;\n    }\n\n    // find the closest point on the circle\n    float t3 = -1.0;\n    vec2 closest3 = vec2(0.0);\n    for (int i = 0; i < NUM_CIRCLES; i++)\n    {\n        float d = distance(p, circles[i].position);\n        if (d < circles[i].radius && d < t3)\n        {\n            t3 = d;\n            closest3 = circles[i].position;\n        }\n    }\n\n    // move the circle by messing with p\n    if (t3 > 0.0)\n    {\n        p = closest3;\n    }\n\n    // find the closest point on the triangle\n    float t4 = -1.0;\n    vec2 closest4 = vec2(0.0);\n    for (int i = 0; i <", "\n\tvec2 res = vec2(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.001;\n\tfloat tmax = 1000.0;\n\tfloat tmin2 = 0.001;\n\tfloat tmax2 = 1000.0;\n\tfloat tmin3 = 0.001;\n\tfloat tmax3 = 1000.0;\n\tfloat tmin4 = 0.001;\n\tfloat tmax4 = 1000.0;\n\tfloat tmin5 = 0.001;\n\tfloat tmax5 = 1000.0;\n\tfloat tmin6 = 0.001;\n\tfloat tmax6 = 1000.0;\n\tfloat tmin7 = 0.001;\n\tfloat tmax7 = 1000.0;\n\tfloat tmin8 = 0.001;\n\tfloat tmax8 = 1000.0;\n\tfloat tmin9 = 0.001;\n\tfloat tmax9 = 1000.0;\n\tfloat tmin10 = 0.001;\n\tfloat tmax10 = 1000.0;\n\tfloat tmin11 = 0.001;\n\tfloat tmax11 = 1000.0;\n\tfloat tmin12 = 0.001;\n\tfloat tmax12 = 1000.0;\n\tfloat tmin13 = 0.001;\n\tfloat tmax13 = 1000.0;\n\tfloat tmin14 = 0.001;\n\tfloat tmax14 = 1000.0;\n\tfloat tmin15 = 0.001;\n\tfloat tmax15 = 1000.0;\n\tfloat tmin16 = 0.001;\n\tfloat tmax16 = 1000.0;\n\tfloat tmin17 = 0.001;\n\tfloat tmax17 = 1000.0;\n\tfloat tmin18 = 0.001;\n\t", "\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/point\n    // find the closest object/", "\n    // ray-plane intersection\n    float t = (plane.z - ro.z) / rd.z;\n    vec3 pt = ro + t * rd;\n\n    // ray-sphere intersection\n    vec3 oc = pt - sphere.xyz;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    float t = min(t1, t2);\n    if (t < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n\n    // ray-triangle intersection\n    vec3 pt2 = ro + t * rd;\n    vec3 e1 = vec3(1.0, 0.0, 0.0);\n    vec3 e2 = vec3(0.0, 1.0, 0.0);\n    vec3 n = cross(e1, e2);\n    vec3 p1 = sphere.xyz + n * sphere.w;\n    vec3 p2 = sphere.xyz - n * sphere.w;\n    vec3 p3 = pt2;\n    vec3 v1 = p2 - p1;\n    vec3 v2 = p3 - p1;\n    vec3 v3 = pt2 - p1;\n    float s = sign(dot(n, cross(v1, v2)));\n    if (s < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.", "\n    vec3 n = vec3(0.0);\n    float d = 0.0001;\n    for(int i=-1; i<=1; i++)\n    {\n        for(int j=-1; j<=1; j++)\n        {\n            for(int k=-1; k<=1; k++)\n            {\n                vec3 p2 = p + vec3(i,j,k)*d;\n                vec3 oN2 = texture(texture_normal, p2).rgb;\n                n += oN2 - oN;\n            }\n        }\n    }\n    return normalize(n);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// output --> averaged? out normal vector at point p\nvec", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // Four corners in 3D space\n    float a = dot(i, vec3(1.0));\n    float b = dot(i, vec3(5.0));\n    float c = dot(i, vec3(7.0));\n    float d = dot(i, vec3(11.0));\n\n    // Smooth values of the four corners\n    vec3 u = smoothstep(0.0, 1.0, f);\n\n    // Mix 4 coords together to create a value between 0 and 1.\n    vec4 x = mix(vec4(a, b, c, d), vec4(b, c, d, a), u.z);\n    vec4 y = mix(vec4(d, a, b, c), vec4(c, a, b, d), u.y);\n    vec4 z0 = mix(vec4(a, b, c, d), vec4(c, a, b, d), u.x);\n    vec4 z1 = mix(vec4(d, a, b, c), vec4(a, b, c, d), u.x);\n\n    // Mix 4 values together to create a value between 0 and 1.\n    vec4 z = mix(z0, z1, u.z);\n    float z2 = mix(z.x, z.y, u.y);\n    return mix(z2, z.z, u.x);\n}\n\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement. I have no idea whether it's faster or not. It could be slower,\n// for all I know, but it doesn't really matter, because in its current state, \n// it's still no match for IQ's texture-based, smooth 3D value", "\n    vec3 color = vec3(0.0);\n    vec2 texCoord = vec2(0.0);\n    float t = 0.0;\n    float step = 1.0 / 1024.0;\n    for (int i = 0; i < 1024; i++) {\n        texCoord.x = (i + 0.5) * step;\n        t = Raymarch(rayDir, texCoord);\n        if (t < 1.0) {\n            color += texture(u_envMap, texCoord).rgb * (1.0 - blur) + texture(u_envMap, texCoord + vec2(blur, 0.0)).rgb * blur;\n        }\n    }\n    return color;\n}\n\n// from https://www.shadertoy.com/view/XljGDz\nvec", "\n    float d = distance(coords, A);\n    float d1 = distance(coords, B);\n    float t = clamp(d / (d1 + d), 0.0, 1.0);\n    return height * t;\n}\n\n//============================================================\nfloat", "\n    float dot = dot(start, end);\n    float theta = acos(dot);\n    float sinTheta = sin(theta);\n    if (sinTheta < 0.0001)\n    {\n        return normalize(start + end);\n    }\n    float theta2 = theta * percent;\n    float sinTheta2 = sin(theta2);\n    float cosTheta2 = cos(theta2);\n    return normalize(start * cosTheta2 + end * sinTheta2 / sinTheta);\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.02;\n    float t = mod(a, 2.0 * 3.14159265359);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n\n    float f = fract(r);\n    float f2 = fract(r * 0.5);\n    float f3 = fract(r * 0.25);\n    float f4 = fract(r * 0.125);\n    float f5 = fract(r * 0.0625);\n    float f6 = fract(r * 0.03125);\n    float f7 = fract(r * 0.015625);\n    float f8 = fract(r * 0.0078125);\n    float f9 = fract(r * 0.00390625);\n    float f10 = fract(r * 0.001953125);\n    float f11 = fract(r * 0.0009765625);\n    float f12 = fract(r * 0.00048828125);\n    float f13 = fract(r * 0.000244140625);\n    float f14 = fract(r * 0.0001220703125);\n    float f15 = fract(r * 0.00006103515625);\n    float f16 = fract(", "\n    //http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect\n    vec2 v = b - a;\n    vec2 w = p - a;\n    float c1 = dot(w, v);\n    if (c1 <= 0.0)\n        return length(w);\n    vec2 vv = v;\n    normalize(vv);\n    float c2 = dot(vv, w);\n    if (c2 >= 0.0 && c2 <= length(v))\n        return length(w - v * c2);\n    return min(length(w - v * c1), length(w - v * c2));\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    float lightIntensity = dot(lightDir, rayDir);\n    color = vec3(lightIntensity);\n    return color;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec", "\n    // The distance to the nearest surface.\n    float d = length(p.xz) - 1.0;\n\n    // The material index.\n    int m = 0;\n\n    // The distance to the nearest surface.\n    if (d < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = -d;\n\n        // The material index.\n        m = 1;\n    }\n\n    // The distance to the nearest surface.\n    if (p.y > 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, -p.y + 1.0);\n\n        // The material index.\n        m = 2;\n    }\n\n    // The distance to the nearest surface.\n    if (p.y < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, p.y - 1.0);\n\n        // The material index.\n        m = 3;\n    }\n\n    // The distance to the nearest surface.\n    if (p.x > 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, -p.x + 1.0);\n\n        // The material index.\n        m = 4;\n    }\n\n    // The distance to the nearest surface.\n    if (p.x < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, p.x - 1.0);\n\n        // The material index.\n        m = 5;\n    }\n\n    // The distance to the nearest surface.\n    if (p.z > 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, -p.z + 1.0);\n\n        // The material index.\n        m = 6;\n    }\n\n    // The distance to the nearest surface.\n    if (p.z < 0.0)\n    {\n        // The distance to the nearest surface.\n        d = max(d, p.z - 1.0);\n\n        // The material index.", "\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, org - vec3(0.0, 0.0, 0.0));\n    float c = dot(org - vec3(0.0, 0.0, 0.0), org - vec3(0.0, 0.0, 0.0)) - 1.0;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0)\n    {\n        near = far = -1.0;\n        return false;\n    }\n    d = sqrt(d);\n    float t0 = (-b - d) / (2.0 * a);\n    float t1 = (-b + d) / (2.0 * a);\n    if (t0 > t1)\n    {\n        near = t1;\n        far = t0;\n    }\n    else\n    {\n        near = t0;\n        far = t1;\n    }\n    return true;\n}\n\n// from https://www.shadertoy.com/view/4s23DX\nfloat", "\n    vec3 q = p - vec3(r.x, r.y, r.z);\n    vec3 q1 = q;\n    q.y -= s.y;\n    vec3 q2 = q;\n    q.y -= s.w;\n    vec3 q3 = q;\n    q.y -= s.z;\n    vec3 q4 = q;\n    q.y -= s.x;\n    vec3 q5 = q;\n    q.y -= s.y;\n    vec3 q6 = q;\n    q.y -= s.w;\n    vec3 q7 = q;\n    q.y -= s.z;\n    vec3 q8 = q;\n    q.y -= s.x;\n    vec3 q9 = q;\n    q.y -= s.y;\n    vec3 q10 = q;\n    q.y -= s.w;\n    vec3 q11 = q;\n    q.y -= s.z;\n    vec3 q12 = q;\n    q.y -= s.x;\n    vec3 q13 = q;\n    q.y -= s.y;\n    vec3 q14 = q;\n    q.y -= s.w;\n    vec3 q15 = q;\n    q.y -= s.z;\n    vec3 q16 = q;\n    q.y -= s.x;\n    vec3 q17 = q;\n    q.y -= s.y;\n    vec3 q18 = q;\n    q.y -= s.w;\n    vec3 q19 = q;\n    q.y -= s.z;\n    vec3 q20 = q;\n    q.y -= s.x;\n    vec3 q21 = q;\n    q.y -= s.y;\n    vec3 q22 = q;\n    q.y -= s.w;\n    vec3 q23 = q;\n", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    f = f*f*(3.0-2.0*f);\n\n    float n = i.x + i.y*57.0 + 113.0*i.z;\n\n    return mix(mix(mix(dot(f, vec3(1.0, 57.0, 113.0)),\n                        dot(f, vec3(57.0, 113.0, 17.0)),\n                        f.y),\n                   mix(dot(f, vec3(17.0, 113.0, 57.0)),\n                       dot(f, vec3(57.0, 17.0, 113.0)),\n                       f.y),\n                   f.z),\n               mix(mix(dot(f, vec3(57.0, 17.0, 113.0)),\n                       dot(f, vec3(17.0, 57.0, 113.0)),\n                       f.z),\n                   mix(dot(f, vec3(113.0, 57.0, 17.0)),\n                       dot(f, vec3(57.0, 113.0, 17.0)),\n                       f.z),\n                   f.x),\n               f.x);\n}\n\n//\n// This is a rewrite of IQ's original. It's self contained, which makes it much\n// easier to copy and paste. I've also tried my best to minimize the amount of \n// operations to lessen the work the GPU has to do, but I think there's room for\n// improvement.\n//\nfloat", "\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 1.0) * 0.5;\n    float c = cos(a);\n    float s = sin(a);\n    float t = (d - 1.0) * 0.5;\n    float x = r * c;\n    float y = r * s;\n    float z = t;\n    float w = (d - 1.0) * 0.5;\n    float u = (d - 1.0) * 0.5;\n    float v = (d - 1.0) * 0.5;\n    float r2 = r * r;\n    float s2 = s * s;\n    float t2 = t * t;\n    float x2 = x * x;\n    float y2 = y * y;\n    float z2 = z * z;\n    float w2 = w * w;\n    float u2 = u * u;\n    float v2 = v * v;\n    float r3 = r2 * r;\n    float s3 = s2 * s;\n    float t3 = t2 * t;\n    float x3 = x2 * x;\n    float y3 = y2 * y;\n    float z3 = z2 * z;\n    float w3 = w2 * w;\n    float u3 = u2 * u;\n    float v3 = v2 * v;\n    float r4 = r3 * r;\n    float s4 = s3 * s;\n    float t4 = t3 * t;\n    float x4 = x3 * x;\n    float y4 = y3 * y;\n    float z4 = z3 * z;\n    float w4 = w3 * w;\n    float u4 = u3 * u;\n    float v4 = v3 * v;\n    float r5 = r4 * r;\n    float s5 = s4 * s;\n    float t5 = t4 * t;\n    float x5 = x4 * x;\n    float y5 = y4 * y;\n    float z5 =", "\n    vec3 bump = texture(bumpMap, sp.xy).rgb;\n    bump = normalize(bump * 2.0 - 1.0);\n    bump = normalize(bump * bumpFactor + sn);\n    return bump;\n}\n\n//\n// Standard bump function.\n//\nvec", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    // Ambient\n    vec3 ambient = vec3(0.1, 0.1, 0.1);\n\n    // Diffuse\n    vec3 lightDir = normalize(vec3(1, 1, 1));\n    float diff = max(dot(n, lightDir), 0.0);\n    vec3 diffuse = vec3(0.5, 0.5, 0.5) * diff;\n\n    // Specular\n    vec3 viewDir = normalize(vec3(0, 0, 1));\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float spec = pow(max(dot(n, halfDir), 0.0), 32.0);\n    vec3 specular = vec3(1, 1, 1) * spec;\n\n    return (ambient + diffuse + specular) * 0.3;\n}\n\n// Raymarching\n// p : point,\n// n : normal at point\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.05;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n\n    vec2 q = vec2(a, b);\n    vec2 r = vec2(a, b);\n\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(q, q) > 4.0) break;\n        s = q;\n        q = q * q + p;\n    }\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(r, r) > 4.0) break;\n        t = r;\n        r = r * r + p;\n    }\n\n    vec3 col = vec3(0.0);\n    if (dot(s, s) > 4.0) col = vec3(1.0, 0.0, 0.0);\n    if (dot(t, t) > 4.0) col = vec3(0.0, 1.0, 0.0);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec3 col = vec3(0.0);\n    vec2 uv = vec2(atan(rd.z, rd.x), asin(rd.y));\n    uv *= vec2(0.1591, 0.3183);\n    uv += 0.5;\n    uv.x *= TAU;\n    uv.y *= TAU;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.002;\n    uv.y += frameTimeCounter * 0.002;\n    uv.x += frameTimeCounter * 0.", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float dp;\n    float dp2;\n    float dp3;\n    float dp4;\n    float dp5;\n    float dp6;\n    float dp7;\n    float dp8;\n    float dp9;\n    float dp10;\n    float dp11;\n    float dp12;\n    float dp13;\n    float dp14;\n    float dp15;\n    float dp16;\n    float dp17;\n    float dp18;\n    float dp19;\n    float dp20;\n    float dp21;\n    float dp22;\n    float dp23;\n    float dp24;\n    float dp25;\n    float dp26;\n    float dp27;\n    float dp28;\n    float dp29;\n    float dp30;\n    float dp31;\n    float dp32;\n    float dp33;\n    float dp34;\n    float dp35;\n    float dp36;\n    float dp37;\n    float dp38;\n    float dp39;\n    float dp40;\n    float dp41;\n    float dp42;\n    float dp43;\n    float dp44;\n    float dp45;\n    float dp46;\n    float dp47;\n    float dp48;\n    float dp49;\n    float dp50;\n    float dp51;\n    float dp52;\n    float dp53;\n    float dp54;\n    float dp55;\n    float dp56;\n    float dp57;\n    float dp58;\n    float dp59;\n    float dp60;", "\n    return length(p)-rad;\n}\n\n//cylinder\nfloat", "\n    float d = length(p);\n    float t = param.x;\n    float r = param.y;\n    float s = param.z;\n    float a = param.w;\n    float b = param.z;\n    float c = param.w;\n    float d1 = (d - r) / s;\n    float d2 = (d - a) / b;\n    float d3 = (d - c) / b;\n    float d4 = (d - c) / a;\n    float d5 = (d - b) / a;\n    float d6 = (d - b) / c;\n    float d7 = (d - a) / c;\n    float d8 = (d - t) / a;\n    float d9 = (d - t) / b;\n    float d10 = (d - t) / c;\n    float d11 = (d - t) / d;\n    float d12 = (d - t) / s;\n    float d13 = (d - t) / a;\n    float d14 = (d - t) / b;\n    float d15 = (d - t) / c;\n    float d16 = (d - t) / d;\n    float d17 = (d - t) / s;\n    float d18 = (d - t) / a;\n    float d19 = (d - t) / b;\n    float d20 = (d - t) / c;\n    float d21 = (d - t) / d;\n    float d22 = (d - t) / s;\n    float d23 = (d - t) / a;\n    float d24 = (d - t) / b;\n    float d25 = (d - t) / c;\n    float d26 = (d - t) / d;\n    float d27 = (d - t) / s;\n    float d28 = (d - t) / a;\n    float d29 = (d - t) / b;\n    float d30 = (d - t) / c;\n    float d31 = (", "\n    float d = DE_scene(p, param);\n    d = min(d, DE_light(p, param));\n    return d;\n}\n\n// scene distant with light gathering\nfloat", "\n    vec3 col = vec3(0.0);\n    vec3 bg = vec3(0.0);\n    vec3 sky = vec3(0.0);\n    vec3 kaliset = vec3(0.0);\n    vec3 kaliset2 = vec3(0.0);\n    vec3 kaliset3 = vec3(0.0);\n    vec3 kaliset4 = vec3(0.0);\n    vec3 kaliset5 = vec3(0.0);\n    vec3 kaliset6 = vec3(0.0);\n    vec3 kaliset7 = vec3(0.0);\n    vec3 kaliset8 = vec3(0.0);\n    vec3 kaliset9 = vec3(0.0);\n    vec3 kaliset10 = vec3(0.0);\n    vec3 kaliset11 = vec3(0.0);\n    vec3 kaliset12 = vec3(0.0);\n    vec3 kaliset13 = vec3(0.0);\n    vec3 kaliset14 = vec3(0.0);\n    vec3 kaliset15 = vec3(0.0);\n    vec3 kaliset16 = vec3(0.0);\n    vec3 kaliset17 = vec3(0.0);\n    vec3 kaliset18 = vec3(0.0);\n    vec3 kaliset19 = vec3(0.0);\n    vec3 kaliset20 = vec3(0.0);\n    vec3 kaliset21 = vec3(0.0);\n    vec3 kaliset22 = vec3(0.0);\n    vec3 kaliset23 = vec3(0.0);\n    vec3 kaliset24 = vec3(0.0);\n    vec3 kaliset25 = vec3(0.0);\n   ", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro + rd * ti;\n    float d = length(p);\n    if (d < 0.001)\n    {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    else\n    {\n        col = vec3(0.0, 0.0, 0.0);\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec2 muv = uv * 2.0 - 1.0;\n    muv.x *= iResolution.x / iResolution.y;\n\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(muv, 1.0));\n\n    float ti = 0.0;\n    float tf = 1000.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n\n    for (int i = 0; i < 100; i++)\n    {\n        ti = tmin;\n        tf = tmax;\n        float t = (ti + tf) * 0.5;\n        vec3 p = ro + rd * t;\n        float d = length(p);\n        if (d < 0.001)\n        {\n            break;\n        }\n        if (d < ti)\n        {\n            ti = d;\n        }\n        if (d > tf)\n        {\n            tf = d;\n        }\n    }\n\n    vec3 col = rayColor(ro, rd, ti);\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col,", "\n    vec2 q = abs(p - diamond.xy);\n    return min(max(q.x, q.y), diamond.z);\n}\n\n// triangle: (center.x, center.y, helf width, helf height)\nfloat", "\n    vec3 color = vec3(0.0);\n    float t = time * 0.01;\n    float r = length(uv);\n    float a = atan(uv.y, uv.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 1.0) * 10.0;\n    float n = floor(d);\n    float f = fract(d);\n    float p = n + f;\n    float w = p * 0.1;\n    float h = p * 0.1;\n    float x = w * c;\n    float y = h * s;\n    float z = w * s;\n    float rx = x * 0.1;\n    float ry = y * 0.1;\n    float rz = z * 0.1;\n    float rw = r * 0.1;\n    float rx2 = rx * 0.1;\n    float ry2 = ry * 0.1;\n    float rz2 = rz * 0.1;\n    float rw2 = rw * 0.1;\n    float rx3 = rx2 * 0.1;\n    float ry3 = ry2 * 0.1;\n    float rz3 = rz2 * 0.1;\n    float rw3 = rw2 * 0.1;\n    float rx4 = rx3 * 0.1;\n    float ry4 = ry3 * 0.1;\n    float rz4 = rz3 * 0.1;\n    float rw4 = rw3 * 0.1;\n    float rx5 = rx4 * 0.1;\n    float ry5 = ry4 * 0.1;\n    float rz5 = rz4 * 0.1;\n    float rw5 = rw4 * 0.1;\n    float rx6 = rx5 * 0.1;\n    float ry6 = ry5 * 0.1;\n   ", "\n    return length( pos - vec3( 0.5, 0.5, 0.5 ) );\n}\n\n// get distance in the world\nfloat", "\n    vec3 l = normalize(v - eye);\n    vec3 r = reflect(-l, n);\n    vec3 h = normalize(l + eye);\n    float s = pow(max(dot(n, l), 0.0), 10.0);\n    float t = pow(max(dot(n, h), 0.0), 10.0);\n    return (0.2 * s + 0.8 * t) * vec3(1.0, 1.0, 1.0);\n}\n\n// phong shading with specular highlights\nvec", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453);\n}\n\n// 2D noise with 2D gradient.\nfloat", "\n    float d = distance(p, vec2(0.5));\n    return pow(d, 1.0 - offset) * 0.5;\n}\n\n// 2D noise function. \nfloat", "\n    float xmts = x.x;\n    float xmts_a = x.y;\n    float xmts_b = x.z;\n    float xmts_c = x.w;\n    float xmts_d = x.z;\n    float xmts_e = x.w;\n    float xmts_f = x.w;\n    float xmts_g = x.w;\n    float xmts_h = x.w;\n    float xmts_i = x.w;\n    float xmts_j = x.w;\n    float xmts_k = x.w;\n    float xmts_l = x.w;\n    float xmts_m = x.w;\n    float xmts_n = x.w;\n    float xmts_o = x.w;\n    float xmts_p = x.w;\n    float xmts_q = x.w;\n    float xmts_r = x.w;\n    float xmts_s = x.w;\n    float xmts_t = x.w;\n    float xmts_u = x.w;\n    float xmts_v = x.w;\n    float xmts_w = x.w;\n    float xmts_x = x.w;\n    float xmts_y = x.w;\n    float xmts_z = x.w;\n    float xmts_aa = x.w;\n    float xmts_ab = x.w;\n    float xmts_ac = x.w;\n    float xmts_ad = x.w;\n    float xmts_ae = x.w;\n    float xmts_af = x.w;\n    float xmts_ag = x.w;\n    float xmts_ah = x.w;\n    float xmts_ai = x.w;\n    float xmts_aj = x.w;\n    float xmts_ak = x.w;\n    float xmts_al = x.w;\n    float xmts_", "\n    vec2 d = abs(vec2(length(p.xz) - r, p.y)) - h;\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n/**\n * Signed distance function for an XY aligned sphere centered at the origin with\n * radius r.\n */\nfloat", "\n    vec3 q = p;\n    q.xz *= mat2(1.0, 0.0, 0.0, 1.0);\n    q.yz *= mat2(1.0, 0.0, 0.0, 1.0);\n    return length(q) - 1.0;\n}\n\n/**\n * Signed distance function describing the scene.\n * \n * Absolute value of the return value indicates the distance to the surface.\n * Sign indicates whether the point is inside or outside the surface,\n * negative indicating inside.\n */\nfloat", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\n/**\n * Return a transform matrix that will transform a ray from world space\n * to view coordinates, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat", "\n    return 0.5 + 0.5*sin(p.x*100.0+p.y*100.0+p.z*100.0);\n}\n\n// my noise\nfloat", "\n\tvec4 color = vec4(0.0);\n\t\n\tfloat x = coord.x;\n\tfloat y = coord.y;\n\t\n\tfloat x1 = x - morphConstant.x;\n\tfloat y1 = y - morphConstant.y;\n\t\n\tfloat x2 = x + morphConstant.x;\n\tfloat y2 = y + morphConstant.y;\n\t\n\tfloat x3 = x - morphConstant.x;\n\tfloat y3 = y + morphConstant.y;\n\t\n\tfloat x4 = x + morphConstant.x;\n\tfloat y4 = y - morphConstant.y;\n\t\n\tfloat x5 = x - morphConstant.x;\n\tfloat y5 = y + morphConstant.y;\n\t\n\tfloat x6 = x + morphConstant.x;\n\tfloat y6 = y - morphConstant.y;\n\t\n\tfloat x7 = x - morphConstant.x;\n\tfloat y7 = y + morphConstant.y;\n\t\n\tfloat x8 = x + morphConstant.x;\n\tfloat y8 = y - morphConstant.y;\n\t\n\tfloat x9 = x - morphConstant.x;\n\tfloat y9 = y + morphConstant.y;\n\t\n\tfloat x10 = x + morphConstant.x;\n\tfloat y10 = y - morphConstant.y;\n\t\n\tfloat x11 = x - morphConstant.x;\n\tfloat y11 = y + morphConstant.y;\n\t\n\tfloat x12 = x + morphConstant.x;\n\tfloat y12 = y - morphConstant.y;\n\t\n\tfloat x13 = x - morphConstant.x;\n\tfloat y13 = y + morphConstant.y;\n\t\n\tfloat x14 = x + morphConstant.x;\n\tfloat y14 = y - morphConstant.y;\n\t\n\tfloat x15 = x - morphConstant.x;\n\tfloat y15 = y + morphConstant.y;\n\t\n\tfloat x16 = x + morphConstant.x;\n\tfloat y16 = y - morphConstant.y;\n\t\n\tfloat x17 = x - morphConstant.x;", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * w);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    float f = sin(p.x * 10.0) * sin(p.y * 10.0) * sin(p.z * 10.0);\n    f = f * f * (3.0 - 2.0 * f);\n    return f;\n}\n\n// The bump mapping function.\nfloat", "\n    vec4 ray_nds = vec4(scr_pt, 0.0, 1.0);\n    vec4 ray_clip = view_inv * ray_nds;\n    vec4 ray_eye = viewp_inv * ray_clip;\n    vec4 ray_world = proj_inv * ray_eye;\n    ray_world.xyz /= ray_world.w;\n    return ray_world;\n}\n\n// screen to world: http://bookofhook.com/mousepick.pdf\nvec", "\n    vec2 p = pA;\n    vec2 d = pB - pA;\n    float dl = length(d);\n    float dp = dot(d, uv - p);\n    float dl2 = dl * dl;\n    float dp2 = dp * dp;\n    float dl4 = dl2 * dl2;\n    float dp4 = dp2 * dp2;\n    float dl8 = dl4 * dl4;\n    float dp8 = dp4 * dp4;\n    float dl16 = dl8 * dl8;\n    float dp16 = dp8 * dp8;\n    float dl32 = dl16 * dl16;\n    float dp32 = dp16 * dp16;\n    float dl64 = dl32 * dl32;\n    float dp64 = dp32 * dp32;\n    float dl128 = dl64 * dl64;\n    float dp128 = dp64 * dp64;\n    float dl256 = dl128 * dl128;\n    float dp256 = dp128 * dp128;\n    float dl512 = dl256 * dl256;\n    float dp512 = dp256 * dp256;\n    float dl1024 = dl512 * dl512;\n    float dp1024 = dp512 * dp512;\n    float dl2048 = dl1024 * dl1024;\n    float dp2048 = dp1024 * dp1024;\n    float dl4096 = dl2048 * dl2048;\n    float dp4096 = dp2048 * dp2048;\n    float dl8192 = dl", "\n    // TODO: implement this function\n    // You can use the following variables:\n    //   p : the point at which the shading is performed\n    //   n : the normal at the point\n    //   light : the light source\n    //   light.position : the position of the light source\n    //   light.intensity : the intensity of the light source\n    //   light.color : the color of the light source\n    //   light.attenuation : the attenuation factor of the light source\n    //   light.type : the type of the light source (ambient, point, spot, directional)\n    //   light.spot.direction : the direction of the spotlight\n    //   light.spot.cutoff : the cutoff angle of the spotlight\n    //   light.spot.exponent : the exponent of the spotlight\n    //   light.spot.innerCutoff : the inner cutoff angle of the spotlight\n    //   light.spot.outerCutoff : the outer cutoff angle of the spotlight\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light.spot.color : the color of the spotlight\n    //   light.spot.intensity : the intensity of the spotlight\n    //   light.spot.attenuation : the attenuation factor of the spotlight\n    //   light.spot.type : the type of the spotlight (constant, linear, quadratic)\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light.spot.innerCutoff : the inner cutoff angle of the spotlight\n    //   light.spot.outerCutoff : the outer cutoff angle of the spotlight\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light.spot.color : the color of the spotlight\n    //   light.spot.intensity : the intensity of the spotlight\n    //   light.spot.attenuation : the attenuation factor of the spotlight\n    //   light.spot.type : the type of the spotlight (constant, linear, quadratic)\n    //   light.spot.falloff : the falloff factor of the spotlight\n    //   light.", "\n    vec2 res = vec2( 1e10 );\n    vec3 q = rd / rd.z;\n    vec3 t1 = (cen - ro) * q;\n    vec3 t2 = (cen - ro) * q + vec3( rad.x, rad.y, rad.z );\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    res.x = max( tmin.x, max( tmin.y, tmin.z ) );\n    res.y = min( tmax.x, min( tmax.y, tmax.z ) );\n    return res;\n}\n\n// ray-box intersection (simplified)\nvec", "\n  return sin(x * a) * 0.5 + sin(x * b) * 0.5 + 0.5;\n}\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat", "\n    return vec2(a.x * b.x, a.y * b.y);\n}\n\n// z * z\nvec", "\n    vec3 ab = pb - pa;\n    vec3 ap = pa - ro;\n    float b = dot(ab, rd);\n    float c = dot(ab, ab) - ra*ra;\n    float d = b*b - c;\n    if (d < 0.0) return vec4(0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) t = -b + sqrt(d);\n    if (t < 0.0) return vec4(0.0);\n    vec3 p = ro + t*rd;\n    vec3 n = normalize(p - pa);\n    return vec4(t, n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec", "\n    vec3 P0 = O.xyz;\n    vec3 P1 = O.xyz + vec3(U.x, U.y, 0.0);\n    vec3 P2 = O.xyz + vec3(U.x, 0.0, U.y);\n    vec3 P3 = O.xyz + vec3(0.0, U.y, U.x);\n    vec3 P4 = O.xyz + vec3(0.0, 0.0, U.x);\n    vec3 P5 = O.xyz + vec3(U.x, U.y, U.x);\n    vec3 P6 = O.xyz + vec3(U.x, U.x, U.y);\n    vec3 P7 = O.xyz + vec3(U.x, U.x, 0.0);\n    vec3 P8 = O.xyz + vec3(0.0, U.x, U.y);\n    vec3 P9 = O.xyz + vec3(0.0, U.x, 0.0);\n    vec3 P10 = O.xyz + vec3(U.x, 0.0, 0.0);\n    vec3 P11 = O.xyz + vec3(0.0, 0.0, 0.0);\n    vec3 P12 = O.xyz + vec3(0.0, U.y, 0.0);\n    vec3 P13 = O.xyz + vec3(0.0, 0.0, 0.0);\n    vec3 P14 = O.xyz + vec3(0.0, 0.0, U.x);\n    vec3 P15 = O.xyz + vec3(0.0, U.y, U.x);\n    vec3 P16 = O.xyz + vec3(0.0, U.y, 0.0);\n    vec3 P17 = O.xyz +", "\n    float d = dot(p, p);\n    return sqrt(d);\n}\n\n// distance estimation of the scene\nfloat", "\n    vec3 color = vec3(0.0);\n    float scale = 1.0;\n    float scaleFactor = 1.0;\n    float scaleFactor2 = 1.0;\n    float scaleFactor3 = 1.0;\n    float scaleFactor4 = 1.0;\n    float scaleFactor5 = 1.0;\n    float scaleFactor6 = 1.0;\n    float scaleFactor7 = 1.0;\n    float scaleFactor8 = 1.0;\n    float scaleFactor9 = 1.0;\n    float scaleFactor10 = 1.0;\n    float scaleFactor11 = 1.0;\n    float scaleFactor12 = 1.0;\n    float scaleFactor13 = 1.0;\n    float scaleFactor14 = 1.0;\n    float scaleFactor15 = 1.0;\n    float scaleFactor16 = 1.0;\n    float scaleFactor17 = 1.0;\n    float scaleFactor18 = 1.0;\n    float scaleFactor19 = 1.0;\n    float scaleFactor20 = 1.0;\n    float scaleFactor21 = 1.0;\n    float scaleFactor22 = 1.0;\n    float scaleFactor23 = 1.0;\n    float scaleFactor24 = 1.0;\n    float scaleFactor25 = 1.0;\n    float scaleFactor26 = 1.0;\n    float scaleFactor27 = 1.0;\n    float scaleFactor28 = 1.0;\n    float scaleFactor29 = 1.0;\n    float scaleFactor30 = 1.0;\n    float scaleFactor31 = 1.0;\n    float scaleFactor32 = 1.0;\n    float scaleFactor33 = 1.0;\n    float scaleFactor34 = 1.0;\n    float scaleFactor35 = 1.0;\n    float scaleFactor36 = 1.0;\n    float scaleFactor37 = 1.0;\n    float scaleFactor38 = 1.0;\n    float scale", "\n    vec3 color = vec3(0.0);\n    vec2 q = p;\n    float r = length(q);\n    if(r < 0.5){\n        color = vec3(1.0);\n    }\n    else{\n        float t = (r-0.5) * 2.0;\n        color = vec3(0.5 + 0.5 * cos(t * 3.1415926535897932384626433832795));\n    }\n    return color;\n}\n\n// The decrotated scale tiles. Render one set of decorated fans, combine them with the\n// other set, then add some highlighting and postprocessing.\nvec", "\n    float flameRadius = 0.00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    // 1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.1.", "\n    return fract(x * sm) - 0.5 * sm;\n}\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat", "\n    p = fract(p * vec3(12345.6789, 12345.6789, 12345.6789));\n    p += dot(p, p + 19.19);\n    return fract(vec3(dot(p, p + 137.19), dot(p, p + 269.59), dot(p, p + 41.71)));\n}\n\n// 3D noise function.\nfloat", "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    return mix(mix(mix(dot(f, vec3(1.0, 57.0, 113.0)), dot(f, vec3(57.0, 113.0, 17.0)), f.y),\n        mix(dot(f, vec3(113.0, 57.0, 17.0)), dot(f, vec3(17.0, 113.0, 57.0)), f.y), f.z),\n        mix(mix(dot(f, vec3(57.0, 17.0, 113.0)), dot(f, vec3(17.0, 57.0, 113.0)), f.y),\n        mix(dot(f, vec3(113.0, 17.0, 57.0)), dot(f, vec3(57.0, 113.0, 17.0)), f.y), f.z),\n        f.x);\n}\n\n// 3D Simplex noise.\nfloat", "\n    return 0.5*sin(p.x*10.0)+0.5*sin(p.y*10.0);\n}\n\n// The function value. In this case, slightly-tapered, quantized Simplex noise.\nfloat", "\n    vec2 balloon = vec2( 0.0 );\n    float balloonRadius = 0.001;\n    float balloonHeight = 0.001;\n    float balloonWidth = 0.001;\n    float balloonDepth = 0.001;\n    float balloonX = currentRayPosition.x;\n    float balloonY = currentRayPosition.y;\n    float balloonZ = currentRayPosition.z;\n    float balloonX2 = balloonX + balloonWidth;\n    float balloonY2 = balloonY + balloonHeight;\n    float balloonZ2 = balloonZ + balloonDepth;\n    float balloonX3 = balloonX - balloonWidth;\n    float balloonY3 = balloonY - balloonHeight;\n    float balloonZ3 = balloonZ - balloonDepth;\n    float balloonX4 = balloonX + balloonWidth;\n    float balloonY4 = balloonY - balloonHeight;\n    float balloonZ4 = balloonZ + balloonDepth;\n    float balloonX5 = balloonX - balloonWidth;\n    float balloonY5 = balloonY + balloonHeight;\n    float balloonZ5 = balloonZ - balloonDepth;\n    float balloonX6 = balloonX + balloonWidth;\n    float balloonY6 = balloonY + balloonHeight;\n    float balloonZ6 = balloonZ - balloonDepth;\n    float balloonX7 = balloonX - balloonWidth;\n    float balloonY7 = balloonY - balloonHeight;\n    float balloonZ7 = balloonZ + balloonDepth;\n    float balloonX8 = balloonX + balloonWidth;\n    float balloonY8 = balloonY - balloonHeight;\n    float balloonZ8 = balloonZ + balloonDepth;\n    float balloonX9 = balloonX - balloonWidth;\n    float balloonY9 = balloonY + balloonHeight;\n    float balloonZ9 = balloonZ - balloonDepth;\n    float balloonX10 = balloonX + balloonWidth", "\n    vec3 n = sign(rd);\n    vec3 k = abs(n) - rad;\n    vec3 t1 = k / rd;\n    vec3 t2 = k / ro;\n    vec3 tmin = min(t1, t2);\n    vec3 tmax = max(t1, t2);\n    vec4 r = vec4(tmin.x, tmin.yz);\n    if(tmax.x < 0.0) discard;\n    r.yz = max(r.yz, tmax.yx);\n    return r;\n}\n\n// ray sphere intersection by iq https://www.shadertoy.com/view/ld23DV\nvec", "\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = p.x + p.y + p.z;\n    return -1.0 + 2.0*f.x + f.y + f.z + f.x + f.y + f.z + f.x + f.y + f.z;\n}\n\n// 3D Simplex noise.\nfloat", "\n    vec2 ab = b-a;\n    vec2 ac = c-a;\n    vec2 ap = p-a;\n    vec2 bp = p-b;\n    vec2 cp = p-c;\n    vec2 apxb = cross(ap,ab);\n    vec2 apxc = cross(ap,ac);\n    vec2 bpxc = cross(bp,ac);\n    vec2 bpxa = cross(bp,ab);\n    vec2 cpxa = cross(cp,ab);\n    vec2 cpxb = cross(cp,bc);\n    float d1 = dot(apxb,ab);\n    float d2 = dot(apxc,ac);\n    float d3 = dot(bpxa,ab);\n    float d4 = dot(bpxc,ac);\n    float d5 = dot(cpxa,ab);\n    float d6 = dot(cpxb,bc);\n    float denom = d1*d4 - d3*d2;\n    float v1 = (d5*d4 - d3*d6)/denom;\n    float v2 = (d2*d1 - d4*d3)/denom;\n    return c + v1*ab + v2*ac;\n}\n\n//coloring lineAO()\nvec", "\n    float a = 0.0;\n    for(int i = 0; i < 100; i++){\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        if(length(z) > 2.0){\n            return float(i)/100.0;\n        }\n    }\n    return 0.0;\n}\n\n//Fractal calculation loop\nfloat", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n    return mat4(x, y, z, vec4(0, 0, 0, 1));\n}\n\n//perspective matrix\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\n//color space\nvec", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float d = w / 2.0;\n    float c = cos(a);\n    float s = sin(a);\n    float x = r * c;\n    float y = r * s;\n    float t = (x * c + y * s) / d;\n    float u = (x * s - y * c) / d;\n    return t * u;\n}\n\n// This is the main function. It's a bit of a mess, but it's pretty easy to understand.\n// The first thing it does is check if the mouse is inside the circle. If it is, it\n// returns 1. If it's not, it returns 0.\nfloat", "\n    return clamp((x - a) / (b - a), 0.0, 1.0);\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat", "\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol)\n{\n    float x = xy.x;\n    float y = xy.y;\n    float z = xy.z;\n    float w = xy.w;\n\n    float f = func(x, y, z, w);\n\n    baseCol.rgb = curveCol.rgb;\n    baseCol.a = curveCol.a;\n\n    baseCol.rgb *= f;", "\n    float d=1.0;\n    for(int i=0;i<4;i++){\n        d=min(d,length(p-voronoi(p+vec2(0.0,j*i*0.1),j)));\n    }\n    return d;\n}\n\nfloat", "\n    return smoothstep(0.0,1.0,f);\n}\n\n//making a linear gradient smoothe and more erroded.\nfloat", "\n    vec3 rgb = vec3(0.0);\n    rgb.r = c.r * 0.299 + c.g * 0.587 + c.b * 0.114;\n    rgb.g = c.r * 0.5957 + c.g * 0.332 + c.b * 0.131;\n    rgb.b = c.r * 0.2115 + c.g * 0.7152 + c.b * 0.0722;\n    return rgb;\n}\n\n//enhance the hue of a color\nvec", "\n    vec4 d = vec4(0.0);\n    d.x = max(abs(p.x)-s.x,0.0);\n    d.y = max(abs(p.y)-s.y,0.0);\n    d.z = max(abs(p.z)-s.z,0.0);\n    return d;\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec", "\n    vec4 rv = vec4(0.0);\n    if(s==0) {\n        rv.x = sdSphere(p,r.x);\n        rv.y = sdBox(p,vec3(r.x,r.y,r.y));\n        rv.z = sdCylinder(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCone(p,vec2(r.x,r.y),r.y);\n    }\n    else if(s==1) {\n        rv.x = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.y = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.z = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCapsule(p,vec2(r.x,r.y),r.y);\n    }\n    else if(s==2) {\n        rv.x = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.y = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.z = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCapsule(p,vec2(r.x,r.y),r.y);\n    }\n    else if(s==3) {\n        rv.x = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.y = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.z = sdCapsule(p,vec2(r.x,r.y),r.y);\n        rv.w = sdCapsule(", "\n    Material mat = Material(vec3(0.0), vec3(0.0), vec3(0.0));\n    vec3 sourceMaterial = vec3(0.0);\n    vec3 targetMaterial = vec3(0.0);\n    float interpolant = 0.0;\n\n    // If we're at the end of the scene, return the final material\n    if (steps == 0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 0.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 1.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 2.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 3.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 4.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 5.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 6.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n\n    // If we're at the end of the scene, return the final material\n    if (depth == 7.0)\n    {\n        return Material(sourceMaterial, targetMaterial, interpolant);\n    }\n", "\n    return clamp(x * (2.51 * x + 0.04), 0.0, 1.0);\n}\n\n// https://knarkowicz.wordpress.com/2016/01/06/aces-filmic-tone-mapping-curve/\nvec", "\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n    float ay = 0.0;\n    float az = 0.0;\n    float ba = 0.0;\n    float bb = 0.0;\n    float bc = 0.0;\n    float bd = 0.0", "\n    vec3 n = normal(p);\n    vec3 r = reflect(lightDir(p), n);\n    float s = max(0.0, dot(r, viewDir));\n    return vec4(vec3(s), 1.0);\n}\n\n//scene light at position p\nvec", "\n    float f = 0.0;\n    float a = 0.5;\n    vec2 shift = vec2(100);\n    // Rotate to reduce axial bias\n    mat2 rot = mat2(cos(0.5), sin(0.5), -sin(0.5), cos(0.50));\n    for (int i = 0; i < 5; ++i) {\n        f += a * noise(p);\n        p = rot * p * 2.02 + shift;\n        a *= 0.5;\n    }\n    return f;\n}\n\n// returns a fractal noise in a 3D space\nfloat", "\n    p = p*2.-1.;\n    float a = dot(p,p);\n    float b = dot(p,vec2(p.y, -p.x));\n    float c = dot(p,vec2(-p.y, p.x));\n    float d = dot(p,vec2(p.y,-p.y));\n    float e = dot(p,vec2(-p.x,-p.x));\n    float f = dot(p,vec2(p.x,-p.x));\n    float g = dot(p,vec2(-p.x,p.x));\n    float h = dot(p,vec2(p.x,p.x));\n    float i = dot(p,vec2(p.y,p.y));\n    float j = dot(p.xz,p.xz);\n    float k = dot(p.yz,p.yz);\n    float l = dot(p.xz,p.yz);\n    float m = dot(p.xz,p.xz);\n    float n = dot(p.yz,p.xz);\n    float o = dot(p.yz,p.yz);\n    float p = dot(p.xz,p.yz);\n    float q = dot(p.xz,p.xz);\n    float r = dot(p.yz,p.xz);\n    float s = dot(p.yz,p.yz);\n    float t = dot(p.xz,p.yz);\n    float u = dot(p.xz,p.xz);\n    float v = dot(p.yz,p.xz);\n    float w = dot(p.yz,p.yz);\n    float x = dot(p.xz,p.yz);\n    float y = dot(p.xz,p.xz);\n    float z = dot(p.yz,p.xz);\n    float aa = a*a;\n    float ab = a*b;\n    float ac = a*c;\n    float ad = a*d;\n    float a", "\n    return dot(u,m);\n}\n\n//return __signed distance of [u] to line trough (0,0) and [m], m must be normalized.\nfloat", "\n    float d = dot(u,m);\n    return d;\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat", "\n    vec2 d = u - m.xy;\n    vec2 d1 = abs(d) - m.zw;\n    return length(max(d,0.0)) + min(max(d1.x,d1.y),0.0);\n}\n\n//return signed distance of u to line trough m.xy and m.zw\nfloat", "\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;\n}\n/* end__.Main\n   start.Implicit\n*/\n\n/* start__.Implicit\n   start.Main\n*/\nv2 c(v1 U){\n  return v1;", "\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U, v10 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U", "\n    return normalize(a - dot(a, b) * b);\n}\n\n//Gram-Schmidt method\nvec", "\n    vec3 v0 = B - A;\n    vec3 v1 = C - A;\n    vec3 v2 = cross(v0, v1);\n    float a = length(v2);\n    float alpha = acos(dot(v0, v1) / (a * length(v0)));\n    float beta = acos(dot(v1, v2) / (a * length(v1)));\n    float gamma = acos(dot(v2, v0) / (a * length(v2)));\n    float s = sin(alpha);\n    float c = cos(alpha);\n    float t = sin(beta);\n    float u = cos(beta);\n    float p = sin(gamma);\n    float q = cos(gamma);\n    float r = sqrt(Xi1);\n    float sigma = sqrt(Xi2);\n    float z = r * c * t;\n    float x = r * s * p;\n    float y = r * s * q;\n    w = vec3(x, y, z);\n    wPdf = (a * sigma * s) / (4.0 * PI);\n}\n\n//Function which does triangle sampling proportional to their solid angle.\n//You can find more information and pseudocode here:\n// * Stratified Sampling of Spherical Triangles. J Arvo - \u200e1995\n// * Stratified sampling of 2d manifolds. J Arvo - \u200e2001\nvoid sampleSphericalTriangle(in vec3 A, in vec3 B, in vec3 C, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec3 v0 = B - A;\n    vec3 v1 = C - A;\n    vec3 v2 = cross(v0, v1);\n    float a = length(v2);\n    float alpha = acos(dot(v0, v1) / (a * length(v0)));\n    float beta = acos(dot(v1, v2) / (a * length(v1)));\n    float gamma = acos(dot(", "\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U, v5 U, v6 U, v7 U, v8 U, v9 U, v10 U){\n   return v1;\n}\n\n/* end__.Implicit\n   start.Main\n*/\nv2 c(v1 U, v2 U, v3 U, v4 U", "\n    float d = length(p);\n    if(d < 0.5){\n        return 1.0;\n    }\n    return 0.0;\n}\n\n// Tube: Cylindrical tube, square tube, etc. In this case, it's a squarish tube with some\n// beveled sides.\nfloat", "\n    vec4 res = vec4(0.0);\n    float d = length(p.xy);\n    if(d < 0.5){\n        res.rgb = vec3(0.0);\n        res.a = 1.0;\n    }\n    else{\n        res.rgb = vec3(0.0);\n        res.a = 0.0;\n    }\n    return res;\n}\n\n// The toroidal tube objects. Each consist of a white squarish outer tube, a similar colored \n// inner one (only visible through the holes) and some colored bands.\nvec", "\n    float d = distance(p, vec3(0.0));\n    float t = gID;\n    float a = t * 0.01;\n    float b = t * 0.02;\n    float c = t * 0.03;\n    float d1 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d2 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d3 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d4 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d5 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d6 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d7 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d8 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d9 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d10 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d11 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d12 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d13 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d14 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d15 = distance(p, vec3(0.0, 0.0, 0.0));\n    float d16 = distance(p, vec3(0.0, 0.", "\n\tfloat t = 0.0;\n\tfloat tmin = 0.001;\n\tfloat tmax = 1000.0;\n\tfloat tmin2 = 0.001;\n\tfloat tmax2 = 1000.0;\n\tfloat tmin3 = 0.001;\n\tfloat tmax3 = 1000.0;\n\tfloat tmin4 = 0.001;\n\tfloat tmax4 = 1000.0;\n\tfloat tmin5 = 0.001;\n\tfloat tmax5 = 1000.0;\n\tfloat tmin6 = 0.001;\n\tfloat tmax6 = 1000.0;\n\tfloat tmin7 = 0.001;\n\tfloat tmax7 = 1000.0;\n\tfloat tmin8 = 0.001;\n\tfloat tmax8 = 1000.0;\n\tfloat tmin9 = 0.001;\n\tfloat tmax9 = 1000.0;\n\tfloat tmin10 = 0.001;\n\tfloat tmax10 = 1000.0;\n\tfloat tmin11 = 0.001;\n\tfloat tmax11 = 1000.0;\n\tfloat tmin12 = 0.001;\n\tfloat tmax12 = 1000.0;\n\tfloat tmin13 = 0.001;\n\tfloat tmax13 = 1000.0;\n\tfloat tmin14 = 0.001;\n\tfloat tmax14 = 1000.0;\n\tfloat tmin15 = 0.001;\n\tfloat tmax15 = 1000.0;\n\tfloat tmin16 = 0.001;\n\tfloat tmax16 = 1000.0;\n\tfloat tmin17 = 0.001;\n\tfloat tmax17 = 1000.0;\n\tfloat tmin18 = 0.001;\n\tfloat tmax18 = 1000.0;\n", "\n    float d = length(lp - ro);\n    float f = k / (d * d);\n    return f * exp(-t * f);\n}\n\n// The main raymarching function.\nfloat", "\n    vec3 q = p;\n    vec3 d = vec3(0.0);\n    float dd = 0.0;\n    float ddd = 0.0;\n    float dddd = 0.0;\n    float ddddd = 0.0;\n    float dddddd = 0.0;\n    float ddddddd = 0.0;\n    float dddddddd = 0.0;\n    float ddddddddd = 0.0;\n    float dddddddddd = 0.0;\n    float ddddddddddd = 0.0;\n    float dddddddddddd = 0.0;\n    float ddddddddddddd = 0.0;\n    float dddddddddddddd = 0.0;\n    float ddddddddddddddd = 0.0;\n    float dddddddddddddddd = 0.0;\n    float ddddddddddddddddd = 0.0;\n    float dddddddddddddddddd = 0.0;\n    float ddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddddddddd = 0.0;\n   ", "\n    vec3 p0 = m[0] * p3;\n    vec3 p1 = m[1] * p3;\n    vec3 p2 = m[2] * p3;\n    vec3 p4 = m[3] * p3;\n    vec3 p5 = m[4] * p3;\n    vec3 p6 = m[5] * p3;\n    vec3 p7 = m[6] * p3;\n    vec3 p8 = m[7] * p3;\n    vec3 p9 = m[8] * p3;\n    vec3 p10 = m[9] * p3;\n    vec3 p11 = m[10] * p3;\n    vec3 p12 = m[11] * p3;\n    vec3 p13 = m[12] * p3;\n    vec3 p14 = m[13] * p3;\n    vec3 p15 = m[14] * p3;\n    vec3 p16 = m[15] * p3;\n    vec3 p17 = m[16] * p3;\n    vec3 p18 = m[17] * p3;\n    vec3 p19 = m[18] * p3;\n    vec3 p20 = m[19] * p3;\n    vec3 p21 = m[20] * p3;\n    vec3 p22 = m[21] * p3;\n    vec3 p23 = m[22] * p3;\n    vec3 p24 = m[23] * p3;\n    vec3 p25 = m[24] * p3;\n    vec3 p26 = m[25] * p3;\n    vec3 p27 = m[26] * p3;\n    vec3 p28 = m[27] * p3;\n    vec3 p29 = m[28] * p3;\n    vec3 p30 =", "\n    vec4 hex = vec4(p, 0.0, 1.0);\n    hex.xy = mod(hex.xy, 2.0) - 1.0;\n    return hex;\n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID - in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything - in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec", "\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float b = atan(p.y, -p.x);\n    float c = atan(p.x, p.y);\n    float d1 = abs(a - dir);\n    float d2 = abs(b - dir);\n    float d3 = abs(c - dir);\n    return min(d1, min(d2, d3));\n}\n\n// Truchet pattern distance field.\nfloat", "\n    return atan2(q.y, q.x) + dir;\n}\n\n// Get the polar coordinate of the arc pixel.\nfloat", "\n    vec3 v0 = p3 - n[0];\n    vec3 v1 = p3 - n[1];\n    vec3 v2 = p3 - n[2];\n    vec3 v3 = p3 - t;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d02 = dot(v0, v2);\n    float d11 = dot(v1, v1);\n    float d12 = dot(v1, v2);\n    float d22 = dot(v2, v2);\n    float inv_det = 1.0 / (d00 * d11 * d22 + d01 * d12 * d02 + d02 * d10 * d01 - d00 * d12 * d11 - d01 * d10 * d22 - d02 * d11 * d00);\n    return vec4(\n        (d11 * d22 - d12 * d12) * inv_det,\n        (d02 * d22 - d01 * d22) * inv_det,\n        (d01 * d12 - d02 * d11) * inv_det,\n        1.0\n    );\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n    vec4 s = cross(q, p);\n    float d = dot(s, r);\n    return d * d;\n}\n\n// Find the (squared) distance to the plane in R3 but\n// using homogeneous coordinates.\nfloat", "\n    float d = length(p);\n    return smoothstep(lW, lW+0.01, d);\n}\n\n// A simple 2D noise function.\nfloat", "\n    vec2 d = ddx * ddy;\n    return 0.25 * (\n        (p.x + p.y) * (p.x - p.y) * (p.x + p.y) * (p.x - p.y) * d.x * d.y +\n        (p.x - p.y) * (p.x + p.y) * (p.x - p.y) * (p.x + p.y) * d.x * d.y +\n        (p.x + p.y) * (p.x - p.y) * (p.x - p.y) * (p.x + p.y) * d.x * d.y +\n        (p.x - p.y) * (p.x - p.y) * (p.x + p.y) * (p.x + p.y) * d.x * d.y\n    );\n}\n\n// grid ratio\nfloat", "\n    float d = dot( n, n );\n    if( d > 0.0 )\n    {\n        float d2 = dot( f, f );\n        if( d2 > d )\n        {\n            float d3 = d2 - d;\n            float d4 = d3 * d3;\n            float d5 = d4 * d4;\n            float d6 = d5 * d5;\n            float d7 = d6 * d6;\n            float d8 = d7 * d7;\n            float d9 = d8 * d8;\n            float d10 = d9 * d9;\n            float d11 = d10 * d10;\n            float d12 = d11 * d11;\n            float d13 = d12 * d12;\n            float d14 = d13 * d13;\n            float d15 = d14 * d14;\n            float d16 = d15 * d15;\n            float d17 = d16 * d16;\n            float d18 = d17 * d17;\n            float d19 = d18 * d18;\n            float d20 = d19 * d19;\n            float d21 = d20 * d20;\n            float d22 = d21 * d21;\n            float d23 = d22 * d22;\n            float d24 = d23 * d23;\n            float d25 = d24 * d24;\n            float d26 = d25 * d25;\n            float d27 = d26 * d26;\n            float d28 = d27 * d27;\n            float d29 = d28 * d28;\n            float d30 = d29 * d29;\n            float d31 = d30 * d30;\n            float d32 = d31 * d31;\n            float d33 = d32 * d32;\n            float d34 = d33 * d33;\n            float d35 = d", "\n    return vec2(\n        lerp(p1.x,p2.x,t),\n        lerp(p1.y,p2.y,t)\n    );\n}\n\n////////////////////////////// POSICAO PONTOS\nvec", "\n    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n    return -1.0 + 2.0 * fract(sin(p) * 43758.5453);\n}\n\n// 2D noise with 2D gradient.\nfloat", "\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\n// vec3 to vec3 hash.\nfloat", "\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p0;\n    vec2 c = p0;\n    float d = dot(a, a);\n    float e = dot(b, b);\n    float f = dot(a, b);\n    float D = d * e - f * f;\n    if(D == 0.0) return c;\n    float sc = (dot(a, a) - dot(b, b) + D) / 2.0;\n    float tc = (dot(b, b) - dot(a, a) + D) / 2.0;\n    return c + a * sc + b * tc;\n}\n\n// Triangle's circumcenter: The center of the circumcircle, which in essence is the smallest\n// circle that you can fit into a triangle.\nvec", "\n    float a = dist(p0, p1);\n    float b = dist(p1, p2);\n    float c = dist(p2, p0);\n    float s = (a + b + c) / 2.0;\n    return sqrt(s * (s - a) * (s - b) * (s - c));\n}\n\n// The area of the triangle:\nfloat", "\n    vec2 v1 = h1 - h2;\n    vec2 v2 = h3 - h2;\n    vec2 v3 = h1 - h3;\n    vec2 v4 = h2 - h3;\n    vec2 v5 = h1 - h1;\n    vec2 v6 = h2 - h2;\n    vec2 v7 = h3 - h3;\n    vec2 v8 = h1 - h1;\n    vec2 v9 = h2 - h2;\n    vec2 v10 = h3 - h3;\n    vec2 v11 = h1 - h1;\n    vec2 v12 = h2 - h2;\n    vec2 v13 = h3 - h3;\n    vec2 v14 = h1 - h1;\n    vec2 v15 = h2 - h2;\n    vec2 v16 = h3 - h3;\n    vec2 v17 = h1 - h1;\n    vec2 v18 = h2 - h2;\n    vec2 v19 = h3 - h3;\n    vec2 v20 = h1 - h1;\n    vec2 v21 = h2 - h2;\n    vec2 v22 = h3 - h3;\n    vec2 v23 = h1 - h1;\n    vec2 v24 = h2 - h2;\n    vec2 v25 = h3 - h3;\n    vec2 v26 = h1 - h1;\n    vec2 v27 = h2 - h2;\n    vec2 v28 = h3 - h3;\n    vec2 v29 = h1 - h1;\n    vec2 v30 = h2 - h2;\n    vec2 v31 = h3 - h3;\n    vec2 v32 = h1 - h1;\n    vec2 v33 = h2 - h2;\n    vec2 v34 = h3 - h3;\n    vec2 v35 = h1", "\n    triObj t;\n    t.p = p;\n    t.c = vec3(0.0);\n    t.n = vec3(0.0);\n    t.t = vec3(0.0);\n    t.i = vec3(0.0);\n    t.j = vec3(0.0);\n    t.k = vec3(0.0);\n    t.l = vec3(0.0);\n    t.m = vec3(0.0);\n    t.n = vec3(0.0);\n    t.o = vec3(0.0);\n    t.q = vec3(0.0);\n    t.r = vec3(0.0);\n    t.s = vec3(0.0);\n    t.t = vec3(0.0);\n    t.u = vec3(0.0);\n    t.v = vec3(0.0);\n    t.w = vec3(0.0);\n    t.x = vec3(0.0);\n    t.y = vec3(0.0);\n    t.z = vec3(0.0);\n    t.a = vec3(0.0);\n    t.b = vec3(0.0);\n    t.c = vec3(0.0);\n    t.d = vec3(0.0);\n    t.e = vec3(0.0);\n    t.f = vec3(0.0);\n    t.g = vec3(0.0);\n    t.h = vec3(0.0);\n    t.i = vec3(0.0);\n    t.j = vec3(0.0);\n    t.k = vec3(0.0);\n    t.l = vec3(0.0);\n    t.m = vec3(0.0);\n    t.n = vec3(0.0);\n    t.o = vec3(0.0);\n    t.p = vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float t = iTime;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 0.01) / 0.08;\n    float d2 = d * d;\n    float d3 = d2 * d;\n    float d4 = d3 * d;\n    float d5 = d4 * d;\n    float d6 = d5 * d;\n    float d7 = d6 * d;\n    float d8 = d7 * d;\n    float d9 = d8 * d;\n    float d10 = d9 * d;\n    float d11 = d10 * d;\n    float d12 = d11 * d;\n    float d13 = d12 * d;\n    float d14 = d13 * d;\n    float d15 = d14 * d;\n    float d16 = d15 * d;\n    float d17 = d16 * d;\n    float d18 = d17 * d;\n    float d19 = d18 * d;\n    float d20 = d19 * d;\n    float d21 = d20 * d;\n    float d22 = d21 * d;\n    float d23 = d22 * d;\n    float d24 = d23 * d;\n    float d25 = d24 * d;\n    float d26 = d25 * d;\n    float d27 = d26 * d;\n    float d28 = d27 * d;\n    float d29 = d28 * d;\n    float d30 = d29 * d;\n   ", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = 2.0 * dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return false;\n    else\n    {\n        float temp = sqrt( discriminant );\n        float q = ( b > 0.0 )? ( -0.5 * ( b + temp ) ) : ( -0.5 * ( b - temp ) );\n        t = q / a;\n        if ( t < tmin || tmax < t )\n            return false;\n        else\n        {\n            hitPos = ray.origin + t * ray.direction;\n            hitNormal = ( hitPos - sph.center ) / sph.radius;\n            return true;\n        }\n    }\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n//\u8ba1\u7b97\u7403\u4f53\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n//\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n//\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax,\n                      out float t, out vec3 hitPos, out vec3 hitNormal ) \n{\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction", "\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray.origin - sph.center ) - sph.radius * sph.radius;\n\n    // Compute the discriminant.\n    float discriminant = b * b - c;\n\n    // If the discriminant is negative, there is no intersection.\n    if ( discriminant < 0.0f )\n    {\n        return false;\n    }\n\n    // Compute the square root of the discriminant.\n    float sqrt_discriminant = sqrt( discriminant );\n\n    // Compute the nearest root that lies in the acceptable range.\n    float root = (-b - sqrt_discriminant) / 2.0f;\n    if ( root < tmin )\n    {\n        root = (-b + sqrt_discriminant) / 2.0f;\n        if ( root < tmin )\n        {\n            return false;\n        }\n    }\n\n    // If the nearest root is beyond tmax, there is no intersection.\n    if ( root > tmax )\n    {\n        return false;\n    }\n\n    // Return true if the nearest root is within tmin and tmax.\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, inout float t )\n{\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray.", "\n    //////////////////////////////////////////////////////////////////////////\n    // Replace with your code:\n    //////////////////////////////////////////////////////////////////////////\n    vec3 color = vec3(0.0);\n    vec3 hitPos_ = vec3(0.0);\n    vec3 hitNormal_ = vec3(0.0);\n    vec3 k_rg_ = vec3(0.0);\n    hasHit = false;\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here:\n    //////////////////////////////////////////////////////////////////////////\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here:\n    //////////////////////////////////////////////////////////////////////////\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes the color of a point light source at a given point.\n// The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n//\u8ba1\u7b97\u70b9\u5149\u6e90\u7684\u989c\u8272\u3002\n//\u989c\u8272\u662f\u6765\u81ea\u6240\u6709\u5149\u6e90\u7684\u5149\u7684\u603b\u548c\uff0c\u6bcf\u4e2a\u5149\u6e90\u4f7f\u7528Phong\u7167\u660e\u6a21\u578b\u8ba1\u7b97\uff0c\u5e76\u8003\u8651\u662f\u5426\u4ece\u5149\u7ebf\u906e\u853d\u4e86\u622a\u9762\u70b9\u3002\n//\u5982\u679c\u6ca1\u6709interesection\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\uff0c\u5e76\u8f93\u51fahasHit\u4e3afalse\u3002\n//\u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u8ba1\u7b97\u7684\u989c\u8272\uff0c\u5e76\u8f93\u51fahasHit\u4e3atrue\uff0c\u4ea4\u70b9\u76843D\u4f4d\u7f6e\uff08hitPos\uff09\uff0c\n//\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u4ee5\u53ca\u76f8\u4ea4\u5bf9\u8c61\u7684\u6750\u8d28\u7684k_rg\u503c\u3002\n/////////////////////////////////////////////////////////////////////////////\nvec", "\n    vec2 p = p0;\n    vec2 q = p1;\n    vec2 r = p2;\n    vec2 s = (p + q) * 0.5;\n    vec2 t = (q + r) * 0.5;\n    vec2 u = (s + t) * 0.5;\n    vec2 v = (t + r) * 0.5;\n    vec2 w = (u + v) * 0.5;\n    vec2 x = (v + w) * 0.5;\n    vec2 y = (w + u) * 0.5;\n    vec2 z = (u + x) * 0.5;\n    vec2 a = (x + y) * 0.5;\n    vec2 b = (y + z) * 0.5;\n    vec2 c = (z + a) * 0.5;\n    vec2 d = (a + b) * 0.5;\n    vec2 e = (b + c) * 0.5;\n    vec2 f = (c + d) * 0.5;\n    vec2 g = (d + e) * 0.5;\n    vec2 h = (e + f) * 0.5;\n    vec2 i = (f + g) * 0.5;\n    vec2 j = (g + h) * 0.5;\n    vec2 k = (h + i) * 0.5;\n    vec2 l = (i + j) * 0.5;\n    vec2 m = (j + k) * 0.5;\n    vec2 n = (k + l) * 0.5;\n    vec2 o = (l + m) * 0.5;\n    vec2 p1 = (m + n) * 0.5;\n    vec2 q1 = (n + o) * 0.5;\n    vec2 r1 = (o + p) * 0.5;\n    vec2 s1 = (p +", "\n    vec3 bmin = vec3( min( min( p0.x, p1.x ), min( p2.x, p3.x ) ),\n                      min( min( p0.y, p1.y ), min( p2.y, p3.y ) ),\n                      min( min( p0.z, p1.z ), min( p2.z, p3.z ) ) );\n    vec3 bmax = vec3( max( max( p0.x, p1.x ), max( p2.x, p3.x ) ),\n                      max( max( p0.y, p1.y ), max( p2.y, p3.y ) ),\n                      max( max( p0.z, p1.z ), max( p2.z, p3.z ) ) );\n    return bound3( bmin, bmax );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://www.iquilezles.org/www/articles/spheresphere/spheresphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://www.iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    float t1 = dot( ap, ab );\n    float t2 = dot( bp, ab );\n    float t3 = dot( ap, ab );\n    float t4 = dot( bp, ab );\n    float tmin = max( max( t1, t2 ), max( t3, t4 ) );\n    float tmax = min( min( t1, t2", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.05;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s", "\n    return 0.5 * ( 1.0 - cos( k * PI ) );\n}\n\n/**\n * Cubic InOut Easing Curve\n */\nfloat", "\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439,\n        -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 ))\n        + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy),\n        dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x", "\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = p - 0.5;\n    float t = iTime;\n    float r = length(q);\n    float a = atan(q.y, q.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 0.5) * 0.5;\n    float f = (r - 0.5) * 0.5;\n    float g = (r - 0.5) * 0.5;\n    float h = (r - 0.5) * 0.5;\n    float i = (r - 0.5) * 0.5;\n    float j = (r - 0.5) * 0.5;\n    float k = (r - 0.5) * 0.5;\n    float l = (r - 0.5) * 0.5;\n    float m = (r - 0.5) * 0.5;\n    float n = (r - 0.5) * 0.5;\n    float o = (r - 0.5) * 0.5;\n    float p = (r - 0.5) * 0.5;\n    float q = (r - 0.5) * 0.5;\n    float r = (r - 0.5) * 0.5;\n    float s = (r - 0.5) * 0.5;\n    float t = (r - 0.5) * 0.5;\n    float u = (r - 0.5) * 0.5;\n    float v = (r - 0.5) * 0.5;\n    float w = (r - 0.5) * 0.5;\n    float x = (r - 0.5) * 0.5;\n    float y = (r - 0.5) * 0.5;\n    float z = (r - 0.5) * 0.5;\n    float aa =", "\n    return (coord * 2.0) / res - 1.0;\n}\n\n// Calculate the value of the julia set at the given coordinate.\nfloat", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec3 hcv = vec3(0.0);\n    float max = max(rgb.r, max(rgb.g, rgb.b));\n    float min = min(rgb.r, min(rgb.g, rgb.b));\n    float delta = max - min;\n    if (delta == 0.0) {\n        hcv.r = hcv.g = hcv.b = 0.0;\n    } else {\n        if (max == rgb.r) {\n            hcv.r = (rgb.g - rgb.b) / delta;\n        } else if (max == rgb.g) {\n            hcv.r = 2.0 + (rgb.b - rgb.r) / delta;\n        } else {\n            hcv.r = 4.0 + (rgb.r - rgb.g) / delta;\n        }\n        hcv.r *= 60.0;\n        if (hcv.r < 0.0) {\n            hcv.r += 360.0;\n        }\n        hcv.g = delta / max;\n        hcv.b = 0.0;\n    }\n    return hcv;\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec", "\n    return fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\n// 2D noise with perlin noise\nfloat", "\n    vec3 e = vec3( 0.0001, 0.0, 0.0 );\n    return normalize( vec3(\n        p.y - surface( p + e.yxx ).y,\n        p.z - surface( p + e.zzx ).z,\n        p.x - surface( p + e.xyx ).x ) );\n}\n\n// Tetrahedral surface, to save a couple of \"map\" calls. Courtesy of IQ.\nfloat", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// --------------------------------------------------------\n// Simplex 3D Noise - fractal noise with an interesting\n// property\n// --------------------------------------------------------\n\nfloat", "\n    float x = pos.x;\n    float y = pos.y;\n    float r = radius;\n    float w = width;\n    float a = 0.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float rr = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float ww = 0.0;\n    float x1 = 0.0;\n    float y1 = 0.0;\n    float x2 = 0.0;\n    float y2 = 0.0;\n    float x3 = 0.0;\n    float y3 = 0.0;\n    float x4 = 0.0;\n    float y4 = 0.0;\n    float x5 = 0.0;\n    float y5 = 0.0;\n    float x6 = 0.0;\n    float y6 = 0.0;\n    float x7 = 0.0;\n    float y7 = 0.0;\n    float x8 = 0.0;\n    float y8 = 0.0;\n    float x9 = 0.0;\n    float y9 = 0.0;\n    float x10 = 0.0;\n    float y10 = 0.0;\n    float x11 = 0.0;\n    float y11 = 0.0;\n    float x12 = 0.0;\n    float y12 = 0.0;\n    float x13 = 0.0;\n    float y13 = 0.0;\n    float", "\n    return snoise(v.x, v.y);\n}\n\n//SNOISE\nfloat", "\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.xy, 1.0));\n\n    vec3 col = vec3(0.0);\n\n    vec3 lightDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n\n    float intensity = 0.0;\n    float attenuation = 1.0;\n\n    vec3 pos = vec3(0.0, 0.0, 0.0);\n    vec3 normal = vec3(0.0, 0.0, 0.0);\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n\n    float radius = 0.5;\n    float dist = 0.0;\n\n    for(int i = 0; i < 100; i++){\n        pos = vec3(0.0, 0.0, 0.0);\n        dist = 0.0;\n\n        for(int j = 0; j < 10; j++){\n            pos = vec3(0.0, 0.0, 0.0);\n            dist = 0.0;\n\n            for(int k = 0; k < 10; k++){\n                pos = vec3(0.0, 0.0, 0.0);\n                dist = 0.0;\n\n                pos.x = (float(i) / 10.0) - 0.5;\n                pos.y = (float(j) / 10.0) - 0.5;\n                pos.z = (float(k) / 10.0) - 0.5;\n\n                dist = length(pos);\n\n", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = i.x + i.y*157.0 + 113.0*i.z;\n    return mix(mix(mix(dot(C.xyz, f+vec3(0.0,0.0,0.0)),\n                        dot(C.xyz, f+vec3(1.0,0.0,0.0)),\n                        f.x),\n                   mix(dot(C.xyz, f+vec3(0.0,1.0,0.0)),\n                       dot(C.xyz, f+vec3(1.0,1.0,0.0)),\n                       f.x),\n                   f.y),\n               mix(mix(dot(C.xyz, f+vec3(0.0,0.0,1.0)),\n                       dot(C.xyz, f+vec3(1.0,0.0,1.0)),\n                       f.x),\n                   mix(dot(C.xyz, f+vec3(0.0,1.0,1.0)),\n                       dot(C.xyz, f+vec3(1.0,1.0,1.0)),\n                       f.x),\n                   f.y),\n               f.z);\n}\n\n// Thanks Shane.\nfloat", "\n    sp = p;\n    tp = p;\n    rp = p;\n    mul = 1.0;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n    tp.y *= TILE_SIZE;\n    rp.xz *= TILE_SIZE;\n    rp.y *= TILE_SIZE;\n\n    // Tile the point\n    sp.xz *= TILE_SIZE;\n    sp.y *= TILE_SIZE;\n    tp.xz *= TILE_SIZE;\n", "\n    vec2 d = vec2(0.0);\n    d.x = length(p.xy) - 0.5;\n    d.y = p.z + 0.5;\n    return d;\n}\n\n//the second scalar represents the object type, the first the actual distance\nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\n// Complex functions\nvec", "\n    float aa = aaSize / 2.0;\n    float aa2 = aa * aa;\n    float aa3 = aa2 * aa;\n    float aa4 = aa3 * aa;\n    float aa5 = aa4 * aa;\n    float aa6 = aa5 * aa;\n    float aa7 = aa6 * aa;\n    float aa8 = aa7 * aa;\n    float aa9 = aa8 * aa;\n    float aa10 = aa9 * aa;\n    float aa11 = aa10 * aa;\n    float aa12 = aa11 * aa;\n    float aa13 = aa12 * aa;\n    float aa14 = aa13 * aa;\n    float aa15 = aa14 * aa;\n    float aa16 = aa15 * aa;\n    float aa17 = aa16 * aa;\n    float aa18 = aa17 * aa;\n    float aa19 = aa18 * aa;\n    float aa20 = aa19 * aa;\n    float aa21 = aa20 * aa;\n    float aa22 = aa21 * aa;\n    float aa23 = aa22 * aa;\n    float aa24 = aa23 * aa;\n    float aa25 = aa24 * aa;\n    float aa26 = aa25 * aa;\n    float aa27 = aa26 * aa;\n    float aa28 = aa27 * aa;\n    float aa29 = aa28 * aa;\n    float aa30 = aa29 * aa;\n    float aa31 = aa30 * aa;\n    float aa32 = aa31 * aa;\n    float aa33 = aa32 * aa;\n    float", "\n    vec2 d = vec2(0.0);\n    vec3 q = pos - vec3(0.0, 0.0, 0.0);\n    d.x = length(q) - 0.01;\n    d.y = boxID(q);\n    return d;\n}\n\n// returns the distance to our rotating box and the associated material ID\nvec", "\n    vec2 d = vec2(0.0);\n    vec3 spherePos = vec3(0.0, 0.0, 0.0);\n    float sphereRadius = 1.0;\n    float sphereDist = distance(pos, spherePos);\n    if (sphereDist < sphereRadius) {\n        d.x = sphereDist - sphereRadius;\n        d.y = sphereRadius;\n    }\n    return d;\n}\n\n// returns the distance to our moving sphere and the its associated material ID packed into a vec2\nvec", "\n    vec2 res = vec2(1000.0);\n    // add your scene here\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 0.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 1.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 2.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 3.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 4.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 5.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 6.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 7.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 8.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 9.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 10.0;\n    // res.x = distance(pos, vec3(0.0, 0.0, 0.0));\n    // res.y = 11.0;\n    // res.", "\n    vec4 color = vec4(0.0);\n    vec3 rayDir = normalize(camDir + lightDir);\n    vec3 rayPos = camPos;\n    float t = 0.0;\n    float tMax = 1000.0;\n    for (int i = 0; i < 100; i++) {\n        if (t > tMax) break;\n        t += rayMarch(rayPos, rayDir);\n        if (t > tMax) break;\n        vec3 hitPos = rayPos + rayDir * t;\n        vec3 hitNormal = getNormal(hitPos);\n        vec3 lightColor = vec3(0.0);\n        if (dot(hitNormal, lightDir) > 0.0) {\n            lightColor = vec3(1.0);\n        }\n        color += vec4(lightColor, 1.0);\n    }\n    return color;\n}\n\nvoid main() {\n    vec2 fragCoord = gl_FragCoord.xy;\n    vec3 camPos = vec3(0.0, 0.0, 10.0);\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec4 color = marchScene(fragCoord, camPos, camDir, lightDir);\n    gl_FragColor = color;\n}\n", "\n    vec2 res = vec2(0.);\n    vec3 q = abs(rd) - rad;\n    vec3 m = max(q, vec3(0.0));\n    res.x = min(max(m.x, m.y), m.z);\n    res.y = length(max(m, 0.0));\n    return res;\n}\n\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.05;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n\n    vec2 q = vec2(a, b);\n    vec2 r = vec2(a, b);\n\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(q, q) > 4.0) break;\n        s = q;\n        q = q * q + r * r;\n        t = s;\n    }\n\n    vec3 color = vec3(0.0);\n    if (dot(q, q) > 4.0) {\n        color = vec3(1.0, 0.0, 0.0);\n    } else {\n        color = vec3(0.0, 0.0, 1.0);\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n", "\n    return dot(plane.normal, pos - plane.position);\n}\n\n// @brief Get signed-distance funciton weight value of sphere.\nfloat", "\n    vec3 p = fract(fx);\n    p = p*p*(3.0-2.0*p);\n    ix = ix + ivec3(gl_GlobalInvocationID.xyz);\n    float res = 0.0;\n    for(int j=-1; j<=1; j++){\n        for(int k=-1; k<=1; k++){\n            for(int l=-1; l<=1; l++){\n                ivec3 c = ix + ivec3(j,k,l);\n                vec4 v = texelFetch(noise, c, 0);\n                res += v.x*p.x;\n                res += v.y*p.y;\n                res += v.z*p.z;\n                res += v.w*(1.0-p.x)*(1.0-p.y)*(1.0-p.z);\n            }\n        }\n    }\n    return res;\n}\n\n// High Precision 3D Gradient Noise\n// ix: integer coordinate, fx: float offset to the integer coordinate\nfloat", "\n    float fractal = 0.0;\n    for(int i = 0; i < 10; i++){\n        fractal += fractal_brownian(fxyz, ixyz, i);\n    }\n    return fractal;\n}\n\n// Fractal Brownian Motion \nfloat", "\n    vec2 d = vec2( length(p.xz) - r, p.y );\n    return length(max(d,0.0)) - h;\n}\n\nfloat", "\n    //The distance of the point from the center of the sphere\n    float d = length(p) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d2 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d3 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d4 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d5 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d6 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d7 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d8 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d9 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d10 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n    //The distance of the point from the center of the sphere\n    float d11 = length(p - vec3(0.0, 0.0, 0.0)) - 0.5;\n", "\n    vec3 normal = vec3(0.0);\n    float d = get_distance(p);\n    normal.x = d - get_distance(p + vec3(1.0, 0.0, 0.0));\n    normal.y = d - get_distance(p + vec3(0.0, 1.0, 0.0));\n    normal.z = d - get_distance(p + vec3(0.0, 0.0, 1.0));\n    return normalize(normal);\n}\n\n// Compute the color at a position p on the surface of our objects\nvec", "\n    return max(dot(n,l),0.0);\n}\n\n// Lighting part, still confusing\nfloat", "\n    vec3 p = ro + rd*ra;\n    return dot(p,p) - ra*ra;\n}\n\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat", "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(q,q) * dot(q,q);\n    float h = f * (f + f - 16.0 * dot(f,f) + 10.0 * dot(f,f) * dot(f,f));\n    return 0.25 * (h * (h + h + 1.0) + g * (g + g + 1.0) * (g + g + 1.0));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n\tglClearColor(0.0f, 0.0f, 0.0f, 0.0f);\n\tglClearDepth(1.0f);\n\tglEnable(GL_DEPTH_TEST);\n\tglDepthFunc(GL_LEQUAL);\n\tglShadeModel(GL_SMOOTH);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Draws the scene.\n/////////////////////////////////////////////////////////////////////////////\nvoid DrawScene()\n{\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\tglLoadIdentity();\n\n\tgluLookAt(0.0f, 0.0f, 10.0f, 0.0f, 0.0f, 0.0f, 0.0f, 1.0f, 0.0f);\n\n\tglColor3f(1.0f, 1.0f, 1.0f);\n\tglBegin(GL_QUADS);\n\tglVertex3f(-1.0f, -1.0f, 0.0f);\n\tglVertex3f(1.0f, -1.0f, 0.0f);\n\tglVertex3f(1.0f, 1.0f, 0.0f);\n\tglVertex3f(-1.0f, 1.0f, 0.0f);\n\tglEnd();\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Main function.\n/////////////////////////////////////////////////////////////////////////////\nint", "\n    ///////////////////////////////////////////////////////////////////////////\n    // TODO: Implement this function.\n    ///////////////////////////////////////////////////////////////////////////\n    //\n    // Hint:\n    //\n    //   - You can use the dot product to compute the distance between a\n    //     point and a line.\n    //\n    //   - You can use the cross product to compute the normal vector of a\n    //     plane.\n    //\n    //   - You can use the length of a vector to compute the distance between\n    //     two points.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n    //     a point and a plane.\n    //\n    //   - You can use the equation of a sphere to compute the distance between\n    //     a point and a sphere.\n    //\n    //   - You can use the equation of a ray to compute the distance between\n    //     a point and a ray.\n    //\n    //   - You can use the equation of a line to compute the distance between\n    //     a point and a line.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n    //     a point and a plane.\n    //\n    //   - You can use the equation of a sphere to compute the distance between\n    //     a point and a sphere.\n    //\n    //   - You can use the equation of a ray to compute the distance between\n    //     a point and a ray.\n    //\n    //   - You can use the equation of a line to compute the distance between\n    //     a point and a line.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n    //     a point and a plane.\n    //\n    //   - You can use the equation of a sphere to compute the distance between\n    //     a point and a sphere.\n    //\n    //   - You can use the equation of a ray to compute the distance between\n    //     a point and a ray.\n    //\n    //   - You can use the equation of a line to compute the distance between\n    //     a point and a line.\n    //\n    //   - You can use the equation of a plane to compute the distance between\n   ", "\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray.origin - sph.center ) - sph.radius * sph.radius;\n\n    // Compute the discriminant.\n    float discriminant = b * b - c;\n\n    // If the discriminant is negative, there is no intersection.\n    if ( discriminant < 0.0f )\n    {\n        return false;\n    }\n\n    // Compute the square root of the discriminant.\n    float sqrt_discriminant = sqrt( discriminant );\n\n    // Compute the nearest root that lies in the acceptable range.\n    float root = (-b - sqrt_discriminant) / 2.0f;\n    if ( root < tmin )\n    {\n        root = (-b + sqrt_discriminant) / 2.0f;\n        if ( root < tmin )\n        {\n            return false;\n        }\n    }\n\n    // If the nearest root is beyond tmax, there is no intersection.\n    if ( root > tmax )\n    {\n        return false;\n    }\n\n    // Return true if the nearest root is within tmin and tmax.\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, inout float t )\n{\n    // Compute the distance between the ray origin and the sphere center.\n    float b = dot( ray.origin - sph.center, ray.direction );\n\n    // Compute the squared distance between the ray origin and the sphere center.\n    float c = dot( ray.origin - sph.center, ray.", "\n    vec3 color = vec3(0.0);\n    hasHit = false;\n    hitPos = vec3(0.0);\n    hitNormal = vec3(0.0);\n    k_rg = vec3(0.0);\n\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here\n    //////////////////////////////////////////////////////////////////////////\n\n    //////////////////////////////////////////////////////////////////////////\n    // Add your code here\n    //////////////////////////////////////////////////////////////////////////\n\n    return color;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Casts a ray into the scene and returns color computed at the nearest\n// intersection point. The color is the sum of light from all light sources,\n// each computed using Phong Lighting Model, with consideration of\n// whether the interesection point is being shadowed from the light.\n// If there is no interesection, returns the background color, and outputs\n// hasHit as false.\n// If there is intersection, returns the computed color, and outputs\n// hasHit as true, the 3D position of the intersection (hitPos), the\n// normal vector at the intersection (hitNormal), and the k_rg value\n// of the material of the intersected object.\n/////////////////////////////////////////////////////////////////////////////\nvec", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 64.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\n// from http://www.neilmendoza.com/glsl-rotation-about-an-arbitrary-axis/\nmat", "\n\tvec3 color = vec3(0.0);\n\tvec3 ray_dir = normalize(dir);\n\tvec3 ray_start = start;\n\tvec3 ray_end = start + ray_dir * max_dist;\n\tvec3 ray_color = vec3(0.0);\n\tvec3 light_color = vec3(0.0);\n\tvec3 light_start = planet_position;\n\tvec3 light_end = planet_position + light_dir * max_dist;\n\tvec3 light_ray_dir = normalize(light_end - light_start);\n\tvec3 light_ray_start = light_start;\n\tvec3 light_ray_end = light_start + light_ray_dir * max_dist;\n\tvec3 light_ray_color = vec3(0.0);\n\tvec3 light_ray_dir_2 = normalize(light_end - light_start);\n\tvec3 light_ray_start_2 = light_start;\n\tvec3 light_ray_end_2 = light_start + light_ray_dir_2 * max_dist;\n\tvec3 light_ray_color_2 = vec3(0.0);\n\tvec3 light_ray_dir_3 = normalize(light_end - light_start);\n\tvec3 light_ray_start_3 = light_start;\n\tvec3 light_ray_end_3 = light_start + light_ray_dir_3 * max_dist;\n\tvec3 light_ray_color_3 = vec3(0.0);\n\tvec3 light_ray_dir_4 = normalize(light_end - light_start);\n\tvec3 light_ray_start_4 = light_start;\n\tvec3 light_ray_end_4 = light_start + light_ray_dir_4 * max_dist;\n\tvec3 light_ray_color_4 = vec3(0.0);\n\tvec3 light_ray_dir_5 = normalize(light_end - light_start);\n\tvec3 light_ray_start_5 = light_start;\n\tvec3 light_ray_end_5 = light_start +", "\n    vec3 sky_col = vec3(0.0);\n    vec3 light_dir_norm = normalize(light_dir);\n    vec3 view_dir_norm = normalize(sample_pos - light_dir_norm);\n    float cos_theta = dot(light_dir_norm, view_dir_norm);\n    float cos_theta_sq = cos_theta * cos_theta;\n    float cos_theta_sq_inv = 1.0 - cos_theta_sq;\n    float cos_theta_sq_inv_sq = cos_theta_sq_inv * cos_theta_sq_inv;\n    float cos_theta_sq_inv_sq_inv = cos_theta_sq_inv_sq * cos_theta_sq_inv_sq;\n    float cos_theta_sq_inv_sq_inv_inv = cos_theta_sq_inv_sq_inv * cos_theta_sq_inv_sq_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv * cos_theta_sq_inv_sq_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_inv_inv;\n    float cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv_inv = cos_theta_sq_inv_sq_inv_inv_inv_inv_inv_inv * cos_theta_sq_inv_sq_inv_inv_inv_", "\n    vec4 color = vec4(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_attenuation = vec3(1.0);\n    vec3 light_ambient = vec3(0.0);\n    vec3 light_diffuse = vec3(0.0);\n    vec3 light_specular = vec3(0.0);\n    vec3 light_spot_dir = vec3(0.0);\n    vec3 light_spot_color = vec3(0.0);\n    vec3 light_spot_attenuation = vec3(0.0);\n    vec3 light_spot_ambient = vec3(0.0);\n    vec3 light_spot_diffuse = vec3(0.0);\n    vec3 light_spot_specular = vec3(0.0);\n    vec3 light_spot_spot_dir = vec3(0.0);\n    vec3 light_spot_spot_color = vec3(0.0);\n    vec3 light_spot_spot_attenuation = vec3(0.0);\n    vec3 light_spot_spot_ambient = vec3(0.0);\n    vec3 light_spot_spot_diffuse = vec3(0.0);\n    vec3 light_spot_spot_specular = vec3(0.0);\n    vec3 light_spot_spot_spot_dir = vec3(0.0);\n    vec3 light_spot_spot_spot_color = vec3(0.0);\n    vec3 light_spot_spot_spot_attenuation = vec3(0.0);\n    vec3 light_spot_spot_spot_ambient = vec3(0.0);\n    vec3 light_spot_spot_spot_diffuse = vec3(0.0);\n    vec3 light_spot_spot_", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 camPos = vec3(0.0, 0.0, 1.0);\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n\n    //get the ray direction\n    vec3 rayDir = normalize(camDir + lightDir);\n\n    //get the ray origin\n    vec3 rayOrigin = camPos;\n\n    //get the ray color\n    vec3 rayColor = vec3(0.0, 0.0, 0.0);\n\n    //get the ray length\n    float rayLength = 1.0;\n\n    //get the ray step\n    float rayStep = 0.001;\n\n    //get the ray step\n    float rayStep2 = 0.001;\n\n    //get the ray step\n    float rayStep3 = 0.001;\n\n    //get the ray step\n    float rayStep4 = 0.001;\n\n    //get the ray step\n    float rayStep5 = 0.001;\n\n    //get the ray step\n    float rayStep6 = 0.001;\n\n    //get the ray step\n    float rayStep7 = 0.001;\n\n    //get the ray step\n    float rayStep8 = 0.001;\n\n    //get the ray step\n    float rayStep9 = 0.001;\n\n    //get the ray step\n    float rayStep10 = 0.001;\n\n    //get the ray step\n    float rayStep11 = 0.001;\n\n    //get the ray step\n    float rayStep12 = 0.001;\n\n    //get the ray step\n    float rayStep13 = 0.001;\n\n    //get the ray step\n    float rayStep14 = 0.001;\n\n    //get the ray step\n    float rayStep15 = 0.00", "\n    vec3 oc = r0 - s0;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sr * sr;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\n//-----------------------------------------------------------------------\n// raySphereIntersect\n//-----------------------------------------------------------------------\nfloat", "\n\tvec4 finalColor = vec4(0.0);\n\tvec3 rayDir = normalize(cameraRayDir);\n\tvec3 rayPos = cameraPos;\n\tvec3 rayPosInc = rayDir;\n\tvec3 rayPosInc2 = rayDir;\n\tvec3 rayPosInc3 = rayDir;\n\tvec3 rayPosInc4 = rayDir;\n\tvec3 rayPosInc5 = rayDir;\n\tvec3 rayPosInc6 = rayDir;\n\tvec3 rayPosInc7 = rayDir;\n\tvec3 rayPosInc8 = rayDir;\n\tvec3 rayPosInc9 = rayDir;\n\tvec3 rayPosInc10 = rayDir;\n\tvec3 rayPosInc11 = rayDir;\n\tvec3 rayPosInc12 = rayDir;\n\tvec3 rayPosInc13 = rayDir;\n\tvec3 rayPosInc14 = rayDir;\n\tvec3 rayPosInc15 = rayDir;\n\tvec3 rayPosInc16 = rayDir;\n\tvec3 rayPosInc17 = rayDir;\n\tvec3 rayPosInc18 = rayDir;\n\tvec3 rayPosInc19 = rayDir;\n\tvec3 rayPosInc20 = rayDir;\n\tvec3 rayPosInc21 = rayDir;\n\tvec3 rayPosInc22 = rayDir;\n\tvec3 rayPosInc23 = rayDir;\n\tvec3 rayPosInc24 = rayDir;\n\tvec3 rayPosInc25 = rayDir;\n\tvec3 rayPosInc26 = rayDir;\n\tvec3 rayPosInc27 = rayDir;\n\tvec3 rayPosInc28 = rayDir;\n\tvec3 rayPosInc29 = rayDir;\n\tvec3 rayPosInc30 = rayDir;\n\tvec3 rayPosInc31 = rayDir;\n\tvec3 rayPosInc32 = rayDir;\n\tvec3 rayPosInc33 = rayDir;\n\tvec3 rayPosInc34 = rayDir;\n\tvec3 ray", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float t = iTime;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float s = sin(a + t);\n    float c = cos(a + t);\n    float d = (r - 0.5) * 0.5;\n    float dd = d * d;\n    float ddd = dd * d;\n    float dddd = ddd * d;\n    float ddddd = dddd * d;\n    float dddddd = ddddd * d;\n    float ddddddd = dddddd * d;\n    float dddddddd = ddddddd * d;\n    float ddddddddd = dddddddd * d;\n    float dddddddddd = ddddddddd * d;\n    float ddddddddddd = dddddddddd * d;\n    float dddddddddddd = ddddddddddd * d;\n    float ddddddddddddd = dddddddddddd * d;\n    float dddddddddddddd = ddddddddddddd * d;\n    float ddddddddddddddd = dddddddddddddd * d;\n    float dddddddddddddddd = ddddddddddddddd * d;\n    float ddddddddddddddddd = dddddddddddddddd * d;\n    float dddddddddddddddddd = ddddddddddddddddd * d;\n    float ddddddddddddddddddd = dddddddddddddddddd * d;\n    float dddddddddddddddddddd = ddddddddddddddddddd * d;\n   ", "\n    vec3 color = vec3(0.0);\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    vec3 ray_position = ray_origin;\n    for (int i = 0; i < MAX_PATHS; i++) {\n        vec3 hit_position = ray_position;\n        vec3 hit_normal = vec3(0.0);\n        vec3 hit_color = vec3(0.0);\n        vec3 hit_reflection = vec3(0.0);\n        vec3 hit_refraction = vec3(0.0);\n        vec3 hit_refraction_color = vec3(0.0);\n        vec3 hit_reflection_color = vec3(0.0);\n        vec3 hit_refraction_normal = vec3(0.0);\n        vec3 hit_reflection_normal = vec3(0.0);\n        vec3 hit_refraction_position = vec3(0.0);\n        vec3 hit_reflection_position = vec3(0.0);\n        vec3 hit_reflection_direction = vec3(0.0);\n        vec3 hit_refraction_direction = vec3(0.0);\n        vec3 hit_refraction_normal_direction = vec3(0.0);\n        vec3 hit_reflection_normal_direction = vec3(0.0);\n        vec3 hit_refraction_normal_position = vec3(0.0);\n        vec3 hit_reflection_normal_position = vec3(0.0);\n        vec3 hit_reflection_direction_position = vec3(0.0);\n        vec3 hit_refraction_direction_position = vec3(0.0);\n        vec3 hit_reflection_direction_normal = vec3(0.0);\n        vec3 hit_refraction_direction_normal = vec3(0.0);\n        vec3 hit_reflection_direction_normal_position = vec3(0.0);\n", "\n    vec3 c = vec3(0.0);\n    vec2 q = p;\n    float d = 0.0;\n    float t = 0.0;\n    float a = 0.0;\n    float b = 0.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b2 = 0.0;\n    float a2 = 0.0;\n    float r2 = 0.0;\n    float g2 = 0.0;\n    float b3 = 0.0;\n    float a3 = 0.0;\n    float r3 = 0.0;\n    float g3 = 0.0;\n    float b4 = 0.0;\n    float a4 = 0.0;\n    float r4 = 0.0;\n    float g4 = 0.0;\n    float b5 = 0.0;\n    float a5 = 0.0;\n    float r5 = 0.0;\n    float g5 = 0.0;\n    float b6 = 0.0;\n    float a6 = 0.0;\n    float r6 = 0.0;\n    float g6 = 0.0;\n    float b7 = 0.0;\n    float a7 = 0.0;\n    float r7 = 0.0;\n    float g7 = 0.0;\n    float b8 = 0.0;\n    float a8 = 0.0;\n    float r8 = 0.0;\n    float g8 = 0.0;\n    float b9 = 0.0;\n    float a9 = 0.0;\n    float r9 = 0.0;\n    float g9 = 0.0;\n    float b10 = 0.0;\n    float a10 = 0.0;\n    float r10 = 0.0;\n    float g10 = 0.0;\n    float b11 = 0.0;\n    float a11 = 0.0;\n    float r11 = 0.0;\n    float g11 = 0.0;\n    float b12 = 0.0;\n    float a12 = 0.0;\n    float r", "\n    return length(p) - 1.0;\n}\n\n// Get the normal of the sphere\nvec", "\n    vec3 Pi0 = floor( P );\n    vec3 Pi1 = Pi0 + vec3( 1.0 );\n    vec3 Pf0 = fract( P );\n    vec3 Pf1 = Pf0 - vec3( 1.0 );\n\n    vec4 x0 = vec4( Pf0.x, Pf1.x, Pi0.x, Pi1.x );\n    vec4 x1 = vec4( Pf0.y, Pf1.y, Pi0.y, Pi1.y );\n    vec4 x2 = vec4( Pf0.z, Pf1.z, Pi0.z, Pi1.z );\n\n    vec4 w0 = vec4( dot( x0, vec4( 1.0 ) ), dot( x1, vec4( 1.0 ) ),\n                    dot( x2, vec4( 1.0 ) ), 1.0 );\n\n    return dot( w0, vec4( 1.0 ) );\n}\n\n// from: https://github.com/BrianSharpe/Wombat/blob/master/Perlin3D.glsl\nfloat", "\n    return fract(sin(x)*43758.5453);\n}\n\n// 2D Perlin noise\nfloat", "\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.z, p.z);\n    return r;\n}\n\n// Scene setup\nvec", "\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.z, p.z);\n    return r;\n}\n\n// Scene setup\nvec", "\n    vec2 pa = p - a;\n    vec2 ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - d;\n}\n\n// segment with disc ends: seamless distance to segment\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.02;\n    float t = mod(a, 2.0 * 3.14159265359);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n\n    float f = fract(r);\n    float f2 = fract(r * 0.5);\n    float f3 = fract(r * 0.25);\n    float f4 = fract(r * 0.125);\n    float f5 = fract(r * 0.0625);\n    float f6 = fract(r * 0.03125);\n    float f7 = fract(r * 0.015625);\n    float f8 = fract(r * 0.0078125);\n    float f9 = fract(r * 0.00390625);\n    float f10 = fract(r * 0.001953125);\n    float f11 = fract(r * 0.0009765625);\n    float f12 = fract(r * 0.00048828125);\n    float f13 = fract(r * 0.000244140625);\n    float f14 = fract(r * 0.0001220703125);\n    float f15 = fract(r * 0.00006103515625);\n    float f16 = fract(", "\n    return abs(p.x) + abs(p.y);\n}\n\n// Circular bound: Not technically a distance function, but it's\n// good enough for this example.\nfloat", "\n    float n = noise(ix, iy);\n    return n;\n}\n\n// yea i basically spammed random stuff\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 pos = p;\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 100; i++ )\n    {\n        float d = length( pos );\n        if ( d > 1.0 )\n        {\n            break;\n        }\n        t += d;\n        pos = p + vec3( 0.0, 0.0, t );\n    }\n    color = vec3( 0.5 + 0.5 * sin( 10.0 * t ) );\n    return color;\n}\n\n// Return the color of the pixel\nvec", "\n    return sin(p * 10.0) * 0.5 + 0.5;\n}\n\n// Fifth scene (many elements)\nfloat", "\n    return vec2(atan(z.y, z.x), length(z));\n}\n\n// coordinate change \nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\n// returns the magnitude of a complex number\nfloat", "\n    vec3 f = fract(p);\n    vec3 u = f * f * (3.0 - 2.0 * f);\n    return mix(mix(mix(dot(f, vec3(1.0, 57.0, 113.0)), dot(f, vec3(57.0, 113.0, 17.0)), u.y),\n                   mix(dot(f, vec3(113.0, 57.0, 17.0)), dot(f, vec3(17.0, 113.0, 57.0)), u.y), u.z),\n               mix(mix(dot(f, vec3(57.0, 17.0, 113.0)), dot(f, vec3(17.0, 57.0, 113.0)), u.x),\n                   mix(dot(f, vec3(113.0, 17.0, 57.0)), dot(f, vec3(57.0, 113.0, 17.0)), u.x), u.z),\n               u.x);\n}\n\n/* 3d simplex noise */\nfloat", "\n\tfloat t = time * 0.025;\n\tfloat d = distance( p, vec3( 0.0 ) );\n\tfloat r = ( 1.0 - d ) * 0.0001;\n\tfloat a = cos( t * 0.05 ) * 0.0001;\n\tfloat b = cos( t * 0.02 ) * 0.0001;\n\tfloat c = cos( t * 0.01 ) * 0.0001;\n\tfloat d1 = cos( t * 0.005 ) * 0.0001;\n\tfloat d2 = cos( t * 0.002 ) * 0.0001;\n\tfloat d3 = cos( t * 0.001 ) * 0.0001;\n\tfloat d4 = cos( t * 0.0005 ) * 0.0001;\n\tfloat d5 = cos( t * 0.0002 ) * 0.0001;\n\tfloat d6 = cos( t * 0.0001 ) * 0.0001;\n\tfloat d7 = cos( t * 0.00005 ) * 0.0001;\n\tfloat d8 = cos( t * 0.00002 ) * 0.0001;\n\tfloat d9 = cos( t * 0.00001 ) * 0.0001;\n\tfloat d10 = cos( t * 0.000005 ) * 0.0001;\n\tfloat d11 = cos( t * 0.000002 ) * 0.0001;\n\tfloat d12 = cos( t * 0.000001 ) * 0.0001;\n\tfloat d13 = cos( t * 0.0000005 ) * 0.0001;\n\tfloat d14 = cos( t * 0.0000002", "\n    float d = sdf( p );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, -0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0, 0.0, 0.0001 ) ) );\n    d = max( d, sdf( p + vec3( 0.0", "\n    float s = 0.0;\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec3(0.0, 0.0, 0.0), 0.01);\n    s += sdSphere(rp, vec", "\n    return clamp((d - start) / (end - start), 0.0, 1.0);\n}\n\n// ref: https://qiita.com/aa_debdeb/items/b78975c5bcb063e28a08\nfloat", "\n    vec4 hex = vec4(p, 0.0, 1.0);\n    hex.xy = mod(hex.xy, 2.0);\n    hex.zw = floor(hex.xy);\n    return hex;\n}\n\n// This function returns the hexagonal grid coordinate for the grid cell, and the corresponding \n// hexagon cell ID -- in the form of the central hexagonal point. That's basically all you need to \n// produce a hexagonal grid.\n//\n// When working with 2D, I guess it's not that important to streamline this particular function.\n// However, if you need to raymarch a hexagonal grid, the number of operations tend to matter.\n// This one has minimal setup, one \"floor\" call, a couple of \"dot\" calls, a ternary operator, etc.\n// To use it to raymarch, you'd have to double up on everything -- in order to deal with \n// overlapping fields from neighboring cells, so the fewer operations the better.\nvec", "\n    vec2 q = p - vec2(0.5);\n    vec2 r = vec2(length(q), atan(q.y, q.x));\n    return r;\n}\n\n// The distance field for the truchet.\nvec", "\n\n\t// Compute the pixel color\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 q = p - 0.5;\n\tfloat t = length(q);\n\tfloat a = atan(q.y, q.x) / 3.1415926535897932384626433832795;\n\tfloat r = mod(a, 1.0);\n\tfloat g = mod(a, 2.0);\n\tfloat b = mod(a, 3.0);\n\tfragColor = vec4(r, g, b, 1.0);\n}\n\n// FUNCTION: mainImage\n//\n// Function is automatically executed. Here it assigns a color to every pixel.\nvoid mainImage(\n    \t\t\tout vec4 fragColor, // Output (r, g, b, a) pixel color \n\t\t\t\tin vec2 fragCoord   // Input (x, y) image coordinate\n\t\t\t  ) {\n\n\t// Compute the pixel color\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 q = p - 0.5;\n\tfloat t = length(q);\n\tfloat a = atan(q.y, q.x) / 3.1415926535897932384626433832795;\n\tfloat r = mod(a, 1.0);\n\tfloat g = mod(a, 2.0);\n\tfloat b = mod(a, 3.0);\n\tfragColor = vec4(r, g, b, 1.0);\n}\n\n// FUNCTION: mainImage\n//\n// Function is automatically executed. Here it assigns a color to every pixel.\nvoid mainImage(\n    \t\t\tout vec4 fragColor, // Output (r, g, b, a) pixel color \n\t\t\t\tin vec2 fragCoord   // Input (x, y) image coordinate\n\t\t\t  ) {\n\n\t// Compute the pixel color\n\tvec2 p = fragCoord.", "\n    float theta = atan(pc.y, pc.x);\n    float r = sqrt(pc.x*pc.x + pc.y*pc.y);\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r3*r;\n    float r5 = r4*r;\n    float r6 = r5*r;\n    float r7 = r6*r;\n    float r8 = r7*r;\n    float r9 = r8*r;\n    float r10 = r9*r;\n    float r11 = r10*r;\n    float r12 = r11*r;\n    float r13 = r12*r;\n    float r14 = r13*r;\n    float r15 = r14*r;\n    float r16 = r15*r;\n    float r17 = r16*r;\n    float r18 = r17*r;\n    float r19 = r18*r;\n    float r20 = r19*r;\n    float r21 = r20*r;\n    float r22 = r21*r;\n    float r23 = r22*r;\n    float r24 = r23*r;\n    float r25 = r24*r;\n    float r26 = r25*r;\n    float r27 = r26*r;\n    float r28 = r27*r;\n    float r29 = r28*r;\n    float r30 = r29*r;\n    float r31 = r30*r;\n    float r32 = r31*r;\n    float r33 = r32*r;\n    float r34 = r33*r;\n    float r35 = r34*r;\n    float r36 = r35*r;\n    float r37 = r36*r;\n    float r38 = r37*r;\n    float r39 = r", "\n    return smoothstep(pct, pct+0.01, st.y);\n}\n\n// Plot a line on X using a value between 0.0-1.0\nfloat", "\n    vec3 domain;\n    float angle = 2.0 * PI / float(N);\n    float radius = R * sqrt(1.0 - cos(angle));\n    domain.x = radius * cos(angle);\n    domain.y = radius * sin(angle);\n    domain.z = 0.0;\n    return domain;\n}\n\n// Calculating the initial circular domain according to number of polygon\n// sides (N) and the number of adjacent polygons (Q): STB was clever enough to  \n// use repeat polar space to position the rest. Anyway, the idea is to use the\n// polygon geometry to set up the required geometrical diagram (see the line \n// below), then use a mixture of standard Euclidean and hyperbolic geometry (if\n// needed) to calculate the required values, which are described below.\n// \nvec", "\n    vec2 q = vec2(p.x, p.y);\n    vec2 r = vec2(p.x - circ.x, p.y - circ.y);\n    return vec2(\n        circ.x + r.x * circ.w + r.y * circ.z,\n        circ.y + r.x * circ.z - r.y * circ.w\n    );\n}\n\n// Returns the distance from a point to a circle.\nfloat", "\n    return vec2(p.x, 1.0 - p.y);\n}\n\n// Mouse pointer inversion.\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 view = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 ambient = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    vec3 shadow = vec3(0.0);\n    vec3 fog = vec3(0.0);\n    vec3 fogColor = vec3(0.0);\n    vec3 fogStart = vec3(0.0);\n    vec3 fogEnd = vec3(0.0);\n    vec3 fogDensity = vec3(0.0);\n    vec3 fogColor2 = vec3(0.0);\n    vec3 fogDensity2 = vec3(0.0);\n    vec3 fogColor3 = vec3(0.0);\n    vec3 fogDensity3 = vec3(0.0);\n    vec3 fogColor4 = vec3(0.0);\n    vec3 fogDensity4 = vec3(0.0);\n    vec3 fogColor5 = vec3(0.0);\n    vec3 fogDensity5 = vec3(0.0);\n    vec3 fogColor6 = vec3(0.0);\n    vec3 fogDensity6 = vec3(0.0);\n    vec3 fogColor7 = vec3(0.0);\n    vec3 fogDensity7 = vec3(0.0);\n    vec3 fogColor8 = vec3(0.0);\n    vec3 fogDensity8 = vec3(0.0);\n    vec3 fogColor9 = vec3(0.0);\n    vec3 fogDensity9 = vec3(0.", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    if (d < 1.0) {\n        float t = (1.0 - d) * 10.0;\n        col = vec3(1.0 - t, t, 0.0);\n    }\n\n    fragColor = vec4(col, 1.0);\n}\n", " // Input (r, g, b, a) pixel color \n\n    // Get the coordinates of the pixel in the polar coordinate system.\n    vec2 polarCoord = polarCoord(fragCoord);\n\n    // Get the colour of the pixel in the polar coordinate system.\n    vec3 polarColour = polarColour(polarCoord);\n\n    // Get the colour of the pixel in the HSB colour space.\n    vec3 hsbColour = hsbColour(polarColour);\n\n    // Get the colour of the pixel in the RGB colour space.\n    vec3 rgbColour = rgbColour(hsbColour);\n\n    // Output the colour of the pixel.\n    fragColor = vec4(rgbColour, 1.0);\n}\n\n// Polar coordinate system.\n// https://thebookofshaders.com/06/\nvec", "\n    return normalize(vec3(\n        hash * 2.0 - 1.0,\n        hash * 4.0 - 2.0,\n        hash * 8.0 - 4.0\n    ));\n}\n\n// Hash function\nfloat", "\n    vec2 XY = bccNoise_Plane(X);\n    return vec2(XY.x, XY.y + X.z);\n}\n\n// Gives X and Y a triangular alignment, and lets Z move up the main diagonal.\n// Should be better for terrain or a time varying X/Y plane. Z repeats.\nvec", "\n  float d = length(p.xz) - 1.0;\n  d = max(d, abs(p.y) - 0.9);\n  return d;\n}\n\n/* scene definition\n  mainly defining a plane deformed to be a wave */\nfloat", "\n    vec3 rayDir = ray.direction;\n    vec3 rayOrigin = ray.origin;\n    vec3 rayPos = rayOrigin + rayDir * ray.t;\n    vec3 rayDirNorm = normalize( rayDir );\n    vec3 rayPosNorm = normalize( rayPos );\n    vec3 rayPosToTarget = targetPos - rayPos;\n    float rayPosToTargetDot = dot( rayPosToTarget, rayDirNorm );\n    float rayPosToTargetDotSq = rayPosToTargetDot * rayPosToTargetDot;\n    float rayPosToTargetDotCos = dot( rayPosToTarget, rayPosNorm );\n    float rayPosToTargetDotSqCos = rayPosToTargetDotCos * rayPosToTargetDotCos;\n    float rayPosToTargetDotSqCosSq = rayPosToTargetDotSqCos * rayPosToTargetDotSqCos;\n    float rayPosToTargetDotSqCosSqSq = rayPosToTargetDotSqCosSq * rayPosToTargetDotSqCosSq;\n    float rayPosToTargetDotSqCosSqSqSq = rayPosToTargetDotSqCosSqSq * rayPosToTargetDotSqCosSqSq;\n    float rayPosToTargetDotSqCosSqSqSqSq = rayPosToTargetDotSqCosSqSqSq * rayPosToTargetDotSqCosSqSqSq;\n    float rayPosToTargetDotSqCosSqSqSqSqSq = rayPosToTargetDotSqCosSqSqSqSq * rayPosToTargetDotSqCosSqSqSqSq;\n    float rayPosToTargetDotSqCosSqSqSqSqSqSq = rayPosToTargetDotSqCosSqSqSqSqSq * rayPosToTargetDotSqCosSqSqSqSqSq;\n    float ray", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for(int i = 0; i < 10; i++){\n        vec2 q = p;\n        float a = 0.0;\n        for(int j = 0; j < 10; j++){\n            a += length(q);\n            q = q / 2.0 + vec2(0.5);\n        }\n        d = min(d, a);\n    }\n    col = vec3(d);\n    fragColor = vec4(col, 1.0);\n}", "\n    vec4 pos = vec4(p, 1.0);\n    vec4 res = vec4(0.0);\n    res.xyz = p;\n    res.w = 1.0;\n    return res;\n}\n\n//---Essential Geometry Function\nvec", "\n\n    float t = ray.t;\n    float t0 = t;\n    float t1 = t + lightDiameter;\n\n    float t2 = t - lightDiameter;\n    float t3 = t + lightDiameter;\n\n    float t4 = t - lightDiameter;\n    float t5 = t + lightDiameter;\n\n    float t6 = t - lightDiameter;\n    float t7 = t + lightDiameter;\n\n    float t8 = t - lightDiameter;\n    float t9 = t + lightDiameter;\n\n    float t10 = t - lightDiameter;\n    float t11 = t + lightDiameter;\n\n    float t12 = t - lightDiameter;\n    float t13 = t + lightDiameter;\n\n    float t14 = t - lightDiameter;\n    float t15 = t + lightDiameter;\n\n    float t16 = t - lightDiameter;\n    float t17 = t + lightDiameter;\n\n    float t18 = t - lightDiameter;\n    float t19 = t + lightDiameter;\n\n    float t20 = t - lightDiameter;\n    float t21 = t + lightDiameter;\n\n    float t22 = t - lightDiameter;\n    float t23 = t + lightDiameter;\n\n    float t24 = t - lightDiameter;\n    float t25 = t + lightDiameter;\n\n    float t26 = t - lightDiameter;\n    float t27 = t + lightDiameter;\n\n    float t28 = t - lightDiameter;\n    float t29 = t + lightDiameter;\n\n    float t30 = t - lightDiameter;\n    float t31 = t + lightDiameter;\n\n    float t32 = t - lightDiameter;\n    float t33 = t + lightDiameter;\n\n    float t34 = t - lightDiameter;\n    float t35 = t + lightDiameter;\n\n    float t36 = t - lightDiameter;\n    float t37 = t + lightDiameter;\n\n    float", "\n    return vec2(length(p.xy), p.z);\n}\n\n// \u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193\u2193", "\n    return fract(sin(x)*1e4);\n}\n\n// Basic noise by iq\n// https://www.shadertoy.com/view/3sd3Rs\nfloat", "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n\n    float dot00 = dot(v0, v0);\n    float dot01 = dot(v0, v1);\n    float dot02 = dot(v0, v2);\n    float dot11 = dot(v1, v1);\n    float dot12 = dot(v1, v2);\n\n    float invDenom = 1.0f / (dot00 * dot11 - dot01 * dot01);\n    float u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    float v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    return (u >= 0.0f && v >= 0.0f && u + v < 1.0f);\n}\n\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nvec", "\n    int closest_hex = -1;\n    float closest_dist = INFINITY;\n    for(int i = 0; i < hex_count; i++){\n        float dist = distance(uv, hex_pos[i]);\n        if(dist < closest_dist){\n            closest_dist = dist;\n            closest_hex = i;\n        }\n    }\n    return closest_hex;\n}\n\n//Find the closest hexagon a point would be near\nint", "\n    //Check if uv is on an edge of the hexagon\n    if(abs(uv.x) + abs(uv.y) <= circumradius){\n        return ON_TRIANGLE;\n    }\n    //Check if uv is inside the nth triangle\n    if(abs(uv.x) + abs(uv.y) <= circumradius * sqrt(3) / 2){\n        return IN_TRIANGLE;\n    }\n    //Check if uv is on the nth triangle\n    if(abs(uv.x) + abs(uv.y) <= circumradius * sqrt(3) / 2 * (1 + sqrt(3))){\n        return ON_TRIANGLE;\n    }\n    return NOT_IN_TRIANGLE;\n}\n\n//Check if uv is on or near an equilateral triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint", "\n    //Check if uv is on an edge of the hexagon.\n    if(uv.x < 0.5 && uv.x > -0.5 && uv.y < 0.5 && uv.y > -0.5){\n        return ON_TRIANGLE;\n    }\n    //Check if uv is inside the isosceles triangle.\n    if(uv.x < 0.5 && uv.x > -0.5 && uv.y < 0.5 && uv.y > -0.5){\n        return IN_TRIANGLE;\n    }\n    //Check if uv is outside the isosceles triangle.\n    if(uv.x < 0.5 && uv.x > -0.5 && uv.y < 0.5 && uv.y > -0.5){\n        return OUT_TRIANGLE;\n    }\n    return NOT_IN_TRIANGLE;\n}\n\n//Check if uv is on or near an isosceles triangle\n//of a hexagon of a given circumradius.\n//Returns ON_TRIANGLE if on an edge, the nth triangle \n//uv is inside, or NOT_IN_TRIANGLE.\nint", "\n    float p = exp(-d);\n    float sum = p;\n    float r = U.x;\n    for (int i = 1; i < d; i++) {\n        r *= U.y;\n        sum += p / float(i);\n        if (r < sum)\n            return i - 1;\n        p *= (d - i) / float(i);\n    }\n    return d - 1;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat", "\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    return n;\n}\n\nuint hash2(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    return n;\n}\n\nuint hash3(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    return n;\n}\n\nuint hash4(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n = (n * (n * n * 15731U + 789221U) + 1376312589U);\n    n = (n << 17U) ^ n;\n    n =", "\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.0) / (1.0 - 0.0);\n    float t = mod(a, 2.0 * PI);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n\n    float f = (x * x + y * y) * 4.0;\n    float g = (x * x - y * y) * 4.0;\n    float h = (x * x + y * y) * 4.0;\n    float i = (x * x - y * y) * 4.0;\n\n    float j = (f + g + h + i) / 4.0;\n\n    col = vec3(j);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.02) / 0.01;\n    float c = cos(a);\n    float s = sin(a);\n    float t = (r + 1.0) * 0.5;\n    float n = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float m = smoothstep(0.0, 1.0, t);\n    float k = smoothstep(0.0, 1.0, t - 1.0);\n    float b = (n + m) * 0.5;\n    float g = (k + m) * 0.5;\n    float y = (b + g) * 0.5;\n    float rr = (r + 1.0) * 0.5;\n    float gg = (g + 1.0) * 0.5;\n    float bb = (b + 1.0) * 0.5;\n    float rr2 = rr * rr;\n    float gg2 = gg * gg;\n    float bb2 = bb * bb;\n    float rr3 = rr2 * rr;\n    float gg3 = gg2 * gg;\n    float bb3 = bb2 * bb;\n    float rr4 = rr3 * rr;\n    float gg4 = gg3 * gg;\n    float bb4 = bb3 * bb;\n    float rr5 = rr4 * rr;\n    float gg5 = gg4 * gg;\n    float bb5 = bb4 * bb;\n    float rr6 = rr5 * rr;\n    float gg6 = gg5 * gg;\n", "\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return normalize(vec3(\n        calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy),\n        calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy),\n        calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx)\n    ));\n}\n\n// Compute height at pos\nfloat", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 f = map(p);\n        vec3 dp = vec3(rd.x, rd.y, rd.z);\n        vec3 dpd = vec3(0.0);\n        for (int j = 0; j < 10; j++) {\n            dp = normalize(dp);\n            dpd = (f - p) / dp;\n            p += dp * d;\n            f = map(p);\n            if (length(f - p) < 0.001) {\n                break;\n            }\n        }\n        t += d;\n        d += length(dpd);\n        if (d > 100.0) {\n            break;\n        }\n    }\n    if (t < 100.0) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 rd = normalize(vec3(p, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    return normalize(vec3(\n        calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy),\n        calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy),\n        calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx)\n    ));\n}\n\n// Compute height at pos\nfloat", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        vec3 f = map(p);\n        vec3 dp = vec3(rd.x, rd.y, rd.z);\n        vec3 dpd = vec3(0.0);\n        for (int j = 0; j < 10; j++) {\n            dp = normalize(dp);\n            dpd = (f - p) / dp;\n            p += dp * d;\n            f = map(p);\n            if (length(f - p) < 0.001) {\n                break;\n            }\n        }\n        t += d;\n        d += length(dpd);\n        if (d > 100.0) {\n            break;\n        }\n    }\n    if (t < 100.0) {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec3 ro = vec3(0.0, 0.0, -5.0);\n    vec3 rd = normalize(vec3(p, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec2 e = vec2(1.0, -1.0) * DELTA;\n    return normalize(vec3(\n        sdf(p + e.xyy) - sdf(p - e.xyy),\n        sdf(p + e.yxy) - sdf(p - e.yxy),\n        sdf(p + e.yyx) - sdf(p - e.yyx)\n    ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n */\nvec", "\n    ivec2 p = ivec2(q.x,q.y);\n    p = (p<<13) ^ p;\n    return (float((p.x*p.x+p.y*p.y)*(p.x*p.x+p.y*p.y+p.x*p.x))*(p.y*p.y+p.x*p.x) + p.x) + p.y;\n}\n\n// random hash via https://www.shadertoy.com/view/3d2GRh\nfloat", "\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity, out float light ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    light = material_lights[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity, out float light, out float specular ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    light = material_lights[i];\n    specular = material_speculars[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec2 coord, out vec3 color, out float opacity, out float light, out float specular, out float emissive ) {\n    if ( i < 0 || i >= material_colors.Length ) {\n        return false;\n    }\n    color = material_colors[i];\n    opacity = material_opacities[i];\n    light = material_lights[i];\n    specular = material_speculars[i];\n    emissive = material_emissives[i];\n    return true;\n}\n\n// port of minecraft\nbool getMaterialColor( int i, vec", "\n    vec2 q = p - ab;\n    float k = dot(q, q) / dot(ab, ab);\n    return vec3(k - 0.5, 2.0 * k * (1.0 - k), 1.0 - k);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    vec3 p3 = fract(vec3(p) * vec3(1.0, 1.0 / 3.0, 1.0 / 5.0));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec2 c = vec2(0.5);\n    float r = 0.0;\n    float a = 1.0;\n    float t = 0.0;\n    float dt = 0.001;\n    float tmax = 100.0;\n    float tmin = 0.0;\n    float tau = 1.0;\n    float tau2 = 1.0;\n    float tau3 = 1.0;\n    float tau4 = 1.0;\n    float tau5 = 1.0;\n    float tau6 = 1.0;\n    float tau7 = 1.0;\n    float tau8 = 1.0;\n    float tau9 = 1.0;\n    float tau10 = 1.0;\n    float tau11 = 1.0;\n    float tau12 = 1.0;\n    float tau13 = 1.0;\n    float tau14 = 1.0;\n    float tau15 = 1.0;\n    float tau16 = 1.0;\n    float tau17 = 1.0;\n    float tau18 = 1.0;\n    float tau19 = 1.0;\n    float tau20 = 1.0;\n    float tau21 = 1.0;\n    float tau22 = 1.0;\n    float tau23 = 1.0;\n    float tau24 = 1.0;\n    float tau25 = 1.0;\n    float tau26 = 1.0;\n    float tau27 = 1.0;\n    float tau28 = 1.0;\n    float tau29 = 1.0;\n    float tau30 = 1.0;\n    float tau31 = 1.0;\n    float tau32 = 1.0;\n    float tau", "\n    vec4 p1 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p2 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p3 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p4 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p5 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p6 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p7 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p8 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p9 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p10 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p11 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p12 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p13 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p14 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p15 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p16 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 p17 =", "\n    return mat3(\n        vec3(cos(rotation.x)*cos(rotation.y), cos(rotation.x)*sin(rotation.y), sin(rotation.x)),\n        vec3(-sin(rotation.y), cos(rotation.y), 0),\n        vec3(sin(rotation.x)*cos(rotation.y), -sin(rotation.x)*sin(rotation.y), cos(rotation.x))\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat", "\n    vec3 raypos = rayori.xyz;\n    vec3 raydir_ = raydir.xyz;\n    vec3 raydir_n = raydir.w;\n    vec3 raydir_n_ = raydir.w;\n    vec3 raydir_n_n = raydir.w;\n    vec3 raydir_n_n_ = raydir.w;\n    vec3 raydir_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n_ = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n_n = raydir.w;\n    vec3 raydir_n_n_n_n_n_n_n_n_n_n", "\n    vec3 color = vec3(0.0);\n    vec3 pos = vec3(0.0);\n    vec3 dir = vec3(0.0);\n    vec3 ray = vec3(0.0);\n    vec3 ray_dir = vec3(0.0);\n    vec3 ray_dir_inv = vec3(0.0);\n    vec3 ray_dir_inv_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir = vec3(0.0);\n    vec3 ray_dir_inv_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir_dir", "\n    vec3 pos = vec3(0.0);\n    float dist = 0.0;\n    for(int i = 0; i < 100; i++){\n        pos = pos + raydir * dist;\n        dist += 0.01;\n        if(pos.y > 0.0) break;\n    }\n    return pos;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 raydir = normalize(vec3(p, 2.0));\n    vec3 rayori = vec3(0.0, 0.0, 0.0);\n    vec3 col = vec3(0.0);\n    vec3 pos = raymarch(raydir, rayori);\n    if(pos.y > 0.0) col = vec3(1.0, 0.0, 0.0);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    float d = 1.0;\n    for(int i = 0; i < 10; i++){\n        vec2 q = p;\n        float a = 0.0;\n        for(int j = 0; j < 10; j++){\n            a += length(q);\n            q = q / 2.0 + vec2(0.5);\n        }\n        d = min(d, a);\n    }\n    col = vec3(d);\n    fragColor = vec4(col, 1.0);\n}", "\n    // get the distance from the ray to the edge of the texture\n    float dist = texture(textureSampler, coord).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist2 = texture(textureSampler, coord + vec2(travelRate, 0.0)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist3 = texture(textureSampler, coord + vec2(travelRate, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist4 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(0.0, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist5 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, 0.0)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist6 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist7 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate) + vec2(0.0, travelRate)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist8 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate) + vec2(travelRate, 0.0)).r;\n\n    // get the distance from the ray to the edge of the texture\n    float dist9 = texture(textureSampler, coord + vec2(travelRate, travelRate) + vec2(travelRate, travelRate) + vec2(travelRate, travelRate)).r;\n\n    // get the distance from the ray to the edge of the", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    vec3 light = vec3(0.0);\n\n    float d = 1.0;\n    for (int i = 0; i < 10; i++) {\n        vec3 p = vec3(0.0);\n        p.x = sin(d * 10.0) * 0.5 + 0.5;\n        p.y = cos(d * 10.0) * 0.5 + 0.5;\n        p.z = sin(d * 10.0) * 0.5 + 0.5;\n        d = length(p);\n        light += vec3(0.0, 0.0, 1.0) * exp(-d * 0.001);\n    }\n\n    col = light;\n\n    fragColor = vec4(col, 1.0);\n}\n// -----------------------------------------------\n", "\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n    e5 = p2;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n    e5 = p2;\n    e6 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4,", "\n    vec3 x = max(vec3(0.0), color - vec3(0.004));\n    return (x * (6.2 * x + 0.5)) / (x * (6.2 * x + 1.7) + 0.06);\n}\n\n// My implementation of the tonemapping curve by milesWaugh\nvec", "\n    vec2 ab = b - a;\n    vec2 pa = p - a;\n    float h = clamp( dot( pa, ab ) / length( ab ), 0.0, 1.0 );\n    return length( pa - ab*h ) - w1 - w2;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    vec2 q = uv - p;\n    float d = length(q);\n    return vec3(d, d, d);\n}\n\n/////////////////////////////////////////////////////////////////////////////////////////////\nvec", "\n\tfloat t = falloff * rnd.x;\n\tfloat s = sin( t );\n\tfloat c = cos( t );\n\tfloat a = s * s;\n\tfloat b = c * c;\n\tfloat c2 = a * b;\n\tfloat d = a * c2;\n\tfloat e = b * c2;\n\tfloat f = c2 * c2;\n\tfloat g = d * d;\n\tfloat h = e * e;\n\tfloat i = f * f;\n\tfloat j = g * g;\n\tfloat k = h * h;\n\tfloat l = i * i;\n\tfloat m = j * j;\n\tfloat n = k * k;\n\tfloat o = l * l;\n\tfloat p = m * m;\n\tfloat q = n * n;\n\tfloat r = o * o;\n\tfloat s2 = p * p;\n\tfloat t2 = q * q;\n\tfloat u2 = r * r;\n\tfloat v2 = s2 * s2;\n\tfloat w2 = t2 * t2;\n\tfloat x2 = u2 * u2;\n\tfloat y2 = v2 * v2;\n\tfloat z2 = w2 * w2;\n\tfloat a2 = x2 * x2;\n\tfloat b2 = y2 * y2;\n\tfloat c2 = z2 * z2;\n\tfloat d2 = a2 * a2;\n\tfloat e2 = b2 * b2;\n\tfloat f2 = c2 * c2;\n\tfloat g2 = d2 * d2;\n\tfloat h2 = e2 * e2;\n\tfloat i2 = f2 * f2;\n\tfloat j2 = g2 * g2;\n\tfloat k2 = h2 * h2;\n\tfloat l2 = i2 * i2;\n\tfloat m2 = j2 * j2;\n\tfloat n2 = k2 * k2;\n\tfloat o2 = l2 * l2;\n\tfloat p2 = m2 * m2;\n\tfloat q2 = n2 * n2;\n\tfloat r2 = o2 * o2;\n\tfloat s2 = p2", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iTime * 0.01;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n\n    vec2 q = vec2(a, b);\n    vec2 r = vec2(a, b);\n\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(q, q) > 4.0) break;\n        s = q;\n        q = q * q + p;\n    }\n\n    for (int i = 0; i < 100; i++) {\n        if (dot(r, r) > 4.0) break;\n        t = r;\n        r = r * r + p;\n    }\n\n    vec3 col = vec3(0.0);\n    if (dot(s, s) > 4.0) col = vec3(1.0, 0.0, 0.0);\n    if (dot(t, t) > 4.0) col = vec3(0.0, 1.0, 0.0);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec3 p3 = fract(vec3(p) * vec3(1.0, 1.0 / 3.0, 1.0 / 5.0));\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract(vec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n//----------------------------------------------------------------------------------------\n//  3 out, 2 in...\nvec", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    vec2 p = q;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x) / 3.14159265359;\n    float r = (d - 0.0) / (1.0 - 0.0) * 0.5 + 0.5;\n    float c = cos(a * 10.0) * 0.5 + 0.5;\n    return mix(col, vec3(c), r);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 q = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x) / 3.14159265359;\n    float r = (d - 0.0) / (1.0 - 0.0) * 0.5 + 0.5;\n    float c = cos(a * 10.0) * 0.5 + 0.5;\n    vec3 col = vec3(c);\n    col = postProcess(col, q);\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec3 q = abs(p) - vec3(1.0);\n    return length(max(q, 0.0)) + min(max(q.x, max(q.y, q.z)), 0.0);\n}\n\n/* \u4e00\u4e2a\u5706\u7684SDF */\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 mouse = iMouse.xy / iResolution.xy;\n    vec2 mouse_offset = mouse - uv;\n\n    float radius = length(mouse_offset);\n    float brightness = radius / iResolution.x;\n\n    vec3 color = vec3(brightness);\n\n    fragColor = vec4(color, 1.0);\n}\n"], "input_none": ["\n\treturn cosf( a );\n}\n\nfloat", "\n    float d = length(p - _position);\n    return d;\n}\n\nvec", "\n    vec3 q = p - voxelPos;\n    return length(q) - voxelRadius;\n}\n\nfloat", "\n    vec3 P0 = vec3(0.0, 0.0, 0.0);\n    vec3 P1 = vec3(1.0, 0.0, 0.0);\n    vec3 P2 = vec3(0.0, 1.0, 0.0);\n    vec3 P3 = vec3(0.0, 0.0, 1.0);\n    vec3 P4 = vec3(0.0, 0.0, -1.0);\n    vec3 P5 = vec3(0.0, 1.0, 1.0);\n    vec3 P6 = vec3(1.0, 0.0, 1.0);\n    vec3 P7 = vec3(1.0, 1.0, 0.0);\n    vec3 P8 = vec3(1.0, 1.0, 1.0);\n    vec3 P9 = vec3(1.0, 0.0, 1.0);\n    vec3 P10 = vec3(1.0, 1.0, 1.0);\n    vec3 P11 = vec3(1.0, 1.0, 1.0);\n    vec3 P12 = vec3(1.0, 1.0, 1.0);\n    vec3 P13 = vec3(1.0, 1.0, 1.0);\n    vec3 P14 = vec3(1.0, 1.0, 1.0);\n    vec3 P15 = vec3(1.0, 1.0, 1.0);\n    vec3 P16 = vec3(1.0, 1.0, 1.0);\n    vec3 P17 = vec3(1.0, 1.0, 1.0);\n    vec3 P18 = vec3(1.0, 1.0, 1.0);\n    vec3 P19 =", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.5;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float d = (r - 0.5) * 0.5;\n    float s = sin(a + t) * 0.5 + 0.5;\n    float c = cos(a + t) * 0.5 + 0.5;\n    float dd = d * d;\n    float sd = s * s;\n    float cd = c * c;\n    float dd2 = dd * dd;\n    float sd2 = sd * sd;\n    float cd2 = cd * cd;\n    float dd3 = dd2 * dd;\n    float sd3 = sd2 * sd;\n    float cd3 = cd2 * cd;\n    float dd4 = dd3 * dd;\n    float sd4 = sd3 * sd;\n    float cd4 = cd3 * cd;\n    float dd5 = dd4 * dd;\n    float sd5 = sd4 * sd;\n    float cd5 = cd4 * cd;\n    float dd6 = dd5 * dd;\n    float sd6 = sd5 * sd;\n    float cd6 = cd5 * cd;\n    float dd7 = dd6 * dd;\n    float sd7 = sd6 * sd;\n    float cd7 = cd6 * cd;\n    float dd8 = dd7 * dd;\n    float sd8 = sd7 * sd;\n    float cd8 = cd7 * cd;\n    float dd9 = dd8 * dd;\n    float sd9 = sd8 * sd;\n    float cd9 = cd8 * cd;\n    float dd10 = dd9 * dd;\n   ", "\n    return vec4(x, x, x, 1.0);\n}\n\nvec", "\n    return vec4(0.0, 0.0, 0.0, 1.0);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    float cosTheta = dot(rayDir, sunDir);\n    if (cosTheta > 0.0)\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    else\n    {\n        color = vec3(0.0, 0.0, 0.0);\n    }\n    return color;\n}\n\nvec", "\n    return sin(coords.x * coords.y * 10.0) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        color += vec3(F(coords + vec2(i, 0.0)));\n        color += vec3(F(coords + vec2(0.0, i)));\n    }\n\n    color /= 15.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return sin(coords.x * coords.y * 10.0) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        color += vec3(F(coords + vec2(i, 0.0)));\n        color += vec3(F(coords + vec2(0.0, i)));\n    }\n\n    color /= 15.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return sin(coords.x * coords.y * 10.0) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec2 coords = (gl_FragCoord.xy * 2.0 - resolution.xy) / min(resolution.x, resolution.y);\n    vec3 color = vec3(0.0);\n\n    for (int i = 0; i < 5; i++)\n    {\n        color += vec3(F(coords + vec2(i, 0.0)));\n        color += vec3(F(coords + vec2(0.0, i)));\n    }\n\n    color /= 15.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    float n = 0.0;\n    float freq = 1.0;\n    float amp = 1.0;\n    float persistence = 0.5;\n\n    for (int i = 0; i < NUM_NOISE_LAYERS; i++) {\n        n += amp * noise(p * freq);\n        freq *= 2.0;\n        amp *= persistence;\n    }\n\n    return n;\n}\n\nfloat", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    vec2 q = p - vec2(0.5);\n    float r = dot(q, q);\n    return r * r * (3.0 - 2.0 * r);\n}\n\nfloat", "\n    vec2 q = p - vec2(floor(p.x), floor(p.y));\n    vec2 r = vec2(fract(p.x), fract(p.y));\n    float d = dot(q, q);\n    if (d < eps) return 0.0;\n    r = r*r*(3.0 - 2.0*r);\n    return -1.0 + 2.0*dot(r, r);\n}\n\nfloat", "\n    vec3 lightPosition = vec3( 0.0, 0.0, 0.0 );\n    vec3 lightDirection = normalize( lightPosition - eyePosition );\n    vec3 lightColor = vec3( 1.0, 1.0, 1.0 );\n    vec3 ambientColor = vec3( 0.2, 0.2, 0.2 );\n    vec3 diffuseColor = vec3( 0.0, 0.0, 0.0 );\n    vec3 specularColor = vec3( 0.0, 0.0, 0.0 );\n    float shininess = 10.0;\n    float attenuation = 1.0;\n    float distance = length( lightPosition - eyePosition );\n    float attenuationFactor = attenuation / ( distance * distance );\n    diffuseColor = lightColor * max( 0.0, dot( lightDirection, rayDirection ) ) * attenuationFactor;\n    vec3 eyeDirection = normalize( eyePosition - rayHitInfo );\n    vec3 reflectionDirection = reflect( -rayDirection, rayDirection );\n    float specularFactor = max( 0.0, dot( reflectionDirection, eyeDirection ) );\n    specularFactor = pow( specularFactor, shininess );\n    specularColor = lightColor * specularFactor * attenuationFactor;\n    return ( ambientColor + diffuseColor + specularColor ) * colorTheWorld;\n}\n\nvoid main()\n{\n    vec3 eyePosition = vec3( 0.0, 0.0, 0.0 );\n    vec3 rayDirection = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheWorld = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheRay = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheLight = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorThe", "\n    return p * 0.5 + 0.5;\n}\n\nvec", "\n    vec2 res = vec2(0.0);\n    float t = 0.0;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        res.x = max(res.x, d);\n        t += d;\n        if(d < 0.001) break;\n    }\n    return res;\n}\n\nvoid main()\n{\n    vec2 res = vec2(0.0);\n    vec2 tex = vec2(0.0);\n    vec3 ro = vec3(0.0);\n    vec3 rd = vec3(0.0);\n    vec3 col = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 amb = vec3(0.0);\n    vec3 dif = vec3(0.0);\n    vec3 spe = vec3(0.0);\n    vec3 fog = vec3(0.0);\n    vec3 sky = vec3(0.0);\n    vec3 sun = vec3(0.0);\n    vec3 moon = vec3(0.0);\n    vec3 moon_col = vec3(0.0);\n    vec3 moon_amb = vec3(0.0);\n    vec3 moon_dif = vec3(0.0);\n    vec3 moon_spe = vec3(0.0);\n    vec3 moon_fog = vec3(0.0);\n    vec3 moon_sky = vec3(0.0);\n    vec3 moon_sun = vec3(0.0);\n    vec3 moon_moon = vec3(0.0);\n    vec3 moon_moon_col = vec3(0.0);\n    vec3 moon_moon_amb = vec3(0.0);\n    vec3 moon_moon_dif = vec3(", "\n    vec4 p2 = vec4(p, 1.0);\n    p2.y *= -1.0;\n    p2.x *= -1.0;\n    p2.z *= -1.0;\n    p2.w = 1.0;\n    return p2;\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    vec3 pos = vec3(0.0);\n    vec3 nor = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 refDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightAttenuation2 = vec3(0.0);\n    vec3 lightAttenuation3 = vec3(0.0);\n    vec3 lightAttenuation4 = vec3(0.0);\n    vec3 lightAttenuation5 = vec3(0.0);\n    vec3 lightAttenuation6 = vec3(0.0);\n    vec3 lightAttenuation7 = vec3(0.0);\n    vec3 lightAttenuation8 = vec3(0.0);\n    vec3 lightAttenuation9 = vec3(0.0);\n    vec3 lightAttenuation10 = vec3(0.0);\n    vec3 lightAttenuation11 = vec3(0.0);\n    vec3 lightAttenuation12 = vec3(0.0);\n    vec3 lightAttenuation13 = vec3(0.0);\n    vec3 lightAttenuation14 = vec3(0.0);\n    vec3 lightAttenuation15 = vec3(0.0);\n    vec3 lightAttenuation16 = vec3(0.0);\n    vec3 lightAttenuation17 = vec3(0.0);\n    vec3 lightAttenuation18 = vec3(0.0);\n    vec3 lightAttenuation19 = vec3(0.0);\n    vec3 lightAttenuation20 = vec3(", "\n    vec3 n = normalize(oN);\n    vec3 n1 = normalize(oN + vec3(1.0, 0.0, 0.0));\n    vec3 n2 = normalize(oN + vec3(-1.0, 0.0, 0.0));\n    vec3 n3 = normalize(oN + vec3(0.0, 1.0, 0.0));\n    vec3 n4 = normalize(oN + vec3(0.0, -1.0, 0.0));\n    vec3 n5 = normalize(oN + vec3(0.0, 0.0, 1.0));\n    vec3 n6 = normalize(oN + vec3(0.0, 0.0, -1.0));\n\n    float d1 = dot(n, p - oN);\n    float d2 = dot(n1, p - oN);\n    float d3 = dot(n2, p - oN);\n    float d4 = dot(n3, p - oN);\n    float d5 = dot(n4, p - oN);\n    float d6 = dot(n5, p - oN);\n    float d7 = dot(n6, p - oN);\n\n    return vec3(d1, d2, d3) - vec3(d4, d5, d6) - vec3(d7, 0.0, 0.0);\n}\n\nvec", "\n    return fract(sin(dot(p,vec3(127.1,311.7, 72.5)))*43758.5453);\n}\n\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 envColor = vec3(0.0);\n    float intensity = 0.0;\n    float attenuation = 1.0;\n    float blurAmount = 0.0;\n    float blurScale = 1.0;\n    float blurFactor = 1.0;\n    float blurFactor2 = 1.0;\n    float blurFactor3 = 1.0;\n    float blurFactor4 = 1.0;\n    float blurFactor5 = 1.0;\n    float blurFactor6 = 1.0;\n    float blurFactor7 = 1.0;\n    float blurFactor8 = 1.0;\n    float blurFactor9 = 1.0;\n    float blurFactor10 = 1.0;\n    float blurFactor11 = 1.0;\n    float blurFactor12 = 1.0;\n    float blurFactor13 = 1.0;\n    float blurFactor14 = 1.0;\n    float blurFactor15 = 1.0;\n    float blurFactor16 = 1.0;\n    float blurFactor17 = 1.0;\n    float blurFactor18 = 1.0;\n    float blurFactor19 = 1.0;\n    float blurFactor20 = 1.0;\n    float blurFactor21 = 1.0;\n    float blurFactor22 = 1.0;\n    float blurFactor23 = 1.0;\n    float blurFactor24 = 1.0;\n    float blurFactor25 = 1.0;\n    float blurFactor26 = 1.0;\n    float blurFactor27 = 1.0;\n    float blurFactor28 = 1.0;\n    float blurFactor29 = 1.0;\n    float blurFactor30 = 1.0;\n    float blurFactor31 = 1.0;\n    float blurFactor32 = 1.0;\n    float blurFactor33 = 1.0;\n    float blurFactor34 = 1.0;\n    float blurFactor35 = ", "\n    float d = distance(coords, A);\n    float d2 = distance(coords, B);\n    float h = height;\n    float a = (d2 - d) / (d2 - d + h);\n    return clamp(a, 0.0, 1.0);\n}\n\nfloat", "\n    return start * (1.0f - percent) + end * percent;\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec2 v = b - a;\n    vec2 w = p - a;\n    return dot(w, v) / dot(v, v);\n}\n\nfloat", "\n    vec3 color = vec3(0.0f);\n    vec3 lightDir = vec3(0.0f);\n    vec3 lightColor = vec3(0.0f);\n    vec3 lightPos = vec3(0.0f);\n    vec3 lightPos2 = vec3(0.0f);\n    vec3 lightPos3 = vec3(0.0f);\n    vec3 lightPos4 = vec3(0.0f);\n    vec3 lightPos5 = vec3(0.0f);\n    vec3 lightPos6 = vec3(0.0f);\n    vec3 lightPos7 = vec3(0.0f);\n    vec3 lightPos8 = vec3(0.0f);\n    vec3 lightPos9 = vec3(0.0f);\n    vec3 lightPos10 = vec3(0.0f);\n    vec3 lightPos11 = vec3(0.0f);\n    vec3 lightPos12 = vec3(0.0f);\n    vec3 lightPos13 = vec3(0.0f);\n    vec3 lightPos14 = vec3(0.0f);\n    vec3 lightPos15 = vec3(0.0f);\n    vec3 lightPos16 = vec3(0.0f);\n    vec3 lightPos17 = vec3(0.0f);\n    vec3 lightPos18 = vec3(0.0f);\n    vec3 lightPos19 = vec3(0.0f);\n    vec3 lightPos20 = vec3(0.0f);\n    vec3 lightPos21 = vec3(0.0f);\n    vec3 lightPos22 = vec3(0.0f);\n    vec3 lightPos23 = vec3(0.0f);\n    vec3 lightPos24 = vec3(0.0f);\n    vec3 lightPos25 = vec3(0.", "\n    vec3 object_center = vec3(0.0, 0.0, 0.0);\n    float radius = 1.0;\n    return length(p - object_center) - radius;\n}\n\nfloat", "\n    float t0, t1;\n    vec3 oc = org - vec3(0.0, 0.0, 0.0);\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc, oc) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        near = far = -1.0;\n        return false;\n    }\n    else\n    {\n        discriminant = sqrt(discriminant);\n        t0 = (-b - discriminant) / (2.0 * a);\n        t1 = (-b + discriminant) / (2.0 * a);\n        if (t0 > t1)\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        if (t0 < 0.0)\n        {\n            near = t1;\n            far = t1;\n        }\n        else if (t1 < 0.0)\n        {\n            near = t0;\n            far = t0;\n        }\n        else\n        {\n            near = t0;\n            far = t1;\n        }\n        return true;\n    }\n}\n\nbool sphere(vec3 org, vec3 dir, out float near, out float far)\n{\n    float t0, t1;\n    vec3 oc = org - vec3(0.0, 0.0, 0.0);\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc, oc) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        near = far = -1.0;\n        return false;\n    }\n    else\n    {\n        discriminant = sqrt(discriminant);\n        t0 =", "\n    float d = s.w;\n    vec3 q = p - s.xyz;\n    return dot(q, q) - d*d;\n}\n\nfloat", "\n    return fract(sin(dot(p,vec3(127.1,311.7, 72.5)))*43758.5453);\n}\n\nfloat", "\n    vec2 pos = p;\n    float d = 0.0;\n    for(int i = 0; i < 10; i++){\n        d += drawCircle(pos, 0.05);\n        pos.x += 0.05;\n    }\n    return d;\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    float d = drawShape(p);\n    gl_FragColor = vec4(vec3(d), 1.0);\n}", "\n    vec3 n = normalize(sn);\n    vec3 t = normalize(cross(n, sp));\n    vec3 b = cross(t, n);\n    return (sp + b * bumpFactor) * 0.5 + 0.5;\n}\n\nvoid main()\n{\n    vec3 sp = vec3(0.0, 0.0, 0.0);\n    vec3 sn = vec3(0.0, 0.0, 0.0);\n    vec3 sn2 = vec3(0.0, 0.0, 0.0);\n    vec3 sn3 = vec3(0.0, 0.0, 0.0);\n    vec3 sn4 = vec3(0.0, 0.0, 0.0);\n    vec3 sn5 = vec3(0.0, 0.0, 0.0);\n    vec3 sn6 = vec3(0.0, 0.0, 0.0);\n    vec3 sn7 = vec3(0.0, 0.0, 0.0);\n    vec3 sn8 = vec3(0.0, 0.0, 0.0);\n    vec3 sn9 = vec3(0.0, 0.0, 0.0);\n    vec3 sn10 = vec3(0.0, 0.0, 0.0);\n    vec3 sn11 = vec3(0.0, 0.0, 0.0);\n    vec3 sn12 = vec3(0.0, 0.0, 0.0);\n    vec3 sn13 = vec3(0.0, 0.0, 0.0);\n    vec3 sn14 = vec3(0.0, 0.0, 0.0);\n    vec3 sn15 = vec3(0.0, 0.0, 0.0);\n    vec3 sn16 = vec3(0.0, 0", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    vec3 light = normalize(vec3(1, 1, 1));\n    vec3 v = normalize(p - eye);\n    vec3 r = reflect(-light, n);\n    float s = pow(max(dot(r, v), 0.0), 100.0);\n    return vec3(s);\n}\n\nvoid main()\n{\n    vec3 p = vec3(gl_FragCoord.xy, 0.0);\n    vec3 n = normal(p);\n    vec3 c = shade(p, n);\n    gl_FragColor = vec4(c, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return vec3(0.5, 0.5, 0.5);\n}\n\nvec", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float d1 = 0.0;\n    float d2 = 0.0;\n    float d3 = 0.0;\n    float d4 = 0.0;\n    float d5 = 0.0;\n    float d6 = 0.0;\n    float d7 = 0.0;\n    float d8 = 0.0;\n    float d9 = 0.0;\n    float d10 = 0.0;\n    float d11 = 0.0;\n    float d12 = 0.0;\n    float d13 = 0.0;\n    float d14 = 0.0;\n    float d15 = 0.0;\n    float d16 = 0.0;\n    float d17 = 0.0;\n    float d18 = 0.0;\n    float d19 = 0.0;\n    float d20 = 0.0;\n    float d21 = 0.0;\n    float d22 = 0.0;\n    float d23 = 0.0;\n    float d24 = 0.0;\n    float d25 = 0.0;\n    float d26 = 0.0;\n    float d27 = 0.0;\n    float d28 = 0.0;\n    float d29 = 0.0;\n    float d30 = 0.0;\n    float d31 = 0.0;\n    float d32 = 0.0;\n    float d33 = 0.0;\n    float d34 = 0.0;\n    float d35 = 0.0;\n    float d36 = 0.0;\n    float d37 = 0.0;\n    float d38 = 0.0;\n    float d39 = 0.0;\n    float d40 = 0.0;\n    float d41 = 0.0;\n    float d42 = 0.0;\n    float d43 = 0.0;\n    float d44", "\n    return length(p)-rad;\n}\n\nfloat", "\n    vec3 q = p;\n    float d = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    float e = 0.0;\n    float f = 1.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n    float ay = 0.0;\n    float az = 0.0;\n    float ba = 0.0;\n    float bb = 0.0;\n    float bc = 0.0;", "\n    vec3 light_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    float light_intensity = 0.5;\n    float light_attenuation = 1.0;\n    float light_radius = 0.0;\n    float light_softness = 0.0;\n    float light_softness_scale = 1.0;\n    float light_softness_power = 1.0;\n    float light_softness_offset = 0.0;\n    float light_softness_falloff = 0.0;\n    float light_softness_falloff_scale = 1.0;\n    float light_softness_falloff_power = 1.0;\n    float light_softness_falloff_offset = 0.0;\n    float light_softness_falloff_falloff = 0.0;\n    float light_softness_falloff_falloff_scale = 1.0;\n    float light_softness_falloff_falloff_power = 1.0;\n    float light_softness_falloff_falloff_offset = 0.0;\n    float light_softness_falloff_falloff_falloff = 0.0;\n    float light_softness_falloff_falloff_falloff_scale = 1.0;\n    float light_softness_falloff_falloff_falloff_power = 1.0;\n    float light_softness_falloff_falloff_falloff_offset = 0.0;\n    float light_softness_falloff_falloff_falloff_falloff = 0.0;\n    float light_softness_falloff_falloff_falloff_falloff_scale = 1.0;\n    float light_softness_falloff_falloff_falloff_falloff_power = 1.0;\n    float light_softness_falloff_falloff_falloff_falloff_offset = 0.0;\n    float light_softness_falloff_falloff_falloff_falloff_falloff = 0.0;\n    float", "\n    vec3 col = vec3(0.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float lightIntensity = 1.0;\n    float diffuseIntensity = dot(lightDir, rd);\n    if (diffuseIntensity > 0.0)\n    {\n        col += lightColor * lightIntensity * diffuseIntensity;\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec3 ro = vec3(0.0, 0.0, 10.0);\n    vec3 rd = normalize(vec3(0.0, 0.0, -1.0));\n    vec3 col = vec3(0.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    float lightIntensity = 1.0;\n    float diffuseIntensity = dot(lightDir, rd);\n    if (diffuseIntensity > 0.0)\n    {\n        col += lightColor * lightIntensity * diffuseIntensity;\n    }\n    col = skyColor(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro + rd * ti;\n    float t = texture(tex, p.xy).x;\n    if (t < 0.001) {\n        col = vec3(0.0);\n    } else {\n        col = vec3(1.0);\n    }\n    return col;\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = vec3(0.0);\n    float ti = 0.0;\n    for (int i = 0; i < 100; i++) {\n        col += rayColor(ro, rd, ti);\n        ti += max(0.001, 0.0001 * length(rd));\n    }\n    col /= 100.0;\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.5", "\n    vec2 q = p - diamond.xy;\n    return length(q - vec2(diamond.zw)) - diamond.w;\n}\n\nfloat", "\n    return vec3(1.0) - smoothstep(0.0, 1.0, abs(sin(uv.x * 10.0) * 0.5 + sin(uv.y * 10.0) * 0.5));\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy - iResolution.xy * 0.5) / iResolution.y;\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < 10; i++)\n    {\n        color += pattern(uv + vec2(i, 0.0));\n    }\n    color /= 10.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec3 p = pos;\n    float d = 0.0;\n    for ( int i = 0; i < 10; i++ ) {\n        d += texture( iChannel0, p ).r;\n        p *= 2.0;\n        p.x += sin( p.y * 10.0 ) * 0.01;\n        p.y += cos( p.x * 10.0 ) * 0.01;\n    }\n    return d;\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    vec3 col = vec3( 0.0 );\n    float d = dist_field( p );\n    col = vec3( 1.0 - d );\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    vec3 l = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 r = reflect(-l, n);\n    vec3 vl = normalize(l + eye);\n    vec3 vr = reflect(vl, n);\n    float diff = max(dot(l, n), 0.0);\n    float spec = pow(max(dot(vr, vl), 0.0), 16.0);\n    return vec3(0.2, 0.2, 0.2) * diff + vec3(0.8, 0.8, 0.8) * spec;\n}\n\nvoid main() {\n    vec3 eye = vec3(0.0, 0.0, 1.0);\n    vec3 n = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 v = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 color = shading(v, n, eye);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    return sin(p.x + offset) * sin(p.y + offset);\n}\n\nfloat", "\n    float xmts = x.x;\n    float ymts = x.y;\n    float zmts = x.z;\n    float wmts = x.w;\n    float xmts2 = xmts * xmts;\n    float ymts2 = ymts * ymts;\n    float zmts2 = zmts * zmts;\n    float wmts2 = wmts * wmts;\n    float xmts3 = xmts2 * xmts;\n    float ymts3 = ymts2 * ymts;\n    float zmts3 = zmts2 * zmts;\n    float wmts3 = wmts2 * wmts;\n    float xmts4 = xmts3 * xmts;\n    float ymts4 = ymts3 * ymts;\n    float zmts4 = zmts3 * zmts;\n    float wmts4 = wmts3 * wmts;\n    float xmts5 = xmts4 * xmts;\n    float ymts5 = ymts4 * ymts;\n    float zmts5 = zmts4 * zmts;\n    float wmts5 = wmts4 * wmts;\n    float xmts6 = xmts5 * xmts;\n    float ymts6 = ymts5 * ymts;\n    float zmts6 = zmts5 * zmts;\n    float wmts6 = wmts5 * wmts;\n    float xmts7 = xmts6 * xmts;\n    float ymts7 = ymts6 * ymts;\n    float zmts7 = zmts6 * zmts;\n    float wmts7 = wmts6 * wmts;\n    float xmts8 = xmts7 * xmts;\n    float ymts8 = ymts7 * ymts;\n    float zmts8 = zmts7 * zmts;\n    float wmts8 = wmts7 *", "\n    vec3 q = abs(p);\n    return max(q.x, max(q.y, q.z)) - h + r;\n}\n\nfloat", "\n    float d = scene(p);\n    if (d < eps) {\n        return 0.0;\n    }\n    return d;\n}\n\nfloat", "\n    vec3 f = normalize(center - eye);\n    vec3 s = normalize(cross(f, up));\n    vec3 u = cross(s, f);\n    return mat3(s, u, -f);\n}\n\nvec", "\n    vec3 a = vec3(12.9898,78.233,45.145);\n    vec3 b = vec3(13.302,15.0287,83.985);\n    vec3 c = vec3(8.124,6.1595,105.291);\n    vec3 d = vec3(1.0,1.0,1.0);\n    vec3 u = fract(sin(dot(p,a))*c);\n    vec3 f = fract(sin(dot(p,b))*c);\n    vec3 g = fract(sin(dot(p,c))*c);\n    return mix(mix(mix(dot(u,f),g),mix(f,g,f.x),f.y),mix(mix(u,g,u.x),mix(g,f,g.x),u.y),f.z);\n}\n\nfloat", "\n    vec4 color = texture2D(u_texture, coord);\n    vec4 color2 = texture2D(u_texture2, coord);\n    vec4 color3 = texture2D(u_texture3, coord);\n    vec4 color4 = texture2D(u_texture4, coord);\n    vec4 color5 = texture2D(u_texture5, coord);\n    vec4 color6 = texture2D(u_texture6, coord);\n    vec4 color7 = texture2D(u_texture7, coord);\n    vec4 color8 = texture2D(u_texture8, coord);\n    vec4 color9 = texture2D(u_texture9, coord);\n    vec4 color10 = texture2D(u_texture10, coord);\n    vec4 color11 = texture2D(u_texture11, coord);\n    vec4 color12 = texture2D(u_texture12, coord);\n    vec4 color13 = texture2D(u_texture13, coord);\n    vec4 color14 = texture2D(u_texture14, coord);\n    vec4 color15 = texture2D(u_texture15, coord);\n    vec4 color16 = texture2D(u_texture16, coord);\n    vec4 color17 = texture2D(u_texture17, coord);\n    vec4 color18 = texture2D(u_texture18, coord);\n    vec4 color19 = texture2D(u_texture19, coord);\n    vec4 color20 = texture2D(u_texture20, coord);\n    vec4 color21 = texture2D(u_texture21, coord);\n    vec4 color22 = texture2D(u_texture22, coord);\n    vec4 color23 = texture2D(u_texture23, coord);\n    vec4 color24 = texture2D(u_texture24, coord);\n    vec", "\n    return fract(sin(vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)))) * w);\n}\n\nfloat", "\n    vec3 q = p;\n    float f = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 5; i++){\n        f += a * texture(iChannel0, q.yz).r;\n        q = q * 2.0 - vec3(0.0, 0.0, 1.0);\n        a *= 0.5;\n    }\n    return f;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    vec2 p = uv * 2.0 - 1.0;\n    p.x *= iResolution.x / iResolution.y;\n    float f = bumpFunction(p);\n    col = vec3(f);\n    fragColor = vec4(col, 1.0);\n}", "\n    vec4 ray_nds = vec4(scr_pt, 0.0, 1.0);\n    vec4 ray_clip = viewp_inv * ray_nds;\n    vec4 ray_eye = view_inv * ray_clip;\n    vec4 ray_world = proj_inv * ray_eye;\n    ray_world.xyz /= ray_world.w;\n    return ray_world;\n}\n\nvec", "\n    float d = distance(pA, pB);\n    float l = length(pA - pB);\n    float r = rounded;\n    float dd = d - r;\n    float dd2 = d - r - thick.x;\n    float dd3 = d - r - thick.y;\n    float dd4 = d - r - thick.x - thick.y;\n    float dd5 = d - r - thick.x - thick.y - thick.x;\n    float dd6 = d - r - thick.x - thick.y - thick.y;\n    float dd7 = d - r - thick.x - thick.y - thick.x - thick.y;\n    float dd8 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x;\n    float dd9 = d - r - thick.x - thick.y - thick.x - thick.y - thick.y;\n    float dd10 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y;\n    float dd11 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x;\n    float dd12 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.y;\n    float dd13 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y;\n    float dd14 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x;\n    float dd15 = d - r - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.x - thick.y - thick.y;\n    float dd16 = d - r - thick.x - thick.y - thick.x - thick.y - thick", "\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 0.0) - p);\n    vec3 halfDir = normalize(lightDir + viewDir);\n    float diff = max(dot(n, lightDir), 0.0);\n    float spec = pow(max(dot(n, halfDir), 0.0), 16.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0) * (1.0 - diff);\n    color += vec3(0.0, 0.0, 0.0) * spec;\n    return color;\n}\n\nvoid main()\n{\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 n = vec3(0.0, 0.0, 0.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    for (int i = 0; i < 100; i++)\n    {\n        p = vec3(0.0, 0.0, 0.0);\n        n = vec3(0.0, 0.0, 0.0);\n        for (int j = 0; j < 100; j++)\n        {\n            p += vec3(0.0, 0.0, 0.0);\n            n += vec3(0.0, 0.0, 0.0);\n        }\n        p /= 100.0;\n        n /= 100.0;\n        color += Shade(p, n);\n    }\n    color /= 100.0;\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    vec2 i = vec2( 0.0 );\n    vec2 f = vec2( 1.0 );\n    for( int j = 0; j < 10; j++ )\n    {\n        if( f.x < f.y )\n            f = vec2( f.x * 2.0, f.y * 2.0 );\n        else\n            f = vec2( f.x, f.y * 2.0 );\n        i += f;\n        if( length( ro + rd * i.x - cen ) > rad.x )\n            break;\n        if( length( ro + rd * i.y - cen ) > rad.y )\n            break;\n    }\n    return i;\n}\n\nvec", "\n\tfloat wave = (sin(x) * a) + b;\n\treturn wave;\n}\n\nfloat", "\n    return (vec2){a.x * b.x, a.y * b.y};\n}\n\nvec", "\n    vec4 res = vec4(0.0);\n    vec3 ab = pb - pa;\n    float d = dot(ab, ab);\n    float e = dot(ab, rd);\n    float f = dot(ab, ro) - ra;\n    float g = d*f - e*e;\n    if (g > 0.0)\n    {\n        float h = sqrt(g);\n        float t = (e + h) / d;\n        if (t > 0.0)\n        {\n            vec3 pt = ro + t*rd;\n            float y = length(pt - pa);\n            if (y < h)\n            {\n                res.x = t;\n                res.y = y;\n                res.z = h;\n            }\n        }\n    }\n    return res;\n}\n\nvec", "\n    float d = length(P - U);\n    if (d < r) {\n        O.xyz = C;\n        O.w = 1.0;\n    }\n}\n\nvoid main() {\n    vec2 U = gl_FragCoord.xy / iResolution.xy;\n    vec2 P = -1.0 + 2.0 * U;\n    P.x *= iResolution.x / iResolution.y;\n    vec3 C = vec3(0.0);\n    sphere(C, U, P, 0.5, vec3(1.0, 0.0, 0.0));\n    sphere(C, U, P, 0.25, vec3(0.0, 1.0, 0.0));\n    sphere(C, U, P, 0.125, vec3(0.0, 0.0, 1.0));\n    gl_FragColor = vec4(C, 1.0);\n}\n", "\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float h = map(a, 0.0, 6.28318530718, 0.0, 1.0);\n    return r * h;\n}\n\nvoid main()\n{\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec3 col = vec3(0.0);\n    for (int i = 0; i < 100; i++)\n    {\n        vec2 q = p + vec2(sin(i + time), cos(i + time)) * 0.01;\n        col += vec3(1.0 - map(q));\n    }\n    col /= 100.0;\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.5));\n    col = pow(col, vec3(1.0 / 1.1));\n    col = pow(col, vec3(1.0 / 0.6));\n    col = pow(col, vec3(1.0 / 0.4));\n    col = pow(col, vec3(1.0 / 0.3));\n    col = pow(col, vec3(1.0 / 0.2));\n    col = pow(col, vec3(1.0 / 0.1));\n    col = pow(col, vec3(1.0 / 0.06));\n    col = pow(col, vec3(1.0 / 0.04));\n    col = pow(col, vec3(1.0 / 0.03));\n    col = pow(col, vec3(1.0 / 0.02));\n    col = pow(col, vec3(1.0 / 0.01));\n   ", "\n    vec3 scale = vec3(1.0, 1.0, 1.0);\n    if(layerID == 0.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 1.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 2.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 3.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 4.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 5.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 6.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 7.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 8.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 9.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 10.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 11.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if(layerID == 12.0){\n        scale = vec3(1.0, 1.0, 1.0);\n    }\n    else if", "\n    return vec3(p.x, p.y, 0.0);\n}\n\nvec", "\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 1000.0;\n    float tymin = 0.0;\n    float tymax = 1000.0;\n    float tzmin = 0.0;\n    float tzmax = 1000.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n", "\n    vec3 rayDirection = normalize(currentRayPosition - cameraPosition);\n    vec3 rayOrigin = cameraPosition;\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    return fract(x * sm);\n}\n\nfloat", "\n    p = fract(p * vec3(12345.6789, 12345.6789, 12345.6789));\n    p += dot(p, p + 19.19);\n    return fract(vec3(dot(p, p + 19.19), dot(p, p + 19.19), dot(p, p + 19.19)));\n}\n\nfloat", "\n    vec3 a = fract(p);\n    a = a * a * (3.0 - 2.0 * a);\n\n    return mix(mix(a.x, a.y, a.z), mix(a.y, a.z, a.x), a.x);\n}\n\nfloat", "\n\t\treturn length(p);\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.5;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.25;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.03125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.015625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0078125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.00390625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.001953125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0009765625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.00048828125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.000244140625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.0001220703125;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.00006103515625;\n\t}\n\t\n\tfloat func(vec2 p){\n\t\treturn length(p) * 0.000030517578125;\n\t}\n\t\n\tfloat func(vec", "\n    vec2 balloonPosition = vec2( 0.0, 0.0 );\n    balloonPosition.x = sdfBalloonPosition.x;\n    balloonPosition.y = sdfBalloonPosition.y;\n    return sdfBalloonPosition.z - length( currentRayPosition - balloonPosition );\n}\n\nvec", "\n    vec4 res = vec4( 0.0 );\n    vec3 p = ro;\n    float t = 0.0;\n    float tmin = 0.0;\n    float tmax = 100000.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        if( tmax - tmin < 0.0001 )\n            break;\n        float tm = ( tmin + tmax ) * 0.5;\n        vec3 pp = p + tm * rd;\n        float d = length( pp - rad );\n        if( d < tmax )\n        {\n            tmax = d;\n            res = vec4( tm, tm, tm, 1.0 );\n        }\n        tmin = max( tmin, tm );\n        t = tm;\n    }\n    return res;\n}\n\nvec", "\n    vec3 a = fract(p);\n    a = a*a*(3.0-2.0*a);\n    return a.x*(a.y+a.z) + a.y*a.z;\n}\n\nfloat", "\n    vec3 oc = p - a;\n    vec3 ab = b - a;\n    vec3 n = cross(oc,ab);\n    float d = dot(n,c);\n    float t = dot(n,oc)/d;\n    return t;\n}\n\nfloat", "\n    vec2 z0 = z;\n    z.x = c.x;\n    z.y = c.y;\n    for(int i = 0; i < 100; i++){\n        z.x = z0.x*z0.x - z0.y*z0.y + c.x;\n        z.y = 2.0*z0.x*z0.y + c.y;\n        if(length(z) > 2.0){\n            return float(i)/100.0;\n        }\n    }\n    return 0.0;\n}\n\nvoid main(){\n    vec2 c = (gl_FragCoord.xy - 0.5*iResolution.xy)/iResolution.y;\n    vec2 z = vec2(0.0);\n    float m = mandelbrot(c, z);\n    gl_FragColor = vec4(m, m, m, 1.0);\n}\n", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = cross(z, x);\n    return mat4(x, y, z, vec4(0, 0, 0, 1));\n}\n\nvec", "\n    vec3 rgb = clamp(abs(mod(c.x*6.0+vec3(0.0,4.0,2.0),6.0)-3.0)-1.0,0.0,1.0);\n    rgb = rgb*rgb*(3.0-2.0*rgb);\n    return c.z*mix(vec3(1.0),rgb,c.y);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy/iResolution.xy);\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 col = vec3(0.0);\n    float aa = 1.0;\n    for(int i=0;i<5;i++){\n        vec2 off = vec2(0.0);\n        off.x = i*0.1;\n        col += hsv2rgb(vec3(mod(iTime+off.x,1.0),1.0,1.0));\n    }\n    col /= 5.0;\n    col = pow(col,vec3(0.4545));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.2));\n    col = pow(col,vec3(1.0/2.", "\n    float c = cos(dir), s = sin(dir);\n    return ciPat(p, w, c, s);\n}\n\nfloat", "\n    return (b - a) * x + a;\n}\n\nfloat", "\n    float dist = length(xy);\n    float alpha = smoothstep(0.0, 1.0, dist);\n    baseCol = mix(baseCol, curveCol, alpha);\n}\n\nvoid main()\n{\n    vec2 xy = gl_FragCoord.xy / resolution.xy;\n    vec4 baseCol = vec4(0.0, 0.0, 0.0, 0.0);\n    vec4 curveCol = vec4(0.0, 0.0, 0.0, 0.0);\n\n    drawFunc(baseCol, xy, curveCol);\n\n    gl_FragColor = baseCol;\n}\n", "\n    return 0.5*sin(j*p.x)+0.5*sin(j*p.y);\n}\n\nfloat", "\n    return f*f;\n}\n\nint", "\n    return vec3(c.r, c.g, c.b);\n}\n\nvec", "\n    return sdBox(p,s);\n}\n\nDAVec3 sdBox(DAVec3 p,vec3 s){\n    DAVec3 q = abs(p)-s;\n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s){\n    DAVec3 q = abs(p)-s;\n    return length(max(q,0.0))+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s,DAVec3 t){\n    DAVec3 q = abs(p)-s;\n    DAVec3 r = abs(q)-t;\n    return length(max(r,0.0))+min(max(max(r.x,r.y),r.z),0.0)+min(max(q.x,max(q.y,q.z)),0.0);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s,DAVec3 t,DAVec3 u){\n    DAVec3 q = abs(p)-s;\n    DAVec3 r = abs(q)-t;\n    DAVec3 s = abs(r)-u;\n    return length(max(s,0.0))+min(max(max(max(s.x,s.y),s.z),r.x),r.y)+min(max(max(max(q.x,q.y),q.z),r.x),r.y)+min(max(max(q.x,q.y),q.z),q.z);\n}\n\nDAVec3 sdBox(DAVec3 p,DAVec3 s,DAVec3 t,DAVec3 u,DAVec3 v){\n    DAVec3 q = abs(p)-s;\n    DAVec3 r = abs(", "\n    vec4 sd = vec4(0.0);\n    vec4 sd1 = vec4(0.0);\n    vec4 sd2 = vec4(0.0);\n    vec4 sd3 = vec4(0.0);\n    vec4 sd4 = vec4(0.0);\n    vec4 sd5 = vec4(0.0);\n    vec4 sd6 = vec4(0.0);\n    vec4 sd7 = vec4(0.0);\n    vec4 sd8 = vec4(0.0);\n    vec4 sd9 = vec4(0.0);\n    vec4 sd10 = vec4(0.0);\n    vec4 sd11 = vec4(0.0);\n    vec4 sd12 = vec4(0.0);\n    vec4 sd13 = vec4(0.0);\n    vec4 sd14 = vec4(0.0);\n    vec4 sd15 = vec4(0.0);\n    vec4 sd16 = vec4(0.0);\n    vec4 sd17 = vec4(0.0);\n    vec4 sd18 = vec4(0.0);\n    vec4 sd19 = vec4(0.0);\n    vec4 sd20 = vec4(0.0);\n    vec4 sd21 = vec4(0.0);\n    vec4 sd22 = vec4(0.0);\n    vec4 sd23 = vec4(0.0);\n    vec4 sd24 = vec4(0.0);\n    vec4 sd25 = vec4(0.0);\n    vec4 sd26 = vec4(0.0);\n    vec4 sd27 = vec4(0.0);\n    vec4 sd28 = vec4(0.0);\n", "\n    vec3 color = vec3(0.0);\n    vec3 rayDir = normalize(pos - cameraPos);\n    vec3 rayPos = cameraPos;\n    for (int i = 0; i < steps; i++)\n    {\n        vec3 hit = raymarch(rayPos, rayDir);\n        if (hit.x == -1.0)\n        {\n            break;\n        }\n        color += shade(hit);\n        rayPos = hit;\n    }\n    return vec4(color, depth);\n}\n\nvoid main()\n{\n    vec2 uv = (gl_FragCoord.xy / resolution.xy) - 0.5;\n    vec2 p = uv * 2.0 - 1.0;\n    vec3 rayDir = normalize(vec3(p.x, p.y, 1.0));\n    vec3 rayPos = cameraPos;\n    vec3 color = vec3(0.0);\n    for (int i = 0; i < steps; i++)\n    {\n        vec3 hit = raymarch(rayPos, rayDir);\n        if (hit.x == -1.0)\n        {\n            break;\n        }\n        color += shade(hit);\n        rayPos = hit;\n    }\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return pow(x, vec3(1.0 / 2.2));\n}\n\nvec", "\n    return dot(p,p);\n}\n\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 light_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 view_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 half_dir = normalize(light_dir + view_dir);\n    float diffuse = max(dot(light_dir, p), 0.0);\n    float specular = pow(max(dot(half_dir, p), 0.0), 16.0);\n    color = vec3(0.0, 0.0, 0.0);\n    return color;\n}\n\nvoid main() {\n    vec3 p = vec3(0.0, 0.0, 0.0);\n    vec3 color = vec3(0.0, 0.0, 0.0);\n    vec3 light_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 view_dir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 half_dir = normalize(light_dir + view_dir);\n    float diffuse = max(dot(light_dir, p), 0.0);\n    float specular = pow(max(dot(half_dir, p), 0.0), 16.0);\n    color = vec3(0.0, 0.0, 0.0);\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    float f = 0.0;\n    f += dot( p, vec2( 12.9898, 78.233 ) );\n    f += dot( p, vec2( 43.123, 53.4321 ) );\n    return fract(sin(f)*43758.5453);\n}\n\nfloat", "\n    gl_Position = vec4(p, 0.0, 1.0);\n}\n\nvoid v(vec3 p){\n    gl_Position = vec4(p, 0.0);\n}\n\nvoid v(vec4 p){\n    gl_Position = p;\n}\n\nvoid v(mat4 m){\n    gl_Position = m * vec4(a_position, 1.0);\n}\n\nvoid v(mat3 m){\n    gl_Position = vec4(m * a_position, 1.0);\n}\n\nvoid v(mat2 m){\n    gl_Position = vec4(m * a_position, 0.0, 1.0);\n}\n\nvoid v(float x, float y){\n    gl_Position = vec4(x, y, 0.0, 1.0);\n}\n\nvoid v(float x, float y, float z){\n    gl_Position = vec4(x, y, z, 1.0);\n}\n\nvoid v(float x, float y, float z, float w){\n    gl_Position = vec4(x, y, z, w);\n}\n\nvoid v(float x, float y, float z, float w, float u, float v){\n    gl_Position = vec4(x, y, z, w);\n    gl_PointSize = u;\n    gl_Position.w = v;\n}\n\nvoid v(float x, float y, float z, float w, float u, float v, float r, float g, float b, float a){\n    gl_Position = vec4(x, y, z, w);\n    gl_PointSize = u;\n    gl_Position.w = v;\n    gl_PointSize = r;\n    gl_Position.w = g;\n    gl_Position.w = b;\n    gl_Position.w = a;\n}\n\nvoid v(float x, float y, float z, float w, float u, float v, float r, float g, float b, float a, float s, float t){\n    gl_Position = vec4(x, y", "\n    return (u.x-m.x)*(u.x-m.x)+(u.y-m.y)*(u.y-m.y);\n}\n\nfloat", "\n    return 0.5*length(u-m)+0.5*length(u-m-vec2(1,0));\n}\n\nfloat", "\n    return dot(u, m.xy) + m.z;\n}\n\nfloat", "\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w", "\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w", "\n    return cross(a, b);\n}\n\nvec", "\n    vec3 v0 = A;\n    vec3 v1 = B;\n    vec3 v2 = C;\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 p = warpTriangle(e1, e2, Xi);\n    vec3 wo = normalize(p - v0);\n    w = wo;\n    wPdf = pdfTriangle(e1, e2, Xi);\n}\n\nvoid sampleSphericalHemisphere(in vec3 A, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 wo = sampleSphericalHemisphere(Xi);\n    w = wo;\n    wPdf = pdfSphericalHemisphere(Xi);\n}\n\nvoid sampleCosineHemisphere(in vec3 A, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 wo = sampleCosineHemisphere(Xi);\n    w = wo;\n    wPdf = pdfCosineHemisphere(Xi);\n}\n\nvoid sampleCone(in vec3 A, in vec3 B, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    vec3 v0 = A;\n    vec3 v1 = B;\n    vec3 e1 = v1 - v0;\n    vec2 Xi = vec2(Xi1, Xi2);\n    vec3 p = warpCone(e1, Xi);\n    vec3 wo = normalize(p - v0);\n    w = wo;\n    wPdf = pdfCone(e1, Xi);\n}\n\nvoid", "\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w;\n}\n\nv2 c(v1 U){\n    return v1.x + v1.y + v1.z + v1.w", "\n    float d = length(p);\n    return d;\n}\n\nfloat", "\n    vec4 res = vec4(0.0);\n    res.x = p.x * p.x;\n    res.y = p.y * p.y;\n    res.z = p.z * p.z;\n    res.w = p.x * p.y;\n    return res;\n}\n\nvec", "\n    float t = time*0.01;\n    float t2 = time*0.02;\n    float t3 = time*0.03;\n    float t4 = time*0.04;\n    float t5 = time*0.05;\n    float t6 = time*0.06;\n    float t7 = time*0.07;\n    float t8 = time*0.08;\n    float t9 = time*0.09;\n    float t10 = time*0.1;\n    float t11 = time*0.11;\n    float t12 = time*0.12;\n    float t13 = time*0.13;\n    float t14 = time*0.14;\n    float t15 = time*0.15;\n    float t16 = time*0.16;\n    float t17 = time*0.17;\n    float t18 = time*0.18;\n    float t19 = time*0.19;\n    float t20 = time*0.2;\n    float t21 = time*0.21;\n    float t22 = time*0.22;\n    float t23 = time*0.23;\n    float t24 = time*0.24;\n    float t25 = time*0.25;\n    float t26 = time*0.26;\n    float t27 = time*0.27;\n    float t28 = time*0.28;\n    float t29 = time*0.29;\n    float t30 = time*0.3;\n    float t31 = time*0.31;\n    float t32 = time*0.32;\n    float t33 = time*0.33;\n    float t34 = time*0.34;\n    float t35 = time*0.35;\n    float t36 = time*0.36;\n    float t37 = time*0.37;\n    float t38 =", "\n    float t = 0.0;\n    for(int i = 0; i < 100; i++){\n        vec3 p = o + r * t;\n        float d = map(p);\n        t += d;\n        if(d < 0.001) break;\n    }\n    return t;\n}\n\nfloat", "\n    vec3 rd = lp - ro;\n    float d = length(rd);\n    rd = normalize(rd);\n    float n = k / (d * d);\n    float m = t / (d * d);\n    return n * exp(-m);\n}\n\nfloat", "\n    vec3 p0 = p - vec3(0.0, 0.0, 0.0);\n    vec3 p1 = p - vec3(1.0, 0.0, 0.0);\n    vec3 p2 = p - vec3(0.0, 1.0, 0.0);\n    vec3 p3 = p - vec3(0.0, 0.0, 1.0);\n    vec3 p4 = p - vec3(1.0, 1.0, 0.0);\n    vec3 p5 = p - vec3(1.0, 0.0, 1.0);\n    vec3 p6 = p - vec3(0.0, 1.0, 1.0);\n    vec3 p7 = p - vec3(1.0, 1.0, 1.0);\n\n    float d0 = dot(p0, p0);\n    float d1 = dot(p1, p1);\n    float d2 = dot(p2, p2);\n    float d3 = dot(p3, p3);\n    float d4 = dot(p4, p4);\n    float d5 = dot(p5, p5);\n    float d6 = dot(p6, p6);\n    float d7 = dot(p7, p7);\n\n    float d = min(d0, min(d1, min(d2, min(d3, min(d4, min(d5, min(d6, d7)))))));\n\n    if (d < edge) {\n        edge = d;\n        crv = 0.0;\n    }\n\n    if (d < t) {\n        t = d;\n        crv = 1.0;\n    }\n\n    return t;\n}\n\nfloat", "\n    vec3 p0 = m[0] * p3.x + m[1] * p3.y + m[2] * p3.z + t;\n    vec3 p1 = m[3] * p3.x + m[4] * p3.y + m[5] * p3.z + t;\n    vec3 p2 = m[6] * p3.x + m[7] * p3.y + m[8] * p3.z + t;\n    return vec4(p0, p1, p2);\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    color.r = p.x;\n    color.g = p.y;\n    color.b = 0.0;\n    color.a = 1.0;\n    return color;\n}\n\nvec", "\n    return sin(p.x + p.y + dir) * 0.5 + 0.5;\n}\n\nfloat", "\n    return q.x * cos(dir) + q.y * sin(dir);\n}\n\nfloat", "\n    vec3 v0 = p3 - n[0];\n    vec3 v1 = p3 - n[1];\n    vec3 v2 = p3 - n[2];\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u = 1.0f - v - w;\n    return vec4(u, v, w, 0.0f);\n}\n\nvec", "\n    vec4 qp = q - p;\n    vec4 qr = q - r;\n    vec4 h = cross(qp, qr);\n    float a = dot(qp, h);\n    float b = dot(qr, h);\n    float c = dot(h, h);\n    float d = a*a + b*b - c*0.25;\n    if (d < 0.0) return 0.0;\n    float e = sqrt(d);\n    return -a*b*0.25/e;\n}\n\nfloat", "\n    float d = length(p);\n    return 1.0 - smoothstep(lW, lW+0.01, d);\n}\n\nfloat", "\n    vec2 dp = ddx * ddy;\n    vec2 dp2 = dp * dp;\n    vec2 dp3 = dp2 * dp;\n    vec2 dp4 = dp3 * dp;\n    vec2 dp5 = dp4 * dp;\n    vec2 dp6 = dp5 * dp;\n    vec2 dp7 = dp6 * dp;\n    vec2 dp8 = dp7 * dp;\n    vec2 dp9 = dp8 * dp;\n    vec2 dp10 = dp9 * dp;\n    vec2 dp11 = dp10 * dp;\n    vec2 dp12 = dp11 * dp;\n    vec2 dp13 = dp12 * dp;\n    vec2 dp14 = dp13 * dp;\n    vec2 dp15 = dp14 * dp;\n    vec2 dp16 = dp15 * dp;\n    vec2 dp17 = dp16 * dp;\n    vec2 dp18 = dp17 * dp;\n    vec2 dp19 = dp18 * dp;\n    vec2 dp20 = dp19 * dp;\n    vec2 dp21 = dp20 * dp;\n    vec2 dp22 = dp21 * dp;\n    vec2 dp23 = dp22 * dp;\n    vec2 dp24 = dp23 * dp;\n    vec2 dp25 = dp24 * dp;\n    vec2 dp26 = dp25 * dp;\n    vec2 dp27 = dp26 * dp;\n    vec2 dp28 = dp27 * dp;\n    vec2 dp29 = dp28 * dp;\n    vec2 dp30 = dp", "\n    vec2 d = n - f;\n    float d2 = dot( d, d );\n    if( d2 > EPSILON )\n    {\n        float d3 = sqrt( d2 );\n        float t = ( d.x * f.x + d.y * f.y ) / d3;\n        if( t < 0.0 )\n        {\n            t = 0.0;\n        }\n        else if( t > 1.0 )\n        {\n            t = 1.0;\n        }\n        mr = f + t * d;\n        mg = f + ( t - 1.0 ) * d;\n    }\n    else\n    {\n        mr = f;\n        mg = f;\n    }\n}\n\nvoid main()\n{\n    vec2 f = gl_FragCoord.xy;\n    vec2 mr, mg;\n    closest( f, vec2( 0.0, 0.0 ), mr, mg );\n    vec2 d = mr - f;\n    float d2 = dot( d, d );\n    if( d2 > EPSILON )\n    {\n        float d3 = sqrt( d2 );\n        float t = ( d.x * f.x + d.y * f.y ) / d3;\n        if( t < 0.0 )\n        {\n            t = 0.0;\n        }\n        else if( t > 1.0 )\n        {\n            t = 1.0;\n        }\n        vec2 p = f + t * d;\n        vec2 q = f + ( t - 1.0 ) * d;\n        vec2 r = mix( p, q, 0.5 );\n        vec2 s = mix( mr, mg, 0.5 );\n        float d4 = dot( r - s, r - s );\n        if( d4 > EPSILON )\n        {\n            float d5 = sqrt( d4 );\n            float t2 = ( r.x * s.x + r.y * s.y ) / d5;\n            if( t2 < 0.0 )", "\n\t\treturn lerp(start_pos, end_pos, t);\n\t}\n\t\n\tvec2 lerp_vel(  float t){\n\t\treturn lerp(start_vel, end_vel, t);\n\t}\n\t\n\tvec2 lerp_acc(  float t){\n\t\treturn lerp(start_acc, end_acc, t);\n\t}\n\t\n\tvec2 lerp_jerk(  float t){\n\t\treturn lerp(start_jerk, end_jerk, t);\n\t}\n\t\n\tvec2 lerp_slope(  float t){\n\t\treturn lerp(start_slope, end_slope, t);\n\t}\n\t\n\tvec2 lerp_bias(  float t){\n\t\treturn lerp(start_bias, end_bias, t);\n\t}\n\t\n\tvec2 lerp_damp(  float t){\n\t\treturn lerp(start_damp, end_damp, t);\n\t}\n\t\n\tvec2 lerp_friction(  float t){\n\t\treturn lerp(start_friction, end_friction, t);\n\t}\n\t\n\tvec2 lerp_gravity(  float t){\n\t\treturn lerp(start_gravity, end_gravity, t);\n\t}\n\t\n\tvec2 lerp_friction_bias(  float t){\n\t\treturn lerp(start_friction_bias, end_friction_bias, t);\n\t}\n\t\n\tvec2 lerp_friction_damp(  float t){\n\t\treturn lerp(start_friction_damp, end_friction_damp, t);\n\t}\n\t\n\tvec2 lerp_friction_slope(  float t){\n\t\treturn lerp(start_friction_slope, end_friction_slope, t);\n\t}\n\t\n\tvec2 lerp_friction_bias_slope(  float t){\n\t\treturn lerp(start_friction_bias_slope, end_friction_bias_slope, t);", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat", "\n    return (p0 + p1 + p2) / 3.0;\n}\n\nvec", "\n    float a = p1.x - p0.x;\n    float b = p1.y - p0.y;\n    float c = p2.x - p0.x;\n    float d = p2.y - p0.y;\n    return atan2(a*d-b*c, a*a+b*b);\n}\n\nfloat", "\n    vec2 h12 = h1 - h2;\n    vec2 h13 = h1 - h3;\n    vec2 h23 = h2 - h3;\n    float d12 = length(h12);\n    float d13 = length(h13);\n    float d23 = length(h23);\n    float d123 = d12 + d13 - d23;\n    float d123_ = d123 * 0.5;\n    float d123_2 = d123_ * d123_;\n    float d123_3 = d123_2 * d123_;\n    float d123_4 = d123_3 * d123_;\n    float d123_5 = d123_4 * d123_;\n    float d123_6 = d123_5 * d123_;\n    float d123_7 = d123_6 * d123_;\n    float d123_8 = d123_7 * d123_;\n    float d123_9 = d123_8 * d123_;\n    float d123_10 = d123_9 * d123_;\n    float d123_11 = d123_10 * d123_;\n    float d123_12 = d123_11 * d123_;\n    float d123_13 = d123_12 * d123_;\n    float d123_14 = d123_13 * d123_;\n    float d123_15 = d123_14 * d123_;\n    float d123_16 = d123_15 * d123_;\n    float d123_17 = d123_16 * d123_;\n    float d123_18 = d123_17 * d123", "\n    vec2 q = p - vec2(0.5);\n    vec2 r = vec2(length(q), atan(q.y, q.x));\n    return r;\n}\n\nvoid main() {\n    vec2 p = triangulate(gl_FragCoord.xy);\n    vec2 q = vec2(0.5);\n    vec2 r = vec2(length(p - q), atan(p.y - q.y, p.x - q.x));\n    float d = length(p - q);\n    float a = atan(p.y - q.y, p.x - q.x);\n    float b = atan(p.y, p.x);\n    float c = atan(q.y, q.x);\n    float d1 = abs(a - b);\n    float d2 = abs(a - c);\n    float d3 = abs(b - c);\n    float d4 = abs(a - d);\n    float d5 = abs(b - d);\n    float d6 = abs(c - d);\n    float d7 = abs(a - d1);\n    float d8 = abs(b - d2);\n    float d9 = abs(c - d3);\n    float d10 = abs(a - d4);\n    float d11 = abs(b - d5);\n    float d12 = abs(c - d6);\n    float d13 = abs(a - d7);\n    float d14 = abs(b - d8);\n    float d15 = abs(c - d9);\n    float d16 = abs(a - d10);\n    float d17 = abs(b - d11);\n    float d18 = abs(c - d12);\n    float d19 = abs(a - d13);\n    float d20 = abs(b - d14);\n    float d21 = abs(c - d15);\n    float d22 = abs(a - d16);\n    float d23 = abs(b - d17);\n    float", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return fract(sin(p) * 43758.5453);\n}\n\nfloat", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = 2.0 * dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n    {\n        t = -1.0;\n        return false;\n    }\n    else\n    {\n        float sqrtd = sqrt( discriminant );\n        float root = (-b - sqrtd) / (2.0 * a);\n        if ( root < tmin || tmax < root )\n        {\n            root = (-b + sqrtd) / (2.0 * a);\n            if ( root < tmin || tmax < root )\n            {\n                t = -1.0;\n                return false;\n            }\n        }\n        t = root;\n    }\n    hitPos = ray.origin + t * ray.direction;\n    hitNormal = normalize( hitPos - sph.center );\n    return true;\n}\n\nbool IntersectTriangle( in vec3 p, in vec3 v0, in vec3 v1, in vec3 v2,\n                        out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 h = cross( p - v0, e2 );\n    float a = dot( e1, h );\n    if ( a > -0.0001 && a < 0.0001 )\n        return false;    // This ray is parallel to this triangle.\n    float f = 1.0 / a;\n    vec3 s = p - v0;\n    float u = f * dot( s, h );\n    if ( u < 0.0 || u > 1.0 )\n        return false;\n    vec3 q = cross( s, e1 );\n    float v = f *", "\n    float t0, t1;\n    float a = Dot( ray.dir, ray.dir );\n    float b = 2.0f * Dot( ray.dir, ray.org - sph.center );\n    float c = Dot( ray.org - sph.center, ray.org - sph.center ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0f * a * c;\n    if ( discriminant < 0.0f )\n        return false;\n    else\n    {\n        discriminant = sqrtf( discriminant );\n        t0 = ( -b - discriminant ) / ( 2.0f * a );\n        t1 = ( -b + discriminant ) / ( 2.0f * a );\n        if ( t0 > t1 )\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        if ( t0 < tmin )\n            t0 = tmin;\n        if ( t1 > tmax )\n            t1 = tmax;\n        if ( t0 > t1 )\n            return false;\n        else\n            return true;\n    }\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax )\n{\n    float t0, t1;\n    float a = tri.v0.x - tri.v1.x;\n    float b = tri.v0.y - tri.v1.y;\n    float c = tri.v0.z - tri.v1.z;\n    float d = tri.v0.x - tri.v2.x;\n    float e = tri.v0.y - tri.v2.y;\n    float f = tri.v0.z - tri.v2.z;\n    float g = ray.dir.x;\n    float h = ray.dir.y;\n    float i = ray.dir.z;\n    float j = tri.v0.x - ray.org.x;\n    float k = tri.v0", "\n    vec3 k_rg_min = vec3( 0.0 );\n    vec3 k_rg_max = vec3( 0.0 );\n    vec3 k_rg_min_t = vec3( 0.0 );\n    vec3 k_rg_max_t = vec3( 0.0 );\n    vec3 k_rg_min_t_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg", "\n    vec2 p = p0;\n    vec2 dp = p1 - p0;\n    vec2 dp2 = p2 - p1;\n    float t = clamp(dot(p, dp2) / dot(dp, dp2), 0.0, 1.0);\n    return vec4(mix(p0, p1, t), 0.0, 1.0);\n}\n\nvec", "\n    vec3 min = vec3( min( p0.x, min( p1.x, p2.x ) ), min( p0.y, min( p1.y, p2.y ) ), min( p0.z, min( p1.z, p2.z ) ) );\n    vec3 max = vec3( max( p0.x, max( p1.x, p2.x ) ), max( p0.y, max( p1.y, p2.y ) ), max( p0.z, max( p1.z, p2.z ) ) );\n    return BezierAABB( min, max );\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    return k * k * (3 - 2 * k);\n}\n\nfloat", "\n    return fract(sin(dot(v, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return (coord - res / 2.0f) / res;\n}\n\nvec", "\n    vec2 q = p - vec2( 0.5 );\n    float r = length( q );\n    return 0.5 * ( 1.0 - step( r, 0.5 ) );\n}\n\nvoid main()\n{\n    vec2 p = ( gl_FragCoord.xy / resolution.xy ) - 0.5;\n    float t = time * 0.05;\n    float d = checkersGradBox( p );\n    float d2 = checkersGradBox( p + vec2( 0.0, 0.001 ) );\n    float d3 = checkersGradBox( p + vec2( 0.0, 0.002 ) );\n    float d4 = checkersGradBox( p + vec2( 0.0, 0.003 ) );\n    float d5 = checkersGradBox( p + vec2( 0.0, 0.004 ) );\n    float d6 = checkersGradBox( p + vec2( 0.0, 0.005 ) );\n    float d7 = checkersGradBox( p + vec2( 0.0, 0.006 ) );\n    float d8 = checkersGradBox( p + vec2( 0.0, 0.007 ) );\n    float d9 = checkersGradBox( p + vec2( 0.0, 0.008 ) );\n    float d10 = checkersGradBox( p + vec2( 0.0, 0.009 ) );\n    float d11 = checkersGradBox( p + vec2( 0.0, 0.010 ) );\n    float d12 = checkersGradBox( p + vec2( 0.0, 0.011 ) );\n    float d13 = checkersGradBox( p + vec2( 0.0, 0.012 ) );\n    float d14 = checkersGradBox( p + vec2( 0.0, 0.013 ) );\n    float d1", "\n    return vec3(\n        dot(rgb, vec3(0.2126, 0.7152, 0.0722)),\n        dot(rgb, vec3(0.2126, 0.2990, 0.5343)),\n        dot(rgb, vec3(0.0722, 0.5343, 0.2126))\n    );\n}\n\nvec", "\n    return fract(sin(p)*43758.5453);\n}\n\nfloat", "\n    vec3 e = vec3( 0.00392, 0.00195, 0.00077 );\n    return normalize( e.zyx * dot( e, p ) + e );\n}\n\nvoid main()\n{\n    vec3 p = ( gl_FragCoord.xyz / vec3( iResolution.xyz ) - 0.5 ) * 2.0;\n    vec3 ro = vec3( 0.0, 0.0, 1.0 );\n    vec3 rd = normalize( p.xyz );\n\n    vec3 col = vec3( 0.0 );\n\n    vec3 lightDir = normalize( vec3( 0.0, 0.0, 1.0 ) );\n    vec3 lightColor = vec3( 1.0 );\n\n    float intensity = 0.0;\n    float attenuation = 1.0;\n\n    for ( int i = 0; i < 10; i++ )\n    {\n        vec3 h = normalize( lightDir + rd );\n        float nh = max( 0.0, dot( h, normal( p ) ) );\n        float diffuse = max( 0.0, dot( lightDir, normal( p ) ) );\n        float specular = pow( nh, 10.0 );\n        intensity = diffuse + specular;\n        col += lightColor * intensity * attenuation;\n        attenuation *= 0.5;\n        p += rd * 0.01;\n    }\n\n    col = pow( col, vec3( 0.4545 ) );\n\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    return dot( q, ivec2( 127.1, 311.7 ) );\n}\n\nfloat", "\n    float x = pos.x;\n    float y = pos.y;\n    float r = radius;\n    float w = width;\n    float h = r * 2;\n    float d = r * 0.5;\n    float a = PI / 4;\n    float b = PI / 2;\n    float c = PI;\n    float s = sin(a);\n    float c = cos(a);\n    float t = sin(b);\n    float u = cos(b);\n    float v = sin(c);\n    float w = cos(c);\n    float x1 = x + r * c;\n    float y1 = y + r * s;\n    float x2 = x + r * c;\n    float y2 = y - r * s;\n    float x3 = x - r * c;\n    float y3 = y - r * s;\n    float x4 = x - r * c;\n    float y4 = y + r * s;\n    float x5 = x + r * c;\n    float y5 = y + r * s;\n    float x6 = x + r * c;\n    float y6 = y - r * s;\n    float x7 = x - r * c;\n    float y7 = y - r * s;\n    float x8 = x - r * c;\n    float y8 = y + r * s;\n    float x9 = x + r * c;\n    float y9 = y + r * s;\n    float x10 = x + r * c;\n    float y10 = y - r * s;\n    float x11 = x - r * c;\n    float y11 = y - r * s;\n    float x12 = x - r * c;\n    float y12 = y + r * s;\n    float x13 = x + r * c;\n    float y13 = y + r * s;\n    float x14 = x + r * c;\n    float y14 = y - r * s;\n    float x15 = x - r * c;\n    float y15 = y - r * s;\n   ", "\n    return fract(sin(dot(v, vec2(127.1, 311.7))) * 43758.5453);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    return fract(sin(dot(p,vec3(127.1,311.7, 72.5)))*43758.5453);\n}\n\nfloat", "\n    sp = p;\n    tp = p;\n    rp = p;\n    mul = 1.0;\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in float t)\n{\n    sp = p;\n    tp = p;\n    rp = p;\n    mul = t;\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t)\n{\n    sp = p;\n    tp = p + t;\n    rp = p;\n    mul = length(t);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in float tt)\n{\n    sp = p;\n    tp = p + t * tt;\n    rp = p;\n    mul = length(t * tt);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in vec3 tt)\n{\n    sp = p;\n    tp = p + t * tt;\n    rp = p;\n    mul = length(t * tt);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in vec3 tt, in float ttt)\n{\n    sp = p;\n    tp = p + t * tt * ttt;\n    rp = p;\n    mul = length(t * tt * ttt);\n}\n\nvoid tile(in vec3 p, out vec3 sp, out vec3 tp, out vec3 rp, out float mul, in vec3 t, in vec3 tt, in vec3 t", "\n    return vec2(\n        abs(p.x) - 1.0,\n        abs(p.y) - 1.0\n    );\n}\n\nvec", "\n    return (vec2){z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x};\n}\n\nvec", "\n    vec2 p0 = p;\n    vec2 p1 = p + vec2(aaSize, 0.0);\n    vec2 p2 = p + vec2(aaSize, aaSize);\n    vec2 p3 = p + vec2(0.0, aaSize);\n    vec2 p4 = p + vec2(aaSize, aaSize);\n    vec2 p5 = p + vec2(aaSize, 0.0);\n    vec2 p6 = p + vec2(0.0, aaSize);\n    vec2 p7 = p + vec2(0.0, 0.0);\n\n    vec2 p8 = p + vec2(aaSize, aaSize);\n    vec2 p9 = p + vec2(aaSize, 0.0);\n    vec2 p10 = p + vec2(0.0, aaSize);\n    vec2 p11 = p + vec2(0.0, 0.0);\n\n    vec2 p12 = p + vec2(aaSize, aaSize);\n    vec2 p13 = p + vec2(aaSize, 0.0);\n    vec2 p14 = p + vec2(0.0, aaSize);\n    vec2 p15 = p + vec2(0.0, 0.0);\n\n    vec2 p16 = p + vec2(aaSize, aaSize);\n    vec2 p17 = p + vec2(aaSize, 0.0);\n    vec2 p18 = p + vec2(0.0, aaSize);\n    vec2 p19 = p + vec2(0.0, 0.0);\n\n    vec2 p20 = p + vec2(aaSize, aaSize);\n    vec2 p21 = p + vec2(aaSize, 0.0);\n    vec2 p22 = p + vec2(0.0, aaSize);\n    ve", "\n    vec2 box = vec2(1.0);\n    box.x = abs(pos.x) - 0.5;\n    box.y = abs(pos.y) - 0.5;\n    return box;\n}\n\nvec", "\n    return vec2(\n        (pos.x + 1.0) * 0.5,\n        (pos.y + 1.0) * 0.5\n    );\n}\n\nvec", "\n    return vec2(pos.x / pos.z, pos.y / pos.z);\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    vec3 rayDir = normalize(camDir + lightDir);\n    vec3 rayOrigin = camPos;\n    float t = 0.0;\n    float tMax = 1000.0;\n    float tMin = 0.001;\n    float tDelta = 0.001;\n    float tDeltaMax = 0.001;\n    float tDeltaMin = 0.001;\n    float tDeltaMax2 = 0.001;\n    float tDeltaMin2 = 0.001;\n    float tDeltaMax3 = 0.001;\n    float tDeltaMin3 = 0.001;\n    float tDeltaMax4 = 0.001;\n    float tDeltaMin4 = 0.001;\n    float tDeltaMax5 = 0.001;\n    float tDeltaMin5 = 0.001;\n    float tDeltaMax6 = 0.001;\n    float tDeltaMin6 = 0.001;\n    float tDeltaMax7 = 0.001;\n    float tDeltaMin7 = 0.001;\n    float tDeltaMax8 = 0.001;\n    float tDeltaMin8 = 0.001;\n    float tDeltaMax9 = 0.001;\n    float tDeltaMin9 = 0.001;\n    float tDeltaMax10 = 0.001;\n    float tDeltaMin10 = 0.001;\n    float tDeltaMax11 = 0.001;\n    float tDeltaMin11 = 0.001;\n    float tDeltaMax12 = 0.001;\n    float tDeltaMin12 = 0.001;\n    float tDeltaMax13 = 0.001;\n    float tDeltaMin13 = 0.001;\n    float tDeltaMax14 = 0.001;\n    float tDeltaMin14 = 0.001;\n    float tDeltaMax15 = 0.001;\n    float tDeltaMin15", "\n    vec2 iRes = vec2(0.0);\n    vec2 fRes = vec2(0.0);\n    vec2 tRes = vec2(0.0);\n    vec2 gRes = vec2(0.0);\n    vec2 bRes = vec2(0.0);\n    vec2 dRes = vec2(0.0);\n    vec2 sRes = vec2(0.0);\n    vec2 cRes = vec2(0.0);\n    vec2 eRes = vec2(0.0);\n    vec2 pRes = vec2(0.0);\n    vec2 nRes = vec2(0.0);\n    vec2 hRes = vec2(0.0);\n    vec2 jRes = vec2(0.0);\n    vec2 kRes = vec2(0.0);\n    vec2 lRes = vec2(0.0);\n    vec2 mRes = vec2(0.0);\n    vec2 oRes = vec2(0.0);\n    vec2 qRes = vec2(0.0);\n    vec2 rRes = vec2(0.0);\n    vec2 tRes2 = vec2(0.0);\n    vec2 uRes = vec2(0.0);\n    vec2 vRes = vec2(0.0);\n    vec2 wRes = vec2(0.0);\n    vec2 xRes = vec2(0.0);\n    vec2 yRes = vec2(0.0);\n    vec2 zRes = vec2(0.0);\n    vec2 aRes = vec2(0.0);\n    vec2 bRes2 = vec2(0.0);\n    vec2 cRes2 = vec2(0.0);\n    vec2 dRes2 = vec2(0.0);\n    vec2 eRes2 = vec2(0.0);\n    vec2 fRes2 = vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return dot(plane.normal, pos - plane.position);\n}\n\nfloat", "\n    vec3 p = fract(fx);\n    p = p*p*(3.0-2.0*p);\n    return mix(mix(mix(dot(ix,ivec3(1,1,1)),ix.yzx,p.x),\n                  mix(ix.xz,ix.yx,p.x),p.y),\n               mix(mix(ix.zy,ix.yz,p.x),\n                   mix(ix.zx,ix.xy,p.x),p.y),p.z);\n}\n\nfloat", "\n    vec3 fxyz2 = fxyz*fxyz;\n    vec3 fxyz3 = fxyz2*fxyz;\n    vec3 fxyz4 = fxyz3*fxyz;\n    vec3 fxyz5 = fxyz4*fxyz;\n    vec3 fxyz6 = fxyz5*fxyz;\n    vec3 fxyz7 = fxyz6*fxyz;\n    vec3 fxyz8 = fxyz7*fxyz;\n    vec3 fxyz9 = fxyz8*fxyz;\n    vec3 fxyz10 = fxyz9*fxyz;\n    vec3 fxyz11 = fxyz10*fxyz;\n    vec3 fxyz12 = fxyz11*fxyz;\n    vec3 fxyz13 = fxyz12*fxyz;\n    vec3 fxyz14 = fxyz13*fxyz;\n    vec3 fxyz15 = fxyz14*fxyz;\n    vec3 fxyz16 = fxyz15*fxyz;\n    vec3 fxyz17 = fxyz16*fxyz;\n    vec3 fxyz18 = fxyz17*fxyz;\n    vec3 fxyz19 = fxyz18*fxyz;\n    vec3 fxyz20 = fxyz19*fxyz;\n    vec3 fxyz21 = fxyz20*fxyz;\n    vec3 fxyz22 = fxyz21*fxyz;\n    vec3 fxyz23 = fxyz22*fxyz;\n    vec3 fxyz24 = fxyz23*fxyz;\n    vec3 fxyz25 = fxyz24*fxyz;\n    vec3 fxyz26 = fxyz25*fxyz;\n    vec3", "\n    vec3 q = vec3( length(p.xz) - r, p.y );\n    return length(max(abs(q)-vec2(h,0.5),0.0)) - 0.5;\n}\n\nfloat", "\n    float d = sdf(p);\n    return d;\n}\n\nfloat", "\n    return normalize(cross(get_edge(p, 0), get_edge(p, 1)));\n}\n\nvec", "\n    return max(0.0,dot(n,l)*d);\n}\n\nfloat", "\n    float t0 = 0.0;\n    float t1 = 1000000.0;\n    float tmin = 0.001;\n    float tmax = 1000000.0;\n    float t = tmin;\n    float tmin2 = 0.001;\n    float tmax2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min = 0.001;\n    float t2max = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n    float t2 = tmin2;\n    float t2min2 = 0.001;\n    float t2max2 = 1000000.0;\n   ", "\n    vec2 dp = dpdx * dpdy;\n    vec2 dp2 = dp * dp;\n    float dp2x = dp2.x;\n    float dp2y = dp2.y;\n    float dp2xy = dp2x * dp2y;\n    float dp2x2 = dp2x * dp2x;\n    float dp2y2 = dp2y * dp2y;\n    float dp2xy2 = dp2x2 * dp2y2;\n    float dp2xy3 = dp2xy * 3.0;\n    float dp2xy4 = dp2xy2 * 4.0;\n    float dp2xy5 = dp2xy3 * 5.0;\n    float dp2xy6 = dp2xy4 * 6.0;\n    float dp2xy7 = dp2xy5 * 7.0;\n    float dp2xy8 = dp2xy6 * 8.0;\n    float dp2xy9 = dp2xy7 * 9.0;\n    float dp2xy10 = dp2xy8 * 10.0;\n    float dp2xy11 = dp2xy9 * 11.0;\n    float dp2xy12 = dp2xy10 * 12.0;\n    float dp2xy13 = dp2xy11 * 13.0;\n    float dp2xy14 = dp2xy12 * 14.0;\n    float dp2xy15 = dp2xy13 * 15.0;\n    float dp2xy16 = dp2xy14 * 16.0;\n    float dp2xy17 = dp2xy15 * 17.0;\n    float dp2xy18 = dp2xy16 * 18.0;\n    float dp2xy19 = dp2xy17 * 19.0;\n    float dp2xy20", "\n    // Initialize the scene\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n    glEnable(GL_DEPTH_TEST);\n    glEnable(GL_CULL_FACE);\n    glCullFace(GL_BACK);\n    glFrontFace(GL_CCW);\n}\n\nvoid DrawScene()\n{\n    // Draw the scene\n    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n    // Draw the scene\n    glBegin(GL_TRIANGLES);\n    glColor3f(1.0f, 0.0f, 0.0f);\n    glVertex3f(-0.5f, -0.5f, 0.0f);\n    glColor3f(0.0f, 1.0f, 0.0f);\n    glVertex3f(0.5f, -0.5f, 0.0f);\n    glColor3f(0.0f, 0.0f, 1.0f);\n    glVertex3f(0.0f, 0.5f, 0.0f);\n    glEnd();\n}\n\nvoid Reshape(int w, int h)\n{\n    // Reshape the scene\n    glViewport(0, 0, w, h);\n    glMatrixMode(GL_PROJECTION);\n    glLoadIdentity();\n    gluPerspective(45.0f, (float)w / (float)h, 0.1f, 100.0f);\n    glMatrixMode(GL_MODELVIEW);\n    glLoadIdentity();\n}\n\nvoid Keyboard(unsigned char key, int x, int y)\n{\n    // Handle keyboard input\n    switch (key)\n    {\n    case 27:\n        exit(0);\n        break;\n    }\n}\n\nvoid Mouse(int button, int state, int x, int y)\n{\n    // Handle mouse input\n    switch (button)\n    {\n    case GLUT_LEFT_BUTTON", "\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = 2.0 * dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n    {\n        t = -1.0;\n        return false;\n    }\n    else\n    {\n        float sqrtd = sqrt( discriminant );\n        float root = (-b - sqrtd) / (2.0 * a);\n        if ( root < tmin || tmax < root )\n        {\n            root = (-b + sqrtd) / (2.0 * a);\n            if ( root < tmin || tmax < root )\n            {\n                t = -1.0;\n                return false;\n            }\n        }\n        t = root;\n    }\n    hitPos = ray.origin + t * ray.direction;\n    hitNormal = normalize( hitPos - sph.center );\n    return true;\n}\n\nbool IntersectTriangle( in vec3 p, in vec3 v0, in vec3 v1, in vec3 v2,\n                        out float t, out vec3 hitPos, out vec3 hitNormal )\n{\n    vec3 e1 = v1 - v0;\n    vec3 e2 = v2 - v0;\n    vec3 h = cross( p - v0, e2 );\n    float a = dot( e1, h );\n    if ( a > -0.0001 && a < 0.0001 )\n        return false;    // This ray is parallel to this triangle.\n    float f = 1.0 / a;\n    vec3 s = p - v0;\n    float u = f * dot( s, h );\n    if ( u < 0.0 || u > 1.0 )\n        return false;\n    vec3 q = cross( s, e1 );\n    float v = f *", "\n    float t0, t1;\n    float a = Dot( ray.dir, ray.dir );\n    float b = 2.0f * Dot( ray.dir, ray.org - sph.center );\n    float c = Dot( ray.org - sph.center, ray.org - sph.center ) - sph.radius * sph.radius;\n    float discriminant = b * b - 4.0f * a * c;\n    if ( discriminant < 0.0f )\n        return false;\n    else\n    {\n        discriminant = sqrtf( discriminant );\n        t0 = ( -b - discriminant ) / ( 2.0f * a );\n        t1 = ( -b + discriminant ) / ( 2.0f * a );\n        if ( t0 > t1 )\n        {\n            float temp = t0;\n            t0 = t1;\n            t1 = temp;\n        }\n        if ( t0 < tmin )\n            t0 = tmin;\n        if ( t1 > tmax )\n            t1 = tmax;\n        if ( t0 > t1 )\n            return false;\n        else\n            return true;\n    }\n}\n\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax )\n{\n    float t0, t1;\n    float a = tri.v0.x - tri.v1.x;\n    float b = tri.v0.y - tri.v1.y;\n    float c = tri.v0.z - tri.v1.z;\n    float d = tri.v0.x - tri.v2.x;\n    float e = tri.v0.y - tri.v2.y;\n    float f = tri.v0.z - tri.v2.z;\n    float g = ray.dir.x;\n    float h = ray.dir.y;\n    float i = ray.dir.z;\n    float j = tri.v0.x - ray.org.x;\n    float k = tri.v0", "\n    vec3 k_rg_min = vec3( 0.0 );\n    vec3 k_rg_max = vec3( 0.0 );\n    vec3 k_rg_min_t = vec3( 0.0 );\n    vec3 k_rg_max_t = vec3( 0.0 );\n    vec3 k_rg_min_t_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_min_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg_max_t_inv_inv_inv_inv_inv_inv_inv = vec3( 0.0 );\n    vec3 k_rg", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nvoid main()\n{\n    vec3 ro = camera.position;\n    vec3 rd = normalize( camera.direction + camera.right * uv.x + camera.up * uv.y );\n\n    vec3 col = vec3( 0.0 );\n    vec3 light = vec3( 0.0 );\n\n    vec3 p = ro + rd * 10.0;\n    vec3 n = normalize( vec3( 0.0, 1.0, 0.0 ) );\n    float t = map( p, 0.0, 100.0 );\n    p = ro + rd * t;\n    float d = map( p, 0.0, 100.0 );\n    float s = calcSoftshadow( p, rd, 0.0, 10.0 );\n    col = vec3( 0.0, 0.0, 0.0 );\n    if( d < 10.0 )\n    {\n        col = vec3( 0.0, 0.0, 0.0 );\n        light = vec3( 0.0, 0.0, 0.0 );\n    }\n    else\n    {\n        col = vec3( 0.0, 0.0, 0.0 );\n        light = vec3( 0.0, 0.0, 0.0 );\n    }\n\n    gl_FragColor = vec4( col, 1.0 );\n}\n", "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n\n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nvec", "\n\tvec3 color = vec3(0.0);\n\tvec3 ray_dir = normalize(dir);\n\tvec3 ray_start = start;\n\tvec3 ray_end = ray_start + ray_dir * max_dist;\n\tvec3 ray_color = vec3(0.0);\n\tvec3 ray_end_color = vec3(0.0);\n\tvec3 ray_end_color_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n\tvec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_", "\n    vec3 light_col = vec3(0.0);\n    vec3 light_dir_norm = normalize(light_dir);\n    float light_dist = length(light_dir);\n    float attenuation = 1.0 / (light_dist * light_dist);\n    float diffuse_strength = max(0.0, dot(surface_normal, light_dir_norm));\n    vec3 diffuse_col = vec3(0.0);\n    if (diffuse_strength > 0.0) {\n        diffuse_col = vec3(1.0, 1.0, 1.0) * diffuse_strength * attenuation;\n    }\n    vec3 view_dir = normalize(sample_pos - camera_pos);\n    vec3 reflect_dir = reflect(-light_dir_norm, surface_normal);\n    float specular_strength = pow(max(0.0, dot(view_dir, reflect_dir)), 32.0);\n    vec3 specular_col = vec3(0.0);\n    if (specular_strength > 0.0) {\n        specular_col = vec3(1.0, 1.0, 1.0) * specular_strength * attenuation;\n    }\n    light_col = diffuse_col + specular_col;\n    return light_col;\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 ambient_color = vec3(0.1);\n    vec3 diffuse_color = vec3(0.5);\n    vec3 specular_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_specular_color = vec3(1.0);\n\n    vec3 light_pos = vec3(0.0, 0.0, 0.0);\n    vec3 light_ambient_color = vec3(0.1);\n    vec3 light_diffuse_color = vec3(0.5);\n    vec3 light_spec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = uv - 0.5;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.5) * 2.0;\n    float t = mod(iTime, 1.0);\n    float s = sin(t * 3.14159265359);\n    float c = cos(t * 3.14159265359);\n    float aa = a * 0.5 + 0.5;\n    float rr = r * 0.5 + 0.5;\n    float aa2 = aa * 0.5 + 0.5;\n    float rr2 = rr * 0.5 + 0.5;\n    float aa3 = aa * 0.5 + 0.5;\n    float rr3 = rr * 0.5 + 0.5;\n    float aa4 = aa * 0.5 + 0.5;\n    float rr4 = rr * 0.5 + 0.5;\n    float aa5 = aa * 0.5 + 0.5;\n    float rr5 = rr * 0.5 + 0.5;\n    float aa6 = aa * 0.5 + 0.5;\n    float rr6 = rr * 0.5 + 0.5;\n    float aa7 = aa * 0.5 + 0.5;\n    float rr7 = rr * 0.5 + 0.5;\n    float aa8 = aa * 0.5 + 0.5;\n    float rr8 = rr * 0.5 + 0.5;\n    float aa9 = aa * 0.5 + 0.5;\n    float rr9 = rr * 0.5 + 0.5;\n    float aa10 = aa * 0.5 + 0.5;\n    float rr10 = rr * ", "\n    vec3 oc = r0 - s0;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sr * sr;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightIntensity = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightSpotDir = vec3(0.0);\n    vec3 lightSpotColor = vec3(0.0);\n    vec3 lightSpotIntensity = vec3(0.0);\n    vec3 lightSpotAttenuation = vec3(0.0);\n    vec3 lightSpotDir2 = vec3(0.0);\n    vec3 lightSpotColor2 = vec3(0.0);\n    vec3 lightSpotIntensity2 = vec3(0.0);\n    vec3 lightSpotAttenuation2 = vec3(0.0);\n    vec3 lightSpotDir3 = vec3(0.0);\n    vec3 lightSpotColor3 = vec3(0.0);\n    vec3 lightSpotIntensity3 = vec3(0.0);\n    vec3 lightSpotAttenuation3 = vec3(0.0);\n    vec3 lightSpotDir4 = vec3(0.0);\n    vec3 lightSpotColor4 = vec3(0.0);\n    vec3 lightSpotIntensity4 = vec3(0.0);\n    vec3 lightSpotAttenuation4 = vec3(0.0);\n    vec3 lightSpotDir5 = vec3(0.0);\n    vec3 lightSpotColor5 = vec3(0.0);\n    vec3 lightSpotIntensity5 = vec3(0.0);\n    vec3 lightSpotAttenuation5 = vec3(0.0);\n    vec3 lightSpotDir6 = vec3(0.0);\n    vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    float t = 0.0;\n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        vec3 intersection = ray_origin + t * ray_direction;\n        float distance = length(intersection - ray_origin);\n        if (distance < EPSILON) {\n            return intersection;\n        }\n        t += distance;\n    }\n    return vec3(0.0);\n}\n\nvec", "\n    vec3 c = vec3(0.0);\n    float t = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 5; i++){\n        t += a;\n        a *= 0.5;\n        c += jigsaw_noise(p * t) * a;\n    }\n    return c;\n}\n\nvoid main()\n{\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    vec3 color = vec3(0.0);\n    vec2 p = st;\n    float t = 0.0;\n    float a = 1.0;\n    for(int i = 0; i < 5; i++){\n        t += a;\n        a *= 0.5;\n        color += jigsaw_noise(p * t) * a;\n    }\n    gl_FragColor = vec4(color, 1.0);\n}", "\n    return sqrt(pow(p.x, 2) + pow(p.y, 2) + pow(p.z, 2));\n}\n\nvec", "\n    vec3 Pi = floor( P );\n    vec3 Pf = fract( P );\n    vec3 Px = Pf.x + vec3( 1.0, 0.0, 1.0 );\n    vec3 Py = Pf.y + vec3( 1.0, 1.0, 0.0 );\n    vec3 Pz = Pf.z + vec3( 0.0, 1.0, 1.0 );\n    vec3 Pw = Pf.z + vec3( 1.0, 0.0, 1.0 );\n    vec3 Pn = Pf.z + vec3( -1.0, 0.0, 1.0 );\n    vec3 Pt = Pf.z + vec3( 1.0, -1.0, 0.0 );\n    vec3 Pb = Pf.z + vec3( -1.0, -1.0, 0.0 );\n    vec3 Pq = Pf.z + vec3( 1.0, 1.0, -1.0 );\n    vec3 Pr = Pf.z + vec3( -1.0, 1.0, -1.0 );\n    vec3 Pu = Pf.z + vec3( 1.0, -1.0, -1.0 );\n    vec3 Pv = Pf.z + vec3( -1.0, 1.0, -1.0 );\n    vec4 Pi0 = texture( iChannel0, Pi );\n    vec4 Pi1 = texture( iChannel0, Pi + vec3( 1.0, 0.0, 0.0 ) );\n    vec4 Pi2 = texture( iChannel0, Pi + vec3( 0.0, 1.0, 0.0 ) );\n    vec4 Pi3 = texture( iChannel0, Pi + vec3( 1.0, 1.0, 0.0 ) );\n    vec4 Pi4 = texture( iChannel0, Pi +", "\n    return fract(sin(x)*43758.5453);\n}\n\nfloat", "\n    return p * 0.5 + 0.5;\n}\n\nvec", "\n    return p * 0.5 + 0.5;\n}\n\nvec", "\n    float t = (p.x - a.x) / (b.x - a.x);\n    if (t < 0.0) return d;\n    if (t > 1.0) return d;\n    return mix(d, 0.0, 1.0 - t);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return texture2D(tex, p).r;\n}\n\nvoid main(){\n    vec2 p = (gl_FragCoord.xy / resolution.xy);\n    vec2 p2 = p * 2.0 - 1.0;\n    vec2 p3 = p2 * 2.0 - 1.0;\n    vec2 p4 = p3 * 2.0 - 1.0;\n    vec2 p5 = p4 * 2.0 - 1.0;\n    vec2 p6 = p5 * 2.0 - 1.0;\n    vec2 p7 = p6 * 2.0 - 1.0;\n    vec2 p8 = p7 * 2.0 - 1.0;\n    vec2 p9 = p8 * 2.0 - 1.0;\n    vec2 p10 = p9 * 2.0 - 1.0;\n    vec2 p11 = p10 * 2.0 - 1.0;\n    vec2 p12 = p11 * 2.0 - 1.0;\n    vec2 p13 = p12 * 2.0 - 1.0;\n    vec2 p14 = p13 * 2.0 - 1.0;\n    vec2 p15 = p14 * 2.0 - 1.0;\n    vec2 p16 = p15 * 2.0 - 1.0;\n    vec2 p17 = p16 * 2.0 - 1.0;\n    vec2 p18 = p17 * 2.0 - 1.0;\n    vec2 p19 = p18 * 2.0 - 1.0;\n    vec2 p20 = p19 * 2.0 - 1.0;\n    vec2 p21 = p20 * 2.0 - 1.0;\n    vec2 p22 = p21 * 2.0 - 1.0;\n    vec2 p", "\n    return (1.0 - cos(2.0 * PI * ix)) * (1.0 - cos(2.0 * PI * iy));\n}\n\nfloat", "\n    vec3 color = vec3( 0.0 );\n    vec3 pos = p;\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float d = map( pos );\n        t += d;\n        pos = p + d * normal( p );\n        if ( t > tmax )\n        {\n            break;\n        }\n    }\n    color = vec3( 0.5 ) + vec3( 0.5 ) * cos( 10.0 * t );\n    return color;\n}\n\nvoid main()\n{\n    vec3 color = vec3( 0.0 );\n    vec3 p = vec3( 0.0 );\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float d = map( p );\n        t += d;\n        p = p + d * normal( p );\n        if ( t > tmax )\n        {\n            break;\n        }\n    }\n    color = vec3( 0.5 ) + vec3( 0.5 ) * cos( 10.0 * t );\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    return 1.0 - smoothstep(0.0, 1.0, p);\n}\n\nfloat", "\n    return vec2(\n        atan(z.y, z.x),\n        sqrt(z.x * z.x + z.y * z.y)\n    );\n}\n\nvec", "\n    return (vec2){z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x};\n}\n\nvec", "\n    return dot(p, vec3(127.1, 311.7, 723.5));\n}\n\nfloat", "\n    float wave = sin( p.x * 0.01 + p.y * 0.01 + p.z * 0.01 ) * 0.5 + 0.5;\n    return wave;\n}\n\nvoid main()\n{\n    vec3 p = vec3( gl_FragCoord.xy, 0.0 );\n    vec3 color = vec3( 0.0 );\n    float wave = waveDisplacement( p );\n    color = vec3( wave );\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    float a = atan( p.y, p.x ) / PI;\n    float r = length( p );\n    float h = map( r );\n    return vec3( a, h, r );\n}\n\nvec", "\n    float t = dot(rp, rp) - 1.0;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n    float t4", "\n    return (d - start) / (end - start);\n}\n\nfloat", "\n    vec4 color = vec4(0.0);\n    color.r = p.x;\n    color.g = p.y;\n    color.b = 0.0;\n    color.a = 1.0;\n    return color;\n}\n\nvec", "\n    return vec2(p.x*p.x,p.y*p.y);\n}\n\nvec", "\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);\n\n\t\t\t  // Compute the position of the pixel in the texture\n\t\t\t  vec2 uv = fragCoord.xy / iResolution.xy;\n\n\t\t\t  // Compute the color of the pixel\n\t\t\t  vec3 color = vec3(0.0);", "\n    float x = pc.x;\n    float y = pc.y;\n    float r = sqrt(x*x + y*y);\n    float theta = atan2(y,x);\n    float d = (r - a) / (b - a);\n    if(d > 1) return 0;\n    if(d < 0) return 0;\n    return 1;\n}\n\nfloat", "\n    return smoothstep(0.0, 1.0, abs(st.x - pct));\n}\n\nvoid main() {\n    vec2 st = gl_FragCoord.xy/u_resolution.xy;\n    st.x *= u_resolution.x/u_resolution.y;\n\n    vec3 color = vec3(0.0);\n\n    float pct = plot(st, 0.0);\n    color = mix(vec3(1.0), vec3(0.0), pct);\n\n    gl_FragColor = vec4(color, 1.0);\n}\n", "\n    return vec3(0.0, 0.0, 0.0);\n}\n\nvec", "\n    vec2 q = p - circ.xy;\n    float r = circ.z;\n    return vec2(\n        r * q.x * (1.0 - q.y * q.y) + circ.x,\n        r * q.y * (1.0 - q.x * q.x) + circ.y\n    );\n}\n\nvoid main() {\n    vec2 p = (gl_FragCoord.xy / resolution.xy) - vec2(0.5);\n    vec2 q = p * 2.0;\n    vec2 r = vec2(0.0);\n    vec2 s = vec2(0.0);\n    vec2 t = vec2(0.0);\n    vec2 u = vec2(0.0);\n    vec2 v = vec2(0.0);\n    vec2 w = vec2(0.0);\n    vec2 x = vec2(0.0);\n    vec2 y = vec2(0.0);\n    vec2 z = vec2(0.0);\n    vec2 a = vec2(0.0);\n    vec2 b = vec2(0.0);\n    vec2 c = vec2(0.0);\n    vec2 d = vec2(0.0);\n    vec2 e = vec2(0.0);\n    vec2 f = vec2(0.0);\n    vec2 g = vec2(0.0);\n    vec2 h = vec2(0.0);\n    vec2 i = vec2(0.0);\n    vec2 j = vec2(0.0);\n    vec2 k = vec2(0.0);\n    vec2 l = vec2(0.0);\n    vec2 m = vec2(0.0);\n    vec2 n = vec2(0.0);\n    vec2 o = vec2(0.0);\n    vec2 p0 = vec2(0.0);\n", "\n    return vec2(p.x, 1.0 - p.y);\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 view = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    vec3 ambient = vec3(0.0);\n    vec3 diffuse = vec3(0.0);\n    vec3 lightPos = vec3(0.0);\n    vec3 lightColor = vec3(0.0);\n    vec3 lightDir = vec3(0.0);\n    vec3 lightAttenuation = vec3(0.0);\n    vec3 lightAmbient = vec3(0.0);\n    vec3 lightDiffuse = vec3(0.0);\n    vec3 lightSpecular = vec3(0.0);\n    vec3 lightAttenuationQuadratic = vec3(0.0);\n    vec3 lightAttenuationLinear = vec3(0.0);\n    vec3 lightAttenuationConstant = vec3(0.0);\n    vec3 lightAmbientQuadratic = vec3(0.0);\n    vec3 lightDiffuseQuadratic = vec3(0.0);\n    vec3 lightSpecularQuadratic = vec3(0.0);\n    vec3 lightAmbientLinear = vec3(0.0);\n    vec3 lightDiffuseLinear = vec3(0.0);\n    vec3 lightSpecularLinear = vec3(0.0);\n    vec3 lightAttenuationConstantQuadratic = vec3(0.0);\n    vec3 lightAttenuationConstantLinear = vec3(0.0);\n    vec3 lightAttenuationConstantConstant = vec3(0.0);\n    vec3 lightAmbientConstant = vec3(0.0);\n    vec3 lightDiffuseConstant = vec3(0.0);\n    vec3 lightSpecularConstant = vec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = mod(a, 2.0 * PI);\n    float t = mod(a / (2.0 * PI), 1.0);\n    float c = cos(r);\n    float s = sin(r);\n    float n = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float r2 = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float g = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float b = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n\n    col = vec3(r2, g, b);\n\n    fragColor = vec4(col, 1.0);\n}\n", "\n    return vec3(hash, hash, hash);\n}\n\nvec", "\n    return bccNoise_PlaneFirst(X.x, X.y, X.z);\n}\n\nvec", "\n    float d = scene(p);\n    if (d < eps) {\n        return 0.0;\n    }\n    return d;\n}\n\nfloat", "\n\t\tfloat t = ( targetPos - ray.origin ).Dot( ray.direction ) / ray.direction.Dot( ray.direction );\n\t\treturn ray.origin + t * ray.direction;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos );\n\t\tfloat distance = ( closestPoint - targetPos ).Length();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos );\n\t\tdistance = ( closestPoint - targetPos ).Length();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance, out vec3 normal ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos, radius );\n\t\tdistance = ( closestPoint - targetPos ).Length();\n\t\tnormal = ( closestPoint - targetPos ).Normalize();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance, out vec3 normal, out vec3 tangent ) {\n\t\tvec3 closestPoint = GetClosestPoint( ray, targetPos, radius );\n\t\tdistance = ( closestPoint - targetPos ).Length();\n\t\tnormal = ( closestPoint - targetPos ).Normalize();\n\t\ttangent = ( closestPoint - targetPos ).Cross( normal ).Normalize();\n\t\tif( distance > radius ) {\n\t\t\treturn closestPoint;\n\t\t}\n\t\treturn targetPos;\n\t}\n\n\tvec3 GetClosestPoint( Ray ray, vec3 targetPos, float radius, out float distance, out vec3 normal, out vec3 tangent, out vec3 bitang", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.08;\n    float c = cos(a * 10.0);\n    float s = sin(a * 10.0);\n    float t = (r + 1.0) * 0.5;\n    float k = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float f = smoothstep(0.0, 1.0, t);\n    float g = smoothstep(0.0, 1.0, t - 1.0);\n    float h = smoothstep(0.0, 1.0, t - 2.0);\n    float i = smoothstep(0.0, 1.0, t - 3.0);\n    float j = smoothstep(0.0, 1.0, t - 4.0);\n    float kk = smoothstep(0.0, 1.0, t - 5.0);\n    float l = smoothstep(0.0, 1.0, t - 6.0);\n    float m = smoothstep(0.0, 1.0, t - 7.0);\n    float n = smoothstep(0.0, 1.0, t - 8.0);\n    float o = smoothstep(0.0, 1.0, t - 9.0);\n    float ppp = smoothstep(0.0, 1.0, t - 10.0);\n    float q = smoothstep(0.0, 1.0, t - 11.0);\n    float rr = smoothstep(0.0, 1.0, t - 12.0);\n    float sss = smoothstep(0.0, 1.0, t - 13.0);\n    float ttt = smoothstep(0", "\n    vec4 p4 = vec4(p, 1.0);\n    p4 = p4 * 2.0 - 1.0;\n    p4.y = -p4.y;\n    p4 = p4 * 0.5 + 0.5;\n    return p4;\n}\n\nvec", "\n    float t = ( targetPos - ray.origin ).length() / ray.direction.length();\n    float d = ( targetPos - ray.origin ).dot( ray.direction );\n    float r = lightDiameter / 2.0;\n    float a = r * r / ( r * r + ( t - d ) * ( t - d ) );\n    float b = sqrt( 1.0 - a * a );\n    float c = ( t - d ) * b;\n    float d1 = c * ( 1.0 - a ) + a;\n    float d2 = c * a - 1.0;\n    float d3 = ( t - d ) * ( 1.0 - b ) + b;\n    float d4 = ( t - d ) * b - 1.0;\n    float d5 = ( t - d ) * ( 1.0 - a ) - a;\n    float d6 = c * ( 1.0 - b ) - b;\n    float d7 = c * b - 1.0;\n    float d8 = ( t - d ) * b - 1.0;\n    float d9 = ( t - d ) * ( 1.0 - b ) - b;\n    float d10 = ( t - d ) * b - 1.0;\n    float d11 = c * ( 1.0 - a ) - a;\n    float d12 = c * a - 1.0;\n    float d13 = ( t - d ) * ( 1.0 - b ) - b;\n    float d14 = ( t - d ) * b - 1.0;\n    float d15 = ( t - d ) * ( 1.0 - a ) - a;\n    float d16 = c * ( 1.0 - b ) - b;\n    float d17 = c * b - 1.0;\n    float d18 = ( t - d ) * b - 1.0;\n    float d19 = ( t - d ) * ( 1.0 - b ) - b;\n    float d20 = ( t - d ) * b - 1.0;\n   ", "\n    return vec2(\n        abs(p.x) - 1.0,\n        abs(p.y) - 1.0\n    );\n}\n\nvec", "\n    return fract(sin(x) * 43758.5453);\n}\n\nfloat", "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    return (v >= 0 && v <= 1) && (w >= 0 && w <= 1);\n}\n\nvoid main() {\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p1 = vec2(0.0, 0.0);\n    vec2 p2 = vec2(resolution.x, 0.0);\n    vec2 p3 = vec2(resolution.x, resolution.y);\n    if (in_triangle(p1, p2, p3, uv)) {\n        gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0);\n    } else {\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n    }\n}\n", "\n    vec2 p = uv - vec2(0.5);\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float c = cos(a);\n    float s = sin(a);\n    float t = atan(p.y, p.x) / (2.0 * PI);\n    float r2 = r * r;\n    float r4 = r2 * r2;\n    float r6 = r4 * r2;\n    float r8 = r6 * r2;\n    float r10 = r8 * r2;\n    float r12 = r10 * r2;\n    float r14 = r12 * r2;\n    float r16 = r14 * r2;\n    float r18 = r16 * r2;\n    float r20 = r18 * r2;\n    float r22 = r20 * r2;\n    float r24 = r22 * r2;\n    float r26 = r24 * r2;\n    float r28 = r26 * r2;\n    float r30 = r28 * r2;\n    float r32 = r30 * r2;\n    float r34 = r32 * r2;\n    float r36 = r34 * r2;\n    float r38 = r36 * r2;\n    float r40 = r38 * r2;\n    float r42 = r40 * r2;\n    float r44 = r42 * r2;\n    float r46 = r44 * r2;\n    float r48 = r46 * r2;\n    float r50 = r48 * r2;\n    float r52 = r50 * r2;\n    float r54 = r52 * r2;\n    float r56 = r54 * r2;\n    float r58 = r56 * r2;\n    float r60 = r58 * r2;\n    float r62 = r60 * r2;\n    float", "\n    float angle = atan(uv.y, uv.x);\n    float radius = length(uv);\n    float angle_offset = rotation * 2.0 * PI;\n    float angle_offset_2 = angle_offset * 2.0;\n    float angle_offset_3 = angle_offset * 3.0;\n    float angle_offset_4 = angle_offset * 4.0;\n    float angle_offset_5 = angle_offset * 5.0;\n    float angle_offset_6 = angle_offset * 6.0;\n    float angle_offset_7 = angle_offset * 7.0;\n    float angle_offset_8 = angle_offset * 8.0;\n    float angle_offset_9 = angle_offset * 9.0;\n    float angle_offset_10 = angle_offset * 10.0;\n    float angle_offset_11 = angle_offset * 11.0;\n    float angle_offset_12 = angle_offset * 12.0;\n    float angle_offset_13 = angle_offset * 13.0;\n    float angle_offset_14 = angle_offset * 14.0;\n    float angle_offset_15 = angle_offset * 15.0;\n    float angle_offset_16 = angle_offset * 16.0;\n    float angle_offset_17 = angle_offset * 17.0;\n    float angle_offset_18 = angle_offset * 18.0;\n    float angle_offset_19 = angle_offset * 19.0;\n    float angle_offset_20 = angle_offset * 20.0;\n    float angle_offset_21 = angle_offset * 21.0;\n    float angle_offset_22 = angle_offset * 22.0;\n    float angle_offset_23 = angle_offset * 23.0;\n    float angle_offset_24 = angle_offset * 24.0;\n    float angle_offset_25 = angle_offset * 25.0;\n    float angle_", "\n    vec2 p = vec2(0.5) - uv;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float c = cos(a);\n    float s = sin(a);\n    mat2 m = mat2(c, -s, s, c);\n    p = m * p;\n    p.x *= circumradius;\n    p.y *= circumradius;\n    p = abs(p);\n    float d = length(p);\n    return step(d, r);\n}\n\nfloat", "\n    float r = sqrt(U.x * U.x + U.y * U.y);\n    float phi = atan2(U.y, U.x);\n    float a = 0.0;\n    float b = 1.0;\n    for (int i = 0; i < 100; i++) {\n        float c = (a + b) / 2.0;\n        if (r * c < d) a = c;\n        else b = c;\n    }\n    return a;\n}\n\nfloat", "\n    return (n * 11) % 1000000007;\n}\n\nuint hash2(uint n)\n{\n    return (n * 13) % 1000000007;\n}\n\nuint hash3(uint n)\n{\n    return (n * 17) % 1000000007;\n}\n\nuint hash4(uint n)\n{\n    return (n * 19) % 1000000007;\n}\n\nuint hash5(uint n)\n{\n    return (n * 23) % 1000000007;\n}\n\nuint hash6(uint n)\n{\n    return (n * 29) % 1000000007;\n}\n\nuint hash7(uint n)\n{\n    return (n * 31) % 1000000007;\n}\n\nuint hash8(uint n)\n{\n    return (n * 37) % 1000000007;\n}\n\nuint hash9(uint n)\n{\n    return (n * 41) % 1000000007;\n}\n\nuint hash10(uint n)\n{\n    return (n * 43) % 1000000007;\n}\n\nuint hash11(uint n)\n{\n    return (n * 47) % 1000000007;\n}\n\nuint hash12(uint n)\n{\n    return (n * 53) % 1000000007;\n}\n\nuint hash13(uint n)\n{\n    return (n * 59) % 1000000007;\n}\n\nuint hash14(uint n)\n{\n    return (n * 61) % 1000000007;\n}\n\nuint hash15(uint n)\n{\n   ", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec3 normal = vec3(0.0);\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    normal.x = calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy);\n    normal.y = calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy);\n    normal.z = calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx);\n    return normalize(normal);\n}\n\nvoid main() {\n    vec3 pos = vec3(gl_FragCoord.xy, calcHeight(gl_FragCoord.xy));\n    vec3 normal = calcNormal(pos);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    float shininess = 10.0;\n    float intensity = 0.0;\n    float attenuation = 1.0;\n    float distance = length(pos);\n    float attenuationFactor = 1.0 / (1.0 + attenuation * distance);\n    intensity = max(dot(normal, lightDir), 0.0);\n    intensity = intensity * attenuationFactor;\n    diffuse = vec3(0.0, 0.0, 0.0);\n    if (intensity > 0.0) {\n        diffuse = vec3(0.0, 0.0, 0.0);\n        vec3 halfVector = normalize(lightDir + viewDir);\n        float specularFactor = pow(max(dot(normal, halfVector), 0.0), shininess);\n        specular = vec3(0.0, 0.0, 0.0);\n        if (specularFactor > 0.0", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        d = map(p);\n        t += d;\n        p = ro + rd * t;\n        if (d < 0.001) break;\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = render(ro, rd);\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col,", "\n    vec3 normal = vec3(0.0);\n    vec3 eps = vec3(0.0001, 0.0, 0.0);\n    normal.x = calcHeight(pos + eps.xyy) - calcHeight(pos - eps.xyy);\n    normal.y = calcHeight(pos + eps.yxy) - calcHeight(pos - eps.yxy);\n    normal.z = calcHeight(pos + eps.yyx) - calcHeight(pos - eps.yyx);\n    return normalize(normal);\n}\n\nvoid main() {\n    vec3 pos = vec3(gl_FragCoord.xy, calcHeight(gl_FragCoord.xy));\n    vec3 normal = calcNormal(pos);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    vec3 viewDir = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    float shininess = 10.0;\n    float intensity = 0.0;\n    float attenuation = 1.0;\n    float distance = length(pos);\n    float attenuationFactor = 1.0 / (1.0 + attenuation * distance);\n    intensity = max(dot(normal, lightDir), 0.0);\n    intensity = intensity * attenuationFactor;\n    diffuse = vec3(0.0, 0.0, 0.0);\n    if (intensity > 0.0) {\n        diffuse = vec3(0.0, 0.0, 0.0);\n        vec3 halfVector = normalize(lightDir + viewDir);\n        float specularFactor = pow(max(dot(normal, halfVector), 0.0), shininess);\n        specular = vec3(0.0, 0.0, 0.0);\n        if (specularFactor > 0.0", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++) {\n        d = map(p);\n        t += d;\n        p = ro + rd * t;\n        if (d < 0.001) break;\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, -1.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = render(ro, rd);\n    col = pow(col, vec3(0.4545));\n    col = pow(col, vec3(1.0 / 2.2));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col, vec3(1.0 / 1.0));\n    col = pow(col,", "\n    vec3 e = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(\n        estimateHeight(p + e.yxx) - estimateHeight(p - e.yxx),\n        estimateHeight(p + e.xyx) - estimateHeight(p - e.xyx),\n        estimateHeight(p + e.xxy) - estimateHeight(p - e.xxy)\n    ));\n}\n\nfloat", "\n    return dot( q, ivec2( 127.1, 311.7 ) );\n}\n\nfloat", "\n    vec3 c = texture2D( material, coord ).rgb;\n    if ( c.r == 0.0 ) {\n        color = vec3( 0.0, 0.0, 0.0 );\n        return false;\n    }\n    color = c;\n    return true;\n}\n\nvoid main() {\n    vec3 color;\n    if ( getMaterialColor( 0, gl_TexCoord[0].st, color ) ) {\n        gl_FragColor = vec4( color, 1.0 );\n    } else {\n        gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n    }\n}\n", "\n    vec2 q = vec2( dot(p, ab), p.x );\n    return vec2( length(q) - ab.y, dot(q, q) - ab.x );\n}\n\nfloat", "\n    return vec3(fmod(p, 1.0), fmod(p + 1.0, 1.0), fmod(p + 2.0, 1.0));\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.08;\n    float c = cos(a * 10.0);\n    float s = sin(a * 10.0);\n    float t = (r + 1.0) * 0.5;\n    float k = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float f = smoothstep(0.0, 1.0, t);\n    float g = smoothstep(0.0, 1.0, t - 1.0);\n    float h = smoothstep(0.0, 1.0, t - 2.0);\n    float i = smoothstep(0.0, 1.0, t - 3.0);\n    float j = smoothstep(0.0, 1.0, t - 4.0);\n    float kk = smoothstep(0.0, 1.0, t - 5.0);\n    float l = smoothstep(0.0, 1.0, t - 6.0);\n    float m = smoothstep(0.0, 1.0, t - 7.0);\n    float n = smoothstep(0.0, 1.0, t - 8.0);\n    float o = smoothstep(0.0, 1.0, t - 9.0);\n    float ppp = smoothstep(0.0, 1.0, t - 10.0);\n    float q = smoothstep(0.0, 1.0, t - 11.0);\n    float rr = smoothstep(0.0, 1.0, t - 12.0);\n    float sss = smoothstep(0.0, 1.0, t - 13.0);\n    float ttt = smoothstep(0", "\n    float tmin = -1.0;\n    float tmax = 1.0;\n    float tymin = (1.0 - raypos.y) / raypos.z;\n    float tymax = (1.0 - raypos.y) / raypos.z;\n    if (tymin > tmax)\n        std::swap(tymin, tmax);\n    if (tymin > tymin)\n        tymin = tymin;\n    if (tymax < tmax)\n        tmax = tymax;\n    float tzmin = (1.0 - raypos.z) / raypos.w;\n    float tzmax = (1.0 - raypos.z) / raypos.w;\n    if (tzmin > tmax)\n        std::swap(tzmin, tmax);\n    if (tzmin > tzmax)\n        tzmax = tzmin;\n    if (tmin > tzmin)\n        tmin = tzmin;\n    if (tmax < tzmax)\n        tmax = tzmax;\n    return tmin;\n}\n\nvec", "\n\trotmat[0][0] = cos(rotation.x) * cos(rotation.y);\n\trotmat[0][1] = cos(rotation.x) * sin(rotation.y);\n\trotmat[0][2] = -sin(rotation.x);\n\trotmat[1][0] = sin(rotation.x) * cos(rotation.y);\n\trotmat[1][1] = sin(rotation.x) * sin(rotation.y);\n\trotmat[1][2] = cos(rotation.x);\n\trotmat[2][0] = 0;\n\trotmat[2][1] = 0;\n\trotmat[2][2] = 1;\n}\n\nvoid mat3::rotate(vec3 rotation){\n\trotmat[0][0] = cos(rotation.x) * cos(rotation.y);\n\trotmat[0][1] = cos(rotation.x) * sin(rotation.y);\n\trotmat[0][2] = -sin(rotation.x);\n\trotmat[1][0] = sin(rotation.x) * cos(rotation.y);\n\trotmat[1][1] = sin(rotation.x) * sin(rotation.y);\n\trotmat[1][2] = cos(rotation.x);\n\trotmat[2][0] = 0;\n\trotmat[2][1] = 0;\n\trotmat[2][2] = 1;\n}\n\nvoid mat3::rotate(float x, float y, float z){\n\trotmat[0][0] = cos(x) * cos(y);\n\trotmat[0][1] = cos(x) * sin(y);\n\trotmat[0][2] = -sin(x);\n\trotmat[1][0] = sin(x) * cos(y);\n\trotmat[1][1] = sin(x) * sin(y);\n\trotmat[1][2] = cos(x);\n\trotmat[2][0] = 0;\n\trotmat[2][1] = 0;\n\trotmat[2", "\n    vec4 raypos = rayori;\n    float t = 0.0;\n    for(int i = 0; i < 100; i++){\n        vec4 pos = raypos;\n        pos.xyz += raydir.xyz * t;\n        if(pos.w < 0.0) break;\n        t += raydir.w;\n    }\n    return pos;\n}\n\nvec", "\n    vec3 color = vec3(0.0);\n    vec2 texCoord = uv.xy;\n    float time = iGlobalTime;\n    float offset = time * 0.001;\n    float offset2 = time * 0.002;\n    float offset3 = time * 0.003;\n    float offset4 = time * 0.004;\n    float offset5 = time * 0.005;\n    float offset6 = time * 0.006;\n    float offset7 = time * 0.007;\n    float offset8 = time * 0.008;\n    float offset9 = time * 0.009;\n    float offset10 = time * 0.01;\n    float offset11 = time * 0.011;\n    float offset12 = time * 0.012;\n    float offset13 = time * 0.013;\n    float offset14 = time * 0.014;\n    float offset15 = time * 0.015;\n    float offset16 = time * 0.016;\n    float offset17 = time * 0.017;\n    float offset18 = time * 0.018;\n    float offset19 = time * 0.019;\n    float offset20 = time * 0.02;\n    float offset21 = time * 0.021;\n    float offset22 = time * 0.022;\n    float offset23 = time * 0.023;\n    float offset24 = time * 0.024;\n    float offset25 = time * 0.025;\n    float offset26 = time * 0.026;\n    float offset27 = time * 0.027;\n    float offset28 = time * 0.028;\n    float offset29 = time * 0.029;\n    float offset30 = time * 0.03;\n    float offset31", "\n    vec3 raypos = rayori;\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    float tmin_tmax[2];\n    for(int i = 0; i < 100; i++){\n        tmin_tmax[0] = tmin;\n        tmin_tmax[1] = tmax;\n        t = raymarch(raypos, raydir, tmin_tmax);\n        if(t < tmin_tmax[0]){\n            tmin_tmax[0] = t;\n        }\n        if(t > tmin_tmax[1]){\n            tmin_tmax[1] = t;\n        }\n        if(tmin_tmax[1] - tmin_tmax[0] < 0.001){\n            break;\n        }\n        tmin = tmin_tmax[0];\n        tmax = tmin_tmax[1];\n    }\n    return raypos + raydir * t;\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.08;\n    float c = cos(a * 10.0);\n    float s = sin(a * 10.0);\n    float t = (r + 1.0) * 0.5;\n    float k = (1.0 - smoothstep(0.0, 1.0, t)) * 0.5;\n    float f = smoothstep(0.0, 1.0, t);\n    float g = smoothstep(0.0, 1.0, t - 1.0);\n    float h = smoothstep(0.0, 1.0, t - 2.0);\n    float i = smoothstep(0.0, 1.0, t - 3.0);\n    float j = smoothstep(0.0, 1.0, t - 4.0);\n    float kk = smoothstep(0.0, 1.0, t - 5.0);\n    float l = smoothstep(0.0, 1.0, t - 6.0);\n    float m = smoothstep(0.0, 1.0, t - 7.0);\n    float n = smoothstep(0.0, 1.0, t - 8.0);\n    float o = smoothstep(0.0, 1.0, t - 9.0);\n    float ppp = smoothstep(0.0, 1.0, t - 10.0);\n    float q = smoothstep(0.0, 1.0, t - 11.0);\n    float rr = smoothstep(0.0, 1.0, t - 12.0);\n    float sss = smoothstep(0.0, 1.0, t - 13.0);\n    float ttt = smoothstep(0", "\n    float strength = maxStrength * sin(frequency * coord.x + time * travelRate);\n    return strength;\n}\n\nvoid main()\n{\n    vec2 coord = gl_FragCoord.xy / resolution.xy;\n    vec2 coord2 = coord * 2.0 - 1.0;\n    vec2 coord3 = coord2 * 2.0 - 1.0;\n    vec2 coord4 = coord3 * 2.0 - 1.0;\n    vec2 coord5 = coord4 * 2.0 - 1.0;\n    vec2 coord6 = coord5 * 2.0 - 1.0;\n    vec2 coord7 = coord6 * 2.0 - 1.0;\n    vec2 coord8 = coord7 * 2.0 - 1.0;\n    vec2 coord9 = coord8 * 2.0 - 1.0;\n    vec2 coord10 = coord9 * 2.0 - 1.0;\n    vec2 coord11 = coord10 * 2.0 - 1.0;\n    vec2 coord12 = coord11 * 2.0 - 1.0;\n    vec2 coord13 = coord12 * 2.0 - 1.0;\n    vec2 coord14 = coord13 * 2.0 - 1.0;\n    vec2 coord15 = coord14 * 2.0 - 1.0;\n    vec2 coord16 = coord15 * 2.0 - 1.0;\n    vec2 coord17 = coord16 * 2.0 - 1.0;\n    vec2 coord18 = coord17 * 2.0 - 1.0;\n    vec2 coord19 = coord18 * 2.0 - 1.0;\n    vec2 coord20 = coord19 * 2.0 - 1.0;\n    vec2 coord21 = coord20 * 2.0 - 1.0;\n    vec2 coord22 = coord21 * ", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    vec2 p1 = p + d;\n    vec2 p2 = p + d + vec2(0.0, 1.0);\n    vec2 p3 = p + d + vec2(1.0, 0.0);\n    vec2 p4 = p + d + vec2(1.0, 1.0);\n    vec2 p5 = p + d + vec2(0.0, 2.0);\n    vec2 p6 = p + d + vec2(1.0, 2.0);\n    vec2 p7 = p + d + vec2(2.0, 1.0);\n    vec2 p8 = p + d + vec2(2.0, 0.0);\n    vec2 p9 = p + d + vec2(2.0, 2.0);\n    vec2 p10 = p + d + vec2(3.0, 1.0);\n    vec2 p11 = p + d + vec2(3.0, 0.0);\n    vec2 p12 = p + d + vec2(3.0, 2.0);\n    vec2 p13 = p + d + vec2(4.0, 1.0);\n    vec2 p14 = p + d + vec2(4.0, 0.0);\n    vec2 p15 = p + d + vec2(4.0, 2.0);\n    vec2 p16 = p + d + vec2(5.0, 1.0);\n    vec2 p17 = p + d + vec2(5.0, 0.0);\n    vec2 p18 = p + d + vec2(5.0, 2.0);\n    vec2 p19 = p + d + vec2(6.0, 1.0);\n    vec2 p20 = p + d + vec2(6.0, 0.0);\n    vec2 p21 = p + d + ve", "\n    return color * (1.0 - filmic_exposure) + vec3(1.0) * filmic_exposure;\n}\n\nvoid main() {\n    vec3 color = texture(u_texture, v_texcoord).rgb;\n    vec3 filmic_color = filmic(color);\n    vec3 gamma = vec3(1.0 / 2.2);\n    vec3 gamma_color = pow(filmic_color, gamma);\n    out_color = vec4(gamma_color, 1.0);\n}\n", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = clamp( dot( ap, ab ) / dot( ab, ab ), 0.0, 1.0 );\n    return sdSegment( p, a, b ) - w1 * ( 1.0 - t ) - w2 * t;\n}\n\nfloat", "\n    vec2 q = uv - p;\n    return vec3( length(q) - 0.02, 0.0, 0.0 );\n}\n\nvoid main()\n{\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n    vec2 p = uv * 2.0 - 1.0;\n    vec3 col = vec3(0.0);\n    col += blob(uv, p);\n    col += blob(uv, p + vec2(0.0, 1.0));\n    col += blob(uv, p + vec2(1.0, 0.0));\n    col += blob(uv, p + vec2(1.0, 1.0));\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n\tfloat t = falloff * rnd.x;\n\treturn vec3( 1.0 - smoothstep( 0.0, 1.0, t ), 1.0 - smoothstep( 0.0, 1.0, t ), 1.0 - smoothstep( 0.0, 1.0, t ) );\n}\n\nvoid main()\n{\n\tvec3 rnd = vec3( 0.0 );\n\trnd.x = fract( sin( dot( gl_FragCoord.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n\trnd.y = fract( sin( dot( gl_FragCoord.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n\trnd.z = fract( sin( dot( gl_FragCoord.xy, vec2( 12.9898, 78.233 ) ) ) * 43758.5453 );\n\n\tvec3 color = vec3( 0.0 );\n\tcolor += pulse( 0.0, rnd );\n\tcolor += pulse( 0.1, rnd );\n\tcolor += pulse( 0.2, rnd );\n\tcolor += pulse( 0.3, rnd );\n\tcolor += pulse( 0.4, rnd );\n\tcolor += pulse( 0.5, rnd );\n\tcolor += pulse( 0.6, rnd );\n\tcolor += pulse( 0.7, rnd );\n\tcolor += pulse( 0.8, rnd );\n\tcolor += pulse( 0.9, rnd );\n\tcolor += pulse( 1.0, rnd );\n\n\tgl_FragColor = vec4( color, 1.0 );\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return vec3(fmod(p, 1.0), fmod(p + 1.0, 1.0), fmod(p + 2.0, 1.0));\n}\n\nvec", "\n    return (1.0f - expf(-2.0f * x)) / (1.0f + expf(-2.0f * x));\n}\n\nfloat", "\n    vec2 uv = q;\n    uv.y = 1.0 - uv.y;\n    vec3 c = texture2D(u_texture, uv).rgb;\n    return mix(col, c, 0.2);\n}\n\nvoid main() {\n    vec2 q = gl_FragCoord.xy / u_resolution.xy;\n    vec3 col = vec3(0.0);\n\n    col = postProcess(col, q);\n\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 q = abs(p);\n    return max(max(q.x, q.y), q.z) - 1.0;\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s ="]}