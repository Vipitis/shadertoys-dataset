{"input_both": ["\n    vec3 q = p - vec3( 0.5 );\n    float d = length( q );\n    return d * 0.5;\n}\n\n//=====================================================\n\nfloat", "\n    vec3 q = Rotate(p, rotDir, rotSpeed);\n\n    // Scale the object\n    vec3 r = Scale(q, scale);\n\n    // Move the object\n    vec3 s = Translate(r, offset);\n\n    // Get the distance to the object\n    float d = Distance(s, vec3(0.0));\n\n    // Return the distance to the object\n    return d;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tp.x *= iResolution.x / iResolution.y;\n\tvec2 d = p - vec2(0.5);\n\t\n\t//get camera\n\tvec3 ro = vec3(0.0, 0.0, 1.0);\n\tvec3 ta = vec3(0.0, 0.0, 0.0);\n\tvec3 ww = normalize(ta - ro);\n\tvec3 uu = normalize(cross(ww, vec3(sin(3.14159265359), cos(3.14159265359), 0.0)));\n\tvec3 vv = normalize(cross(uu, ww));\n\t\n\t//get camera parameters\n\tfloat fov = 60.0;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tfloat znear = 0.1;\n\tfloat zfar = 100.0;\n\t\n\t//get camera matrix\n\tmat4 cam = lookAt(ro, ta, ww);\n\t\n\t//get camera ray\n\tvec4 ray = cam * vec4(d.x * uu + d.y * vv + d.x * znear * ww, zfar);\n\tray.xyz /= ray.w;\n\t\n\t//get camera ray direction\n\tvec3 raydir = normalize(ray.xyz);\n\t\n\t//get camera ray origin\n\tvec3 rayorig = ro + raydir * znear;\n\t\n\t//get camera ray origin\n\tvec3 rayorig2 = ro + raydir * znear;\n\t\n\t//get camera ray origin\n\tvec3 rayorig3 = ro + raydir * znear;\n\t\n\t//get camera ray origin\n\tvec3 rayorig4 = ro + raydir * znear;\n\t\n\t//get camera ray origin\n\tvec3 rayorig5 = ro + raydir * znear;\n\t\n\t//get camera ray origin\n\tvec3 rayorig6 = ro + raydir *", "\n\n    vec2 cc = vec2(0.5, 0.5);\n\n    vec2 z = p;\n    vec2 c = cc;\n    float m = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + c;\n        m = length(z);\n        if (m > 2.0) break;\n    }\n    return vec4(m, m, m, 1.0);\n}\n\nvoid main()\n{\n    vec2 p = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec4 col = juliaSet(p);\n    gl_FragColor = col;\n}\n", " and forth\n    float fade = clamp(0.5 + 0.5 * (1.0 + dot(rayDir, sunDir)), 0.0, 1.0);\n    vec3 color = vec3(0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0", "\n\tvec3 pos = vec3(0.0, 0.0, 0.0);\n\tvec3 dir = vec3(0.0, 0.0, 0.0);\n\tfloat shutter_time = 0.0;\n\n\t// Camera pathing\n\tswitch (cam_path)\n\t{\n\t\tcase 0:\n\t\t\tpos = vec3(0.0, 0.0, 0.0);\n\t\t\tdir = vec3(0.0, 0.0, 0.0);\n\t\t\tshutter_time = 0.0;\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tpos = vec3(0.0, 0.0, 0.0);\n\t\t\tdir = vec3(0.0, 0.0, 0.0);\n\t\t\tshutter_time = 0.0;\n\t\t\tbreak;\n\t\tcase 2:\n\t\t\tpos = vec3(0.0, 0.0, 0.0);\n\t\t\tdir = vec3(0.0, 0.0, 0.0);\n\t\t\tshutter_time = 0.0;\n\t\t\tbreak;\n\t\tcase 3:\n\t\t\tpos = vec3(0.0, 0.0, 0.0);\n\t\t\tdir = vec3(0.0, 0.0, 0.0);\n\t\t\tshutter_time = 0.0;\n\t\t\tbreak;\n\t\tcase 4:\n\t\t\tpos = vec3(0.0, 0.0, 0.0);\n\t\t\tdir = vec3(0.0, 0.0, 0.0);\n\t\t\tshutter_time = 0.0;\n\t\t\tbreak;\n\t\tcase 5:\n\t\t\tpos = vec3(0.0, 0.0, 0.0);\n\t\t\tdir = vec3(0.0, 0.0, 0.0);\n\t\t\tshutter_time = 0.0;\n\t\t\tbreak;\n\t\tcase 6:\n\t\t\tpos = vec3(0.0, 0.0, 0.0", "\n\tif (p.y > 0.0)\n\t\treturn vec3(0.0);\n\n\t// Get the texture coordinates.\n\tvec2 tex = vec2(p.x, p.z) * 0.01;\n\n\t// Get the texture color.\n\tvec3 t = texture(tex_sampler, tex).rgb;\n\n\t// Apply the texture color to the eye coordinate.\n\tt *= e.y;\n\n\t// Return the texture color.\n\treturn t;\n}\n\n/*\n\tReturns the color of a point in space.\n*/\nvec", " and forth\n    float fade = clamp(0.5 + 0.5 * (1.0 + dot(rayDir, sunDir)), 0.0, 1.0);\n    vec3 color = vec3(0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0", "\n  float distanceToSurface = INFINITY;\n  vec2 hitCoordinates = vec2(0.0);\n\n  // we will loop through all the objects in the scene\n  for( int i = 0; i < NUMBER_OF_OBJECTS; i++ ){\n\n    // we will check if the ray hits the object\n    // if it does, we will store the distance to the surface\n    // and the coordinates of the hit\n    if( rayHit( eyePosition, rayDirection, objects[i] ) ){\n      distanceToSurface = distance( eyePosition, objects[i].position );\n      hitCoordinates = objects[i].coordinates;\n    }\n  }\n\n  // if we did not hit anything, we will return a default value\n  if( distanceToSurface == INFINITY ){\n    return vec2(0.0);\n  }\n\n  // if we did hit something, we will return the coordinates of the hit\n  return hitCoordinates;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 -", "\n    vec2 res = vec2(0.0);\n\n    // loop through all the objects\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        // get the object\n        Object obj = objects[i];\n\n        // check if the ray intersects with the object\n        if (intersect(p, obj))\n        {\n            // if it does, then we need to find the closest point\n            // to the ray\n            vec3 closest = closestPoint(p, obj);\n\n            // find the distance between the ray and the closest point\n            float dist = distance(p, closest);\n\n            // if the distance is less than the current distance,\n            // then we need to update the distance and the color\n            if (dist < res.x)\n            {\n                res.x = dist;\n                res.y = i;\n            }\n        }\n    }\n\n    // return the result\n    return res;\n}\n\n// ~~~~~~~ ray marching\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\nvec", "\n\tfloat t = 0.0;\n\tfloat tmax = 1000.0;\n\tfloat tmin = 0.001;\n\tfloat tmin_step = 0.001;\n\tfloat tmax_step = 0.001;\n\tfloat tmin_step_max = 100.0;\n\tfloat tmax_step_max = 100.0;\n\tfloat tmin_step_min = 0.001;\n\tfloat tmax_step_min = 0.001;\n\tfloat tmin_step_min_max = 0.001;\n\tfloat tmax_step_min_max = 0.001;\n\tfloat tmin_step_min_max_max = 0.001;\n\tfloat tmax_step_min_max_max = 0.001;\n\tfloat tmin_step_min_max_max_max = 0.001;\n\tfloat tmax_step_min_max_max_max = 0.001;\n\tfloat tmin_step_min_max_max_max_max = 0.001;\n\tfloat tmax_step_min_max_max_max_max = 0.001;\n\tfloat tmin_step_min_max_max_max_max_max = 0.001;\n\tfloat tmax_step_min_max_max_max_max_max = 0.001;\n\tfloat tmin_step_min_max_max_max_max_max_max = 0.001;\n\tfloat tmax_step_min_max_max_max_max_max_max = 0.001;\n\tfloat tmin_step_min_max_max_max_max_max_max_max = 0.001;\n\tfloat tmax_step_min_max_max_max_max_max_max_max = 0.001;\n\tfloat tmin_step_min_max_max_max_max_max_max_max_max = 0.001;\n\tfloat tmax_step_min_max_max_max_max_", "\n    vec4 result = vec4(0.0);\n\n    // distance to the surface\n    float d = 1000.0;\n\n    // find the closest object\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        // get the object\n        Object o = objects[i];\n\n        // check if the ray intersects with the object\n        if (intersect(o, p))\n        {\n            // get the distance to the surface\n            float dist = length(o.p - p);\n\n            // if the distance is closer than the previous closest distance\n            if (dist < d)\n            {\n                // set the distance to the surface\n                d = dist;\n\n                // set the blended color\n                result = vec4(o.color, 1.0);\n            }\n        }\n    }\n\n    // return the blended color\n    return result;\n}\n\n// ~~~~~~~ raymarching\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec", "\n    float t = 0.0;\n    float tmax = 10000.0;\n    float tmin = 0.001;\n    float tmin2 = 0.0001;\n    float tmin3 = 0.00001;\n    float tmin4 = 0.000001;\n    float tmin5 = 0.0000001;\n    float tmin6 = 0.00000001;\n    float tmin7 = 0.000000001;\n    float tmin8 = 0.0000000001;\n    float tmin9 = 0.00000000001;\n    float tmin10 = 0.000000000001;\n    float tmin11 = 0.0000000000001;\n    float tmin12 = 0.00000000000001;\n    float tmin13 = 0.000000000000001;\n    float tmin14 = 0.0000000000000001;\n    float tmin15 = 0.00000000000000001;\n    float tmin16 = 0.000000000000000001;\n    float tmin17 = 0.0000000000000000001;\n    float tmin18 = 0.00000000000000000001;\n    float tmin19 = 0.000000000000000000001;\n    float tmin20 = 0.0000000000000000000001;\n    float tmin21 = 0.0000000000000000000", "s\n    vec3 wp1 = vec3(0.0);\n    vec3 wp2 = vec3(0.0);\n    vec3 wp3 = vec3(0.0);\n    vec3 wp4 = vec3(0.0);\n    vec3 wp5 = vec3(0.0);\n    vec3 wp6 = vec3(0.0);\n    vec3 wp7 = vec3(0.0);\n    vec3 wp8 = vec3(0.0);\n    vec3 wp9 = vec3(0.0);\n    vec3 wp10 = vec3(0.0);\n    vec3 wp11 = vec3(0.0);\n    vec3 wp12 = vec3(0.0);\n    vec3 wp13 = vec3(0.0);\n    vec3 wp14 = vec3(0.0);\n    vec3 wp15 = vec3(0.0);\n    vec3 wp16 = vec3(0.0);\n    vec3 wp17 = vec3(0.0);\n    vec3 wp18 = vec3(0.0);\n    vec3 wp19 = vec3(0.0);\n    vec3 wp20 = vec3(0.0);\n    vec3 wp21 = vec3(0.0);\n    vec3 wp22 = vec3(0.0);\n    vec3 wp23 = vec3(0.0);\n    vec3 wp24 = vec3(0.0);\n    vec3 wp25 = vec3(0.0);\n    vec3 wp26 = vec3(0.0);\n    vec3 wp27 = vec3(0.0);\n    vec3 wp28 = vec3(0.0);\n    vec3 wp29 = vec3(0.", "\n\n    // This is the original code\n    // It is the same as the above code, but with a different name\n    // This is the code that is used in the original\n    //\n    // The original can be found here\n    // http://www.kchapelier.com/blacksea/\n    //\n\n    // This is the original code\n    // It is the same as the above code, but with a different name\n    // This is the code that is used in the original\n    //\n    // The original can be found here\n    // http://www.kchapelier.com/blacksea/\n    //\n\n    // This is the original code\n    // It is the same as the above code, but with a different name\n    // This is the code that is used in the original\n    //\n    // The original can be found here\n    // http://www.kchapelier.com/blacksea/\n    //\n\n    // This is the original code\n    // It is the same as the above code, but with a different name\n    // This is the code that is used in the original\n    //\n    // The original can be found here\n    // http://www.kchapelier.com/blacksea/\n    //\n\n    // This is the original code\n    // It is the same as the above code, but with a different name\n    // This is the code that is used in the original\n    //\n    // The original can be found here\n    // http://www.kchapelier.com/blacksea/\n    //\n\n    // This is the original code\n    // It is the same as the above code, but with a different name\n    // This is the code that is used in the original\n    //\n    // The original can be found here\n    // http://www.kchapelier.com/blacksea/\n    //\n\n    // This is the original code\n    // It is the same as the above code, but with a different name\n    // This is the code that is used in the original\n    //\n    // The original can be found here\n    // http://www.kchapelier.com/blacksea/\n    //\n\n    // This is the original", "\n    vec4 result = vec4(0.0);\n\n    // distance to the surface\n    float d = 1000.0;\n\n    // find the closest object\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        // get the object\n        Object o = objects[i];\n\n        // check if the ray intersects with the object\n        if (intersect(o, p))\n        {\n            // get the distance to the surface\n            float dist = length(o.p - p);\n\n            // if the distance is closer than the previous closest distance\n            if (dist < d)\n            {\n                // set the distance to the surface\n                d = dist;\n\n                // set the blended color\n                result = vec4(o.color, 1.0);\n            }\n        }\n    }\n\n    // return the blended color\n    return result;\n}\n\n// ~~~~~~~ raymarching\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec", "\n    float t = 0.0;\n    float tmax = 10000.0;\n    float tmin = 0.001;\n    float tmin2 = 0.0001;\n    float tmin3 = 0.00001;\n    float tmin4 = 0.000001;\n    float tmin5 = 0.0000001;\n    float tmin6 = 0.00000001;\n    float tmin7 = 0.000000001;\n    float tmin8 = 0.0000000001;\n    float tmin9 = 0.00000000001;\n    float tmin10 = 0.000000000001;\n    float tmin11 = 0.0000000000001;\n    float tmin12 = 0.00000000000001;\n    float tmin13 = 0.000000000000001;\n    float tmin14 = 0.0000000000000001;\n    float tmin15 = 0.00000000000000001;\n    float tmin16 = 0.000000000000000001;\n    float tmin17 = 0.0000000000000000001;\n    float tmin18 = 0.00000000000000000001;\n    float tmin19 = 0.000000000000000000001;\n    float tmin20 = 0.0000000000000000000001;\n    float tmin21 = 0.0000000000000000000", "s\n    vec3 wp1 = vec3(0.0);\n    vec3 wp2 = vec3(0.0);\n    vec3 wp3 = vec3(0.0);\n    vec3 wp4 = vec3(0.0);\n    vec3 wp5 = vec3(0.0);\n    vec3 wp6 = vec3(0.0);\n    vec3 wp7 = vec3(0.0);\n    vec3 wp8 = vec3(0.0);\n    vec3 wp9 = vec3(0.0);\n    vec3 wp10 = vec3(0.0);\n    vec3 wp11 = vec3(0.0);\n    vec3 wp12 = vec3(0.0);\n    vec3 wp13 = vec3(0.0);\n    vec3 wp14 = vec3(0.0);\n    vec3 wp15 = vec3(0.0);\n    vec3 wp16 = vec3(0.0);\n    vec3 wp17 = vec3(0.0);\n    vec3 wp18 = vec3(0.0);\n    vec3 wp19 = vec3(0.0);\n    vec3 wp20 = vec3(0.0);\n    vec3 wp21 = vec3(0.0);\n    vec3 wp22 = vec3(0.0);\n    vec3 wp23 = vec3(0.0);\n    vec3 wp24 = vec3(0.0);\n    vec3 wp25 = vec3(0.0);\n    vec3 wp26 = vec3(0.0);\n    vec3 wp27 = vec3(0.0);\n    vec3 wp28 = vec3(0.0);\n    vec3 wp29 = vec3(0.", " and forth\n    float fade = clamp(0.5 + 0.5 * rayDir.y, 0.0, 1.0);\n    vec3 color = vec3(0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n    color += vec3(0.0, 0.0, 0.0);\n   ", "\n    vec2 d = vec2(0.0);\n    vec2 a = vec2(0.0);\n    vec2 b = vec2(0.0);\n    vec2 c = vec2(0.0);\n    vec2 d1 = vec2(0.0);\n    vec2 d2 = vec2(0.0);\n    vec2 d3 = vec2(0.0);\n    vec2 d4 = vec2(0.0);\n    vec2 d5 = vec2(0.0);\n    vec2 d6 = vec2(0.0);\n    vec2 d7 = vec2(0.0);\n    vec2 d8 = vec2(0.0);\n    vec2 d9 = vec2(0.0);\n    vec2 d10 = vec2(0.0);\n    vec2 d11 = vec2(0.0);\n    vec2 d12 = vec2(0.0);\n    vec2 d13 = vec2(0.0);\n    vec2 d14 = vec2(0.0);\n    vec2 d15 = vec2(0.0);\n    vec2 d16 = vec2(0.0);\n    vec2 d17 = vec2(0.0);\n    vec2 d18 = vec2(0.0);\n    vec2 d19 = vec2(0.0);\n    vec2 d20 = vec2(0.0);\n    vec2 d21 = vec2(0.0);\n    vec2 d22 = vec2(0.0);\n    vec2 d23 = vec2(0.0);\n    vec2 d24 = vec2(0.0);\n    vec2 d25 = vec2(0.0);\n    vec2 d26 = vec2(0.0);\n    vec2 d27 = vec2(0.0);\n   ", "\n    PT = getPermutationMatrix(pos);\n    g = getCubeFace(pos);\n}\n\n/* For any point in 3D, obtain the permutation matrix, as well as grid coordinates\n   on a cube face. */\nvoid posToGrid(in vec3 pos, out mat3 PT, out vec2 g, out vec3 g3) {\n    \n    // Get permutation matrix and cube face id\n    PT = getPermutationMatrix(pos);\n    g = getCubeFace(pos);\n    g3 = getCubeFace3(pos);\n}\n\n/* For any point in 3D, obtain the permutation matrix, as well as grid coordinates\n   on a cube face. */\nvoid posToGrid(in vec3 pos, out mat3 PT, out vec2 g, out vec3 g3, out vec3 g4) {\n    \n    // Get permutation matrix and cube face id\n    PT = getPermutationMatrix(pos);\n    g = getCubeFace(pos);\n    g3 = getCubeFace3(pos);\n    g4 = getCubeFace4(pos);\n}\n\n/* For any point in 3D, obtain the permutation matrix, as well as grid coordinates\n   on a cube face. */\nvoid posToGrid(in vec3 pos, out mat3 PT, out vec2 g, out vec3 g3, out vec3 g4, out vec3 g5) {\n    \n    // Get permutation matrix and cube face id\n    PT = getPermutationMatrix(pos);\n    g = getCubeFace(pos);\n    g3 = getCubeFace3(pos);\n    g4 = getCubeFace4(pos);\n    g5 = getCubeFace5(pos);\n}\n\n/* For any point in 3D, obtain the permutation matrix, as well as grid coordinates\n   on a cube face. */\nvoid posToGrid(in vec3 pos, out mat3 PT, out vec2 g, out vec3 g3, out vec3 g4, out vec3 g5, out ve", "\n    vec2 p = (g + 0.5) / N;\n    \n    // Map [-1,1] to [0,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;", "\n\tfloat cosTheta = dot(normalize(a), normalize(b));\n\treturn 1.0 - cosTheta * cosTheta;\n}\n\n/* Return squared great circle distance of two points projected onto sphere. */\nfloat", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tvec2 r = p;\n\tfloat t = 0.0;\n\tfloat dt = 0.0;\n\tfloat dt2 = 0.0;\n\tfloat dt3 = 0.0;\n\tfloat dt4 = 0.0;\n\tfloat dt5 = 0.0;\n\tfloat dt6 = 0.0;\n\tfloat dt7 = 0.0;\n\tfloat dt8 = 0.0;\n\tfloat dt9 = 0.0;\n\tfloat dt10 = 0.0;\n\tfloat dt11 = 0.0;\n\tfloat dt12 = 0.0;\n\tfloat dt13 = 0.0;\n\tfloat dt14 = 0.0;\n\tfloat dt15 = 0.0;\n\tfloat dt16 = 0.0;\n\tfloat dt17 = 0.0;\n\tfloat dt18 = 0.0;\n\tfloat dt19 = 0.0;\n\tfloat dt20 = 0.0;\n\tfloat dt21 = 0.0;\n\tfloat dt22 = 0.0;\n\tfloat dt23 = 0.0;\n\tfloat dt24 = 0.0;\n\tfloat dt25 = 0.0;\n\tfloat dt26 = 0.0;\n\tfloat dt27 = 0.0;\n\tfloat dt28 = 0.0;\n\tfloat dt29 = 0.0;\n\tfloat dt30 = 0.0;\n\tfloat dt31 = 0.0;\n\tfloat dt32 = 0.0;\n\tfloat dt33 = 0.0;\n\tfloat dt34 = 0.0;\n\tfloat dt35 = 0.0;\n\tfloat dt36 = 0.0;\n\tfloat dt37 = 0.0;\n\tfloat dt38 = 0.0;\n\tfloat dt39 = 0.0;\n\tfloat dt40 = 0.0;\n\tfloat dt41 = 0.0;\n\tfloat dt42 = 0.0;\n\tfloat dt43", "\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate", "\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure if this is the best way to do it.\n    // I'm not sure", "\n    //It is used to calculate the color of a biomorph\n    //It is based on the formula from the book\n    //The formula is:\n    //color = (1/2) + (1/2) * cos(2 * PI * (x/width) + (y/height))\n    //where x and y are the coordinates of the biomorph\n    //width and height are the dimensions of the biomorph\n    //The formula is used to calculate the color of the biomorph\n    //The formula is:\n    //color = (1/2) + (1/2) * cos(2 * PI * (x/width) + (y/height))\n    //where x and y are the coordinates of the biomorph\n    //width and height are the dimensions of the biomorph\n    //The formula is used to calculate the color of the biomorph\n    //The formula is:\n    //color = (1/2) + (1/2) * cos(2 * PI * (x/width) + (y/height))\n    //where x and y are the coordinates of the biomorph\n    //width and height are the dimensions of the biomorph\n    //The formula is used to calculate the color of the biomorph\n    //The formula is:\n    //color = (1/2) + (1/2) * cos(2 * PI * (x/width) + (y/height))\n    //where x and y are the coordinates of the biomorph\n    //width and height are the dimensions of the biomorph\n    //The formula is used to calculate the color of the biomorph\n    //The formula is:\n    //color = (1/2) + (1/2) * cos(2 * PI * (x/width) + (y/height))\n    //where x and y are the coordinates of the biomorph\n    //width and height are the dimensions of the biomorph\n    //The formula is used to calculate the color of the biomorph\n    //The formula is:\n    //color = (1/2) + (1/2) * cos(2 * PI * (x/width) + (y/height))\n    //where x and y are the coordinates of the biomorph\n    //width and height are the dimensions of", "\n    if (rounded > thick.y) rounded = thick.y;\n    // Get the distance from the line to the point.\n    float d = distance(pA, pB);\n    // Get the distance from the point to the line.\n    float d2 = distance(uv, pA);\n    // Get the distance from the point to the line.\n    float d3 = distance(uv, pB);\n    // Get the distance from the point to the line.\n    float d4 = distance(uv, pA + (pB - pA) * 0.5);\n    // Get the distance from the point to the line.\n    float d5 = distance(uv, pB + (pA - pB) * 0.5);\n    // Get the distance from the point to the line.\n    float d6 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n    // Get the distance from the point to the line.\n    float d7 = distance(uv, pB + (pA - pB) * 0.5 + (pA - pB) * 0.5);\n    // Get the distance from the point to the line.\n    float d8 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n    // Get the distance from the point to the line.\n    float d9 = distance(uv, pB + (pA - pB) * 0.5 + (pA - pB) * 0.5 + (pA - pB) * 0.5);\n    // Get the distance from the point to the line.\n    float d10 = distance(uv, pA + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5 + (pB - pA) * 0.5);\n    // Get the distance from the point to the line.\n    float d11 = distance(uv, pB", "\n    float k = 0.0;\n    k += (1.0 - step( 0.0, ddx.x )) * (1.0 - step( 0.0, ddy.y ));\n    k += (1.0 - step( 0.0, ddx.y )) * (1.0 - step( 0.0, ddy.x ));\n    return k;\n}\n\nfloat", "\n    float tmin = 0.001, tmax = 1000.0;\n    float t = 0.0;\n    float tmin2 = 0.001, tmax2 = 1000.0;\n    float t2 = 0.0;\n    float tmin3 = 0.001, tmax3 = 1000.0;\n    float t3 = 0.0;\n    float tmin4 = 0.001, tmax4 = 1000.0;\n    float t4 = 0.0;\n    float tmin5 = 0.001, tmax5 = 1000.0;\n    float t5 = 0.0;\n    float tmin6 = 0.001, tmax6 = 1000.0;\n    float t6 = 0.0;\n    float tmin7 = 0.001, tmax7 = 1000.0;\n    float t7 = 0.0;\n    float tmin8 = 0.001, tmax8 = 1000.0;\n    float t8 = 0.0;\n    float tmin9 = 0.001, tmax9 = 1000.0;\n    float t9 = 0.0;\n    float tmin10 = 0.001, tmax10 = 1000.0;\n    float t10 = 0.0;\n    float tmin11 = 0.001, tmax11 = 1000.0;\n    float t11 = 0.0;\n    float tmin12 = 0.001, tmax12 = 1000.0;\n    float t12 = 0.0;\n    float tmin13 = 0.001, tmax13 = 1000.0;\n    float t13 = 0.0;\n    float tmin14 = 0.001, tmax14 = 1000.0;\n    float t14 = 0.0;\n    float tmin15 = 0.001, tmax15 = 1000.", "\n\tvec3 n = (cen - ro) / rd;\n\tvec3 f = fract(n);\n\tvec3 e = (cen + rad) - ro;\n\tvec3 t = e / rd;\n\tvec3 s = sign(e);\n\tvec3 t1 = min(t, f);\n\tvec3 t2 = max(t, f);\n\tvec3 tf = max(t1, t2);\n\tvec3 ts = min(s, tf);\n\treturn ts;\n}\n\n// ray-sphere intersection (simplified)\nvec", "\n    vec3 ab = pb - pa;\n    vec3 abn = normalize(ab);\n    // center the cylinder\n    vec3 oc = ro - pa;\n    // ray-cylinder intersection\n    float tca = dot(oc, abn);\n    if( tca < 0.0 ) return vec4(0.0);\n    float d2 = dot(oc, oc) - tca*tca;\n    if( d2 > ra*ra ) return vec4(0.0);\n    float thc = sqrt( ra*ra - d2 );\n    float t0 = tca - thc;\n    float t1 = tca + thc;\n    // find the nearest t value\n    float t = t0 < 0.0? t1 : t0;\n    // find the normal\n    vec3 n = abn * sign(tca - ra) + abn * sign(tca + ra);\n    return vec4(t, n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec", "\n  vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon radius\n  float balloonRadius = 0.05;\n  \n  // Then we define our balloon height\n  float balloonHeight = 0.05;\n  \n  // Then we define our balloon width\n  float balloonWidth = 0.05;\n  \n  // Then we define our balloon depth\n  float balloonDepth = 0.05;\n  \n  // Then we define our balloon texture\n  vec4 balloonTexture = vec4( 1.0, 1.0, 1.0, 1.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor = vec3( 1.0, 1.0, 1.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial = 0.0;\n  \n  // Then we define our balloon texture\n  vec4 balloonTexture2 = vec4( 1.0, 1.0, 1.0, 1.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor2 = vec3( 1.0, 1.0, 1.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial2 = 0.0;\n  \n  // Then we define our balloon texture\n  vec4 balloonTexture3 = vec4( 1.0, 1.0, 1.0, 1.0 );\n  \n  // Then we define our balloon color\n  vec3 balloonColor3 = vec3( 1.0, 1.0, 1.0 );\n  \n  // Then we define our balloon material\n  float balloonMaterial3 = 0.0;\n  \n  // Then we define our balloon texture\n  vec4 balloonTexture4 = vec4( 1.0, 1.0, 1.0, 1.0 );\n  \n  // Then we define our balloon", "\n  float distanceToSurface = INFINITY;\n  vec2 hitCoordinates = vec2(0.0);\n\n  // we will loop through all the objects in the scene\n  for( int i = 0; i < NUMBER_OF_OBJECTS; i++ ){\n\n    // we will check if the ray hits the object\n    // if it does, we will store the distance to the surface\n    // and the coordinates of the hit\n    if( rayHit( eyePosition, rayDirection, objects[i] ) ){\n      distanceToSurface = distance( eyePosition, objects[i].position );\n      hitCoordinates = objects[i].coordinates;\n    }\n  }\n\n  // if we did not hit anything, we will return a default value\n  if( distanceToSurface == INFINITY ){\n    return vec2(0.0);\n  }\n\n  // if we did hit something, we will return the coordinates of the hit\n  return hitCoordinates;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n", "\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 -", "'s hash function\n    n = (n << 13) ^ n;\n    n = (n * (n * n * 15731 + 789221) + 1376312589);\n    return 1.0 - float(n & 0x7fffffff) / 1073741824.0;\n}\n\nfloat", "\n\tvec2 p = fragCoord.xy / iResolution.xy;\n\tvec2 q = p - 0.5;\n\tq.x *= iResolution.x / iResolution.y;\n\tvec3 ro2 = ro + q.x*rd.x*iResolution.x + q.y*rd.y*iResolution.y;\n\tvec3 rd2 = rd;\n\t\n\t//camera\n\tfloat fov = 60.0;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tfloat znear = 0.01;\n\tfloat zfar = 100.0;\n\tvec3 up = vec3(0.0, 1.0, 0.0);\n\tvec3 right = cross(rd2, up);\n\tvec3 forward = cross(right, rd2);\n\t\n\tvec3 ro3 = ro2;\n\tvec3 rd3 = normalize(ro3 + znear*forward + q.x*right + q.y*up);\n\t\n\t//camera\n\tvec3 ro4 = ro3;\n\tvec3 rd4 = normalize(ro4 + znear*forward + q.x*right + q.y*up);\n\t\n\t//camera\n\tvec3 ro5 = ro4;\n\tvec3 rd5 = normalize(ro5 + znear*forward + q.x*right + q.y*up);\n\t\n\t//camera\n\tvec3 ro6 = ro5;\n\tvec3 rd6 = normalize(ro6 + znear*forward + q.x*right + q.y*up);\n\t\n\t//camera\n\tvec3 ro7 = ro6;\n\tvec3 rd7 = normalize(ro7 + znear*forward + q.x*right + q.y*up);\n\t\n\t//camera\n\tvec3 ro8 = ro7;\n\tvec3 rd8 = normalize(ro8 + znear*forward + q.x*right + q.y*up);\n\t\n\t//camera\n\tvec3 ro9 = ro8;\n\tvec3 rd9 = normalize(ro", " 10.10.100.100\n    // 10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n   //{\n   //    pos.x=x;\n   //    pos.y=sin(x*2.);\n   //    pos.z=cos(x*2.);\n   //}\n   \n   return pos.xy;\n}\n\n//------------------------------------------------------------------\n\nvoid main()\n{\n    vec2 uv = map( vPosition );\n    vec4 color = texture2D( texture, uv );\n    gl_FragColor = color;\n}\n", "\n    vec3 q = p - vec3( 0.5 );\n    float d = length( q );\n    return d * 0.5;\n}\n\n//=====================================================\n\nfloat", "\n    vec4 p = cam * sph;\n\n    // project to screen space\n    vec2 p2 = fle * p.xy / p.w;\n\n    // compute axis lengths\n    float axisMinor = length(p2 - vec2(p.x, p.y));\n    float axisMajor = length(p2 - vec2(p.z, p.w));\n\n    // compute center\n    vec2 center = vec2(p.x, p.y) + vec2(p.z, p.w);\n\n    // compute coefficients\n    float a = p2.x - center.x;\n    float b = p2.y - center.y;\n    float c = axisMinor;\n    float d = p2.x - center.x;\n    float e = p2.y - center.y;\n    float f = axisMajor;\n\n    return ProjectionResult(center, axisMinor, axisMajor, a, b, c, d, e, f);\n}\n\n// ---------------------------------------------------------------------------------------------\n\nstruct ProjectionResult\n{\n    vec2  center;\n    float axisMinor;\n    float axisMajor;\t\n\tfloat a, b, c, d, e, f;\n};\n\nProjectionResult projectSphere( /* sphere        */ in vec4 sph, \n\t\t\t\t                /* camera matrix */ in mat4 cam,\n\t\t\t\t\t\t\t    /* projection    */ in float fle )\n{\n    // transform to camera space\t\n    vec4 p = cam * sph;\n\n    // project to screen space\n    vec2 p2 = fle * p.xy / p.w;\n\n    // compute axis lengths\n    float axisMinor = length(p2 - vec2(p.x, p.y));\n    float axisMajor = length(p2 - vec2(p.z, p.w));\n\n    // compute center\n    vec2 center = vec2(p.x, p.y) + vec2(p.z, p.w);\n\n    // compute coefficients\n    float a = p2.x - center.x;\n    float b = p2.y -", "\n    //res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.35,-2.0), vec2(0.15, 0.2) ), 12.0 ) );\n    //res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), vec3(0.15, 0.2, 0.1) ), 13.0 ) );\n    //res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.35,-2.0), vec2(0.15, 0.2) ), 12.0 ) );\n    //res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), vec3(0.15, 0.2, 0.1) ), 13.0 ) );\n    //res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.35,-2.0), vec2(0.15, 0.2) ), 12.0 ) );\n    //res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), vec3(0.15, 0.2, 0.1) ), 13.0 ) );\n    //res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.35,-2.0), vec2(0.15, 0.2) ), 12.0 ) );\n    //res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), vec3(0.15, 0.2, 0.1) ), 13.0 ) );", "\n    vec3 p = floor(x);\n    vec3 f = fract(x);\n    vec3 u = f*f*(3.0-2.0*f);\n    return mix(mix(p.x,p.y,u.x),mix(p.z,p.y,u.x),u.y);\n}\n\nvec", "\n    float tmin = 0.0;\n    float tmax = 10000.0;\n    float t = 0.0;\n    float tmin_sphere = 10000.0;\n    float tmin_plane = 10000.0;\n    float tmin_cylinder = 10000.0;\n    float tmin_cone = 10000.0;\n    float tmin_capsule = 10000.0;\n    float tmin_capsule_2 = 10000.0;\n    float tmin_capsule_3 = 10000.0;\n    float tmin_capsule_4 = 10000.0;\n    float tmin_capsule_5 = 10000.0;\n    float tmin_capsule_6 = 10000.0;\n    float tmin_capsule_7 = 10000.0;\n    float tmin_capsule_8 = 10000.0;\n    float tmin_capsule_9 = 10000.0;\n    float tmin_capsule_10 = 10000.0;\n    float tmin_capsule_11 = 10000.0;\n    float tmin_capsule_12 = 10000.0;\n    float tmin_capsule_13 = 10000.0;\n    float tmin_capsule_14 = 10000.0;\n    float tmin_capsule_15 = 10000.0;\n    float tmin_capsule_16 = 10000.0;\n    float tmin_capsule_17 = 10000.0;\n    float tmin_capsule_18 = 10000.0;\n    float tmin_capsule_19 = 10000.0;\n    float tmin_capsule_20 = 10000.0;\n   ", " the scene\n    float tmin = 0.0;\n    float tmax = 10000.0;\n    float t = 0.0;\n    float tmin_sphere = 10000.0;\n    float tmax_sphere = 0.0;\n    float tmin_plane = 10000.0;\n    float tmax_plane = 0.0;\n    float tmin_cylinder = 10000.0;\n    float tmax_cylinder = 0.0;\n    float tmin_cone = 10000.0;\n    float tmax_cone = 0.0;\n    float tmin_capsule = 10000.0;\n    float tmax_capsule = 0.0;\n    float tmin_triangle = 10000.0;\n    float tmax_triangle = 0.0;\n    float tmin_capsule_triangle = 10000.0;\n    float tmax_capsule_triangle = 0.0;\n    float tmin_capsule_capsule = 10000.0;\n    float tmax_capsule_capsule = 0.0;\n    float tmin_capsule_capsule_triangle = 10000.0;\n    float tmax_capsule_capsule_triangle = 0.0;\n    float tmin_capsule_capsule_capsule = 10000.0;\n    float tmax_capsule_capsule_capsule = 0.0;\n    float tmin_capsule_capsule_capsule_triangle = 10000.0;\n    float tmax_capsule_capsule_capsule_triangle = 0.0;\n    float tmin_capsule_capsule_capsule_capsule = 10000.0;\n    float tmax_capsule_capsule_capsule_capsule = 0.0;\n    float tmin_capsule_capsule_capsule_capsule", "\n\tfloat k = 1.0 / ( 2.0 * ( ddx.x * ddy.y - ddy.x * ddx.y ) );\n\n\t// sample texture\n\tvec2 dp = ddx * ddy;\n\tfloat n = textureGrad( iChannel0, p, dp, dp ).x;\n\n\t// return filtered value\n\treturn n * k;\n}\n\n//------------------------------------------------------------------------------\n// grid ratio\nfloat", " of the grid\n    vec2 ij = floor(p);\n    vec2 f = fract(p);\n\n    // distance from the grid\n    float d = distance(p, ij);\n\n    // fade-in/out\n    float a = 1.0;\n    if(d < 0.001)\n        a = 0.0;\n\n    // fade-in/out\n    float b = 1.0;\n    if(d > 0.001)\n        b = 0.0;\n\n    // fade-in/out\n    float c = 1.0;\n    if(d < 0.001)\n        c = 0.0;\n\n    // fade-in/out\n    float dd = 1.0;\n    if(d > 0.001)\n        dd = 0.0;\n\n    // fade-in/out\n    float e = 1.0;\n    if(d < 0.001)\n        e = 0.0;\n\n    // fade-in/out\n    float fd = 1.0;\n    if(d > 0.001)\n        fd = 0.0;\n\n    // fade-in/out\n    float g = 1.0;\n    if(d < 0.001)\n        g = 0.0;\n\n    // fade-in/out\n    float h = 1.0;\n    if(d > 0.001)\n        h = 0.0;\n\n    // fade-in/out\n    float i = 1.0;\n    if(d < 0.001)\n        i = 0.0;\n\n    // fade-in/out\n    float j = 1.0;\n    if(d > 0.001)\n        j = 0.0;\n\n    // fade-in/out\n    float k = 1.0;\n    if(d < 0.001)\n        k = 0.0;\n\n    // fade-in/out\n    float l = 1.0;\n    if(d > 0.001)\n        l = 0.0;\n\n    // fade-", "\n    float tmin = 0.001, tmax = 1000.0;\n    float t = 0.0;\n    float tmin2 = 0.001, tmax2 = 1000.0;\n    float t2 = 0.0;\n    float tmin3 = 0.001, tmax3 = 1000.0;\n    float t3 = 0.0;\n    float tmin4 = 0.001, tmax4 = 1000.0;\n    float t4 = 0.0;\n    float tmin5 = 0.001, tmax5 = 1000.0;\n    float t5 = 0.0;\n    float tmin6 = 0.001, tmax6 = 1000.0;\n    float t6 = 0.0;\n    float tmin7 = 0.001, tmax7 = 1000.0;\n    float t7 = 0.0;\n    float tmin8 = 0.001, tmax8 = 1000.0;\n    float t8 = 0.0;\n    float tmin9 = 0.001, tmax9 = 1000.0;\n    float t9 = 0.0;\n    float tmin10 = 0.001, tmax10 = 1000.0;\n    float t10 = 0.0;\n    float tmin11 = 0.001, tmax11 = 1000.0;\n    float t11 = 0.0;\n    float tmin12 = 0.001, tmax12 = 1000.0;\n    float t12 = 0.0;\n    float tmin13 = 0.001, tmax13 = 1000.0;\n    float t13 = 0.0;\n    float tmin14 = 0.001, tmax14 = 1000.0;\n    float t14 = 0.0;\n    float tmin15 = 0.001, tmax15 = 1000.", "\n    float f = sin(p.x*10.0)*sin(p.y*10.0);\n    f = abs(f);\n    f = smoothstep(0.0, 1.0, f);\n    return f;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec2 q = mod(p,5.0);\n    // repeat domain 5x\n    vec2 r = mod(p,5.0);\n    // repeat domain 5x\n    vec2 s = mod(p,5.0);\n    // repeat domain 5x\n    vec2 t = mod(p,5.0);\n    // repeat domain 5x\n    vec2 u = mod(p,5.0);\n    // repeat domain 5x\n    vec2 v = mod(p,5.0);\n    // repeat domain 5x\n    vec2 w = mod(p,5.0);\n    // repeat domain 5x\n    vec2 x = mod(p,5.0);\n    // repeat domain 5x\n    vec2 y = mod(p,5.0);\n    // repeat domain 5x\n    vec2 z = mod(p,5.0);\n    // repeat domain 5x\n    vec2 a = mod(p,5.0);\n    // repeat domain 5x\n    vec2 b = mod(p,5.0);\n    // repeat domain 5x\n    vec2 c = mod(p,5.0);\n    // repeat domain 5x\n    vec2 d = mod(p,5.0);\n    // repeat domain 5x\n    vec2 e = mod(p,5.0);\n    // repeat domain 5x\n    vec2 f = mod(p,5.0);\n    // repeat domain 5x\n    vec2 g = mod(p,5.0);\n    // repeat domain 5x\n    vec2 h = mod(p,5.0);\n    // repeat domain 5x\n    vec2 i = mod(p,5.0);\n    // repeat domain 5x\n    vec2 j = mod(p,5.0);\n    // repeat domain 5x\n    vec2 k = mod(p,5.0);\n    // repeat domain 5x\n    vec2 l = mod(p,5.0);\n    // repeat domain 5x\n    vec2 m", "\n    vec2 p01 = mix(p0, p1, 0.5);\n    vec2 p12 = mix(p1, p2, 0.5);\n    vec2 p20 = mix(p2, p0, 0.5);\n\n    // midpoints\n    vec2 p012 = mix(p01, p12, 0.5);\n    vec2 p120 = mix(p12, p20, 0.5);\n    vec2 p201 = mix(p20, p01, 0.5);\n\n    // corners\n    vec2 p0120 = mix(p012, p120, 0.5);\n    vec2 p1201 = mix(p120, p201, 0.5);\n    vec2 p2010 = mix(p201, p012, 0.5);\n\n    // return the smallest rectangle that contains all the points\n    return vec4(min(min(p0120.x, p1201.x), p2010.x),\n                min(min(p0120.y, p1201.y), p2010.y),\n                max(max(p0120.x, p1201.x), p2010.x),\n                max(max(p0120.y, p1201.y), p2010.y));\n}\n\n// Approximate the bounding box of a quadratic bezier curve\nvec", "\n    vec3 bmin = min( min( min( p0, p1 ), p2 ), p3 );\n    vec3 bmax = max( max( max( p0, p1 ), p2 ), p3 );\n\n    // center\n    vec3 bcenter = 0.5 * ( bmin + bmax );\n\n    // diagonal\n    vec3 bdiag = bmax - bmin;\n\n    // return\n    return bound3( bcenter - 0.5 * bdiag, bcenter + 0.5 * bdiag );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://iquilezles.org/www/articles/spheresphere/spheresphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 q, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://iquilezles.org/www/articles/conecone/conecone.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 p, in vec3 q, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 q, in float r )\n{\n    return bound3", "\n\tvec3 n = (cen - ro) / rd;\n\tvec3 f = fract(n);\n\tvec3 e = (cen + rad) - ro;\n\tvec3 t = e / rd;\n\tvec3 s = sign(e);\n\tvec3 t1 = min(t, f);\n\tvec3 t2 = max(t, f);\n\tvec3 tf = max(t1, t2);\n\tvec3 ts = min(s, tf);\n\treturn ts;\n}\n\n// ray-sphere intersection (simplified)\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvoid main()\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n", "\n    float t = iTime;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    // 2D texture input, we get a 2D texture from the image\n    vec2 uv = fragCoord.xy / iResolution", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n\nvoid main()\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n\n    // Time varying pixel color\n    vec3 light = vec3(0.0);\n\n    // Rotate the light\n    float t = iTime*0.5;\n    float r = cos(t);\n    float i = sin(t);\n    mat2 rot = mat2(r, -i, i, r);\n    light = rot*light;\n\n    // Rotate the sphere\n    t = iTime*0.25;\n    r = cos(t);\n    i = sin(t);\n    mat2 rot2 = mat2(r, -i, i, r);\n    p = rot2*p;\n\n    // Rotate the sphere\n    t = iTime*0.125;\n    r = cos(t);\n    i = sin(t);\n    mat2 rot3 = mat2(r, -i, i, r);\n    p = rot3*p;\n\n    // Rotate the sphere\n    t = iTime*0.0625;\n    r = cos(t);\n    i = sin(t);\n    mat2 rot4 = mat2(r, -i, i, r);\n    p = rot4*p;\n\n    // Rotate the sphere\n    t = iTime*0.03125;\n    r = cos(t);\n    i = sin(t);\n    mat2 rot5 = mat2(r, -i, i, r);\n    p = rot5*p;\n\n    // Rotate the sphere\n    t = iTime*0.015625;\n    r = cos(t);\n    i = sin(t);\n    mat2 rot6 = mat2(r, -i, i, r);\n    p = rot6*p;\n\n    // Rotate the sphere\n    t = iTime*0.0078", "\n    float f = sin(p.x*10.0)*sin(p.y*10.0);\n    f = abs(f);\n    f = smoothstep(0.0, 1.0, f);\n    return f;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec3 ab = pb - pa;\n    vec3 ac = pa - ro;\n    vec3 abn = normalize(ab);\n    vec3 acn = normalize(ac);\n\n    // solve quadratic equation\n    float b = dot(abn, acn);\n    float c = dot(abn, abn) - ra*ra;\n    float h = b*b - c;\n    if (h < 0.0) return vec4(0.0);\n    h = sqrt(h);\n\n    // find the nearest root\n    float t0 = b - h;\n    float t1 = b + h;\n    if (t0 > t1) {\n        t0 = t1;\n    }\n\n    // find the point on the ray\n    vec3 pt = ro + t0*rd;\n\n    // check if the point is inside the cylinder\n    vec3 pt2 = pt - pa;\n    float d = dot(pt2, abn);\n    if (d < 0.0) return vec4(0.0);\n    float d2 = dot(pt2, pt2) - ra*ra;\n    if (d2 > d) return vec4(0.0);\n\n    // return the point on the cylinder\n    return vec4(abn, t0);\n}\n\n//-----------------------------------------------------------------\n// ray - sphere intersection, return.xyz=normal, return.w=distance\n//   https://www.shadertoy.com/view/MtcXRf\n//-----------------------------------------------------------------\nvec", "\n    vec3 ab = pb - pa;\n    vec3 ac = normalize(cross(ab, vec3(0.0, 1.0, 0.0)));\n    vec3 ba = pa - ab;\n    vec3 bc = normalize(cross(ba, ac));\n\n    // cylinder axis\n    vec3 abc = cross(ab, ac);\n\n    // cylinder radius\n    float r2 = ra * ra;\n\n    // cylinder plane equation\n    float b = dot(bc, pa);\n    float c = dot(bc, rd);\n\n    // cylinder plane intersection\n    float t0 = (-b - sqrt(b*b - 4.0*c)) / 2.0;\n    float t1 = (-b + sqrt(b*b - 4.0*c)) / 2.0;\n\n    // cylinder plane intersection\n    vec3 p0 = ro + t0 * rd;\n    vec3 p1 = ro + t1 * rd;\n\n    // cylinder plane intersection\n    vec3 n0 = normalize(p0 - pa);\n    vec3 n1 = normalize(p1 - pa);\n\n    // cylinder plane intersection\n    float d0 = dot(n0, abc);\n    float d1 = dot(n1, abc);\n\n    // cylinder plane intersection\n    if (d0 > 0.0 && d1 > 0.0)\n    {\n        // cylinder plane intersection\n        if (t0 > 0.0)\n        {\n            // cylinder plane intersection\n            return vec4(n0, t0);\n        }\n        else\n        {\n            // cylinder plane intersection\n            return vec4(n1, t1);\n        }\n    }\n    else\n    {\n        // cylinder plane intersection\n        if (t0 > 0.0)\n        {\n            // cylinder plane intersection\n            return vec4(n0, t0);\n        }\n        else\n        {\n            // cylinder plane intersection\n            return vec4(n1, t1);\n        }\n    }\n}\n\n//-----------------------------------------------------------------\n// ray - endless cone intersection, return", "\n    vec3 ab = b - a;\n    float h = length(ab);\n    float k = dot(p - a, ab) / h;\n    if (k < 0.0) return length(p - a);\n    if (k > 1.0) return length(p - b);\n\n    // sampling dependent computations (depend on shape)\n    vec3 c = a + k * ab;\n    float d = length(p - c);\n    if (d < r1) return r1 - d;\n    if (d < r2) return r2 - d;\n    return length(p - b);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nfloat", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// 2D Perlin noise\nfloat", "\n    float f = sin(p.x * 10.0) * sin(p.y * 10.0);\n    f = abs(f);\n    f = smoothstep(0.0, 1.0, f);\n    return f;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n\t vec3 s = floor(p);\n\t vec3 x = p - s;\n\t \n\t /* calculate i1, i2, 1.0 - the integer coordinates of the four corners of T */\n\t vec3 i1 = step(vec3(0.0), x - vec3(0.0, 0.0, 1.0));\n\t vec3 i2 = step(vec3(1.0), x - vec3(1.0, 0.0, 1.0));\n\t vec3 i3 = step(vec3(1.0), x - vec3(1.0, 1.0, 1.0));\n\t vec3 i4 = step(vec3(0.0), x - vec3(0.0, 1.0, 1.0));\n\t \n\t /* calculate the contribution from the four corners */\n\t vec3 x1 = x - i1 + (i2 - i1) * vec3(0.0, 0.0, 1.0);\n\t vec3 x2 = x - i2 + (i3 - i2) * vec3(0.0, 0.0, 1.0);\n\t vec3 x3 = x - i3 + (i4 - i3) * vec3(0.0, 0.0, 1.0);\n\t vec3 x4 = x - i4 + (i1 - i4) * vec3(0.0, 0.0, 1.0);\n\t \n\t /* calculate the contribution from the four vertices */\n\t float n1 = dot(x, x);\n\t float n2 = dot(x1, x1);\n\t float n3 = dot(x2, x2);\n\t float n4 = dot(x3, x3);\n\t float n5 = dot(x4, x4);\n\t \n\t /* calculate the 4x4 dot product matrix */\n\t mat2 m = mat2(n1, n2, n3, n4);\n\t \n\t /* calculate the 4x4 dot product */\n\t float n = m[0][0] + m[1", "\n    return fract(sin(dot(v, vec2(12.1215, 23.02751))) * 541.9283);\n}\n\nfloat", "\n    float f = sin(p.x*10.0)*sin(p.y*10.0);\n    f = abs(f);\n    f = smoothstep(0.0, 1.0, f);\n    return f;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec3 q = p;\n    q.xz = q.xz * mat2( 1.0, 0.0, 0.0, 1.0 );\n    q.yz = q.yz * mat2( 1.0, 0.0, 0.0, 1.0 );\n    q.xy = q.xy * mat2( 1.0, 0.0, 0.0, 1.0 );\n\n    // rotate\n    q = q * mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 );\n\n    // translate\n    q = q + vec3( 0.0, 0.0, 0.0 );\n\n    // scale\n    q = q * vec3( 1.0, 1.0, 1.0 );\n\n    // map\n    vec2 r = vec2( 0.0 );\n    r.x = q.x * 0.5 + 0.5;\n    r.y = q.y * 0.5 + 0.5;\n    r.x = r.x * 2.0 - 1.0;\n    r.y = r.y * 2.0 - 1.0;\n\n    // rotate\n    r = r * mat2( 1.0, 0.0, 0.0, 1.0 );\n\n    // translate\n    r = r + vec2( 0.5, 0.5 );\n\n    // map\n    r = r * vec2( 1.0, 1.0 );\n\n    // scale\n    r = r * vec2( 2.0, 2.0 );\n\n    // map\n    r = r * vec2( 1.0, 1.0 );\n\n    // scale\n    r = r * vec2( 2.0, 2.0 );\n\n    // map\n    r = r * vec2( 1.0, 1.", "\n    float f = sin(p.x*10.0)*sin(p.y*10.0);\n    f = abs(f);\n    f = smoothstep(0.0, 1.0, f);\n    return f;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec3 q = p;\n    q.xz = q.xz * mat2( 1.0, 0.0, 0.0, 1.0 );\n    q.yz = q.yz * mat2( 1.0, 0.0, 0.0, 1.0 );\n    q.xy = q.xy * mat2( 1.0, 0.0, 0.0, 1.0 );\n\n    // rotate\n    q = q * mat3( 1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 1.0 );\n\n    // translate\n    q = q + vec3( 0.0, 0.0, 0.0 );\n\n    // scale\n    q = q * vec3( 1.0, 1.0, 1.0 );\n\n    // map\n    vec2 r = vec2( 0.0 );\n    r.x = q.x * 0.5 + 0.5;\n    r.y = q.y * 0.5 + 0.5;\n    r.x = r.x * 2.0 - 1.0;\n    r.y = r.y * 2.0 - 1.0;\n\n    // rotate\n    r = r * mat2( 1.0, 0.0, 0.0, 1.0 );\n\n    // translate\n    r = r + vec2( 0.5, 0.5 );\n\n    // map\n    r = r * vec2( 1.0, 1.0 );\n\n    // scale\n    r = r * vec2( 2.0, 2.0 );\n\n    // map\n    r = r * vec2( 1.0, 1.0 );\n\n    // scale\n    r = r * vec2( 2.0, 2.0 );\n\n    // map\n    r = r * vec2( 1.0, 1.", "\n    float f = sin(p.x*10.0)*sin(p.y*10.0);\n    f = abs(f);\n    f = smoothstep(0.0, 1.0, f);\n    return f;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n    float res = 1.0;\n    for( int i=0; i<50; i++ )\n    {\n        // get the distance to the light\n        float d = map( bv );\n        // if the distance is negative, the light is behind us\n        if( d<0.0 )\n            return 0.0;\n        // if the distance is too far, we are outside the shadow\n        if( d>tmax )\n            return 1.0;\n        // update the bounding volume\n        bv = bv + d*rd;\n        // update the shadow\n        res = min( res, mint*d/bv.w );\n        // if the shadow is too small, we are outside the shadow\n        if( res<0.001 )\n            return 0.0;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float f = sin(p.x*10.0)*sin(p.y*10.0);\n    f = abs(f);\n    f = smoothstep(0.0, 1.0, f);\n    return f;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    float a = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec4 q = vec4(rd.x, rd.y, rd.z, -ra);\n    vec4 k = vec4(1.0, 1.0, 1.0, -4.0) * q;\n    vec4 u = vec4(1.0, 1.0, 1.0, 4.0) * q;\n    vec4 disc = k * k - u;\n    float h = clamp( disc.x + disc.y + disc.z, 0.0, 1.0 );\n    float t = mix( q.w, sqrt( h ), h );\n\n    // -----------------------------\n    // solve cubic equation\n    // -----------------------------\n    vec3 p = vec3(t, t, t) - k;\n    float e = max( max( p.x, p.y ), p.z );\n    vec3 q = clamp( abs(p) - vec3(e), 0.0, 1.0 );\n    float d = q.x*q.x + q.y*q.y;\n    if( d > 1.0 )\n    {\n        return 1.0;\n    }\n    float t1 = q.x > 0.0? -q.y : q.y;\n    float t2 = q.x > 0.0? q.x : -q.x;\n    return 1.0 - (d * (t1 + t2) + e) / ra;\n}\n\n// -----------------------------\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat", "\n    vec3 col = vec3(0.0);\n\n    // raymarching\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        d = map( p );\n        t += d;\n        p = ro + rd * t;\n        if( d < 0.001 ) break;\n    }\n\n    // lighting\n    vec3 n = normal( p );\n    vec3 l = normalize( vec3( 1.0, 0.9, 0.3 ) );\n    vec3 v = normalize( ro - p );\n    vec3 r = reflect( -rd, n );\n    float s = max( 0.0, dot( n, l ) );\n    float s2 = max( 0.0, dot( n, v ) );\n    float s3 = max( 0.0, dot( n, r ) );\n    vec3 c = vec3( 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0", " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n    float res = 1.0;\n    for( int i=0; i<50; i++ )\n    {\n        // get the distance to the light\n        float d = map( bv );\n        // if the distance is negative, the light is behind us\n        if( d<0.0 )\n            return 0.0;\n        // if the distance is too far, we are outside the shadow\n        if( d>tmax )\n            return 1.0;\n        // update the bounding volume\n        bv = bv + d*rd;\n        // update the shadow\n        res = min( res, mint*d/bv.w );\n        // if the shadow is too small, we are outside the shadow\n        if( res<0.001 )\n            return 0.0;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float f = (fract(p.x+p.y)>0.5)? 1.0 : 0.0;\n\n    // gradient\n    vec2 g = vec2( dpdx.x, dpdy.y ) - vec2( dpdx.y, -dpdy.x );\n\n    // dot product\n    return f * dot(g,g);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    start += planet_position;\n\n    // the color of the rayleigh scattering\n    vec3 rayleigh_color = vec3(0.0);\n\n    // the color of the mie scattering\n    vec3 mie_color = vec3(0.0);\n\n    // the color of the absorption\n    vec3 absorption_color = vec3(0.0);\n\n    // the color of the ambient\n    vec3 ambient_color = vec3(0.0);\n\n    // the color of the final result\n    vec3 final_color = vec3(0.0);\n\n    // the color of the light\n    vec3 light_color = vec3(0.0);\n\n    // the color of the atmosphere\n    vec3 atmosphere_color = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_2 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_2 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_3 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_3 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_4 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_4 = vec3(0.0);\n\n    // the color of the back side of the atmosphere\n    vec3 back_color_5 = vec3(0.0);\n\n    // the color of the front side of the atmosphere\n    vec3 front_color_5 = vec3(0", "\n    vec3 oc = start - vec3(0.0);\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return vec2(-1.0, -1.0);\n    }\n    float sqrt_discriminant = sqrt(discriminant);\n    float result_1 = (-b - sqrt_discriminant) / (2.0 * a);\n    float result_2 = (-b + sqrt_discriminant) / (2.0 * a);\n    if (result_1 > result_2) {\n        return vec2(result_2, result_1);\n    }\n    return vec2(result_1, result_2);\n}\n\n/*\nA ray-plane intersect\nThis was previously used in the atmosphere as well, but it's only used for the planet intersect now, since the atmosphere has this\nray plane intersect built in\n*/\n\nvec", "\n    vec3 light_dir_bend = normalize(light_dir + surface_normal * 0.001);\n\n    // sample the skylight\n    vec3 skylight_sample = texture(skylight_tex, sample_pos.xy).rgb;\n\n    // sample the skylight in the direction of the light direction\n    vec3 skylight_sample_light = texture(skylight_tex, sample_pos.xy + light_dir_bend * 0.001).rgb;\n\n    // mix the skylight samples\n    vec3 skylight_mix = mix(skylight_sample, skylight_sample_light, 0.5);\n\n    // mix the skylight with the background color\n    vec3 skylight_mix_background = mix(skylight_mix, background_col, 0.5);\n\n    // return the skylight mix\n    return skylight_mix_background;\n}\n\n/*\nThis function takes a sample position and a surface normal and returns the color of the skylight\n*/\nvec", "\n    vec4 color = vec4(0.0, 1.0, 0.0, 1.0);\n    \n    // the distance to the surface\n    float dist = length(pos);\n    \n    // the color of the sphere\n    vec3 sphere_color = vec3(0.0, 1.0, 0.0);\n    \n    // the distance to the sphere\n    float sphere_dist = length(pos - vec3(0.0, 0.0, 0.0));\n    \n    // the color of the light\n    vec3 light_color = vec3(1.0, 1.0, 1.0);\n    \n    // the distance to the light\n    float light_dist = length(pos - light_dir);\n    \n    // the color of the atmosphere\n    vec3 atmosphere_color = vec3(0.0, 0.0, 0.0);\n    \n    // the distance to the atmosphere\n    float atmosphere_dist = dist - 10.0;\n    \n    // the color of the sky\n    vec3 sky_color = vec3(0.0, 0.0, 0.0);\n    \n    // the distance to the sky\n    float sky_dist = 100.0;\n    \n    // the color of the ground\n    vec3 ground_color = vec3(0.0, 0.0, 0.0);\n    \n    // the distance to the ground\n    float ground_dist = 10.0;\n    \n    // the color of the water\n    vec3 water_color = vec3(0.0, 0.0, 1.0);\n    \n    // the distance to the water\n    float water_dist = 1.0;\n    \n    // the color of the sun\n    vec3 sun_color = vec3(1.0, 1.0, 0.0);\n    \n    // the distance to the sun\n    float sun_dist = 100.0;\n    \n    // the color of the moon\n    vec3 moon_color = vec3(0.0", " and position\n    vec3 camPos = cameraPos;\n    vec3 camDir = cameraDir;\n    \n    // get the light dir\n    vec3 lightDir = normalize(lightDir);\n    \n    // get the ray direction\n    vec3 rayDir = normalize(camDir + lightDir);\n    \n    // get the ray origin\n    vec3 rayOrigin = camPos;\n    \n    // get the ray length\n    float rayLength = 1000.0;\n    \n    // get the ray color\n    vec3 rayColor = vec3(0.0);\n    \n    // get the ray step\n    float rayStep = 0.001;\n    \n    // get the ray step\n    float rayStep2 = 0.001;\n    \n    // get the ray step\n    float rayStep3 = 0.001;\n    \n    // get the ray step\n    float rayStep4 = 0.001;\n    \n    // get the ray step\n    float rayStep5 = 0.001;\n    \n    // get the ray step\n    float rayStep6 = 0.001;\n    \n    // get the ray step\n    float rayStep7 = 0.001;\n    \n    // get the ray step\n    float rayStep8 = 0.001;\n    \n    // get the ray step\n    float rayStep9 = 0.001;\n    \n    // get the ray step\n    float rayStep10 = 0.001;\n    \n    // get the ray step\n    float rayStep11 = 0.001;\n    \n    // get the ray step\n    float rayStep12 = 0.001;\n    \n    // get the ray step\n    float rayStep13 = 0.001;\n    \n    // get the ray step\n    float rayStep14 = 0.001;\n    \n    // get the ray step\n    float rayStep15 = 0.001;\n    \n    // get the ray step\n    float rayStep16 = 0.001;\n    \n    // get the ray step\n    float rayStep", " ray\n    vec3 ray_path[MAX_PATHS];\n    ray_path[0] = ray_origin;\n\n    // Initialize the sample color -\n    // the color of the sample ray\n    vec3 sample_color = vec3(0.0);\n\n    // Initialize the sample depth -\n    // the depth of the sample ray\n    float sample_depth = 0.0;\n\n    // Initialize the sample index -\n    // the index of the sample ray in the ray queue\n    int sample_index = 0;\n\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray = ray_target;\n\n    // Initialize the sample ray direction -\n    // the direction of the sample ray\n    vec3 sample_ray_direction = normalize(ray_target - ray_origin);\n\n    // Initialize the sample ray length -\n    // the length of the sample ray\n    float sample_ray_length = length(ray_target - ray_origin);\n\n    // Initialize the sample ray length squared -\n    // the length of the sample ray squared\n    float sample_ray_length_squared = sample_ray_length * sample_ray_length;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed = sample_ray_length_squared * sample_ray_length;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root = sqrt(sample_ray_length_cubed);\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root_inv = 1.0 / sample_ray_length_cubed_root;\n\n    // Initialize the sample ray length cubed -\n    // the length of the sample ray cubed\n    float sample_ray_length_cubed_root_inv_2 = sample_ray_length_cubed_root_inv * sample_ray", "\n    float n = floor(x);\n    float f = fract(x);\n    float u = f * f * (3.0 - 2.0 * f);\n    return mix(\n        noise(n),\n        noise(n + 1.0),\n        u\n    );\n}\n\n// 2D Perlin noise\nfloat", "\n    vec3 q = p;\n    q.xz *= mat2(cos(time),sin(time),-sin(time),cos(time));\n    q.y *= mat2(cos(time),sin(time),-sin(time),cos(time));\n\n    // compute the quadratic polynomial\n    float k = 1.0;\n    vec3 color = vec3(0.0);\n    for ( int i=0; i<5; i++ )\n    {\n        float a = dot(q,q);\n        float b = dot(q,vec3(0.0,0.5,0.0));\n        float c = length(q) - 0.5;\n        float disc = b*b - a*c;\n        if ( disc < 0.0 ) break;\n        float t = -b - sqrt(disc);\n        if ( t > 0.0 )\n        {\n            t /= a;\n            if ( t < k ) k = t;\n        }\n        t = -b + sqrt(disc);\n        if ( t > 0.0 )\n        {\n            t /= a;\n            if ( t < k ) k = t;\n        }\n        q = q*2.0 - vec3(0.0,0.5,0.0);\n    }\n\n    // compute the color\n    color = vec3(0.5) + 0.5*cos(time+k*10.0);\n    return color;\n}\n\n// compute the color at a point\nvec", "\n    vec3 col = vec3(0.0);\n\n    // raymarching\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        d = map( p );\n        t += d;\n        p = ro + rd * t;\n        if( d < 0.001 ) break;\n    }\n\n    // lighting\n    vec3 n = normal( p );\n    vec3 l = normalize( vec3( 1.0, 0.9, 0.3 ) );\n    vec3 v = normalize( ro - p );\n    vec3 r = reflect( -rd, n );\n    float s = max( 0.0, dot( n, l ) );\n    float s2 = max( 0.0, dot( n, v ) );\n    float s3 = max( 0.0, dot( n, r ) );\n    vec3 c = vec3( 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0.0 );\n    c += vec3( 0.0, 0.0, 0", "\n    vec3 bmin = ro - vec3(w);\n    vec3 bmax = ro + vec3(w);\n    \n    // shadow ray\n    float t = tmin;\n    float tmin_shadow = 1.0;\n    float tmax_shadow = 0.0;\n    float tmin_shadow_shadow = 1.0;\n    float tmax_shadow_shadow = 0.0;\n    \n    // shadow ray\n    for (int i = 0; i < 10; i++)\n    {\n        // shadow ray\n        float h = map(ro + rd * t);\n        if (h < tmin)\n        {\n            tmin_shadow = max(tmin_shadow, t);\n        }\n        else if (h > t)\n        {\n            tmax_shadow = min(tmax_shadow, t);\n        }\n        \n        // shadow ray\n        h = map(ro + rd * (t + eps));\n        if (h < tmin)\n        {\n            tmin_shadow_shadow = max(tmin_shadow_shadow, t);\n        }\n        else if (h > t)\n        {\n            tmax_shadow_shadow = min(tmax_shadow_shadow, t);\n        }\n        \n        // bounding volume\n        t += h * 0.5;\n        if (t > tmax)\n        {\n            break;\n        }\n    }\n    \n    // shadow\n    float shadow = smoothstep(tmin_shadow, tmax_shadow, t);\n    float shadow_shadow = smoothstep(tmin_shadow_shadow, tmax_shadow_shadow, t);\n    \n    // shadow\n    return (shadow + shadow_shadow) * 0.5;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float a = time * 0.5;\n    float b = time * 0.5;\n    float c = time * 0.5;\n    float d = time * 0.5;\n    float e = time * 0.5;\n    float f = time * 0.5;\n    float g = time * 0.5;\n    float h = time * 0.5;\n    float i = time * 0.5;\n    float j = time * 0.5;\n    float k = time * 0.5;\n    float l = time * 0.5;\n    float m = time * 0.5;\n    float n = time * 0.5;\n    float o = time * 0.5;\n    float p = time * 0.5;\n    float q = time * 0.5;\n    float r = time * 0.5;\n    float s = time * 0.5;\n    float t = time * 0.5;\n    float u = time * 0.5;\n    float v = time * 0.5;\n    float w = time * 0.5;\n    float x = time * 0.5;\n    float y = time * 0.5;\n    float z = time * 0.5;\n    float aa = time * 0.5;\n    float ab = time * 0.5;\n    float ac = time * 0.5;\n    float ad = time * 0.5;\n    float ae = time * 0.5;\n    float af = time * 0.5;\n    float ag = time * 0.5;\n    float ah = time * 0.5;\n    float ai = time * 0.5;\n    float aj = time * 0.5;\n    float ak = time * 0.5;\n    float al = time * 0.5;\n    float am = time * 0.5;\n    float an = time * 0.5;\n    float ao = time * 0.5;\n    float ap = time * 0.5;\n    float", "\n    //\n    // This is a modified version of the code by Martijn Steinrucken\n    // https://www.shadertoy.com/view/4djSRW\n    //\n    // The original code is licensed under the MIT License\n    // Copyright \u00a9 2019 Martijn Steinrucken\n    // Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n    // Email: countfrolic@gmail.com\n    // Twitter: @The_ArtOfCode\n    // YouTube: youtube.com/TheArtOfCodeIsCool\n    // Facebook: https://www.facebook.com/groups/theartofcode/\n    //\n    // I needed something like this for a logo and I think it might\n    // be useful for other things as well.\n    // It is made by fitting circles together. The code could probably\n    // be simpler, especially if you take just the pinch, or just the bulge.\n    //\n    // See comments for a slightly more compact version by IQ\n\n    // p = point to evaluate\n   ", "\n    vec3 oc = r.origin - center;\n    float a = dot(r.direction, r.direction);\n    float b = 2.0 * dot(oc, r.direction);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\nfloat", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tvec2 r = p;\n\tfloat t = 0.0;\n\tfloat dt = 0.0;\n\tfloat dt2 = 0.0;\n\tfloat dt3 = 0.0;\n\tfloat dt4 = 0.0;\n\tfloat dt5 = 0.0;\n\tfloat dt6 = 0.0;\n\tfloat dt7 = 0.0;\n\tfloat dt8 = 0.0;\n\tfloat dt9 = 0.0;\n\tfloat dt10 = 0.0;\n\tfloat dt11 = 0.0;\n\tfloat dt12 = 0.0;\n\tfloat dt13 = 0.0;\n\tfloat dt14 = 0.0;\n\tfloat dt15 = 0.0;\n\tfloat dt16 = 0.0;\n\tfloat dt17 = 0.0;\n\tfloat dt18 = 0.0;\n\tfloat dt19 = 0.0;\n\tfloat dt20 = 0.0;\n\tfloat dt21 = 0.0;\n\tfloat dt22 = 0.0;\n\tfloat dt23 = 0.0;\n\tfloat dt24 = 0.0;\n\tfloat dt25 = 0.0;\n\tfloat dt26 = 0.0;\n\tfloat dt27 = 0.0;\n\tfloat dt28 = 0.0;\n\tfloat dt29 = 0.0;\n\tfloat dt30 = 0.0;\n\tfloat dt31 = 0.0;\n\tfloat dt32 = 0.0;\n\tfloat dt33 = 0.0;\n\tfloat dt34 = 0.0;\n\tfloat dt35 = 0.0;\n\tfloat dt36 = 0.0;\n\tfloat dt37 = 0.0;\n\tfloat dt38 = 0.0;\n\tfloat dt39 = 0.0;\n\tfloat dt40 = 0.0;\n\tfloat dt41 = 0.0;\n\tfloat dt42 = 0.0;\n\tfloat dt43", "\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.sh", "\n  // where k and j are scalars\n  float k = dot(p, q);\n  float j = dot(p, p) - k*k;\n  return (k*q + j*p) / j;\n}\n\nvec", "\n    vec3 q = p - vec3( 0.5 );\n    float d = length( q );\n    return d * 0.5;\n}\n\n//=====================================================\n\nfloat", "\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ:", "\n    float f = sin(p.x*10.0)*sin(p.y*10.0);\n    f = abs(f);\n    f = smoothstep(0.0, 1.0, f);\n    return f;\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec3 pmin = min( p0, min( p1, p2 ) );\n    vec3 pmax = max( p0, max( p1, p2 ) );\n\n    // center\n    vec3 p = ( pmin + pmax ) * 0.5;\n\n    // diagonal\n    vec3 d = pmax - pmin;\n    return bound3( p - d * 0.5, p + d * 0.5 );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://www.iquilezles.org/www/articles/sphere/sphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://www.iquilezles.org/www/articles/cylinder/cylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in float r, in float h )\n{\n    vec3 d = abs( vec3( length( p.xz ) - r, p.y, h ) );\n    return bound3( p - d, p + d );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://www.iquilezles.org/www/articles/cone/cone.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 p, in float r, in float h )\n{\n    vec3 d = abs( vec3( length( p.xz ) - r, p.y, h ) );\n    return bound3( p - d, p + d );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://www.iquilezles.org/www/articles/cylinder/cylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in float r, in float h )\n{", "\n\tvec3 n = (cen - ro) / rd;\n\tvec3 f = fract(n);\n\tvec3 e = (cen + rad) - ro;\n\tvec3 t = e / rd;\n\tvec3 s = sign(e);\n\tvec3 t1 = min(t, f);\n\tvec3 t2 = max(t, f);\n\tvec3 tf = max(t1, t2);\n\tvec3 ts = min(s, tf);\n\treturn ts;\n}\n\n// ray-sphere intersection (simplified)\nvec", " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n    float res = 1.0;\n    for( int i=0; i<50; i++ )\n    {\n        // get the distance to the light\n        float d = map( bv );\n        // if the distance is negative, the light is behind us\n        if( d<0.0 )\n            return 0.0;\n        // if the distance is too far, we are outside the shadow\n        if( d>tmax )\n            return 1.0;\n        // update the bounding volume\n        bv = bv + d*rd;\n        // update the shadow\n        res = min( res, mint*d/bv.w );\n        // if the shadow is too small, we are outside the shadow\n        if( res<0.001 )\n            return 0.0;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float f = (fract(p.x+p.y)>0.5)? 1.0 : 0.0;\n\n    // gradient\n    vec2 g = vec2( dpdx.x, dpdy.y ) - vec2( dpdx.y, -dpdy.x );\n\n    // dot product\n    return f * dot(g,g);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    float a = time * 0.01;\n    float b = time * 0.02;\n    float c = time * 0.03;\n    float d = time * 0.04;\n    float e = time * 0.05;\n    float f = time * 0.06;\n    float g = time * 0.07;\n    float h = time * 0.08;\n    float i = time * 0.09;\n    float j = time * 0.1;\n    float k = time * 0.11;\n    float l = time * 0.12;\n    float m = time * 0.13;\n    float n = time * 0.14;\n    float o = time * 0.15;\n    float p = time * 0.16;\n    float q = time * 0.17;\n    float r = time * 0.18;\n    float s = time * 0.19;\n    float t = time * 0.2;\n    float u = time * 0.21;\n    float v = time * 0.22;\n    float w = time * 0.23;\n    float x = time * 0.24;\n    float y = time * 0.25;\n    float z = time * 0.26;\n    float aa = time * 0.27;\n    float bb = time * 0.28;\n    float cc = time * 0.29;\n    float dd = time * 0.3;\n    float ee = time * 0.31;\n    float ff = time * 0.32;\n    float gg = time * 0.33;\n    float hh = time * 0.34;\n    float ii = time * 0.35;\n    float jj = time * 0.36;\n    float kk = time * 0.37;\n    float ll = time * 0.38;\n    float mm = time * 0.39;", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n\treturn fract(sin(vec2(dot(p,vec2(127.1,311.7)),dot(p,vec2(269.5,183.3))))*43758.5453);\n}\n\nfloat", "\n\t vec3 s = floor(p);\n\t vec3 x = p - s;\n\t \n\t /* calculate i1, i2, 1.0 - the integer coordinates of the four corners of T */\n\t vec3 i1 = step(vec3(0.0), x - vec3(0.0, 0.0, 1.0));\n\t vec3 i2 = step(vec3(1.0), x - vec3(1.0, 0.0, 1.0));\n\t vec3 i3 = step(vec3(1.0), x - vec3(1.0, 1.0, 1.0));\n\t vec3 i4 = step(vec3(0.0), x - vec3(0.0, 1.0, 1.0));\n\t \n\t /* calculate the contribution from the four corners */\n\t vec3 x1 = x - i1 + (i2 - i1) * vec3(0.0, 0.0, 1.0);\n\t vec3 x2 = x - i2 + (i3 - i2) * vec3(0.0, 0.0, 1.0);\n\t vec3 x3 = x - i3 + (i4 - i3) * vec3(0.0, 0.0, 1.0);\n\t vec3 x4 = x - i4 + (i1 - i4) * vec3(0.0, 0.0, 1.0);\n\t \n\t /* calculate the contribution from the four vertices */\n\t float n1 = dot(x, x);\n\t float n2 = dot(x1, x1);\n\t float n3 = dot(x2, x2);\n\t float n4 = dot(x3, x3);\n\t float n5 = dot(x4, x4);\n\t \n\t /* calculate the 4x4 dot product matrix */\n\t mat2 m = mat2(n1, n2, n3, n4);\n\t \n\t /* calculate the 4x4 dot product */\n\t float n = m[0][0] + m[1", " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n    float res = 1.0;\n    for( int i=0; i<50; i++ )\n    {\n        // get the distance to the light\n        float d = map( bv );\n        // if the distance is negative, the light is behind us\n        if( d<0.0 )\n            return 0.0;\n        // if the distance is too far, we are outside the shadow\n        if( d>tmax )\n            return 1.0;\n        // update the bounding volume\n        bv = bv + d*rd;\n        // update the shadow\n        res = min( res, mint*d/bv.w );\n        // if the shadow is too small, we are outside the shadow\n        if( res<0.001 )\n            return 0.0;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec3 col = vec3(0.0);\n    vec3 bg = vec3(0.0);\n    vec3 bg2 = vec3(0.0);\n    vec3 bg3 = vec3(0.0);\n    vec3 bg4 = vec3(0.0);\n    vec3 bg5 = vec3(0.0);\n    vec3 bg6 = vec3(0.0);\n    vec3 bg7 = vec3(0.0);\n    vec3 bg8 = vec3(0.0);\n    vec3 bg9 = vec3(0.0);\n    vec3 bg10 = vec3(0.0);\n    vec3 bg11 = vec3(0.0);\n    vec3 bg12 = vec3(0.0);\n    vec3 bg13 = vec3(0.0);\n    vec3 bg14 = vec3(0.0);\n    vec3 bg15 = vec3(0.0);\n    vec3 bg16 = vec3(0.0);\n    vec3 bg17 = vec3(0.0);\n    vec3 bg18 = vec3(0.0);\n    vec3 bg19 = vec3(0.0);\n    vec3 bg20 = vec3(0.0);\n    vec3 bg21 = vec3(0.0);\n    vec3 bg22 = vec3(0.0);\n    vec3 bg23 = vec3(0.0);\n    vec3 bg24 = vec3(0.0);\n    vec3 bg25 = vec3(0.0);\n    vec3 bg26 = vec3(0.0);\n    vec3 bg27 = vec3(0.0);\n    vec3 bg28 = vec3(0.0);\n    vec3 bg29 = vec3(0.0);\n    vec3 bg30 = vec3(0", " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n    float res = 1.0;\n    for( int i=0; i<50; i++ )\n    {\n        // get the distance to the light\n        float d = map( bv );\n        // if the distance is negative, the light is behind us\n        if( d<0.0 )\n            return 0.0;\n        // if the distance is too far, we are outside the shadow\n        if( d>tmax )\n            return 1.0;\n        // update the bounding volume\n        bv = bv + d*rd;\n        // update the shadow\n        res = min( res, mint*d/bv.w );\n        // if the shadow is too small, we are outside the shadow\n        if( res<0.001 )\n            return 0.0;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float f = (fract(p.x+p.y)>0.5)? 1.0 : 0.0;\n\n    // gradient\n    vec2 g = vec2( dpdx.x, dpdy.y ) - vec2( dpdx.y, -dpdy.x );\n\n    // dot product\n    return f * dot(g,g);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    p.x *= iResolution.x/iResolution.y;\n\n    // Time varying pixel color\n    vec3 color = vec3(0.0);\n\n    // Normalized pixel coordinates (from 0 to 1)", "\n    // h is the height of the extrusion\n    return abs(d) - h;\n}\n\nfloat", "\n    p.x = abs(p.x);\n\n    // rotate\n    float c = cos(p.y);\n    float s = sin(p.y);\n    mat2 m = mat2(c, -s, s, c);\n    p = m * p;\n\n    // ellipse\n    float a = ab.x;\n    float b = ab.y;\n    float x = p.x;\n    float y = p.y;\n    float k = (a*a - b*b) / (a*a);\n    float l = (b*b - a*a) / (b*b);\n    float m = (a*a*a - b*b*b*2.0) / (a*a*a);\n    float n = (b*b*b*2.0 - a*a*a) / (b*b*b);\n    float p = (a*a*a*a - b*b*b*b*2.0) / (a*a*a*a);\n    float q = (b*b*b*b*2.0 - a*a*a*a) / (b*b*b*b);\n    float r = (a*a*a*a*a - b*b*b*b*b*2.0) / (a*a*a*a*a);\n    float s = (b*b*b*b*b*2.0 - a*a*a*a*a*a) / (b*b*b*b*b*b);\n    float t = (a*a*a*a*a*a - b*b*b*b*b*b*2.0) / (a*a*a*a*a*a*a);\n    float u = (b*b*b*b*b*b*2.0 - a*a*a*a*a*a*a) / (b*b*b*b*b*b*b*2.0);\n    float v = (a*a*a*a*a*a*a - b*b*b*b*b*b*b*2.0)", "\n  return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", "\n  return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", "\n    vec3 color = vec3(0.0);\n    color.r = clamp(val, 0.0, 1.0);\n    color.g = clamp(val - 0.5, 0.0, 1.0);\n    color.b = clamp(val - 1.0, 0.0, 1.0);\n    return color;\n}\n\n/* Returns rgb vec from input 0-1 */\nvec", "\n    p.x = abs(p.x);\n\n    // ellipse\n    float a = ab.x;\n    float b = ab.y;\n    float c = dot(p, p) / (a*a) + dot(p, p) / (b*b);\n    return sqrt(max(c - 1.0, 0.0));\n}\n\nfloat", "\n  return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n    float res = 1.0;\n    for( int i=0; i<50; i++ )\n    {\n        // get the distance to the light\n        float d = map( bv );\n        // if the distance is negative, the light is behind us\n        if( d<0.0 )\n            return 0.0;\n        // if the distance is too far, we are outside the shadow\n        if( d>tmax )\n            return 1.0;\n        // update the bounding volume\n        bv = bv + d*rd;\n        // update the shadow\n        res = min( res, mint*d/bv.w );\n        // if the shadow is too small, we are outside the shadow\n        if( res<0.001 )\n            return 0.0;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float f = (fract(p.x+p.y)>0.5)? 1.0 : 0.0;\n\n    // gradient\n    vec2 g = vec2( dpdx.x, dpdy.y ) - vec2( dpdx.y, -dpdy.x );\n\n    // dot product\n    return f * dot(g,g);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n  return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", "\n  return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", "\n  return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n    float res = 1.0;\n    for( int i=0; i<50; i++ )\n    {\n        // get the distance to the light\n        float d = map( bv );\n        // if the distance is negative, the light is behind us\n        if( d<0.0 )\n            return 0.0;\n        // if the distance is too far, we are outside the shadow\n        if( d>tmax )\n            return 1.0;\n        // update the bounding volume\n        bv = bv + d*rd;\n        // update the shadow\n        res = min( res, mint*d/bv.w );\n        // if the shadow is too small, we are outside the shadow\n        if( res<0.001 )\n            return 0.0;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float f = (fract(p.x+p.y)>0.5)? 1.0 : 0.0;\n\n    // gradient\n    vec2 g = vec2( dpdx.x, dpdy.y ) - vec2( dpdx.y, -dpdy.x );\n\n    // dot product\n    return f * dot(g,g);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "\n\tuint mask = (1 << 16) - 1;\n\tuint mask2 = (1 << 16) - 1;\n\tuint mask3 = (1 << 16) - 1;\n\tuint mask4 = (1 << 16) - 1;\n\tuint mask5 = (1 << 16) - 1;\n\tuint mask6 = (1 << 16) - 1;\n\tuint mask7 = (1 << 16) - 1;\n\tuint mask8 = (1 << 16) - 1;\n\tuint mask9 = (1 << 16) - 1;\n\tuint mask10 = (1 << 16) - 1;\n\tuint mask11 = (1 << 16) - 1;\n\tuint mask12 = (1 << 16) - 1;\n\tuint mask13 = (1 << 16) - 1;\n\tuint mask14 = (1 << 16) - 1;\n\tuint mask15 = (1 << 16) - 1;\n\tuint mask16 = (1 << 16) - 1;\n\tuint mask17 = (1 << 16) - 1;\n\tuint mask18 = (1 << 16) - 1;\n\tuint mask19 = (1 << 16) - 1;\n\tuint mask20 = (1 << 16) - 1;\n\tuint mask21 = (1 << 16) - 1;\n\tuint mask22 = (1 << 16) - 1;\n\tuint mask23 = (1 << 16) - 1;\n\tuint mask24 = (1 << 16) - 1;\n\tuint mask25 = (1 << 16) - 1;\n\tuint mask26 = (1 << 16) - 1;\n\tuint mask27 = (1 << 16) - 1;\n\tuint mask28 = (1 << 16) - 1;\n\tuint mask29 = (1 << 16) - 1;\n\tuint mask30 = (1 << 16) - 1;\n\tuint mask31 = (1 << 16", "\n  return 0.5*(exp(x)-exp(-x));\n}\n\nfloat", "\n    float a2 = a*a;\n    float b2 = b*b;\n    float h2 = h*h;\n    float a2b2 = a2+b2;\n    float a2b2h2 = a2b2+h2;\n    float a2b2h2_2 = a2b2h2*0.5;\n    float a2b2h2_3 = a2b2h2_2*0.3333333333333333;\n    float a2b2h2_4 = a2b2h2_3*0.25;\n    float a2b2h2_5 = a2b2h2_4*0.2;\n    float a2b2h2_6 = a2b2h2_5*0.14285714285714285;\n    float a2b2h2_7 = a2b2h2_6*0.1111111111111111;\n    float a2b2h2_8 = a2b2h2_7*0.08333333333333333;\n    float a2b2h2_9 = a2b2h2_8*0.06666666666666666;\n    float a2b2h2_10 = a2b2h2_9*0.05714285714285714;\n    float a2b2h2_11 = a2b2h2_10*0.05;\n    float a2b2h2_12 = a2b2h2_11*0.042857142857142855;\n    float a2b2h2_13 = a2b2h2_12*0.0375;\n    float a2b2h2_14 = a2b2h2_13*0.0333", "\n  return (exp(x)-exp(-x))/(exp(x)+exp(-x));\n}\n\nfloat", "\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it later\n//I'm going to try to make it work first, then refactor it", "\n  return 0.5*(exp(x)-exp(-x))/(exp(x)+exp(-x));\n}\n\nfloat", "\n  return (exp(x)-exp(-x))/(exp(x)+exp(-x));\n}\n\nfloat", "\n    vec2 q = p - (va+vb)*0.5;\n\n    // get the distance to the closest point on the line\n    float h = clamp( dot(q,normalize(vb-va)), 0.0, length(vb-va) );\n\n    // get the squared distance to the closest point on the circle\n    float d2 = dot(q,q) - h*h;\n\n    // get the squared distance to the closest point on the capsule\n    return sqrt( max(d2,0.0) ) - rb;\n}\n\n\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------\n// -------------------------------", "\n    //d = length(p) - r;\n    //d2 = d*d - (length(p) - r)*(length(p) - r);\n    //return d2;\n    return length(p) - r;\n}\n\n//-------------------------------------------------\n\nfloat", "\n  return 0.5*log((1.0+x)/(1.0-x))/PI;\n}\n\nfloat", "\n    vec2 ab = b-a;\n    vec2 ap = p-a;\n    vec2 bp = p-b;\n    float h = clamp( dot(ap,ab)/dot(ab,ab), 0.0, 1.0 );\n    float d = length( ap-ab*h );\n    float w = w1+w2;\n\n    // head\n    if( d<w ) return d-w2;\n\n    // tail\n    return length( bp-ab*h )-w1;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n\n\t//vec2 uv = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv2 = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv3 = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv4 = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv5 = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv6 = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv7 = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv8 = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv9 = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv10 = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv11 = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec2 uv12 = p*vec2(iResolution.x/iResolution.y,1.0) + iTime*0.05;\n\n\tvec", "\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (exp(x) - exp(-x)) / (exp(x) + exp(-x)) * 2;\n  //  return (", ", but I don't remember where.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //", ", but I don't remember where.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //  It's a simple post-processing effect that I found on the internet.\n  //", "\n    vec2 p = vec2( z.x, z.y );\n\n    // 1D to 2D\n    return -1.0 + 2.0 * fract( 16.0 * fract( dot( p, vec2( 127.1, 311.7 ) ) ) );\n}\n\n// 2D Perlin noise\nfloat", " from heightmap\n    float d = texture(heightmap, p).r;\n\n    // get polygon normal\n    vec2 n = texture(normalmap, p).rg;\n\n    // get polygon tangent\n    vec2 t = texture(tangentmap, p).rg;\n\n    // get polygon bitangent\n    vec2 b = texture(bitangentmap, p).rg;\n\n    // get polygon color\n    vec4 c = texture(colormap, p);\n\n    // get polygon alpha\n    float a = texture(alphamap, p).r;\n\n    // get polygon uv\n    vec2 uv = texture(uvmap, p).rg;\n\n    // get polygon uv offset\n    vec2 uvOffset = texture(uvOffsetmap, p).rg;\n\n    // get polygon uv scale\n    vec2 uvScale = texture(uvScale, p).rg;\n\n    // get polygon uv rotation\n    float uvRotation = texture(uvRotation, p).r;\n\n    // get polygon uv rotation\n    float uvRotation2 = texture(uvRotation2, p).r;\n\n    // get polygon uv rotation\n    float uvRotation3 = texture(uvRotation3, p).r;\n\n    // get polygon uv rotation\n    float uvRotation4 = texture(uvRotation4, p).r;\n\n    // get polygon uv rotation\n    float uvRotation5 = texture(uvRotation5, p).r;\n\n    // get polygon uv rotation\n    float uvRotation6 = texture(uvRotation6, p).r;\n\n    // get polygon uv rotation\n    float uvRotation7 = texture(uvRotation7, p).r;\n\n    // get polygon uv rotation\n    float uvRotation8 = texture(uvRotation8, p).r;\n\n    // get polygon uv rotation\n    float uvRotation9 = texture(uvRotation9, p).r;\n\n    // get polygon uv rotation\n    float uvRotation10 = texture(uvRotation10, p).r;\n\n    // get polygon", "\n    float rot = time * 0.25;\n\n    // get the position of the pixel\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // get the position of the pixel in the unit square\n    vec2 uv = p * 2.0 - 1.0;\n\n    // get the position of the pixel in the unit circle\n    vec2 r = vec2(length(uv), atan(uv.y, uv.x));\n\n    // rotate the position\n    r = rotate(r, rot);\n\n    // get the position of the pixel in the unit square\n    uv = r / 2.0 + 0.5;\n\n    // get the position of the pixel in the unit circle\n    vec2 c = vec2(length(uv), atan(uv.y, uv.x));\n\n    // rotate the position\n    c = rotate(c, -rot);\n\n    // get the position of the pixel in the unit square\n    uv = c / 2.0 + 0.5;\n\n    // get the position of the pixel in the unit circle\n    vec2 s = vec2(length(uv), atan(uv.y, uv.x));\n\n    // rotate the position\n    s = rotate(s, -rot);\n\n    // get the position of the pixel in the unit square\n    uv = s / 2.0 + 0.5;\n\n    // get the position of the pixel in the unit circle\n    vec2 t = vec2(length(uv), atan(uv.y, uv.x));\n\n    // rotate the position\n    t = rotate(t, rot);\n\n    // get the position of the pixel in the unit square\n    uv = t / 2.0 + 0.5;\n\n    // get the position of the pixel in the unit circle\n    vec2 f = vec2(length(uv), atan(uv.y, uv.x));\n\n    // rotate the position\n    f = rotate(f, -rot);\n\n    // get the position of the pixel in the unit square\n    uv = f / 2", " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n    float res = 1.0;\n    for( int i=0; i<50; i++ )\n    {\n        // get the distance to the light\n        float d = map( bv );\n        // if the distance is negative, the light is behind us\n        if( d<0.0 )\n            return 0.0;\n        // if the distance is too far, we are outside the shadow\n        if( d>tmax )\n            return 1.0;\n        // update the bounding volume\n        bv = bv + d*rd;\n        // update the shadow\n        res = min( res, mint*d/bv.w );\n        // if the shadow is too small, we are outside the shadow\n        if( res<0.001 )\n            return 0.0;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float f = (fract(p.x+p.y)>0.5)? 1.0 : 0.0;\n\n    // gradient\n    vec2 g = vec2( dpdx.x, dpdy.y ) - vec2( dpdx.y, -dpdy.x );\n\n    // dot product\n    return f * dot(g,g);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec2 p = vec2( z.x, z.y );\n\n    // 1D to 2D\n    return -1.0 + 2.0 * fract( 16.0 * fract( dot( p, vec2( 127.1, 311.7 ) ) ) );\n}\n\n// 2D Perlin noise\nfloat", " from heightmap\n    float d = texture(heightmap, p).r;\n\n    // get polygon normal\n    vec2 n = texture(normalmap, p).rg;\n\n    // get polygon tangent\n    vec2 t = texture(tangentmap, p).rg;\n\n    // get polygon bitangent\n    vec2 b = texture(bitangentmap, p).rg;\n\n    // get polygon color\n    vec4 c = texture(colormap, p);\n\n    // get polygon alpha\n    float a = texture(alphamap, p).r;\n\n    // get polygon uv\n    vec2 uv = texture(uvmap, p).rg;\n\n    // get polygon uv offset\n    vec2 uvOffset = texture(uvOffsetmap, p).rg;\n\n    // get polygon uv scale\n    vec2 uvScale = texture(uvScale, p).rg;\n\n    // get polygon uv rotation\n    float uvRotation = texture(uvRotation, p).r;\n\n    // get polygon uv rotation\n    float uvRotation2 = texture(uvRotation2, p).r;\n\n    // get polygon uv rotation\n    float uvRotation3 = texture(uvRotation3, p).r;\n\n    // get polygon uv rotation\n    float uvRotation4 = texture(uvRotation4, p).r;\n\n    // get polygon uv rotation\n    float uvRotation5 = texture(uvRotation5, p).r;\n\n    // get polygon uv rotation\n    float uvRotation6 = texture(uvRotation6, p).r;\n\n    // get polygon uv rotation\n    float uvRotation7 = texture(uvRotation7, p).r;\n\n    // get polygon uv rotation\n    float uvRotation8 = texture(uvRotation8, p).r;\n\n    // get polygon uv rotation\n    float uvRotation9 = texture(uvRotation9, p).r;\n\n    // get polygon uv rotation\n    float uvRotation10 = texture(uvRotation10, p).r;\n\n    // get polygon", "\n    float rot = time * 0.25;\n\n    // get the position of the pixel\n    vec2 p = fragCoord.xy / iResolution.xy;\n\n    // get the position of the pixel in the unit square\n    vec2 uv = p * 2.0 - 1.0;\n\n    // get the position of the pixel in the unit circle\n    vec2 r = vec2(length(uv), atan(uv.y, uv.x));\n\n    // rotate the position\n    r = rotate(r, rot);\n\n    // get the position of the pixel in the unit square\n    uv = r / 2.0 + 0.5;\n\n    // get the position of the pixel in the unit circle\n    vec2 c = vec2(length(uv), atan(uv.y, uv.x));\n\n    // rotate the position\n    c = rotate(c, -rot);\n\n    // get the position of the pixel in the unit square\n    uv = c / 2.0 + 0.5;\n\n    // get the position of the pixel in the unit circle\n    vec2 s = vec2(length(uv), atan(uv.y, uv.x));\n\n    // rotate the position\n    s = rotate(s, -rot);\n\n    // get the position of the pixel in the unit square\n    uv = s / 2.0 + 0.5;\n\n    // get the position of the pixel in the unit circle\n    vec2 t = vec2(length(uv), atan(uv.y, uv.x));\n\n    // rotate the position\n    t = rotate(t, rot);\n\n    // get the position of the pixel in the unit square\n    uv = t / 2.0 + 0.5;\n\n    // get the position of the pixel in the unit circle\n    vec2 f = vec2(length(uv), atan(uv.y, uv.x));\n\n    // rotate the position\n    f = rotate(f, -rot);\n\n    // get the position of the pixel in the unit square\n    uv = f / 2", " for the shadow\n    vec4 bv = vec4(ro, 1.0);\n    float res = 1.0;\n    for( int i=0; i<50; i++ )\n    {\n        // get the distance to the light\n        float d = map( bv );\n        // if the distance is negative, the light is behind us\n        if( d<0.0 )\n            return 0.0;\n        // if the distance is too far, we are outside the shadow\n        if( d>tmax )\n            return 1.0;\n        // update the bounding volume\n        bv = bv + d*rd;\n        // update the shadow\n        res = min( res, mint*d/bv.w );\n        // if the shadow is too small, we are outside the shadow\n        if( res<0.001 )\n            return 0.0;\n    }\n    return res;\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    float f = (fract(p.x+p.y)>0.5)? 1.0 : 0.0;\n\n    // gradient\n    vec2 g = vec2( dpdx.x, dpdy.y ) - vec2( dpdx.y, -dpdy.x );\n\n    // dot product\n    return f * dot(g,g);\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat"], "input_comment": ["\n    float a = atan( p.y, p.x ) / 3.1415926535897932384626433832795;\n    float r = length( p );\n    return r * 0.5 + 0.5 * cos( a * 10.0 );\n}\n\n//=====================================================\n\nfloat", "\n    float d = length(p);\n    return d - 0.001;\n}\n\n// This is the big money function that makes the crazy fractally shape\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    uv -= 0.5;\n    uv.x *= iResolution.x / iResolution.y;\n    uv *= zoom;\n    uv += tile;\n    vec2 p = uv;\n    vec2 d = vec2(0.0);\n    float t = 0.0;\n    float dt = 0.0;\n    float dt2 = 0.0;\n    float dt3 = 0.0;\n    float dt4 = 0.0;\n    float dt5 = 0.0;\n    float dt6 = 0.0;\n    float dt7 = 0.0;\n    float dt8 = 0.0;\n    float dt9 = 0.0;\n    float dt10 = 0.0;\n    float dt11 = 0.0;\n    float dt12 = 0.0;\n    float dt13 = 0.0;\n    float dt14 = 0.0;\n    float dt15 = 0.0;\n    float dt16 = 0.0;\n    float dt17 = 0.0;\n    float dt18 = 0.0;\n    float dt19 = 0.0;\n    float dt20 = 0.0;\n    float dt21 = 0.0;\n    float dt22 = 0.0;\n    float dt23 = 0.0;\n    float dt24 = 0.0;\n    float dt25 = 0.0;\n    float dt26 = 0.0;\n    float dt27 = 0.0;\n    float dt28 = 0.0;\n    float dt29 = 0.0;\n    float dt30 = 0.0;\n    float dt31 = 0.0;\n    float dt32 = 0.0;\n    float dt33 = 0.0;\n    float dt34 = 0.0;\n    float dt35 = 0.0;\n    float dt36 = 0.0;\n    float dt37 = 0.0;\n    float dt38 = 0.0;\n    float dt3", "\n    vec4 color = vec4(0.0);\n    vec2 z = p;\n    float iterations = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        if (iterations > 200.0)\n            break;\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + p;\n        iterations += 1.0;\n    }\n    color = vec4(iterations / 100.0);\n    return color;\n}\n\nvoid main()\n{\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec4 color = juliaSet(p);\n    gl_FragColor = color;\n}\n", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(sunDir);\n    float lightDist = length(sunDir);\n    float lightRadius = 1.0;\n    float lightFalloff = 1.0;\n    float lightIntensity = 1.0;\n    float lightFade = 1.0;\n    float lightFadeFactor = 1.0;\n    float lightFadeFactor2 = 1.0;\n    float lightFadeFactor3 = 1.0;\n    float lightFadeFactor4 = 1.0;\n    float lightFadeFactor5 = 1.0;\n    float lightFadeFactor6 = 1.0;\n    float lightFadeFactor7 = 1.0;\n    float lightFadeFactor8 = 1.0;\n    float lightFadeFactor9 = 1.0;\n    float lightFadeFactor10 = 1.0;\n    float lightFadeFactor11 = 1.0;\n    float lightFadeFactor12 = 1.0;\n    float lightFadeFactor13 = 1.0;\n    float lightFadeFactor14 = 1.0;\n    float lightFadeFactor15 = 1.0;\n    float lightFadeFactor16 = 1.0;\n    float lightFadeFactor17 = 1.0;\n    float lightFadeFactor18 = 1.0;\n    float lightFadeFactor19 = 1.0;\n    float lightFadeFactor20 = 1.0;\n    float lightFadeFactor21 = 1.0;\n    float lightFadeFactor22 = 1.0;\n    float lightFadeFactor23 = 1.0;\n    float lightFadeFactor24 = 1.0;\n    float lightFadeFactor25 = 1.0;\n    float lightFadeFactor26 = 1.0;\n    float lightFadeFactor27 = 1.0;\n    float lightFadeFactor28 = 1.0;\n    float lightFadeFactor29 = 1.0;\n   ", "\n\tfloat time = t * 0.001;\n\tfloat speed = 0.001;\n\tfloat dist = sin(time * speed) * 0.001;\n\tfloat dist2 = sin(time * speed * 2) * 0.001;\n\tfloat dist3 = sin(time * speed * 3) * 0.001;\n\tfloat dist4 = sin(time * speed * 4) * 0.001;\n\tfloat dist5 = sin(time * speed * 5) * 0.001;\n\tfloat dist6 = sin(time * speed * 6) * 0.001;\n\tfloat dist7 = sin(time * speed * 7) * 0.001;\n\tfloat dist8 = sin(time * speed * 8) * 0.001;\n\tfloat dist9 = sin(time * speed * 9) * 0.001;\n\tfloat dist10 = sin(time * speed * 10) * 0.001;\n\tfloat dist11 = sin(time * speed * 11) * 0.001;\n\tfloat dist12 = sin(time * speed * 12) * 0.001;\n\tfloat dist13 = sin(time * speed * 13) * 0.001;\n\tfloat dist14 = sin(time * speed * 14) * 0.001;\n\tfloat dist15 = sin(time * speed * 15) * 0.001;\n\tfloat dist16 = sin(time * speed * 16) * 0.001;\n\tfloat dist17 = sin(time * speed * 17) * 0.001;\n\tfloat dist18 = sin(time * speed * 18) * 0.001;\n\tfloat dist19 = sin(time * speed * 19) * 0.001;\n\tfloat dist20 = sin(time * speed * 20) * 0.001;\n\tfloat dist21 = sin(", "\n\tvec3 color = vec3(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 1000000.0;\n\tfloat tmax = 0.0;\n\tfloat t0 = 0.0;\n\tfloat t1 = 0.0;\n\tfloat t2 = 0.0;\n\tfloat t3 = 0.0;\n\tfloat t4 = 0.0;\n\tfloat t5 = 0.0;\n\tfloat t6 = 0.0;\n\tfloat t7 = 0.0;\n\tfloat t8 = 0.0;\n\tfloat t9 = 0.0;\n\tfloat t10 = 0.0;\n\tfloat t11 = 0.0;\n\tfloat t12 = 0.0;\n\tfloat t13 = 0.0;\n\tfloat t14 = 0.0;\n\tfloat t15 = 0.0;\n\tfloat t16 = 0.0;\n\tfloat t17 = 0.0;\n\tfloat t18 = 0.0;\n\tfloat t19 = 0.0;\n\tfloat t20 = 0.0;\n\tfloat t21 = 0.0;\n\tfloat t22 = 0.0;\n\tfloat t23 = 0.0;\n\tfloat t24 = 0.0;\n\tfloat t25 = 0.0;\n\tfloat t26 = 0.0;\n\tfloat t27 = 0.0;\n\tfloat t28 = 0.0;\n\tfloat t29 = 0.0;\n\tfloat t30 = 0.0;\n\tfloat t31 = 0.0;\n\tfloat t32 = 0.0;\n\tfloat t33 = 0.0;\n\tfloat t34 = 0.0;\n\tfloat t35 = 0.0;\n\tfloat t36 = 0.0;\n\tfloat t37 = 0.0;\n\tfloat t38 = 0.0;\n\tfloat t39 = 0.0;\n\tfloat t40 = 0.0;\n\tfloat t41 = 0.0;\n\tfloat t42 = 0.0;", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(sunDir);\n    float lightDist = length(sunDir);\n    float lightRadius = 1.0;\n    float lightFalloff = 1.0;\n    float lightIntensity = 1.0;\n    float lightFade = 1.0;\n    float lightFadeFactor = 1.0;\n    float lightFadeFactor2 = 1.0;\n    float lightFadeFactor3 = 1.0;\n    float lightFadeFactor4 = 1.0;\n    float lightFadeFactor5 = 1.0;\n    float lightFadeFactor6 = 1.0;\n    float lightFadeFactor7 = 1.0;\n    float lightFadeFactor8 = 1.0;\n    float lightFadeFactor9 = 1.0;\n    float lightFadeFactor10 = 1.0;\n    float lightFadeFactor11 = 1.0;\n    float lightFadeFactor12 = 1.0;\n    float lightFadeFactor13 = 1.0;\n    float lightFadeFactor14 = 1.0;\n    float lightFadeFactor15 = 1.0;\n    float lightFadeFactor16 = 1.0;\n    float lightFadeFactor17 = 1.0;\n    float lightFadeFactor18 = 1.0;\n    float lightFadeFactor19 = 1.0;\n    float lightFadeFactor20 = 1.0;\n    float lightFadeFactor21 = 1.0;\n    float lightFadeFactor22 = 1.0;\n    float lightFadeFactor23 = 1.0;\n    float lightFadeFactor24 = 1.0;\n    float lightFadeFactor25 = 1.0;\n    float lightFadeFactor26 = 1.0;\n    float lightFadeFactor27 = 1.0;\n    float lightFadeFactor28 = 1.0;\n    float lightFadeFactor29 = 1.0;\n   ", "\n    vec2 result = vec2( -1.0 );\n    float t = -1.0;\n    float tmin = 0.0001;\n    float tmax = 10000.0;\n    for( int i = 0 ; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE ; i++ ){\n        float t0 = tmin;\n        float t1 = tmax;\n        vec3 p0 = eyePosition + t0 * rayDirection;\n        vec3 p1 = eyePosition + t1 * rayDirection;\n        float d0 = mapTheWorld( p0 );\n        float d1 = mapTheWorld( p1 );\n        if( d0 > t0 ){\n            t0 = d0;\n        }\n        if( d1 > t1 ){\n            t1 = d1;\n        }\n        if( t0 > t1 ){\n            break;\n        }\n        t = ( t0 + t1 ) / 2.0;\n    }\n    if( t > 0.0 ){\n        result.x = t;\n        result.y = mapTheWorld( eyePosition + t * rayDirection );\n    }\n    return result;\n}\n\n\nvoid main() {\n    vec2 result = checkRayHit( eyePosition, rayDirection );\n    if( result.x > 0.0 ){\n        gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n    }else{\n        gl_FragColor = vec4( 0.0, 0.0, 1.0, 1.0 );\n    }\n}\n", "\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo", "\n    // find the closest object\n    float t = INF;\n    vec2 tex = vec2(0.0);\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        float d = distance(p, objects[i].position);\n        if (d < t)\n        {\n            t = d;\n            tex = objects[i].texture;\n        }\n    }\n\n    // move the object\n    p = p + objects[int(tex.x)].position;\n\n    // move the object\n    p = p + objects[int(tex.y)].position;\n\n    // move the object\n    p = p + objects[int(tex.z)].position;\n\n    // move the object\n    p = p + objects[int(tex.w)].position;\n\n    // move the object\n    p = p + objects[int(tex.u)].position;\n\n    // move the object\n    p = p + objects[int(tex.v)].position;\n\n    // move the object\n    p = p + objects[int(tex.z)].position;\n\n    // move the object\n    p = p + objects[int(tex.w)].position;\n\n    // move the object\n    p = p + objects[int(tex.u)].position;\n\n    // move the object\n    p = p + objects[int(tex.v)].position;\n\n    // move the object\n    p = p + objects[int(tex.z)].position;\n\n    // move the object\n    p = p + objects[int(tex.w)].position;\n\n    // move the object\n    p = p + objects[int(tex.u)].position;\n\n    // move the object\n    p = p + objects[int(tex.v)].position;\n\n    // move the object\n    p = p + objects[int(tex.z)].position;\n\n    // move the object\n    p = p + objects[int(tex.w)].position;\n\n    // move the object\n    p = p + objects[int(tex.u)].position", "\n\tvec2 res = vec2(0.0);\n\tfloat t = 0.0;\n\tfloat tmin = 0.001;\n\tfloat tmax = 1000.0;\n\tfloat tmin_id = 0.0;\n\tfloat tmax_id = 0.0;\n\tfloat tmin_dist = 0.0;\n\tfloat tmax_dist = 0.0;\n\tfloat tmin_dist_id = 0.0;\n\tfloat tmax_dist_id = 0.0;\n\tfloat tmin_dist_id_dist = 0.0;\n\tfloat tmax_dist_id_dist = 0.0;\n\tfloat tmin_dist_id_dist_dist = 0.0;\n\tfloat tmax_dist_id_dist_dist = 0.0;\n\tfloat tmin_dist_id_dist_dist_dist = 0.0;\n\tfloat tmax_dist_id_dist_dist_dist = 0.0;\n\tfloat tmin_dist_id_dist_dist_dist_dist = 0.0;\n\tfloat tmax_dist_id_dist_dist_dist_dist = 0.0;\n\tfloat tmin_dist_id_dist_dist_dist_dist_dist = 0.0;\n\tfloat tmax_dist_id_dist_dist_dist_dist_dist = 0.0;\n\tfloat tmin_dist_id_dist_dist_dist_dist_dist_dist = 0.0;\n\tfloat tmax_dist_id_dist_dist_dist_dist_dist_dist = 0.0;\n\tfloat tmin_dist_id_dist_dist_dist_dist_dist_dist_dist = 0.0;\n\tfloat tmax_dist_id_dist_dist_dist_dist_dist_dist_dist = 0.0;\n\tfloat tmin_dist_id_dist_dist_dist_dist_dist_dist_dist_dist = 0.0;\n\tfloat tmax_dist_id_dist_dist_dist_dist_dist_dist_dist_dist = 0.0;\n\tfloat tmin_dist_id_dist_dist_dist_dist_dist_", "\n    // find the closest object/point\n    float d = -1.0;\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        float dist = length(objects[i].p - p);\n        if (dist < d || d < 0.0)\n        {\n            d = dist;\n            color = objects[i].color;\n        }\n    }\n    return color;\n}\n\n// ~~~~~~~ raymarching\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec", "\n    // ray-plane intersection\n    float t = (plane.z - ro.z) / rd.z;\n    vec3 pt = ro + t * rd;\n\n    // ray-sphere intersection\n    vec3 oc = pt - sphere.xyz;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    float t = min(t1, t2);\n    if (t < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n    vec3 pt = ro + t * rd;\n\n    // ray-cylinder intersection\n    vec3 oc = pt - cylinder.xyz;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - cylinder.w * cylinder.w;\n    discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n    t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    t = min(t1, t2);\n    if (t < 0.0)\n    {\n        itterRatio = 0.0;\n        return ve", "\n    vec3 n = vec3(0.0);\n    float d = 0.0001;\n    float d2 = d*d;\n    for(int i=-1; i<=1; i++)\n    {\n        for(int j=-1; j<=1; j++)\n        {\n            for(int k=-1; k<=1; k++)\n            {\n                vec3 p2 = p + vec3(i,j,k)*d;\n                vec3 oN2 = texture(tex, p2).rgb;\n                n += (oN2 - oN) * (1.0/d2);\n            }\n        }\n    }\n    return normalize(n);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec", "\n    vec2 q = p;\n    float d = dot(q, q);\n    float a = atan(q.y, q.x) / 3.1415926535897932384626433832795;\n    float r = sqrt(d) * (1.0 + distortionLevel * (a * a - 1.0));\n    return r * q;\n}\n\nvec", "\n    // find the closest object/point\n    float d = -1.0;\n    vec4 color = vec4(0.0);\n    for (int i = 0; i < NUM_OBJECTS; i++)\n    {\n        float dist = length(objects[i].p - p);\n        if (dist < d || d < 0.0)\n        {\n            d = dist;\n            color = objects[i].color;\n        }\n    }\n    return color;\n}\n\n// ~~~~~~~ raymarching\n// input p --> is ray position\n// basically find the object/point closest to the ray by\n// checking all the objects with respect to p\n// move objects/shapes by messing with p\n// outputs closest distance and blended colors for that surface as a vec4\nvec", "\n    // ray-plane intersection\n    float t = (plane.z - ro.z) / rd.z;\n    vec3 pt = ro + t * rd;\n\n    // ray-sphere intersection\n    vec3 oc = pt - sphere.xyz;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - sphere.w * sphere.w;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    float t = min(t1, t2);\n    if (t < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n    vec3 pt = ro + t * rd;\n\n    // ray-cylinder intersection\n    vec3 oc = pt - cylinder.xyz;\n    float a = dot(rd, rd);\n    float b = 2.0 * dot(oc, rd);\n    float c = dot(oc, oc) - cylinder.w * cylinder.w;\n    discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0)\n    {\n        itterRatio = 0.0;\n        return vec4(0.0);\n    }\n    t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    t = min(t1, t2);\n    if (t < 0.0)\n    {\n        itterRatio = 0.0;\n        return ve", "\n    vec3 n = vec3(0.0);\n    float d = 0.0001;\n    float d2 = d*d;\n    for(int i=-1; i<=1; i++)\n    {\n        for(int j=-1; j<=1; j++)\n        {\n            for(int k=-1; k<=1; k++)\n            {\n                vec3 p2 = p + vec3(i,j,k)*d;\n                vec3 oN2 = texture(tex, p2).rgb;\n                n += (oN2 - oN) * (1.0/d2);\n            }\n        }\n    }\n    return normalize(n);\n}\n\n// ~~~~~~~ calculates the normals near point p in world space\n// input p --> ray position world coordinates\n// input oN --> normal vector at point p\n// output --> averaged? out norals diffs of nearby points  \nvec", "\n    vec3 color = vec3(0.0);\n    vec3 lightDir = normalize(vec3(0.0, 1.0, 0.0));\n    float lightIntensity = dot(lightDir, rayDir);\n    float softboxLightIntensity = clamp(lightIntensity, 0.0, 1.0);\n    color = vec3(softboxLightIntensity);\n    return color;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec", "\n    vec2 d = vec2(1000.0);\n    vec3 q = p;\n    for (int i = 0; i < 10; i++)\n    {\n        vec3 r = vec3(0.0);\n        r.x = sin(q.x + q.y + q.z);\n        r.y = cos(q.x + q.y + q.z);\n        r.z = sin(q.x + q.y + q.z);\n        q = r;\n        d = min(d, vec2(length(r - p) - 0.01, float(i)));\n    }\n    return d;\n}\n\n// This is the distance function that defines all the scene's geometry.\n// The input is a position in space.\n// The output is the distance to the nearest surface and a material index.\nvec", "\n    vec3 p = pos;\n    vec3 p0 = floor(p);\n    vec3 p1 = p0 + 1.0;\n    vec3 p2 = p0 + vec3(1.0, 0.0, 0.0);\n    vec3 p3 = p0 + vec3(0.0, 1.0, 0.0);\n    vec3 p4 = p0 + vec3(0.0, 0.0, 1.0);\n    vec3 p5 = p0 + vec3(1.0, 1.0, 0.0);\n    vec3 p6 = p0 + vec3(1.0, 0.0, 1.0);\n    vec3 p7 = p0 + vec3(0.0, 1.0, 1.0);\n    vec3 p8 = p0 + vec3(1.0, 1.0, 1.0);\n    vec3 p9 = p0 + vec3(0.0, 0.0, 0.0);\n    vec3 p10 = p0 + vec3(1.0, 0.0, 0.0);\n    vec3 p11 = p0 + vec3(0.0, 1.0, 0.0);\n    vec3 p12 = p0 + vec3(0.0, 0.0, 1.0);\n    vec3 p13 = p0 + vec3(1.0, 1.0, 0.0);\n    vec3 p14 = p0 + vec3(1.0, 0.0, 1.0);\n    vec3 p15 = p0 + vec3(0.0, 1.0, 1.0);\n    vec3 p16 = p0 + vec3(1.0, 1.0, 1.0);\n    vec3 p17 = p0 + vec3(0.0, 0.0, 0.0);\n    vec", "\n    vec3 p = vec3(g, 0.0);\n    p.xy *= PT;\n    return p;\n}\n\n/* For any grid point on a cube face, along with projection matrix, \n   obtain the 2D point it represents. */\nvec", "\n    return dot(a, b) * dot(a, b);\n}\n\n/* Return squared great circle distance of two points projected onto sphere. */\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    vec2 pos = vec2(0.0);\n    float t = 0.0;\n    float dt = 0.0;\n    float dt2 = 0.0;\n    float dt3 = 0.0;\n    float dt4 = 0.0;\n    float dt5 = 0.0;\n    float dt6 = 0.0;\n    float dt7 = 0.0;\n    float dt8 = 0.0;\n    float dt9 = 0.0;\n    float dt10 = 0.0;\n    float dt11 = 0.0;\n    float dt12 = 0.0;\n    float dt13 = 0.0;\n    float dt14 = 0.0;\n    float dt15 = 0.0;\n    float dt16 = 0.0;\n    float dt17 = 0.0;\n    float dt18 = 0.0;\n    float dt19 = 0.0;\n    float dt20 = 0.0;\n    float dt21 = 0.0;\n    float dt22 = 0.0;\n    float dt23 = 0.0;\n    float dt24 = 0.0;\n    float dt25 = 0.0;\n    float dt26 = 0.0;\n    float dt27 = 0.0;\n    float dt28 = 0.0;\n    float dt29 = 0.0;\n    float dt30 = 0.0;\n    float dt31 = 0.0;\n    float dt32 = 0.0;\n    float dt33 = 0.0;\n    float dt34 = 0.0;\n    float dt35 = 0.0;\n    float dt36 = 0.0;\n    float dt37 = 0.0;\n    float dt38 = 0.0;\n    float dt39", "\n    vec3 q = p - b;\n    return length(q) - b.y;\n}\n\n// Rounded box with a plasma displacement.\nfloat", "\n    return 0.0;\n}\n\n// This is the main function that does the work.\n// It returns the color of the pixel at the given point.\nvec", "\n\tvec4 color = vec4(0.0);\n\tvec2 coordMorph = coord * morphConstant;\n\tfloat dist = distance(coordMorph, vec2(0.0));\n\tfloat dist2 = dist * dist;\n\tfloat dist3 = dist2 * dist;\n\tfloat dist4 = dist3 * dist;\n\tfloat dist5 = dist4 * dist;\n\tfloat dist6 = dist5 * dist;\n\tfloat dist7 = dist6 * dist;\n\tfloat dist8 = dist7 * dist;\n\tfloat dist9 = dist8 * dist;\n\tfloat dist10 = dist9 * dist;\n\tfloat dist11 = dist10 * dist;\n\tfloat dist12 = dist11 * dist;\n\tfloat dist13 = dist12 * dist;\n\tfloat dist14 = dist13 * dist;\n\tfloat dist15 = dist14 * dist;\n\tfloat dist16 = dist15 * dist;\n\tfloat dist17 = dist16 * dist;\n\tfloat dist18 = dist17 * dist;\n\tfloat dist19 = dist18 * dist;\n\tfloat dist20 = dist19 * dist;\n\tfloat dist21 = dist20 * dist;\n\tfloat dist22 = dist21 * dist;\n\tfloat dist23 = dist22 * dist;\n\tfloat dist24 = dist23 * dist;\n\tfloat dist25 = dist24 * dist;\n\tfloat dist26 = dist25 * dist;\n\tfloat dist27 = dist26 * dist;\n\tfloat dist28 = dist27 * dist;\n\tfloat dist29 = dist28 * dist;\n\tfloat dist30 = dist29 * dist;\n\tfloat dist31 = dist30 * dist;\n\tfloat dist32 = dist31 * dist;\n\tfloat dist33 = dist32 * dist;\n\tfloat dist34 = dist33 * dist;\n\tfloat dist35 = dist34 * dist;\n\tfloat dist36 = dist35 * dist;\n\tfloat dist37 = dist36 * dist;\n\tfloat dist38 = dist37 * dist;\n\t", "\n    vec2 p = pA;\n    vec2 d = pB - pA;\n    float dl = length(d);\n    float dp = dot(d, uv - p);\n    float dl2 = dl * dl;\n    float dp2 = dp * dp;\n    float dl4 = dl2 * dl2;\n    float dp4 = dp2 * dp2;\n    float dl8 = dl4 * dl4;\n    float dp8 = dp4 * dp4;\n    float dl16 = dl8 * dl8;\n    float dp16 = dp8 * dp8;\n    float dl32 = dl16 * dl16;\n    float dp32 = dp16 * dp16;\n    float dl64 = dl32 * dl32;\n    float dp64 = dp32 * dp32;\n    float dl128 = dl64 * dl64;\n    float dp128 = dp64 * dp64;\n    float dl256 = dl128 * dl128;\n    float dp256 = dp128 * dp128;\n    float dl512 = dl256 * dl256;\n    float dp512 = dp256 * dp256;\n    float dl1024 = dl512 * dl512;\n    float dp1024 = dp512 * dp512;\n    float dl2048 = dl1024 * dl1024;\n    float dp2048 = dp1024 * dp1024;\n    float dl4096 = dl2048 * dl2048;\n    float dp4096 = dp2048 * dp2048;\n    float dl8192 = dl", "\n    float c = texture( iChannel0, p ).x;\n    float d = texture( iChannel0, p + ddx ).x;\n    float e = texture( iChannel0, p + ddy ).x;\n    return (c + d + e) * 0.333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333", "\n    float tmin = 0.001, tmax = 1000.0;\n    float t0 = 0.0, t1 = 0.0;\n    float tnear = tmin, tfar = tmax;\n    float tymin = 0.0, tymax = 1000.0;\n    float tzmin = 0.0, tzmax = 1000.0;\n    float tymin2 = 0.0, tymax2 = 1000.0;\n    float tzmin2 = 0.0, tzmax2 = 1000.0;\n    float tmin2 = 0.0, tmax2 = 0.0;\n    float tmin3 = 0.0, tmax3 = 0.0;\n    float tmin4 = 0.0, tmax4 = 0.0;\n    float tmin5 = 0.0, tmax5 = 0.0;\n    float tmin6 = 0.0, tmax6 = 0.0;\n    float tmin7 = 0.0, tmax7 = 0.0;\n    float tmin8 = 0.0, tmax8 = 0.0;\n    float tmin9 = 0.0, tmax9 = 0.0;\n    float tmin10 = 0.0, tmax10 = 0.0;\n    float tmin11 = 0.0, tmax11 = 0.0;\n    float tmin12 = 0.0, tmax12 = 0.0;\n    float tmin13 = 0.0, tmax13 = 0.0;\n    float tmin14 = 0.0, tmax14 = 0.0;\n    float tmin15 = 0.0, tmax15 = 0.0;\n    float tmin16 = 0.0, tmax16 = 0.0;\n    float tmin17 = 0.0, tmax17 = 0.0;\n    float tmin18 = 0.0, tmax18 = 0.0;\n    float tmin19 = 0.0, tmax19 = 0.0;\n    float tmin2", "\n    vec2 res = vec2( -1.0 );\n    vec3 q = rd / rd.z;\n    vec3 t1 = (cen - ro) * q;\n    vec3 t2 = (cen - ro) * q + vec3( rad.x, rad.y, rad.z );\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    res.x = max( tmin.x, max( tmin.y, tmin.z ) );\n    res.y = min( tmax.x, min( tmax.y, tmax.z ) );\n    return res;\n}\n\n// ray-box intersection (simplified)\nvec", "\n    vec3 ab = pb - pa;\n    vec3 ap = pa - ro;\n    float b = dot(ab, rd);\n    float c = dot(ab, ab) - ra*ra;\n    float d = b*b - c;\n    if (d < 0.0) return vec4(0.0);\n    float t = -b - sqrt(d);\n    if (t < 0.0) t = -b + sqrt(d);\n    if (t < 0.0) return vec4(0.0);\n    vec3 p = ro + t*rd;\n    vec3 n = normalize(p - pa);\n    return vec4(t, n);\n}\n\n// ray-sphere intersection (returns t and normal)\nvec", "\n    vec2 balloon = vec2( 0.0 );\n    vec3 balloonPosition = vec3( 0.0 );\n    balloonPosition.x = -0.5;\n    balloonPosition.y = 0.0;\n    balloonPosition.z = 0.0;\n    balloon.x = length( currentRayPosition - balloonPosition );\n    balloon.y = 0.0;\n    return balloon;\n}\n\n//'TAG: BALL'\nvec", "\n    vec2 result = vec2( -1.0 );\n    float t = -1.0;\n    float tmin = 0.0001;\n    float tmax = 10000.0;\n    for( int i = 0 ; i < HOW_MANY_STEPS_CAN_OUR_RAY_TAKE ; i++ ){\n        float t0 = tmin;\n        float t1 = tmax;\n        vec3 p0 = eyePosition + t0 * rayDirection;\n        vec3 p1 = eyePosition + t1 * rayDirection;\n        float d0 = mapTheWorld( p0 );\n        float d1 = mapTheWorld( p1 );\n        if( d0 > t0 ){\n            t0 = d0;\n        }\n        if( d1 > t1 ){\n            t1 = d1;\n        }\n        if( t0 > t1 ){\n            break;\n        }\n        t = ( t0 + t1 ) / 2.0;\n    }\n    if( t > 0.0 ){\n        result.x = t;\n        result.y = mapTheWorld( eyePosition + t * rayDirection );\n    }\n    return result;\n}\n\n\nvoid main() {\n    vec2 result = checkRayHit( eyePosition, rayDirection );\n    if( result.x > 0.0 ){\n        gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n    }else{\n        gl_FragColor = vec4( 0.0, 0.0, 1.0, 1.0 );\n    }\n}\n", "\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo to determine what color we want to return\n    // We are going to use the rayHitInfo", "\n    return fract(sin(n)*43758.5453);\n}\n\nfloat", "\n    vec2 p = fragCoord.xy / iResolution.xy;\n    vec2 q = p - 0.5;\n    q.x *= iResolution.x / iResolution.y;\n    vec2 m = vec2(0.0);\n    vec3 col = vec3(0.0);\n    vec3 ro2 = ro;\n    vec3 rd2 = rd;\n    vec3 ro3 = ro2;\n    vec3 rd3 = rd2;\n    vec3 ro4 = ro3;\n    vec3 rd4 = rd3;\n    vec3 ro5 = ro4;\n    vec3 rd5 = rd4;\n    vec3 ro6 = ro5;\n    vec3 rd6 = rd5;\n    vec3 ro7 = ro6;\n    vec3 rd7 = rd6;\n    vec3 ro8 = ro7;\n    vec3 rd8 = rd7;\n    vec3 ro9 = ro8;\n    vec3 rd9 = rd8;\n    vec3 ro10 = ro9;\n    vec3 rd10 = rd9;\n    vec3 ro11 = ro10;\n    vec3 rd11 = rd10;\n    vec3 ro12 = ro11;\n    vec3 rd12 = rd11;\n    vec3 ro13 = ro12;\n    vec3 rd13 = rd12;\n    vec3 ro14 = ro13;\n    vec3 rd14 = rd13;\n    vec3 ro15 = ro14;\n    vec3 rd15 = rd14;\n    vec3 ro16 = ro15;\n    vec3 rd16 = rd15;\n    vec3 ro17 = ro16;\n    vec3 rd17 = rd16;\n    vec3 ro18 = ro17;\n    vec3", "\n    vec3 a = vec3(12.9898, 78.233, 45.145);\n    vec3 s = vec3(43758.5453, 22578.1455, 18123.1455);\n    vec3 f = fract(p);\n    f = f * f;\n    f = f * f;\n    float n = dot(p, a);\n    vec3 an = mod(floor(n), 73.1);\n    return mix(mix(mix(an.x + an.y + an.z, an.x + an.y, f.x), mix(an.x + an.z, an.y, f.x), f.y),\n               mix(mix(an.y + an.z, an.x, f.x), mix(an.y, an.z, f.x), f.y), f.z);\n}\n\n// Noise generator from https://otaviogood.github.io/noisegen/\n// Params: 3D, Seed 1, Waves 128, Octaves 7, Smooth 1\nfloat", "\n    vec2 uv = vec2( pos.x, pos.y );\n    uv.x *= _ScreenParams.x / _ScreenParams.y;\n    return uv;\n}\n\n//------------------------------------------------------------------\n\nvoid main()\n{\n    vec2 uv = map( _Position );\n    vec4 color = texture2D( _MainTex, uv );\n    gl_FragColor = color;\n}\n", "\n    float a = atan( p.y, p.x ) / 3.1415926535897932384626433832795;\n    float r = length( p );\n    return r * 0.5 + 0.5 * cos( a * 10.0 );\n}\n\n//=====================================================\n\nfloat", "\n    ProjectionResult result;\n\n    vec4 p = cam * sph;\n    vec3 p3 = p.xyz / p.w;\n\n    result.center = p3.xy;\n    result.axisMinor = dot(p3.xy, p3.xy);\n    result.axisMajor = dot(p3.xy, p3.xy) * fle;\n\n    result.a = p3.x;\n    result.b = p3.y;\n    result.c = p3.z;\n    result.d = -1.0;\n    result.e = -p3.x * p3.x - p3.y * p3.y;\n    result.f = -p3.x * p3.y;\n\n    return result;\n}\n\n// ---------------------------------------------------------------------------------------------\n\nProjectionResult projectCylinder( /* cylinder       */ in vec4 cyl, \n\t\t\t\t                /* camera matrix */ in mat4 cam,\n\t\t\t\t\t\t\t    /* projection    */ in float fle )\n{\n    ProjectionResult result;\n\n    vec4 p = cam * cyl;\n    vec3 p3 = p.xyz / p.w;\n\n    result.center = p3.xy;\n    result.axisMinor = dot(p3.xy, p3.xy);\n    result.axisMajor = dot(p3.xy, p3.xy) * fle;\n\n    result.a = p3.x;\n    result.b = p3.y;\n    result.c = p3.z;\n    result.d = -1.0;\n    result.e = -p3.x * p3.x - p3.y * p3.y;\n    result.f = -p3.x * p3.y;\n\n    return result;\n}\n\n// ---------------------------------------------------------------------------------------------\n\nProjectionResult projectCone( /* cone          */ in vec4 cone, \n\t\t\t\t                /* camera matrix */ in mat4 cam,\n\t\t\t\t\t\t\t    /* projection    */ in float fle )\n{\n    ProjectionResult result;\n\n    vec4 p = cam * cone;\n    vec3 p3 = p.xyz /", "\n    vec2 uv = vec2( pos.x, pos.y );\n    uv.x *= _ScreenParams.x / _ScreenParams.y;\n    return uv;\n}\n\n//------------------------------------------------------------------\n\nvoid main()\n{\n    vec2 uv = map( _Position );\n    vec4 color = texture2D( _MainTex, uv );\n    gl_FragColor = color;\n}\n", "\n    vec3 y = vec3( 0.0 );\n    y.x = x.x + x.y + x.z;\n    y.y = x.x - x.y - x.z;\n    y.z = x.x + x.y - x.z;\n    return y;\n}\n\nvec", "\n    float tmin = 0.001, tmax = 1000.0;\n    float t0 = 0.0, t1 = 0.0;\n    float tnear = tmin, tfar = tmax;\n    float tymin = 0.0, tymax = 1000.0;\n    float tzmin = 0.0, tzmax = 1000.0;\n    float tymin2 = 0.0, tymax2 = 1000.0;\n    float tzmin2 = 0.0, tzmax2 = 1000.0;\n    float tmin2 = 0.0, tmax2 = 0.0;\n    float tmin3 = 0.0, tmax3 = 0.0;\n    float tmin4 = 0.0, tmax4 = 0.0;\n    float tmin5 = 0.0, tmax5 = 0.0;\n    float tmin6 = 0.0, tmax6 = 0.0;\n    float tmin7 = 0.0, tmax7 = 0.0;\n    float tmin8 = 0.0, tmax8 = 0.0;\n    float tmin9 = 0.0, tmax9 = 0.0;\n    float tmin10 = 0.0, tmax10 = 0.0;\n    float tmin11 = 0.0, tmax11 = 0.0;\n    float tmin12 = 0.0, tmax12 = 0.0;\n    float tmin13 = 0.0, tmax13 = 0.0;\n    float tmin14 = 0.0, tmax14 = 0.0;\n    float tmin15 = 0.0, tmax15 = 0.0;\n    float tmin16 = 0.0, tmax16 = 0.0;\n    float tmin17 = 0.0, tmax17 = 0.0;\n    float tmin18 = 0.0, tmax18 = 0.0;\n    float tmin19 = 0.0, tmax19 = 0.0;\n    float tmin2", "\n    float tmin = 0.001, tmax = 1000.0;\n    float t0 = 0.0, t1 = 0.0;\n    float tnear = tmin, tfar = tmax;\n    float tymin = 0.0, tymax = 1000.0;\n    float tzmin = 0.0, tzmax = 1000.0;\n    float tymin2 = 0.0, tymax2 = 1000.0;\n    float tzmin2 = 0.0, tzmax2 = 1000.0;\n    float tmin2 = 0.0, tmax2 = 0.0;\n    float tmin3 = 0.0, tmax3 = 0.0;\n    float tmin4 = 0.0, tmax4 = 0.0;\n    float tmin5 = 0.0, tmax5 = 0.0;\n    float tmin6 = 0.0, tmax6 = 0.0;\n    float tmin7 = 0.0, tmax7 = 0.0;\n    float tmin8 = 0.0, tmax8 = 0.0;\n    float tmin9 = 0.0, tmax9 = 0.0;\n    float tmin10 = 0.0, tmax10 = 0.0;\n    float tmin11 = 0.0, tmax11 = 0.0;\n    float tmin12 = 0.0, tmax12 = 0.0;\n    float tmin13 = 0.0, tmax13 = 0.0;\n    float tmin14 = 0.0, tmax14 = 0.0;\n    float tmin15 = 0.0, tmax15 = 0.0;\n    float tmin16 = 0.0, tmax16 = 0.0;\n    float tmin17 = 0.0, tmax17 = 0.0;\n    float tmin18 = 0.0, tmax18 = 0.0;\n    float tmin19 = 0.0, tmax19 = 0.0;\n    float tmin2", "\n    vec2 d = fwidth(p);\n    vec2 a = d.xy;\n    vec2 b = d.yx;\n    vec2 k = (a - b) / d;\n    vec2 t = p - k*floor(p+k*0.5);\n    vec2 u = clamp( t, -a, a );\n    vec2 v = clamp( t-a, -b, b );\n    float x = length(u);\n    float y = length(v);\n    return x*x + y*y;\n}\n\n// grid ratio\nfloat", "\n    float t = texture( iChannel0, p ).r;\n    return t;\n}\n\nfloat", "\n    float tmin = 0.001, tmax = 1000.0;\n    float t0 = 0.0, t1 = 0.0;\n    float tnear = tmin, tfar = tmax;\n    float tymin = 0.0, tymax = 1000.0;\n    float tzmin = 0.0, tzmax = 1000.0;\n    float tymin2 = 0.0, tymax2 = 1000.0;\n    float tzmin2 = 0.0, tzmax2 = 1000.0;\n    float tmin2 = 0.0, tmax2 = 0.0;\n    float tmin3 = 0.0, tmax3 = 0.0;\n    float tmin4 = 0.0, tmax4 = 0.0;\n    float tmin5 = 0.0, tmax5 = 0.0;\n    float tmin6 = 0.0, tmax6 = 0.0;\n    float tmin7 = 0.0, tmax7 = 0.0;\n    float tmin8 = 0.0, tmax8 = 0.0;\n    float tmin9 = 0.0, tmax9 = 0.0;\n    float tmin10 = 0.0, tmax10 = 0.0;\n    float tmin11 = 0.0, tmax11 = 0.0;\n    float tmin12 = 0.0, tmax12 = 0.0;\n    float tmin13 = 0.0, tmax13 = 0.0;\n    float tmin14 = 0.0, tmax14 = 0.0;\n    float tmin15 = 0.0, tmax15 = 0.0;\n    float tmin16 = 0.0, tmax16 = 0.0;\n    float tmin17 = 0.0, tmax17 = 0.0;\n    float tmin18 = 0.0, tmax18 = 0.0;\n    float tmin19 = 0.0, tmax19 = 0.0;\n    float tmin2", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    float t = length(p);\n    float a = atan(p.y,p.x);\n    float r = (t*t*t*t*t - 10.0*t*t + 10.0)/2.0;\n    return r*cos(a*5.0) + 0.5;\n}\n\nfloat", "\n    vec2 p = p0;\n    vec2 q = p1;\n    vec2 r = p2;\n    vec2 s = (p + q) * 0.5;\n    vec2 t = (q + r) * 0.5;\n    vec2 u = (s + t) * 0.5;\n    vec2 v = (t + r) * 0.5;\n    vec2 w = (u + v) * 0.5;\n    vec2 x = (v + w) * 0.5;\n    vec2 y = (w + u) * 0.5;\n    vec2 z = (u + x) * 0.5;\n    vec2 a = (x + y) * 0.5;\n    vec2 b = (y + z) * 0.5;\n    vec2 c = (z + a) * 0.5;\n    vec2 d = (a + b) * 0.5;\n    vec2 e = (b + c) * 0.5;\n    vec2 f = (c + d) * 0.5;\n    vec2 g = (d + e) * 0.5;\n    vec2 h = (e + f) * 0.5;\n    vec2 i = (f + g) * 0.5;\n    vec2 j = (g + h) * 0.5;\n    vec2 k = (h + i) * 0.5;\n    vec2 l = (i + j) * 0.5;\n    vec2 m = (j + k) * 0.5;\n    vec2 n = (k + l) * 0.5;\n    vec2 o = (l + m) * 0.5;\n    vec2 p1 = (m + n) * 0.5;\n    vec2 q1 = (n + o) * 0.5;\n    vec2 r1 = (o + p) * 0.5;\n    vec2 s1 = (p +", "\n    vec3 bmin = vec3( min( min( min( p0.x, p1.x ), p2.x ), p3.x ),\n                      min( min( min( p0.y, p1.y ), p2.y ), p3.y ),\n                      min( min( min( p0.z, p1.z ), p2.z ), p3.z ) );\n    vec3 bmax = vec3( max( max( max( p0.x, p1.x ), p2.x ), p3.x ),\n                      max( max( max( p0.y, p1.y ), p2.y ), p3.y ),\n                      max( max( max( p0.z, p1.z ), p2.z ), p3.z ) );\n    return bound3( bmin, bmax );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://www.iquilezles.org/www/articles/spheresphere/spheresphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://www.iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 ab = b - a;\n    vec3 ap = p - a;\n    vec3 bp = p - b;\n    float t1 = dot( ap, ab );\n    float t2 = dot( bp, ab );\n    float t3 = dot( ap, ab );\n    float t4 = dot( bp, ab );\n    float tmin = max( max( t1, t2 ), max( t3, t4 ) );\n    float tmax = min( min( t1, t2 ), min( t3,", "\n    vec2 res = vec2( -1.0 );\n    vec3 q = rd / rd.z;\n    vec3 t1 = (cen - ro) * q;\n    vec3 t2 = (cen - ro) * q + vec3( rad.x, rad.y, rad.z );\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    res.x = max( tmin.x, max( tmin.y, tmin.z ) );\n    res.y = min( tmax.x, min( tmax.y, tmax.z ) );\n    return res;\n}\n\n// ray-box intersection (simplified)\nvec", "\n\tfloat2 iResolution = vec2(width, height);\n\tfloat2 uv = fragCoord / iResolution;\n\tfloat r = cos(iTime+uv.x+0), g = cos(iTime+uv.y+2), b = cos(iTime+uv.x+4);\n\tfloat3 fragColor = clamp(0.5 + 0.5 * vec3(r,g,b),0.0,1.0);\n\tfloat colour;\n\tGLubyte bytes[] = {(GLubyte)(fragColor.x*255+0.5),(GLubyte)(fragColor.y*255+0.5),(GLubyte)(fragColor.z*255+0.5)};\n\tmemcpy(&colour, &bytes, sizeof(colour));\n\tfragColor = vec4(x, y, colour);\n}\n\nvoid main()\n{\n\tShowCursor(0);\n\tfloat s = GetTickCount();\n\tdo\n\t{\n\t\ttimer = (GetTickCount()-s)*0.001f;\n\t\tmainImage(gl_FragColor, gl_FragCoord.xy);\n\t} while (!GetAsyncKeyState(VK_ESCAPE));\n}\n\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iGlobalTime;\n    float a = t * 0.001;\n    float b = t * 0.002;\n    float c = t * 0.003;\n    float d = t * 0.004;\n    float e = t * 0.005;\n    float f = t * 0.006;\n    float g = t * 0.007;\n    float h = t * 0.008;\n    float i = t * 0.009;\n    float j = t * 0.01;\n    float k = t * 0.011;\n    float l = t * 0.012;\n    float m = t * 0.013;\n    float n = t * 0.014;\n    float o = t * 0.015;\n    float p = t * 0.016;\n    float q = t * 0.017;\n    float r = t * 0.018;\n    float s = t * 0.019;\n    float t = t * 0.02;\n    float u = t * 0.021;\n    float v = t * 0.022;\n    float w = t * 0.023;\n    float x = t * 0.024;\n    float y = t * 0.025;\n    float z = t * 0.026;\n\n    float r1 = sin(a) * 0.5 + 0.5;\n    float r2 = sin(b) * 0.5 + 0.5;\n    float r3 = sin(c) * 0.5 + 0.5;\n    float r4 = sin(d) * 0.5 + 0.5;\n", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tfloat t = GetTickCount()*0.001f;\n\tfloat s = sin(t);\n\tfloat c = cos(t);\n\tfloat a = atan(p.y,p.x);\n\tfloat r = length(p);\n\tfloat f = (r-0.5)*(r-0.5)*(r-0.5);\n\tfloat d = (r-0.5)*(r-0.5)*(r-0.5)*(r-0.5);\n\tfloat g = (r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5);\n\tfloat h = (r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5);\n\tfloat k = (r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5);\n\tfloat l = (r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5);\n\tfloat m = (r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5);\n\tfloat n = (r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5)*(r-0.5);\n\tfloat o = (r-0.", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.05;\n    float a = atan(p.y, p.x);\n    float r = length(p);\n    float s = sin(t + a);\n    float c = cos(t + a);\n    float z = r * c;\n    float x = r * s;\n    float y = sqrt(r * r - z * z);\n    vec3 v = vec3(x, y, z);\n    vec3 n = normalize(v);\n    vec3 l = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 r = reflect(l, n);\n    vec3 c1 = vec3(0.0, 0.0, 0.0);\n    vec3 c2 = vec3(0.0, 0.0, 0.0);\n    vec3 c3 = vec3(0.0, 0.0, 0.0);\n    vec3 c4 = vec3(0.0, 0.0, 0.0);\n    vec3 c5 = vec3(0.0, 0.0, 0.0);\n    vec3 c6 = vec3(0.0, 0.0, 0.0);\n    vec3 c7 = vec3(0.0, 0.0, 0.0);\n    vec3 c8 = vec3(0.0, 0.0, 0.0);\n    vec3 c9 = vec3(0.0, 0.0, 0.0);\n    vec3 c10 = vec3(0.0, 0.0, 0.0);\n    vec3 c11 = vec3(0.0, 0.0, 0.0);\n   ", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n  vec3 ab = pb - pa;\n  vec3 ap = pa - ro;\n  float b = dot(ab, rd);\n  float c = dot(ab, ab) - ra*ra;\n  float d = b*b - c;\n  if (d < 0.0) return (vec4(0.0));\n  d = sqrt(d);\n  float t = -b - d;\n  if (t < 0.0) t = -b + d;\n  if (t < 0.0) return (vec4(0.0));\n  vec3 pt = ro + t*rd;\n  vec3 n = normalize(pt - pa);\n  return (vec4(n, t));\n}\n\n//-----------------------------------------------------------------\n// ray - sphere intersection, return.xyz=normal, return.w=distance\n//   https://www.shadertoy.com/view/MtcXRf\n//-----------------------------------------------------------------\nvec", "\n  vec3 ab = pb - pa;\n  vec3 ap = pa - ro;\n  float b = dot(ab, rd);\n  float c = dot(ab, ab) - ra*ra;\n  float d = b*b - c;\n  if (d < 0.0) return vec4(0.0);\n  float sqrtD = sqrt(d);\n  float t0 = -b - sqrtD;\n  float t1 = -b + sqrtD;\n  if (t0 > t1) swap(t0, t1);\n  float t = t0;\n  if (t < 0.0) t = t1;\n  if (t < 0.0) return vec4(0.0);\n  vec3 p = ro + t*rd;\n  vec3 n = normalize(p - pa);\n  return vec4(n, t);\n}\n\n//-----------------------------------------------------------------\n// ray - infinite cylinder intersection, return.xyz=normal, return.w=distance\n//   https://www.shadertoy.com/view/MtcXRf\n//-----------------------------------------------------------------\nvec", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - (r1 + r2 - ba.z) * abs(h);\n}\n\n// rounded cone distance see https://www.shadertoy.com/view/tdXGWr\nfloat", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// 2D Perlin noise\nfloat", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x, 1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, vec3(1,57,113));\n    return mix(mix(mix(dot(i, vec3(1,57,113)), i.yzx, f.xzx),\n                   mix(i.xyx, i.yzx, f.yzx), f.yzx),\n               mix(mix(dot(i, vec3(1,57,113)), i.xzy, f.xzy),\n                   mix(i.xyx, i.xzy, f.xyx), f.xyx), f.zxy);\n}\n\n/* 3d simplex noise */\nfloat", "\n    return fract(sin(vec2(dot(v, vec2(127.1, 311.7)), dot(v, vec2(269.5, 183.3)))) * 43758.5453);\n}\n\nfloat", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec2 res = vec2( 0.0 );\n    res.x = p.x;\n    res.y = p.y;\n    return res;\n}\n\n//------------------------------------------------------------------\n\nvec", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec2 res = vec2( 0.0 );\n    res.x = p.x;\n    res.y = p.y;\n    return res;\n}\n\n//------------------------------------------------------------------\n\nvec", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n  return 1.0 / (1.0 + exp(-x));\n}\n\nfloat", "\n    vec3 p = ro + rd*ra;\n    return dot(p,p) - ra*ra;\n}\n\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat", "\n    vec3 col = vec3(0.0);\n    vec3 pos = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float dmin = 1.0;\n    float dmax = 100.0;\n    float dmin2 = 1.0;\n    float dmax2 = 100.0;\n    float dmin3 = 1.0;\n    float dmax3 = 100.0;\n    float dmin4 = 1.0;\n    float dmax4 = 100.0;\n    float dmin5 = 1.0;\n    float dmax5 = 100.0;\n    float dmin6 = 1.0;\n    float dmax6 = 100.0;\n    float dmin7 = 1.0;\n    float dmax7 = 100.0;\n    float dmin8 = 1.0;\n    float dmax8 = 100.0;\n    float dmin9 = 1.0;\n    float dmax9 = 100.0;\n    float dmin10 = 1.0;\n    float dmax10 = 100.0;\n    float dmin11 = 1.0;\n    float dmax11 = 100.0;\n    float dmin12 = 1.0;\n    float dmax12 = 100.0;\n    float dmin13 = 1.0;\n    float dmax13 = 100.0;\n    float dmin14 = 1.0;\n    float dmax14 = 100.0;\n    float dmin15 = 1.0;\n    float dmax15 = 100.0;\n    float dmin16 = 1.0;\n    float dmax16 = 100.0;\n    float dmin17 = 1.0;\n    float dmax17 = 100.0;\n    float dmin18 = 1.0;\n    float dmax18 = 100.0;\n    float dmin19 = 1.0;\n    float dmax19 = 10", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(q,q) * 0.5;\n    return 0.5 * (1.0 - step(f, g)) * (1.0 - step(g, f)) * (1.0 - step(f, g)) * (1.0 - step(g, f));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 ray_dir = normalize(dir);\n    vec3 ray_start = start;\n    vec3 ray_end = start + ray_dir * max_dist;\n    vec3 ray_color = vec3(0.0);\n    vec3 light_color = vec3(0.0);\n    vec3 light_start = planet_position + light_dir * height_ray;\n    vec3 light_end = planet_position + light_dir * height_mie;\n    vec3 light_ray_dir = normalize(light_end - light_start);\n    vec3 light_ray_start = light_start;\n    vec3 light_ray_end = light_start + light_ray_dir * max_dist;\n    vec3 light_ray_color = vec3(0.0);\n    vec3 light_ray_start_color = vec3(0.0);\n    vec3 light_ray_end_color = vec3(0.0);\n    vec3 light_ray_color_temp = vec3(0.0);\n    vec3 light_ray_start_color_temp = vec3(0.0);\n    vec3 light_ray_end_color_temp = vec3(0.0);\n    vec3 light_ray_color_temp_temp = vec3(0.0);\n    vec3 light_ray_start_color_temp_temp = vec3(0.0);\n    vec3 light_ray_end_color_temp_temp = vec3(0.0);\n    vec3 light_ray_color_temp_temp_temp = vec3(0.0);\n    vec3 light_ray_start_color_temp_temp_temp = vec3(0.0);\n    vec3 light_ray_end_color_temp_temp_temp = vec3(0.0);\n    vec3 light_ray_color_temp_temp_temp_temp = vec3(0.0);\n    vec3 light_", "\n    vec3 oc = start - camera.position; // the oc of the ray and the camera\n    float a = dot(dir, dir); // the a of the ray\n    float b = 2.0 * dot(oc, dir); // the b of the ray\n    float c = dot(oc, oc) - radius * radius; // the c of the ray\n    float discriminant = b * b - 4.0 * a * c; // the discriminant of the ray\n    if (discriminant < 0.0) {\n        return vec2(-1.0); // if the discriminant is less than 0, return -1\n    }\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a); // the t1 of the ray\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a); // the t2 of the ray\n    if (t1 < 0.0) {\n        t1 = t2; // if t1 is less than 0, set t1 to t2\n        if (t1 < 0.0) {\n            return vec2(-1.0); // if t1 is less than 0, return -1\n        }\n    }\n    return vec2(t1, t2); // return the t1 and t2 of the ray\n}\n\n/*\nA ray-plane intersect\nThis was previously used in the atmosphere as well, but it's only used for the planet intersect now, since the atmosphere has this\nray plane intersect built in\n*/\n\nvec", "\n    vec3 sky_col = vec3(0.0);\n    vec3 light_dir_norm = normalize(light_dir);\n    vec3 view_dir = normalize(sample_pos - camera_pos);\n    float cos_theta = dot(light_dir_norm, view_dir);\n    float epsilon = 0.0001;\n    float attenuation = 1.0 / (1.0 + epsilon + epsilon * cos_theta * cos_theta);\n    vec3 diffuse = attenuation * light_col * max(0.0, dot(surface_normal, light_dir_norm));\n    vec3 reflect_dir = reflect(-light_dir_norm, surface_normal);\n    vec3 reflect_col = vec3(0.0);\n    if (dot(view_dir, reflect_dir) > 0.0) {\n        reflect_col = skylight(sample_pos + reflect_dir * 0.001, surface_normal, reflect_dir, background_col);\n    }\n    sky_col = diffuse + reflect_col;\n    return sky_col;\n}\n\n/*\nThis function is used to calculate the color of the atmosphere\n*/\nvec", "\n    vec4 color = vec4(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_attenuation = vec3(1.0);\n    vec3 light_ambient = vec3(0.0);\n    vec3 light_diffuse = vec3(0.0);\n    vec3 light_specular = vec3(0.0);\n    vec3 light_spot_dir = vec3(0.0);\n    vec3 light_spot_color = vec3(0.0);\n    vec3 light_spot_attenuation = vec3(0.0);\n    vec3 light_spot_ambient = vec3(0.0);\n    vec3 light_spot_diffuse = vec3(0.0);\n    vec3 light_spot_specular = vec3(0.0);\n    vec3 light_spot_spot_dir = vec3(0.0);\n    vec3 light_spot_spot_color = vec3(0.0);\n    vec3 light_spot_spot_attenuation = vec3(0.0);\n    vec3 light_spot_spot_ambient = vec3(0.0);\n    vec3 light_spot_spot_diffuse = vec3(0.0);\n    vec3 light_spot_spot_specular = vec3(0.0);\n    vec3 light_spot_spot_spot_dir = vec3(0.0);\n    vec3 light_spot_spot_spot_color = vec3(0.0);\n    vec3 light_spot_spot_spot_attenuation = vec3(0.0);\n    vec3 light_spot_spot_spot_ambient = vec3(0.0);\n    vec3 light_spot_spot_spot_diffuse = vec3(0.0);\n    vec3 light_spot_spot_spot_specular = vec3(0", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 camPos = vec3(0.0, 0.0, 1.0);\n    vec3 camDir = vec3(0.0, 0.0, -1.0);\n    vec3 lightDir = vec3(0.0, 0.0, 1.0);\n\n    //get the ray direction\n    vec3 rayDir = normalize(camDir + lightDir);\n\n    //get the ray origin\n    vec3 rayOrigin = camPos;\n\n    //get the ray color\n    vec3 rayColor = vec3(0.0, 0.0, 0.0);\n\n    //get the ray length\n    float rayLength = 1.0;\n\n    //get the ray step\n    float rayStep = 0.001;\n\n    //get the ray step\n    float rayStep2 = 0.001;\n\n    //get the ray step\n    float rayStep3 = 0.001;\n\n    //get the ray step\n    float rayStep4 = 0.001;\n\n    //get the ray step\n    float rayStep5 = 0.001;\n\n    //get the ray step\n    float rayStep6 = 0.001;\n\n    //get the ray step\n    float rayStep7 = 0.001;\n\n    //get the ray step\n    float rayStep8 = 0.001;\n\n    //get the ray step\n    float rayStep9 = 0.001;\n\n    //get the ray step\n    float rayStep10 = 0.001;\n\n    //get the ray step\n    float rayStep11 = 0.001;\n\n    //get the ray step\n    float rayStep12 = 0.001;\n\n    //get the ray step\n    float rayStep13 = 0.001;\n\n    //get the ray step\n    float rayStep14 = 0.001;\n\n    //get the ray step\n    float rayStep15 = 0.00", "\n    vec3 color = vec3(0.0);\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    vec3 ray_position = ray_origin;\n    for (int i = 0; i < MAX_PATHS; i++) {\n        vec3 hit_position = ray_position;\n        vec3 hit_normal = vec3(0.0);\n        vec3 hit_color = vec3(0.0);\n        float hit_distance = MAX_DISTANCE;\n        for (int j = 0; j < NUM_OBJECTS; j++) {\n            float distance = ray_intersect(ray_position, ray_direction, objects[j]);\n            if (distance < hit_distance) {\n                hit_distance = distance;\n                hit_position = ray_position + ray_direction * distance;\n                hit_normal = objects[j].normal(hit_position);\n                hit_color = objects[j].color(hit_position);\n            }\n        }\n        if (hit_distance < MAX_DISTANCE) {\n            color += hit_color * (1.0 - hit_distance / MAX_DISTANCE);\n            ray_position = hit_position + hit_normal * EPSILON;\n            ray_direction = reflect(ray_direction, hit_normal);\n        } else {\n            break;\n        }\n    }\n    return color;\n}\n\n// Trace the path of a ray, i.e. from the camera position to a\n// ray direction depending on a fragment's position in the render.\n// The function will incorporate up to MAX_PATHS reflections and\n// refractions in the final sample color.\nvec", "\n    return fract(sin(x)*43758.5453);\n}\n\n// 2D Perlin noise\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 pos = p;\n    float t = 0.0;\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float aa = 0.0;\n    float ab = 0.0;\n    float ac = 0.0;\n    float ad = 0.0;\n    float ae = 0.0;\n    float af = 0.0;\n    float ag = 0.0;\n    float ah = 0.0;\n    float ai = 0.0;\n    float aj = 0.0;\n    float ak = 0.0;\n    float al = 0.0;\n    float am = 0.0;\n    float an = 0.0;\n    float ao = 0.0;\n    float ap = 0.0;\n    float aq = 0.0;\n    float ar = 0.0;\n    float as = 0.0;\n    float at = 0.0;\n    float au = 0.0;\n    float av = 0.0;\n    float aw = 0.0;\n    float ax = 0.0;\n    float ay = 0.0;\n    float az = 0.0;\n    float ba = ", "\n    vec3 col = vec3(0.0);\n    vec3 pos = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float dmin = 1.0;\n    float dmax = 100.0;\n    float dmin2 = 1.0;\n    float dmax2 = 100.0;\n    float dmin3 = 1.0;\n    float dmax3 = 100.0;\n    float dmin4 = 1.0;\n    float dmax4 = 100.0;\n    float dmin5 = 1.0;\n    float dmax5 = 100.0;\n    float dmin6 = 1.0;\n    float dmax6 = 100.0;\n    float dmin7 = 1.0;\n    float dmax7 = 100.0;\n    float dmin8 = 1.0;\n    float dmax8 = 100.0;\n    float dmin9 = 1.0;\n    float dmax9 = 100.0;\n    float dmin10 = 1.0;\n    float dmax10 = 100.0;\n    float dmin11 = 1.0;\n    float dmax11 = 100.0;\n    float dmin12 = 1.0;\n    float dmax12 = 100.0;\n    float dmin13 = 1.0;\n    float dmax13 = 100.0;\n    float dmin14 = 1.0;\n    float dmax14 = 100.0;\n    float dmin15 = 1.0;\n    float dmax15 = 100.0;\n    float dmin16 = 1.0;\n    float dmax16 = 100.0;\n    float dmin17 = 1.0;\n    float dmax17 = 100.0;\n    float dmin18 = 1.0;\n    float dmax18 = 100.0;\n    float dmin19 = 1.0;\n    float dmax19 = 10", "\n    float res = 1.0;\n    float t = tmin;\n    for (int i = 0; i < 100; i++)\n    {\n        float h = map(ro + rd * t);\n        res = min(res, h * w);\n        t += h;\n        if (h < 0.001 || t > tmax)\n            break;\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec4 color = vec4( 0.0 );\n    float t = time * 0.5;\n    float r = length( pos );\n    float a = atan( pos.y, pos.x );\n    float s = sin( a );\n    float c = cos( a );\n    float x = r * c;\n    float y = r * s;\n    float z = r * t;\n    float d = ( 1.0 - smoothstep( 0.0, 0.001, r ) ) * 0.5;\n    float aa = smoothstep( 0.0, 0.001, r );\n    float bb = smoothstep( 0.0, 0.001, r );\n    float cc = smoothstep( 0.0, 0.001, r );\n    float dd = smoothstep( 0.0, 0.001, r );\n    float ee = smoothstep( 0.0, 0.001, r );\n    float ff = smoothstep( 0.0, 0.001, r );\n    float gg = smoothstep( 0.0, 0.001, r );\n    float hh = smoothstep( 0.0, 0.001, r );\n    float ii = smoothstep( 0.0, 0.001, r );\n    float jj = smoothstep( 0.0, 0.001, r );\n    float kk = smoothstep( 0.0, 0.001, r );\n    float ll = smoothstep( 0.0, 0.001, r );\n    float mm = smoothstep( 0.0, 0.001, r );\n    float nn = smoothstep( 0.0, 0.001, r );\n    float oo = smoothstep( 0.0, 0.001, r );\n    float pp = smoothstep( 0.0, 0.001, r );\n    float qq = smoothstep( 0.0, 0.", "\n    vec2 q = vec2(length(p.xz), p.y);\n    float k = r - b;\n    float s = (k*k)/(4.0*k*k);\n    float t = clamp(dot(q, q) - r*r, 0.0, k*k);\n    return sqrt(max(t, 0.0)) + s;\n}\n\nfloat", "\n    vec3 oc = r.origin - center;\n    float a = dot(r.direction, r.direction);\n    float b = 2.0 * dot(oc, r.direction);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n    vec2 pos = vec2(0.0);\n    float t = 0.0;\n    float dt = 0.0;\n    float dt2 = 0.0;\n    float dt3 = 0.0;\n    float dt4 = 0.0;\n    float dt5 = 0.0;\n    float dt6 = 0.0;\n    float dt7 = 0.0;\n    float dt8 = 0.0;\n    float dt9 = 0.0;\n    float dt10 = 0.0;\n    float dt11 = 0.0;\n    float dt12 = 0.0;\n    float dt13 = 0.0;\n    float dt14 = 0.0;\n    float dt15 = 0.0;\n    float dt16 = 0.0;\n    float dt17 = 0.0;\n    float dt18 = 0.0;\n    float dt19 = 0.0;\n    float dt20 = 0.0;\n    float dt21 = 0.0;\n    float dt22 = 0.0;\n    float dt23 = 0.0;\n    float dt24 = 0.0;\n    float dt25 = 0.0;\n    float dt26 = 0.0;\n    float dt27 = 0.0;\n    float dt28 = 0.0;\n    float dt29 = 0.0;\n    float dt30 = 0.0;\n    float dt31 = 0.0;\n    float dt32 = 0.0;\n    float dt33 = 0.0;\n    float dt34 = 0.0;\n    float dt35 = 0.0;\n    float dt36 = 0.0;\n    float dt37 = 0.0;\n    float dt38 = 0.0;\n    float dt39", "\n    vec2 q = vec2(p.x, p.y - 1.0);\n    vec2 a = vec2(0.0, 1.0);\n    vec2 b = vec2(1.0, 0.0);\n    vec2 c = vec2(0.0, -1.0);\n    vec2 d1 = vec2(1.0, 0.0);\n    vec2 d2 = vec2(0.0, 1.0);\n    vec2 d3 = vec2(-1.0, 0.0);\n    vec2 d4 = vec2(0.0, -1.0);\n    vec2 d5 = vec2(0.0, 1.0);\n    vec2 d6 = vec2(0.0, -1.0);\n    vec2 d7 = vec2(0.0, 1.0);\n    vec2 d8 = vec2(0.0, -1.0);\n    vec2 d9 = vec2(0.0, 1.0);\n    vec2 d10 = vec2(0.0, -1.0);\n    vec2 d11 = vec2(0.0, 1.0);\n    vec2 d12 = vec2(0.0, -1.0);\n    vec2 d13 = vec2(0.0, 1.0);\n    vec2 d14 = vec2(0.0, -1.0);\n    vec2 d15 = vec2(0.0, 1.0);\n    vec2 d16 = vec2(0.0, -1.0);\n    vec2 d17 = vec2(0.0, 1.0);\n    vec2 d18 = vec2(0.0, -1.0);\n    vec2 d19 = vec2(0.0, 1.0);\n    vec2 d20 = vec2(0.0, -1", "\n    return vec3(\n        p.x + q.x,\n        p.y + q.y,\n        p.z + q.z\n    );\n}\n\nvec", "\n    float a = atan( p.y, p.x ) / 3.1415926535897932384626433832795;\n    float r = length( p );\n    return r * 0.5 + 0.5 * cos( a * 10.0 );\n}\n\n//=====================================================\n\nfloat", "\n    vec2 res = vec2( 0.0 );\n    res.x = p.x;\n    res.y = p.y;\n    return res;\n}\n\n//------------------------------------------------------------------\n\nvec", "\n    vec2 q = vec2(fract(p.x), fract(p.y));\n    q = q*q*(3.0-2.0*q);\n    return dot(q, vec2(1.0-q.x,1.0-q.y));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec3 min = vec3( min( min( p0.x, p1.x ), p2.x ),\n                     min( min( p0.y, p1.y ), p2.y ),\n                     min( min( p0.z, p1.z ), p2.z ) );\n    vec3 max = vec3( max( max( p0.x, p1.x ), p2.x ),\n                     max( max( p0.y, p1.y ), p2.y ),\n                     max( max( p0.z, p1.z ), p2.z ) );\n    return bound3( min, max );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a sphere (http://www.iquilezles.org/www/articles/spheresphere/spheresphere.htm)\n//---------------------------------------------------------------------------------------\nbound3 SphereAABB( in vec3 p, in float r )\n{\n    return bound3( p - vec3( r ), p + vec3( r ) );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cylinder (http://www.iquilezles.org/www/articles/cylindercylinder/cylindercylinder.htm)\n//---------------------------------------------------------------------------------------\nbound3 CylinderAABB( in vec3 p, in vec3 a, in vec3 b )\n{\n    vec3 min = vec3( min( a.x, b.x ), min( a.y, b.y ), min( a.z, b.z ) );\n    vec3 max = vec3( max( a.x, b.x ), max( a.y, b.y ), max( a.z, b.z ) );\n    return bound3( min, max );\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a cone (http://www.iquilezles.org/www/articles/conecone/conecone.htm)\n//---------------------------------------------------------------------------------------\nbound3 ConeAABB( in vec3 p, in vec3 a, in vec3 b )\n{\n   ", "\n    vec2 res = vec2( -1.0 );\n    vec3 q = rd / rd.z;\n    vec3 t1 = (cen - ro) * q;\n    vec3 t2 = (cen - ro) * q + vec3( rad.x, rad.y, rad.z );\n    vec3 tmin = min( t1, t2 );\n    vec3 tmax = max( t1, t2 );\n    res.x = max( tmin.x, max( tmin.y, tmin.z ) );\n    res.y = min( tmax.x, min( tmax.y, tmax.z ) );\n    return res;\n}\n\n// ray-box intersection (simplified)\nvec", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(q,q) * 0.5;\n    return 0.5 * (1.0 - step(f, g)) * (1.0 - step(g, f)) * (1.0 - step(f, g)) * (1.0 - step(g, f));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec3 color = vec3(0.0);\n    vec2 q = p;\n    float a = 1.0;\n    float b = 0.0;\n    float c = 0.0;\n    float d = 0.0;\n    float e = 0.0;\n    float f = 0.0;\n    float g = 0.0;\n    float h = 0.0;\n    float i = 0.0;\n    float j = 0.0;\n    float k = 0.0;\n    float l = 0.0;\n    float m = 0.0;\n    float n = 0.0;\n    float o = 0.0;\n    float p = 0.0;\n    float q = 0.0;\n    float r = 0.0;\n    float s = 0.0;\n    float t = 0.0;\n    float u = 0.0;\n    float v = 0.0;\n    float w = 0.0;\n    float x = 0.0;\n    float y = 0.0;\n    float z = 0.0;\n    float w1 = 0.0;\n    float w2 = 0.0;\n    float w3 = 0.0;\n    float w4 = 0.0;\n    float w5 = 0.0;\n    float w6 = 0.0;\n    float w7 = 0.0;\n    float w8 = 0.0;\n    float w9 = 0.0;\n    float w10 = 0.0;\n    float w11 = 0.0;\n    float w12 = 0.0;\n    float w13 = 0.0;\n    float w14 = 0.0;\n    float w15 = 0.0;\n    float w16 = 0.0;\n    float w17 = 0.0;\n    float w18 = 0.0;\n    float w19 = 0.0;\n    float w20 = 0.0;\n    float w21 = 0.0;\n    float w22 = 0.0;\n    float w23 = 0.0;\n    float w24 = 0.0", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iGlobalTime;\n    float a = t * 0.001;\n    float b = t * 0.002;\n    float c = t * 0.003;\n    float d = t * 0.004;\n    float e = t * 0.005;\n    float f = t * 0.006;\n    float g = t * 0.007;\n    float h = t * 0.008;\n    float i = t * 0.009;\n    float j = t * 0.01;\n    float k = t * 0.011;\n    float l = t * 0.012;\n    float m = t * 0.013;\n    float n = t * 0.014;\n    float o = t * 0.015;\n    float p = t * 0.016;\n    float q = t * 0.017;\n    float r = t * 0.018;\n    float s = t * 0.019;\n    float t = t * 0.02;\n    float u = t * 0.021;\n    float v = t * 0.022;\n    float w = t * 0.023;\n    float x = t * 0.024;\n    float y = t * 0.025;\n    float z = t * 0.026;\n    float aa = t * 0.027;\n    float bb = t * 0.028;\n    float cc = t * 0.029;\n    float dd = t * 0.03;\n    float ee = t * 0.031;\n    float ff = t * 0.", "\n    p = vec2( dot(p,vec2(127.1,311.7)),\n              dot(p,vec2(269.5,183.3)) );\n    return -1.0 + 2.0*fract(sin(p)*43758.5453123);\n}\n\nfloat", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, vec3(1,57,113));\n    return mix(mix(mix(dot(i, vec3(1,57,113)), i.yzx, f.xzx),\n                   mix(i.xyx, i.yzx, f.yzx), f.yzx),\n               mix(mix(dot(i, vec3(1,57,113)), i.xzy, f.xzy),\n                   mix(i.xyx, i.xzy, f.xyx), f.xyx), f.zxy);\n}\n\n/* 3d simplex noise */\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float d = 0.0;\n    float t = 0.0;\n    float dp;\n    float dp2;\n    float dp3;\n    float dp4;\n    float dp5;\n    float dp6;\n    float dp7;\n    float dp8;\n    float dp9;\n    float dp10;\n    float dp11;\n    float dp12;\n    float dp13;\n    float dp14;\n    float dp15;\n    float dp16;\n    float dp17;\n    float dp18;\n    float dp19;\n    float dp20;\n    float dp21;\n    float dp22;\n    float dp23;\n    float dp24;\n    float dp25;\n    float dp26;\n    float dp27;\n    float dp28;\n    float dp29;\n    float dp30;\n    float dp31;\n    float dp32;\n    float dp33;\n    float dp34;\n    float dp35;\n    float dp36;\n    float dp37;\n    float dp38;\n    float dp39;\n    float dp40;\n    float dp41;\n    float dp42;\n    float dp43;\n    float dp44;\n    float dp45;\n    float dp46;\n    float dp47;\n    float dp48;\n    float dp49;\n    float dp50;\n    float dp51;\n    float dp52;\n    float dp53;\n    float dp54;\n    float dp55;\n    float dp56;\n    float dp57;\n    float dp58;\n    float dp59;\n    float dp60;", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(q,q) * 0.5;\n    return 0.5 * (1.0 - step(f, g)) * (1.0 - step(g, f)) * (1.0 - step(f, g)) * (1.0 - step(g, f));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = TIME_DELAY + iTime;\n    float d = DISPLACEMENT;\n\n    vec2 q = p;\n    vec2 r = p;\n    for (int i = 0; i < 100; i++)\n    {\n        q = p + vec2(sin(t + q.x), cos(t + q.y));\n        r = p + vec2(sin(t + r.x), cos(t + r.y));\n        t += 0.01;\n    }\n\n    vec2 dp = q - p;\n    vec2 dr = r - p;\n    float dd = length(dp);\n    float drr = length(dr);\n\n    float dd2 = dd * dd;\n    float drr2 = drr * drr;\n    float ddrr = dd2 + drr2;\n    float ddrr2 = ddrr * ddrr;\n    float ddrr3 = ddrr2 * ddrr2;\n    float ddrr4 = ddrr3 * ddrr2;\n    float ddrr5 = ddrr4 * ddrr2;\n    float ddrr6 = ddrr5 * ddrr2;\n    float ddrr7 = ddrr6 * ddrr2;\n    float ddrr8 = ddrr7 * ddrr2;\n    float ddrr9 = ddrr8 * ddrr2;\n    float ddrr10 = ddrr9 * ddrr2;\n    float ddrr11 = ddrr10 * ddrr2;\n    float ddrr12 = ddrr11 * ddrr2;\n    float ddrr13 = ddrr12 * ddrr2;\n    float ddrr14 = ddrr13 * dd", "\n    return max(d, abs(p.y) - h);\n}\n\nfloat", "\n    vec2 q = p - ab;\n    float k = dot(q, q) / dot(ab, ab);\n    float s = sqrt(max(0.0, 1.0 - k));\n    return vec3(q.x * s, q.y * s, 0.0);\n}\n\n//.x = f(p)\n//.y = \u2202f(p)/\u2202x\n//.z = \u2202f(p)/\u2202y\n//.yz = \u2207f(p) with \u2016\u2207f(p)\u2016 = 1\nvec", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", "\n    return mix(vec3(1.0, 0.0, 0.0), vec3(0.0, 1.0, 0.0), val);\n}\n\n/* Returns rgb vec from input 0-1 */\nvec", "\n    vec2 q = p - ab;\n    float k = dot(q,q) / dot(ab,ab);\n    return sqrt(max(k-0.25,0.0)) + min(max(k-0.5,0.0),0.0);\n}\n\nfloat", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(q,q) * 0.5;\n    return 0.5 * (1.0 - step(f, g)) * (1.0 - step(g, f)) * (1.0 - step(f, g)) * (1.0 - step(g, f));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(q,q) * 0.5;\n    return 0.5 * (1.0 - step(f, g)) * (1.0 - step(g, f)) * (1.0 - step(f, g)) * (1.0 - step(g, f));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    float t = iGlobalTime;\n    float a = t * 0.001;\n    float b = t * 0.002;\n    float c = t * 0.003;\n    float d = t * 0.004;\n    float e = t * 0.005;\n    float f = t * 0.006;\n    float g = t * 0.007;\n    float h = t * 0.008;\n    float i = t * 0.009;\n    float j = t * 0.01;\n    float k = t * 0.011;\n    float l = t * 0.012;\n    float m = t * 0.013;\n    float n = t * 0.014;\n    float o = t * 0.015;\n    float p = t * 0.016;\n    float q = t * 0.017;\n    float r = t * 0.018;\n    float s = t * 0.019;\n    float tt = t * 0.02;\n    float u = t * 0.021;\n    float v = t * 0.022;\n    float w = t * 0.023;\n    float x = t * 0.024;\n    float y = t * 0.025;\n    float z = t * 0.026;\n\n    float r1 = sin(a) * 0.5 + 0.5;\n    float r2 = sin(b) * 0.5 + 0.5;\n    float r3 = sin(c) * 0.5 + 0.5;\n    float r4 = sin(d) * 0.5 + 0.5;", "\n    uint a = idx, b = count, t;\n    a ^= seed;\n    b ^= seed;\n    t = a;\n    a = b;\n    b = t;\n    a ^= b;\n    b ^= a;\n    a ^= b;\n    return a;\n}\n\n//src/main.cpp\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <cmath>\n#include <cstdlib>\n#include <ctime>\n#include <cstdint>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstdint>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstdint>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstdint>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstdint>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstdint>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <cstdint>\n#include <cstring>\n#include <cassert>\n#include <cstdio>\n#include <cctype>\n#include <cmath>\n#include <cstdlib>\n#include <c", "\n    return 0.5*(exp(x)-exp(-x))/(exp(x)+exp(-x));\n}\n\nfloat", "\n    vec3 p = pIn;\n    p.x -= a;\n    p.y -= b;\n    p.z -= h;\n    float d = length(p);\n    if (d > a) {\n        return vec4(0.0);\n    }\n    float d2 = d*d;\n    float d4 = d2*d2;\n    float d6 = d4*d2;\n    float d8 = d6*d2;\n    float d10 = d8*d2;\n    float d12 = d10*d2;\n    float d14 = d12*d2;\n    float d16 = d14*d2;\n    float d18 = d16*d2;\n    float d20 = d18*d2;\n    float d22 = d20*d2;\n    float d24 = d22*d2;\n    float d26 = d24*d2;\n    float d28 = d26*d2;\n    float d30 = d28*d2;\n    float d32 = d30*d2;\n    float d34 = d32*d2;\n    float d36 = d34*d2;\n    float d38 = d36*d2;\n    float d40 = d38*d2;\n    float d42 = d40*d2;\n    float d44 = d42*d2;\n    float d46 = d44*d2;\n    float d48 = d46*d2;\n    float d50 = d48*d2;\n    float d52 = d50*d2;\n    float d54 = d52*d2;\n    float d56 = d54*d2;\n    float d58 = d56*d2;\n    float d60 = d58*d2;\n    float d62 = d60*d2;\n    float d64 = d62*d2;\n    float d66", "\n    return 0.5*(exp(x)-exp(-x))/(exp(x)+exp(-x));\n}\n\nfloat", "\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n    e5 = p2;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4, inout vec2 e5, inout vec2 e6) {\n    vec2 d2 = d / 2.0;\n    vec2 p2 = p - d2;\n    vec2 p3 = p + d2;\n    e1 = p2;\n    e2 = p3;\n    e3 = p2;\n    e4 = p3;\n    e5 = p2;\n    e6 = p3;\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec2 p, vec2 d, inout vec2 e1, inout vec2 e2, inout vec2 e3, inout vec2 e4,", "\n    return 0.5 * (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\nfloat", "\n    return 0.5*(exp(x)-exp(-x))/(exp(x)+exp(-x));\n}\n\nfloat", "\n    vec2 pa = p - va, ba = vb - va;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - rb;\n}\n\n\n// -------------------------------\n// -------------------------------\n// -------------------------------\n\n\nfloat", "\n    return length(p) - r;\n}\n\n//-------------------------------------------------\n\nfloat", "\n    return 0.5*tanh(0.5*x);\n}\n\nfloat", "\n    vec2 ab = b - a;\n    vec2 pa = p - a;\n    float h = length( pa );\n    float c = dot( pa, ab ) / dot( ab, ab );\n    if( c < 0.0 ) return length( pa ) - w1 - w2;\n    if( c > 1.0 ) return length( pa - ab ) - w1 - w2;\n    return length( cross( pa - ab*c, ab ) ) - w1 - w2;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n\n    vec3 col = vec3(0.0);\n\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float r = (d - 0.01) / 0.02;\n    float t = mod(a, 2.0 * 3.14159265359);\n    float s = sin(t);\n    float c = cos(t);\n    float x = r * c;\n    float y = r * s;\n\n    float f = fract(x);\n    float g = fract(y);\n\n    float h = f * g;\n    float k = h * (1.0 - h);\n    float l = k * (1.0 - h);\n    float m = l * (1.0 - h);\n\n    float n = k * (1.0 - h);\n    float o = l * (1.0 - h);\n    float p = m * (1.0 - h);\n\n    float q = n * (1.0 - h);\n    float r = o * (1.0 - h);\n    float s = p * (1.0 - h);\n\n    float t = q * (1.0 - h);\n    float u = r * (1.0 - h);\n    float v = s * (1.0 - h);\n\n    float w = t * (1.0 - h);\n    float x = u * (1.0 - h);\n    float y = v * (1.0 - h);\n\n    float z = w * (1.0 - h);\n\n    col = vec3(x, y, z);\n\n    fragColor = vec4(col, 1.0);\n}\n\n// -----------------------------------------------\n\nvoid main()\n{\n    mainImage(gl_FragColor, gl_FragCoord.xy);", "\n    return (exp(x) - exp(-x)) / (exp(x) + exp(-x));\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    vec2 p = q;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x) / 3.14159265359;\n    float r = (d - 0.001) * 0.001;\n    float c = cos(a * 10.0) * 0.5 + 0.5;\n    float s = sin(a * 10.0) * 0.5 + 0.5;\n    float t = (d - 0.001) * 0.001;\n    float b = (t - 0.001) * 0.001;\n    float n = (t - 0.001) * 0.001;\n    float f = (t - 0.001) * 0.001;\n    float g = (t - 0.001) * 0.001;\n    float h = (t - 0.001) * 0.001;\n    float k = (t - 0.001) * 0.001;\n    float l = (t - 0.001) * 0.001;\n    float m = (t - 0.001) * 0.001;\n    float o = (t - 0.001) * 0.001;\n    float p = (t - 0.001) * 0.001;\n    float q = (t - 0.001) * 0.001;\n    float r = (t - 0.001) * 0.001;\n    float s = (t - 0.001) * 0.001;\n    float t = (t - 0.001) * 0.001;\n    float u = (t - 0.001) * 0.001;\n   ", "\n    vec2 p = q;\n    p.x *= iResolution.x / iResolution.y;\n    float d = length(p);\n    float a = atan(p.y, p.x) / 3.14159265359;\n    float r = (d - 0.001) * 0.001;\n    float c = cos(a * 10.0) * 0.5 + 0.5;\n    float s = sin(a * 10.0) * 0.5 + 0.5;\n    float t = (d - 0.001) * 0.001;\n    float b = (t - 0.001) * 0.001;\n    float n = (t - 0.001) * 0.001;\n    float f = (t - 0.001) * 0.001;\n    float g = (t - 0.001) * 0.001;\n    float h = (t - 0.001) * 0.001;\n    float k = (t - 0.001) * 0.001;\n    float l = (t - 0.001) * 0.001;\n    float m = (t - 0.001) * 0.001;\n    float o = (t - 0.001) * 0.001;\n    float p = (t - 0.001) * 0.001;\n    float q = (t - 0.001) * 0.001;\n    float r = (t - 0.001) * 0.001;\n    float s = (t - 0.001) * 0.001;\n    float t = (t - 0.001) * 0.001;\n    float u = (t - 0.001) * 0.001;\n   ", "\n    vec2 d = vec2( 0.0, 0.0 );\n    d.x = dFdx( z.x );\n    d.y = dFdy( z.y );\n    return d;\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nfloat", "\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t = p;\n    vec2 u = p;\n    vec2 v = p;\n    vec2 w = p;\n    vec2 x = p;\n    vec2 y = p;\n    vec2 z = p;\n    vec2 a = p;\n    vec2 b = p;\n    vec2 c = p;\n    vec2 d = p;\n    vec2 e = p;\n    vec2 f = p;\n    vec2 g = p;\n    vec2 h = p;\n    vec2 i = p;\n    vec2 j = p;\n    vec2 k = p;\n    vec2 l = p;\n    vec2 m = p;\n    vec2 n = p;\n    vec2 o = p;\n    vec2 p = p;\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t = p;\n    vec2 u = p;\n    vec2 v = p;\n    vec2 w = p;\n    vec2 x = p;\n    vec2 y = p;\n    vec2 z = p;\n    vec2 a = p;\n    vec2 b = p;\n    vec2 c = p;\n    vec2 d = p;\n    vec2 e = p;\n    vec2 f = p;\n    vec2 g = p;\n    vec2 h = p;\n    vec2 i = p;\n    vec2 j = p;\n    vec2 k = p;\n    vec2 l = p;\n    vec2 m = p;\n    vec2 n = p;\n    vec2 o = p;\n    vec2 p = p;\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t = p;\n    vec2 u = p", "\n\n    // get the pixel color from the texture\n    vec4 texColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor2 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor3 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor4 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor5 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor6 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor7 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor8 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor9 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor10 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor11 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor12 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor13 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(q,q) * 0.5;\n    return 0.5 * (1.0 - step(f, g)) * (1.0 - step(g, f)) * (1.0 - step(f, g)) * (1.0 - step(g, f));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat", "\n    vec2 d = vec2( 0.0, 0.0 );\n    d.x = dFdx( z.x );\n    d.y = dFdy( z.y );\n    return d;\n}\n\n// from https://www.shadertoy.com/view/XdXGW8 - used for noise below\nfloat", "\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t = p;\n    vec2 u = p;\n    vec2 v = p;\n    vec2 w = p;\n    vec2 x = p;\n    vec2 y = p;\n    vec2 z = p;\n    vec2 a = p;\n    vec2 b = p;\n    vec2 c = p;\n    vec2 d = p;\n    vec2 e = p;\n    vec2 f = p;\n    vec2 g = p;\n    vec2 h = p;\n    vec2 i = p;\n    vec2 j = p;\n    vec2 k = p;\n    vec2 l = p;\n    vec2 m = p;\n    vec2 n = p;\n    vec2 o = p;\n    vec2 p = p;\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t = p;\n    vec2 u = p;\n    vec2 v = p;\n    vec2 w = p;\n    vec2 x = p;\n    vec2 y = p;\n    vec2 z = p;\n    vec2 a = p;\n    vec2 b = p;\n    vec2 c = p;\n    vec2 d = p;\n    vec2 e = p;\n    vec2 f = p;\n    vec2 g = p;\n    vec2 h = p;\n    vec2 i = p;\n    vec2 j = p;\n    vec2 k = p;\n    vec2 l = p;\n    vec2 m = p;\n    vec2 n = p;\n    vec2 o = p;\n    vec2 p = p;\n    vec2 q = p;\n    vec2 r = p;\n    vec2 s = p;\n    vec2 t = p;\n    vec2 u = p", "\n\n    // get the pixel color from the texture\n    vec4 texColor = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor2 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor3 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor4 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor5 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor6 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor7 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor8 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor9 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor10 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor11 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor12 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n    // get the pixel color from the texture\n    vec4 texColor13 = texture(iChannel0, fragCoord.xy / iResolution.xy);\n\n", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<50; i++ )\n    {\n        float h = map(ro+rd*t);\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( res<0.002 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\n// http://iquilezles.org/www/articles/rmshadows/rmshadows.htm\nfloat", "\n    vec2 q = p - 0.5;\n    float f = dot(q,q);\n    float g = dot(q,q) * 0.5;\n    return 0.5 * (1.0 - step(f, g)) * (1.0 - step(g, f)) * (1.0 - step(f, g)) * (1.0 - step(g, f));\n}\n\n// http://iquilezles.org/www/articles/checkerfiltering/checkerfiltering.htm\nfloat"], "input_docstring": ["\n    vec3 p0 = vec3( 0.0, 0.0, 0.0 );\n    vec3 p1 = vec3( 1.0, 0.0, 0.0 );\n    vec3 p2 = vec3( 0.0, 1.0, 0.0 );\n\n    // edge vectors\n    vec3 e0 = p1 - p0;\n    vec3 e1 = p2 - p0;\n\n    // normal vector\n    vec3 n = cross( e0, e1 );\n\n    // projection of p onto plane\n    float d = dot( n, p - p0 );\n\n    // distance from p to plane\n    float t = -dot( n, p - p0 ) / dot( n, e1 );\n\n    // point on plane\n    vec3 pt = p0 + t * e1;\n\n    // distance from pt to triangle\n    float d2 = distance( pt, p );\n\n    // distance from p to plane\n    float d3 = distance( pt, p0 );\n\n    // distance from p to plane\n    float d4 = distance( pt, p1 );\n\n    // distance from p to plane\n    float d5 = distance( pt, p2 );\n\n    // distance from p to plane\n    float d6 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 );\n\n    // distance from p to plane\n    float d7 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 ) - d;\n\n    // distance from p to plane\n    float d8 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 ) - d6;\n\n    // distance from p to plane\n    float d9 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 ) - d7;\n\n    // distance from p to plane\n    float d10 = distance( pt, p0 ) + distance( pt, p", "\n    vec3 rotated = Rotate(p, rotDir);\n\n    // Rotate the object back to the original position\n    vec3 rotatedBack = Rotate(rotated, -rotDir);\n\n    // Get the distance to the object\n    float dist = length(rotatedBack - rotated);\n\n    // Return the distance\n    return dist;\n}\n\nfloat", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv_offset = uv - 0.5;\n\tuv_offset.x *= iResolution.x / iResolution.y;\n\tvec2 dir = normalize(uv_offset);\n\n\t//get the ray\n\tvec3 ray = vec3(0.0);\n\tray.x = dir.x * iCamera.x;\n\tray.y = dir.y * iCamera.y;\n\tray.z = iCamera.z;\n\n\t//get the raymarching distance\n\tfloat t = 0.0;\n\tfloat t_max = 1000.0;\n\n\t//get the color\n\tvec3 color = vec3(0.0);\n\n\t//raymarch\n\twhile(t < t_max)\n\t{\n\t\t//get the position\n\t\tvec3 pos = ray * t;\n\n\t\t//get the distance\n\t\tfloat d = getDistance(pos);\n\n\t\t//get the color\n\t\tvec3 c = getColor(pos);\n\n\t\t//get the attenuation\n\t\tfloat attenuation = getAttenuation(pos);\n\n\t\t//get the color\n\t\tcolor += c * attenuation;\n\n\t\t//get the distance\n\t\tt += d;\n\t}\n\n\t//get the final color\n\tcolor = pow(color, vec3(1.0 / 2.2));\n\n\t//get the final color\n\tfragColor = vec4(color, 1.0);\n}\n\n//get the distance\nfloat", "\n\n    vec2 cc = vec2( 1.5*cos(0.1*iTime) - 0.25*cos(0.2*iTime), \n\t                1.5*sin(0.1*iTime) - 0.25*sin(0.2*iTime) );\n\n    vec2 z = p;\n    float m = 0.0;\n    for (int i = 0; i < 100; i++) {\n        z = vec2(z.x*z.x - z.y*z.y, 2.0*z.x*z.y) + cc;\n        m = length(z);\n        if (m > 2.0) break;\n    }\n    return vec4(m, m, m, 1.0);\n}\n\nvoid main()\n{\n    vec2 p = (gl_FragCoord.xy * 2.0 - iResolution.xy) / min(iResolution.x, iResolution.y);\n    vec4 col = juliaSet(p);\n    gl_FragColor = col;\n}\n", " and forth\n    float fade = clamp(0.5 - dot(rayDir, sunDir), 0.0, 1.0);\n    return mix(vec3(0.0), vec3(0.5), fade);\n}\n\nvec", "\n\tvec3 pos = vec3(0.0, 0.0, 0.0);\n\tvec3 rot = vec3(0.0, 0.0, 0.0);\n\tvec3 rot_axis = vec3(0.0, 0.0, 0.0);\n\tfloat rot_angle = 0.0;\n\tfloat rot_speed = 0.0;\n\tfloat rot_accel = 0.0;\n\tfloat rot_decel = 0.0;\n\tfloat rot_max_speed = 0.0;\n\tfloat rot_max_accel = 0.0;\n\tfloat rot_max_decel = 0.0;\n\tfloat rot_max_angle = 0.0;\n\tfloat rot_max_speed_accel = 0.0;\n\tfloat rot_max_speed_decel = 0.0;\n\tfloat rot_max_angle_accel = 0.0;\n\tfloat rot_max_angle_decel = 0.0;\n\tfloat rot_max_angle_accel_decel = 0.0;\n\tfloat rot_max_angle_accel_decel_max = 0.0;\n\tfloat rot_max_angle_accel_decel_max_accel = 0.0;\n\tfloat rot_max_angle_accel_decel_max_decel = 0.0;\n\tfloat rot_max_angle_accel_decel_max_accel_decel = 0.0;\n\tfloat rot_max_angle_accel_decel_max_accel_decel_max = 0.0;\n\tfloat rot_max_angle_accel_decel_max_accel_decel_max_accel = 0.0;\n\tfloat rot_max_angle_accel_decel_max_accel_decel_max_decel = 0.0;\n\tfloat rot_max_angle_accel_decel_max_accel_decel_max_accel_decel = 0.0;\n\tfloat rot_max_angle_accel_decel_max_accel_decel_max_accel_decel_", "\n\tvec3 n = normalize(cross(e, vec3(0, 1, 0)));\n\tvec3 d = dot(p, n) * n;\n\tfloat k = length(d);\n\tvec3 uv = d / k;\n\treturn texture(tex_plane, uv).rgb;\n}\n\nvoid main()\n{\n\tvec3 p = vec3(gl_FragCoord.xy, 0);\n\tvec3 e = vec3(0, 1, 0);\n\tvec3 r = vec3(0, 0, 1);\n\tvec3 up = vec3(0, 1, 0);\n\tvec3 f = vec3(0, 0, 1);\n\tvec3 c = vec3(0, 0, 0);\n\tvec3 l = vec3(0, 0, 0);\n\tvec3 v = vec3(0, 0, 0);\n\tvec3 n = vec3(0, 0, 0);\n\tvec3 b = vec3(0, 0, 0);\n\tvec3 t = vec3(0, 0, 0);\n\tvec3 s = vec3(0, 0, 0);\n\tvec3 a = vec3(0, 0, 0);\n\tvec3 d = vec3(0, 0, 0);\n\tvec3 g = vec3(0, 0, 0);\n\tvec3 h = vec3(0, 0, 0);\n\tvec3 j = vec3(0, 0, 0);\n\tvec3 k = vec3(0, 0, 0);\n\tvec3 m = vec3(0, 0, 0);\n\tvec3 o = vec3(0, 0, 0);\n\tvec3 q = vec3(0, 0, 0);\n\tvec3 rr = vec3(0, 0, 0);\n\tvec3 ss = vec3(0, 0, 0);\n\tvec3 ttt = vec3", " and forth\n    float fade = clamp(0.5 - dot(rayDir, sunDir), 0.0, 1.0);\n    return mix(vec3(0.0), vec3(0.5), fade);\n}\n\nvec", "\n  float distanceToSurface = far;\n  vec3 surfaceNormal = vec3(0.0);\n  vec3 surfacePosition = vec3(0.0);\n  vec3 surfaceColor = vec3(0.0);\n  vec3 surfaceTangent = vec3(0.0);\n  vec3 surfaceBitangent = vec3(0.0);\n  vec3 surfaceUV = vec3(0.0);\n  vec3 surfaceLight = vec3(0.0);\n  vec3 surfaceLightColor = vec3(0.0);\n  vec3 surfaceLightDirection = vec3(0.0);\n  vec3 surfaceLightPosition = vec3(0.0);\n  vec3 surfaceLightColor2 = vec3(0.0);\n  vec3 surfaceLightDirection2 = vec3(0.0);\n  vec3 surfaceLightPosition2 = vec3(0.0);\n  vec3 surfaceLightColor3 = vec3(0.0);\n  vec3 surfaceLightDirection3 = vec3(0.0);\n  vec3 surfaceLightPosition3 = vec3(0.0);\n  vec3 surfaceLightColor4 = vec3(0.0);\n  vec3 surfaceLightDirection4 = vec3(0.0);\n  vec3 surfaceLightPosition4 = vec3(0.0);\n  vec3 surfaceLightColor5 = vec3(0.0);\n  vec3 surfaceLightDirection5 = vec3(0.0);\n  vec3 surfaceLightPosition5 = vec3(0.0);\n  vec3 surfaceLightColor6 = vec3(0.0);\n  vec3 surfaceLightDirection6 = vec3(0.0);\n  vec3 surfaceLightPosition6 = vec3(0.0);\n  vec3 surfaceLightColor7 = vec3(0.0);\n  vec3 surfaceLightDirection7 = vec3(0.0);\n  vec3 surfaceLightPosition7 = vec3(0.0);\n  vec3 surfaceLightColor8 = ve", "\n  // 0.0 - 1.0\n  // 0.0 - 255.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.", "\n    vec2 res;\n\n    // map the point to the unit cube\n    res.x = (p.x + 1.0) * 0.5;\n    res.y = (p.y + 1.0) * 0.5;\n\n    // map the point to the unit sphere\n    res.x = res.x * 2.0 - 1.0;\n    res.y = res.y * 2.0 - 1.0;\n\n    // map the point to the unit disk\n    if (res.x * res.x + res.y * res.y > 1.0)\n        discard;\n\n    // map the point to the unit disk\n    res.x = res.x * sqrt(1.0 - res.y * res.y);\n    res.y = res.y * sqrt(1.0 - res.x * res.x);\n\n    // map the point to the unit disk\n    res.x *= resolution;\n    res.y *= resolution;\n\n    return res;\n}\n\n// compute the ray direction\nvec", "\n\tfloat t = 0.0;\n\tfloat tmin = 0.0;\n\tfloat tmax = 10000.0;\n\tfloat tmin2 = 0.0;\n\tfloat tmax2 = 10000.0;\n\tfloat tmin3 = 0.0;\n\tfloat tmax3 = 10000.0;\n\tfloat tmin4 = 0.0;\n\tfloat tmax4 = 10000.0;\n\tfloat tmin5 = 0.0;\n\tfloat tmax5 = 10000.0;\n\tfloat tmin6 = 0.0;\n\tfloat tmax6 = 10000.0;\n\tfloat tmin7 = 0.0;\n\tfloat tmax7 = 10000.0;\n\tfloat tmin8 = 0.0;\n\tfloat tmax8 = 10000.0;\n\tfloat tmin9 = 0.0;\n\tfloat tmax9 = 10000.0;\n\tfloat tmin10 = 0.0;\n\tfloat tmax10 = 10000.0;\n\tfloat tmin11 = 0.0;\n\tfloat tmax11 = 10000.0;\n\tfloat tmin12 = 0.0;\n\tfloat tmax12 = 10000.0;\n\tfloat tmin13 = 0.0;\n\tfloat tmax13 = 10000.0;\n\tfloat tmin14 = 0.0;\n\tfloat tmax14 = 10000.0;\n\tfloat tmin15 = 0.0;\n\tfloat tmax15 = 10000.0;\n\tfloat tmin16 = 0.0;\n\tfloat tmax16 = 10000.0;\n\tfloat tmin17 = 0.0;\n\tfloat tmax17 = 10000.0;\n\tfloat tmin18 = 0.0;\n\tfloat tmax18 = 10000.0;\n\tfloat tmin19 = 0.0;\n\tfloat tmax19", "\n    vec4 res;\n\n    // map the point to the unit cube\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit sphere\n    p.y = abs(p.y);\n\n    // map the point to the unit disk\n    if (p.x * p.x + p.y * p.y > 1.0)\n        return res;\n\n    // map the point to the unit square\n    p.x = abs(p.x);\n\n    // map the point to the unit rectangle\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y > 1.0)\n        return res;\n\n    // map the point to the unit circle\n    if (p.x * p.x + p.y * p.y < 1.0)\n        return res;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit circle\n    if (p.x * p.x + p.y * p.y < 1.0)\n        return res;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p", "\n    vec3 p = ro;\n    vec3 d = rd;\n    vec3 step = vec3(0.0);\n    vec3 dp;\n    vec3 dp2;\n    vec3 dp3;\n    vec3 dp4;\n    vec3 dp5;\n    vec3 dp6;\n    vec3 dp7;\n    vec3 dp8;\n    vec3 dp9;\n    vec3 dp10;\n    vec3 dp11;\n    vec3 dp12;\n    vec3 dp13;\n    vec3 dp14;\n    vec3 dp15;\n    vec3 dp16;\n    vec3 dp17;\n    vec3 dp18;\n    vec3 dp19;\n    vec3 dp20;\n    vec3 dp21;\n    vec3 dp22;\n    vec3 dp23;\n    vec3 dp24;\n    vec3 dp25;\n    vec3 dp26;\n    vec3 dp27;\n    vec3 dp28;\n    vec3 dp29;\n    vec3 dp30;\n    vec3 dp31;\n    vec3 dp32;\n    vec3 dp33;\n    vec3 dp34;\n    vec3 dp35;\n    vec3 dp36;\n    vec3 dp37;\n    vec3 dp38;\n    vec3 dp39;\n    vec3 dp40;\n    vec3 dp41;\n    vec3 dp42;\n    vec3 dp43;\n    vec3 dp44;\n    vec3 dp45;\n    vec3 dp46;\n    vec3 dp47;\n    vec3 dp48;\n    vec3 dp4", "\n    vec3 wp = (modelMatrix * vec4(p, 1.0)).xyz;\n    vec3 wo = (modelMatrix * vec4(oN, 0.0)).xyz;\n    vec3 wd = wp - wo;\n\n    // world pos diff\n    vec3 wp2 = (modelMatrix * vec4(p + wd, 1.0)).xyz;\n    vec3 wo2 = (modelMatrix * vec4(oN + wd, 0.0)).xyz;\n    vec3 wd2 = wp2 - wo2;\n\n    // world pos diff\n    vec3 wp3 = (modelMatrix * vec4(p + wd2, 1.0)).xyz;\n    vec3 wo3 = (modelMatrix * vec4(oN + wd2, 0.0)).xyz;\n    vec3 wd3 = wp3 - wo3;\n\n    // world pos diff\n    vec3 wp4 = (modelMatrix * vec4(p + wd3, 1.0)).xyz;\n    vec3 wo4 = (modelMatrix * vec4(oN + wd3, 0.0)).xyz;\n    vec3 wd4 = wp4 - wo4;\n\n    // world pos diff\n    vec3 wp5 = (modelMatrix * vec4(p + wd4, 1.0)).xyz;\n    vec3 wo5 = (modelMatrix * vec4(oN + wd4, 0.0)).xyz;\n    vec3 wd5 = wp5 - wo5;\n\n    // world pos diff\n    vec3 wp6 = (modelMatrix * vec4(p + wd5, 1.0)).xyz;\n    vec3 wo6 = (modelMatrix * vec4(oN + wd5, 0.0)).xyz;\n    vec3 wd6 = wp6 - wo6;\n\n    // world pos diff\n    vec3", "\n    return vec2(0.0);\n}\n\nvec", "\n    vec4 res;\n\n    // map the point to the unit cube\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit sphere\n    p.y = abs(p.y);\n\n    // map the point to the unit disk\n    if (p.x * p.x + p.y * p.y > 1.0)\n        return res;\n\n    // map the point to the unit square\n    p.x = abs(p.x);\n\n    // map the point to the unit rectangle\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y > 1.0)\n        return res;\n\n    // map the point to the unit circle\n    if (p.x * p.x + p.y * p.y < 1.0)\n        return res;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit circle\n    if (p.x * p.x + p.y * p.y < 1.0)\n        return res;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p.x + p.y < 1.0)\n        return res;\n\n    // map the point to the unit square\n    p = p * 2.0 - 1.0;\n\n    // map the point to the unit triangle\n    if (p", "\n    vec3 p = ro;\n    vec3 d = rd;\n    vec3 step = vec3(0.0);\n    vec3 dp;\n    vec3 dp2;\n    vec3 dp3;\n    vec3 dp4;\n    vec3 dp5;\n    vec3 dp6;\n    vec3 dp7;\n    vec3 dp8;\n    vec3 dp9;\n    vec3 dp10;\n    vec3 dp11;\n    vec3 dp12;\n    vec3 dp13;\n    vec3 dp14;\n    vec3 dp15;\n    vec3 dp16;\n    vec3 dp17;\n    vec3 dp18;\n    vec3 dp19;\n    vec3 dp20;\n    vec3 dp21;\n    vec3 dp22;\n    vec3 dp23;\n    vec3 dp24;\n    vec3 dp25;\n    vec3 dp26;\n    vec3 dp27;\n    vec3 dp28;\n    vec3 dp29;\n    vec3 dp30;\n    vec3 dp31;\n    vec3 dp32;\n    vec3 dp33;\n    vec3 dp34;\n    vec3 dp35;\n    vec3 dp36;\n    vec3 dp37;\n    vec3 dp38;\n    vec3 dp39;\n    vec3 dp40;\n    vec3 dp41;\n    vec3 dp42;\n    vec3 dp43;\n    vec3 dp44;\n    vec3 dp45;\n    vec3 dp46;\n    vec3 dp47;\n    vec3 dp48;\n    vec3 dp4", "\n    vec3 wp = (modelMatrix * vec4(p, 1.0)).xyz;\n    vec3 wo = (modelMatrix * vec4(oN, 0.0)).xyz;\n    vec3 wd = wp - wo;\n\n    // world pos diff\n    vec3 wp2 = (modelMatrix * vec4(p + wd, 1.0)).xyz;\n    vec3 wo2 = (modelMatrix * vec4(oN + wd, 0.0)).xyz;\n    vec3 wd2 = wp2 - wo2;\n\n    // world pos diff\n    vec3 wp3 = (modelMatrix * vec4(p + wd2, 1.0)).xyz;\n    vec3 wo3 = (modelMatrix * vec4(oN + wd2, 0.0)).xyz;\n    vec3 wd3 = wp3 - wo3;\n\n    // world pos diff\n    vec3 wp4 = (modelMatrix * vec4(p + wd3, 1.0)).xyz;\n    vec3 wo4 = (modelMatrix * vec4(oN + wd3, 0.0)).xyz;\n    vec3 wd4 = wp4 - wo4;\n\n    // world pos diff\n    vec3 wp5 = (modelMatrix * vec4(p + wd4, 1.0)).xyz;\n    vec3 wo5 = (modelMatrix * vec4(oN + wd4, 0.0)).xyz;\n    vec3 wd5 = wp5 - wo5;\n\n    // world pos diff\n    vec3 wp6 = (modelMatrix * vec4(p + wd5, 1.0)).xyz;\n    vec3 wo6 = (modelMatrix * vec4(oN + wd5, 0.0)).xyz;\n    vec3 wd6 = wp6 - wo6;\n\n    // world pos diff\n    vec3", " and forth\n    float fade = (1.0 - abs(rayDir.y)) * 0.5;\n    return mix(vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0), fade);\n}\n\nvec", "\n    vec3 p2 = p;\n    p2.x += sin(p.y * 10.0) * 0.5;\n    p2.y += cos(p.y * 10.0) * 0.5;\n    p2.z += sin(p.y * 10.0) * 0.5;\n    p2.x += sin(p.z * 10.0) * 0.5;\n    p2.y += cos(p.z * 10.0) * 0.5;\n    p2.z += sin(p.z * 10.0) * 0.5;\n    p2.x += sin(p.x * 10.0) * 0.5;\n    p2.y += cos(p.x * 10.0) * 0.5;\n    p2.z += sin(p.x * 10.0) * 0.5;\n\n    // find the distance to the closest object.\n    float d = length(p2 - _ball.position);\n    return vec2(d, 0.0);\n}\n\nvec", "\n    vec3 p = pos;\n    vec3 p0 = floor(p);\n    vec3 f = fract(p);\n    vec3 i = floor(f);\n    vec3 gi = i;\n    vec3 g = f - i;\n    \n    // Get cube face id\n    int faceId = int(i.x) + int(i.y) * 2 + int(i.z) * 4;\n    \n    // Get permutation matrix\n    mat3 P = mat3(\n        1.0, 0.0, 0.0,\n        0.0, 1.0, 0.0,\n        0.0, 0.0, 1.0\n    );\n    \n    // Get grid position\n    vec2 g0 = g;\n    g = g - vec2(0.5);\n    g = (g + 1.0) * vec2(0.5);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2(2.0) - vec2(1.0);\n    g = g * vec2", "\n    vec2 p = (g + 0.5) / vec2(N);\n    \n    // Map [-1,1] to [0,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - 1.0;\n    \n    // Map [0,1] to [-1,1]\n    p = p * 2.0 - ", "\n\tfloat dot = dot(a, b);\n\tfloat sqr = dot * dot;\n\treturn sqr / (1.0f - sqr);\n}\n\nfloat", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv_offset = uv - 0.5;\n\tuv_offset.x *= iResolution.x / iResolution.y;\n\tvec2 dir = normalize(uv_offset);\n\n\t//get the ray\n\tvec3 ray = vec3(0.0);\n\tray.x = dir.x * iCamera.x;\n\tray.y = dir.y * iCamera.y;\n\tray.z = iCamera.z;\n\n\t//get the raymarching distance\n\tfloat t = 0.0;\n\tfloat t_max = 1000.0;\n\n\t//get the color\n\tvec3 color = vec3(0.0);\n\n\t//raymarch\n\twhile(t < t_max)\n\t{\n\t\t//get the position\n\t\tvec3 pos = ray * t;\n\n\t\t//get the distance\n\t\tfloat d = getDistance(pos);\n\n\t\t//get the color\n\t\tvec3 c = getColor(pos);\n\n\t\t//get the attenuation\n\t\tfloat attenuation = getAttenuation(pos);\n\n\t\t//get the color\n\t\tcolor += c * attenuation;\n\n\t\t//get the distance\n\t\tt += d;\n\t}\n\n\t//get the final color\n\tcolor = pow(color, vec3(1.0 / 2.2));\n\n\t//get the final color\n\tfragColor = vec4(color, 1.0);\n}\n\n//get the distance\nfloat", "\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate(vec3(0,1.,1.),10.,vec3(0.), p);\n  //p = qRotate", "\n    // I'm not sure if this is the best way to do it.\n    if (pt.x < -1.0 || pt.x > 1.0 || pt.y < -1.0 || pt.y > 1.0 || pt.z < -1.0 || pt.z > 1.0)\n        return 0.0;\n\n    // I'm not sure if this is the best way to do it.\n    float t = (pt.x + 1.0) / 2.0;\n    t = (t * t * (3.0 - 2.0 * t)) + (pt.y + 1.0) / 2.0;\n    t = (t * t * (3.0 - 2.0 * t)) + (pt.z + 1.0) / 2.0;\n    return t;\n}\n\nfloat", "\n    //It is just a bit more complicated\n    //The idea is to use the coordinates of the pixel to determine the color of the pixel\n    //The color of the pixel is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from the center of the fractal is determined by the distance of the pixel from the center of the fractal\n    //The distance of the pixel from", "\n    rounded = min(rounded, length(pB - pA));\n\n    // Get the distance from the line to the point.\n    float dist = distance(pA, pB);\n\n    // If the distance is less than the rounded radius, then it's on the line.\n    if (dist < rounded) {\n        return 1.0;\n    }\n\n    // If the distance is greater than the rounded radius, then it's not on the line.\n    if (dist > rounded) {\n        return 0.0;\n    }\n\n    // Get the distance from the point to the line.\n    float distToLine = distance(pA, uv);\n\n    // If the distance is less than the thickness, then it's on the line.\n    if (distToLine < thick.x) {\n        return 1.0;\n    }\n\n    // If the distance is greater than the thickness, then it's not on the line.\n    if (distToLine > thick.x) {\n        return 0.0;\n    }\n\n    // If the distance is less than the rounded radius, then it's on the line.\n    if (distToLine < rounded) {\n        return 1.0;\n    }\n\n    // If the distance is greater than the rounded radius, then it's not on the line.\n    if (distToLine > rounded) {\n        return 0.0;\n    }\n\n    // If the distance is less than the thickness, then it's on the line.\n    if (distToLine < thick.y) {\n        return 1.0;\n    }\n\n    // If the distance is greater than the thickness, then it's not on the line.\n    if (distToLine > thick.y) {\n        return 0.0;\n    }\n\n    // If the distance is less than the rounded radius, then it's on the line.\n    if (distToLine < rounded) {\n        return 1.0;\n    }\n\n    // If the distance is greater than the rounded radius, then it's not on the line.\n    if (distToLine > rounded) {\n        return 0", "\n    vec2 f = vec2( 0.25, 0.25 );\n\n    // sample the texture\n    vec4 texel = texture2D( checkersTexture, p );\n\n    // compute the gradient\n    vec2 grad = vec2(\n        texture2D( checkersTexture, p + f * ddx ).r - texel.r,\n        texture2D( checkersTexture, p + f * ddy ).r - texel.r\n    );\n\n    // compute the dot product\n    return dot( grad, grad );\n}\n\nvoid main()\n{\n    // compute the gradient\n    vec2 grad = vec2(\n        checkersTextureGradBox( gl_FragCoord.xy, vec2( 1.0, 0.0 ), vec2( 0.0, 1.0 ) ),\n        checkersTextureGradBox( gl_FragCoord.xy, vec2( 0.0, 1.0 ), vec2( 1.0, 0.0 ) )\n    );\n\n    // compute the dot product\n    float dot = dot( grad, grad );\n\n    // compute the threshold\n    float threshold = 0.0001;\n\n    // compute the alpha\n    float alpha = smoothstep( threshold, 0.0, dot );\n\n    // compute the color\n    vec4 color = vec4( 0.0, 0.0, 0.0, 1.0 );\n\n    // compute the color\n    if( dot > threshold )\n    {\n        color = vec4( 1.0, 1.0, 1.0, 1.0 );\n    }\n\n    // output the color\n    gl_FragColor = color;\n}\n", " the scene\n    float tmin = 0.001, tmax = 1000.0;\n    float t = 0.0;\n    vec3 p = ro;\n    vec3 n = vec3(0.0);\n    float occ = 0.0;\n    int matid = 1;\n    for( int i = 0; i < 100; i++ )\n    {\n        if( tmin > t || t > tmax ) break;\n        t += tmin;\n        p = ro + t*rd;\n        float d = map( p );\n        if( d < 0.001 )\n        {\n            n = vec3(0.0);\n            occ = 0.0;\n            break;\n        }\n        tmin = d;\n        n = normalize( p - vec3( map( p - vec3(0.0, 0.0, tmin) ) ) );\n        occ = map( p - vec3(0.0, 0.0, tmin) );\n        if( occ > 0.0 )\n        {\n            matid = 2;\n            break;\n        }\n    }\n    pos = ro + t*rd;\n    nor = n;\n    if( t > tmax )\n    {\n        matid = 0;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // image\n    vec2 p = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3( 2.0, 1.0, 1.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3 vv = normalize( cross( ww,", "\n\tvec3 bmin = cen - rad;\n\tvec3 bmax = cen + rad;\n\tvec3 tmin = (bmin - ro) / rd;\n\tvec3 tmax = (bmax - ro) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(t1.x, max(t1.y, t1.z));\n\tfloat t3 = min(t2.x, min(t2.y, t2.z));\n\tfloat tN = max(t0, t3);\n\tfloat tF = min(t2.x, t2.y);\n\tfloat tB = max(t1.y, t1.z);\n\tfloat tL = min(t1.x, t1.z);\n\tfloat tH = max(t2.y, t2.z);\n\tfloat tS = max(t2.x, t1.y);\n\tfloat t4 = max(tF, tB);\n\tfloat t6 = min(tL, tH);\n\tfloat t5 = max(tS, t4);\n\tfloat t7 = min(t6, t5);\n\tfloat t8 = max(tN, t7);\n\tfloat t9 = min(t8, tT);\n\tfloat t = max(t9, 0.0);\n\treturn vec2(t, t);\n}\n\nvec", "\n    vec3 ab = pb - pa;\n    vec3 abn = normalize( ab );\n    // center the cylinder\n    vec3 ca = pa + abn * 0.5;\n    // cylinder radius\n    float r = length( pb - pa );\n    // cylinder height\n    float h = length( pb - ca );\n    // cylinder axis\n    vec3 c = normalize( pb - ca );\n    // cylinder axis\n    vec3 cn = normalize( cross( c, abn ) );\n    // cylinder axis\n    vec3 ct = cross( cn, c );\n    // cylinder axis\n    vec3 ct2 = cross( ct, cn );\n    // cylinder axis\n    vec3 ct3 = cross( ct2, c );\n    // cylinder axis\n    vec3 ct4 = cross( ct3, cn );\n    // cylinder axis\n    vec3 ct5 = cross( ct4, c );\n    // cylinder axis\n    vec3 ct6 = cross( ct5, cn );\n    // cylinder axis\n    vec3 ct7 = cross( ct6, c );\n    // cylinder axis\n    vec3 ct8 = cross( ct7, cn );\n    // cylinder axis\n    vec3 ct9 = cross( ct8, c );\n    // cylinder axis\n    vec3 ct10 = cross( ct9, cn );\n    // cylinder axis\n    vec3 ct11 = cross( ct10, c );\n    // cylinder axis\n    vec3 ct12 = cross( ct11, cn );\n    // cylinder axis\n    vec3 ct13 = cross( ct12, c );\n    // cylinder axis\n    vec3 ct14 = cross( ct13, cn );\n    // cylinder axis\n    vec3 ct15 = cross( ct14, c );\n    // cylinder axis\n    vec3 ct16 = cross( ct15, cn );\n    // cylinder axis\n    vec3 ct17 = cross", "\n  vec3 balloonPosition = vec3( 0.0, 0.0, 0.0 );\n  \n  // Then we define our balloon radius\n  float balloonRadius = 0.5;\n  \n  // Then we define our balloon height\n  float balloonHeight = 0.5;\n  \n  // Then we define our balloon width\n  float balloonWidth = 0.5;\n  \n  // Then we define our balloon depth\n  float balloonDepth = 0.5;\n  \n  // Then we define our balloon rotation\n  float balloonRotation = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed2 = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed3 = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed4 = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed5 = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed6 = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed7 = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed8 = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed9 = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed10 = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed11 = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed12 = 0.0;\n  \n  // Then we define our balloon rotation speed\n  float balloonRotationSpeed13 = 0.0;\n  \n  // Then we define our balloon rotation speed", "\n  float distanceToSurface = far;\n  vec3 surfaceNormal = vec3(0.0);\n  vec3 surfacePosition = vec3(0.0);\n  vec3 surfaceColor = vec3(0.0);\n  vec3 surfaceTangent = vec3(0.0);\n  vec3 surfaceBitangent = vec3(0.0);\n  vec3 surfaceUV = vec3(0.0);\n  vec3 surfaceLight = vec3(0.0);\n  vec3 surfaceLightColor = vec3(0.0);\n  vec3 surfaceLightDirection = vec3(0.0);\n  vec3 surfaceLightPosition = vec3(0.0);\n  vec3 surfaceLightColor2 = vec3(0.0);\n  vec3 surfaceLightDirection2 = vec3(0.0);\n  vec3 surfaceLightPosition2 = vec3(0.0);\n  vec3 surfaceLightColor3 = vec3(0.0);\n  vec3 surfaceLightDirection3 = vec3(0.0);\n  vec3 surfaceLightPosition3 = vec3(0.0);\n  vec3 surfaceLightColor4 = vec3(0.0);\n  vec3 surfaceLightDirection4 = vec3(0.0);\n  vec3 surfaceLightPosition4 = vec3(0.0);\n  vec3 surfaceLightColor5 = vec3(0.0);\n  vec3 surfaceLightDirection5 = vec3(0.0);\n  vec3 surfaceLightPosition5 = vec3(0.0);\n  vec3 surfaceLightColor6 = vec3(0.0);\n  vec3 surfaceLightDirection6 = vec3(0.0);\n  vec3 surfaceLightPosition6 = vec3(0.0);\n  vec3 surfaceLightColor7 = vec3(0.0);\n  vec3 surfaceLightDirection7 = vec3(0.0);\n  vec3 surfaceLightPosition7 = vec3(0.0);\n  vec3 surfaceLightColor8 = ve", "\n  // 0.0 - 1.0\n  // 0.0 - 255.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.0 - 1.0\n  // 0.", "'s hash function\n    // http://www.cse.yorku.ca/~oz/hash.html\n    uint h = n;\n    h = (h + 0x7ed55d16) + (h << 12);\n    h = (h ^ 0xc761c23c) ^ (h >> 19);\n    h = (h + 0x165667b1) + (h << 5);\n    h = (h + 0xd3a2646c) ^ (h << 9);\n    h = (h + 0xfd7046c5) + (h << 3);\n    h = (h ^ 0xb55a4f09) ^ (h >> 16);\n    return h;\n}\n\nuint hash2( uint n ) \n{\n    // integer hash copied from Hugo Elias's hash function\n    // http://www.cse.yorku.ca/~oz/hash.html\n    uint h = n;\n    h = (h + 0x7ed55d16) + (h << 12);\n    h = (h ^ 0xc761c23c) ^ (h >> 19);\n    h = (h + 0x165667b1) + (h << 5);\n    h = (h + 0xd3a2646c) ^ (h << 9);\n    h = (h + 0xfd7046c5) + (h << 3);\n    h = (h ^ 0xb55a4f09) ^ (h >> 16);\n    return h;\n}\n\nuint hash3( uint n ) \n{\n    // integer hash copied from Hugo Elias's hash function\n    // http://www.cse.yorku.ca/~oz/hash.html\n    uint h = n;\n    h = (h + 0x7ed55d16) + (h << 12);\n    h = (h ^ 0xc761c23c) ^ (h >> 19);\n    h = (h + 0x", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 p = -1.0 + 2.0 * uv;\n\tp.x *= iResolution.x / iResolution.y;\n\tvec3 ro = vec3( 0.0, 0.0, 0.0 );\n\tvec3 rd = normalize( vec3( p, 1.0 ) );\n\n\t//camera\n\tfloat fov = 60.0;\n\tfloat aspect = iResolution.x / iResolution.y;\n\tfloat aperture = 0.001;\n\tfloat focus = 1.0;\n\tvec3 up = vec3( 0.0, 1.0, 0.0 );\n\tmat4 cam = lookAt( ro, vec3( 0.0, 0.0, 0.0 ), up );\n\tcam = perspective( fov, aspect, aperture, focus );\n\tcam = cam * camInverse;\n\trd = ( cam * vec4( rd, 0.0 ) ).xyz;\n\n\t//light\n\tvec3 light = vec3( 1.0, 1.0, 1.0 );\n\tvec3 lightDir = normalize( light - ro );\n\tvec3 lightColor = vec3( 1.0, 1.0, 1.0 );\n\tvec3 ambient = vec3( 0.1, 0.1, 0.1 );\n\n\t//material\n\tvec3 diffuse = vec3( 0.0, 0.0, 0.0 );\n\tvec3 specular = vec3( 0.0, 0.0, 0.0 );\n\tvec3 reflectDir = reflect( -rd, lightDir );\n\tfloat shininess = 10.0;\n\n\t//lighting\n\tfloat diff = max( dot( lightDir, normalize( normal ) ), 0.0 );\n\tvec3 diffuseLight = diff * lightColor * diffuse;\n\tvec3 specularLight = pow( max( dot( rd, reflectDir ), 0.0 ), shin", " 64-bit with 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n   //{\n   //    pos.x=x;\n   //}\n   \n   //for (float y=0.;y<2;y++)\n   //{\n   //    pos.y=y;\n   //}\n   \n   //for (float z=0.;z<2;z++)\n   //{\n   //    pos.z=z;\n   //}\n   \n   //return pos;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n   //return pos*2.0;\n   \n  ", "\n    vec3 p0 = vec3( 0.0, 0.0, 0.0 );\n    vec3 p1 = vec3( 1.0, 0.0, 0.0 );\n    vec3 p2 = vec3( 0.0, 1.0, 0.0 );\n\n    // edge vectors\n    vec3 e0 = p1 - p0;\n    vec3 e1 = p2 - p0;\n\n    // normal vector\n    vec3 n = cross( e0, e1 );\n\n    // projection of p onto plane\n    float d = dot( n, p - p0 );\n\n    // distance from p to plane\n    float t = -dot( n, p - p0 ) / dot( n, e1 );\n\n    // point on plane\n    vec3 pt = p0 + t * e1;\n\n    // distance from pt to triangle\n    float d2 = distance( pt, p );\n\n    // distance from p to plane\n    float d3 = distance( pt, p0 );\n\n    // distance from p to plane\n    float d4 = distance( pt, p1 );\n\n    // distance from p to plane\n    float d5 = distance( pt, p2 );\n\n    // distance from p to plane\n    float d6 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 );\n\n    // distance from p to plane\n    float d7 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 ) - d;\n\n    // distance from p to plane\n    float d8 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 ) - d6;\n\n    // distance from p to plane\n    float d9 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 ) - d7;\n\n    // distance from p to plane\n    float d10 = distance( pt, p0 ) + distance( pt, p", "\n\tvec4 camSph = cam * sph;\n\t\n\t// project to screen space\n\tvec4 sphScre = proj( camSph, fle );\n\t\n\t// transform back to world space\n\tvec4 sphWorld = cam * sphScre;\n\t\n\t// return result\n\treturn sphWorld;\n}\n\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//------------------------------------------------------------------------------\n//", "\n    //res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.35,-2.0), vec2(0.15, 0.2) ), 12.0 ) );\n    //res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), vec3(0.15, 0.2, 0.1) ), 13.0 ) );\n    //res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.35,-2.0), vec2(0.15, 0.2) ), 12.0 ) );\n    //res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), vec3(0.15, 0.2, 0.1) ), 13.0 ) );\n    //res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.35,-2.0), vec2(0.15, 0.2) ), 12.0 ) );\n    //res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), vec3(0.15, 0.2, 0.1) ), 13.0 ) );\n    //res = opU( res, vec2( sdCylinder(  pos-vec3( 1.0,0.35,-2.0), vec2(0.15, 0.2) ), 12.0 ) );\n    //res = opU( res, vec2( sdCone(      pos-vec3( 0.0,0.35,-2.0), vec3(0.15, 0.2, 0.1) ), 13.0 ) );", "\n    return x * (3.0 - x * x);\n}\n\nvec", " the scene\n    float tmin = 0.001, tmax = 1000.0;\n    float t = 0.0;\n    float tmin_sphere = 0.0, tmax_sphere = 1000.0;\n    float tmin_plane = 0.0, tmax_plane = 1000.0;\n    float tmin_cylinder = 0.0, tmax_cylinder = 1000.0;\n    float tmin_cone = 0.0, tmax_cone = 1000.0;\n    float tmin_triangle = 0.0, tmax_triangle = 1000.0;\n    float tmin_quad = 0.0, tmax_quad = 1000.0;\n    float tmin_capsule = 0.0, tmax_capsule = 1000.0;\n    float tmin_capsule_2 = 0.0, tmax_capsule_2 = 1000.0;\n    float tmin_capsule_3 = 0.0, tmax_capsule_3 = 1000.0;\n    float tmin_capsule_4 = 0.0, tmax_capsule_4 = 1000.0;\n    float tmin_capsule_5 = 0.0, tmax_capsule_5 = 1000.0;\n    float tmin_capsule_6 = 0.0, tmax_capsule_6 = 1000.0;\n    float tmin_capsule_7 = 0.0, tmax_capsule_7 = 1000.0;\n    float tmin_capsule_8 = 0.0, tmax_capsule_8 = 1000.0;\n    float tmin_capsule_9 = 0.0, tmax_capsule_9 = 1000.0;\n    float tmin_capsule_10 = 0.0, tmax_capsule_10 = 1000.0;\n    float tmin_capsule", " the scene\n    float tmin = 0.001, tmax = 1000.0;\n    float t = 0.0;\n    float tmin_sphere = 0.0, tmax_sphere = 1000.0;\n    float tmin_plane = 0.0, tmax_plane = 1000.0;\n    float tmin_cylinder = 0.0, tmax_cylinder = 1000.0;\n    float tmin_cone = 0.0, tmax_cone = 1000.0;\n    float tmin_triangle = 0.0, tmax_triangle = 1000.0;\n    float tmin_quad = 0.0, tmax_quad = 1000.0;\n    float tmin_capsule = 0.0, tmax_capsule = 1000.0;\n    float tmin_capsule_2 = 0.0, tmax_capsule_2 = 1000.0;\n    float tmin_capsule_3 = 0.0, tmax_capsule_3 = 1000.0;\n    float tmin_capsule_4 = 0.0, tmax_capsule_4 = 1000.0;\n    float tmin_capsule_5 = 0.0, tmax_capsule_5 = 1000.0;\n    float tmin_capsule_6 = 0.0, tmax_capsule_6 = 1000.0;\n    float tmin_capsule_7 = 0.0, tmax_capsule_7 = 1000.0;\n    float tmin_capsule_8 = 0.0, tmax_capsule_8 = 1000.0;\n    float tmin_capsule_9 = 0.0, tmax_capsule_9 = 1000.0;\n    float tmin_capsule_10 = 0.0, tmax_capsule_10 = 1000.0;\n    float tmin_capsule", "\n\tfloat k00 = -0.25;\n\tfloat k10 =  0.25;\n\tfloat k01 = -0.25;\n\tfloat k11 =  0.25;\n\n\t// filter kernel derivatives\n\tfloat dk00 = -0.25;\n\tfloat dk10 =  0.25;\n\tfloat dk01 = -0.25;\n\tfloat dk11 =  0.25;\n\n\t// filter kernel derivatives\n\tfloat ddx0 = dk00 * ddx.x + dk10 * ddx.y;\n\tfloat ddx1 = dk01 * ddx.x + dk11 * ddx.y;\n\tfloat ddy0 = dk00 * ddy.x + dk10 * ddy.y;\n\tfloat ddy1 = dk01 * ddy.x + dk11 * ddy.y;\n\n\t// filter kernel derivatives\n\tfloat ddx2 = ddx0 * ddx0 + ddx1 * ddx1;\n\tfloat ddy2 = ddy0 * ddy0 + ddy1 * ddy1;\n\n\t// filter kernel derivatives\n\tfloat ddx3 = ddx2 * ddx2;\n\tfloat ddy3 = ddy2 * ddy2;\n\n\t// filter kernel derivatives\n\tfloat ddx4 = ddx3 * ddx3;\n\tfloat ddy4 = ddy3 * ddy3;\n\n\t// filter kernel derivatives\n\tfloat ddx5 = ddx4 * ddx4;\n\tfloat ddy5 = ddy4 * ddy4;\n\n\t// filter kernel derivatives\n\tfloat ddx6 = ddx5 * ddx5;\n\tfloat ddy6 = ddy5 * ddy5;\n\n\t// filter kernel derivatives\n\tfloat ddx7 = ddx6 * ddx6;\n\tfloat ddy7 = ddy6 * ddy6;\n\n\t// filter kernel derivatives\n\tfloat ddx8 = ddx7 * ddx7;\n\tfloat ddy8 = ddy7 * ddy7;\n\n\t// filter kernel derivatives\n\tfloat ddx9 = ddx8", " of the grid\n    vec2 gridCoords = p - floor(p);\n\n    // distance from the grid\n    float d = distance(gridCoords, vec2(0.5));\n\n    // grid texture\n    return 1.0 - smoothstep(0.0, 0.01, d);\n}\n\nvoid main()\n{\n    // coordinates of the pixel\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n\n    // grid texture\n    float grid = gridTexture(p);\n\n    // color\n    vec3 color = vec3(grid);\n\n    // output to screen\n    gl_FragColor = vec4(color, 1.0);\n}\n", " the scene\n    float tmin = 0.001, tmax = 1000.0;\n    float t = 0.0;\n    vec3 p = ro;\n    vec3 n = vec3(0.0);\n    float occ = 0.0;\n    int matid = 1;\n    for( int i = 0; i < 100; i++ )\n    {\n        if( tmin > t || t > tmax ) break;\n        t += tmin;\n        p = ro + t*rd;\n        float d = map( p );\n        if( d < 0.001 )\n        {\n            n = vec3(0.0);\n            occ = 0.0;\n            break;\n        }\n        tmin = d;\n        n = normalize( p - vec3( map( p - vec3(0.0, 0.0, tmin) ) ) );\n        occ = map( p - vec3(0.0, 0.0, tmin) );\n        if( occ > 0.0 )\n        {\n            matid = 2;\n            break;\n        }\n    }\n    pos = ro + t*rd;\n    nor = n;\n    if( t > tmax )\n    {\n        matid = 0;\n    }\n    return t;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    // image\n    vec2 p = -1.0 + 2.0*fragCoord.xy/iResolution.xy;\n    p.x *= iResolution.x/iResolution.y;\n    vec3 ro = vec3( 2.0, 1.0, 1.0 );\n    vec3 ta = vec3( 0.0, 0.0, 0.0 );\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross( vec3(0.0,1.0,0.0), ww ) );\n    vec3 vv = normalize( cross( ww,", "\n    float k = 0.0;\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    return k;\n}\n\nfloat", "5\n    vec2 q = p - vec2( 2.0, 2.0 );\n    vec2 r = vec2( 5.0, 5.0 );\n    vec2 s = vec2( 1.0, 1.0 );\n    vec2 t = vec2( 1.0, 1.0 );\n    vec2 u = vec2( 1.0, 1.0 );\n    vec2 v = vec2( 1.0, 1.0 );\n    vec2 w = vec2( 1.0, 1.0 );\n    vec2 x = vec2( 1.0, 1.0 );\n    vec2 y = vec2( 1.0, 1.0 );\n    vec2 z = vec2( 1.0, 1.0 );\n    vec2 a = vec2( 1.0, 1.0 );\n    vec2 b = vec2( 1.0, 1.0 );\n    vec2 c = vec2( 1.0, 1.0 );\n    vec2 d = vec2( 1.0, 1.0 );\n    vec2 e = vec2( 1.0, 1.0 );\n    vec2 f = vec2( 1.0, 1.0 );\n    vec2 g = vec2( 1.0, 1.0 );\n    vec2 h = vec2( 1.0, 1.0 );\n    vec2 i = vec2( 1.0, 1.0 );\n    vec2 j = vec2( 1.0, 1.0 );\n    vec2 k = vec2( 1.0, 1.0 );\n    vec2 l = vec2( 1.0, 1.0 );\n    vec2 m = vec2( 1.0, 1.0 );\n    vec2 n = vec2( 1.0, 1.0 );\n    vec2", "\n    vec2 p01 = p0 - p1;\n    vec2 p12 = p1 - p2;\n    vec2 p20 = p2 - p0;\n\n    // midpoints\n    vec2 p012 = p01 + p12;\n    vec2 p120 = p12 + p20;\n    vec2 p201 = p20 + p01;\n\n    // distances\n    float d01 = length(p01);\n    float d12 = length(p12);\n    float d20 = length(p20);\n\n    // distances to midpoints\n    float d012 = length(p012);\n    float d120 = length(p120);\n    float d201 = length(p201);\n\n    // distances to extremes\n    float d012_ = d012 / d01;\n    float d120_ = d120 / d12;\n    float d201_ = d201 / d20;\n\n    // distances to midpoints\n    float d012_1 = d012_ * d012_;\n    float d120_1 = d120_ * d120_;\n    float d201_1 = d201_ * d201_;\n\n    // distances to extremes\n    float d012_2 = d012_ * d012_ * d012_;\n    float d120_2 = d120_ * d120_ * d120_;\n    float d201_2 = d201_ * d201_ * d201_;\n\n    // distances to midpoints\n    float d012_3 = d012_ * d012_ * d012_ * d012_;\n    float d120_3 = d120_ * d120_ * d120_ * d120_;\n    float d201_3 = d201", "\n    vec3 min = min( p0, min( p1, min( p2, p3 ) ) );\n    vec3 max = max( p0, max( p1, max( p2, p3 ) ) );\n\n    // center\n    vec3 center = ( min + max ) * 0.5;\n\n    // radius\n    vec3 radius = max( abs( p0 - center ), abs( p1 - center ) );\n    radius = max( radius, abs( p2 - center ) );\n    radius = max( radius, abs( p3 - center ) );\n\n    // bounding box\n    return BezierAABB( center, radius );\n}\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------", "\n\tvec3 bmin = cen - rad;\n\tvec3 bmax = cen + rad;\n\tvec3 tmin = (bmin - ro) / rd;\n\tvec3 tmax = (bmax - ro) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(t1.x, max(t1.y, t1.z));\n\tfloat t3 = min(t2.x, min(t2.y, t2.z));\n\tfloat tN = max(t0, t3);\n\tfloat tF = min(t2.x, t2.y);\n\tfloat tB = max(t1.y, t1.z);\n\tfloat tL = min(t1.x, t1.z);\n\tfloat tH = max(t2.y, t2.z);\n\tfloat tS = max(t2.x, t1.y);\n\tfloat t4 = max(tF, tB);\n\tfloat t6 = min(tL, tH);\n\tfloat t5 = max(tS, t4);\n\tfloat t7 = min(t6, t5);\n\tfloat t8 = max(tN, t7);\n\tfloat t9 = min(t8, tT);\n\tfloat t = max(t9, 0.0);\n\treturn vec2(t, t);\n}\n\nvec", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n    float time = iTime;\n    float t = time * 0.001;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t24 = t23 * t;\n    float t25 = t24 * t;\n    float t26 = t25 * t;\n    float t27 = t26 * t;\n    float t28 = t27 * t;\n    float t29 = t28 * t;\n    float t30 = t29 * t;\n    float t31 = t30 * t;\n    float t32 = t31 * t;\n    float t33 = t32 * t;\n    float t34 = t33 * t;\n    float t35 = t34 * t;\n    float t36 = t35 * t;\n    float t37 = t36 * t;\n    float t38 = t37 * t;\n    float t39 = t38 * t;\n    float t40 = t39 * t;\n", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n    float k = 0.0;\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    return k;\n}\n\nfloat", "\n    vec3 c = (pa+pb)/2.0;\n    vec3 a = normalize(pa-c);\n    vec3 b = normalize(pb-c);\n\n    // ray-cylinder intersection\n    float t = dot(a,rd);\n    vec3 p = ro + t*rd;\n    float d = length(p-c);\n    if(d>ra) return vec4(0.0);\n\n    // cylinder-sphere intersection\n    float t2 = dot(p-c,a);\n    if(t2<0.0) return vec4(0.0);\n    float d2 = length(p-c-t2*a);\n    if(d2>ra) return vec4(0.0);\n\n    // cylinder-cylinder intersection\n    float t3 = dot(p-c,b);\n    if(t3<0.0) return vec4(0.0);\n    float d3 = length(p-c-t3*b);\n    if(d3>ra) return vec4(0.0);\n\n    // cylinder-cylinder intersection\n    float t4 = dot(p-c,a);\n    if(t4<0.0) return vec4(0.0);\n    float d4 = length(p-c-t4*a);\n    if(d4>ra) return vec4(0.0);\n\n    // cylinder-cylinder intersection\n    float t5 = dot(p-c,b);\n    if(t5<0.0) return vec4(0.0);\n    float d5 = length(p-c-t5*b);\n    if(d5>ra) return vec4(0.0);\n\n    // cylinder-cylinder intersection\n    float t6 = dot(p-c,a);\n    if(t6<0.0) return vec4(0.0);\n    float d6 = length(p-c-t6*a);\n    if(d6>ra) return vec4(0.0);\n\n    // cylinder-cylinder intersection\n   ", "\n    vec3 c = (pa + pb) / 2.0;\n    vec3 a = normalize(pa - c);\n    vec3 b = normalize(pb - c);\n\n    // cylinder radius\n    float r = length(pb - pa) / 2.0;\n\n    // cylinder axis\n    vec3 n = cross(a, b);\n\n    // cylinder plane\n    float d = dot(n, c);\n\n    // cylinder plane equation\n    float t = (-d - ra) / dot(n, rd);\n\n    // cylinder plane intersection\n    vec3 p = ro + rd * t;\n\n    // cylinder plane normal\n    vec3 nn = normalize(cross(a, b));\n\n    // cylinder plane distance\n    float dn = dot(n, p - c);\n\n    // cylinder plane distance\n    float dp = dot(n, p - c) / dot(n, rd);\n\n    // cylinder plane distance\n    float dn2 = dot(n, p - c) / dot(n, rd);\n\n    // cylinder plane distance\n    float dp2 = dot(n, p - c) / dot(n, rd);\n\n    // cylinder plane distance\n    float dn3 = dot(n, p - c) / dot(n, rd);\n\n    // cylinder plane distance\n    float dp3 = dot(n, p - c) / dot(n, rd);\n\n    // cylinder plane distance\n    float dn4 = dot(n, p - c) / dot(n, rd);\n\n    // cylinder plane distance\n    float dp4 = dot(n, p - c) / dot(n, rd);\n\n    // cylinder plane distance\n    float dn5 = dot(n, p - c) / dot(n, rd);\n\n    // cylinder plane distance\n    float dp5 = dot(n, p - c) / dot(n, rd);\n\n    // cylinder plane distance\n    float dn6 = dot(n, p - c) / dot(n, rd);\n\n    // cylinder plane distance\n    float dp6 = dot(", "\n    float d = distance(p, a);\n    float r = r1;\n    float h = r2;\n    float s = h / d;\n    float t = clamp((d - r) / h, 0.0, 1.0);\n    float u = clamp((d - r) / h, 0.0, 1.0);\n\n    // sampling dependent computations (depend on shape)\n    float d1 = distance(p, a);\n    float d2 = distance(p, b);\n    float d3 = distance(p, a + b);\n    float d4 = distance(p, a - b);\n    float d5 = distance(p, a + b - a);\n    float d6 = distance(p, a - b - a);\n    float d7 = distance(p, a + b + a);\n    float d8 = distance(p, a - b + a);\n    float d9 = distance(p, a + b + a - a);\n    float d10 = distance(p, a - b + a - a);\n    float d11 = distance(p, a + b - a - a);\n    float d12 = distance(p, a - b - a - a);\n\n    float d13 = distance(p, a + b + a + a);\n    float d14 = distance(p, a - b + a + a);\n    float d15 = distance(p, a + b - a + a);\n    float d16 = distance(p, a - b - a + a);\n    float d17 = distance(p, a + b + a - a);\n    float d18 = distance(p, a - b + a - a);\n    float d19 = distance(p, a + b - a - a);\n    float d20 = distance(p, a - b - a - a);\n\n    float d1a = distance(p, a + b + a + a + a);\n    float d1b = distance(p, a - b + a + a + a);\n    float d1c = distance(p, a + b - a + a + a);\n    float d1", "\n    return (float)q.x + (float)q.y * 1000000000.0;\n}\n\nfloat", "\n    float k = 0.0;\n    for (int i = -1; i <= 1; i++)\n    {\n        for (int j = -1; j <= 1; j++)\n        {\n            k += (i + j) * (i + j);\n        }\n    }\n    k = 1.0 / k;\n\n    // compute gradient\n    vec2 grad = vec2(0.0);\n    for (int i = -1; i <= 1; i++)\n    {\n        for (int j = -1; j <= 1; j++)\n        {\n            grad += texture(tex, p + vec2(i, j) * k).rgb;\n        }\n    }\n    return length(grad);\n}\n\nvoid main()\n{\n    vec2 p = gl_FragCoord.xy / resolution.xy;\n    float d = checkersGradBox(p);\n    float d2 = checkersGradBox(p * 2.0);\n    float d3 = checkersGradBox(p * 4.0);\n    float d4 = checkersGradBox(p * 8.0);\n    float d5 = checkersGradBox(p * 16.0);\n    float d6 = checkersGradBox(p * 32.0);\n    float d7 = checkersGradBox(p * 64.0);\n    float d8 = checkersGradBox(p * 128.0);\n    float d9 = checkersGradBox(p * 256.0);\n    float d10 = checkersGradBox(p * 512.0);\n    float d11 = checkersGradBox(p * 1024.0);\n    float d12 = checkersGradBox(p * 2048.0);\n    float d13 = checkersGradBox(p * 4096.0);\n    float d14 = checkersGradBox(p * 8192.0);\n    float d15 = checkersGradBox(p * 16384.0);\n    float d16 = checkersGrad", "\n\t vec3 s = p - vec3(floor(p));\n\t vec3 x = p - s;\n\t \n\t /* calculate i1, i2, and 1.0 - x */\n\t vec3 i1 = step(vec3(0.0), x);\n\t vec3 i2 = step(vec3(1.0), x);\n\t vec3 x1 = 1.0 - x;\n\t \n\t /* calculate T and four vertices of T */\n\t vec4 T = vec4(s, i1.x) + vec4(s, i2.x);\n\t vec3 v0 = T.xyz;\n\t vec3 v1 = T.wxy;\n\t vec3 v2 = T.ywx;\n\t vec3 v3 = T.zxw;\n\t \n\t /* calculate dT and four barycentric coordinates of p relative to T */\n\t vec3 dT = x1 * (x2 * v0 + x3 * v1) + x2 * (x3 * v2 + x1 * v3) + x3 * (x1 * v3 + x2 * v0);\n\t vec3 b0 = x1 * i1;\n\t vec3 b1 = x2 * i2;\n\t vec3 b2 = x3 * (1.0 - i1 - i2);\n\t \n\t /* return dot(dT, b0) */\n\t return dot(dT, b0);\n}\n\nfloat", "\n    return fract(sin(dot(v, vec2(12.1215, 23.02751))) * 541.9283);\n}\n\nfloat", "\n    float k = 0.0;\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    return k;\n}\n\nfloat", "\n    vec3 q = p - vec3( 0.5, 0.5, 0.5 );\n    float a = length( q );\n    float b = dot( q, q );\n    float c = dot( q, q ) * 0.25;\n    float d = a * a / ( b * b ) + c;\n    float e = sqrt( max( 0.0, d - 0.25 ) );\n    float f = sqrt( max( 0.0, d - 0.5 ) );\n    float g = sqrt( max( 0.0, d - 0.75 ) );\n    float h = sqrt( max( 0.0, d - 1.0 ) );\n    float i = sqrt( max( 0.0, d - 1.25 ) );\n    float j = sqrt( max( 0.0, d - 1.5 ) );\n    float k = sqrt( max( 0.0, d - 1.75 ) );\n    float l = sqrt( max( 0.0, d - 2.0 ) );\n    float m = sqrt( max( 0.0, d - 2.25 ) );\n    float n = sqrt( max( 0.0, d - 2.5 ) );\n    float o = sqrt( max( 0.0, d - 2.75 ) );\n    float p = sqrt( max( 0.0, d - 3.0 ) );\n    float q = sqrt( max( 0.0, d - 3.25 ) );\n    float r = sqrt( max( 0.0, d - 3.5 ) );\n    float s = sqrt( max( 0.0, d - 3.75 ) );\n    float t = sqrt( max( 0.0, d - 4.0 ) );\n    float u = sqrt( max( 0.0, d - 4.25 ) );\n    float v = sqrt( max( 0.0, d - 4.5 ) );\n    float w = sq", "\n    float k = 0.0;\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    return k;\n}\n\nfloat", "\n    vec3 q = p - vec3( 0.5, 0.5, 0.5 );\n    float a = length( q );\n    float b = dot( q, q );\n    float c = dot( q, q ) * 0.25;\n    float d = a * a / ( b * b ) + c;\n    float e = sqrt( max( 0.0, d - 0.25 ) );\n    float f = sqrt( max( 0.0, d - 0.5 ) );\n    float g = sqrt( max( 0.0, d - 0.75 ) );\n    float h = sqrt( max( 0.0, d - 1.0 ) );\n    float i = sqrt( max( 0.0, d - 1.25 ) );\n    float j = sqrt( max( 0.0, d - 1.5 ) );\n    float k = sqrt( max( 0.0, d - 1.75 ) );\n    float l = sqrt( max( 0.0, d - 2.0 ) );\n    float m = sqrt( max( 0.0, d - 2.25 ) );\n    float n = sqrt( max( 0.0, d - 2.5 ) );\n    float o = sqrt( max( 0.0, d - 2.75 ) );\n    float p = sqrt( max( 0.0, d - 3.0 ) );\n    float q = sqrt( max( 0.0, d - 3.25 ) );\n    float r = sqrt( max( 0.0, d - 3.5 ) );\n    float s = sqrt( max( 0.0, d - 3.75 ) );\n    float t = sqrt( max( 0.0, d - 4.0 ) );\n    float u = sqrt( max( 0.0, d - 4.25 ) );\n    float v = sqrt( max( 0.0, d - 4.5 ) );\n    float w = sq", "\n    float k = 0.0;\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    return k;\n}\n\nfloat", "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // ray-sphere intersection\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ( ro - vec3( 0.0, 0.0, 0.0 ) ) );\n    float c = dot( ( ro - vec3( 0.0, 0.0, 0.0 ) ), ( ro - vec3( 0.0, 0.0, 0.0 ) ) ) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return 0.0;\n    float t = ( -b - sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t < tmin.x )\n        t = ( -b + sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t > tmax.x )\n        return 0.0;\n\n    // shadow\n    float shadow = 1.0;\n    vec3 p = ro + t * rd;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = texture( shadowMap, p.xy ).r;\n        if ( h < p.z - mint )\n            shadow -= 0.2;\n        if ( shadow < 0.0 )\n            return 0.0;\n        p += rd * 0.01;\n    }\n    return shadow;\n}\n\nvoid main()\n{\n    vec3 ro = vec3( 0.0, 0.0, 0", "\n    float k = 0.0;\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    return k;\n}\n\nfloat", "\n    float a = 0.0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( ro - rd, rd );\n    float c = dot( ro - rd, ro - rd ) - ra * ra;\n    float d = b * b - 4.0 * a * c;\n    if( d < 0.0 ) return -1.0;\n    d = sqrt( d );\n    float t1 = (-b - d) / (2.0 * a);\n    float t2 = (-b + d) / (2.0 * a);\n    if( t1 < 0.0 ) t1 = t2;\n    if( t2 < 0.0 ) t2 = t1;\n    if( t1 < 0.0 ) return -1.0;\n    if( t2 < 0.0 ) return -1.0;\n    if( t1 < t2 ) return t1;\n    return t2;\n}\n\n// -----------------------------\n// solve cubic equation\n// -----------------------------\nfloat", "\n    vec3 col = vec3(0.0);\n\n    // raymarching\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        d = map( p );\n        t += d;\n        p = ro + rd * t;\n        if( d < 0.001 ) break;\n    }\n\n    // lighting\n    vec3 n = normal( p );\n    vec3 l = normalize( vec3( 1.0, 1.0, 1.0 ) );\n    vec3 v = normalize( rd );\n    vec3 h = normalize( l + v );\n    float s = max( 0.0, dot( n, h ) );\n    float a = max( 0.0, dot( n, l ) );\n    float r = max( 0.0, dot( n, v ) );\n    float g = max( 0.0, dot( n, l ) );\n    float b = max( 0.0, dot( n, v ) );\n    col = vec3( a, g, b );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // tone mapping\n    col = col / ( col + vec3( 1.0 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3(", "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // ray-sphere intersection\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ( ro - vec3( 0.0, 0.0, 0.0 ) ) );\n    float c = dot( ( ro - vec3( 0.0, 0.0, 0.0 ) ), ( ro - vec3( 0.0, 0.0, 0.0 ) ) ) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return 0.0;\n    float t = ( -b - sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t < tmin.x )\n        t = ( -b + sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t > tmax.x )\n        return 0.0;\n\n    // shadow\n    float shadow = 1.0;\n    vec3 p = ro + t * rd;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = texture( shadowMap, p.xy ).r;\n        if ( h < p.z - mint )\n            shadow -= 0.2;\n        if ( shadow < 0.0 )\n            return 0.0;\n        p += rd * 0.01;\n    }\n    return shadow;\n}\n\nvoid main()\n{\n    vec3 ro = vec3( 0.0, 0.0, 0", "\n    float k = 0.0;\n    k += (1.0 - dpdx.x) * (1.0 - dpdx.y);\n    k += (1.0 - dpdy.x) * (1.0 - dpdy.y);\n    k += (1.0 + dpdx.x) * (1.0 + dpdx.y);\n    k += (1.0 + dpdy.x) * (1.0 + dpdy.y);\n    k *= 0.25;\n    return k;\n}\n\nfloat", "\n    vec3 offset = vec3(0.0, 0.0, 0.0);\n    offset.x = planet_radius;\n    offset.y = planet_radius;\n    offset.z = planet_radius;\n    start += offset;\n\n    // calculate the rayleigh scattering\n    vec3 rayleigh_scattering = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp_2 = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp_3 = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp_4 = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp_5 = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp_6 = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp_7 = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp_8 = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp_9 = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp_10 = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp_11 = vec3(0.0, 0.0, 0.0);\n    vec3 rayleigh_scattering_temp_12 = vec3(0.0, 0.0, 0.0);\n   ", "\n    vec3 oc = start - vec3(0.0);\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return vec2(-1.0, -1.0);\n    }\n    float sqrt_discriminant = sqrt(discriminant);\n    float t0 = (-b - sqrt_discriminant) / (2.0 * a);\n    float t1 = (-b + sqrt_discriminant) / (2.0 * a);\n    if (t0 > t1) {\n        return vec2(t1, t0);\n    }\n    return vec2(t0, t1);\n}\n\n// https://www.shadertoy.com/view/4djSRW\nvec", "\n    vec3 light_dir_bend = normalize(light_dir + surface_normal * 0.001);\n\n    // compute the cosine of the angle between the surface normal and the light direction\n    float cos_theta = dot(surface_normal, light_dir_bend);\n\n    // compute the cosine of the angle between the surface normal and the view direction\n    float cos_alpha = dot(surface_normal, normalize(view_dir));\n\n    // compute the cosine of the angle between the light direction and the view direction\n    float cos_beta = dot(light_dir_bend, normalize(view_dir));\n\n    // compute the cosine of the angle between the light direction and the view direction\n    float cos_gamma = dot(light_dir_bend, normalize(view_dir));\n\n    // compute the cosine of the angle between the light direction and the view direction\n    float cos_delta = dot(light_dir_bend, normalize(view_dir));\n\n    // compute the cosine of the angle between the light direction and the view direction\n    float cos_epsilon = dot(light_dir_bend, normalize(view_dir));\n\n    // compute the cosine of the angle between the light direction and the view direction\n    float cos_zeta = dot(light_dir_bend, normalize(view_dir));\n\n    // compute the cosine of the angle between the light direction and the view direction\n    float cos_theta_prime = dot(light_dir_bend, normalize(view_dir));\n\n    // compute the cosine of the angle between the light direction and the view direction\n    float cos_theta_double = dot(light_dir_bend, normalize(view_dir));\n\n    // compute the cosine of the angle between the light direction and the view direction\n    float cos_theta_triple = dot(light_dir_bend, normalize(view_dir));\n\n    // compute the cosine of the angle between the light direction and the view direction\n    float cos_theta_quadruple = dot(light_dir_bend, normalize(view_dir));\n\n    // compute the cosine of the angle between the light direction", "\n    vec4 color = vec4(0.0, 0.0, 0.0, 0.0);\n    \n    // the ray direction\n    vec3 ray_dir = normalize(dir);\n    \n    // the ray origin\n    vec3 ray_origin = pos;\n    \n    // the ray origin\n    vec3 light_origin = vec3(0.0, 0.0, 0.0);\n    \n    // the ray direction\n    vec3 light_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray_dir = normalize(light_dir);\n    \n    // the ray origin\n    vec3 light_ray_origin = light_origin;\n    \n    // the ray direction\n    vec3 light_ray", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    \n    // get the ray direction\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(p.xy, 2.0));\n    \n    // get the raymarching parameters\n    float t = 0.0;\n    float tmax = 100.0;\n    float tmin = 0.001;\n    float tdelta = 0.001;\n    float tacc = 0.0;\n    float tdec = 0.0;\n    float tinc = 0.0;\n    float tdec2 = 0.0;\n    float tdec3 = 0.0;\n    float tdec4 = 0.0;\n    float tdec5 = 0.0;\n    float tdec6 = 0.0;\n    float tdec7 = 0.0;\n    float tdec8 = 0.0;\n    float tdec9 = 0.0;\n    float tdec10 = 0.0;\n    float tdec11 = 0.0;\n    float tdec12 = 0.0;\n    float tdec13 = 0.0;\n    float tdec14 = 0.0;\n    float tdec15 = 0.0;\n    float tdec16 = 0.0;\n    float tdec17 = 0.0;\n    float tdec18 = 0.0;\n    float tdec19 = 0.0;\n    float tdec20 = 0.0;\n    float tdec21 = 0.0;\n    float tdec22 = 0.0;\n    float tdec23 = 0.0;\n    float tdec24 = 0.0;\n    float tdec25 = 0.0;\n    float tdec26 = 0.0;\n    float tdec27 = 0.0;\n    float tdec2", " ray\n    ray_queue.push_back(ray_origin);\n    // Initialize the sample ray -\n    // the ray that will be used to sample the scene\n    vec3 sample_ray = ray_origin;\n    // Initialize the sample ray direction -\n    // the direction of the sample ray\n    vec3 sample_ray_direction = normalize(ray_target - ray_origin);\n    // Initialize the sample ray distance -\n    // the distance of the sample ray\n    float sample_ray_distance = 0.0f;\n    // Initialize the sample ray color -\n    // the color of the sample ray\n    vec3 sample_ray_color = vec3(0.0f);\n    // Initialize the sample ray depth -\n    // the depth of the sample ray\n    float sample_ray_depth = 0.0f;\n    // Initialize the sample ray index -\n    // the index of the sample ray in the sample ray queue\n    int sample_ray_index = 0;\n    // Initialize the sample ray index -\n    // the index of the sample ray in the sample ray queue\n    int sample_ray_index_next = 0;\n    // Initialize the sample ray index -\n    // the index of the sample ray in the sample ray queue\n    int sample_ray_index_prev = 0;\n    // Initialize the sample ray index -\n    // the index of the sample ray in the sample ray queue\n    int sample_ray_index_prev_next = 0;\n    // Initialize the sample ray index -\n    // the index of the sample ray in the sample ray queue\n    int sample_ray_index_prev_prev = 0;\n    // Initialize the sample ray index -\n    // the index of the sample ray in the sample ray queue\n    int sample_ray_index_prev_prev_next = 0;\n    // Initialize the sample ray index -\n    // the index of the sample ray in the sample ray queue\n    int sample_ray_index_prev_prev_prev = 0;\n    // Initialize the sample ray index -\n    // the index of the sample ray in the sample ray queue\n    int sample_ray_index_prev_prev_prev_next = 0;\n    // Init", "\n    float t = x * 10.0;\n    float s = sin(t);\n    float r = cos(t);\n    float b = sin(t * 0.5);\n    float g = cos(t * 0.5);\n    float a = sin(t * 0.25);\n    float n = cos(t * 0.25);\n    \n    // compute\n    float r1 = r * 0.5 + 0.5;\n    float g1 = g * 0.5 + 0.5;\n    float b1 = b * 0.5 + 0.5;\n    float a1 = a * 0.5 + 0.5;\n    float n1 = n * 0.5 + 0.5;\n    \n    // return\n    return r1 + g1 + b1 + a1 + n1;\n}\n\nfloat", "\n    vec3 p2 = rotate( p, vec3( 0.0, 0.0, 0.0 ) );\n\n    // map the solution space to the unit sphere\n    vec3 p3 = p2 / length( p2 );\n\n    // map the solution space to the unit cube\n    vec3 p4 = p3 * 0.5 + 0.5;\n\n    // map the solution space to the unit cube\n    vec3 p5 = p4 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p6 = p5 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p7 = p6 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p8 = p7 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p9 = p8 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p10 = p9 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p11 = p10 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p12 = p11 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p13 = p12 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p14 = p13 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p15 = p14 * 2.0 - 1.0;\n\n    // map the solution space to the unit cube\n    vec3 p16 = p15 * 2.0 - 1.", "\n    vec3 col = vec3(0.0);\n\n    // raymarching\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    for( int i = 0; i < 100; i++ )\n    {\n        d = map( p );\n        t += d;\n        p = ro + rd * t;\n        if( d < 0.001 ) break;\n    }\n\n    // lighting\n    vec3 n = normal( p );\n    vec3 l = normalize( vec3( 1.0, 1.0, 1.0 ) );\n    vec3 v = normalize( rd );\n    vec3 h = normalize( l + v );\n    float s = max( 0.0, dot( n, h ) );\n    float a = max( 0.0, dot( n, l ) );\n    float r = max( 0.0, dot( n, v ) );\n    float g = max( 0.0, dot( n, l ) );\n    float b = max( 0.0, dot( n, v ) );\n    col = vec3( a, g, b );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // tone mapping\n    col = col / ( col + vec3( 1.0 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3( 1.0 / 2.2 ) );\n\n    // gamma correction\n    col = pow( col, vec3(", "\n    vec3 bv = ro + rd * tmax;\n    float t = dot(ro, rd);\n    float tmin2 = tmin * tmin;\n    float tmax2 = tmax * tmax;\n    float tmin3 = tmin2 * tmin;\n    float tmax3 = tmax2 * tmax;\n    float tmin4 = tmin3 * tmin;\n    float tmax4 = tmax3 * tmax;\n    float tmin5 = tmin4 * tmin;\n    float tmax5 = tmax4 * tmax;\n    float tmin6 = tmin5 * tmin;\n    float tmax6 = tmax5 * tmax;\n    float tmin7 = tmin6 * tmin;\n    float tmax7 = tmax6 * tmax;\n    float tmin8 = tmin7 * tmin;\n    float tmax8 = tmax7 * tmax;\n    float tmin9 = tmin8 * tmin;\n    float tmax9 = tmax8 * tmax;\n    float tmin10 = tmin9 * tmin;\n    float tmax10 = tmax9 * tmax;\n    float tmin11 = tmin10 * tmin;\n    float tmax11 = tmax10 * tmax;\n    float tmin12 = tmin11 * tmin;\n    float tmax12 = tmax11 * tmax;\n    float tmin13 = tmin12 * tmin;\n    float tmax13 = tmax12 * tmax;\n    float tmin14 = tmin13 * tmin;\n    float tmax14 = tmax13 * tmax;\n    float tmin15 = tmin14 * tmin;\n    float tmax15 = tmax14 * tmax;\n    float tmin16 = tmin15 * tmin;\n    float tmax16 = tmax15 * tmax;\n    float tmin17 = tmin16 * tmin;\n    float tmax17 = tmax16 * tmax;\n    float tmin18 =", "\n    float t = time * 0.01;\n    float a = sin(t * 2.0) * 0.5 + 0.5;\n    float b = sin(t * 3.0) * 0.5 + 0.5;\n    float c = sin(t * 4.0) * 0.5 + 0.5;\n    float d = sin(t * 5.0) * 0.5 + 0.5;\n    float e = sin(t * 6.0) * 0.5 + 0.5;\n    float f = sin(t * 7.0) * 0.5 + 0.5;\n    float g = sin(t * 8.0) * 0.5 + 0.5;\n    float h = sin(t * 9.0) * 0.5 + 0.5;\n    float i = sin(t * 10.0) * 0.5 + 0.5;\n    float j = sin(t * 11.0) * 0.5 + 0.5;\n    float k = sin(t * 12.0) * 0.5 + 0.5;\n    float l = sin(t * 13.0) * 0.5 + 0.5;\n    float m = sin(t * 14.0) * 0.5 + 0.5;\n    float n = sin(t * 15.0) * 0.5 + 0.5;\n    float o = sin(t * 16.0) * 0.5 + 0.5;\n    float p = sin(t * 17.0) * 0.5 + 0.5;\n    float q = sin(t * 18.0) * 0.5 + 0.5;\n    float r = sin(t * 19.0) * 0.5 + 0.5;\n    float s = sin(t * 20.0) * 0.5 + 0.5;\n    float tt = sin(t * 21.0) * 0.5 + 0.5;\n    float u = sin", "\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n    //\n   ", "\n    vec3 oc = r.origin - center;\n    float a = dot(r.direction, r.direction);\n    float b = 2.0 * dot(oc, r.direction);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-simple-shapes/ray-sphere-intersection\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-spheres/ray-sphere-intersection\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-spheres/ray-sphere-intersection\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-spheres/ray-sphere-intersection\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-spheres/ray-sphere-intersection\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-spheres/ray-sphere-intersection\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-spheres/ray-sphere-intersection\n// https://www.scratchapixel.com/lessons/3d-basic-rendering/minimal-ray-tracer-rendering-spheres/ray-sphere-intersection\n// https://www.scratchapixel.com/lessons/3d-", "\n\tvec2 uv = fragCoord.xy / iResolution.xy;\n\tvec2 uv_offset = uv - 0.5;\n\tuv_offset.x *= iResolution.x / iResolution.y;\n\tvec2 dir = normalize(uv_offset);\n\n\t//get the ray\n\tvec3 ray = vec3(0.0);\n\tray.x = dir.x * iCamera.x;\n\tray.y = dir.y * iCamera.y;\n\tray.z = iCamera.z;\n\n\t//get the raymarching distance\n\tfloat t = 0.0;\n\tfloat t_max = 1000.0;\n\n\t//get the color\n\tvec3 color = vec3(0.0);\n\n\t//raymarch\n\twhile(t < t_max)\n\t{\n\t\t//get the position\n\t\tvec3 pos = ray * t;\n\n\t\t//get the distance\n\t\tfloat d = getDistance(pos);\n\n\t\t//get the color\n\t\tvec3 c = getColor(pos);\n\n\t\t//get the attenuation\n\t\tfloat attenuation = getAttenuation(pos);\n\n\t\t//get the color\n\t\tcolor += c * attenuation;\n\n\t\t//get the distance\n\t\tt += d;\n\t}\n\n\t//get the final color\n\tcolor = pow(color, vec3(1.0 / 2.2));\n\n\t//get the final color\n\tfragColor = vec4(color, 1.0);\n}\n\n//get the distance\nfloat", "\n    //https://www.shadertoy.com/view/4djSRW\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.shadertoy.com/view/Xds3zS\n    //https://www.sh", "\n  // where k is the slope of the line, j is the y-intercept\n  // and r is the point of intersection\n  //\n  // If the lines are parallel, return the point of\n  // intersection of the lines\n  //\n  // If the lines are identical, return the point of\n  // intersection of the lines\n  //\n  // If the lines are not parallel, return the point of\n  // intersection of the lines\n  //\n  // If the lines are not identical, return the point of\n  // intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not parallel and not identical,\n  // return the point of intersection of the lines\n  //\n  // If the lines are not", "\n    vec3 p0 = vec3( 0.0, 0.0, 0.0 );\n    vec3 p1 = vec3( 1.0, 0.0, 0.0 );\n    vec3 p2 = vec3( 0.0, 1.0, 0.0 );\n\n    // edge vectors\n    vec3 e0 = p1 - p0;\n    vec3 e1 = p2 - p0;\n\n    // normal vector\n    vec3 n = cross( e0, e1 );\n\n    // projection of p onto plane\n    float d = dot( n, p - p0 );\n\n    // distance from p to plane\n    float t = -dot( n, p - p0 ) / dot( n, e1 );\n\n    // point on plane\n    vec3 pt = p0 + t * e1;\n\n    // distance from pt to triangle\n    float d2 = distance( pt, p );\n\n    // distance from p to plane\n    float d3 = distance( pt, p0 );\n\n    // distance from p to plane\n    float d4 = distance( pt, p1 );\n\n    // distance from p to plane\n    float d5 = distance( pt, p2 );\n\n    // distance from p to plane\n    float d6 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 );\n\n    // distance from p to plane\n    float d7 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 ) - d;\n\n    // distance from p to plane\n    float d8 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 ) - d6;\n\n    // distance from p to plane\n    float d9 = distance( pt, p0 ) + distance( pt, p1 ) + distance( pt, p2 ) - d7;\n\n    // distance from p to plane\n    float d10 = distance( pt, p0 ) + distance( pt, p", "\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ: 1.05\n    // CJ:", "\n    float k = 0.0;\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( 0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( 0.5, p.y ));\n    k += (1.0 - step( -0.5, p.x )) * (1.0 - step( -0.5, p.y ));\n    return k;\n}\n\nfloat", "\n    vec3 min = min( p0, min( p1, p2 ) );\n    vec3 max = max( p0, max( p1, p2 ) );\n\n    // center\n    vec3 center = ( min + max ) * 0.5;\n\n    // radius\n    vec3 radius = max( abs( p0 - center ), abs( p1 - center ) ) + abs( p2 - center );\n\n    // bounding box\n    return BezierAABB( center, radius );\n}\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//------------------------------------------------------------------------------\n// BezierAABB\n//------------------------------------------------------------------------------\n\n//----------------------------------------------------------------", "\n\tvec3 bmin = cen - rad;\n\tvec3 bmax = cen + rad;\n\tvec3 tmin = (bmin - ro) / rd;\n\tvec3 tmax = (bmax - ro) / rd;\n\tvec3 t1 = min(tmin, tmax);\n\tvec3 t2 = max(tmin, tmax);\n\tfloat t0 = max(t1.x, max(t1.y, t1.z));\n\tfloat t3 = min(t2.x, min(t2.y, t2.z));\n\tfloat tN = max(t0, t3);\n\tfloat tF = min(t2.x, t2.y);\n\tfloat tB = max(t1.y, t1.z);\n\tfloat tL = min(t1.x, t1.z);\n\tfloat tH = max(t2.y, t2.z);\n\tfloat tS = max(t2.x, t1.y);\n\tfloat t4 = max(tF, tB);\n\tfloat t6 = min(tL, tH);\n\tfloat t5 = max(tS, t4);\n\tfloat t7 = min(t6, t5);\n\tfloat t8 = max(tN, t7);\n\tfloat t9 = min(t8, tT);\n\tfloat t = max(t9, 0.0);\n\treturn vec2(t, t);\n}\n\nvec", "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // ray-sphere intersection\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ( ro - vec3( 0.0, 0.0, 0.0 ) ) );\n    float c = dot( ( ro - vec3( 0.0, 0.0, 0.0 ) ), ( ro - vec3( 0.0, 0.0, 0.0 ) ) ) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return 0.0;\n    float t = ( -b - sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t < tmin.x )\n        t = ( -b + sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t > tmax.x )\n        return 0.0;\n\n    // shadow\n    float shadow = 1.0;\n    vec3 p = ro + t * rd;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = texture( shadowMap, p.xy ).r;\n        if ( h < p.z - mint )\n            shadow -= 0.2;\n        if ( shadow < 0.0 )\n            return 0.0;\n        p += rd * 0.01;\n    }\n    return shadow;\n}\n\nvoid main()\n{\n    vec3 ro = vec3( 0.0, 0.0, 0", "\n    float k = 0.0;\n    k += (1.0 - dpdx.x) * (1.0 - dpdx.y);\n    k += (1.0 - dpdy.x) * (1.0 - dpdy.y);\n    k += (1.0 + dpdx.x) * (1.0 + dpdx.y);\n    k += (1.0 + dpdy.x) * (1.0 + dpdy.y);\n    k *= 0.25;\n    return k;\n}\n\nfloat", "\n    float a = time * 0.1;\n    float b = time * 0.2;\n    float c = time * 0.3;\n    float d = time * 0.4;\n    float e = time * 0.5;\n    float f = time * 0.6;\n    float g = time * 0.7;\n    float h = time * 0.8;\n    float i = time * 0.9;\n    float j = time * 1.0;\n\n    // noise\n    float n = noise( p + vec2( a, b ) );\n    float m = noise( p + vec2( c, d ) );\n    float o = noise( p + vec2( e, f ) );\n    float p = noise( p + vec2( g, h ) );\n    float q = noise( p + vec2( i, j ) );\n\n    // fractal\n    float r = fractal( p + vec2( n, m ) );\n    float s = fractal( p + vec2( o, p ) );\n    float t = fractal( p + vec2( q, q ) );\n\n    // color\n    vec3 color = vec3( 0.0 );\n    color += vec3( 0.5 ) * mix( vec3( 1.0 ), vec3( 0.0 ), r );\n    color += vec3( 0.5 ) * mix( vec3( 1.0 ), vec3( 0.0 ), s );\n    color += vec3( 0.5 ) * mix( vec3( 1.0 ), vec3( 0.0 ), t );\n\n    return color;\n}\n\nvoid main()\n{\n    vec2 p = ( gl_FragCoord.xy * 2.0 - resolution ) / min( resolution.x, resolution.y );\n    float time = iGlobalTime;\n\n    vec3 color = vec3( 0.0 );\n    color += render( p, time );\n\n    gl_FragColor = vec4( color, 1.0", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv;\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 p = -1.0 + 2.0*uv", "\n\tfloat a = 12.9898, b = 78.233, c = 43758.5453;\n\treturn fract(sin(dot(p, vec2(a, b))) * c);\n}\n\nfloat", "\n\t vec3 s = p - vec3(floor(p));\n\t vec3 x = p - s;\n\t \n\t /* calculate i1, i2, and 1.0 - x */\n\t vec3 i1 = step(vec3(0.0), x);\n\t vec3 i2 = step(vec3(1.0), x);\n\t vec3 x1 = 1.0 - x;\n\t \n\t /* calculate T and four vertices of T */\n\t vec4 T = vec4(s, i1.x) + vec4(s, i2.x);\n\t vec3 v0 = T.xyz;\n\t vec3 v1 = T.wxy;\n\t vec3 v2 = T.ywx;\n\t vec3 v3 = T.zxw;\n\t \n\t /* calculate dT and four barycentric coordinates of p relative to T */\n\t vec3 dT = x1 * (x2 * v0 + x3 * v1) + x2 * (x3 * v2 + x1 * v3) + x3 * (x1 * v3 + x2 * v0);\n\t vec3 b0 = x1 * i1;\n\t vec3 b1 = x2 * i2;\n\t vec3 b2 = x3 * (1.0 - i1 - i2);\n\t \n\t /* return dot(dT, b0) */\n\t return dot(dT, b0);\n}\n\nfloat", "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // ray-sphere intersection\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ( ro - vec3( 0.0, 0.0, 0.0 ) ) );\n    float c = dot( ( ro - vec3( 0.0, 0.0, 0.0 ) ), ( ro - vec3( 0.0, 0.0, 0.0 ) ) ) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return 0.0;\n    float t = ( -b - sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t < tmin.x )\n        t = ( -b + sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t > tmax.x )\n        return 0.0;\n\n    // shadow\n    float shadow = 1.0;\n    vec3 p = ro + t * rd;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = texture( shadowMap, p.xy ).r;\n        if ( h < p.z - mint )\n            shadow -= 0.2;\n        if ( shadow < 0.0 )\n            return 0.0;\n        p += rd * 0.01;\n    }\n    return shadow;\n}\n\nvoid main()\n{\n    vec3 ro = vec3( 0.0, 0.0, 0", "\n    vec3 col = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 light2 = vec3(0.0);\n    vec3 light3 = vec3(0.0);\n    vec3 light4 = vec3(0.0);\n    vec3 light5 = vec3(0.0);\n    vec3 light6 = vec3(0.0);\n    vec3 light7 = vec3(0.0);\n    vec3 light8 = vec3(0.0);\n    vec3 light9 = vec3(0.0);\n    vec3 light10 = vec3(0.0);\n    vec3 light11 = vec3(0.0);\n    vec3 light12 = vec3(0.0);\n    vec3 light13 = vec3(0.0);\n    vec3 light14 = vec3(0.0);\n    vec3 light15 = vec3(0.0);\n    vec3 light16 = vec3(0.0);\n    vec3 light17 = vec3(0.0);\n    vec3 light18 = vec3(0.0);\n    vec3 light19 = vec3(0.0);\n    vec3 light20 = vec3(0.0);\n    vec3 light21 = vec3(0.0);\n    vec3 light22 = vec3(0.0);\n    vec3 light23 = vec3(0.0);\n    vec3 light24 = vec3(0.0);\n    vec3 light25 = vec3(0.0);\n    vec3 light26 = vec3(0.0);\n    vec3 light27 = vec3(0.0);\n    vec3 light28 = vec3(0.0);\n    vec3 light29 = vec3(0.0);\n    vec3 light30 = vec3(0", "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // ray-sphere intersection\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ( ro - vec3( 0.0, 0.0, 0.0 ) ) );\n    float c = dot( ( ro - vec3( 0.0, 0.0, 0.0 ) ), ( ro - vec3( 0.0, 0.0, 0.0 ) ) ) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return 0.0;\n    float t = ( -b - sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t < tmin.x )\n        t = ( -b + sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t > tmax.x )\n        return 0.0;\n\n    // shadow\n    float shadow = 1.0;\n    vec3 p = ro + t * rd;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = texture( shadowMap, p.xy ).r;\n        if ( h < p.z - mint )\n            shadow -= 0.2;\n        if ( shadow < 0.0 )\n            return 0.0;\n        p += rd * 0.01;\n    }\n    return shadow;\n}\n\nvoid main()\n{\n    vec3 ro = vec3( 0.0, 0.0, 0", "\n    float k = 0.0;\n    k += (1.0 - dpdx.x) * (1.0 - dpdx.y);\n    k += (1.0 - dpdy.x) * (1.0 - dpdy.y);\n    k += (1.0 + dpdx.x) * (1.0 + dpdx.y);\n    k += (1.0 + dpdy.x) * (1.0 + dpdy.y);\n    k *= 0.25;\n    return k;\n}\n\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n    // h is the height of the 2D shape using the z component of p\n    // return the height of the extruded shape\n    return h - d;\n}\n\nvec", "\n    p.x = abs(p.x);\n\n    // rotate\n    mat2 m = mat2(cos(ab.x), -sin(ab.x), sin(ab.x), cos(ab.x));\n    p = m * p;\n\n    // scale\n    p.x *= ab.y;\n\n    // translate\n    p += ab;\n\n    return p;\n}\n\nfloat", "\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(", "\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(", "\n    float r = val;\n    float g = val;\n    float b = val;\n    if (val < 0.25) {\n        r = 2.0 * val;\n        g = 0.0;\n    } else if (val < 0.5) {\n        r = 1.0;\n        g = 2.0 * (val - 0.25);\n    } else if (val < 0.75) {\n        r = 1.0 - 2.0 * (val - 0.5);\n        g = 1.0;\n    } else {\n        r = 0.0;\n        g = 1.0;\n    }\n    return vec3(r, g, b);\n}\n\nvoid main() {\n    vec3 color = vec3(0.0);\n    vec3 pos = vec3(gl_FragCoord.xy, 0.0);\n    float dist = length(pos);\n    float t = dist / 100.0;\n    float t2 = t * t;\n    float t3 = t2 * t;\n    float t4 = t3 * t;\n    float t5 = t4 * t;\n    float t6 = t5 * t;\n    float t7 = t6 * t;\n    float t8 = t7 * t;\n    float t9 = t8 * t;\n    float t10 = t9 * t;\n    float t11 = t10 * t;\n    float t12 = t11 * t;\n    float t13 = t12 * t;\n    float t14 = t13 * t;\n    float t15 = t14 * t;\n    float t16 = t15 * t;\n    float t17 = t16 * t;\n    float t18 = t17 * t;\n    float t19 = t18 * t;\n    float t20 = t19 * t;\n    float t21 = t20 * t;\n    float t22 = t21 * t;\n    float t23 = t22 * t;\n    float t", "\n    vec2 q = abs(p) - ab;\n    return length(max(q,0.0)) + min(max(q.x,q.y),0.0);\n}\n\nfloat", "\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(", "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // ray-sphere intersection\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ( ro - vec3( 0.0, 0.0, 0.0 ) ) );\n    float c = dot( ( ro - vec3( 0.0, 0.0, 0.0 ) ), ( ro - vec3( 0.0, 0.0, 0.0 ) ) ) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return 0.0;\n    float t = ( -b - sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t < tmin.x )\n        t = ( -b + sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t > tmax.x )\n        return 0.0;\n\n    // shadow\n    float shadow = 1.0;\n    vec3 p = ro + t * rd;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = texture( shadowMap, p.xy ).r;\n        if ( h < p.z - mint )\n            shadow -= 0.2;\n        if ( shadow < 0.0 )\n            return 0.0;\n        p += rd * 0.01;\n    }\n    return shadow;\n}\n\nvoid main()\n{\n    vec3 ro = vec3( 0.0, 0.0, 0", "\n    float k = 0.0;\n    k += (1.0 - dpdx.x) * (1.0 - dpdx.y);\n    k += (1.0 - dpdy.x) * (1.0 - dpdy.y);\n    k += (1.0 + dpdx.x) * (1.0 + dpdx.y);\n    k += (1.0 + dpdy.x) * (1.0 + dpdy.y);\n    k *= 0.25;\n    return k;\n}\n\nfloat", "\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(", "\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(", "\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(", "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // ray-sphere intersection\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ( ro - vec3( 0.0, 0.0, 0.0 ) ) );\n    float c = dot( ( ro - vec3( 0.0, 0.0, 0.0 ) ), ( ro - vec3( 0.0, 0.0, 0.0 ) ) ) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return 0.0;\n    float t = ( -b - sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t < tmin.x )\n        t = ( -b + sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t > tmax.x )\n        return 0.0;\n\n    // shadow\n    float shadow = 1.0;\n    vec3 p = ro + t * rd;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = texture( shadowMap, p.xy ).r;\n        if ( h < p.z - mint )\n            shadow -= 0.2;\n        if ( shadow < 0.0 )\n            return 0.0;\n        p += rd * 0.01;\n    }\n    return shadow;\n}\n\nvoid main()\n{\n    vec3 ro = vec3( 0.0, 0.0, 0", "\n    float k = 0.0;\n    k += (1.0 - dpdx.x) * (1.0 - dpdx.y);\n    k += (1.0 - dpdy.x) * (1.0 - dpdy.y);\n    k += (1.0 + dpdx.x) * (1.0 + dpdx.y);\n    k += (1.0 + dpdy.x) * (1.0 + dpdy.y);\n    k *= 0.25;\n    return k;\n}\n\nfloat", "\n    vec2 uv = fragCoord/iResolution.xy;\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n\tuint mask = (1 << count) - 1;\n\tuint mask_inv = mask ^ 0xffffffff;\n\n\t/* Shuffle the index. */\n\tidx ^= seed;\n\tidx = (idx << 13) ^ (idx >> 17);\n\tidx = (idx << 12) ^ (idx >> 25);\n\tidx = (idx ^ seed) ^ (idx >> 4);\n\n\t/* Shuffle the index. */\n\tidx ^= seed;\n\tidx = (idx << 13) ^ (idx >> 17);\n\tidx = (idx << 12) ^ (idx >> 25);\n\tidx = (idx ^ seed) ^ (idx >> 4);\n\n\t/* Shuffle the index. */\n\tidx ^= seed;\n\tidx = (idx << 13) ^ (idx >> 17);\n\tidx = (idx << 12) ^ (idx >> 25);\n\tidx = (idx ^ seed) ^ (idx >> 4);\n\n\t/* Shuffle the index. */\n\tidx ^= seed;\n\tidx = (idx << 13) ^ (idx >> 17);\n\tidx = (idx << 12) ^ (idx >> 25);\n\tidx = (idx ^ seed) ^ (idx >> 4);\n\n\t/* Shuffle the index. */\n\tidx ^= seed;\n\tidx = (idx << 13) ^ (idx >> 17);\n\tidx = (idx << 12) ^ (idx >> 25);\n\tidx = (idx ^ seed) ^ (idx >> 4);\n\n\t/* Shuffle the index. */\n\tidx ^= seed;\n\tidx = (idx << 13) ^ (idx >> 17);\n\tidx = (idx << 12) ^ (idx >> 25);\n\tidx = (idx ^ seed) ^ (idx >> 4);\n\n\t/* Shuffle the index. */\n\tidx ^= seed;\n\tidx = (idx << 13) ^ (idx >> 17);\n\tidx = (idx << 12) ^ (idx >> 25);\n\tidx = (idx ^ seed) ^ (idx >> 4);\n\n\t/* Shuffle the index", "\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(", " and then used for all points\n    float x = pIn.x;\n    float y = pIn.y;\n    float z = pIn.z;\n    float r = sqrt(x*x + y*y);\n    float theta = atan(y,x);\n    float phi = acos(z/r);\n    \n    //These next 4 lines can be precalculated once and then used for all points\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r3*r;\n    float r5 = r4*r;\n    float r6 = r5*r;\n    float r7 = r6*r;\n    float r8 = r7*r;\n    float r9 = r8*r;\n    float r10 = r9*r;\n    float r11 = r10*r;\n    float r12 = r11*r;\n    float r13 = r12*r;\n    float r14 = r13*r;\n    float r15 = r14*r;\n    float r16 = r15*r;\n    float r17 = r16*r;\n    float r18 = r17*r;\n    float r19 = r18*r;\n    float r20 = r19*r;\n    float r21 = r20*r;\n    float r22 = r21*r;\n    float r23 = r22*r;\n    float r24 = r23*r;\n    float r25 = r24*r;\n    float r26 = r25*r;\n    float r27 = r26*r;\n    float r28 = r27*r;\n    float r29 = r28*r;\n    float r30 = r29*r;\n    float r31 = r30*r;\n    float r32 = r31*r;\n    float r33 = r32*r;\n    float r34 = r33*r;\n", "\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(", "\n    vec2 e12 = e1 - p;\n    vec2 e23 = e2 - p;\n    vec2 e34 = e3 - p;\n    vec2 e41 = e4 - p;\n    float d12 = dot(e12, e12);\n    float d23 = dot(e23, e23);\n    float d34 = dot(e34, e34);\n    float d41 = dot(e41, e41);\n    float d123 = dot(e12, e23);\n    float d124 = dot(e12, e34);\n    float d234 = dot(e23, e34);\n    float d134 = dot(e13, e34);\n    float d1234 = dot(e12, e34);\n    float d12341 = dot(e12, e41);\n    float d123412 = dot(e12, e23);\n    float d1234123 = dot(e12, e34);\n    float d12341234 = dot(e12, e41);\n    float d2341234 = dot(e23, e34);\n    float d23412341 = dot(e23, e41);\n    float d34123412 = dot(e34, e41);\n    float d341234123 = dot(e34, e23);\n    float d3412341234 = dot(e34, e41);\n    float d412341234 = dot(e41, e23);\n    float d4123412341 = dot(e41, e34);\n    float d41234123412 = dot(e41, e23);\n    float d412341234123 = dot(", "\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(", "\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(", "\n    vec2 pa = p - (va + vb) * 0.5;\n\n    // project onto line segment\n    float h = dot( pa, pa ) - rb * rb;\n\n    // clamp to capsule\n    return max( h, 0.0 );\n}\n\nfloat", "\n    //d = length(p) - r;\n    //d2 = d*d;\n    //return d2;\n    return length(p) - r;\n}\n\nfloat", "\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(float x) {\n//  return tanh(x);\n//}\n\n//float tanh_approx(", "\n    float k = 1.0;\n    float d = distance(p,a);\n    float d1 = distance(p,b);\n    float d2 = distance(p,a)+distance(p,b);\n\n    // compute the distance from the line segment\n    float d3 = max(0.0,min(d,d2)-d1);\n\n    // compute the distance from the circle\n    float d4 = length(p-a)-w1;\n\n    // compute the distance from the circle\n    float d5 = length(p-b)-w2;\n\n    // compute the distance from the circle\n    float d6 = length(p-a)-w1+length(p-b)-w2;\n\n    // compute the distance from the circle\n    float d7 = length(p-a)-w1+length(p-b)-w2+distance(p,a)+distance(p,b);\n\n    // compute the distance from the circle\n    float d8 = length(p-a)-w1+length(p-b)-w2+distance(p,a)+distance(p,b)+distance(p,a)+distance(p,b);\n\n    // compute the distance from the circle\n    float d9 = length(p-a)-w1+length(p-b)-w2+distance(p,a)+distance(p,b)+distance(p,a)+distance(p,b)+distance(p,a)+distance(p,b);\n\n    // compute the distance from the circle\n    float d10 = length(p-a)-w1+length(p-b)-w2+distance(p,a)+distance(p,b)+distance(p,a)+distance(p,b)+distance(p,a)+distance(p,b)+distance(p,a)+distance(p,b);\n\n    // compute the distance from the circle\n    float d11 = length(p-a)-w1+length(p-b)-w2+distance(p,a)+distance(p,b)+distance(p,a)+distance(p,b)+distance(p,a)+distance", "\n\n    vec2 uv = fragCoord.xy / iResolution.xy;\n\n    vec3 color = vec3(0.0);\n\n    float d = length(uv);\n\n    if(d < 0.5)\n    {\n        color = vec3(1.0);\n    }\n\n    fragColor = vec4(color,1.0);\n}\n", "\n  //  return 1.0 - exp(-2.0 * x) / (1.0 + exp(-2.0 * x));\n  //  return 1.0 - tanh(2.0 * x);\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tanh(2.0 * x) / 2.0;\n  //  return 1.0 - tan", ".\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n", ".\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n  //  http://www.iquilezles.org/www/articles/palettes/palettes.htm\n", "\n    return ivec2( z.x + z.y * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", " from heightmap\n    float d = heightmap(p);\n\n    // get polygon normal\n    vec3 n = normal(p);\n\n    // get polygon tangent\n    vec3 t = tangent(p);\n\n    // get polygon bitangent\n    vec3 b = bitangent(p);\n\n    // get polygon color\n    vec4 c = color(p);\n\n    // get polygon alpha\n    float a = alpha(p);\n\n    // get polygon uv\n    vec2 uv = uv(p);\n\n    // get polygon uv offset\n    vec2 uv_offset = uv_offset(p);\n\n    // get polygon uv scale\n    vec2 uv_scale = uv_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale =", "\n    float angle = 45.0;\n    vec2 rotatedCoord = vec2( fragCoord.x * cos(angle) - fragCoord.y * sin(angle), fragCoord.x * sin(angle) + fragCoord.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord2 = vec2( rotatedCoord.x * cos(angle) - rotatedCoord.y * sin(angle), rotatedCoord.x * sin(angle) + rotatedCoord.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord3 = vec2( rotatedCoord2.x * cos(angle) - rotatedCoord2.y * sin(angle), rotatedCoord2.x * sin(angle) + rotatedCoord2.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord4 = vec2( rotatedCoord3.x * cos(angle) - rotatedCoord3.y * sin(angle), rotatedCoord3.x * sin(angle) + rotatedCoord3.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord5 = vec2( rotatedCoord4.x * cos(angle) - rotatedCoord4.y * sin(angle), rotatedCoord4.x * sin(angle) + rotatedCoord4.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord6 = vec2( rotatedCoord5.x * cos(angle) - rotatedCoord5.y * sin(angle), rotatedCoord5.x * sin(angle) + rotatedCoord5.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord7 = vec2( rotatedCoord6.x * cos(angle) - rotatedCoord6.y * sin(angle), rotatedCoord6.x * sin(angle) + rotatedCoord6.y * cos(angle) );\n\n    // rotate", "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // ray-sphere intersection\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ( ro - vec3( 0.0, 0.0, 0.0 ) ) );\n    float c = dot( ( ro - vec3( 0.0, 0.0, 0.0 ) ), ( ro - vec3( 0.0, 0.0, 0.0 ) ) ) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return 0.0;\n    float t = ( -b - sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t < tmin.x )\n        t = ( -b + sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t > tmax.x )\n        return 0.0;\n\n    // shadow\n    float shadow = 1.0;\n    vec3 p = ro + t * rd;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = texture( shadowMap, p.xy ).r;\n        if ( h < p.z - mint )\n            shadow -= 0.2;\n        if ( shadow < 0.0 )\n            return 0.0;\n        p += rd * 0.01;\n    }\n    return shadow;\n}\n\nvoid main()\n{\n    vec3 ro = vec3( 0.0, 0.0, 0", "\n    float k = 0.0;\n    k += (1.0 - dpdx.x) * (1.0 - dpdx.y);\n    k += (1.0 - dpdy.x) * (1.0 - dpdy.y);\n    k += (1.0 + dpdx.x) * (1.0 + dpdx.y);\n    k += (1.0 + dpdy.x) * (1.0 + dpdy.y);\n    k *= 0.25;\n    return k;\n}\n\nfloat", "\n    return ivec2( z.x + z.y * 1000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", " from heightmap\n    float d = heightmap(p);\n\n    // get polygon normal\n    vec3 n = normal(p);\n\n    // get polygon tangent\n    vec3 t = tangent(p);\n\n    // get polygon bitangent\n    vec3 b = bitangent(p);\n\n    // get polygon color\n    vec4 c = color(p);\n\n    // get polygon alpha\n    float a = alpha(p);\n\n    // get polygon uv\n    vec2 uv = uv(p);\n\n    // get polygon uv offset\n    vec2 uv_offset = uv_offset(p);\n\n    // get polygon uv scale\n    vec2 uv_scale = uv_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale = uv_offset_scale(p);\n\n    // get polygon uv offset scale\n    vec2 uv_offset_scale =", "\n    float angle = 45.0;\n    vec2 rotatedCoord = vec2( fragCoord.x * cos(angle) - fragCoord.y * sin(angle), fragCoord.x * sin(angle) + fragCoord.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord2 = vec2( rotatedCoord.x * cos(angle) - rotatedCoord.y * sin(angle), rotatedCoord.x * sin(angle) + rotatedCoord.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord3 = vec2( rotatedCoord2.x * cos(angle) - rotatedCoord2.y * sin(angle), rotatedCoord2.x * sin(angle) + rotatedCoord2.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord4 = vec2( rotatedCoord3.x * cos(angle) - rotatedCoord3.y * sin(angle), rotatedCoord3.x * sin(angle) + rotatedCoord3.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord5 = vec2( rotatedCoord4.x * cos(angle) - rotatedCoord4.y * sin(angle), rotatedCoord4.x * sin(angle) + rotatedCoord4.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord6 = vec2( rotatedCoord5.x * cos(angle) - rotatedCoord5.y * sin(angle), rotatedCoord5.x * sin(angle) + rotatedCoord5.y * cos(angle) );\n\n    // rotate the coordinate system\n    vec2 rotatedCoord7 = vec2( rotatedCoord6.x * cos(angle) - rotatedCoord6.y * sin(angle), rotatedCoord6.x * sin(angle) + rotatedCoord6.y * cos(angle) );\n\n    // rotate", "\n    vec3 bbmin = vec3( -1.0 );\n    vec3 bbmax = vec3( 1.0 );\n\n    // ray-box intersection\n    vec3 t0 = ( bbmin - ro ) / rd;\n    vec3 t1 = ( bbmax - ro ) / rd;\n    vec3 tmin = min( t0, t1 );\n    vec3 tmax = max( t0, t1 );\n\n    // ray-sphere intersection\n    float a = dot( rd, rd );\n    float b = 2.0 * dot( rd, ( ro - vec3( 0.0, 0.0, 0.0 ) ) );\n    float c = dot( ( ro - vec3( 0.0, 0.0, 0.0 ) ), ( ro - vec3( 0.0, 0.0, 0.0 ) ) ) - 1.0;\n    float discriminant = b * b - 4.0 * a * c;\n    if ( discriminant < 0.0 )\n        return 0.0;\n    float t = ( -b - sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t < tmin.x )\n        t = ( -b + sqrt( discriminant ) ) / ( 2.0 * a );\n    if ( t > tmax.x )\n        return 0.0;\n\n    // shadow\n    float shadow = 1.0;\n    vec3 p = ro + t * rd;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float h = texture( shadowMap, p.xy ).r;\n        if ( h < p.z - mint )\n            shadow -= 0.2;\n        if ( shadow < 0.0 )\n            return 0.0;\n        p += rd * 0.01;\n    }\n    return shadow;\n}\n\nvoid main()\n{\n    vec3 ro = vec3( 0.0, 0.0, 0", "\n    float k = 0.0;\n    k += (1.0 - dpdx.x) * (1.0 - dpdx.y);\n    k += (1.0 - dpdy.x) * (1.0 - dpdy.y);\n    k += (1.0 + dpdx.x) * (1.0 + dpdx.y);\n    k += (1.0 + dpdy.x) * (1.0 + dpdy.y);\n    k *= 0.25;\n    return k;\n}\n\nfloat"], "input_none": ["\n    vec3 q = p;\n    vec3 r = p;\n    float t = 0.0;\n    float dt = 1.0;\n    float eps = 0.0001;\n    float eps2 = 0.00001;\n    float f = 1.0;\n    float g = 1.0;\n    float h = 1.0;\n    float i = 1.0;\n    float j = 1.0;\n    float k = 1.0;\n    float l = 1.0;\n    float m = 1.0;\n    float n = 1.0;\n    float o = 1.0;\n    float p = 1.0;\n    float q = 1.0;\n    float r = 1.0;\n    float s = 1.0;\n    float t = 1.0;\n    float u = 1.0;\n    float v = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.0;\n    float d = 1.0;\n    float e = 1.0;\n    float f = 1.0;\n    float g = 1.0;\n    float h = 1.0;\n    float i = 1.0;\n    float j = 1.0;\n    float k = 1.0;\n    float l = 1.0;\n    float m = 1.0;\n    float n = 1.0;\n    float o = 1.0;\n    float p = 1.0;\n    float q = 1.0;\n    float r = 1.0;\n    float s = 1.0;\n    float t = 1.0;\n    float u = 1.0;\n    float v = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.", "\n    float d = length(p - _position);\n    return d;\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    vec4 color = vec4(0.0);\n    vec2 z = p;\n    int i = 0;\n    while (i < 256 && length(z) < 2.0) {\n        z = vec2(z.x * z.x - z.y * z.y, 2.0 * z.x * z.y) + p;\n        color.r = float(i) / 256.0;\n        i++;\n    }\n    return color;\n}\n\nvoid main()\n{\n    vec2 p = (gl_FragCoord.xy * 2.0 - resolution) / min(resolution.x, resolution.y);\n    vec4 color = juliaSet(p);\n    gl_FragColor = vec4(color.rgb, 1.0);\n}\n", "\n    float cosTheta = dot(rayDir, sunDir);\n    float cos2Theta = cosTheta * cosTheta;\n    float cos4Theta = cos2Theta * cos2Theta;\n    float cos6Theta = cos4Theta * cos2Theta;\n    float cos8Theta = cos6Theta * cos2Theta;\n    float cos12Theta = cos8Theta * cos2Theta;\n    float cos16Theta = cos12Theta * cos2Theta;\n    float cos20Theta = cos16Theta * cos2Theta;\n    float cos24Theta = cos20Theta * cos2Theta;\n    float cos28Theta = cos24Theta * cos2Theta;\n    float cos32Theta = cos28Theta * cos2Theta;\n    float cos36Theta = cos32Theta * cos2Theta;\n    float cos40Theta = cos36Theta * cos2Theta;\n    float cos44Theta = cos40Theta * cos2Theta;\n    float cos48Theta = cos44Theta * cos2Theta;\n    float cos52Theta = cos48Theta * cos2Theta;\n    float cos56Theta = cos52Theta * cos2Theta;\n    float cos60Theta = cos56Theta * cos2Theta;\n    float cos64Theta = cos60Theta * cos2Theta;\n    float cos68Theta = cos64Theta * cos2Theta;\n    float cos72Theta = cos68Theta * cos2Theta;\n    float cos76Theta = cos72Theta * cos2Theta;\n    float cos80Theta = cos76Theta * cos2Theta;\n    float cos84Theta = cos80Theta * cos2Theta;\n    float cos88Theta = cos84Theta * cos2Theta;\n    float cos92Theta = cos88Theta * cos2Theta;\n    float cos96Theta = cos92Theta * cos2Theta;\n    float cos100Theta = cos96Theta * cos2Theta;\n    float cos104Theta = cos100Theta * cos2Theta;\n    float cos108Theta = cos104Theta * cos2Theta;\n    float cos112Theta = cos1", "\n    vec2 p = uv;\n    vec2 q = vec2(sin(t), cos(t));\n    vec2 r = vec2(sin(t + PI), cos(t + PI));\n    vec2 s = vec2(sin(t + 2.0 * PI), cos(t + 2.0 * PI));\n    vec2 t = vec2(sin(t + 3.0 * PI), cos(t + 3.0 * PI));\n    vec2 u = vec2(sin(t + 4.0 * PI), cos(t + 4.0 * PI));\n    vec2 v = vec2(sin(t + 5.0 * PI), cos(t + 5.0 * PI));\n    vec2 w = vec2(sin(t + 6.0 * PI), cos(t + 6.0 * PI));\n    vec2 x = vec2(sin(t + 7.0 * PI), cos(t + 7.0 * PI));\n    vec2 y = vec2(sin(t + 8.0 * PI), cos(t + 8.0 * PI));\n    vec2 z = vec2(sin(t + 9.0 * PI), cos(t + 9.0 * PI));\n    vec2 a = vec2(sin(t + 10.0 * PI), cos(t + 10.0 * PI));\n    vec2 b = vec2(sin(t + 11.0 * PI), cos(t + 11.0 * PI));\n    vec2 c = vec2(sin(t + 12.0 * PI), cos(t + 12.0 * PI));\n    vec2 d = vec2(sin(t + 13.0 * PI), cos(t + 13.0 * PI));\n    vec2 e = vec2(sin(t + 14.0 * PI), cos(t + 14.0 * PI));\n    vec2 f = vec2(sin(t + 15.0", "\n    vec3 n = normal(p);\n    float d = dot(n, e);\n    if (d < 0.0)\n        return vec3(0.0);\n    vec3 r = reflect(e, n);\n    float s = pow(d, 3.0);\n    return vec3(s * r.x, s * r.y, s * r.z);\n}\n\nvec", "\n    float cosTheta = dot(rayDir, sunDir);\n    float cos2Theta = cosTheta * cosTheta;\n    float cos4Theta = cos2Theta * cos2Theta;\n    float cos6Theta = cos4Theta * cos2Theta;\n    float cos8Theta = cos6Theta * cos2Theta;\n    float cos12Theta = cos8Theta * cos2Theta;\n    float cos16Theta = cos12Theta * cos2Theta;\n    float cos20Theta = cos16Theta * cos2Theta;\n    float cos24Theta = cos20Theta * cos2Theta;\n    float cos28Theta = cos24Theta * cos2Theta;\n    float cos32Theta = cos28Theta * cos2Theta;\n    float cos36Theta = cos32Theta * cos2Theta;\n    float cos40Theta = cos36Theta * cos2Theta;\n    float cos44Theta = cos40Theta * cos2Theta;\n    float cos48Theta = cos44Theta * cos2Theta;\n    float cos52Theta = cos48Theta * cos2Theta;\n    float cos56Theta = cos52Theta * cos2Theta;\n    float cos60Theta = cos56Theta * cos2Theta;\n    float cos64Theta = cos60Theta * cos2Theta;\n    float cos68Theta = cos64Theta * cos2Theta;\n    float cos72Theta = cos68Theta * cos2Theta;\n    float cos76Theta = cos72Theta * cos2Theta;\n    float cos80Theta = cos76Theta * cos2Theta;\n    float cos84Theta = cos80Theta * cos2Theta;\n    float cos88Theta = cos84Theta * cos2Theta;\n    float cos92Theta = cos88Theta * cos2Theta;\n    float cos96Theta = cos92Theta * cos2Theta;\n    float cos100Theta = cos96Theta * cos2Theta;\n    float cos104Theta = cos100Theta * cos2Theta;\n    float cos108Theta = cos104Theta * cos2Theta;\n    float cos112Theta = cos1", "\n    vec3 rayOrigin = eyePosition;\n    vec3 rayDirectionNormalized = normalize( rayDirection );\n    float t = -1.0;\n    float tmin = 0.0;\n    float tmax = 1000000.0;\n    float tymin = 0.0;\n    float tymax = 1000000.0;\n    float tzmin = 0.0;\n    float tzmax = 1000000.0;\n    float tminx = 0.0;\n    float tmaxx = 1000000.0;\n    float tminy = 0.0;\n    float tmaxy = 1000000.0;\n    float tminz = 0.0;\n    float tmaxz = 1000000.0;\n    float tminxy = 0.0;\n    float tmaxxy = 1000000.0;\n    float tminyz = 0.0;\n    float tmaxyz = 1000000.0;\n    float tminxz = 0.0;\n    float tmaxxz = 1000000.0;\n    float tminxyz = 0.0;\n    float tmaxxyz = 1000000.0;\n    float tminxzy = 0.0;\n    float tmaxxzy = 1000000.0;\n    float tminyzx = 0.0;\n    float tmaxyzx = 1000000.0;\n    float tminyzy = 0.0;\n    float tmaxyzy = 1000000.0;\n    float tminzxy = 0.0;\n    float tmaxzxy = 1000000.0;\n    float tminzxz = 0.0;\n    float tmaxzxz = 1000000.0;\n    float tminzyx = 0.0;\n    float tmaxzyx = 1000000.0;\n    float tminzyz = ", "\n    vec3 lightDirection = normalize( lightPosition - eyePosition );\n    vec3 reflectDirection = reflect( -lightDirection, rayDirection );\n    float specularFactor = pow( max( dot( reflectDirection, eyeDirection ), 0.0 ), 32.0 );\n    vec3 diffuseColor = vec3( 0.0, 0.0, 0.0 );\n    vec3 specularColor = vec3( 0.0, 0.0, 0.0 );\n    if( dot( lightDirection, rayDirection ) > 0.0 ){\n        diffuseColor = vec3( 0.0, 0.0, 0.0 );\n        specularColor = vec3( 0.0, 0.0, 0.0 );\n    }\n    else{\n        diffuseColor = vec3( 0.0, 0.0, 0.0 );\n        specularColor = vec3( 0.0, 0.0, 0.0 );\n    }\n    return vec3( 0.0, 0.0, 0.0 );\n}\n\nvoid main(){\n    vec2 rayHitInfo = vec2( 0.0, 0.0 );\n    vec3 eyePosition = vec3( 0.0, 0.0, 0.0 );\n    vec3 eyeDirection = vec3( 0.0, 0.0, 0.0 );\n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheWorld = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheLight = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheReflect = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheRefract = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheAmbient = vec3( ", "\n    return p * 0.5 + 0.5;\n}\n\nvec", "\n    vec2 res = vec2(0.0);\n    float t = 0.0;\n    float tmin = 0.001;\n    float tmax = 1000.0;\n    for(int i = 0; i < 100; i++)\n    {\n        vec3 p = ro + rd * t;\n        float d = map(p);\n        if(d < tmin)\n        {\n            tmin = d;\n            res.x = t;\n        }\n        if(d > tmax)\n        {\n            tmax = d;\n            res.y = t;\n        }\n        if(d < 0.001 || t > tmax)\n        {\n            break;\n        }\n        t += d;\n    }\n    return res;\n}\n\nvec", "\n    vec4 p2 = vec4(p, 1.0);\n    p2.y *= -1.0;\n    p2.x *= -1.0;\n    p2.z *= -1.0;\n    p2.w = 1.0;\n    return p2;\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    vec3 pos = vec3(0.0);\n    vec3 nor = vec3(0.0);\n    float t = 0.0;\n    float tmin = 1000000.0;\n    float tmax = 0.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n   ", "\n    vec3 n = normalize(oN);\n    vec3 n2 = normalize(oN + n);\n    vec3 n3 = normalize(oN - n);\n    vec3 n4 = normalize(oN + n2);\n    vec3 n5 = normalize(oN - n2);\n    vec3 n6 = normalize(oN + n3);\n    vec3 n7 = normalize(oN - n3);\n    vec3 n8 = normalize(oN + n4);\n    vec3 n9 = normalize(oN - n4);\n    vec3 n10 = normalize(oN + n5);\n    vec3 n11 = normalize(oN - n5);\n    vec3 n12 = normalize(oN + n6);\n    vec3 n13 = normalize(oN - n6);\n    vec3 n14 = normalize(oN + n7);\n    vec3 n15 = normalize(oN - n7);\n    vec3 n16 = normalize(oN + n8);\n    vec3 n17 = normalize(oN - n8);\n    vec3 n18 = normalize(oN + n9);\n    vec3 n19 = normalize(oN - n9);\n    vec3 n20 = normalize(oN + n10);\n    vec3 n21 = normalize(oN - n10);\n    vec3 n22 = normalize(oN + n11);\n    vec3 n23 = normalize(oN - n11);\n    vec3 n24 = normalize(oN + n12);\n    vec3 n25 = normalize(oN - n12);\n    vec3 n26 = normalize(oN + n13);\n    vec3 n27 = normalize(oN - n13);\n    vec3 n28 = normalize(oN + n14);\n    vec3 n29 = normalize(oN", "\n    vec2 p2 = p * 2.0 - 1.0;\n    float d = dot(p2, p2);\n    float d2 = d * d;\n    float d3 = d2 * d;\n    float d4 = d3 * d;\n    float d5 = d4 * d;\n    float d6 = d5 * d;\n    float d7 = d6 * d;\n    float d8 = d7 * d;\n    float d9 = d8 * d;\n    float d10 = d9 * d;\n    float d11 = d10 * d;\n    float d12 = d11 * d;\n    float d13 = d12 * d;\n    float d14 = d13 * d;\n    float d15 = d14 * d;\n    float d16 = d15 * d;\n    float d17 = d16 * d;\n    float d18 = d17 * d;\n    float d19 = d18 * d;\n    float d20 = d19 * d;\n    float d21 = d20 * d;\n    float d22 = d21 * d;\n    float d23 = d22 * d;\n    float d24 = d23 * d;\n    float d25 = d24 * d;\n    float d26 = d25 * d;\n    float d27 = d26 * d;\n    float d28 = d27 * d;\n    float d29 = d28 * d;\n    float d30 = d29 * d;\n    float d31 = d30 * d;\n    float d32 = d31 * d;\n    float d33 = d32 * d;\n    float d34 = d33 * d;\n    float d35 = d34 * d;\n    float d36 = d35 * d;\n    float d37 = d36 * d;\n    float d38 = d37 * d;\n    float d39 = d38 * d;\n    float", "\n    vec4 p2 = vec4(p, 1.0);\n    p2.y *= -1.0;\n    p2.x *= -1.0;\n    p2.z *= -1.0;\n    p2.w = 1.0;\n    return p2;\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    vec3 pos = vec3(0.0);\n    vec3 nor = vec3(0.0);\n    float t = 0.0;\n    float tmin = 1000000.0;\n    float tmax = 0.0;\n    float t0 = 0.0;\n    float t1 = 0.0;\n    float t2 = 0.0;\n    float t3 = 0.0;\n    float t4 = 0.0;\n    float t5 = 0.0;\n    float t6 = 0.0;\n    float t7 = 0.0;\n    float t8 = 0.0;\n    float t9 = 0.0;\n    float t10 = 0.0;\n    float t11 = 0.0;\n    float t12 = 0.0;\n    float t13 = 0.0;\n    float t14 = 0.0;\n    float t15 = 0.0;\n    float t16 = 0.0;\n    float t17 = 0.0;\n    float t18 = 0.0;\n    float t19 = 0.0;\n    float t20 = 0.0;\n    float t21 = 0.0;\n    float t22 = 0.0;\n    float t23 = 0.0;\n    float t24 = 0.0;\n    float t25 = 0.0;\n    float t26 = 0.0;\n    float t27 = 0.0;\n    float t28 = 0.0;\n    float t29 = 0.0;\n    float t30 = 0.0;\n    float t31 = 0.0;\n    float t32 = 0.0;\n    float t33 = 0.0;\n    float t34 = 0.0;\n    float t35 = 0.0;\n    float t36 = 0.0;\n    float t37 = 0.0;\n    float t38 = 0.0;\n    float t39 = 0.0;\n   ", "\n    vec3 n = normalize(oN);\n    vec3 n2 = normalize(oN + n);\n    vec3 n3 = normalize(oN - n);\n    vec3 n4 = normalize(oN + n2);\n    vec3 n5 = normalize(oN - n2);\n    vec3 n6 = normalize(oN + n3);\n    vec3 n7 = normalize(oN - n3);\n    vec3 n8 = normalize(oN + n4);\n    vec3 n9 = normalize(oN - n4);\n    vec3 n10 = normalize(oN + n5);\n    vec3 n11 = normalize(oN - n5);\n    vec3 n12 = normalize(oN + n6);\n    vec3 n13 = normalize(oN - n6);\n    vec3 n14 = normalize(oN + n7);\n    vec3 n15 = normalize(oN - n7);\n    vec3 n16 = normalize(oN + n8);\n    vec3 n17 = normalize(oN - n8);\n    vec3 n18 = normalize(oN + n9);\n    vec3 n19 = normalize(oN - n9);\n    vec3 n20 = normalize(oN + n10);\n    vec3 n21 = normalize(oN - n10);\n    vec3 n22 = normalize(oN + n11);\n    vec3 n23 = normalize(oN - n11);\n    vec3 n24 = normalize(oN + n12);\n    vec3 n25 = normalize(oN - n12);\n    vec3 n26 = normalize(oN + n13);\n    vec3 n27 = normalize(oN - n13);\n    vec3 n28 = normalize(oN + n14);\n    vec3 n29 = normalize(oN", "\n    vec3 color = vec3(0.0f);\n    float t = 0.0f;\n    float tmin = 1.0f;\n    float tmax = 1000.0f;\n    for (int i = 0; i < 3; i++)\n    {\n        vec3 origin = ray.origin + ray.direction * t;\n        vec3 direction = reflect(ray.direction, ray.normal);\n        vec3 spherePos = vec3(0.0f, 0.0f, 0.0f);\n        spherePos.x = cos(ray.direction.x) * ray.direction.y;\n        spherePos.y = cos(ray.direction.y) * ray.direction.z;\n        spherePos.z = cos(ray.direction.z) * ray.direction.x;\n        vec3 sphereNormal = normalize(spherePos);\n        float sphereRadius = 0.5f;\n        float sphereDistance = length(spherePos);\n        float sphereT = (sphereRadius - sphereDistance) / dot(sphereNormal, ray.direction);\n        if (sphereT > 0.0f && sphereT < tmax)\n        {\n            t = sphereT;\n            tmin = sphereT;\n        }\n    }\n    if (tmin < 1.0f)\n    {\n        color = vec3(1.0f, 0.0f, 0.0f);\n    }\n    return color;\n}\n\nvec", "\n    vec3 object_center = vec3(0.0, 0.0, 0.0);\n    float radius = 1.0;\n    return length(p - object_center) - radius;\n}\n\nfloat", "\n    PT = mat3(\n        vec3(1.0, 0.0, 0.0),\n        vec3(0.0, 1.0, 0.0),\n        vec3(0.0, 0.0, 1.0)\n    );\n    g = pos.xy;\n}\n\nvoid gridToPos(in vec2 g, out vec3 pos) {\n    pos = vec3(g, 0.0);\n}\n\nvoid main() {\n    vec3 pos;\n    vec2 g;\n    posToGrid(gl_FragCoord.xy, PT, g);\n    gridToPos(g, pos);\n    gl_FragColor = vec4(pos, 1.0);\n}\n", "\n    return PT * vec3(g, 1.0);\n}\n\nvec", "\n    return length(a - b) - (sphereRadius + sphereRadius);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    vec3 q = p - b;\n    return dot( q, q ) - b.z * b.z;\n}\n\nfloat", "\n    float d = dot(pt, pt);\n    return d;\n}\n\nfloat", "\n    vec4 color = texture2D(u_texture, coord);\n    vec4 color2 = texture2D(u_texture2, coord);\n    vec4 color3 = texture2D(u_texture3, coord);\n    vec4 color4 = texture2D(u_texture4, coord);\n    vec4 color5 = texture2D(u_texture5, coord);\n    vec4 color6 = texture2D(u_texture6, coord);\n    vec4 color7 = texture2D(u_texture7, coord);\n    vec4 color8 = texture2D(u_texture8, coord);\n    vec4 color9 = texture2D(u_texture9, coord);\n    vec4 color10 = texture2D(u_texture10, coord);\n    vec4 color11 = texture2D(u_texture11, coord);\n    vec4 color12 = texture2D(u_texture12, coord);\n    vec4 color13 = texture2D(u_texture13, coord);\n    vec4 color14 = texture2D(u_texture14, coord);\n    vec4 color15 = texture2D(u_texture15, coord);\n    vec4 color16 = texture2D(u_texture16, coord);\n    vec4 color17 = texture2D(u_texture17, coord);\n    vec4 color18 = texture2D(u_texture18, coord);\n    vec4 color19 = texture2D(u_texture19, coord);\n    vec4 color20 = texture2D(u_texture20, coord);\n    vec4 color21 = texture2D(u_texture21, coord);\n    vec4 color22 = texture2D(u_texture22, coord);\n    vec4 color23 = texture2D(u_texture23, coord);\n    vec4 color24 = texture2D(u_texture24, coord);\n    vec", "\n    float d = distance(pA, pB);\n    float l = length(pA - pB);\n    float r = rounded;\n    float dd = dashOn;\n    float dd2 = dd / 2.0;\n    float dd3 = dd2 / 2.0;\n    float dd4 = dd3 / 2.0;\n    float dd5 = dd4 / 2.0;\n    float dd6 = dd5 / 2.0;\n    float dd7 = dd6 / 2.0;\n    float dd8 = dd7 / 2.0;\n    float dd9 = dd8 / 2.0;\n    float dd10 = dd9 / 2.0;\n    float dd11 = dd10 / 2.0;\n    float dd12 = dd11 / 2.0;\n    float dd13 = dd12 / 2.0;\n    float dd14 = dd13 / 2.0;\n    float dd15 = dd14 / 2.0;\n    float dd16 = dd15 / 2.0;\n    float dd17 = dd16 / 2.0;\n    float dd18 = dd17 / 2.0;\n    float dd19 = dd18 / 2.0;\n    float dd20 = dd19 / 2.0;\n    float dd21 = dd20 / 2.0;\n    float dd22 = dd21 / 2.0;\n    float dd23 = dd22 / 2.0;\n    float dd24 = dd23 / 2.0;\n    float dd25 = dd24 / 2.0;\n    float dd26 = dd25 / 2.0;\n    float dd27 = dd26 / 2.0;\n    float dd28 = dd27 / 2.0;\n   ", "\n    vec2 f = fract(p);\n    vec2 i = floor(p);\n    vec2 u = f - vec2(0.5);\n    vec2 w = vec2(0.5) - f;\n    vec2 uu = u * u;\n    vec2 uw = u * w;\n    vec2 ww = w * w;\n    vec2 uuu = uu * u;\n    vec2 uww = uw * w;\n    vec2 wwu = ww * u;\n    vec2 wwv = ww * vec2(1.0, -1.0);\n    vec2 uuuu = uuu * u;\n    vec2 uuww = uuw * w;\n    vec2 uwwu = uww * u;\n    vec2 uwwv = uww * vec2(1.0, -1.0);\n    vec2 wwuu = wwu * u;\n    vec2 wwuv = wwu * vec2(1.0, -1.0);\n    vec2 wwvv = wwv * vec2(1.0, -1.0);\n    vec2 uuuuu = uuuu * u;\n    vec2 uuwwv = uuww * vec2(1.0, -1.0);\n    vec2 uwwvv = uwwv * vec2(1.0, -1.0);\n    vec2 uuuuuu = uuuuu * u;\n    vec2 uuuuuv = uuuu * vec2(1.0, -1.0);\n    vec2 uuuuvv = uuuv * vec2(1.0, -1.0);\n    vec2 uuuvvv = uuuv * vec2(1.0, -1.0);\n    vec2 uuvvvv = uuvv * vec2(1.0, -1.0);\n    vec2 uvuvvv = uvuv * vec2(1.0, -1.0);", "\n    float tmin = 0.001, tmax = 1000.0;\n    vec3  p;\n    vec3  n;\n    float t;\n    float tmin_sphere = 0.001, tmax_sphere = 1000.0;\n    vec3  p_sphere;\n    float t_sphere;\n    float tmin_plane = 0.001, tmax_plane = 1000.0;\n    vec3  p_plane;\n    float t_plane;\n    float tmin_cylinder = 0.001, tmax_cylinder = 1000.0;\n    vec3  p_cylinder;\n    float t_cylinder;\n    float tmin_cone = 0.001, tmax_cone = 1000.0;\n    vec3  p_cone;\n    float t_cone;\n    float tmin_triangle = 0.001, tmax_triangle = 1000.0;\n    vec3  p_triangle;\n    float t_triangle;\n    float tmin_cube = 0.001, tmax_cube = 1000.0;\n    vec3  p_cube;\n    float t_cube;\n    float tmin_sphere_2 = 0.001, tmax_sphere_2 = 1000.0;\n    vec3  p_sphere_2;\n    float t_sphere_2;\n    float tmin_cube_2 = 0.001, tmax_cube_2 = 1000.0;\n    vec3  p_cube_2;\n    float t_cube_2;\n    float tmin_cube_3 = 0.001, tmax_cube_3 = 1000.0;\n    vec3  p_cube_3;\n    float t_cube_3;\n    float tmin_cube_4 = 0.001, tmax_cube_4 = 1", "\n    vec2 i = vec2( 0.0 );\n    vec2 f = vec2( 1.0 );\n    for ( int j = 0; j < 10; j++ ) {\n        if ( f.x < f.y ) {\n            f = vec2( f.x * 2.0, f.y * 2.0 );\n            i = i + vec2( 0.5 );\n        } else {\n            f = vec2( f.x / 2.0, f.y / 2.0 );\n            i = i + vec2( 0.0, 0.5 );\n        }\n        vec3 p = ro + rd * i.x * f.x + rd * i.y * f.y;\n        if ( length( p - cen ) < rad.x ) {\n            return i;\n        }\n    }\n    return vec2( 0.0 );\n}\n\nvec", "\n    vec4 res = vec4( 0.0 );\n    vec3 ab = pb - pa;\n    float d = dot( ab, ab );\n    float e = dot( ab, rd );\n    float f = dot( ab, ro - pa );\n    float g = dot( rd, rd ) * d - e * e;\n    float h = f * f / g;\n    float i = e * f / g;\n    float j = sqrt( d * d - h );\n    float k = ( e > 0.0? -j : j );\n    float l = k / e;\n    float m = k / f;\n    float n = ( l > m? l : m );\n    float p = n < 0.0? 0.0 : n;\n    float q = ( p > k? p : k );\n    float r = q / e;\n    float s = q / f;\n    float t = ( r > s? r : s );\n    float u = t < 0.0? 0.0 : t;\n    float v = ( u > t? u : t );\n    float w = v < 0.0? 0.0 : v;\n    float x = w < 0.0? 0.0 : w;\n    float y = x < 0.0? 0.0 : x;\n    float z = y < 0.0? 0.0 : y;\n    float ww = max( 0.0, z );\n    float xx = max( 0.0, z - 1.0 );\n    float yy = max( 0.0, z - 2.0 );\n    float zz = max( 0.0, z - 3.0 );\n    float ww2 = ww * ww;\n    float xx2 = xx * xx;\n    float yy2 = yy * yy;\n    float zz2 = zz * zz;\n    float ww3 = ww2 * ww;\n    float xx3 = xx2 * xx;\n    float yy3 = yy2 * yy;\n    float zz3 = zz2 * zz", "\n    vec2 balloonPosition = vec2( 0.0, 0.0 );\n    float balloonRadius = 0.05;\n    float balloonHeight = 0.05;\n    float balloonWidth = 0.05;\n    float balloonDepth = 0.05;\n    float balloonX = currentRayPosition.x;\n    float balloonY = currentRayPosition.y;\n    float balloonZ = currentRayPosition.z;\n    float balloonDistance = length( vec3( balloonPosition, 0.0 ) );\n    float balloonDistanceToCenter = length( vec3( balloonX, balloonY, balloonZ ) );\n    float balloonDistanceToTop = balloonY - balloonHeight;\n    float balloonDistanceToBottom = balloonY + balloonHeight;\n    float balloonDistanceToLeft = balloonX - balloonWidth;\n    float balloonDistanceToRight = balloonX + balloonWidth;\n    float balloonDistanceToFront = balloonZ - balloonDepth;\n    float balloonDistanceToBack = balloonZ + balloonDepth;\n    float balloonDistanceToCenterToTop = balloonDistanceToCenter - balloonDistanceToTop;\n    float balloonDistanceToCenterToBottom = balloonDistanceToCenter - balloonDistanceToBottom;\n    float balloonDistanceToCenterToLeft = balloonDistanceToCenter - balloonDistanceToLeft;\n    float balloonDistanceToCenterToRight = balloonDistanceToCenter - balloonDistanceToRight;\n    float balloonDistanceToCenterToFront = balloonDistanceToCenter - balloonDistanceToFront;\n    float balloonDistanceToCenterToBack = balloonDistanceToCenter - balloonDistanceToBack;\n    float balloonDistanceToTopToBottom = balloonDistanceToTop - balloonDistanceToBottom;\n    float balloonDistanceToLeftToRight = balloonDistanceToLeft - balloonDistanceToRight;\n    float balloonDistanceToFrontToBack = balloonDistanceToFront - balloonDistanceToBack;\n    float balloonDistanceToCenterToTopToBottom = balloonDistanceToCenterToTop - balloonDistanceToBottom;\n    float balloonDistance", "\n    vec3 rayOrigin = eyePosition;\n    vec3 rayDirectionNormalized = normalize( rayDirection );\n    float t = -1.0;\n    float tmin = 0.0;\n    float tmax = 1000000.0;\n    float tymin = 0.0;\n    float tymax = 1000000.0;\n    float tzmin = 0.0;\n    float tzmax = 1000000.0;\n    float tminx = 0.0;\n    float tmaxx = 1000000.0;\n    float tminy = 0.0;\n    float tmaxy = 1000000.0;\n    float tminz = 0.0;\n    float tmaxz = 1000000.0;\n    float tminxy = 0.0;\n    float tmaxxy = 1000000.0;\n    float tminyz = 0.0;\n    float tmaxyz = 1000000.0;\n    float tminxz = 0.0;\n    float tmaxxz = 1000000.0;\n    float tminxyz = 0.0;\n    float tmaxxyz = 1000000.0;\n    float tminxzy = 0.0;\n    float tmaxxzy = 1000000.0;\n    float tminyzx = 0.0;\n    float tmaxyzx = 1000000.0;\n    float tminyzy = 0.0;\n    float tmaxyzy = 1000000.0;\n    float tminzxy = 0.0;\n    float tmaxzxy = 1000000.0;\n    float tminzxz = 0.0;\n    float tmaxzxz = 1000000.0;\n    float tminzyx = 0.0;\n    float tmaxzyx = 1000000.0;\n    float tminzyz = ", "\n    vec3 lightDirection = normalize( lightPosition - eyePosition );\n    vec3 reflectDirection = reflect( -lightDirection, rayDirection );\n    float specularFactor = pow( max( dot( reflectDirection, eyeDirection ), 0.0 ), 32.0 );\n    vec3 diffuseColor = vec3( 0.0, 0.0, 0.0 );\n    vec3 specularColor = vec3( 0.0, 0.0, 0.0 );\n    if( dot( lightDirection, rayDirection ) > 0.0 ){\n        diffuseColor = vec3( 0.0, 0.0, 0.0 );\n        specularColor = vec3( 0.0, 0.0, 0.0 );\n    }\n    else{\n        diffuseColor = vec3( 0.0, 0.0, 0.0 );\n        specularColor = vec3( 0.0, 0.0, 0.0 );\n    }\n    return vec3( 0.0, 0.0, 0.0 );\n}\n\nvoid main(){\n    vec2 rayHitInfo = vec2( 0.0, 0.0 );\n    vec3 eyePosition = vec3( 0.0, 0.0, 0.0 );\n    vec3 eyeDirection = vec3( 0.0, 0.0, 0.0 );\n    vec3 color = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheWorld = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheLight = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheReflect = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheRefract = vec3( 0.0, 0.0, 0.0 );\n    vec3 colorTheAmbient = vec3( ", "\n    return (float)n / (float)UINT_MAX;\n}\n\nfloat", "\n    vec3 col = vec3(0.0);\n    vec3 pos = ro;\n    vec3 nor = vec3(0.0);\n    vec3 brdf = vec3(0.0);\n    vec3 light = vec3(0.0);\n    vec3 bsdf = vec3(0.0);\n    vec3 f = vec3(0.0);\n    vec3 f0 = vec3(0.0);\n    vec3 f90 = vec3(0.0);\n    vec3 f95 = vec3(0.0);\n    vec3 f100 = vec3(0.0);\n    vec3 f105 = vec3(0.0);\n    vec3 f110 = vec3(0.0);\n    vec3 f115 = vec3(0.0);\n    vec3 f120 = vec3(0.0);\n    vec3 f125 = vec3(0.0);\n    vec3 f130 = vec3(0.0);\n    vec3 f135 = vec3(0.0);\n    vec3 f140 = vec3(0.0);\n    vec3 f145 = vec3(0.0);\n    vec3 f150 = vec3(0.0);\n    vec3 f155 = vec3(0.0);\n    vec3 f160 = vec3(0.0);\n    vec3 f165 = vec3(0.0);\n    vec3 f170 = vec3(0.0);\n    vec3 f175 = vec3(0.0);\n    vec3 f180 = vec3(0.0);\n    vec3 f185 = vec3(0.0);\n    vec3 f190 = vec3(0.0);\n    vec3 f195 = vec3(0.0);", "\n    return fract(sin(dot(p, vec3(127.1, 311.7, 255.4))) * 43758.5453);\n}\n\nfloat", "\n    vec2 uv = pos.xy;\n    uv.y *= -1.0;\n    uv.x += time * 0.005;\n    uv.y += time * 0.005;\n    return uv;\n}\n\nvoid main()\n{\n    vec2 uv = map( pos );\n    vec4 color = texture2D( texture, uv );\n    gl_FragColor = color;\n}\n", "\n    vec3 q = p;\n    vec3 r = p;\n    float t = 0.0;\n    float dt = 1.0;\n    float eps = 0.0001;\n    float eps2 = 0.00001;\n    float f = 1.0;\n    float g = 1.0;\n    float h = 1.0;\n    float i = 1.0;\n    float j = 1.0;\n    float k = 1.0;\n    float l = 1.0;\n    float m = 1.0;\n    float n = 1.0;\n    float o = 1.0;\n    float p = 1.0;\n    float q = 1.0;\n    float r = 1.0;\n    float s = 1.0;\n    float t = 1.0;\n    float u = 1.0;\n    float v = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.0;\n    float d = 1.0;\n    float e = 1.0;\n    float f = 1.0;\n    float g = 1.0;\n    float h = 1.0;\n    float i = 1.0;\n    float j = 1.0;\n    float k = 1.0;\n    float l = 1.0;\n    float m = 1.0;\n    float n = 1.0;\n    float o = 1.0;\n    float p = 1.0;\n    float q = 1.0;\n    float r = 1.0;\n    float s = 1.0;\n    float t = 1.0;\n    float u = 1.0;\n    float v = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.", "\n\tvec4 p = cam * sph;\n\tvec4 q = vec4(p.xyz / p.w, 1.0);\n\tvec4 r = vec4(p.xyz / p.w, 1.0);\n\tvec4 s = vec4(p.xyz / p.w, 1.0);\n\tvec4 t = vec4(p.xyz / p.w, 1.0);\n\tvec4 u = vec4(p.xyz / p.w, 1.0);\n\tvec4 v = vec4(p.xyz / p.w, 1.0);\n\tvec4 w = vec4(p.xyz / p.w, 1.0);\n\tvec4 x = vec4(p.xyz / p.w, 1.0);\n\tvec4 y = vec4(p.xyz / p.w, 1.0);\n\tvec4 z = vec4(p.xyz / p.w, 1.0);\n\tvec4 a = vec4(p.xyz / p.w, 1.0);\n\tvec4 b = vec4(p.xyz / p.w, 1.0);\n\tvec4 c = vec4(p.xyz / p.w, 1.0);\n\tvec4 d = vec4(p.xyz / p.w, 1.0);\n\tvec4 e = vec4(p.xyz / p.w, 1.0);\n\tvec4 f = vec4(p.xyz / p.w, 1.0);\n\tvec4 g = vec4(p.xyz / p.w, 1.0);\n\tvec4 h = vec4(p.xyz / p.w, 1.0);\n\tvec4 i = vec4(p.xyz / p.w, 1.0);\n\tvec4 j = vec4(p.xyz / p.w, 1.0);\n\tvec4 k = vec4(p.xyz / p.w, 1", "\n    vec2 uv = pos.xy;\n    uv.y *= -1.0;\n    uv.x += time * 0.005;\n    uv.y += time * 0.005;\n    return uv;\n}\n\nvoid main()\n{\n    vec2 uv = map( pos );\n    vec4 color = texture2D( texture, uv );\n    gl_FragColor = color;\n}\n", "\n    return x;\n}\n\nvec", "\n    float tmin = 0.001, tmax = 1000.0;\n    vec3  p = ro;\n    vec3  d = rd;\n    vec3  t = vec3( 0.0 );\n    vec3  b = vec3( 0.0 );\n    vec3  n = vec3( 0.0 );\n    float tp, tn, tm, tl, tr, tb, tt;\n    float tmin_ = tmin, tmax_ = tmax;\n    float tmin_n = tmin, tmax_n = tmax;\n    float tmin_b = tmin, tmax_b = tmax;\n    float tmin_t = tmin, tmax_t = tmax;\n    float tmin_l = tmin, tmax_l = tmax;\n    float tmin_r = tmin, tmax_r = tmax;\n    float tmin_b = tmin, tmax_b = tmax;\n    float tmin_t = tmin, tmax_t = tmax;\n    float tmin_l = tmin, tmax_l = tmax;\n    float tmin_r = tmin, tmax_r = tmax;\n    float tmin_b = tmin, tmax_b = tmax;\n    float tmin_t = tmin, tmax_t = tmax;\n    float tmin_l = tmin, tmax_l = tmax;\n    float tmin_r = tmin, tmax_r = tmax;\n    float tmin_b = tmin, tmax_b = tmax;\n    float tmin_t = tmin, tmax_t = tmax;\n    float tmin_l = tmin, tmax_l = tmax;\n    float tmin_r = tmin, tmax_r = tmax;\n    float tmin_b = tmin, tmax_b = tmax;\n    float tmin_t = tmin, tmax_t = tmax;\n    float tmin_l = tmin, tmax_l = t", "\n    float tmin = 0.001, tmax = 1000.0;\n    vec3  p = ro;\n    vec3  d = rd;\n    vec3  t = vec3( 0.0 );\n    vec3  b = vec3( 0.0 );\n    vec3  n = vec3( 0.0 );\n    float tp, tn, tm, tl, tr, tb, tt;\n    float tmin_ = tmin, tmax_ = tmax;\n    float tmin_n = tmin, tmax_n = tmax;\n    float tmin_b = tmin, tmax_b = tmax;\n    float tmin_t = tmin, tmax_t = tmax;\n    float tmin_l = tmin, tmax_l = tmax;\n    float tmin_r = tmin, tmax_r = tmax;\n    float tmin_b = tmin, tmax_b = tmax;\n    float tmin_t = tmin, tmax_t = tmax;\n    float tmin_l = tmin, tmax_l = tmax;\n    float tmin_r = tmin, tmax_r = tmax;\n    float tmin_b = tmin, tmax_b = tmax;\n    float tmin_t = tmin, tmax_t = tmax;\n    float tmin_l = tmin, tmax_l = tmax;\n    float tmin_r = tmin, tmax_r = tmax;\n    float tmin_b = tmin, tmax_b = tmax;\n    float tmin_t = tmin, tmax_t = tmax;\n    float tmin_l = tmin, tmax_l = tmax;\n    float tmin_r = tmin, tmax_r = tmax;\n    float tmin_b = tmin, tmax_b = tmax;\n    float tmin_t = tmin, tmax_t = tmax;\n    float tmin_l = tmin, tmax_l = t", "\n    vec2 d = ddx * ddy;\n    vec2 f = fract( p );\n    vec2 u = f + vec2( -0.5, -0.5 );\n    vec2 w = u.xxy + u.y - 0.5;\n    vec2 s = w.xxy + w.y - 0.5;\n    vec2 a = s.xxy + s.y - 0.5;\n    vec2 t = a.xxy + a.y - 0.5;\n    vec2 g = t.xxy + t.y - 0.5;\n    vec2 r = g.xxy + g.y - 0.5;\n    vec2 b = r.xxy + r.y - 0.5;\n    vec2 q = b.xxy + b.y - 0.5;\n    vec2 h = q.xxy + q.y - 0.5;\n    vec2 j = h.xxy + h.y - 0.5;\n    vec2 k = j.xxy + j.y - 0.5;\n    vec2 l = k.xxy + k.y - 0.5;\n    vec2 m = l.xxy + l.y - 0.5;\n    vec2 n = m.xxy + m.y - 0.5;\n    vec2 o = n.xxy + n.y - 0.5;\n    vec2 p = o.xxy + o.y - 0.5;\n    vec2 c = p.xxy + p.y - 0.5;\n    vec2 e = c.xxy + c.y - 0.5;\n    vec2 f1 = e.xxy + e.y - 0.5;\n    vec2 f2 = f1.xxy + f1.y - 0.5;\n    vec2 f3 = f2.xxy + f2.y - 0.5;\n    vec2 f4 = f3.xxy + f3.", "\n    vec2 uv = p;\n    uv.y = 1.0 - uv.y;\n    return texture( iChannel0, uv ).r;\n}\n\nvoid main()\n{\n    vec2 p = ( gl_FragCoord.xy / iResolution.xy ) * 2.0 - 1.0;\n    float d = length( p );\n    float a = atan( p.y, p.x );\n    float r = ( 1.0 - d ) * 0.5;\n    float t = ( a + PI ) / ( 2.0 * PI );\n    float c = cos( t * PI );\n    float s = sin( t * PI );\n    vec2 uv = vec2( c, s );\n    float tex = gridTexture( uv );\n    float tex2 = gridTexture( uv * 2.0 );\n    float tex3 = gridTexture( uv * 3.0 );\n    float tex4 = gridTexture( uv * 4.0 );\n    float tex5 = gridTexture( uv * 5.0 );\n    float tex6 = gridTexture( uv * 6.0 );\n    float tex7 = gridTexture( uv * 7.0 );\n    float tex8 = gridTexture( uv * 8.0 );\n    float tex9 = gridTexture( uv * 9.0 );\n    float tex10 = gridTexture( uv * 10.0 );\n    float tex11 = gridTexture( uv * 11.0 );\n    float tex12 = gridTexture( uv * 12.0 );\n    float tex13 = gridTexture( uv * 13.0 );\n    float tex14 = gridTexture( uv * 14.0 );\n    float tex15 = gridTexture( uv * 15.0 );\n    float tex16 = gridTexture( uv * 16.0 );\n    float tex17 = gridTexture( uv * 17.0 );\n    float tex18 =", "\n    float tmin = 0.001, tmax = 1000.0;\n    vec3  p;\n    vec3  n;\n    float t;\n    float tmin_sphere = 0.001, tmax_sphere = 1000.0;\n    vec3  p_sphere;\n    float t_sphere;\n    float tmin_plane = 0.001, tmax_plane = 1000.0;\n    vec3  p_plane;\n    float t_plane;\n    float tmin_cylinder = 0.001, tmax_cylinder = 1000.0;\n    vec3  p_cylinder;\n    float t_cylinder;\n    float tmin_cone = 0.001, tmax_cone = 1000.0;\n    vec3  p_cone;\n    float t_cone;\n    float tmin_triangle = 0.001, tmax_triangle = 1000.0;\n    vec3  p_triangle;\n    float t_triangle;\n    float tmin_cube = 0.001, tmax_cube = 1000.0;\n    vec3  p_cube;\n    float t_cube;\n    float tmin_sphere_2 = 0.001, tmax_sphere_2 = 1000.0;\n    vec3  p_sphere_2;\n    float t_sphere_2;\n    float tmin_cube_2 = 0.001, tmax_cube_2 = 1000.0;\n    vec3  p_cube_2;\n    float t_cube_2;\n    float tmin_cube_3 = 0.001, tmax_cube_3 = 1000.0;\n    vec3  p_cube_3;\n    float t_cube_3;\n    float tmin_cube_4 = 0.001, tmax_cube_4 = 1", "\n    vec2 q = p - vec2( 0.5 );\n    float r = length( q );\n    float a = atan( q.y, q.x ) / 3.1415926535897932384626433832795;\n    float b = floor( a + 0.5 );\n    float t = b - a;\n    float x = r * cos( t );\n    float y = r * sin( t );\n    return fract( sin( dot( vec2( x, y ), vec2( 12.9898, 78.233 ) ) ) );\n}\n\nfloat", "\n    vec2 q = vec2( dot(p,vec2(127.1,311.7)), dot(p,vec2(269.5,183.3)) );\n    return fract(sin(dot(q,vec2(41.482,233.405)))*43758.5453);\n}\n\nfloat", "\n    vec2 p = p0;\n    vec2 dp = p1 - p0;\n    vec2 dp2 = p2 - p1;\n    float t = clamp( dot(p, dp2) / dot(dp, dp2), 0.0, 1.0 );\n    return vec4( mix( p0, p1, t ), 0.0, 1.0 );\n}\n\nvec", "\n    vec3 min = vec3( min( p0.x, min( p1.x, p2.x ) ), min( p0.y, min( p1.y, p2.y ) ), min( p0.z, min( p1.z, p2.z ) ) );\n    vec3 max = vec3( max( p0.x, max( p1.x, p2.x ) ), max( p0.y, max( p1.y, p2.y ) ), max( p0.z, max( p1.z, p2.z ) ) );\n    return BezierAABB( min, max );\n}\n\nvec", "\n    vec2 i = vec2( 0.0 );\n    vec2 f = vec2( 1.0 );\n    for ( int j = 0; j < 10; j++ ) {\n        if ( f.x < f.y ) {\n            f = vec2( f.x * 2.0, f.y * 2.0 );\n            i = i + vec2( 0.5 );\n        } else {\n            f = vec2( f.x / 2.0, f.y / 2.0 );\n            i = i + vec2( 0.0, 0.5 );\n        }\n        vec3 p = ro + rd * i.x * f.x + rd * i.y * f.y;\n        if ( length( p - cen ) < rad.x ) {\n            return i;\n        }\n    }\n    return vec2( 0.0 );\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    vec2 q = p - vec2( 0.5 );\n    float r = length( q );\n    float a = atan( q.y, q.x ) / 3.1415926535897932384626433832795;\n    float b = floor( a + 0.5 );\n    float t = b - a;\n    float x = r * cos( t );\n    float y = r * sin( t );\n    return fract( sin( dot( vec2( x, y ), vec2( 12.9898, 78.233 ) ) ) );\n}\n\nfloat", "\n    vec3 ab = pb - pa;\n    float t = dot( ab, rd );\n    if( t < 0.0 ) return vec4( 0.0 );\n    vec3 pao = pa - ro;\n    float t2 = dot( pao, pao );\n    float t3 = dot( ab, ab );\n    float t4 = t2 - t*t;\n    if( t4 > t3 ) return vec4( 0.0 );\n    float t5 = sqrt( t3 - t4 );\n    float h = dot( pao, ab ) / t5;\n    if( h < 0.0 || h > 1.0 ) return vec4( 0.0 );\n    vec3 p = ro + rd * h;\n    vec3 n = normalize( cross( ab, pao ) );\n    float d = length( p - pa ) - ra;\n    if( d < 0.0 ) return vec4( 0.0 );\n    return vec4( n, d );\n}\n\nvec", "\n    vec4 res = vec4(0.0);\n    vec3 ab = pb - pa;\n    float t = dot(ab, rd);\n    if (t < 0.0) return res;\n    vec3 paa = pa - ro;\n    float d = dot(paa, paa);\n    if (d > ra*ra) return res;\n    float b = dot(paa, ab);\n    float c = dot(ab, ab) - ra*ra;\n    float h = b*b - c;\n    if (h < 0.0) return res;\n    float t1 = -b - sqrt(h);\n    float t2 = -b + sqrt(h);\n    if (t1 < 0.0) t1 = -b + sqrt(h);\n    if (t2 < 0.0) t2 = -b + sqrt(h);\n    if (t1 < 0.0) t1 = -b - sqrt(h);\n    if (t2 < 0.0) t2 = -b - sqrt(h);\n    if (t1 < 0.0) return res;\n    if (t2 < 0.0) t2 = t1;\n    if (t1 < 0.0) t1 = t2;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0) return res;\n    if (t1 < 0.0", "\n    vec3 pa = p - a, ba = b - a;\n    float h = clamp(dot(pa, ba) / dot(ba, ba), 0.0, 1.0);\n    return length(pa - ba * h) - r1;\n}\n\nfloat", "\n    return dot( q, ivec2( 127.1, 311.7 ) );\n}\n\nfloat", "\n    vec2 q = p - vec2(floor(p.x), floor(p.y));\n    vec2 r = vec2(fract(p.x), fract(p.y));\n    r = r*r*(3.0-2.0*r);\n    return mix(mix(r.x, r.y, q.x), mix(r.x, r.y, q.y), q.y);\n}\n\nfloat", "\n    return dot(p, vec3(127.1, 311.7, 723.5));\n}\n\nfloat", "\n    return vec2(\n        fract(sin(dot(v, vec2(127.1, 311.7))) * 43758.5453),\n        fract(sin(dot(v, vec2(269.5, 183.3))) * 43758.5453)\n    );\n}\n\nfloat", "\n    vec2 q = p - vec2( 0.5 );\n    float r = length( q );\n    float a = atan( q.y, q.x ) / 3.1415926535897932384626433832795;\n    float b = floor( a + 0.5 );\n    float t = b - a;\n    float x = r * cos( t );\n    float y = r * sin( t );\n    return fract( sin( dot( vec2( x, y ), vec2( 12.9898, 78.233 ) ) ) );\n}\n\nfloat", "\n    vec2 res = vec2( 0.0 );\n    res.x = p.x * 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec2 q = p - vec2( 0.5 );\n    float r = length( q );\n    float a = atan( q.y, q.x ) / 3.1415926535897932384626433832795;\n    float b = floor( a + 0.5 );\n    float t = b - a;\n    float x = r * cos( t );\n    float y = r * sin( t );\n    return fract( sin( dot( vec2( x, y ), vec2( 12.9898, 78.233 ) ) ) );\n}\n\nfloat", "\n    vec2 res = vec2( 0.0 );\n    res.x = p.x * 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec2 q = p - vec2( 0.5 );\n    float r = length( q );\n    float a = atan( q.y, q.x ) / 3.1415926535897932384626433832795;\n    float b = floor( a + 0.5 );\n    float t = b - a;\n    float x = r * cos( t );\n    float y = r * sin( t );\n    return fract( sin( dot( vec2( x, y ), vec2( 12.9898, 78.233 ) ) ) );\n}\n\nfloat", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n    vec2 q = p - vec2( 0.5 );\n    float r = length( q );\n    float a = atan( q.y, q.x ) / 3.1415926535897932384626433832795;\n    float b = floor( a + 0.5 );\n    float t = b - a;\n    float x = r * cos( t );\n    float y = r * sin( t );\n    return fract( sin( dot( vec2( x, y ), vec2( 12.9898, 78.233 ) ) ) );\n}\n\nfloat", "\n    return (x - 32) * 5 / 9;\n}\n\nint", "\n    float tmin = 0.0;\n    float tmax = 10000.0;\n    float t = 0.0;\n    float tmin2 = 0.0;\n    float tmax2 = 10000.0;\n    float t2 = 0.0;\n    float tmin3 = 0.0;\n    float tmax3 = 10000.0;\n    float t3 = 0.0;\n    float tmin4 = 0.0;\n    float tmax4 = 10000.0;\n    float t4 = 0.0;\n    float tmin5 = 0.0;\n    float tmax5 = 10000.0;\n    float t5 = 0.0;\n    float tmin6 = 0.0;\n    float tmax6 = 10000.0;\n    float t6 = 0.0;\n    float tmin7 = 0.0;\n    float tmax7 = 10000.0;\n    float t7 = 0.0;\n    float tmin8 = 0.0;\n    float tmax8 = 10000.0;\n    float t8 = 0.0;\n    float tmin9 = 0.0;\n    float tmax9 = 10000.0;\n    float t9 = 0.0;\n    float tmin10 = 0.0;\n    float tmax10 = 10000.0;\n    float t10 = 0.0;\n    float tmin11 = 0.0;\n    float tmax11 = 10000.0;\n    float t11 = 0.0;\n    float tmin12 = 0.0;\n    float tmax12 = 10000.0;\n    float t12 = 0.0;\n    float tmin13 = 0.0;\n    float tmax13 = 10000.0;\n    float t13 = 0.0;\n    float tmin14 = 0.0;\n    float tmax14 = 10000.0;\n    float t14 = ", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float dmin = 1.0;\n    float dmax = 100.0;\n    float dmin2 = 1.0;\n    float dmax2 = 100.0;\n    float dmin3 = 1.0;\n    float dmax3 = 100.0;\n    float dmin4 = 1.0;\n    float dmax4 = 100.0;\n    float dmin5 = 1.0;\n    float dmax5 = 100.0;\n    float dmin6 = 1.0;\n    float dmax6 = 100.0;\n    float dmin7 = 1.0;\n    float dmax7 = 100.0;\n    float dmin8 = 1.0;\n    float dmax8 = 100.0;\n    float dmin9 = 1.0;\n    float dmax9 = 100.0;\n    float dmin10 = 1.0;\n    float dmax10 = 100.0;\n    float dmin11 = 1.0;\n    float dmax11 = 100.0;\n    float dmin12 = 1.0;\n    float dmax12 = 100.0;\n    float dmin13 = 1.0;\n    float dmax13 = 100.0;\n    float dmin14 = 1.0;\n    float dmax14 = 100.0;\n    float dmin15 = 1.0;\n    float dmax15 = 100.0;\n    float dmin16 = 1.0;\n    float dmax16 = 100.0;\n    float dmin17 = 1.0;\n    float dmax17 = 100.0;\n    float dmin18 = 1.0;\n    float dmax18 = 100.0;\n    float dmin19 = 1.0;\n    float dmax19 = 10", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n    vec2 dp = dpdx * dpdy;\n    vec2 dp2 = dp * dp;\n    float dp2x = dp2.x;\n    float dp2y = dp2.y;\n    float dp2xy = dp2x * dp2y;\n    float dp2x2 = dp2x * dp2x;\n    float dp2y2 = dp2y * dp2y;\n    float dp2xy2 = dp2x2 * dp2y2;\n    float dp2xy3 = dp2xy * 3.0;\n    float dp2xy4 = dp2xy2 * 4.0;\n    float dp2xy5 = dp2xy3 * 5.0;\n    float dp2xy6 = dp2xy4 * 6.0;\n    float dp2xy7 = dp2xy5 * 7.0;\n    float dp2xy8 = dp2xy6 * 8.0;\n    float dp2xy9 = dp2xy7 * 9.0;\n    float dp2xy10 = dp2xy8 * 10.0;\n    float dp2xy11 = dp2xy9 * 11.0;\n    float dp2xy12 = dp2xy10 * 12.0;\n    float dp2xy13 = dp2xy11 * 13.0;\n    float dp2xy14 = dp2xy12 * 14.0;\n    float dp2xy15 = dp2xy13 * 15.0;\n    float dp2xy16 = dp2xy14 * 16.0;\n    float dp2xy17 = dp2xy15 * 17.0;\n    float dp2xy18 = dp2xy16 * 18.0;\n    float dp2xy19 = dp2xy17 * 19.0;\n    float dp2xy20", "\n    vec3 color = vec3(0.0);\n    vec3 ray_dir = normalize(dir);\n    vec3 ray_start = start;\n    vec3 ray_end = ray_start + ray_dir * max_dist;\n    vec3 ray_color = vec3(0.0);\n    vec3 ray_end_color = vec3(0.0);\n    vec3 ray_end_color_scattered = vec3(0.0);\n    vec3 ray_end_color_scattered_scattered = vec3(0.0);\n    vec3 ray_end_color_scattered_scattered_scattered = vec3(0.0);\n    vec3 ray_end_color_scattered_scattered_scattered_scattered = vec3(0.0);\n    vec3 ray_end_color_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n    vec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n    vec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n    vec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n    vec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n    vec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n    vec3 ray_end_color_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered_scattered = vec3(0.0);\n    vec3 ray_end", "\n    vec3 oc = start - sphere_center;\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(oc, dir);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return vec2(-1.0);\n    }\n    float t1 = (-b - sqrt(discriminant)) / (2.0 * a);\n    float t2 = (-b + sqrt(discriminant)) / (2.0 * a);\n    if (t1 < 0.0) {\n        t1 = t2;\n    }\n    if (t2 < 0.0) {\n        return vec2(-1.0);\n    }\n    return vec2(t1, t2);\n}\n\nvec", "\n    vec3 light_col = vec3(1.0);\n    vec3 light_dir_norm = normalize(light_dir);\n    float diffuse_factor = dot(surface_normal, light_dir_norm);\n    if (diffuse_factor < 0.0) {\n        diffuse_factor = 0.0;\n    }\n    vec3 diffuse_col = diffuse_factor * light_col;\n    vec3 ambient_col = vec3(0.1);\n    vec3 ambient_light = ambient_col * light_col;\n    vec3 light_col_final = ambient_light + diffuse_col;\n    return light_col_final;\n}\n\nvec", "\n    vec4 color = vec4(0.0);\n    vec3 light_color = vec3(1.0);\n    vec3 light_pos = vec3(0.0);\n    vec3 light_dir_normalized = normalize(light_dir);\n    vec3 light_pos_normalized = normalize(light_pos);\n    vec3 light_color_normalized = normalize(light_color);\n    vec3 view_dir_normalized = normalize(dir);\n    vec3 view_dir_normalized_inverse = normalize(-dir);\n    vec3 view_pos_normalized = normalize(pos);\n    vec3 view_pos_normalized_inverse = normalize(-pos);\n    vec3 view_dir_normalized_inverse_inverse = normalize(-view_dir_normalized);\n    vec3 view_pos_normalized_inverse_inverse = normalize(-view_pos_normalized);\n    vec3 view_dir_normalized_inverse_inverse_inverse = normalize(-view_dir_normalized_inverse);\n    vec3 view_pos_normalized_inverse_inverse_inverse = normalize(-view_pos_normalized_inverse);\n    vec3 view_dir_normalized_inverse_inverse_inverse_inverse = normalize(-view_dir_normalized_inverse_inverse);\n    vec3 view_pos_normalized_inverse_inverse_inverse_inverse = normalize(-view_pos_normalized_inverse_inverse);\n    vec3 view_dir_normalized_inverse_inverse_inverse_inverse_inverse = normalize(-view_dir_normalized_inverse_inverse_inverse);\n    vec3 view_pos_normalized_inverse_inverse_inverse_inverse_inverse = normalize(-view_pos_normalized_inverse_inverse_inverse);\n    vec3 view_dir_normalized_inverse_inverse_inverse_inverse_inverse_inverse = normalize(-view_dir", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    float t = 0.0;\n    for (int i = 0; i < MAX_BOUNCES; i++) {\n        vec3 intersection = ray_origin + t * ray_direction;\n        float distance = length(intersection - ray_origin);\n        if (distance < EPSILON) {\n            return intersection;\n        }\n        t += distance;\n    }\n    return vec3(0.0);\n}\n\nvec", "\n    return fract(sin(x)*43758.5453);\n}\n\nfloat", "\n    vec3 color = vec3( 0.0 );\n    vec3 pos = p;\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float d = map( pos );\n        t += d;\n        pos = p + d * normal( p );\n        if ( t > tmax )\n        {\n            break;\n        }\n    }\n    color = vec3( 0.5 ) + vec3( 0.5 ) * cos( 2.0 * 3.1415926 * t / tmax );\n    return color;\n}\n\nvoid main()\n{\n    vec3 color = vec3( 0.0 );\n    vec3 p = vec3( 0.0 );\n    float t = 0.0;\n    float tmax = 100.0;\n    for ( int i = 0; i < 10; i++ )\n    {\n        float d = map( p );\n        t += d;\n        p = p + d * normal( p );\n        if ( t > tmax )\n        {\n            break;\n        }\n    }\n    color = vec3( 0.5 ) + vec3( 0.5 ) * cos( 2.0 * 3.1415926 * t / tmax );\n    gl_FragColor = vec4( color, 1.0 );\n}\n", "\n    vec3 col = vec3(0.0);\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float dmin = 1.0;\n    float dmax = 100.0;\n    float dmin2 = 1.0;\n    float dmax2 = 100.0;\n    float dmin3 = 1.0;\n    float dmax3 = 100.0;\n    float dmin4 = 1.0;\n    float dmax4 = 100.0;\n    float dmin5 = 1.0;\n    float dmax5 = 100.0;\n    float dmin6 = 1.0;\n    float dmax6 = 100.0;\n    float dmin7 = 1.0;\n    float dmax7 = 100.0;\n    float dmin8 = 1.0;\n    float dmax8 = 100.0;\n    float dmin9 = 1.0;\n    float dmax9 = 100.0;\n    float dmin10 = 1.0;\n    float dmax10 = 100.0;\n    float dmin11 = 1.0;\n    float dmax11 = 100.0;\n    float dmin12 = 1.0;\n    float dmax12 = 100.0;\n    float dmin13 = 1.0;\n    float dmax13 = 100.0;\n    float dmin14 = 1.0;\n    float dmax14 = 100.0;\n    float dmin15 = 1.0;\n    float dmax15 = 100.0;\n    float dmin16 = 1.0;\n    float dmax16 = 100.0;\n    float dmin17 = 1.0;\n    float dmax17 = 100.0;\n    float dmin18 = 1.0;\n    float dmax18 = 100.0;\n    float dmin19 = 1.0;\n    float dmax19 = 10", "\n    float res = 1.0;\n    for (int i = 0; i < 5; i++)\n    {\n        float t = calcSoftShadow(ro, rd, tmin, tmax, w);\n        res *= t;\n        tmax += t;\n    }\n    return res;\n}\n\nfloat", "\n    vec4 p = vec4( pos, 1.0 );\n    p.y += sin( time * 0.5 ) * 0.2;\n    p.x += sin( time * 0.3 ) * 0.1;\n    return p;\n}\n\nvec", "\n    float d = length(p - vec2(0.5, 0.5)) - r;\n    return max(d, 0.0);\n}\n\nfloat", "\n    vec3 oc = r.origin - center;\n    float a = dot(r.direction, r.direction);\n    float b = 2.0 * dot(oc, r.direction);\n    float c = dot(oc, oc) - radius * radius;\n    float discriminant = b * b - 4.0 * a * c;\n    if (discriminant < 0.0) {\n        return -1.0;\n    }\n    return (-b - sqrt(discriminant)) / (2.0 * a);\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    float sd = sdHexagram(p, r, d);\n    float sd2 = sdHexagram(p, r, d + 0.001);\n    return sd - sd2;\n}\n\nfloat", "\n    return vec3(\n        p.x + q.x,\n        p.y + q.y,\n        p.z + q.z\n    );\n}\n\nvec", "\n    vec3 q = p;\n    vec3 r = p;\n    float t = 0.0;\n    float dt = 1.0;\n    float eps = 0.0001;\n    float eps2 = 0.00001;\n    float f = 1.0;\n    float g = 1.0;\n    float h = 1.0;\n    float i = 1.0;\n    float j = 1.0;\n    float k = 1.0;\n    float l = 1.0;\n    float m = 1.0;\n    float n = 1.0;\n    float o = 1.0;\n    float p = 1.0;\n    float q = 1.0;\n    float r = 1.0;\n    float s = 1.0;\n    float t = 1.0;\n    float u = 1.0;\n    float v = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.0;\n    float d = 1.0;\n    float e = 1.0;\n    float f = 1.0;\n    float g = 1.0;\n    float h = 1.0;\n    float i = 1.0;\n    float j = 1.0;\n    float k = 1.0;\n    float l = 1.0;\n    float m = 1.0;\n    float n = 1.0;\n    float o = 1.0;\n    float p = 1.0;\n    float q = 1.0;\n    float r = 1.0;\n    float s = 1.0;\n    float t = 1.0;\n    float u = 1.0;\n    float v = 1.0;\n    float w = 1.0;\n    float x = 1.0;\n    float y = 1.0;\n    float z = 1.0;\n    float a = 1.0;\n    float b = 1.0;\n    float c = 1.", "\n    vec2 res = vec2( 0.0 );\n    res.x = p.x * 0.000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec2 q = p - vec2( 0.5 );\n    float r = length( q );\n    float a = atan( q.y, q.x ) / 3.1415926535897932384626433832795;\n    float b = floor( a + 0.5 );\n    float t = b - a;\n    float x = r * cos( t );\n    float y = r * sin( t );\n    return fract( sin( dot( vec2( x, y ), vec2( 12.9898, 78.233 ) ) ) );\n}\n\nfloat", "\n    vec3 min = vec3( min( p0.x, min( p1.x, p2.x ) ), min( p0.y, min( p1.y, p2.y ) ), min( p0.z, min( p1.z, p2.z ) ) );\n    vec3 max = vec3( max( p0.x, max( p1.x, p2.x ) ), max( p0.y, max( p1.y, p2.y ) ), max( p0.z, max( p1.z, p2.z ) ) );\n    return BezierAABB( min, max );\n}\n\nvec", "\n    vec2 i = vec2( 0.0 );\n    vec2 f = vec2( 1.0 );\n    for ( int j = 0; j < 10; j++ ) {\n        if ( f.x < f.y ) {\n            f = vec2( f.x * 2.0, f.y * 2.0 );\n            i = i + vec2( 0.5 );\n        } else {\n            f = vec2( f.x / 2.0, f.y / 2.0 );\n            i = i + vec2( 0.0, 0.5 );\n        }\n        vec3 p = ro + rd * i.x * f.x + rd * i.y * f.y;\n        if ( length( p - cen ) < rad.x ) {\n            return i;\n        }\n    }\n    return vec2( 0.0 );\n}\n\nvec", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n    vec2 dp = dpdx * dpdy;\n    vec2 dp2 = dp * dp;\n    float dp2x = dp2.x;\n    float dp2y = dp2.y;\n    float dp2xy = dp2x * dp2y;\n    float dp2x2 = dp2x * dp2x;\n    float dp2y2 = dp2y * dp2y;\n    float dp2xy2 = dp2x2 * dp2y2;\n    float dp2xy3 = dp2xy * 3.0;\n    float dp2xy4 = dp2xy2 * 4.0;\n    float dp2xy5 = dp2xy3 * 5.0;\n    float dp2xy6 = dp2xy4 * 6.0;\n    float dp2xy7 = dp2xy5 * 7.0;\n    float dp2xy8 = dp2xy6 * 8.0;\n    float dp2xy9 = dp2xy7 * 9.0;\n    float dp2xy10 = dp2xy8 * 10.0;\n    float dp2xy11 = dp2xy9 * 11.0;\n    float dp2xy12 = dp2xy10 * 12.0;\n    float dp2xy13 = dp2xy11 * 13.0;\n    float dp2xy14 = dp2xy12 * 14.0;\n    float dp2xy15 = dp2xy13 * 15.0;\n    float dp2xy16 = dp2xy14 * 16.0;\n    float dp2xy17 = dp2xy15 * 17.0;\n    float dp2xy18 = dp2xy16 * 18.0;\n    float dp2xy19 = dp2xy17 * 19.0;\n    float dp2xy20", "\n    vec3 color = vec3(0.0);\n    vec2 pos = p;\n    float dist = 1.0;\n    float t = 0.0;\n    for ( int i = 0; i < 100; i++ )\n    {\n        vec2 p = pos;\n        p.x += sin(p.y*10.0+time)*0.1;\n        p.y += cos(p.x*10.0+time)*0.1;\n        vec2 q = p;\n        q.x += sin(q.y*10.0+time)*0.1;\n        q.y += cos(q.x*10.0+time)*0.1;\n        vec2 r = p;\n        r.x += sin(r.y*10.0+time)*0.1;\n        r.y += cos(r.x*10.0+time)*0.1;\n        vec2 s = p;\n        s.x += sin(s.y*10.0+time)*0.1;\n        s.y += cos(s.x*10.0+time)*0.1;\n        vec2 t = p;\n        t.x += sin(t.y*10.0+time)*0.1;\n        t.y += cos(t.x*10.0+time)*0.1;\n        vec2 u = p;\n        u.x += sin(u.y*10.0+time)*0.1;\n        u.y += cos(u.x*10.0+time)*0.1;\n        vec2 v = p;\n        v.x += sin(v.y*10.0+time)*0.1;\n        v.y += cos(v.x*10.0+time)*0.1;\n        vec2 w = p;\n        w.x += sin(w.y*10.0+time)*0.1;\n        w.y += cos(w.x*10.0+time)*0.1;\n        vec2 x = p;", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    return fract(sin(p)*43758.5453123);\n}\n\nfloat", "\n    return dot(p, vec3(127.1, 311.7, 723.5));\n}\n\nfloat", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n    vec3 col = vec3( 0.0 );\n    vec3 p = ro;\n    float t = 0.0;\n    float d = 0.0;\n    float dp = 0.0;\n    float dd = 0.0;\n    float ddd = 0.0;\n    float dddd = 0.0;\n    float ddddd = 0.0;\n    float dddddd = 0.0;\n    float ddddddd = 0.0;\n    float dddddddd = 0.0;\n    float ddddddddd = 0.0;\n    float dddddddddd = 0.0;\n    float ddddddddddd = 0.0;\n    float dddddddddddd = 0.0;\n    float ddddddddddddd = 0.0;\n    float dddddddddddddd = 0.0;\n    float ddddddddddddddd = 0.0;\n    float dddddddddddddddd = 0.0;\n    float ddddddddddddddddd = 0.0;\n    float dddddddddddddddddd = 0.0;\n    float ddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddddd = 0.0;\n    float dddddddddddddddddddddddddddd = 0.0;\n    float ddddddddddddddddddddddddddddd = 0", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n    vec2 dp = dpdx * dpdy;\n    vec2 dp2 = dp * dp;\n    float dp2x = dp2.x;\n    float dp2y = dp2.y;\n    float dp2xy = dp2x * dp2y;\n    float dp2x2 = dp2x * dp2x;\n    float dp2y2 = dp2y * dp2y;\n    float dp2xy2 = dp2x2 * dp2y2;\n    float dp2xy3 = dp2xy * 3.0;\n    float dp2xy4 = dp2xy2 * 4.0;\n    float dp2xy5 = dp2xy3 * 5.0;\n    float dp2xy6 = dp2xy4 * 6.0;\n    float dp2xy7 = dp2xy5 * 7.0;\n    float dp2xy8 = dp2xy6 * 8.0;\n    float dp2xy9 = dp2xy7 * 9.0;\n    float dp2xy10 = dp2xy8 * 10.0;\n    float dp2xy11 = dp2xy9 * 11.0;\n    float dp2xy12 = dp2xy10 * 12.0;\n    float dp2xy13 = dp2xy11 * 13.0;\n    float dp2xy14 = dp2xy12 * 14.0;\n    float dp2xy15 = dp2xy13 * 15.0;\n    float dp2xy16 = dp2xy14 * 16.0;\n    float dp2xy17 = dp2xy15 * 17.0;\n    float dp2xy18 = dp2xy16 * 18.0;\n    float dp2xy19 = dp2xy17 * 19.0;\n    float dp2xy20", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.75) * 0.5 + 0.5;\n    float h = cos(t * 0.75) * 0.5 + 0.5;\n    float i = sin(t * 1.25) * 0.5 + 0.5;\n    float j = cos(t * 1.25) * 0.5 + 0.5;\n    float k = sin(t * 1.75) * 0.5 + 0.5;\n    float l = cos(t * 1.75) * 0.5 + 0.5;\n    float m = sin(t * 2.25) * 0.5 + 0.5;\n    float n = cos(t * 2.25) * 0.5 + 0.5;\n    float o = sin(t * 2.75) * 0.5 + 0.5;\n    float p = cos(t * 2.75) * 0.5 + 0.5;\n    float q = sin(t * 3.25) * 0.5 + 0.5;\n    float r = cos(t * 3.25) * 0.5 + 0.5;\n    float s =", "\n    return opExtrusion(p, d, h, 0.0);\n}\n\nfloat", "\n    vec2 q = vec2( dot(p, ab), p.x );\n    return vec2( length(q) - ab.y, dot(q, q) - ab.x );\n}\n\nfloat", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    float h = val * 6.0;\n    float s = 1.0;\n    float v = 1.0;\n    float r = 0.0;\n    float g = 0.0;\n    float b = 0.0;\n\n    if (h < 1.0) {\n        r = v;\n        g = h;\n    } else if (h < 2.0) {\n        r = v;\n        g = v;\n        b = h - 1.0;\n    } else if (h < 3.0) {\n        r = h - 2.0;\n        g = v;\n    } else if (h < 4.0) {\n        r = v;\n        g = v;\n        b = h - 3.0;\n    } else if (h < 5.0) {\n        r = v;\n        g = h - 4.0;\n        b = v;\n    } else {\n        r = h - 5.0;\n        g = v;\n        b = v;\n    }\n\n    r = r * s;\n    g = g * s;\n    b = b * s;\n\n    return vec3(r, g, b);\n}\n\nvoid main() {\n    vec3 color = vec3(0.0);\n    vec3 rainbowColor = vec3(0.0);\n    float val = gl_FragCoord.x / float(width);\n    float val2 = gl_FragCoord.y / float(height);\n    float val3 = gl_FragCoord.z / float(width * height);\n    float val4 = gl_FragCoord.w / float(width * height);\n    float val5 = gl_FragCoord.x / float(width * height);\n    float val6 = gl_FragCoord.y / float(width * height);\n    float val7 = gl_FragCoord.z / float(width * height);\n    float val8 = gl_FragCoord.w / float(width * height);\n    float val9 = gl_FragCoord.x / float(width * height", "\n    vec2 q = p - ab;\n    return length( q - vec2( dot( q, ab ), 0.0 ) ) - length( ab );\n}\n\nfloat", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n    vec2 dp = dpdx * dpdy;\n    vec2 dp2 = dp * dp;\n    float dp2x = dp2.x;\n    float dp2y = dp2.y;\n    float dp2xy = dp2x * dp2y;\n    float dp2x2 = dp2x * dp2x;\n    float dp2y2 = dp2y * dp2y;\n    float dp2xy2 = dp2x2 * dp2y2;\n    float dp2xy3 = dp2xy * 3.0;\n    float dp2xy4 = dp2xy2 * 4.0;\n    float dp2xy5 = dp2xy3 * 5.0;\n    float dp2xy6 = dp2xy4 * 6.0;\n    float dp2xy7 = dp2xy5 * 7.0;\n    float dp2xy8 = dp2xy6 * 8.0;\n    float dp2xy9 = dp2xy7 * 9.0;\n    float dp2xy10 = dp2xy8 * 10.0;\n    float dp2xy11 = dp2xy9 * 11.0;\n    float dp2xy12 = dp2xy10 * 12.0;\n    float dp2xy13 = dp2xy11 * 13.0;\n    float dp2xy14 = dp2xy12 * 14.0;\n    float dp2xy15 = dp2xy13 * 15.0;\n    float dp2xy16 = dp2xy14 * 16.0;\n    float dp2xy17 = dp2xy15 * 17.0;\n    float dp2xy18 = dp2xy16 * 18.0;\n    float dp2xy19 = dp2xy17 * 19.0;\n    float dp2xy20", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n    vec2 dp = dpdx * dpdy;\n    vec2 dp2 = dp * dp;\n    float dp2x = dp2.x;\n    float dp2y = dp2.y;\n    float dp2xy = dp2x * dp2y;\n    float dp2x2 = dp2x * dp2x;\n    float dp2y2 = dp2y * dp2y;\n    float dp2xy2 = dp2x2 * dp2y2;\n    float dp2xy3 = dp2xy * 3.0;\n    float dp2xy4 = dp2xy2 * 4.0;\n    float dp2xy5 = dp2xy3 * 5.0;\n    float dp2xy6 = dp2xy4 * 6.0;\n    float dp2xy7 = dp2xy5 * 7.0;\n    float dp2xy8 = dp2xy6 * 8.0;\n    float dp2xy9 = dp2xy7 * 9.0;\n    float dp2xy10 = dp2xy8 * 10.0;\n    float dp2xy11 = dp2xy9 * 11.0;\n    float dp2xy12 = dp2xy10 * 12.0;\n    float dp2xy13 = dp2xy11 * 13.0;\n    float dp2xy14 = dp2xy12 * 14.0;\n    float dp2xy15 = dp2xy13 * 15.0;\n    float dp2xy16 = dp2xy14 * 16.0;\n    float dp2xy17 = dp2xy15 * 17.0;\n    float dp2xy18 = dp2xy16 * 18.0;\n    float dp2xy19 = dp2xy17 * 19.0;\n    float dp2xy20", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    uint r = idx + seed;\n    r ^= r >> 11;\n    r ^= r << 7;\n    r ^= r >> 15;\n    return r % count;\n}\n\nuint hash(uint idx, uint count, uint seed) {\n    uint r = idx + seed;\n    r ^= r >> 16;\n    r ^= r << 11;\n    r ^= r >> 14;\n    return r % count;\n}\n\nuint hash2(uint idx, uint count, uint seed) {\n    uint r = idx + seed;\n    r ^= r >> 16;\n    r ^= r << 11;\n    r ^= r >> 14;\n    r ^= r << 15;\n    return r % count;\n}\n\nuint hash3(uint idx, uint count, uint seed) {\n    uint r = idx + seed;\n    r ^= r >> 16;\n    r ^= r << 11;\n    r ^= r >> 14;\n    r ^= r << 15;\n    r ^= r << 10;\n    return r % count;\n}\n\nuint hash4(uint idx, uint count, uint seed) {\n    uint r = idx + seed;\n    r ^= r >> 16;\n    r ^= r << 11;\n    r ^= r >> 14;\n    r ^= r << 15;\n    r ^= r << 10;\n    r ^= r >> 6;\n    return r % count;\n}\n\nuint hash5(uint idx, uint count, uint seed) {\n    uint r = idx + seed;\n    r ^= r >> 16;\n    r ^= r << 11;\n    r ^= r >> 14;\n    r ^= r << 15;\n    r ^= r << 10;\n    r ^= r >> 6;\n    r ^= r << 3;\n    return r % count;\n}\n\nuint hash6(uint idx, uint count, uint seed) {\n    uint r = idx + seed;\n    r ^= r >> 16", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    vec4 p = vec4(pIn, 1.0);\n    vec4 q = vec4(p.x, p.y, p.z, 1.0);\n    vec4 r = vec4(p.x, p.y, p.z, 1.0);\n    vec4 s = vec4(p.x, p.y, p.z, 1.0);\n    vec4 t = vec4(p.x, p.y, p.z, 1.0);\n    vec4 u = vec4(p.x, p.y, p.z, 1.0);\n    vec4 v = vec4(p.x, p.y, p.z, 1.0);\n    vec4 w = vec4(p.x, p.y, p.z, 1.0);\n    vec4 x = vec4(p.x, p.y, p.z, 1.0);\n    vec4 y = vec4(p.x, p.y, p.z, 1.0);\n    vec4 z = vec4(p.x, p.y, p.z, 1.0);\n    vec4 w1 = vec4(p.x, p.y, p.z, 1.0);\n    vec4 w2 = vec4(p.x, p.y, p.z, 1.0);\n    vec4 w3 = vec4(p.x, p.y, p.z, 1.0);\n    vec4 w4 = vec4(p.x, p.y, p.z, 1.0);\n    vec4 w5 = vec4(p.x, p.y, p.z, 1.0);\n    vec4 w6 = vec4(p.x, p.y, p.z, 1.0);\n    vec4 w7 = vec4(p.x, p.y, p.z, 1.0);\n    vec4 w8 = vec", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    vec2 e = p - d;\n    vec2 e12 = e1 - e2;\n    vec2 e34 = e3 - e4;\n    vec2 e13 = e1 - e3;\n    vec2 e24 = e2 - e4;\n    vec2 e14 = e1 - e4;\n    vec2 e123 = e12 - e34;\n    vec2 e234 = e23 - e4;\n    vec2 e1234 = e123 - e4;\n    vec2 e12345 = e1234 - e5;\n    vec2 e123456 = e12345 - e6;\n    vec2 e1234567 = e123456 - e7;\n    vec2 e12345678 = e1234567 - e8;\n    vec2 e123456789 = e12345678 - e9;\n    vec2 e1234567890 = e123456789 - e10;\n    vec2 e12345678901 = e1234567890 - e11;\n    vec2 e123456789012 = e12345678901 - e12;\n    vec2 e1234567890123 = e123456789012 - e13;\n    vec2 e12345678901234 = e1234567890123 - e14;\n    vec2 e123456789012345 = e12345678901234 - e15;\n    vec2 e1234567890123456 = e1", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    vec2 pa = p - va;\n    vec2 pb = p - vb;\n    float h = length( pa );\n    float a = dot( pa, pa ) - rb*rb;\n    float b = dot( pb, pb ) - rb*rb;\n    float c = dot( pa, pb );\n    float d = (rb*rb)*(a+b-c);\n    float s = max( 0.0, min( a, b ) - d );\n    float t = max( 0.0, min( b, a ) - d );\n    return sqrt( max( 0.0, min( s*s + t*t, h*h ) ) );\n}\n\nfloat", "\n    return length(p) - r;\n}\n\nfloat", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = clamp( dot( ap, ab ) / dot( ab, ab ), 0.0, 1.0 );\n    return sdSegment( p, a, b ) - w1 * ( 1.0 - t ) - w2 * t;\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.1;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t * 0.5) * 0.5 + 0.5;\n    float d = cos(t * 0.5) * 0.5 + 0.5;\n    float e = sin(t * 0.25) * 0.5 + 0.5;\n    float f = cos(t * 0.25) * 0.5 + 0.5;\n    float g = sin(t * 0.125) * 0.5 + 0.5;\n    float h = cos(t * 0.125) * 0.5 + 0.5;\n    float i = sin(t * 0.0625) * 0.5 + 0.5;\n    float j = cos(t * 0.0625) * 0.5 + 0.5;\n    float k = sin(t * 0.03125) * 0.5 + 0.5;\n    float l = cos(t * 0.03125) * 0.5 + 0.5;\n    float m = sin(t * 0.015625) * 0.5 + 0.5;\n    float n = cos(t * 0.015625) * 0.5 + 0.5;\n    float o = sin(t * 0.0078125) * 0.5 + 0.5;\n    float p = cos(t * 0.0078125) * 0.5 + 0.5;\n    float q = sin(t * 0.00390625) * 0.", "\n    return (expf(x) - expf(-x)) / (expf(x) + expf(-x));\n}\n\nfloat", "\n    vec2 uv = q;\n    uv.y = 1.0 - uv.y;\n    vec3 c = texture2D(u_texture, uv).rgb;\n    return mix(col, c, 0.2);\n}\n\nvoid main() {\n    vec2 q = gl_FragCoord.xy / u_resolution.xy;\n    vec3 col = vec3(0.0);\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= u_resolution.x / u_resolution.y;\n    float d = length(p);\n    if (d < 0.001) {\n        col = vec3(1.0);\n    } else {\n        col = vec3(0.0);\n    }\n    col = postProcess(col, q);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec2 uv = q;\n    uv.y = 1.0 - uv.y;\n    vec3 c = texture2D(u_texture, uv).rgb;\n    return mix(col, c, 0.2);\n}\n\nvoid main() {\n    vec2 q = gl_FragCoord.xy / u_resolution.xy;\n    vec3 col = vec3(0.0);\n    vec2 p = -1.0 + 2.0 * q;\n    p.x *= u_resolution.x / u_resolution.y;\n    float d = length(p);\n    if (d < 0.001) {\n        col = vec3(1.0);\n    } else {\n        col = vec3(0.0);\n    }\n    col = postProcess(col, q);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    return ivec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y );\n}\n\nivec2 grad( ivec3 z ) {\n    return ivec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y ) + ivec2( z.z * z.z - z.w * z.w, 2.0 * z.z * z.w );\n}\n\nivec2 grad( ivec4 z ) {\n    return ivec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y ) + ivec2( z.z * z.z - z.w * z.w, 2.0 * z.z * z.w ) + ivec2( z.t * z.t - z.u * z.u, 2.0 * z.t * z.u );\n}\n\nivec3 grad( ivec2 z ) {\n    return ivec3( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y, 0.0 );\n}\n\nivec3 grad( ivec3 z ) {\n    return ivec3( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y, 0.0 ) + ivec3( z.z * z.z - z.w * z.w, 2.0 * z.z * z.w, 0.0 );\n}\n\nivec3 grad( ivec4 z ) {\n    return ivec3( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y, 0.0 ) + ivec3( z.z * z.z - z.w * z.w, 2.0 * z.z * z.w, 0.0 ) + ivec3( z.t * z.t - z.u * z.u, 2.0 *", "\n    return vec2(texture(heightmap_tex, p).r, 0.0);\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.5;\n    float a = atan(p.y, p.x) + t;\n    float r = length(p);\n    float d = (r - 0.5) * 0.5;\n    float c = cos(a);\n    float s = sin(a);\n    float x = p.x * c - p.y * s;\n    float y = p.x * s + p.y * c;\n    float z = d;\n    vec3 v = vec3(x, y, z);\n    vec3 n = normalize(v);\n    vec3 l = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 r = reflect(l, n);\n    float sd = sdSphere(v, 0.5);\n    float sd2 = sdSphere(v, 0.1);\n    float sd3 = sdSphere(v, 0.05);\n    float sd4 = sdSphere(v, 0.01);\n    float sd5 = sdSphere(v, 0.005);\n    float sd6 = sdSphere(v, 0.001);\n    float sd7 = sdSphere(v, 0.0005);\n    float sd8 = sdSphere(v, 0.0001);\n    float sd9 = sdSphere(v, 0.00005);\n    float sd10 = sdSphere(v, 0.00001);\n    float sd11 = sdSphere(v, 0.000005);\n    float sd12 = sdSphere(v, 0.000001);\n    float sd1", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n    vec2 dp = dpdx * dpdy;\n    vec2 dp2 = dp * dp;\n    float dp2x = dp2.x;\n    float dp2y = dp2.y;\n    float dp2xy = dp2x * dp2y;\n    float dp2x2 = dp2x * dp2x;\n    float dp2y2 = dp2y * dp2y;\n    float dp2xy2 = dp2x2 * dp2y2;\n    float dp2xy3 = dp2xy * 3.0;\n    float dp2xy4 = dp2xy2 * 4.0;\n    float dp2xy5 = dp2xy3 * 5.0;\n    float dp2xy6 = dp2xy4 * 6.0;\n    float dp2xy7 = dp2xy5 * 7.0;\n    float dp2xy8 = dp2xy6 * 8.0;\n    float dp2xy9 = dp2xy7 * 9.0;\n    float dp2xy10 = dp2xy8 * 10.0;\n    float dp2xy11 = dp2xy9 * 11.0;\n    float dp2xy12 = dp2xy10 * 12.0;\n    float dp2xy13 = dp2xy11 * 13.0;\n    float dp2xy14 = dp2xy12 * 14.0;\n    float dp2xy15 = dp2xy13 * 15.0;\n    float dp2xy16 = dp2xy14 * 16.0;\n    float dp2xy17 = dp2xy15 * 17.0;\n    float dp2xy18 = dp2xy16 * 18.0;\n    float dp2xy19 = dp2xy17 * 19.0;\n    float dp2xy20", "\n    return ivec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y );\n}\n\nivec2 grad( ivec3 z ) {\n    return ivec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y ) + ivec2( z.z * z.z - z.w * z.w, 2.0 * z.z * z.w );\n}\n\nivec2 grad( ivec4 z ) {\n    return ivec2( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y ) + ivec2( z.z * z.z - z.w * z.w, 2.0 * z.z * z.w ) + ivec2( z.t * z.t - z.u * z.u, 2.0 * z.t * z.u );\n}\n\nivec3 grad( ivec2 z ) {\n    return ivec3( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y, 0.0 );\n}\n\nivec3 grad( ivec3 z ) {\n    return ivec3( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y, 0.0 ) + ivec3( z.z * z.z - z.w * z.w, 2.0 * z.z * z.w, 0.0 );\n}\n\nivec3 grad( ivec4 z ) {\n    return ivec3( z.x * z.x - z.y * z.y, 2.0 * z.x * z.y, 0.0 ) + ivec3( z.z * z.z - z.w * z.w, 2.0 * z.z * z.w, 0.0 ) + ivec3( z.t * z.t - z.u * z.u, 2.0 *", "\n    return vec2(texture(heightmap_tex, p).r, 0.0);\n}\n\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec2 p = -1.0 + 2.0 * uv;\n    p.x *= iResolution.x / iResolution.y;\n    float t = iTime * 0.5;\n    float a = atan(p.y, p.x) + t;\n    float r = length(p);\n    float d = (r - 0.5) * 0.5;\n    float c = cos(a);\n    float s = sin(a);\n    float x = p.x * c - p.y * s;\n    float y = p.x * s + p.y * c;\n    float z = d;\n    vec3 v = vec3(x, y, z);\n    vec3 n = normalize(v);\n    vec3 l = normalize(vec3(0.0, 0.0, 1.0));\n    vec3 r = reflect(l, n);\n    float sd = sdSphere(v, 0.5);\n    float sd2 = sdSphere(v, 0.1);\n    float sd3 = sdSphere(v, 0.05);\n    float sd4 = sdSphere(v, 0.01);\n    float sd5 = sdSphere(v, 0.005);\n    float sd6 = sdSphere(v, 0.001);\n    float sd7 = sdSphere(v, 0.0005);\n    float sd8 = sdSphere(v, 0.0001);\n    float sd9 = sdSphere(v, 0.00005);\n    float sd10 = sdSphere(v, 0.00001);\n    float sd11 = sdSphere(v, 0.000005);\n    float sd12 = sdSphere(v, 0.000001);\n    float sd1", "\n    float t = mint;\n    float res = 1.0;\n    for( int i = 0; i < 5; i++ )\n    {\n        float h = map( ro + rd * t, mint, tmax );\n        res = min( res, 32.0 * h / t );\n        t += h;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n    vec2 dp = dpdx * dpdy;\n    vec2 dp2 = dp * dp;\n    float dp2x = dp2.x;\n    float dp2y = dp2.y;\n    float dp2xy = dp2x * dp2y;\n    float dp2x2 = dp2x * dp2x;\n    float dp2y2 = dp2y * dp2y;\n    float dp2xy2 = dp2x2 * dp2y2;\n    float dp2xy3 = dp2xy * 3.0;\n    float dp2xy4 = dp2xy2 * 4.0;\n    float dp2xy5 = dp2xy3 * 5.0;\n    float dp2xy6 = dp2xy4 * 6.0;\n    float dp2xy7 = dp2xy5 * 7.0;\n    float dp2xy8 = dp2xy6 * 8.0;\n    float dp2xy9 = dp2xy7 * 9.0;\n    float dp2xy10 = dp2xy8 * 10.0;\n    float dp2xy11 = dp2xy9 * 11.0;\n    float dp2xy12 = dp2xy10 * 12.0;\n    float dp2xy13 = dp2xy11 * 13.0;\n    float dp2xy14 = dp2xy12 * 14.0;\n    float dp2xy15 = dp2xy13 * 15.0;\n    float dp2xy16 = dp2xy14 * 16.0;\n    float dp2xy17 = dp2xy15 * 17.0;\n    float dp2xy18 = dp2xy16 * 18.0;\n    float dp2xy19 = dp2xy17 * 19.0;\n    float dp2xy20"]}