from wgpu_shadertoy import Shadertoy
from PIL import Image
import numpy as np


# shadertoy source: https://www.shadertoy.com/view/tdyyzc by FabriceNeyret2
# this outputs just white in wgpu-py which is wrong. the problem could be anywhere really, a bunch of stuff is going on.
original_code = """
float DENS = 10.;                         // target average density per cell

#define hash2(p)      fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) // https://www.shadertoy.com/view/llySRh
#define lcg(p)        toFloat( p = p * 1664525u + 1013904223u )
#define toFloat(p)  ( float(p)  / float(0xffffffffu) )
#define toUint(p)     uint( (p) * float(0xffffffffu) )

// Poisson generator via Inverse transform sampling ( for small d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables
float Poisson(vec2 U, float d) {          // d = target average density
    float x = 0., p = exp(-d), s = p;
    uint r = toUint( hash2(U+.5).x );     // seed
    
    for( ; lcg(r) > s && x<50. ; ) 
        s += p *= d/++x; 
        
    return x;
}
    
void mainImage( out vec4 O,  vec2 u )
{
    vec2 R = iResolution.xy,
         M = length(iMouse.xy) < 10. ? vec2(0) : 2.*iMouse.xy/R-1.,
         S = 4.*exp2(2.*M.x) / R.yy,
         U = S * ( 2.*u - R ) - iTime,
         I = floor(U), F = fract(U), P;
    
 // O = vec4( 2.-R.y/8.*length(hash2(I)-F) ); return; // test: one single value per cell

    float d = 1e5, i = 0.,
           n = Poisson(I, DENS );         // number of dot per cell = Poisson law
    for( ; i < n; i++ )                   // then, generates n Uniform dots in the cell
        P = F - hash2(I+i/100.),
        d = min(d, dot(P,P) );
                         // dot size proportional if big or 1 pixel if small 
    O = vec4( max(0., 1. - min(R.y/8.,.5/S.x)* sqrt(d) ) );   // draw points 
    O.b += .2*mod(I.x+I.y,2.);            // show cells
    O = sqrt(O);                          // to sRGB
}
"""


# in this code the Possion function is generated by deepseek-coder-base-6.7b (docstring input)
# it crashes in wgpu-py and also WebGL in the browser.
# I assume that the float has too many digits... and I feel like that was mentioned in wgpu once as fixed.
# naga 0.19.0 still validates this. But wgpu panics with "Error in wgpuQueueSubmit: Validation Error \n Parent device is list"
# okay that wasn't actually the problem - might be something else entirely - with exp() likely?
altered_code = """//glsl
float DENS = 10.;                         // target average density per cell

#define hash2(p)      fract(sin((p)*mat2(127.1,311.7, 269.5,183.3)) *43758.5453123) // https://www.shadertoy.com/view/llySRh
#define lcg(p)        toFloat( p = p * 1664525u + 1013904223u )
#define toFloat(p)  ( float(p)  / float(0xffffffffu) )
#define toUint(p)     uint( (p) * float(0xffffffffu) )

// Poisson generator via Inverse transform sampling ( for small d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables
float Poisson(vec2 U, float d) {          // d = target average density
    float k = exp(d);
    float x = exp(dot(U, U) / 2.0);
    return abs(x);
    return x * k / (2.0 * 3.1415926535897932384626433832795);
}
    
void mainImage( out vec4 O, vec2 u )
{
    vec2 R = iResolution.xy,
         M = length(iMouse.xy) < 10. ? vec2(0) : 2.*iMouse.xy/R-1.,
         S = 4.*exp2(2.*M.x) / R.yy,
         U = S * ( 2.*u - R ) - iTime,
         I = floor(U), F = fract(U), P;
    
 // O = vec4( 2.-R.y/8.*length(hash2(I)-F) ); return; // test: one single value per cell

    float d = 1e5, i = 0.,
           n = Poisson(I, DENS );         // number of dot per cell = Poisson law
    for(  ; i < n; i++ )                   // then, generates n Uniform dots in the cell
        P = F - hash2(I+i/100.),
        d = min(d, dot(P,P) );
                        // dot size proportional if big or 1 pixel if small 
    O = vec4( max(0., 1. - min(R.y/8.,.5/S.x)* sqrt(d) ) );   // draw points 
    O.b += .2*mod(I.x+I.y,2.);            // show cells
    O = sqrt(O);                          // to sRGB

    // added for easier debugging
    O = vec4(vec3(Poisson(u, DENS)), 1.0);
}
"""


# it's the same as panic shader 16: we got a for loop where it does go into an infinite because it is somehow depenant on time...
# declined issue: 
minimal_code = """//glsl

float Poisson(vec2 U, float d) {          // d = target average density
    float k = exp(-d);
    float x = exp(dot(U, U) / 2.0);
    // return x;
    return x * k / (2.0 * 3.1415926535897932384626433832795);
}

void mainImage( out vec4 fragColor, in vec2 fragCoord )
{
    vec2 uv = (2.0*fragCoord - iResolution.xy)/iResolution.y;
    vec3 col = vec3(0.1);
    col.g = dot(fragCoord, fragCoord);
    col.r = Poisson(fragCoord, 10.0);
    
    fragColor = vec4(col,1.0);
}


"""


# shader = Shadertoy(original_code, resolution=(800, 450), shader_type="glsl")
shader = Shadertoy(altered_code, resolution=(800, 450), shader_type="glsl") #, offscreen=True
# shader = Shadertoy(minimal_code, resolution=(800, 450), shader_type="glsl")


if __name__ == "__main__":
    shader.show()
    # snap = shader.snapshot(9999999.0)
    # img = Image.fromarray(snap)


    