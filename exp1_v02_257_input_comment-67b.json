{"input_comment": ["\n    return (cos(a*TAU)+1.)/2.;\n}\n\n//vec3 i = vec3(.5)+vec3(.5,-.5,-.5);\n//=> fsin st fsin(0) = 0, fsin(1/3) = 1, fsin(2/3) = -1\n// sin(tau/3) =.5\n// = sin(tau*a); [-.5,1] -> [-1,1] = x+.5)/1.5)*2-1 = x*2/1.5-1/1.5\nfloat", "\n    float d = p.y + 1.0;\n    float r = 1.0;\n    for (int i = 0; i < 10; i++)\n    {\n        p = abs(p) - 1.0;\n        p.xy = vec2(p.x + p.y, p.x - p.y) * 0.57735027;\n        p.z -= r;\n        r *= 3.0;\n        d = max(d, length(p) * pow(r, -2.1));\n    }\n    return d;\n}\n\n// This is the function that makes the crazy fractally shape\nvec", "\n    return length(max(abs(p) - vec3(0.5), 0.0));\n}\n\n// Distance to the scene\nfloat", "\n    vec3 q = p;\n    float d = length(q) - 1.0;\n    P = q;\n    return vec2(d, 0.0);\n}\n\n// Distance to the scene and color of the closest point\nvec", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", "\n    vec4 c1 = vec4(0.0, 0.0, 0.0, 1.0);\n    vec4 c2 = vec4(1.0, 1.0, 1.0, 1.0);\n    vec4 c3 = vec4(0.0, 0.0, 1.0, 1.0);\n    vec4 c4 = vec4(0.0, 1.0, 0.0, 1.0);\n    vec4 c5 = vec4(1.0, 0.0, 0.0, 1.0);\n    vec4 c6 = vec4(1.0, 1.0, 0.0, 1.0);\n    vec4 c7 = vec4(0.0, 1.0, 1.0, 1.0);\n    vec4 c8 = vec4(1.0, 0.0, 1.0, 1.0);\n    vec4 c9 = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 c10 = vec4(0.5, 0.5, 1.0, 1.0);\n    vec4 c11 = vec4(0.5, 1.0, 0.5, 1.0);\n    vec4 c12 = vec4(1.0, 0.5, 0.5, 1.0);\n    vec4 c13 = vec4(0.5, 0.5, 0.0, 1.0);\n    vec4 c14 = vec4(0.5, 0.0, 0.5, 1.0);\n    vec4 c15 = vec4(0.0, 0.5, 0.5, 1.0);\n    vec4 c16 = vec4(0.5, 0.5, 0.5, 1.0);\n    vec4 c17 =", "\n    float d2 = d * d;\n    float d3 = d2 * d;\n    float d4 = d2 * d2;\n    float d5 = d4 * d;\n    float d6 = d4 * d2;\n    float d7 = d6 * d;\n    float d8 = d6 * d2;\n    float d9 = d8 * d;\n    float d10 = d8 * d2;\n    float d11 = d10 * d;\n    float d12 = d10 * d2;\n    float d13 = d12 * d;\n    float d14 = d12 * d2;\n    float d15 = d14 * d;\n    float d16 = d14 * d2;\n    float d17 = d16 * d;\n    float d18 = d16 * d2;\n    float d19 = d18 * d;\n    float d20 = d18 * d2;\n    float d21 = d20 * d;\n    float d22 = d20 * d2;\n    float d23 = d22 * d;\n    float d24 = d22 * d2;\n    float d25 = d24 * d;\n    float d26 = d24 * d2;\n    float d27 = d26 * d;\n    float d28 = d26 * d2;\n    float d29 = d28 * d;\n    float d30 = d28 * d2;\n    float d31 = d30 * d;\n    float d32 = d30 * d2;\n    float d33 = d32 * d;\n    float d34 = d32 * d2;\n    float d35 = d34 * d;\n    float d36 = d34 * d2;\n    float d37 = d36 * d;\n    float d38 = d36 * d2;\n    float d39 = d38 * d;\n    float d40 = d38 * d2;\n    float d", "\n    // Softbox\n    float t = RayBox(rayDir, vec3(0.0), vec3(1000.0), 0.0);\n    if (t > 0.0)\n    {\n        vec3 pos = rayDir * t;\n        vec3 normal = GetBoxNormal(pos, vec3(0.0), vec3(1000.0), 0.0);\n        return GetSoftboxColor(pos, normal, sunDir);\n    }\n\n    // Lights\n    vec3 lightColor = vec3(0.0);\n    for (int i = 0; i < 4; i++)\n    {\n        float angle = float(i) * 0.7853981633974483;\n        vec3 lightPos = vec3(cos(angle), 0.0, sin(angle)) * 100.0;\n        float dist = length(lightPos - rayDir * 100.0);\n        float atten = 1.0 / (dist * dist);\n        lightColor += GetLightColor(lightPos, sunDir) * atten;\n    }\n\n    // Fade\n    float fade = rayDir.y * 0.5 + 0.5;\n    return lightColor * fade;\n}\n\n// This is a procedural environment map with a giant overhead softbox,\n// 4 lights in a horizontal circle, and a bottom-to-top fade.\nvec", "\n    return texture(iChannel0, coords).r - iChannelResolution.y;\n}\n\n// F'(x,y) = F'(x)\nfloat", "\n    return texture(iChannel0, coords).r - iChannelResolution.y;\n}\n\n// F'(x,y) = F'(x)\nfloat", "\n    return texture(iChannel0, coords).r - iChannelResolution.y;\n}\n\n// F'(x,y) = F'(x)\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = vec3(uv,0.5+0.5*sin(iTime));\n    fragColor = vec4(col,1.0);\n}", "\n    float f = 0.0;\n    float w = 0.5;\n    float ws = 0.0;\n    for (int i = 0; i < 5; i++) {\n        f += w * noise(p);\n        ws += w;\n        w *= 0.5;\n        p *= 2.0;\n    }\n    return f / ws;\n}\n\n// Standard fBm function with some time dialation to give a parallax \n// kind of effect. In other words, the position and time frequencies \n// are changed at different rates from layer to layer.\n//\nfloat", "\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    vec2 p0 = floor(p);\n    vec2 p1 = p0 + vec2(1.0, 0.0);\n    vec2 p2 = p0 + vec2(0.0, 1.0);\n    vec2 p3 = p0 + vec2(1.0, 1.0);\n\n    float v0 = random(p0);\n    float v1 = random(p1);\n    float v2 = random(p2);\n    float v3 = random(p3);\n\n    vec2 d0 = p - p0;\n    vec2 d1 = p - p1;\n    vec2 d2 = p - p2;\n    vec2 d3 = p - p3;\n\n    float d00 = dot(d0, d0);\n    float d11 = dot(d1, d1);\n    float d22 = dot(d2, d2);\n    float d33 = dot(d3, d3);\n\n    float d01 = dot(d0, d1);\n    float d02 = dot(d0, d2);\n    float d03 = dot(d0, d3);\n    float d12 = dot(d1, d2);\n    float d13 = dot(d1, d3);\n    float d23 = dot(d2, d3);\n\n    float m0 = max(v0, max(v1, v2));\n    float m1 = max(v3, max(v0, v1));\n    float m2 = max(v2, max(v3, v0));\n    float m3 = max(v1, max(v2, v3));\n\n    float f0 = m0 - v0;\n    float f1 = m1 - v1;\n    float f2 = m2 - v2;\n    float f3 = m3 - v3;\n\n    float f01 = f0 + f1;\n    float f02 = f0 + f2;\n    float f03 = f0 + f3;\n    float f12 = f1 + f2", "\n    // Get the integer part of the coordinate and scale it up\n    vec2 i_p = floor(p);\n    p -= i_p;\n\n    // Get the distance to the four closest points\n    vec2 d0 = vec2(distance(p, vec2(0.0, 0.0)));\n    vec2 d1 = vec2(distance(p, vec2(1.0, 0.0)));\n    vec2 d2 = vec2(distance(p, vec2(0.0, 1.0)));\n    vec2 d3 = vec2(distance(p, vec2(1.0, 1.0)));\n\n    // Get the minimum of those four distances\n    float dmin = min(d0, min(d1, min(d2, d3)));\n\n    // Return the square root of the minimum distance\n    return sqrt(dmin);\n}\n\n// The main function\nvoid main()\n{\n    // Get the texture coordinate\n    vec2 uv = gl_FragCoord.xy / resolution.xy;\n\n    // Get the Voronoi value\n    float v = Voronoi(uv);\n\n    // Output the Voronoi value\n    gl_FragColor = vec4(v, v, v, 1.0);\n}\n", "\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition is the position of the eye\n\n    // We will use the rayDirection to decide what color to return\n    // rayDirection is the direction of the ray\n\n    // We will use the rayHitInfo to decide what color to return\n    // rayHitInfo.x is the distance to the hit\n    // rayHitInfo.y is the object id\n    // rayHitInfo.z is the material id\n\n    // We will use the eyePosition to decide what color to return\n    // eyePosition", "\n    // ~~~~~~~ sphere\n    // vec3 s = vec3(0.0, 0.0, 0.0);\n    // float r = 1.0;\n    // float d = length(p - s) - r;\n\n    // ~~~~~~~ plane\n    // vec3 pn = vec3(0.0, 1.0, 0.0);\n    // float d = dot(p, pn);\n\n    // ~~~~~~~ box\n    // vec3 b = vec3(0.0, 0.0, 0.0);\n    // vec3 s = vec3(1.0, 1.0, 1.0);\n    // vec3 d = abs(p - b) - s;\n    // float res = min(max(d.x, max(d.y, d.z)), 0.0) + length(max(d, 0.0));\n\n    // ~~~~~~~ torus\n    // vec2 t = vec2(0.5, 0.2);\n    // vec3 c = vec3(0.0, 0.0, 0.0);\n    // vec3 pt = p - c;\n    // float d = length(vec2(length(pt.xz) - t.x, pt.y)) - t.y;\n\n    // ~~~~~~~ torus\n    // vec2 t = vec2(0.5, 0.2);\n    // vec3 c = vec3(0.0, 0.0, 0.0);\n    // vec3 pt = p - c;\n    // float d = length(vec2(length(pt.xz) - t.x, pt.y)) - t.y;\n\n    // ~~~~~~~ torus\n    // vec2 t = vec2(0.5, 0.2);\n    // vec3 c = vec3(0.0, 0.0, 0.0);\n    // vec3 pt = p - c;\n    // float d = length(vec2(length(pt.", "\n\tfloat tmin = 1000.0;\n\tfloat tmax = 2000.0;\n\t\n\tfloat t = tmin;\n\t\n\tfor (int i = 0; i < NUM_OBJECTS; i++)\n\t{\n\t\tfloat d = objects[i].sdf(ro);\n\t\tif (d < t)\n\t\t{\n\t\t\tt = d;\n\t\t\thitID = i;\n\t\t}\n\t}\n\t\n\treturn vec2(t, hitID);\n}\n\n// ~~~~~~~ get normal of the object at the hit point\n// input ro --> ray origin point/position\n// input rd --> ray direction\n// input t --> distance travelled by ray\n// output is normal of the object at the hit point\n//\nvec", "\n    // ~~~~~~~ sphere\n    float sd = sdSphere(p, vec3(0.0, 0.0, 0.0), 1.0);\n    vec3 sColor = vec3(1.0, 0.0, 0.0);\n\n    // ~~~~~~~ plane\n    float pd = p.y;\n    vec3 pColor = vec3(0.0, 1.0, 0.0);\n\n    // ~~~~~~~ box\n    float bd = sdBox(p, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    vec3 bColor = vec3(0.0, 0.0, 1.0);\n\n    // ~~~~~~~ union\n    float ud = opUnion(sd, pd);\n    vec3 uColor = vec3(1.0, 1.0, 0.0);\n\n    // ~~~~~~~ intersection\n    float id = opIntersection(sd, pd);\n    vec3 iColor = vec3(1.0, 0.0, 1.0);\n\n    // ~~~~~~~ difference\n    float dd = opDifference(sd, pd);\n    vec3 dColor = vec3(0.0, 1.0, 1.0);\n\n    // ~~~~~~~ blend\n    float blend = smoothstep(0.0, 0.01, ud);\n    vec3 color = mix(sColor, uColor, blend);\n\n    return vec4(color, 1.0);\n}\n\n// ~~~~~~~ ray march\n// input p --> is ray position\n// input rd --> is ray direction\n// outputs distance to the closest object\nfloat", "\n    float tmin = 1000.0;\n    float tmax = 2000.0;\n\n    float t = tmin;\n    float m = -1.0;\n    for (int i = 0; i < 100; i++)\n    {\n        vec2 res = map(ro + rd * t);\n        if (res.x < EPSILON)\n        {\n            m = res.y;\n            break;\n        }\n        t += res.x;\n        if (t > tmax)\n        {\n            break;\n        }\n    }\n\n    if (m == -1.0)\n    {\n        return vec4(t, m, itterRatio, 0.0);\n    }\n\n    vec3 pos = ro + rd * t;\n    vec3 nor = calcNormal(pos);\n\n    vec3 mate = vec3(0.0);\n    if (m == 0.0)\n    {\n        mate = vec3(0.8, 0.3, 0.3);\n    }\n    else if (m == 1.0)\n    {\n        mate = vec3(0.3, 0.3, 0.8);\n    }\n    else if (m == 2.0)\n    {\n        mate = vec3(0.8, 0.8, 0.3);\n    }\n    else if (m == 3.0)\n    {\n        mate = vec3(0.3, 0.8, 0.3);\n    }\n    else if (m == 4.0)\n    {\n        mate = vec3(0.8, 0.3, 0.8);\n    }\n    else if (m == 5.0)\n    {\n        mate = vec3(0.3, 0.8, 0.8);\n    }\n    else if (m == 6.0)\n    {\n        mate = vec3(0.8, 0.8, 0.8);\n    }\n\n    float dif = clamp(dot(nor, vec3", "\n    vec3 n = vec3(0.0);\n    float d = 0.0;\n    float w = 0.0;\n    float wSum = 0.0;\n    float dSum = 0.0;\n    float dMax = 0.0;\n    float dMin = 1000000.0;\n    float dMinIdx = 0.0;\n    float dMaxIdx = 0.0;\n    float dMinIdx2 = 0.0;\n    float dMaxIdx2 = 0.0;\n    float dMinIdx3 = 0.0;\n    float dMaxIdx3 = 0.0;\n    float dMinIdx4 = 0.0;\n    float dMaxIdx4 = 0.0;\n    float dMinIdx5 = 0.0;\n    float dMaxIdx5 = 0.0;\n    float dMinIdx6 = 0.0;\n    float dMaxIdx6 = 0.0;\n    float dMinIdx7 = 0.0;\n    float dMaxIdx7 = 0.0;\n    float dMinIdx8 = 0.0;\n    float dMaxIdx8 = 0.0;\n    float dMinIdx9 = 0.0;\n    float dMaxIdx9 = 0.0;\n    float dMinIdx10 = 0.0;\n    float dMaxIdx10 = 0.0;\n    float dMinIdx11 = 0.0;\n    float dMaxIdx11 = 0.0;\n    float dMinIdx12 = 0.0;\n    float dMaxIdx12 = 0.0;\n    float dMinIdx13 = 0.0;\n    float dMaxIdx13 = 0.0;\n    float dMinIdx14 = 0.0;\n    float dMaxIdx14 = 0.0;\n    float dMinIdx15 = 0.0;\n    float dMaxIdx15 = 0.0;\n    float dMinIdx16 = 0.0;\n    float dMaxIdx16 = 0.0;\n    float dMin", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, vec3(1.0, 57.0, 21.0));\n    vec4 v = vec4(n, n+1.0, n+57.0, n+58.0) + dot(i, vec3(57.0, 21.0, 1.0));\n    vec4 r = fract(sin(v*0.015625)*23456.54321);\n    r *= 2.0-r.yzwx;\n    return mix(mix(mix(r.x, r.y, f.x), mix(r.z, r.w, f.x), f.y), mix(mix(r.x, r.y, f.z), mix(r.z, r.w, f.z), f.y), f.w);\n}\n\n// This is a 3D value noise function that returns a value between 0.0 and 1.0.\n// It's a lot like the 2D version, but it's 3D.\nfloat", "\n    vec3 color = vec3(0.0);\n    float t = 0.0;\n    float tmax = 1000.0;\n    float tmin = 0.001;\n    float tstep = 0.01;\n    for (int i = 0; i < 100; i++) {\n        t += tstep;\n        if (t > tmax) break;\n        vec3 pos = rayDir * t;\n        float d = map(pos);\n        if (d < tstep) {\n            vec3 normal = GetNormal(pos);\n            float diffuse = max(0.0, dot(normal, -rayDir));\n            color += diffuse * vec3(1.0, 0.5, 0.0);\n            t += d;\n            tstep = d * 0.5;\n        }\n    }\n    return color;\n}\n\nvec", "\n    vec2 AB = B - A;\n    vec2 AC = coords - A;\n    float t = dot(AC, AB) / dot(AB, AB);\n    t = clamp(t, 0.0, 1.0);\n    vec2 P = A + t * AB;\n    float d = length(P - coords);\n    return d - height;\n}\n\n//============================================================\nfloat", "\n    float dot = dot(start, end);\n    float theta_0 = acos(dot);\n    float theta = theta_0 * percent;\n    vec2 v2 = end - start * dot;\n    v2 = normalize(v2);\n    return ((start * cos(theta)) + (v2 * sin(theta)));\n}\n\n//============================================================\n// adapted from source at:\n// https://keithmaggio.wordpress.com/2011/02/15/math-magician-lerp-slerp-and-nlerp/\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    float t = iTime;\n    float t2 = t * 0.5;\n    float t3 = t * 0.25;\n    float t4 = t * 0.125;\n    \n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n    float s = sin(a * 10.0 + t2);\n    float c = cos(a * 10.0 + t2);\n    float r2 = r + s * 0.05;\n    float r3 = r + c * 0.05;\n    float r4 = r + s * 0.025;\n    float r5 = r + c * 0.025;\n    \n    float f1 = smoothstep(0.0, 0.01, abs(r - r2));\n    float f2 = smoothstep(0.0, 0.01, abs(r - r3));\n    float f3 = smoothstep(0.0, 0.01, abs(r - r4));\n    float f4 = smoothstep(0.0, 0.01, abs(r - r5));\n    \n    float f = f1 + f2 + f3 + f4;\n    \n    col = vec3(f);\n    \n    fragColor = vec4(col, 1.0);\n}\n//============================================================", "\n    vec2 ab = b - a;\n    vec2 ap = p - a;\n    float t = dot(ap, ab) / dot(ab, ab);\n    if (t < 0.0)\n        return length(ap);\n    else if (t > 1.0)\n        return length(p - b);\n    else\n        return length(ap - t * ab);\n}\n\n//Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat", "\n    vec3 color = vec3(0.0);\n\n    // Add a softbox light.\n    float dist = RayBox(rayDir, vec3(0.0), vec3(1000.0), 0.0);\n    if (dist > 0.0)\n    {\n        color += vec3(1.0);\n    }\n\n    return color;\n}\n\n// Make a procedural environment map with a giant softbox light.\nvec", "\n    // The material index.\n    int materialIndex = 0;\n\n    // The distance to the nearest surface.\n    float distanceToSurface = -1.0;\n\n    // The distance to the sphere.\n    float distanceToSphere = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n\n    // The distance to the plane.\n    float distanceToPlane = p.y;\n\n    // The distance to the box.\n    float distanceToBox = length(max(abs(p) - vec3(1.0, 1.0, 1.0), 0.0));\n\n    // The distance to the torus.\n    float distanceToTorus = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // The distance to the cylinder.\n    float distanceToCylinder = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // The distance to the cone.\n    float distanceToCone = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n\n    // The distance to the torus.\n    float distanceToTorus2 = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // The distance to the cylinder.\n    float distanceToCylinder2 = length(p.xz - vec2(0.0, 0.0)) - 0.5;\n\n    // The distance to the cone.\n    float distanceToCone2 = length(p - vec3(0.0, 0.0, 0.0)) - 1.0;\n\n    // The distance to the torus.\n    float distanceToTorus3 = length(vec2(length(p.xz) - 2.0, p.y)) - 0.5;\n\n    // The distance to the cylinder.\n    float distanceToCylinder3 = length(p.xz - vec", "\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, org);\n    float c = dot(org, org) - 1.0;\n    float d = b * b - 4.0 * a * c;\n    if (d < 0.0)\n        return false;\n    float t1 = (-b - sqrt(d)) / (2.0 * a);\n    float t2 = (-b + sqrt(d)) / (2.0 * a);\n    near = min(t1, t2);\n    far = max(t1, t2);\n    return true;\n}\n\n// from https://www.shadertoy.com/view/4s23DR\nbool sphere(vec3 org, vec3 dir, out float near, out float far)\n{\n    float b = dot(org, dir);\n    float c = dot(org, org) - 1.0;\n    float d = b * b - c;\n    if (d < 0.0)\n        return false;\n    float t1 = -b - sqrt(d);\n    float t2 = -b + sqrt(d);\n    near = min(t1, t2);\n    far = max(t1, t2);\n    return true;\n}\n\n// from https://www.shadertoy.com/view/4s23DR\nbool plane(vec3 org, vec3 dir, out float near)\n{\n    float d = dot(org, vec3(0.0, 1.0, 0.0));\n    float b = dot(dir, vec3(0.0, 1.0, 0.0));\n    if (b == 0.0)\n        return false;\n    near = -d / b;\n    return true;\n}\n\n// from https://www.shadertoy.com/view/4s23DR\nbool box(vec3 org, vec3 dir, out float near, out float far)\n{\n    vec3 t1 = (-1.0 - org) / dir;\n    vec3 t2 = (1.0 - org", "\n    vec3 q = abs(p) - s.xyz + r.x;\n    float k0 = max(q.x, max(q.y, q.z * r.z));\n    float k1 = max(q.z, max(q.x, q.y * r.z));\n    float k2 = max(q.y, max(q.x, q.z * r.z));\n    float d = min(max(k0, k1), k2);\n    return d - s.w;\n}\n\nfloat", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n\n    // For performance, compute the cross-product for the three corners of the cube\n    // in which the point p resides.\n    vec3 u = f*f*(3.0-2.0*f);\n\n    // Random float offsets for the 3D noise\n    float n = p.x + p.y*57.0 + 113.0*p.z;\n\n    // Compute the dot product between the gradients and the distance vector\n    // for each of the 8 corners of the cube.\n    return mix(\n        mix(\n            mix(\n                dot(\n                    hash33(n+dot(i, vec3(0, 1, 1))),\n                    f - vec3(0, 0, 0),\n                    u\n                ),\n                dot(\n                    hash33(n+dot(i, vec3(1, 0, 1))),\n                    f - vec3(1, 0, 0),\n                    u\n                ),\n                u.y\n            ),\n            mix(\n                dot(\n                    hash33(n+dot(i, vec3(0, 1, 0))),\n                    f - vec3(0, 1, 0),\n                    u\n                ),\n                dot(\n                    hash33(n+dot(i, vec3(1, 1, 0))),\n                    f - vec3(1, 1, 0),\n                    u\n                ),\n                u.y\n            ),\n            u.z\n        ),\n        mix(\n            mix(\n                dot(\n                    hash33(n+dot(i, vec3(0, 0, 1))),\n                    f - vec3(0, 0, 1),\n                    u\n                ),\n                dot(\n                    hash33(n+dot(i, vec3(1, 0, 1))),\n                    f - vec3(1, 0, 1),\n                    u\n                ),\n                u.y\n            ),\n", "\n    float d = 1e5;\n    for(int i=0; i<4; i++){\n        float a = float(i)*TWO_PI/4.0;\n        vec2 q = p - vec2(cos(a), sin(a))*0.5;\n        d = min(d, length(q)-0.2);\n    }\n    return d;\n}\n\nvec", "\n    vec3 bump = normalize(sn);\n    bump = normalize(bump + sp);\n    bump *= bumpFactor;\n    return bump;\n}\n\n// Standard bump function.\n//\nvec", "\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    vec3 l = normalize(light_pos - p);\n    vec3 v = normalize(camera_pos - p);\n    vec3 h = normalize(l + v);\n\n    float n_dot_l = max(dot(n, l), 0.0);\n    float n_dot_h = max(dot(n, h), 0.0);\n\n    vec3 diffuse = n_dot_l * light_color;\n    vec3 specular = pow(n_dot_h, 100.0) * light_color;\n\n    return diffuse + specular;\n}\n\n// Ray marching\n// p : point,\n// d : direction\nfloat", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}", "\n    vec3 uvw = normalize(rd);\n    float u = atan(uvw.z, uvw.x) / 3.1415926535897932384626433832795;\n    float v = 0.5 - asin(uvw.y) / 3.1415926535897932384626433832795;\n    return texture(iChannel0, vec2(u, v)).rgb;\n}\n\n// raymarching\nfloat", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        d = map(ro + rd * t);\n        if (d < 0.001)\n        {\n            col = vec3(1.0, 0.0, 0.0);\n            break;\n        }\n        t += d;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = rayColor(ro, rd);\n    fragColor = vec4(col, 1.0);\n}\n", "\n    return length(p)-rad;\n}\n\nfloat", "\n    float d = length(p) - param.x;\n    return d;\n}\n\n// scene distance\nfloat", "\n    float d = DE(p, param);\n    float l = length(p);\n    float ld = l * d;\n    float ld2 = ld * ld;\n    float ld3 = ld2 * ld;\n    float ld4 = ld2 * ld2;\n    float ld5 = ld4 * ld;\n    float ld6 = ld4 * ld2;\n    float ld7 = ld6 * ld;\n    float ld8 = ld6 * ld2;\n    float ld9 = ld8 * ld;\n    float ld10 = ld8 * ld2;\n    float ld11 = ld10 * ld;\n    float ld12 = ld10 * ld2;\n    float ld13 = ld12 * ld;\n    float ld14 = ld12 * ld2;\n    float ld15 = ld14 * ld;\n    float ld16 = ld14 * ld2;\n    float ld17 = ld16 * ld;\n    float ld18 = ld16 * ld2;\n    float ld19 = ld18 * ld;\n    float ld20 = ld18 * ld2;\n    float ld21 = ld20 * ld;\n    float ld22 = ld20 * ld2;\n    float ld23 = ld22 * ld;\n    float ld24 = ld22 * ld2;\n    float ld25 = ld24 * ld;\n    float ld26 = ld24 * ld2;\n    float ld27 = ld26 * ld;\n    float ld28 = ld26 * ld2;\n    float ld29 = ld28 * ld;\n    float ld30 = ld28 * ld2;\n    float ld31 = ld30 * ld;\n    float ld3", "\n    vec3 col = vec3(0.0);\n    float sun = max(dot(rd, sunDir), 0.0);\n    float sky = max(dot(rd, skyDir), 0.0);\n    float sky2 = max(dot(rd, skyDir2), 0.0);\n    float sky3 = max(dot(rd, skyDir3), 0.0);\n    float sky4 = max(dot(rd, skyDir4), 0.0);\n    float sky5 = max(dot(rd, skyDir5), 0.0);\n    float sky6 = max(dot(rd, skyDir6), 0.0);\n    float sky7 = max(dot(rd, skyDir7), 0.0);\n    float sky8 = max(dot(rd, skyDir8), 0.0);\n    float sky9 = max(dot(rd, skyDir9), 0.0);\n    float sky10 = max(dot(rd, skyDir10), 0.0);\n    float sky11 = max(dot(rd, skyDir11), 0.0);\n    float sky12 = max(dot(rd, skyDir12), 0.0);\n    float sky13 = max(dot(rd, skyDir13), 0.0);\n    float sky14 = max(dot(rd, skyDir14), 0.0);\n    float sky15 = max(dot(rd, skyDir15), 0.0);\n    float sky16 = max(dot(rd, skyDir16), 0.0);\n    float sky17 = max(dot(rd, skyDir17), 0.0);\n    float sky18 = max(dot(rd, skyDir18), 0.0);\n    float sky19 = max(dot(rd, skyDir19), 0.0);\n    float sky20 = max(dot(rd, skyDir20), 0.0);\n    float sky21 = max(dot(rd, skyDir21), 0.0);\n    float sky22 = max(dot(rd, skyDir", "\n    vec3 col = vec3(0.0);\n    float t = ti;\n    float d = 0.0;\n    for (int i = 0; i < 100; i++)\n    {\n        d = map(ro + rd * t);\n        if (d < 0.001)\n        {\n            col = vec3(1.0, 0.0, 0.0);\n            break;\n        }\n        t += d;\n    }\n    return col;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = (fragCoord.xy - 0.5 * iResolution.xy) / iResolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv, 1.0));\n    vec3 col = rayColor(ro, rd, 0.0);\n    fragColor = vec4(col, 1.0);\n}\n", "\n    p = abs(p - diamond.xy);\n    p -= 2.0 * clamp(dot(vec2(1.0, 1.0), p), 0.0, 1.0);\n    return length(p) * sign(p.x + p.y);\n}\n\n// circle: (center.x, center.y, radius)\nfloat", "\n    vec3 col = vec3(0.0);\n    uv *= 1.0;\n    uv = fract(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv *= 2.0;\n    uv = abs(uv);\n    uv -= 0.5;\n    uv", "\n    float d = length(pos) - 1.0;\n    return d;\n}\n\n// get normal in the world\nvec", "\n    vec3 l = normalize( vec3( 1.0, 1.0, 1.0 ) );\n    vec3 h = normalize( l + eye );\n    float ndotl = max( dot( n, l ), 0.0 );\n    float ndoth = max( dot( n, h ), 0.0 );\n    float spec = pow( ndoth, 10.0 );\n    return vec3( 0.2, 0.2, 0.2 ) + vec3( 0.8, 0.8, 0.8 ) * ndotl + vec3( 1.0, 1.0, 1.0 ) * spec;\n}\n\nvoid main() {\n    vec3 v = normalize( vec3( gl_FragCoord.xy - u_resolution.xy, u_resolution.y ) );\n    vec3 n = normalize( vec3( 0.0, 0.0, 1.0 ) );\n    vec3 eye = normalize( vec3( 0.0, 0.0, 1.0 ) );\n    gl_FragColor = vec4( shading( v, n, eye ), 1.0 );\n}\n", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    float d = length(p) - offset;\n    return pow(abs(sin(d * 100.0)), 1.0);\n}\n\n// 2d rotation matrix\nmat", "\n    float xmts = (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (1.0 - a) * (", "\n    vec2 d = abs(vec2(length(p.xz), p.y)) - vec2(r, h/2.0);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0));\n}\n\n/**\n * Signed distance function for a box centered at the origin with the given dimensions.\n */\nfloat", "\n    float sphere = length(p) - 1.0;\n    float plane = p.y;\n    return min(sphere, plane);\n}\n\n/**\n * Calculate the normal of the surface at point p.\n */\nvec", "\n    vec3 forward = normalize(center - eye);\n    vec3 right = normalize(cross(forward, up));\n    vec3 up_ = normalize(cross(right, forward));\n\n    return mat3(right, up_, -forward);\n}\n\n/**\n * Return a transform matrix that will transform a ray from world coordinates\n * to view space, given the eye point, the camera target, and an up vector.\n *\n * This assumes that the center of the camera is aligned with the negative z axis in\n * view space when calculating the ray marching direction. See rayDirection.\n */\nmat", "\n    float n = pnoise(p, 1.0);\n    n += pnoise(p*2.0, 2.0);\n    n += pnoise(p*4.0, 4.0);\n    n += pnoise(p*8.0, 8.0);\n    n /= 4.0;\n    return n;\n}\n\n// my noise\nfloat", "\n    vec2 pos = coord;\n    float r = length(pos);\n    float a = atan(pos.y, pos.x);\n    float f = fract(a / 3.1415926535897932384626433832795);\n    float g = fract(a / 3.1415926535897932384626433832795 + 0.5);\n    float b = fract(a / 3.1415926535897932384626433832795 + 1.0);\n    float h = fract(a / 3.1415926535897932384626433832795 + 1.5);\n    float i = fract(a / 3.1415926535897932384626433832795 + 2.0);\n    float j = fract(a / 3.1415926535897932384626433832795 + 2.5);\n    float k = fract(a / 3.1415926535897932384626433832795 + 3.0);\n    float l = fract(a / 3.1415926535897932384626433832795 + 3.5);\n    float m = fract(a / 3.1415926535897932384626433832795 + 4.0);\n    float n = fract(a / 3.1415926535897932384626433832795 + 4.5);\n   ", "\n  vec2 q = vec2(\n    dot(p, vec2(127.1, 311.7)),\n    dot(p, vec2(269.5, 183.3))\n  );\n  return fract(sin(q) * w);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    float f = 0.0;\n    f += 0.5000*noise(p); p = p*2.02;\n    f += 0.2500*noise(p); p = p*2.03;\n    f += 0.1250*noise(p); p = p*2.01;\n    f += 0.0625*noise(p);\n    return f;\n}\n\n// The bump mapping function.\nvec", "\n    vec4 scr_pt_hom = vec4(scr_pt, 0.0, 1.0);\n    vec4 view_pt = viewp_inv * scr_pt_hom;\n    view_pt /= view_pt.w;\n    vec4 world_pt = view_inv * view_pt;\n    vec4 world_dir = world_pt - view_inv[3];\n    return world_dir;\n}\n\n// screen to world: http://bookofhook.com/mousepick.pdf\nvec", "\n    vec2 dir = pB - pA;\n    vec2 dirN = normalize(dir);\n    vec2 dirP = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90 = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90 = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P = normalize(dir * vec2(1.0, 1.0));\n    vec2 dirP90P = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90N = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90N = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P90 = normalize(dir * vec2(1.0, 1.0));\n    vec2 dirP90P90 = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90N90 = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90N90 = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P90N90 = normalize(dir * vec2(1.0, 1.0));\n    vec2 dirP90P90N90 = normalize(dir * vec2(-1.0, 1.0));\n    vec2 dirN90N90P90N90 = normalize(dir * vec2(1.0, -1.0));\n    vec2 dirP90N90P90N90 = normalize(dir * vec2(-1.0, -1.0));\n    vec2 dirN90P90N90P90N90 =", "\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n    vec3 lightColor = vec3(1.0, 1.0, 1.0);\n    vec3 ambient = vec3(0.1, 0.1, 0.1);\n    vec3 diffuse = max(dot(n, lightDir), 0.0) * lightColor;\n    return ambient + diffuse;\n}\n\n// Ray-marching\n// p : point,\n// d : direction\nfloat", "\n    vec3 m = (ro - cen) / rd;\n    vec3 n = (ro - cen) / rad;\n    vec3 k = abs(m) - n;\n    float t1 = max( max( k.x, k.y ), k.z );\n    float t2 = min( min( k.x, k.y ), k.z );\n    return vec2( max( t1, t2 ), min( t1, t2 ) );\n}\n\n// ray-box intersection (simplified)\nvec", "\n    float y = sin(x);\n    float z = (y + 1) / 2;\n    float w = pow(z, a);\n    float v = pow(1 - z, b);\n    return w * v;\n}\n\n// a lovely function that goes up and down periodically between 0 and 1, pausing at the extremes\nfloat", "\n    return vec2(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);\n}\n\n// z * z\nvec", "\n    vec3 ba = pb - pa;\n    vec3 oa = ro - pa;\n    float baba = dot(ba,ba);\n    float bard = dot(ba,rd);\n    float baoa = dot(ba,oa);\n    float rdoa = dot(rd,oa);\n    float oaoa = dot(oa,oa);\n    float a = baba - bard*bard;\n    float b = baba*rdoa - baoa*bard;\n    float c = baba*oaoa - baoa*baoa - ra*ra*baba;\n    float h = b*b - a*c;\n    if( h>=0.0 )\n    {\n        float t = (-b - sqrt(h)) / a;\n        vec3  p = ro + t*rd;\n        vec3  n = (p-pa) - ba*dot(p-pa,ba)/baba;\n        return vec4( t, n );\n    }\n    return vec4( -1.0 );\n}\n\n// ray-cone intersection (returns t and normal)\nvec", "\n    vec2 p = P - U;\n    float d = length(p);\n    if (d < r) {\n        float a = atan(p.y, p.x);\n        float s = sin(a);\n        float c = cos(a);\n        float t = (d - r) / r;\n        float aa = a + t * 0.5;\n        float ss = sin(aa);\n        float cc = cos(aa);\n        float dd = d + t * r;\n        float h = sqrt(r * r - dd * dd);\n        float sss = ss * h;\n        float ccc = cc * h;\n        O.x = sss + dd * c;\n        O.y = ccc - dd * s;\n        O.z = dd;\n        O.w = aa;\n        O.xyz = C;\n    }\n}\n\nvoid main() {\n    vec2 U = iMouse.xy / iResolution.xy;\n    vec2 P = gl_FragCoord.xy / iResolution.xy;\n    vec4 O = vec4(0.0);\n    sphere(O, U, P, 0.2, vec3(1.0, 0.0, 0.0));\n    sphere(O, U, P, 0.1, vec3(0.0, 1.0, 0.0));\n    sphere(O, U, P, 0.05, vec3(0.0, 0.0, 1.0));\n    gl_FragColor = vec4(O.xyz, 1.0);\n}\n", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    return d;\n}\n\n// ray marching\nvec", "\n    float r = length(p);\n    float a = atan(p.y, p.x);\n    float d = r - layerID;\n    float s = sin(a);\n    float c = cos(a);\n    float s2 = s*s;\n    float c2 = c*c;\n    float s3 = s*s2;\n    float c3 = c*c2;\n    float s4 = s*s3;\n    float c4 = c*c3;\n    float s5 = s*s4;\n    float c5 = c*c4;\n    float s6 = s*s5;\n    float c6 = c*c5;\n    float s7 = s*s6;\n    float c7 = c*c6;\n    float s8 = s*s7;\n    float c8 = c*c7;\n    float s9 = s*s8;\n    float c9 = c*c8;\n    float s10 = s*s9;\n    float c10 = c*c9;\n    float s11 = s*s10;\n    float c11 = c*c10;\n    float s12 = s*s11;\n    float c12 = c*c11;\n    float s13 = s*s12;\n    float c13 = c*c12;\n    float s14 = s*s13;\n    float c14 = c*c13;\n    float s15 = s*s14;\n    float c15 = c*c14;\n    float s16 = s*s15;\n    float c16 = c*c15;\n    float s17 = s*s16;\n    float c17 = c*c16;\n    float s18 = s*s17;\n    float c18 = c*c17;\n    float s19 = s*s18;\n    float c19 = c*c18;\n    float s20 = s*s19;\n    float c20 = c*c19;\n", "\n    vec3 col = vec3(0.0);\n    float d = 1000.0;\n    float a = atan(p.y,p.x);\n    float r = length(p);\n    float s = sin(a*10.0);\n    float c = cos(a*10.0);\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r6 = r4*r2;\n    float r8 = r4*r4;\n    float r10 = r8*r2;\n    float r12 = r8*r4;\n    float r14 = r12*r2;\n    float r16 = r12*r4;\n    float r18 = r16*r2;\n    float r20 = r16*r4;\n    float r22 = r20*r2;\n    float r24 = r20*r4;\n    float r26 = r24*r2;\n    float r28 = r24*r4;\n    float r30 = r28*r2;\n    float r32 = r28*r4;\n    float r34 = r32*r2;\n    float r36 = r32*r4;\n    float r38 = r36*r2;\n    float r40 = r36*r4;\n    float r42 = r40*r2;\n    float r44 = r40*r4;\n    float r46 = r44*r2;\n    float r48 = r44*r4;\n    float r50 = r48*r2;\n    float r52 = r48*r4;\n    float r54 = r52*r2;\n    float r56 = r52*r4;\n    float r58 = r56*r2;\n    float r60 = r56*r4;\n    float r62 = r60*r2;\n    float r64 = r60", "\n    float flameRadius = 0.5;\n    float flameHeight = 0.5;\n    float flameWidth = 0.5;\n    float flameLength = 0.5;\n    float flameSpeed = 0.5;\n    float flameTime = iTime * flameSpeed;\n    float flameNoise = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime));\n    float flameNoise2 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 1.0));\n    float flameNoise3 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 2.0));\n    float flameNoise4 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 3.0));\n    float flameNoise5 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 4.0));\n    float flameNoise6 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 5.0));\n    float flameNoise7 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 6.0));\n    float flameNoise8 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 7.0));\n    float flameNoise9 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 8.0));\n    float flameNoise10 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition.z, flameTime + 9.0));\n    float flameNoise11 = snoise(vec4(currentRayPosition.x, currentRayPosition.y, currentRayPosition", "\n    float sphereDist = sdSphere(currentRayPosition, vec3(0.0, 0.0, 0.0), 1.0);\n    float planeDist = sdPlane(currentRayPosition, vec3(0.0, 1.0, 0.0), vec3(0.0, 0.0, 0.0));\n    float boxDist = sdBox(currentRayPosition, vec3(0.0, 0.0, 0.0), vec3(1.0, 1.0, 1.0));\n    float result = min(sphereDist, planeDist);\n    result = min(result, boxDist);\n    return result;\n}\n\n// \u043d\u043e\u0440\u043c\u0430\u043b\u044c \u043a \u0442\u043e\u0447\u043a\u0435\nvec", "\n    return fract(sin(x)*sm);\n}\n\n// Based on Ollj's smooth \"fract\" formula.\nfloat", "\n    vec3 q = vec3(dot(p, vec3(1.0, 57.0, 21.0)),\n                  dot(p, vec3(57.0, 21.0, 1.0)),\n                  dot(p, vec3(21.0, 1.0, 57.0)));\n    return fract(sin(q) * 43758.5453);\n}\n\n// vec3 to float hash algorithm.\nfloat", "\n    // Skew the input space to determine which simplex cell we're in\n    float s = (p.x + p.y + p.z) * F3; // F3 = (sqrt(3) - 1) / 3;\n    // Very nice interpolating function.\n    // s = s - floor(s * (1.0 / 69.0)) * 69.0;\n    // And this is the same thing, but faster.\n    s = fract(s);\n    // To reduce the common \"wrap\" artifact, I'm using a bitwise AND.\n    // The result is a value in the range [0, 64].\n    int i = int(p.x + s);\n    int j = int(p.y + s);\n    int k = int(p.z + s);\n\n    float x0 = float(i) - s;\n    float y0 = float(j) - s;\n    float z0 = float(k) - s;\n    float x1 = x0 + 1.0;\n    float y1 = y0;\n    float z1 = z0;\n    float x2 = x0;\n    float y2 = y0 + 1.0;\n    float z2 = z0;\n    float x3 = x0;\n    float y3 = y0;\n    float z3 = z0 + 1.0;\n\n    // Work out the hashed gradient indices of the four simplex corners\n    int ii = i & 255;\n    int jj = j & 255;\n    int kk = k & 255;\n    int gi0 = perm[ii + perm[jj + perm[kk]]] % 12;\n    int gi1 = perm[ii + 1 + perm[jj + perm[kk]]] % 12;\n    int gi2 = perm[ii + perm[jj + 1 + perm[kk]]] % 12;\n    int gi3 = perm[ii + 1 + perm[jj + 1 + perm[kk]]] % 12;\n\n    // Calculate the contribution from the four corners\n    float t0", "\n    float f = snoise(p);\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*f;\n    f = f*f*f*", "\n\n    float balloonRadius = 0.05;\n    float balloonHeight = 0.1;\n\n    vec3 balloonPosition = vec3(0.0, 0.0, 0.0);\n\n    vec3 balloonToCurrentRayPosition = currentRayPosition - balloonPosition;\n\n    float balloonToCurrentRayPositionLength = length(balloonToCurrentRayPosition);\n\n    float balloonToCurrentRayPositionLengthSquared = balloonToCurrentRayPositionLength * balloonToCurrentRayPositionLength;\n\n    float balloonToCurrentRayPositionLengthSquaredMinusBalloonRadiusSquared = balloonToCurrentRayPositionLengthSquared - (balloonRadius * balloonRadius);\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeight = balloonToCurrentRayPositionLength - balloonHeight;\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquared = balloonToCurrentRayPositionLengthMinusBalloonHeight * balloonToCurrentRayPositionLengthMinusBalloonHeight;\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquared = balloonToCurrentRayPositionLengthMinusBalloonHeightSquared - (balloonRadius * balloonRadius);\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquaredSquared = balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquared * balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquared;\n\n    float balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquaredSquaredSquared = balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusSquaredSquared * balloonToCurrentRayPositionLengthMinusBalloonHeightSquaredMinusBalloonRadiusS", "\n    vec3 m = 1.0 / rd;\n    vec3 n = m * ro;\n    vec3 k = abs( m ) * rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec4( tN, tF, tN > tF? -1.0 : tF < tN? 0.0 : 1.0, tF );\n}\n\n// ray box intersection by iq https://www.shadertoy.com/view/ld23DV\nvec", "\n    // Skew the input space to determine which simplex cell we're in\n    float s = (p.x + p.y + p.z) * F3; // F3 = (sqrt(3.0) - 1.0) / 3.0\n    // Very nice interpolating function.\n    // s = s - floor(s * (1.0 / 69.0)) * 69.0;\n    // And this is the same thing, but faster.\n    s = s - (floor(s + 0.5) - 0.5);\n    // Truncate the integer part of the coordinates, leaving only the \"smaller\" coordinates.\n    // This is the index of the first corner of the simplex cell we are in.\n    // The last incremental value is guaranteed to be less than 1.\n    ivec3 i = ivec3(floor(p + s));\n    vec3 x0 = vec3(p - i); // The vector, p, relative to the i'th corner of the simplex cell.\n    // For the 3D case, the simplex shape is a slightly irregular tetrahedron.\n    // Determine which simplex we are in.\n    int i1, j1, k1; // Offsets for second corner of simplex in (i,j,k) coords\n    int i2, j2, k2; // Offsets for third corner of simplex in (i,j,k) coords\n    if(x0.x >= x0.y){\n        if(x0.y >= x0.z){\n            i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 1; k2 = 0; // X Y Z order\n        }else if(x0.x >= x0.z){\n            i1 = 1; j1 = 0; k1 = 0; i2 = 1; j2 = 0; k2 = 1; // X Z Y order\n        }else{\n            i1 = 0; j1 = 0; k1 = 1; i2 = 1; j2 = 0; k2 = 1; // Z X Y order\n        }\n    }else{ //", "\n    vec2 pa=p-a, ba=b-a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return c*(1.0-h);\n}\n\n//coloring lineAO()\nvec", "\n    float i = 0.0;\n    float r = 0.0;\n    float r2 = 0.0;\n    float i2 = 0.0;\n    float r2i2 = 0.0;\n    float r2i2_2 = 0.0;\n    float r2i2_4 = 0.0;\n    float r2i2_8 = 0.0;\n    float r2i2_16 = 0.0;\n    float r2i2_32 = 0.0;\n    float r2i2_64 = 0.0;\n    float r2i2_128 = 0.0;\n    float r2i2_256 = 0.0;\n    float r2i2_512 = 0.0;\n    float r2i2_1024 = 0.0;\n    float r2i2_2048 = 0.0;\n    float r2i2_4096 = 0.0;\n    float r2i2_8192 = 0.0;\n    float r2i2_16384 = 0.0;\n    float r2i2_32768 = 0.0;\n    float r2i2_65536 = 0.0;\n    float r2i2_131072 = 0.0;\n    float r2i2_262144 = 0.0;\n    float r2i2_524288 = 0.0;\n    float r2i2_1048576 = 0.0;\n    float r2i2_2097152 = 0.0;\n    float r2i2_4194304 = 0.0;\n    float r2i2_8388608 = 0.0;\n    float r2i2_16777216 = 0.0;\n    float r2i2_33554432 = 0.0;\n    float r2i2_67108864 = 0.0;\n    float r2", "\n    vec3 z = normalize(cam - focusPoint);\n    vec3 x = normalize(cross(up, z));\n    vec3 y = normalize(cross(z, x));\n\n    return mat4(\n        x.x, x.y, x.z, 0.0,\n        y.x, y.y, y.z, 0.0,\n        z.x, z.y, z.z, 0.0,\n        cam.x, cam.y, cam.z, 1.0\n    );\n}\n\n//projection matrix\nmat", "\n    vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n    vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n    return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n}\n\nvec", "\n    float d = abs(p.x) - w;\n    d = max(d, abs(p.y) - w);\n    d = max(d, abs(p.x) - w * dir);\n    return d;\n}\n\nfloat", "\n    return (x - a) / (b - a);\n}\n\n// AA falloff function, trying lerp instead of smoothstep.\nfloat", "\n    float x = xy.x;\n    float y = func(x);\n    if (y < xy.y && xy.y < y + 1.0)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float y)\n{\n    float x = xy.x;\n    if (y < xy.y && xy.y < y + 1.0)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws explicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float y, float y2)\n{\n    float x = xy.x;\n    if (y < xy.y && xy.y < y + 1.0)\n    {\n        baseCol = curveCol;\n    }\n    else if (y2 < xy.y && xy.y < y2 + 1.0)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float y, float y2, float y3)\n{\n    float x = xy.x;\n    if (y < xy.y && xy.y < y + 1.0)\n    {\n        baseCol = curveCol;\n    }\n    else if (y2 < xy.y && xy.y < y2 + 1.0)\n    {\n        baseCol = curveCol;\n    }\n    else if (y3 < xy.y && xy.y < y3 + 1.0)\n    {\n        baseCol = curveCol;\n    }\n}\n\n// Draws implicit function of x defined in func(x)\nvoid drawFunc(inout vec4 baseCol, vec2 xy, vec4 curveCol, float y, float y2,", "\n    float d=0.;\n    float a=0.;\n    for(int i=0;i<5;i++){\n        float n=float(i)+1.;\n        float t=n*3.1415926535897932384626433832795/2.;\n        vec2 q=p+vec2(cos(t),sin(t))*j;\n        d+=abs(length(q)-n);\n        a+=atan(q.y,q.x);\n    }\n    return d/5.-a/3.1415926535897932384626433832795;\n}\n\nfloat", "\n    return smoothstep(0.0, 1.0, f);\n}\n\nfloat", "\n    c.r = c.r*1.05 - 0.05;\n    c.g = c.g*0.95 + 0.05;\n    c.b = c.b*1.05 - 0.05;\n    return c;\n}\n\n//reduce rgb values of some ranges, similar to EnChromaHsv(), but\n//not quite how human vision works, still helps \"visualizing\"\n//how this apparently enhanches yellow, and mostly filters out green.\nvec", "\n    vec3 d = abs(p) - s;\n    float insideDistance = min(max(d.x,max(d.y,d.z)),0.0);\n    float outsideDistance = length(max(d,0.0));\n    return vec4(insideDistance + outsideDistance,1.0,0.0,0.0);\n}\n\n//hg_sdf\n//return distance to box size (s)\nvec", "\n    float d = sdSphere(p,r.x);\n    float d2 = sdBox(p,r.y);\n    float d3 = sdBox(p,r.z);\n    float d4 = sdBox(p,r.w);\n    float d5 = sdBox(p,r.x);\n    float d6 = sdBox(p,r.y);\n    float d7 = sdBox(p,r.z);\n    float d8 = sdBox(p,r.w);\n    float d9 = sdBox(p,r.x);\n    float d10 = sdBox(p,r.y);\n    float d11 = sdBox(p,r.z);\n    float d12 = sdBox(p,r.w);\n    float d13 = sdBox(p,r.x);\n    float d14 = sdBox(p,r.y);\n    float d15 = sdBox(p,r.z);\n    float d16 = sdBox(p,r.w);\n    float d17 = sdBox(p,r.x);\n    float d18 = sdBox(p,r.y);\n    float d19 = sdBox(p,r.z);\n    float d20 = sdBox(p,r.w);\n    float d21 = sdBox(p,r.x);\n    float d22 = sdBox(p,r.y);\n    float d23 = sdBox(p,r.z);\n    float d24 = sdBox(p,r.w);\n    float d25 = sdBox(p,r.x);\n    float d26 = sdBox(p,r.y);\n    float d27 = sdBox(p,r.z);\n    float d28 = sdBox(p,r.w);\n    float d29 = sdBox(p,r.x);\n    float d30 = sdBox(p,r.y);\n    float d31 = sdBox(", "\n    // Get the material at the current position\n    Material mat = getMaterial(pos);\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 0.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 1.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 2.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 3.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 4.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 5.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 6.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 7.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 8.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 9.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 10.0)\n    {\n        return mat;\n    }\n\n    // If we're at the end of the scene, return the material\n    if (mat.a == 11.0)\n    {\n        return mat;\n", "\n    float a = 2.51f;\n    float b = 0.03f;\n    float c = 2.43f;\n    float d = 0.59f;\n    float e = 0.14f;\n    return clamp((x * (a * x + b)) / (x * (c * x + d) + e), 0.0, 1.0);\n}\n\nvec", "\n    float r = 1e10;\n    for(int i=0; i<10; i++){\n        p = abs(p*2.)-1.;\n        p.x = max(p.x, p.y);\n        p.x = max(p.x, p.z);\n        r = min(r, p.x);\n    }\n    return r;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = (fragCoord.xy - iResolution.xy*.5)/iResolution.y;\n    vec3 p = vec3(uv, 0);\n    float t = iGlobalTime*.5;\n    p.z = t;\n    p.xy *= mat2(cos(t), sin(t), -sin(t), cos(t));\n    float d = m(p);\n    vec3 c = vec3(1.0, 0.5, 0.25) * d;\n    fragColor = vec4(c, 1.0);\n}\n", "\n    vec3 n = normal(p);\n    vec3 l = normalize(lightPos - p);\n    float diffuse = max(dot(n, l), 0.0);\n    float specular = pow(max(dot(reflect(-l, n), normalize(camPos - p)), 0.0), 16.0);\n    return mat(diffuse, specular);\n}\n\n//scene color at position p\nvec", "\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = p*2.02;\n    f += 0.2500*noise( p ); p = p*2.03;\n    f += 0.1250*noise( p ); p = p*2.01;\n    f += 0.0625*noise( p );\n    return f/0.9375;\n}\n\n// returns a fractal noise in a 3D space\nfloat", "\n    vec2 a = vec2(0.0, 0.0);\n    vec2 b = vec2(0.0, 0.0);\n    vec2 c = vec2(0.0, 0.0);\n    vec2 d = vec2(0.0, 0.0);\n    vec2 e = vec2(0.0, 0.0);\n    vec2 f = vec2(0.0, 0.0);\n    vec2 g = vec2(0.0, 0.0);\n    vec2 h = vec2(0.0, 0.0);\n    vec2 i = vec2(0.0, 0.0);\n    vec2 j = vec2(0.0, 0.0);\n    vec2 k = vec2(0.0, 0.0);\n    vec2 l = vec2(0.0, 0.0);\n    vec2 m = vec2(0.0, 0.0);\n    vec2 n = vec2(0.0, 0.0);\n    vec2 o = vec2(0.0, 0.0);\n    vec2 p = vec2(0.0, 0.0);\n    vec2 q = vec2(0.0, 0.0);\n    vec2 r = vec2(0.0, 0.0);\n    vec2 s = vec2(0.0, 0.0);\n    vec2 t = vec2(0.0, 0.0);\n    vec2 u = vec2(0.0, 0.0);\n    vec2 v = vec2(0.0, 0.0);\n    vec2 w = vec2(0.0, 0.0);\n    vec2 x = vec2(0.0, 0.0);\n    vec2 y = vec2(0.0, 0.0);\n    vec2 z = vec2(0", "\n    return dot(u,m);\n}\n\n//return __signed distance of [u] to line trough [a] and [b], b must be normalized.\nfloat", "\n    return dot(u,m);\n}\n\n//return distance of [u] to ray from (0,0) trough [m], m must be normalized.\nfloat", "\n    vec2 d = u - m.xy;\n    return dot(d, normalize(m.zw - m.xy));\n}\n\n//return signed distance of u to line trough m.xy and m.zw\nfloat", "\n  return U.x;\n}\n\nv2 d(v1 U){\n  return U.y;\n}\n\nv2 e(v1 U){\n  return U.z;\n}\n\nv2 f(v1 U){\n  return U.w;\n}\n\nv2 g(v1 U){\n  return U.x;\n}\n\nv2 h(v1 U){\n  return U.y;\n}\n\nv2 i(v1 U){\n  return U.z;\n}\n\nv2 j(v1 U){\n  return U.w;\n}\n\nv2 k(v1 U){\n  return U.x;\n}\n\nv2 l(v1 U){\n  return U.y;\n}\n\nv2 m(v1 U){\n  return U.z;\n}\n\nv2 n(v1 U){\n  return U.w;\n}\n\nv2 o(v1 U){\n  return U.x;\n}\n\nv2 p(v1 U){\n  return U.y;\n}\n\nv2 q(v1 U){\n  return U.z;\n}\n\nv2 r(v1 U){\n  return U.w;\n}\n\nv2 s(v1 U){\n  return U.x;\n}\n\nv2 t(v1 U){\n  return U.y;\n}\n\nv2 u(v1 U){\n  return U.z;\n}\n\nv2 v(v1 U){\n  return U.w;\n}\n\nv2 w(v1 U){\n  return U.x;\n}\n\nv2 x(v1 U){\n  return U.y;\n}\n\nv2 y(v1 U){\n  return U.z;\n}\n\nv2 z(v1 U){\n  return U.w;\n}\n\nv2 A(v1 U){\n  return U.x;\n}\n\nv2 B(v1 U){\n  return U.y;\n}\n\nv2 C(v1 U){\n  return U.z;\n}\n\nv2 D(v1 U", "\n  return U.x;\n}\n\nv2 d(v1 U){\n  return U.x;\n}\n\nv2 e(v1 U){\n  return U.x;\n}\n\nv2 f(v1 U){\n  return U.x;\n}\n\nv2 g(v1 U){\n  return U.x;\n}\n\nv2 h(v1 U){\n  return U.x;\n}\n\nv2 i(v1 U){\n  return U.x;\n}\n\nv2 j(v1 U){\n  return U.x;\n}\n\nv2 k(v1 U){\n  return U.x;\n}\n\nv2 l(v1 U){\n  return U.x;\n}\n\nv2 m(v1 U){\n  return U.x;\n}\n\nv2 n(v1 U){\n  return U.x;\n}\n\nv2 o(v1 U){\n  return U.x;\n}\n\nv2 p(v1 U){\n  return U.x;\n}\n\nv2 q(v1 U){\n  return U.x;\n}\n\nv2 r(v1 U){\n  return U.x;\n}\n\nv2 s(v1 U){\n  return U.x;\n}\n\nv2 t(v1 U){\n  return U.x;\n}\n\nv2 u(v1 U){\n  return U.x;\n}\n\nv2 v(v1 U){\n  return U.x;\n}\n\nv2 w(v1 U){\n  return U.x;\n}\n\nv2 x(v1 U){\n  return U.x;\n}\n\nv2 y(v1 U){\n  return U.x;\n}\n\nv2 z(v1 U){\n  return U.x;\n}\n\nv2 A(v1 U){\n  return U.x;\n}\n\nv2 B(v1 U){\n  return U.x;\n}\n\nv2 C(v1 U){\n  return U.x;\n}\n\nv2 D(v1 U", "\n    return a - dot(a, b) * b;\n}\n\nvec", "\n    float r1 = sqrt(Xi1);\n    float r2 = Xi2;\n    w = mix(A, B, r1);\n    w = mix(w, C, r1);\n    w = mix(w, A, r2);\n    w = normalize(w);\n    wPdf = 1.0 / (2.0 * PI);\n}\n\n//Function which does triangle sampling proportional to their area.\n//You can find more information and pseudocode here:\n// * Stratified Sampling of Spherical Triangles. J Arvo - \u200e1995\n// * Stratified sampling of 2d manifolds. J Arvo - \u200e2001\nvoid sampleSphericalTriangleArea(in vec3 A, in vec3 B, in vec3 C, in float Xi1, in float Xi2, out vec3 w, out float wPdf) {\n    float r1 = sqrt(Xi1);\n    float r2 = Xi2;\n    w = mix(A, B, r1);\n    w = mix(w, C, r1);\n    w = mix(w, A, r2);\n    w = normalize(w);\n    wPdf = 1.0 / (2.0 * (dot(cross(A, B), C) + dot(cross(B, C), A) + dot(cross(C, A), B)));\n}\n\n//Function which does triangle sampling proportional to their area.\n//You can find more information and pseudocode here:\n// * Stratified Sampling of Spherical Triangles. J Arvo - \u200e1995\n// * Stratified sampling of 2d manifolds. J Arvo - \u200e2001\nvoid sampleSphericalTriangleArea(in vec3 A, in vec3 B, in vec3 C, in float Xi1, in float Xi2, out vec3 w, out float wPdf, out vec3 wN) {\n    float r1 = sqrt(Xi1);\n    float r2 = Xi2;\n    w = mix(A, B, r1);\n    w =", "\n  return U.x;\n}\n\nv2 d(v1 U){\n  return U.x;\n}\n\nv2 e(v1 U){\n  return U.x;\n}\n\nv2 f(v1 U){\n  return U.x;\n}\n\nv2 g(v1 U){\n  return U.x;\n}\n\nv2 h(v1 U){\n  return U.x;\n}\n\nv2 i(v1 U){\n  return U.x;\n}\n\nv2 j(v1 U){\n  return U.x;\n}\n\nv2 k(v1 U){\n  return U.x;\n}\n\nv2 l(v1 U){\n  return U.x;\n}\n\nv2 m(v1 U){\n  return U.x;\n}\n\nv2 n(v1 U){\n  return U.x;\n}\n\nv2 o(v1 U){\n  return U.x;\n}\n\nv2 p(v1 U){\n  return U.x;\n}\n\nv2 q(v1 U){\n  return U.x;\n}\n\nv2 r(v1 U){\n  return U.x;\n}\n\nv2 s(v1 U){\n  return U.x;\n}\n\nv2 t(v1 U){\n  return U.x;\n}\n\nv2 u(v1 U){\n  return U.x;\n}\n\nv2 v(v1 U){\n  return U.x;\n}\n\nv2 w(v1 U){\n  return U.x;\n}\n\nv2 x(v1 U){\n  return U.x;\n}\n\nv2 y(v1 U){\n  return U.x;\n}\n\nv2 z(v1 U){\n  return U.x;\n}\n\nv2 A(v1 U){\n  return U.x;\n}\n\nv2 B(v1 U){\n  return U.x;\n}\n\nv2 C(v1 U){\n  return U.x;\n}\n\nv2 D(v1 U", "\n    p.x = abs(p.x);\n    p.y -=.5;\n    return length(p)-.5;\n}\n\n// Torus: A torus is a tube with a hole in the middle.\nfloat", "\n    vec3 q = p;\n    q.xz = mod(q.xz, 2.0) - 1.0;\n    q.y = mod(q.y, 2.0) - 1.0;\n    float d = length(q) - 0.5;\n    float d2 = length(q.xz) - 0.5;\n    float d3 = length(q.yz) - 0.5;\n    float d4 = length(q.xy) - 0.5;\n    float d5 = length(q.xz) - 0.5;\n    float d6 = length(q.yz) - 0.5;\n    float d7 = length(q.xy) - 0.5;\n    float d8 = length(q.xz) - 0.5;\n    float d9 = length(q.yz) - 0.5;\n    float d10 = length(q.xy) - 0.5;\n    float d11 = length(q.xz) - 0.5;\n    float d12 = length(q.yz) - 0.5;\n    float d13 = length(q.xy) - 0.5;\n    float d14 = length(q.xz) - 0.5;\n    float d15 = length(q.yz) - 0.5;\n    float d16 = length(q.xy) - 0.5;\n    float d17 = length(q.xz) - 0.5;\n    float d18 = length(q.yz) - 0.5;\n    float d19 = length(q.xy) - 0.5;\n    float d20 = length(q.xz) - 0.5;\n    float d21 = length(q.yz) - 0.5;\n    float d22 = length(q.xy) - 0.5;\n    float d23 = length(q.xz) - 0.5;\n    float d24 = length(q.yz) -", "\n    float d = length(p) - 0.5;\n    float id = floor(gID);\n    float blink = mod(id, 2.0);\n    if(blink > 0.5){\n        d = abs(d);\n    }\n    return d;\n}\n\n// Recreating part of the distance function to obtain the segment IDs, which in turn is used\n// to create the blink effect.\nfloat", "\n    float t = 0.0;\n    for(int i = 0; i < 128; i++){\n        vec3 p = o + r * t;\n        float d = map(p);\n        if(d < 0.001){\n            return t;\n        }\n        t += d;\n    }\n    return 1000.0;\n}\n\n// Calculate the normal of the surface at a point.\nvec", "\n    float res = 1.0;\n    float tmax = 100.0;\n    float tmin = 0.001;\n    float tstep = tmax/100.0;\n    for(float ti = tmin; ti < tmax; ti += tstep){\n        float h = map(ro + lp*ti);\n        if(h < 0.001){\n            return 0.0;\n        }\n        float y = h*h/(2.0*k*ti);\n        float d = sqrt(h*h-y*y);\n        res = min(res, 32.0*d/ti);\n    }\n    return clamp(res, 0.0, 1.0);\n}\n\n// The main raymarching function.\nfloat", "\n    vec3 e = vec3(0.001, 0., 0.);\n    vec3 n = vec3(0.);\n    n += sdf(p + e.yxx) - sdf(p - e.yxx);\n    n += sdf(p + e.xyx) - sdf(p - e.xyx);\n    n += sdf(p + e.xxy) - sdf(p - e.xxy);\n    n.x = abs(n.x);\n    n.y = abs(n.y);\n    n.z = abs(n.z);\n    n = normalize(n);\n    edge = min(min(n.x, n.y), n.z);\n    crv = (sdf(p + e.yxx) + sdf(p - e.yxx) + sdf(p + e.xyx) + sdf(p - e.xyx) + sdf(p + e.xxy) + sdf(p - e.xxy)) / 6.0;\n    return n;\n}\n\n// Normal calculation, with some edging and curvature bundled in.\nvec", "\n    vec3 v = p3 - t;\n    return vec4(dot(v, m[0]), dot(v, m[1]), dot(v, m[2]), 1.0);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n   ", "\n    float d = p.x;\n    d = max(d, -p.y);\n    d = max(d, p.y - 1.0);\n    return d;\n}\n\n// Distance to the pattern.\nfloat", "\n    float r = length(q);\n    float theta = atan(q.y, q.x);\n    if(dir == 1.){\n        return theta;\n    }else{\n        return r;\n    }\n}\n\n// Get the color of the arc pixel.\nvec", "\n    vec3 v = p3 - t;\n    vec3 b = vec3(dot(v, n[0]), dot(v, n[1]), dot(v, n[2]));\n    return vec4(b.x, b.y, b.z, 1.0 - b.x - b.y - b.z);\n}\n\n// computes barycentric coordinates for point from the fourth vertex,\n// three plane normals with premultiplied inverse determinant\nvec", "\n  vec4 v = q - p;\n  vec4 w = r - p;\n  float a = dot(v, v);\n  float b = dot(v, w);\n  float c = dot(w, w);\n  float bb4ac = b * b - a * c;\n  if (bb4ac <= 0.0) return 0.0;\n  return (a * c - b * b) / bb4ac;\n}\n\n// Find the (squared) distance to the line segment in R3 but\n// using homogeneous coordinates.\nfloat", "\n    float d = length(p);\n    float a = atan(p.y, p.x);\n    float s = sin(a * 10.0);\n    float c = cos(a * 10.0);\n    float r = lW * 0.5;\n    float w = r * (1.0 - s * s);\n    float d1 = d - w;\n    float d2 = d + w;\n    float d3 = d1 * d1 + r * r;\n    float d4 = d2 * d2 + r * r;\n    float d5 = sqrt(d3) * sqrt(d4);\n    float d6 = d5 / (d1 + d2);\n    float d7 = d6 * 0.5;\n    float d8 = d7 * c;\n    float d9 = d7 * s;\n    float d10 = d8 + d9;\n    float d11 = d10 * 0.5;\n    float d12 = d11 * 0.5;\n    float d13 = d12 * 0.5;\n    float d14 = d13 * 0.5;\n    float d15 = d14 * 0.5;\n    float d16 = d15 * 0.5;\n    float d17 = d16 * 0.5;\n    float d18 = d17 * 0.5;\n    float d19 = d18 * 0.5;\n    float d20 = d19 * 0.5;\n    float d21 = d20 * 0.5;\n    float d22 = d21 * 0.5;\n    float d23 = d22 * 0.5;\n    float d24 = d23 * 0.5;\n    float d25 = d24 * 0.5;\n    float d26 = d25 * 0.5;\n    float d27 = d26 * 0.5;\n    float d28 = d27 * 0.5;\n    float d", "\n    vec2 grid = fract(p);\n    vec2 d = abs(ddx) + abs(ddy);\n    vec2 offset = vec2(0.5, 0.5) - grid;\n    vec2 r = vec2(\n        dot2(greaterThan(d.xy, offset.xy)),\n        dot2(greaterThan(d.yx, offset.yx))\n    );\n    return r.x * r.y;\n}\n\n// grid ratio\nfloat", "\n    vec2 p = n;\n    float d = dot(p,p);\n    mr = p;\n    mg = p;\n    for( int i=0; i<4; i++ )\n    {\n        p.x = n.x;\n        p.y = f.y;\n        float d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = f.x;\n        p.y = n.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = f.x;\n        p.y = f.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = n.x;\n        p.y = n.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = n.x;\n        p.y = f.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = f.x;\n        p.y = n.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = f.x;\n        p.y = f.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = n.x;\n        p.y = n.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=d2; mr=p; }\n        p.x = n.x;\n        p.y = f.y;\n        d2 = dot(p,p);\n        if( d2<d ) { d=", "\n    return vec2(lerp(pos_inicial.x, pos_final.x, t), lerp(pos_inicial.y, pos_final.y, t));\n}\n\n//////////// POSICAO PONTOS\n\n//////////// POSICAO PONTOS\nvec", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\n// vec3 to vec3 hash.\nvec", "\n  p = fract(p * vec2(123.34, 345.45));\n  p += dot(p, p + 23.45);\n  return fract(p.x * p.y);\n}\n\n// vec2 to vec2 hash.\nfloat", "\n    vec2 a = p1 - p0;\n    vec2 b = p2 - p0;\n    vec2 c = p2 - p1;\n    float a2 = dot(a, a);\n    float b2 = dot(b, b);\n    float c2 = dot(c, c);\n    float denom = a2 * (b2 + c2 - a2) + b2 * c2;\n    vec2 ab = (a2 * b + a * b2 + a * c2) / denom;\n    vec2 bc = (b2 * c + b * c2 + b * a2) / denom;\n    vec2 ca = (c2 * a + c * a2 + c * b2) / denom;\n    return ab * a2 + bc * b2 + ca * c2;\n}\n\n// Triangle's circumcenter: The center of the circumscribed circle, which in essence is the\n// smallest circle that can contain a triangle.\nvec", "\n    float a = length(p0 - p1);\n    float b = length(p1 - p2);\n    float c = length(p2 - p0);\n    float s = (a + b + c) / 2.0;\n    return sqrt(s * (s - a) * (s - b) * (s - c)) / s;\n}\n\n// The radius of the triangle's circumcircle:\nfloat", "\n    vec2 v1 = h2 - h1;\n    vec2 v2 = h3 - h1;\n    vec2 v3 = h3 - h2;\n    float a = dot(v1, v1);\n    float b = dot(v2, v2);\n    float c = dot(v3, v3);\n    float d = dot(v1, v2);\n    float e = dot(v1, v3);\n    float f = dot(v2, v3);\n    float g = dot(h1, h1);\n    float h = dot(h2, h2);\n    float i = dot(h3, h3);\n    float j = dot(h1, h2);\n    float k = dot(h1, h3);\n    float l = dot(h2, h3);\n    float m = a * (b + c - a) * (a + b - c) * (a + c - b);\n    float n = b * (a + c - b) * (b + a - c) * (b + c - a);\n    float o = c * (a + b - c) * (c + a - b) * (c + b - a);\n    float p = d * (e + f - d) * (d + e - f) * (d + f - e);\n    float q = e * (d + f - e) * (e + d - f) * (e + f - d);\n    float r = f * (d + e - f) * (f + d - e) * (f + e - d);\n    float s = g * (h + i - g) * (g + h - i) * (g + i - h);\n    float t = h * (g + i - h) * (h + g - i) * (h + i - g);\n    float u = i * (g + h - i) * (i + g - h) * (i + h - g);\n    float v = j * (k + l - j) * (j + k - l) * (j + l - k);\n    float w = k * (j + l - k)", "\n    vec2 p0 = p;\n    vec2 p1 = p;\n    vec2 p2 = p;\n    vec2 p3 = p;\n    vec2 p4 = p;\n    vec2 p5 = p;\n    vec2 p6 = p;\n    vec2 p7 = p;\n    vec2 p8 = p;\n    vec2 p9 = p;\n    vec2 p10 = p;\n    vec2 p11 = p;\n    vec2 p12 = p;\n    vec2 p13 = p;\n    vec2 p14 = p;\n    vec2 p15 = p;\n    vec2 p16 = p;\n    vec2 p17 = p;\n    vec2 p18 = p;\n    vec2 p19 = p;\n    vec2 p20 = p;\n    vec2 p21 = p;\n    vec2 p22 = p;\n    vec2 p23 = p;\n    vec2 p24 = p;\n    vec2 p25 = p;\n    vec2 p26 = p;\n    vec2 p27 = p;\n    vec2 p28 = p;\n    vec2 p29 = p;\n    vec2 p30 = p;\n    vec2 p31 = p;\n    vec2 p32 = p;\n    vec2 p33 = p;\n    vec2 p34 = p;\n    vec2 p35 = p;\n    vec2 p36 = p;\n    vec2 p37 = p;\n    vec2 p38 = p;\n    vec2 p39 = p;\n    vec2 p40 = p;\n    vec2 p41 = p;\n    vec2 p42 = p;\n    vec2 p43 = p;\n    vec2 p44 = p;\n    vec2 p45 = p;\n    vec2 p46 = p;\n    vec2", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col, 1.0);\n}\n", "\n  p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));\n  return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);\n}\n\n// Standard 3x3 hash algorithm.\nvec", "\n    /////////////////////////////////////////////////////////////////////////////\n    // Compute the intersection between the ray and the sphere.\n    //\u8ba1\u7b97\u5c04\u7ebf\u548c\u7403\u4f53\u4e4b\u95f4\u7684\u4ea4\u70b9\u3002\n    /////////////////////////////////////////////////////////////////////////////\n    vec3 L = sph.center - ray.origin;\n    float tca = dot(L, ray.direction);\n    if (tca < 0.0) return false;\n    float d2 = dot(L, L) - tca * tca;\n    if (d2 > sph.radius * sph.radius) return false;\n    float thc = sqrt(sph.radius * sph.radius - d2);\n    t = tca - thc;\n    if (t < tmin || t > tmax) {\n        t = tca + thc;\n        if (t < tmin || t > tmax) return false;\n    }\n\n    /////////////////////////////////////////////////////////////////////////////\n    // Compute the normal at the intersection point.\n    //\u8ba1\u7b97\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u3002\n    /////////////////////////////////////////////////////////////////////////////\n    hitPos = ray.origin + t * ray.direction;\n    hitNormal = normalize(hitPos - sph.center);\n\n    return true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n// If there is one or two such intersections, outputs the value of the \n// smaller t, the position of the intersection (hitPos) and the normal \n// vector at the intersection (hitNormal).\n//\u8ba1\u7b97\u5e73\u9762\u548c\u5c04\u7ebf\u4e4b\u95f4\u7684\u4ea4\u96c6\u3002\n//\u5982\u679c\u6709\u4e00\u4e2a\u4ea4\u53c9\u70b9\uff0c\u5176\u4e2dray\u53c2\u6570t\u4ecb\u4e8etmin\u548ctmax\u4e4b\u95f4\uff0c\u5219\u8fd4\u56detrue\uff0c\u5426\u5219\u8fd4\u56defalse\u3002\n//\u5982\u679c\u6709\u4e00\u4e2a\u6216\u4e24\u4e2a\u8fd9\u6837\u7684\u4ea4\u70b9\uff0c\u5219\u8f93\u51fa\u8f83\u5c0f\u7684t\u7684\u503c\uff0c\u4ea4\u70b9\u7684\u4f4d\u7f6e\uff08hitPos\uff09\u548c\u4ea4\u70b9\u5904\u7684\u6cd5\u7ebf\u5411\u91cf\uff08hitNormal\uff09\u3002\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t pl, in Ray_t ray, in float tmin, in float tmax,\n                     out float t, out vec3 hitPos, out vec", "\n    // Compute the intersection of the ray and the sphere.\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - a * c;\n    if ( discriminant > 0.0 )\n    {\n        float temp = (-b - sqrt( discriminant )) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            return true;\n        }\n        temp = (-b + sqrt( discriminant )) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            return true;\n        }\n    }\n    return false;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a sphere and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectSphere( in Sphere_t sph, in Ray_t ray, in float tmin, in float tmax, out float t )\n{\n    // Compute the intersection of the ray and the sphere.\n    vec3 oc = ray.origin - sph.center;\n    float a = dot( ray.direction, ray.direction );\n    float b = dot( oc, ray.direction );\n    float c = dot( oc, oc ) - sph.radius * sph.radius;\n    float discriminant = b * b - a * c;\n    if ( discriminant > 0.0 )\n    {\n        float temp = (-b - sqrt( discriminant )) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            t = temp;\n            return true;\n        }\n        temp = (-b + sqrt( discriminant )) / a;\n        if ( temp < tmax && temp > tmin )\n        {\n            t = temp;\n            return true;\n        }\n    }\n    return", "\n    /////////////////////////////////////////////////////////////////////////////\n    // TODO:\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219\u8fd4\u56de\u80cc\u666f\u989c\u8272\n    /////////////////////////////////////////////////////////////////////////////\n    // 1. \u904d\u5386\u573a\u666f\u4e2d\u7684\u6240\u6709\u7269\u4f53\uff0c\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\n    // 2. \u5982\u679c\u6709\u4ea4\u70b9\uff0c\u5219\u8ba1\u7b97\u5149\u7ebf\u4e0e\u7269\u4f53\u7684\u4ea4\u70b9\u5904\u7684\u989c\u8272\n    // 3. \u5982\u679c\u6ca1\u6709\u4ea4\u70b9\uff0c\u5219", "\n    vec2 d0 = p1 - p0;\n    vec2 d1 = p2 - p1;\n    vec2 d2 = p0 - p2;\n\n    vec2 d0d1 = d0 * d1;\n    vec2 d1d2 = d1 * d2;\n    vec2 d2d0 = d2 * d0;\n\n    vec2 d0d1d2 = d0d1 * d2;\n    vec2 d1d2d0 = d1d2 * d0;\n    vec2 d2d0d1 = d2d0 * d1;\n\n    vec2 d0d1d2d0 = d0d1d2 * d0;\n    vec2 d1d2d0d1 = d1d2d0 * d1;\n    vec2 d2d0d1d2 = d2d0d1 * d2;\n\n    vec2 d0d1d2d0d1 = d0d1d2d0 * d1;\n    vec2 d1d2d0d1d2 = d1d2d0d1 * d2;\n    vec2 d2d0d1d2d0 = d2d0d1d2 * d0;\n\n    vec2 d0d1d2d0d1d2 = d0d1d2d0d1 * d2;\n    vec2 d1d2d0d1d2d0 = d1d2d0d1d2 * d0;\n    vec2 d2d0d1d2d0d1 = d2d0d1d2d0 * d1;\n\n    vec2 d0d1d2d0d1d2d0 = d0d1d2d0d1d2 * d0;\n    vec2 d1d2d0d1d2d0d1 = d1d2d0d1d2d0 * d1;\n    vec2 d2d0d1d2d0d1d2 = d2d0d1d2d0d1", "\n    vec3 p01 = mix(p0,p1,0.5);\n    vec3 p12 = mix(p1,p2,0.5);\n    vec3 p23 = mix(p2,p3,0.5);\n    vec3 p012 = mix(p01,p12,0.5);\n    vec3 p123 = mix(p12,p23,0.5);\n    vec3 p0123 = mix(p012,p123,0.5);\n    vec3 p01234 = mix(p0123,p3,0.5);\n    return bound3(p01234-vec3(0.001),p01234+vec3(0.001));\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/www/articles/bezierbbox/bezierbbox.htm)\n//---------------------------------------------------------------------------------------\nbound3 BezierAABB( in vec3 p0, in vec3 p1, in vec3 p2, in vec3 p3, in float t )\n{\n    vec3 p01 = mix(p0,p1,t);\n    vec3 p12 = mix(p1,p2,t);\n    vec3 p23 = mix(p2,p3,t);\n    vec3 p012 = mix(p01,p12,t);\n    vec3 p123 = mix(p12,p23,t);\n    vec3 p0123 = mix(p012,p123,t);\n    vec3 p01234 = mix(p0123,p3,t);\n    return bound3(p01234-vec3(0.001),p01234+vec3(0.001));\n}\n\n//---------------------------------------------------------------------------------------\n// bounding box for a bezier (http://iquilezles.org/", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = vec3(uv,0.5+0.5*sin(iTime));\n    fragColor = vec4(col,1.0);\n}", "\n    return -0.5 * (cos(k * PI) - 1.0);\n}\n\n/**\n * Sinusoidal In Easing Curve\n */\nfloat", "\n    const vec4 C = vec4(0.211324865405187,  // (3.0-sqrt(3.0))/6.0\n                        0.366025403784439,  // 0.5*(sqrt(3.0)-1.0)\n                        -0.577350269189626, // -1.0 + 2.0 * C.x\n                        0.024390243902439); // 1.0 / 41.0\n    // First corner\n    vec2 i  = floor(v + dot(v, C.yy));\n    vec2 x0 = v - i + dot(i, C.xx);\n\n    // Other corners\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n\n    // Permutations\n    i = mod(i, 289.0);\n    vec3 p = permute(permute(i.y + vec3(0.0, i1.y, 1.0)) + i.x + vec3(0.0, i1.x, 1.0));\n\n    vec3 m = max(0.5 - vec3(dot(x0, x0), dot(x12.xy, x12.xy), dot(x12.zw, x12.zw)), 0.0);\n    m = m*m;\n    m = m*m;\n\n    // Gradients: 41 points uniformly over a line, mapped onto a diamond.\n    // The ring size 17*17 = 289 is close to a multiple of 41 (41*7 = 287)\n    vec3 x = 2.0 * fract(p *", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iGlobalTime;\n    float r = length(uv-0.5);\n    float a = atan(uv.y-0.5,uv.x-0.5);\n    float d = r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*r*", "\n    return vec2(coord.x / res.x * 4.0 - 2.0, coord.y / res.y * 4.0 - 2.0);\n}\n\n// Compute the number of iterations of the Julia set for a given point.\nint", "\n    // filter kernel\n    const vec2 w = vec2(1.0);\n    // analytical integral (box filter)\n    // vec2 i = 2.0*(abs(fract((p-0.5*w)*0.5)-0.5)-abs(fract((p+0.5*w)*0.5)-0.5))/w;\n    // xor pattern\n    bvec2 b = bvec2( mod( floor(p.x), 2.0 ) == mod( floor(p.y), 2.0 ) );\n    float i = float( b.x == b.y );\n    return i;\n}\n\nfloat", "\n    float r = rgb.r;\n    float g = rgb.g;\n    float b = rgb.b;\n\n    float max = max(r, max(g, b));\n    float min = min(r, min(g, b));\n\n    float h = (max - min) / (max + min);\n    float c = (max + min) / 2.0;\n    float v = max;\n\n    return vec3(h, c, v);\n}\n\n// Converts a value from HCV (Hue, Chroma, Value) to linear RGB\nvec", "\n    vec3 p3 = fract(vec3(p.xyx) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yzx+33.33);\n    return fract((p3.xx+p3.yz)*p3.zy);\n}\n\n// vec3 to vec3 hash.\nvec", "\n    const float eps = 0.0001;\n    const vec2 h = vec2(eps,0);\n    return normalize( vec3( map(p+h.xyy).x - map(p-h.xyy).x,\n                            map(p+h.yxy).x - map(p-h.yxy).x,\n                            map(p+h.yyx).x - map(p-h.yyx).x ) );\n}\n\n// Distance estimator.\nfloat", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// random hash\nfloat", "\n    float d = length(pos);\n    float w = width * 0.5;\n    float r = radius * 0.5;\n    float dd = d - r;\n    float ww = w * 0.5;\n    float ddw = dd - ww;\n    float ddww = ddw * ddw;\n    float ddww2 = ddww * ddww;\n    float ddww3 = ddww2 * ddw;\n    float ddww4 = ddww3 * ddw;\n    float ddww5 = ddww4 * ddw;\n    float ddww6 = ddww5 * ddw;\n    float ddww7 = ddww6 * ddw;\n    float ddww8 = ddww7 * ddw;\n    float ddww9 = ddww8 * ddw;\n    float ddww10 = ddww9 * ddw;\n    float ddww11 = ddww10 * ddw;\n    float ddww12 = ddww11 * ddw;\n    float ddww13 = ddww12 * ddw;\n    float ddww14 = ddww13 * ddw;\n    float ddww15 = ddww14 * ddw;\n    float ddww16 = ddww15 * ddw;\n    float ddww17 = ddww16 * ddw;\n    float ddww18 = ddww17 * ddw;\n    float ddww19 = ddww18 * ddw;\n    float ddww20 = ddww19 * ddw;\n    float ddww21 = ddww20 * ddw;\n    float ddww22 = ddww21 * ddw;\n    float ddww23 = ddww22 * ddw;\n    float ddww24 = ddww23 * ddw;\n    float ddww25 =", "\n    const vec4 C = vec4(0.211324865405187, 0.366025403784439, -0.577350269189626, 0.024390243902439);\n    vec2 i  = floor(v + dot(v, C.yy) );\n    vec2 x0 = v -   i + dot(i, C.xx);\n    vec2 i1;\n    i1 = (x0.x > x0.y)? vec2(1.0, 0.0) : vec2(0.0, 1.0);\n    vec4 x12 = x0.xyxy + C.xxzz;\n    x12.xy -= i1;\n    i = mod(i, 289.0);\n    vec3 p = permute( permute( i.y + vec3(0.0, i1.y, 1.0 )) + i.x + vec3(0.0, i1.x, 1.0 ));\n    vec3 m = max(0.5 - vec3(dot(x0,x0), dot(x12.xy,x12.xy), dot(x12.zw,x12.zw)), 0.0);\n    m = m*m ;\n    m = m*m ;\n    vec3 x = 2.0 * fract(p * C.www) - 1.0;\n    vec3 h = abs(x) - 0.5;\n    vec3 ox = floor(x + 0.5);\n    vec3 a0 = x - ox;\n    m *= 1.79284291400159 - 0.85373472095314 * ( a0*a0 + h*h );\n    vec3 g;\n    g.x  = a0.x  * x0.x  + h.x  *", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 ro = vec3(0,0,0);\n    vec3 rd = normalize(vec3(uv,1));\n    float r = 0.5;\n    float t = intersect(ro,rd,r);\n    if(t>0.0){\n        vec3 p = ro + rd*t;\n        vec3 n = normal(p,r);\n        vec3 c = vec3(0.5)+0.5*n;\n        fragColor = vec4(c,1);\n    }else{\n        fragColor = vec4(0,0,0,1);\n    }\n}\n\nfloat", "\n    vec3 i = floor(p);\n    vec3 f = fract(p);\n    f = f*f*(3.0-2.0*f);\n    float n = dot(i, vec3(1.0, 57.0, 21.0));\n    vec3 u = vec3(n+13.0, n+51.0, n+19.0);\n    vec3 r = fract(u*0.1);\n    float rx = mix(mix(dot(r, vec3(1.0, 57.0, 21.0)), dot(r, vec3(4.0, 58.0, 22.0)), f.x), mix(dot(r, vec3(17.0, 59.0, 23.0)), dot(r, vec3(19.0, 61.0, 25.0)), f.x), f.y);\n    float ry = mix(mix(dot(r, vec3(13.0, 60.0, 24.0)), dot(r, vec3(15.0, 62.0, 26.0)), f.x), mix(dot(r, vec3(29.0, 63.0, 27.0)), dot(r, vec3(31.0, 65.0, 29.0)), f.x), f.y);\n    float rz = mix(mix(dot(r, vec3(41.0, 67.0, 30.0)), dot(r, vec3(43.0, 69.0, 32.0)), f.x), mix(dot(r, vec3(53.0, 71.0, 34.0)), dot(r, vec3(57.0, 73.0, 35.0)), f.x), f.y);\n    return (mix(rx, ry, f.z)+(1.0-f.z)*r", "\n    // Tile the point in log-spherical space.\n    tp = log(p);\n    tp.xz = mod(tp.xz, 2.0 * PI);\n\n    // Rotate the point in log-spherical space.\n    rp = tp;\n    rp.x = -rp.x;\n\n    // Compute the scaling factor.\n    mul = exp(length(tp) - 1.0);\n\n    // Compute the un-tiled point in log-spherical space.\n    sp = tp / mul;\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`: point in log-spherical space without offset or tiling\n- out `tp`: point in tiled log-spherical space\n- out `rp`: point in rotated tiled log-spherical space\n- out `mul`: total amount of scaling applied at this point\n*/\nvoid tile(in vec2 p, out vec2 sp, out vec2 tp, out vec2 rp, out float mul)\n{\n    // Tile the point in log-spherical space.\n    tp = mod(p, 2.0 * PI);\n\n    // Rotate the point in log-spherical space.\n    rp = tp;\n    rp.x = -rp.x;\n\n    // Compute the scaling factor.\n    mul = exp(length(tp) - 1.0);\n\n    // Compute the un-tiled point in log-spherical space.\n    sp = tp / mul;\n}\n\n/*\nTile space in a log-spherical grid.\n\n- in `p`: input point\n- out `sp`: point in log-spherical space without offset or tiling\n- out `tp`: point in tiled log-spherical space\n- out `rp`: point in rotated tiled log-spherical space\n- out `mul`: total amount of scaling applied at this point\n*/\nvoid tile(in float p, out float sp, out float tp, out float rp,", "\n    vec2 d = vec2(1000.0, 0.0);\n    d = opU(d, vec2(SDFSphere(p - vec3(0.0, 0.0, 0.0), 1.0), 1.0));\n    d = opU(d, vec2(SDFSphere(p - vec3(0.0, 0.0, 0.0), 1.0), 2.0));\n    return d;\n}\n\nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n    // 1.0 is the size of the square\n    // 0.5 is the size of the angled square\n    // 0.25 is the size of the angled square\n    // 0.125 is the size of the angled square\n    // 0.0625 is the size of the angled square\n    // 0.03125 is the size of the angled square\n    // 0.015625 is the size of the angled square\n    // 0.0078125 is the size of the angled square\n    // 0.00390625 is the size of the angled square\n    // 0.001953125 is the size of the angled square\n    // 0.0009765625 is the size of the angled square\n    // 0.00048828125 is the size of the angled square\n    // 0.000244140625 is the size of the angled square\n    // 0.0001220703125 is the size of the angled square\n    // 0.00006103515625 is the size of the angled square\n    // 0.000030517578125 is the size of the angled square\n    // 0.0000152587890625 is the size of the angled square\n    // 0.00000762939453125 is the size of the angled square\n    // 0.000003814697265625 is the size of the angled square\n    // 0.0000019073486328125 is the size of the angled square\n    // 0.00000095367431640625 is the size of the angled square\n    // 0.000", "\n    vec3 boxPos = pos - vec3(0.0, 0.0, 0.0);\n    float dist = length(boxPos) - 0.5;\n    float matID = 1.0;\n    return vec2(dist, matID);\n}\n\n// returns the distance to our rotating box and the its associated material ID packed into a vec2\nvec", "\n    float dist = length(pos - vec3(0.0, 0.0, 0.0)) - 0.5;\n    return vec2(dist, 0.0);\n}\n\n// returns the distance to the ground plane and the associated material ID packed into a vec2\nvec", "\n    vec2 res = vec2(100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000", "\n    vec4 color = vec4(0.0);\n    float dist = 0.0;\n    float totalDist = 0.0;\n    float t = 0.0;\n    float maxDist = 100.0;\n    float maxSteps = 100.0;\n    float eps = 0.001;\n    float lightIntensity = 0.5;\n    float ambientIntensity = 0.1;\n    float specularIntensity = 0.5;\n    float specularPower = 10.0;\n    float shadowIntensity = 0.5;\n    float shadowMaxDist = 10.0;\n    float shadowMaxSteps = 100.0;\n    float shadowEps = 0.001;\n    float shadowBias = 0.001;\n    float shadowFade = 0.001;\n    float shadowFadeDist = 10.0;\n    float shadowFadeSteps = 100.0;\n    float shadowFadeEps = 0.001;\n    float shadowFadeBias = 0.001;\n    float shadowFadeFade = 0.001;\n    float shadowFadeFadeDist = 10.0;\n    float shadowFadeFadeSteps = 100.0;\n    float shadowFadeFadeEps = 0.001;\n    float shadowFadeFadeBias = 0.001;\n    float shadowFadeFadeFade = 0.001;\n    float shadowFadeFadeFadeDist = 10.0;\n    float shadowFadeFadeFadeSteps = 100.0;\n    float shadowFadeFadeFadeEps = 0.001;\n    float shadowFadeFadeFadeBias = 0.001;\n    float shadowFadeFadeFadeFade = 0.001;\n    float shadowFadeFadeFadeFadeDist = 10.0;\n    float shadowFadeFadeFadeFadeSteps = 100.0;\n    float shadowFadeFadeFadeFadeEps = 0.001;", "\n    vec3 m = 1.0/rd;\n    vec3 n = m*ro;\n    vec3 k = abs(m)*rad;\n    vec3 t1 = -n - k;\n    vec3 t2 = -n + k;\n    float tN = max( max( t1.x, t1.y ), t1.z );\n    float tF = min( min( t2.x, t2.y ), t2.z );\n    return vec2( tN, tF );\n}\n\n//box intersection from iq\n//https://www.shadertoy.com/view/ld23DV\nvec", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Output to screen\n    fragColor = vec4(uv,0.5+0.5*sin(iTime),1.0);\n}", "\n    return dot(pos, plane.normal) + plane.distance;\n}\n\n/// @brief Get signed-distance funciton weight value of sphere.\nfloat", "\n    ivec3 ix0 = ix;\n    ivec3 ix1 = ix0 + 1;\n    vec3 fx0 = fx;\n    vec3 fx1 = fx - ivec3(1);\n    vec3 fx2 = fx - ivec3(2);\n    vec3 fx3 = fx - ivec3(3);\n    vec3 fx4 = fx - ivec3(4);\n    vec3 fx5 = fx - ivec3(5);\n    vec3 fx6 = fx - ivec3(6);\n    vec3 fx7 = fx - ivec3(7);\n    vec3 fx8 = fx - ivec3(8);\n    vec3 fx9 = fx - ivec3(9);\n    vec3 fx10 = fx - ivec3(10);\n    vec3 fx11 = fx - ivec3(11);\n    vec3 fx12 = fx - ivec3(12);\n    vec3 fx13 = fx - ivec3(13);\n    vec3 fx14 = fx - ivec3(14);\n    vec3 fx15 = fx - ivec3(15);\n    vec3 fx16 = fx - ivec3(16);\n    vec3 fx17 = fx - ivec3(17);\n    vec3 fx18 = fx - ivec3(18);\n    vec3 fx19 = fx - ivec3(19);\n    vec3 fx20 = fx - ivec3(20);\n    vec3 fx21 = fx - ivec3(21);\n    vec3 fx22 = fx - ivec3(22);\n    vec3 fx23 = fx - ivec3(23);\n    vec3 fx24 = fx - ivec3(24);\n    vec3 fx25 = f", "\n    float f = 0.0;\n    float amp = 0.5;\n    float freq = 1.0;\n    for(int i = 0; i < 5; i++){\n        f += amp * noise(fxyz);\n        fxyz *= freq;\n        amp *= 0.5;\n        freq *= 2.0;\n    }\n    return f;\n}\n\n// 3D Perlin Noise\nfloat", "\n    p.xz = abs(p.xz);\n    p.x -= clamp( p.x, 0.0, h );\n    return length(p) - r;\n}\n\nfloat", "\n    float sphere = length(p) - 1.0;\n    float plane = p.y;\n    float box = length(max(abs(p.xz) - vec2(1.0, 0.5), 0.0));\n    float d = min(sphere, plane);\n    d = min(d, box);\n    return d;\n}\n\n/***********************\nThe normal function.\nWe need to know the normal of the surface at a given point.\n\nThe normal is the gradient of the SDF function.\n***********************/\nvec", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    return normalize(vec3(\n        map(p + eps.xyy) - map(p - eps.xyy),\n        map(p + eps.yxy) - map(p - eps.yxy),\n        map(p + eps.yyx) - map(p - eps.yyx)\n    ));\n}\n\n// Compute the color of a point on the surface of our objects\nvec", "\n    return max(dot(n,l),0.0)*d;\n}\n\nfloat", "\n    float k0 = dot(rd,rd);\n    float k1 = dot(rd,ro);\n    float k2 = dot(ro,ro) - ra*ra;\n    float h = k1*k1 - k0*k2;\n    if( h<0.0 ) return -1.0;\n    h = sqrt(h);\n    float t1 = -k1 - h;\n    float t2 = -k1 + h;\n    if( t1<0.0 ) return t2;\n    if( t2<0.0 ) return t1;\n    return min(t1,t2);\n}\n\n// f(x,y,z) = x^4 + y^4 + z^4 - ra^4\nfloat", "\n    vec2 w = max(abs(dpdx), abs(dpdy));\n    vec2 a = p + 0.5*w;\n    vec2 b = p - 0.5*w;\n    vec2 i = floor(a);\n    vec2 f = fract(a);\n    float va = 0.0;\n    float vb = 0.0;\n    float va1 = 0.0;\n    float va2 = 0.0;\n    float vb1 = 0.0;\n    float vb2 = 0.0;\n    if (i.x+i.y < 1.0) {\n        va = mix( dot(hash22(i+vec2(0.0,0.0)),f-vec2(0.0,0.0) ),\n                  dot(hash22(i+vec2(1.0,0.0)),f-vec2(1.0,0.0) ), f.x);\n        vb = mix( dot(hash22(i+vec2(0.0,1.0)),f-vec2(0.0,1.0) ),\n                  dot(hash22(i+vec2(1.0,1.0)),f-vec2(1.0,1.0) ), f.x);\n    } else {\n        va = mix( dot(hash22(i+vec2(1.0,0.0)),f-vec2(1.0,0.0) ),\n                  dot(hash22(i+vec2(0.0,0.0)),f-vec2(0.0,0.0) ), f.x);\n        vb = mix( dot(hash22(i+vec2(1.0,1.0)),f-vec2(1.0,1.0) ),\n                  dot(hash22(i+vec2(0.0,1.0)),f-vec2(0.0,1.0) ), f.x);\n    }\n    va1 = mix( va, vb, f.y );\n    if (i.x+i.y < 1.0) {\n        va = mix( dot", "\n    // Set the background color.\n    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);\n\n    // Set the camera position.\n    g_Camera.SetPosition(0.0f, 0.0f, 10.0f);\n\n    // Set the camera target.\n    g_Camera.SetTarget(0.0f, 0.0f, 0.0f);\n\n    // Set the camera projection parameters.\n    g_Camera.SetProjection(45.0f, 1.0f, 1.0f, 100.0f);\n\n    // Set the camera viewport.\n    g_Camera.SetViewport(0, 0, g_ViewportWidth, g_ViewportHeight);\n\n    // Set the camera aspect ratio.\n    g_Camera.SetAspectRatio((float)g_ViewportWidth / (float)g_ViewportHeight);\n\n    // Set the camera frustum.\n    g_Camera.SetFrustum(45.0f, 1.0f, 1.0f, 100.0f);\n\n    // Set the camera view.\n    g_Camera.SetView(g_Camera.GetPosition(), g_Camera.GetTarget(), g_Camera.GetUp());\n\n    // Set the camera projection.\n    g_Camera.SetProjection(45.0f, 1.0f, 1.0f, 100.0f);\n\n    // Set the camera viewport.\n    g_Camera.SetViewport(0, 0, g_ViewportWidth, g_ViewportHeight);\n\n    // Set the camera aspect ratio.\n    g_Camera.SetAspectRatio((float)g_ViewportWidth / (float)g_ViewportHeight);\n\n    // Set the camera frustum.\n    g_Camera.SetFrustum(45.0f, 1.0f, 1.0f, 100.0f);\n\n    // Set the camera view.\n    g", "\n    // Compute the intersection between the ray and the sphere\n    // (see the lecture slides for the derivation)\n    //\n    // The ray is given by:\n    //\n    //  P(t) = ray.origin + t * ray.direction\n    //\n    // The sphere is given by:\n    //\n    //  (P(t) - sph.center) dot (P(t) - sph.center) = sph.radius * sph.radius\n    //\n    // The above equation can be rewritten as:\n    //\n    //  t^2 * ray.direction dot ray.direction + 2 * t * ray.direction dot (ray.origin - sph.center) + (ray.origin - sph.center) dot (ray.origin - sph.center) - sph.radius * sph.radius = 0\n    //\n    // The quadratic equation is:\n    //\n    //  a * t^2 + b * t + c = 0\n    //\n    // where:\n    //\n    //  a = ray.direction dot ray.direction\n    //  b = 2 * ray.direction dot (ray.origin - sph.center)\n    //  c = (ray.origin - sph.center) dot (ray.origin - sph.center) - sph.radius * sph.radius\n    //\n    // The quadratic equation can be solved using the quadratic formula:\n    //\n    //  t = (-b +/- sqrt(b^2 - 4 * a * c)) / (2 * a)\n    //\n    // The smaller root is the one we are looking for.\n    //\n    // If the smaller root is between tmin and tmax, then the ray intersects\n    // the sphere.\n    //\n    // If the smaller root is outside the range [tmin, tmax], then the ray\n    // misses the sphere.\n    //\n    // If the smaller root is inside the range [tmin, tmax], then the ray\n    // intersects the sphere.\n    //\n    // If the smaller root is negative, then the ray misses the sphere.\n    //\n    // If the smaller root is positive, then the ray intersects the sphere", "\n\tvec3_t L = ray.origin - sph.center;\n\tfloat a = dot( ray.direction, ray.direction );\n\tfloat b = 2.0 * dot( ray.direction, L );\n\tfloat c = dot( L, L ) - sph.radius * sph.radius;\n\tfloat disc = b * b - 4.0 * a * c;\n\n\tif ( disc < 0.0 )\n\t\treturn false;\n\n\tfloat t = ( -b - sqrt( disc ) ) / ( 2.0 * a );\n\n\tif ( t < tmin )\n\t\tt = ( -b + sqrt( disc ) ) / ( 2.0 * a );\n\n\tif ( t < tmin || t > tmax )\n\t\treturn false;\n\n\treturn true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a plane and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectPlane( in Plane_t plane, in Ray_t ray, in float tmin, in float tmax )\n{\n\tfloat denom = dot( plane.normal, ray.direction );\n\n\tif ( abs( denom ) < 0.0001 )\n\t\treturn false;\n\n\tfloat t = dot( plane.point - ray.origin, plane.normal ) / denom;\n\n\tif ( t < tmin || t > tmax )\n\t\treturn false;\n\n\treturn true;\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes intersection between a triangle and a ray.\n// Returns true if there is an intersection where the ray parameter t is\n// between tmin and tmax, otherwise returns false.\n/////////////////////////////////////////////////////////////////////////////\nbool IntersectTriangle( in Triangle_t tri, in Ray_t ray, in float tmin, in float tmax )\n{\n\tvec3_t edge1 = tri.v1 - tri.v0;\n\tvec3_t edge2 = tri.v2 - tri.v0;\n\tvec3_t pvec = cross( ray.direction, edge2 );\n\tfloat det = dot( edge1, p", "\n    /////////////////////////////////////////////////////////////////////////////\n    // TODO: Implement this function.\n    /////////////////////////////////////////////////////////////////////////////\n    hasHit = false;\n    hitPos = vec3(0.0);\n    hitNormal = vec3(0.0);\n    k_rg = vec3(0.0);\n\n    /////////////////////////////////////////////////////////////////////////////\n    // End of TODO.\n    /////////////////////////////////////////////////////////////////////////////\n\n    return vec3(0.0);\n}\n\n/////////////////////////////////////////////////////////////////////////////\n// Computes the color of the pixel at (x, y) by casting a ray into the scene\n// and returning the color computed at the nearest intersection point.\n/////////////////////////////////////////////////////////////////////////////\nvec", "\n    float res = 1.0;\n    float t = mint;\n    for( int i=0; i<16; i++ )\n    {\n        float h = map( ro + rd*t );\n        res = min( res, 8.0*h/t );\n        t += clamp( h, 0.02, 0.10 );\n        if( h<0.001 || t>tmax ) break;\n    }\n    return clamp( res, 0.0, 1.0 );\n}\n\nfloat", "\n    axis = normalize(axis);\n    float s = sin(angle);\n    float c = cos(angle);\n    float oc = 1.0 - c;\n    \n    return mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n                oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n                oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n}\n\nmat", "\n    // the color of the ray\n    vec3 color = vec3(0.0);\n\n    // the distance the ray has traveled\n    float dist = 0.0;\n\n    // the direction of the ray\n    vec3 ray_dir = dir;\n\n    // the position of the ray\n    vec3 ray_pos = start;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_i = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_i = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_l = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_l = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_i_prev = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_i_prev = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_l_prev = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_l_prev = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_i_prev_prev = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_i_prev_prev = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_l_prev_prev = 0.0;\n\n    // the distance the ray has traveled along the light ray\n    float light_dist_l_prev_prev = 0.0;\n\n    // the distance the ray has traveled along the ray\n    float ray_dist_i_prev", "\n    vec3 sample_dir = normalize(sample_pos - surface_normal);\n    float sample_dist = length(sample_pos - surface_normal);\n    float sample_angle = dot(sample_dir, light_dir);\n\n    float sample_intensity = max(0.0, sample_angle);\n    float sample_attenuation = pow(sample_dist, 2.0);\n\n    return sample_intensity * sample_attenuation * background_col;\n}\n\n/*\nThis is the main function that renders the planet.\n\nIt takes in the position of the planet, the camera, the light direction, the background color, and the time.\n\nIt returns the color of the planet.\n*/\nvec", "\n    vec3 color = vec3(0.0);\n    float dist = 0.0;\n    float depth = 0.0;\n    float shadow = 0.0;\n    float shadow_dist = 0.0;\n    float shadow_depth = 0.0;\n    float shadow_shadow = 0.0;\n    float shadow_shadow_dist = 0.0;\n    float shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_depth = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow = 0.0;\n    float shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_shadow_dist = 0.0;\n    float shadow_shadow_shadow_shadow_", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 camPos = vec3(0.0, 0.0, 0.0);\n    vec3 camDir = normalize(vec3(uv, 1.0));\n    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0));\n\n    // get the color of the atmosphere\n    vec3 color = atmosphere(camPos, camDir, lightDir);\n\n    // output the color\n    fragColor = vec4(color, 1.0);\n}\n", "\n    vec3 s0_r0 = s0 - r0;\n    float b = dot(s0_r0, rd);\n    float c = dot(s0_r0, s0_r0) - (sr * sr);\n    float b2_ac = (b * b) - c;\n    if (b2_ac > 0.0) {\n        float t = b - sqrt(b2_ac);\n        if (t > 0.0) {\n            return t;\n        }\n    }\n    return -1.0;\n}\n\n//-----------------------------------------------------------------------\nfloat", "\n    vec3 color = vec3(0.0);\n    vec3 normal = vec3(0.0);\n    vec3 position = vec3(0.0);\n    float distance = 0.0;\n    float specular = 0.0;\n    float roughness = 0.0;\n    float metallic = 0.0;\n    float occlusion = 0.0;\n    float alpha = 0.0;\n    float ao = 0.0;\n    float shadow = 0.0;\n    float shadowDistance = 0.0;\n    float shadowFade = 0.0;\n    float shadowFadeDistance = 0.0;\n    float shadowFadeFactor = 0.0;\n    float shadowFadeFactor2 = 0.0;\n    float shadowFadeFactor3 = 0.0;\n    float shadowFadeFactor4 = 0.0;\n    float shadowFadeFactor5 = 0.0;\n    float shadowFadeFactor6 = 0.0;\n    float shadowFadeFactor7 = 0.0;\n    float shadowFadeFactor8 = 0.0;\n    float shadowFadeFactor9 = 0.0;\n    float shadowFadeFactor10 = 0.0;\n    float shadowFadeFactor11 = 0.0;\n    float shadowFadeFactor12 = 0.0;\n    float shadowFadeFactor13 = 0.0;\n    float shadowFadeFactor14 = 0.0;\n    float shadowFadeFactor15 = 0.0;\n    float shadowFadeFactor16 = 0.0;\n    float shadowFadeFactor17 = 0.0;\n    float shadowFadeFactor18 = 0.0;\n    float shadowFadeFactor19 = 0.0;\n    float shadowFadeFactor20 = 0.0;\n    float shadowFadeFactor21 = 0.0;\n    float shadowFadeFactor22 = 0.0;\n    float shadowFadeFactor23 = 0.0;\n    float shadowFadeFactor24 = 0.0;\n    float shadowFadeF", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = length(uv-0.5);\n    float a = atan(uv.y-0.5,uv.x-0.5);\n    float d = abs(r-0.25);\n    float f = smoothstep(0.0,0.01,d);\n    float s = sin(a*10.0+t*10.0);\n    float c = cos(a*10.0+t*10.0);\n    float l = length(uv-vec2(0.5,0.5));\n    float aa = atan(uv.y-0.5,uv.x-0.5);\n    float b = sin(aa*10.0+t*10.0);\n    float c2 = cos(aa*10.0+t*10.0);\n    float d2 = abs(l-0.25);\n    float f2 = smoothstep(0.0,0.01,d2);\n    float s2 = sin(aa*10.0+t*10.0);\n    float c3 = cos(aa*10.0+t*10.0);\n    float l2 = length(uv-vec2(0.5,0.5));\n    float aa2 = atan(uv.y-0.5,uv.x-0.5);\n    float b2 = sin(aa2*10.0+t*10.0);\n    float c4 = cos(aa2*10.0+t*10.0);\n    float d4 = abs(l2-0.25);\n    float f4 = smoothstep(0.0,0.01,d4);\n    float s4 = sin(aa2*10.0+t*10.0);\n    float c5 = cos(aa2*10.0+t*10.0);\n    float l3 = length(uv-vec2(", "\n    vec3 sample_color = vec3(0.0);\n    vec3 ray_direction = normalize(ray_target - ray_origin);\n    vec3 ray_position = ray_origin;\n    float ray_length = 0.0;\n    float ray_length_squared = 0.0;\n    float ray_length_squared_max = RAY_LENGTH_MAX * RAY_LENGTH_MAX;\n    float ray_length_squared_min = RAY_LENGTH_MIN * RAY_LENGTH_MIN;\n    float ray_length_squared_min_inv = 1.0 / ray_length_squared_min;\n    float ray_length_squared_max_inv = 1.0 / ray_length_squared_max;\n    float ray_length_squared_min_inv_sq = ray_length_squared_min_inv * ray_length_squared_min_inv;\n    float ray_length_squared_max_inv_sq = ray_length_squared_max_inv * ray_length_squared_max_inv;\n    float ray_length_squared_min_inv_sq_inv = 1.0 / ray_length_squared_min_inv_sq;\n    float ray_length_squared_max_inv_sq_inv = 1.0 / ray_length_squared_max_inv_sq;\n    float ray_length_squared_min_inv_sq_inv_sq = ray_length_squared_min_inv_sq_inv * ray_length_squared_min_inv_sq_inv;\n    float ray_length_squared_max_inv_sq_inv_sq = ray_length_squared_max_inv_sq_inv * ray_length_squared_max_inv_sq_inv;\n    float ray_length_squared_min_inv_sq_inv_sq_inv = 1.0 / ray_length_squared_min_inv_sq_inv_sq;\n    float ray_length_squared_max_inv_sq_inv_sq_inv = 1.0 / ray_length_squared_max_inv_sq", "\n    vec2 q = p*2.0;\n    vec2 i = floor(q);\n    vec2 f = fract(q);\n    float d = (i.x+i.y)%2.0;\n    float m = (i.x+i.y+d)%2.0;\n    float n = (i.x+i.y+1.0-d)%2.0;\n    float o = (i.x+i.y+1.0-m)%2.0;\n    float s = (i.x+i.y+1.0-n)%2.0;\n    float t = (i.x+i.y+1.0-o)%2.0;\n    float u = (i.x+i.y+1.0-s)%2.0;\n    float v = (i.x+i.y+1.0-t)%2.0;\n    float w = (i.x+i.y+1.0-u)%2.0;\n    float x = (i.x+i.y+1.0-v)%2.0;\n    float y = (i.x+i.y+1.0-w)%2.0;\n    float z = (i.x+i.y+1.0-x)%2.0;\n    float a = (i.x+i.y+1.0-y)%2.0;\n    float b = (i.x+i.y+1.0-z)%2.0;\n    float c = (i.x+i.y+1.0-a)%2.0;\n    float e = (i.x+i.y+1.0-b)%2.0;\n    float g = (i.x+i.y+1.0-c)%2.0;\n    float h = (i.x+i.y+1.0-e)%2.0;\n    float i1 = (i.x+i.y+1.0-g)%2.0;\n    float j = (i.x+i", "\n    return length(p) - 1.0;\n}\n\n// Get Normal of the sphere\nvec", "\n    vec3 Pi = floor(P);\n    vec3 Pf = P - Pi;\n\n    vec3 w = Pf * Pf * (3.0 - 2.0 * Pf);\n\n    return \n        mix(\n            mix(\n                mix( dot( random3( Pi + vec3(0.0,0.0,0.0) ), Pf - vec3(0.0,0.0,0.0) ), \n                    dot( random3( Pi + vec3(1.0,0.0,0.0) ), Pf - vec3(1.0,0.0,0.0) ), w.x),\n                mix( dot( random3( Pi + vec3(0.0,1.0,0.0) ), Pf - vec3(0.0,1.0,0.0) ), \n                    dot( random3( Pi + vec3(1.0,1.0,0.0) ), Pf - vec3(1.0,1.0,0.0) ), w.x),\n                w.y),\n            mix(\n                mix( dot( random3( Pi + vec3(0.0,0.0,1.0) ), Pf - vec3(0.0,0.0,1.0) ), \n                    dot( random3( Pi + vec3(1.0,0.0,1.0) ), Pf - vec3(1.0,0.0,1.0) ), w.x),\n                mix( dot( random3( Pi + vec3(0.0,1.0,1.0) ), Pf - vec3(0.0,1.0,1.0) ), \n                    dot( random3( Pi + vec3(1.0,1.0,1.0) ), Pf - vec3(1.0,1.0,1.0) ), w.x),\n                w.y),\n            w.z);\n}\n\nfloat", "\n    return fract(sin(x)*43758.5453);\n}\n\n// 1D noise\nfloat", "\n    float d = length(p) - 1.0;\n    return vec2(d, 1.0);\n}\n\nvec", "\n    float d = length(p) - 1.0;\n    return vec2(d, 1.0);\n}\n\nvec", "\n    vec2 pa = p - a, ba = b - a;\n    float h = clamp( dot(pa,ba)/dot(ba,ba), 0.0, 1.0 );\n    return length( pa - ba*h ) - d;\n}\n\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = length(uv-0.5);\n    float a = atan(uv.y-0.5,uv.x-0.5);\n    float d = abs(r-0.25);\n    float f = smoothstep(0.0,0.01,d);\n    float s = sin(a*10.0+t*10.0);\n    float c = cos(a*10.0+t*10.0);\n    float l = length(uv-vec2(0.5,0.5));\n    float aa = atan(uv.y-0.5,uv.x-0.5);\n    float b = sin(aa*10.0+t*10.0);\n    float c2 = cos(aa*10.0+t*10.0);\n    float l2 = length(uv-vec2(0.5,0.5));\n    float a2 = atan(uv.y-0.5,uv.x-0.5);\n    float b2 = sin(a2*10.0+t*10.0);\n    float c3 = cos(a2*10.0+t*10.0);\n    float l3 = length(uv-vec2(0.5,0.5));\n    float a3 = atan(uv.y-0.5,uv.x-0.5);\n    float b3 = sin(a3*10.0+t*10.0);\n    float c4 = cos(a3*10.0+t*10.0);\n    float l4 = length(uv-vec2(0.5,0.5));\n    float a4 = atan(uv.y-0.5,uv.x-0.5);\n    float b4 = sin(a4*10.0+t*10.0);\n    float c5 = cos(a4*10.0+", "\n    p = abs(p);\n    return max(p.x, p.y) + min(p.x, p.y) * 0.8660254037844386;\n}\n\n// Distance function for a hexagon.\nfloat", "\n    float2 p = float2(ix, iy);\n    float2 f = floor(p);\n    p -= f;\n    float2 u = p*p*(3.0-2.0*p);\n    float2 a = float2(f.x, f.y) + float2(0.0, 1.0);\n    float2 b = float2(f.x, f.y) + float2(1.0, 0.0);\n    float2 c = float2(f.x, f.y) + float2(1.0, 1.0);\n    float2 d = float2(f.x, f.y) + float2(0.0, 2.0);\n    float2 e = float2(f.x, f.y) + float2(1.0, 2.0);\n    float2 f2 = float2(f.x, f.y) + float2(2.0, 0.0);\n    float2 g = float2(f.x, f.y) + float2(2.0, 1.0);\n    float2 h = float2(f.x, f.y) + float2(2.0, 2.0);\n    float k0 = dot(a, a);\n    float k1 = dot(b, b);\n    float k2 = dot(c, c);\n    float k3 = dot(d, d);\n    float k4 = dot(e, e);\n    float k5 = dot(f2, f2);\n    float k6 = dot(g, g);\n    float k7 = dot(h, h);\n    float2 g0 = float2(k0, k0)*float2(k0, k0);\n    float2 g1 = float2(k1, k1)*float2(k1, k1);\n    float2 g2 = float2(k2, k2)*float2(k2, k2);\n    float2 g3 = float2(k3, k3)*float2(k3, k3);\n    float2 g4 = float2(k4, k4)*float2(k4,", "\n    float t = time;\n    float a = sin(t) * 0.5 + 0.5;\n    float b = cos(t) * 0.5 + 0.5;\n    float c = sin(t) * 0.5 + 0.5;\n    float d = cos(t) * 0.5 + 0.5;\n    float e = sin(t) * 0.5 + 0.5;\n    float f = cos(t) * 0.5 + 0.5;\n    float g = sin(t) * 0.5 + 0.5;\n    float h = cos(t) * 0.5 + 0.5;\n    float i = sin(t) * 0.5 + 0.5;\n    float j = cos(t) * 0.5 + 0.5;\n    float k = sin(t) * 0.5 + 0.5;\n    float l = cos(t) * 0.5 + 0.5;\n    float m = sin(t) * 0.5 + 0.5;\n    float n = cos(t) * 0.5 + 0.5;\n    float o = sin(t) * 0.5 + 0.5;\n    float p = cos(t) * 0.5 + 0.5;\n    float q = sin(t) * 0.5 + 0.5;\n    float r = cos(t) * 0.5 + 0.5;\n    float s = sin(t) * 0.5 + 0.5;\n    float t = cos(t) * 0.5 + 0.5;\n    float u = sin(t) * 0.5 + 0.5;\n    float v = cos(t) * 0.5 + 0.5;\n    float w = sin(t) * 0.5 + 0.5;\n    float x = cos(t) * 0.5 + 0.5;\n    float y = sin(t) * 0.5 + 0.5;\n    float z = cos(t) * 0.5 + 0.5;\n    float A = sin(t) * ", "\n    float d = p;\n    d = sdBox(p, vec3(1.0, 1.0, 1.0));\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 1.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 2.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 3.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 4.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 5.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 6.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 7.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p + vec3(0.0, 0.0, 8.0), vec3(1.0, 1.0, 1.0)), 0.1);\n    d = op", "\n    return vec2(atan(z.x, z.y), length(z));\n}\n\nvec", "\n    return vec2(z.x * w.x - z.y * w.y, z.x * w.y + z.y * w.x);\n}\n\nvec", "\n    // 3d simplex noise\n    // https://www.shadertoy.com/view/4djSRW\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33RB\n    // https://www.shadertoy.com/view/Xs33", "\n    float time = mod( iTime, 25.0 );\n    float wave = cos( p.x * 10.0 + time * 0.5 );\n    float dist = length( p );\n    float rings = exp( -dist * dist );\n    return wave * rings;\n}\n\n// the color of the droplet is based on the distance to the center\n// the color is a gradient from blue to red\n// the color is also attenuated by the distance to the center\n// the color is also attenuated by the wave displacement\nvec", "\n    float d = sdSphere(p, 1.0);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d = opSmoothUnion(d, sdBox(p, vec3(1.0, 1.0, 1.0)), 0.1);\n    d", "\n    float d = sdBox(rp, vec3(1.0, 1.0, 1.0));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d = max(d, -sdBox(rp, vec3(1.0, 1.0, 1.0)));\n    d", "\n    return 1.0 - clamp((d - start) / (end - start), 0.0, 1.0);\n}\n\nvec", "\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n    // The hexagonal grid is a bit more complicated than a regular grid.\n   ", "\n    vec2 q = p;\n    q.x = mod(q.x, 2.0);\n    q.y = mod(q.y, 2.0);\n    vec2 d = vec2(0.0);\n    if(q.x > 1.0){\n        q.x = 2.0 - q.x;\n    }\n    if(q.y > 1.0){\n        q.y = 2.0 - q.y;\n    }\n    if(q.x > q.y){\n        d.x = q.x;\n    }else{\n        d.y = q.y;\n    }\n    return d;\n}\n\n// The distance function for the Truchet tile.\nfloat", "\n\n\t// Set the color of the pixel to a constant color\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}", "\n    float theta = atan(pc.y, pc.x);\n    float r = a + b*theta;\n    float d = length(pc);\n    float d_r = abs(d - r);\n    if(d_r < 0.001){\n        return theta;\n    }\n    return -1.0;\n}\n\n//https://en.wikipedia.org/wiki/Archimedean_spiral\n//If on spiral, return number of degrees (theta).\n//If not on spiral, return -1.0\nfloat", "\n  return  smoothstep( pct-0.02, pct, st.y) -\n          smoothstep( pct, pct+0.02, st.y);\n}\n\nvoid main() {\n  vec2 st = gl_FragCoord.xy/u_resolution.xy;\n  vec3 color = vec3(0.0);\n\n  // Plot a line\n  color = vec3(plot(st,0.5));\n\n  gl_FragColor = vec4(color,1.0);\n}\n", "\n    // The initial domain is a circle with radius 1.0.\n    // The center of the circle is at the origin.\n    // The circle is divided into N segments.\n    // The segments are numbered from 0 to N-1.\n    // The segment number is calculated as follows:\n    // \n    // 1. The angle of the segment is calculated as follows:\n    //    angle = (2.0 * PI) / N\n    // 2. The segment number is calculated as follows:\n    //    segment = int(mod(atan(v.y, v.x) / angle, N))\n    // 3. The segment number is returned as a vec3 with the x, y, and z components\n    //    equal to the segment number.\n    // 4. The x, y, and z components of the vec3 are then used to calculate the\n    //    position of the point on the circle.\n    // 5. The position of the point on the circle is returned as a vec3.\n    // \n    // The segment number is used to calculate the position of the point on the\n    // circle. The position of the point on the circle is then used to calculate\n    // the position of the point on the circle. The position of the point on the\n    // circle is then used to calculate the position of the point on the circle.\n    // The position of the point on the circle is then used to calculate the\n    // position of the point on the circle. The position of the point on the\n    // circle is then used to calculate the position of the point on the circle.\n    // The position of the point on the circle is then used to calculate the\n    // position of the point on the circle. The position of the point on the\n    // circle is then used to calculate the position of the point on the circle.\n    // The position of the point on the circle is then used to calculate the\n    // position of the point on the circle. The position of the point on the\n    // circle is then used to calculate the position of the point on the circle.\n    // The position of the point on the circle is then used to calculate the\n    // position of the point on the circle. The position of the point on the\n    // circle is", "\n  float r = circ.x;\n  float a = circ.y;\n  float b = circ.z;\n  float c = a * a + b * b;\n  float d = r * r;\n  float e = a * p.x + b * p.y;\n  float f = a * a - b * b;\n  float g = d - e * e / c;\n  float h = sqrt(g);\n  float i = e * h / c;\n  float j = sqrt(c);\n  float k = (d - h * h) / c;\n  float l = (e * h - i * j) / c;\n  float m = (e * i + h * k) / c;\n  float n = (h * l + i * m) / c;\n  float o = (i * l - h * m) / c;\n  float p = (h * k - i * l) / c;\n  float q = (i * m + h * n) / c;\n  float r = (h * o - i * p) / c;\n  float s = (i * n + h * r) / c;\n  float t = (h * q - i * s) / c;\n  float u = (i * r + h * t) / c;\n  float v = (h * u - i * t) / c;\n  float w = (i * q + h * v) / c;\n  float x = (h * w - i * v) / c;\n  float y = (i * x + h * y) / c;\n  float z = (h * y - i * x) / c;\n  float A = (i * z + h * w) / c;\n  float B = (h * A - i * w) / c;\n  float C = (i * B + h * z) / c;\n  float D = (h * C - i * B) / c;\n  float E = (i * D + h * C) / c;\n  float F = (h * E - i * D) / c;\n  float G = (i * F + h * E) / c;", "\n    return vec2(p.x, 1.0 - p.y);\n}\n\n// Mouse pointer inversion.\nvec", "\n    vec3 color = vec3(0.0);\n\n    // Get the normal\n    vec3 normal = getNormal(march);\n\n    // Get the material\n    Material material = getMaterial(march);\n\n    // Get the light\n    vec3 light = getLight(march);\n\n    // Get the shadow\n    float shadow = getShadow(march);\n\n    // Get the specular\n    float specular = getSpecular(march, light, normal);\n\n    // Get the diffuse\n    float diffuse = getDiffuse(march, light, normal);\n\n    // Get the ambient\n    float ambient = getAmbient(march);\n\n    // Get the fresnel\n    float fresnel = getFresnel(march, light, normal);\n\n    // Get the reflection\n    vec3 reflection = getReflection(march, light, normal);\n\n    // Get the refraction\n    vec3 refraction = getRefraction(march, light, normal);\n\n    // Get the fresnel refraction\n    float fresnelRefraction = getFresnelRefraction(march, light, normal);\n\n    // Get the fresnel reflection\n    float fresnelReflection = getFresnelReflection(march, light, normal);\n\n    // Get the fresnel refraction\n    float fresnelRefraction2 = getFresnelRefraction2(march, light, normal);\n\n    // Get the fresnel reflection\n    float fresnelReflection2 = getFresnelReflection2(march, light, normal);\n\n    // Get the fresnel refraction\n    float fresnelRefraction3 = getFresnelRefraction3(march, light, normal);\n\n    // Get the fresnel reflection\n    float fresnelReflection3 = getFresnelReflection3(march, light, normal);\n\n    // Get the fresnel refraction\n    float fresnelRefraction4 = getFresnelRefraction4(march, light, normal);\n\n    // Get the fresnel reflection\n    float fresnelReflection4 = getFresnelReflection4(march, light, normal);\n\n    // Get the fresnel ref", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = 0.5 + 0.5*cos(iTime+uv.xyx+vec3(0,2,4));\n\n    // Output to screen\n    fragColor = vec4(col,1.0);\n}\n", " // Input (x, y) pixel coordinate\n\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Convert to polar coordinates\n    vec2 p = uv * 2.0 - 1.0;\n    float r = length(p);\n    float a = atan(p.y, p.x);\n\n    // Convert to HSB\n    float h = a / (2.0 * PI) + 0.5;\n    float s = 1.0;\n    float b = r;\n\n    // Convert to RGB\n    vec3 rgb = hsb2rgb(vec3(h, s, b));\n\n    // Output to screen\n    fragColor = vec4(rgb, 1.0);\n}", "\n    float h = fract(hash);\n    float i = floor(hash);\n    float j = floor(i / 12.0);\n    float k = i - j * 12.0;\n    float l = j % 3.0;\n    float m = k % 4.0;\n    float n = k / 4.0;\n    float o = l + m * 0.5;\n    float p = n + o * 0.25;\n    float q = p * 2.0 - 1.0;\n    float r = (l + m * 0.5) * 0.5;\n    float s = (n + o * 0.25) * 0.25;\n    float t = r * 2.0 - 1.0;\n    float u = s * 2.0 - 1.0;\n    float v = t * 2.0 - 1.0;\n    float w = u * 2.0 - 1.0;\n    float x = v * 2.0 - 1.0;\n    float y = w * 2.0 - 1.0;\n    float z = x * 2.0 - 1.0;\n    float a = y * 2.0 - 1.0;\n    float b = z * 2.0 - 1.0;\n    float c = a * 2.0 - 1.0;\n    float d = b * 2.0 - 1.0;\n    float e = c * 2.0 - 1.0;\n    float f = d * 2.0 - 1.0;\n    float g = e * 2.0 - 1.0;\n    float h = f * 2.0 - 1.0;\n    float i = g * 2.0 - 1.0;\n    float j = h * 2.0 - 1.0;\n    float k = i * 2.0 - 1.0;\n    float l = j * 2.0 - 1.0;\n    float m = k * 2.0 - 1.", "\n    X.z = mod(X.z, 1.0);\n    X.xy = mod(X.xy, 1.0);\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n    X.z = X.z * X.z;\n    X.xy = X.xy * X.xy;\n   ", "\n  float plane = p.y;\n  float wave = sin(p.x * 10.0) * sin(p.z * 10.0);\n  return plane + wave;\n}\n\n/* scene normal */\nvec", "\n    vec3 rayToTarget = targetPos - ray.origin;\n    float rayToTargetLength = length( rayToTarget );\n    float rayToTargetLengthSq = rayToTargetLength * rayToTargetLength;\n    float rayToTargetDot = dot( ray.direction, rayToTarget );\n    float rayToTargetDotSq = rayToTargetDot * rayToTargetDot;\n    float rayToTargetDotSqMinusRadiusSq = rayToTargetDotSq - rayToTargetLengthSq + ( 0.0001 * 0.0001 );\n    float rayToTargetDotSqMinusRadiusSqSq = rayToTargetDotSqMinusRadiusSq * rayToTargetDotSqMinusRadiusSq;\n    float rayToTargetDotSqMinusRadiusSqSqSq = rayToTargetDotSqMinusRadiusSqSq * rayToTargetDotSqMinusRadiusSqSq;\n    float rayToTargetDotSqMinusRadiusSqSqSqSq = rayToTargetDotSqMinusRadiusSqSqSq * rayToTargetDotSqMinusRadiusSqSqSq;\n    float rayToTargetDotSqMinusRadiusSqSqSqSqSq = rayToTargetDotSqMinusRadiusSqSqSqSq * rayToTargetDotSqMinusRadiusSqSqSqSq;\n    float rayToTargetDotSqMinusRadiusSqSqSqSqSqSq = rayToTargetDotSqMinusRadiusSqSqSqSqSq * rayToTargetDotSqMinusRadiusSqSqSqSqSq;\n    float rayToTargetDotSqMinusRadiusSqSqSqSqSqSqSq = rayToTargetDotSqMinusRadiusSqSqSqSqSqSq * rayToTargetDotSqMinusRadiusSqSqSqSqSqSq", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col, 1.0);\n}", "\n    float d = length(p) - 1.0;\n    return vec4(d, 1.0, 0.0, 0.0);\n}\n\n//---Essential Ray Marching Function\nvec", "\n\n    float t = length( targetPos - ray.origin );\n    float r = lightDiameter * 0.5;\n    float b = blur;\n\n    float a = r * r - b * b;\n    float b2 = t * t * 2.0 - 4.0 * a;\n    float det = b2 * b2 - 4.0 * a * t * t;\n\n    if ( det < 0.0 ) {\n        return 0.0;\n    }\n\n    float t1 = ( -b2 - sqrt( det ) ) / ( 2.0 * a );\n    float t2 = ( -b2 + sqrt( det ) ) / ( 2.0 * a );\n\n    float tmin = min( t1, t2 );\n    float tmax = max( t1, t2 );\n\n    if ( tmin > tmax ) {\n        float tmp = tmin;\n        tmin = tmax;\n        tmax = tmp;\n    }\n\n    if ( tmin > t || tmax < 0.0 ) {\n        return 0.0;\n    }\n\n    tmin = max( tmin, 0.0 );\n\n    float result = ( tmax - tmin ) / ( t * 2.0 );\n    result = 1.0 - result;\n\n    return result;\n}\n\n// BOKEH\nfloat", "\n    float d = sdSphere(p, 1.0);\n    return vec2(d, 1.0);\n}\n\nvec", "\n    float i = floor(x);\n    float f = fract(x);\n    f = f * f * (3.0 - 2.0 * f);\n    return mix(hash(i), hash(i + 1.0), f);\n}\n\n// Fractal noise by iq\n// https://www.shadertoy.com/view/XslGRr\nfloat", "\n    vec2 v0 = p2 - p1;\n    vec2 v1 = p3 - p1;\n    vec2 v2 = uv - p1;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u = 1.0 - v - w;\n    return (u >= 0.0) && (v >= 0.0) && (w >= 0.0);\n}\n\n//Check if uv inside triangle using barycentric coords\n//https://en.wikipedia.org/wiki/Barycentric_coordinate_system#Conversion_between_barycentric_and_Cartesian_coordinates\nbool in_triangle(vec3 p1, vec3 p2, vec3 p3, vec3 uv){\n    vec3 v0 = p2 - p1;\n    vec3 v1 = p3 - p1;\n    vec3 v2 = uv - p1;\n    float d00 = dot(v0, v0);\n    float d01 = dot(v0, v1);\n    float d11 = dot(v1, v1);\n    float d20 = dot(v2, v0);\n    float d21 = dot(v2, v1);\n    float denom = d00 * d11 - d01 * d01;\n    float v = (d11 * d20 - d01 * d21) / denom;\n    float w = (d00 * d21 - d01 * d20) / denom;\n    float u", "\n    vec2 p = uv;\n    float r = start_radius;\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r2*r2;\n    float r5 = r2*r3;\n    float r6 = r2*r4;\n    float r7 = r2*r5;\n    float r8 = r2*r6;\n    float r9 = r2*r7;\n    float r10 = r2*r8;\n    float r11 = r2*r9;\n    float r12 = r2*r10;\n    float r13 = r2*r11;\n    float r14 = r2*r12;\n    float r15 = r2*r13;\n    float r16 = r2*r14;\n    float r17 = r2*r15;\n    float r18 = r2*r16;\n    float r19 = r2*r17;\n    float r20 = r2*r18;\n    float r21 = r2*r19;\n    float r22 = r2*r20;\n    float r23 = r2*r21;\n    float r24 = r2*r22;\n    float r25 = r2*r23;\n    float r26 = r2*r24;\n    float r27 = r2*r25;\n    float r28 = r2*r26;\n    float r29 = r2*r27;\n    float r30 = r2*r28;\n    float r31 = r2*r29;\n    float r32 = r2*r30;\n    float r33 = r2*r31;\n    float r34 = r2*r32;\n    float r35 = r2*r33;\n    float r36 = r2*r34;\n    float r37 = r2*r35;\n    float r38 = r2*", "\n    float r = circumradius;\n    float r2 = r*r;\n    float r3 = r2*r;\n    float r4 = r2*r2;\n    float r5 = r4*r;\n    float r6 = r4*r2;\n    float r7 = r6*r;\n    float r8 = r6*r2;\n    float r9 = r8*r;\n    float r10 = r8*r2;\n    float r11 = r10*r;\n    float r12 = r10*r2;\n    float r13 = r12*r;\n    float r14 = r12*r2;\n    float r15 = r14*r;\n    float r16 = r14*r2;\n    float r17 = r16*r;\n    float r18 = r16*r2;\n    float r19 = r18*r;\n    float r20 = r18*r2;\n    float r21 = r20*r;\n    float r22 = r20*r2;\n    float r23 = r22*r;\n    float r24 = r22*r2;\n    float r25 = r24*r;\n    float r26 = r24*r2;\n    float r27 = r26*r;\n    float r28 = r26*r2;\n    float r29 = r28*r;\n    float r30 = r28*r2;\n    float r31 = r30*r;\n    float r32 = r30*r2;\n    float r33 = r32*r;\n    float r34 = r32*r2;\n    float r35 = r34*r;\n    float r36 = r34*r2;\n    float r37 = r36*r;\n    float r38 = r36*r2;\n    float r39 = r38*r;\n    float r40 = r38", "\n    float r = circumradius;\n    float r2 = r*r;\n    float r4 = r2*r2;\n    float r6 = r4*r2;\n    float r8 = r6*r2;\n    float r10 = r8*r2;\n    float r12 = r10*r2;\n    float r14 = r12*r2;\n    float r16 = r14*r2;\n    float r18 = r16*r2;\n    float r20 = r18*r2;\n    float r22 = r20*r2;\n    float r24 = r22*r2;\n    float r26 = r24*r2;\n    float r28 = r26*r2;\n    float r30 = r28*r2;\n    float r32 = r30*r2;\n    float r34 = r32*r2;\n    float r36 = r34*r2;\n    float r38 = r36*r2;\n    float r40 = r38*r2;\n    float r42 = r40*r2;\n    float r44 = r42*r2;\n    float r46 = r44*r2;\n    float r48 = r46*r2;\n    float r50 = r48*r2;\n    float r52 = r50*r2;\n    float r54 = r52*r2;\n    float r56 = r54*r2;\n    float r58 = r56*r2;\n    float r60 = r58*r2;\n    float r62 = r60*r2;\n    float r64 = r62*r2;\n    float r66 = r64*r2;\n    float r68 = r66*r2;\n    float r70 = r68*r2;\n    float r72 = r70*r2;\n    float r74 = r72*", "\n    float L = exp(-d);\n    float k = 0.0;\n    float p = L;\n    float U1 = U.x;\n    while (U1 > p) {\n        k += 1.0;\n        p *= d / k;\n    }\n    return k;\n}\n\n// Poisson generator via Inverse transform sampling ( for large d ) https://en.wikipedia.org/wiki/Poisson_distribution#Generating_Poisson-distributed_random_variables\nfloat", "\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash2(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash3(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash4(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash5(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash6(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash7(uint n)\n{\n    n = (n << 13U) ^ n;\n    n = n * (n * n * 15731U + 789221U) + 1376312589U;\n    return n;\n}\n\nuint hash8(uint n)\n{\n    n = (n << 1", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = texture(iChannel0, uv).rgb;\n    col = pow(col, vec3(1.0/2.2));\n    fragColor = vec4(col, 1.0);\n}\n", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    if (uv.x < 0.5) {\n        col = vec3(0.0, 0.0, 1.0);\n    } else {\n        col = vec3(1.0, 0.0, 0.0);\n    }\n    fragColor = vec4(col, 1.0);\n}", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx)\n    );\n    return normalize(nor);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec2 res = map(ro + rd * t);\n        float d = res.x;\n        int m = int(res.y);\n        if (d < EPSILON || t > MAX_DISTANCE) break;\n        t += d;\n        if (m == SPHERE) {\n            col = vec3(1.0);\n        }\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    vec3 eps = vec3(0.001, 0.0, 0.0);\n    vec3 nor = vec3(\n        map(pos+eps.xyy) - map(pos-eps.xyy),\n        map(pos+eps.yxy) - map(pos-eps.yxy),\n        map(pos+eps.yyx) - map(pos-eps.yyx)\n    );\n    return normalize(nor);\n}\n\n// Compute normal vector to surface at pos, using central differences method?\nvec", "\n    vec3 col = vec3(0.0);\n    float t = 0.0;\n    for (int i = 0; i < MAX_STEPS; i++) {\n        vec2 res = map(ro + rd * t);\n        float d = res.x;\n        int m = int(res.y);\n        if (d < EPSILON || t > MAX_DISTANCE) break;\n        t += d;\n        if (m == SPHERE) {\n            col = vec3(1.0);\n        }\n    }\n    return col;\n}\n\nvoid main() {\n    vec2 uv = (gl_FragCoord.xy - 0.5 * u_resolution.xy) / u_resolution.y;\n    vec3 ro = vec3(0.0, 0.0, 0.0);\n    vec3 rd = normalize(vec3(uv.x, uv.y, 1.0));\n    vec3 col = render(ro, rd);\n    gl_FragColor = vec4(col, 1.0);\n}\n", "\n    return normalize(vec3(\n        sdf(vec3(p.x + EPSILON, p.yz)) - sdf(vec3(p.x - EPSILON, p.yz)),\n        sdf(vec3(p.xy + EPSILON, p.z)) - sdf(vec3(p.xy - EPSILON, p.z)),\n        sdf(vec3(p.xy, p.z + EPSILON)) - sdf(vec3(p.xy, p.z - EPSILON))\n    ));\n}\n\n/**\n * Using the gradient of the SDF, estimate the normal on the surface at point p.\n * This is a faster version of estimateNormal that does not normalize the result.\n */\nvec", "\n    return fract(sin(dot(q,ivec2(127.1,311.7)))*43758.5453);\n}\n\n// random hash via https://www.shadertoy.com/view/3d2GRh\nfloat", "\n    if ( i == 0 ) {\n        color = vec3( 0.6, 0.6, 0.6 );\n        return true;\n    }\n    if ( i == 1 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 2 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 3 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 4 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 5 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 6 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 7 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 8 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 9 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 10 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 11 ) {\n        color = vec3( 0.9, 0.9, 0.9 );\n        return true;\n    }\n    if ( i == 12 ) {\n        color = vec3( 0.9, 0.9, 0", "\n    p = p*2.0 - 1.0;\n    vec2 p2 = p*p;\n    vec2 p4 = p2*p2;\n    vec2 p8 = p4*p4;\n    vec2 p16 = p8*p8;\n    vec2 p32 = p16*p16;\n    vec2 p64 = p32*p32;\n    vec2 p128 = p64*p64;\n    vec2 p256 = p128*p128;\n    vec2 p512 = p256*p256;\n    vec2 p1024 = p512*p512;\n    vec2 p2048 = p1024*p1024;\n    vec2 p4096 = p2048*p2048;\n    vec2 p8192 = p4096*p4096;\n    vec2 p16384 = p8192*p8192;\n    vec2 p32768 = p16384*p16384;\n    vec2 p65536 = p32768*p32768;\n    vec2 p131072 = p65536*p65536;\n    vec2 p262144 = p131072*p131072;\n    vec2 p524288 = p262144*p262144;\n    vec2 p1048576 = p524288*p524288;\n    vec2 p2097152 = p1048576*p1048576;\n    vec2 p4194304 = p2097152*p2097152;\n    vec2", "\n    vec3 p3 = fract(vec3(p) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n//  4 out, 1 in...\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = length(uv - 0.5);\n    float a = atan(uv.y - 0.5, uv.x - 0.5);\n    float d = abs(r - 0.5);\n    float f = sin(a * 10.0 + t * 10.0) * 0.5 + 0.5;\n    float g = sin(a * 10.0 + t * 10.0) * 0.5 + 0.5;\n    float b = sin(a * 10.0 + t * 10.0) * 0.5 + 0.5;\n    col = vec3(f, g, b);\n    fragColor = vec4(col, 1.0);\n}", "\n    float d = length(raypos.xyz);\n    float r = hypersphereRadius;\n    float d2 = d*d;\n    float r2 = r*r;\n    float d2r2 = d2-r2;\n    float d2r2_2 = d2r2*d2r2;\n    float d2r2_3 = d2r2_2*d2r2;\n    float d2r2_4 = d2r2_3*d2r2;\n    float d2r2_5 = d2r2_4*d2r2;\n    float d2r2_6 = d2r2_5*d2r2;\n    float d2r2_7 = d2r2_6*d2r2;\n    float d2r2_8 = d2r2_7*d2r2;\n    float d2r2_9 = d2r2_8*d2r2;\n    float d2r2_10 = d2r2_9*d2r2;\n    float d2r2_11 = d2r2_10*d2r2;\n    float d2r2_12 = d2r2_11*d2r2;\n    float d2r2_13 = d2r2_12*d2r2;\n    float d2r2_14 = d2r2_13*d2r2;\n    float d2r2_15 = d2r2_14*d2r2;\n    float d2r2_16 = d2r2_15*d2r2;\n    float d2r2_17 = d2r2_16*d2r2;\n    float d2r2_18 = d2r2_17*d2r2;\n    float d2r2_19 = d2r2_18*d2r2;\n    float d2r2_20 = d2r2_19*d2r2;\n    float d2r2_21 = d2r2_", "\n    float cx = cos(rotation.x);\n    float sx = sin(rotation.x);\n    float cy = cos(rotation.y);\n    float sy = sin(rotation.y);\n    float cz = cos(rotation.z);\n    float sz = sin(rotation.z);\n    return mat3(\n        cy*cz, sx*sy*cz - cx*sz, cx*sy*cz + sx*sz,\n        cy*sz, sx*sy*sz + cx*cz, cx*sy*sz - sx*cz,\n        -sy, sx*cy, cx*cy\n    );\n}\n\n// Rotation Matrix from LoicVDB\nmat", "\n    float t = 0.0;\n    float d = 0.0;\n    float m = 0.0;\n    for(int i = 0; i < MAX_STEPS; i++){\n        vec4 pos = rayori + raydir * t;\n        d = map(pos);\n        m = d;\n        t += d;\n        if(d < MIN_DIST || t > MAX_DIST) break;\n    }\n    return vec3(t, m, 0.0);\n}\n\n// 3D Ray-Marching\nvec", "\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float t2 = t*t;\n    float t3 = t2*t;\n    float t4 = t3*t;\n    float t5 = t4*t;\n    float t6 = t5*t;\n    float t7 = t6*t;\n    float t8 = t7*t;\n    float t9 = t8*t;\n    float t10 = t9*t;\n    float t11 = t10*t;\n    float t12 = t11*t;\n    float t13 = t12*t;\n    float t14 = t13*t;\n    float t15 = t14*t;\n    float t16 = t15*t;\n    float t17 = t16*t;\n    float t18 = t17*t;\n    float t19 = t18*t;\n    float t20 = t19*t;\n    float t21 = t20*t;\n    float t22 = t21*t;\n    float t23 = t22*t;\n    float t24 = t23*t;\n    float t25 = t24*t;\n    float t26 = t25*t;\n    float t27 = t26*t;\n    float t28 = t27*t;\n    float t29 = t28*t;\n    float t30 = t29*t;\n    float t31 = t30*t;\n    float t32 = t31*t;\n    float t33 = t32*t;\n    float t34 = t33*t;\n    float t35 = t34*t;\n    float t36 = t35*t;\n    float t37 = t36*t;\n    float t38 = t37*t;\n    float t39 = t38*t;\n    float t40 = t39*t;", "\n    float t = 0.0;\n    float d = 0.0;\n    for(int i = 0; i < 100; i++){\n        d = map(rayori + raydir * t);\n        if(d < 0.001){\n            break;\n        }\n        t += d;\n    }\n    return vec3(t, d, 0.0);\n}\n\n// 3D Raymarching\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    col = texture(iChannel0, uv).rgb;\n    fragColor = vec4(col, 1.0);\n}", "\n    float x = coord.x * frequency;\n    float y = coord.y * frequency;\n    float xOffset = travelRate * frequency;\n    float yOffset = travelRate * frequency;\n    float xValue = sin(x + xOffset) * maxStrength;\n    float yValue = sin(y + yOffset) * maxStrength;\n    return xValue + yValue;\n}\n\n// coord: (texture coordinate: [0-1], [0-1])\n// frequency: rate at which ray appears\n// travel rate: direction the ray travels in the x directions\n// max strength: light intensity of the ray\nfloat", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    \n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // -----------------------------------------------\n    // --------------------------------------------", "\n    vec2 p1 = p - d;\n    vec2 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec2(p1.x, p2.y);\n    e3 = p2 - vec2(p2.x, p1.y);\n    e4 = p2 - vec2(p1.x, p1.y);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec3 p, vec3 d, inout vec3 e1, inout vec3 e2, inout vec3 e3, inout vec3 e4) {\n    vec3 p1 = p - d;\n    vec3 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec3(p1.x, p2.y, p1.z);\n    e3 = p2 - vec3(p2.x, p1.y, p1.z);\n    e4 = p2 - vec3(p1.x, p1.y, p2.z);\n}\n\n//returns the vectors pointing to each edge of the box with dimensions d,\n//ordered by closeness to the point p. only valid inside the rectangle\nvoid edge4(vec4 p, vec4 d, inout vec4 e1, inout vec4 e2, inout vec4 e3, inout vec4 e4) {\n    vec4 p1 = p - d;\n    vec4 p2 = p + d;\n    e1 = p2 - p1;\n    e2 = p2 - vec4(p1.x, p2.y, p1.z, p1.w);\n    e3 = p2 - vec4(p2.x, p1.y, p1.z, p1.w);\n    e4 = p2 - vec4(p1.x, p1.y, p2.z, p1.w);", "\n    color = max(vec3(0.0), color - 0.004);\n    color = (color * (6.2 * color + 0.5)) / (color * (6.2 * color + 1.7) + 0.06);\n    return color;\n}\n\n// https://www.shadertoy.com/view/Xlf3Dl\nvec", "\n    vec2  ba = b - a;\n    float h = clamp( dot(p-a,ba)/dot(ba,ba), 0.0, 1.0 );\n    vec2  n = ba*h - (p-a);\n    float d = length(n)*sign(w1-w2) - w2;\n    float t = w1 - w2;\n    return  min( max(d,-t), min(d,0.0) ) + length(ba)*h;\n}\n\n// The arrow goes from a to b. It's thickness is w1. The arrow\n// head's thickness is w2.\nfloat", "\n    float d = length( uv - p );\n    float f = exp( -d * 10.0 );\n    return vec3( f, f, f );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3( 0.0 );\n    for( int i = 0; i < 10; i++ )\n    {\n        float t = float( i ) * 0.1;\n        vec2 p = vec2( sin( t ), cos( t ) ) * 0.5 + 0.5;\n        col += blob( uv, p );\n    }\n    fragColor = vec4( col, 1.0 );\n}\n", "\n    return vec3( 1.0 ) - smoothstep( falloff, falloff + 0.01, rnd );\n}\n\n/////////////////////////////////////////////////////////////\nvec", "\n    vec2 uv = fragCoord.xy / iResolution.xy;\n    vec3 col = vec3(0.0);\n    float t = iTime;\n    float r = length(uv-0.5);\n    float a = atan(uv.y-0.5,uv.x-0.5);\n    float d = abs(r-0.25);\n    float f = smoothstep(0.0,0.01,d);\n    float s = sin(a*10.0+t*10.0);\n    float c = cos(a*10.0+t*10.0);\n    float l = length(uv-vec2(0.5,0.5));\n    float a2 = atan(uv.y-0.5,uv.x-0.5);\n    float s2 = sin(a2*10.0+t*10.0);\n    float c2 = cos(a2*10.0+t*10.0);\n    float l2 = length(uv-vec2(0.5,0.5));\n    float a3 = atan(uv.y-0.5,uv.x-0.5);\n    float s3 = sin(a3*10.0+t*10.0);\n    float c3 = cos(a3*10.0+t*10.0);\n    float l3 = length(uv-vec2(0.5,0.5));\n    float a4 = atan(uv.y-0.5,uv.x-0.5);\n    float s4 = sin(a4*10.0+t*10.0);\n    float c4 = cos(a4*10.0+t*10.0);\n    float l4 = length(uv-vec2(0.5,0.5));\n    float a5 = atan(uv.y-0.5,uv.x-0.5);\n    float s5 = sin(a5*10.0+t*10.0);\n    float c5 = cos(a5*10", "\n    vec3 p3 = fract(vec3(p) * vec3(.1031,.1030,.0973));\n    p3 += dot(p3, p3.yxz+33.33);\n    return fract((p3.xxy+p3.yxx)*p3.zyx);\n}\n\n//----------------------------------------------------------------------------------------\n//  4 out, 1 in...\nvec", "\n    float x2 = x * x;\n    return x * (27.0f + x2) / (27.0f + 9.0f * x2);\n}\n\n// License: Unknown, author: Unknown, found: don't remember\nfloat", "\n    col = pow(clamp(col, 0.0, 1.0), vec3(0.4545));\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col * (0.69470 * col + 0.06670);\n    col = col", "\n    p = abs(p) - 0.5;\n    return length(max(p, 0.0)) + min(max(p.x, max(p.y, p.z)), 0.0);\n}\n\n/* \u4e00\u4e2a\u7403\u4f53\u7684SDF */\nfloat", "\n    // Normalized pixel coordinates (from 0 to 1)\n    vec2 uv = fragCoord/iResolution.xy;\n\n    // Time varying pixel color\n    vec3 col = vec3(0.0);\n\n    // circle radius\n    float r = 0.1;\n\n    // circle center\n    vec2 c = vec2(0.5, 0.5);\n\n    // circle color\n    vec3 circle_color = vec3(1.0, 0.0, 0.0);\n\n    // circle brightness\n    float circle_brightness = 0.0;\n\n    // circle radius change\n    float circle_radius_change = 0.0;\n\n    // circle radius change threshold\n    float circle_radius_change_threshold = 0.01;\n\n    // circle radius change rate\n    float circle_radius_change_rate = 0.01;\n\n    // circle radius change direction\n    float circle_radius_change_direction = 1.0;\n\n    // circle radius change direction threshold\n    float circle_radius_change_direction_threshold = 0.01;\n\n    // circle radius change direction rate\n    float circle_radius_change_direction_rate = 0.01;\n\n    // circle radius change direction direction\n    float circle_radius_change_direction_direction = 1.0;\n\n    // circle radius change direction direction threshold\n    float circle_radius_change_direction_direction_threshold = 0.01;\n\n    // circle radius change direction direction rate\n    float circle_radius_change_direction_direction_rate = 0.01;\n\n    // circle radius change direction direction direction\n    float circle_radius_change_direction_direction_direction = 1.0;\n\n    // circle radius change direction direction direction threshold\n    float circle_radius_change_direction_direction_direction_threshold = 0.01;\n\n    // circle radius change direction direction direction rate\n    float circle_radius_change_direction_direction_direction_rate = 0.01;\n\n    // circle radius change direction direction direction direction\n    float circle_radius_change_direction_direction_direction_direction = 1.0;\n\n"]}